

Set Implicit Arguments.



Notation "'exists' x1 ',' P" :=

  (exists x1, P)

  (at level 200, x1 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 ',' P" :=

  (exists x1, exists x2, P)

  (at level 200, x1 ident, x2 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 ',' P" :=

  (exists x1, exists x2, exists x3, P)

  (at level 200, x1 ident, x2 ident, x3 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 x5 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, exists x5, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, x5 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 x5 x6 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, exists x5, exists x6, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, x5 ident,

   x6 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 x5 x6 x7 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, exists x5, exists x6,

   exists x7, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, x5 ident,

   x6 ident, x7 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 x5 x6 x7 x8 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, exists x5, exists x6,

   exists x7, exists x8, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, x5 ident,

   x6 ident, x7 ident, x8 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 x5 x6 x7 x8 x9 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, exists x5, exists x6,

   exists x7, exists x8, exists x9, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, x5 ident,

   x6 ident, x7 ident, x8 ident, x9 ident,

   right associativity) : type_scope.

Notation "'exists' x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 ',' P" :=

  (exists x1, exists x2, exists x3, exists x4, exists x5, exists x6,

   exists x7, exists x8, exists x9, exists x10, P)

  (at level 200, x1 ident, x2 ident, x3 ident, x4 ident, x5 ident,

   x6 ident, x7 ident, x8 ident, x9 ident, x10 ident,

   right associativity) : type_scope.



Ltac idcont tt :=

  idtac.



Inductive Boxer : Type :=

  | boxer : forall (A:Type), A -> Boxer.



Inductive ltac_No_arg : Set :=

  | ltac_no_arg : ltac_No_arg.



Inductive ltac_Wild : Set :=

  | ltac_wild : ltac_Wild.



Notation "'__'" := ltac_wild : ltac_scope.



Inductive ltac_Wilds : Set :=

  | ltac_wilds : ltac_Wilds.



Notation "'___'" := ltac_wilds : ltac_scope.



Open Scope ltac_scope.



Inductive ltac_Mark : Type :=

  | ltac_mark : ltac_Mark.



Ltac gen_until_mark :=

  match goal with H: ?T |- _ =>

  match T with

  | ltac_Mark => clear H

  | _ => generalize H; clear H; gen_until_mark

  end end.



Ltac intro_until_mark :=

  match goal with

  | |- (ltac_Mark -> _) => intros _

  | _ => intro; intro_until_mark

  end.



Require Import List.
(* List:
Set Implicit Arguments.

Require Import FCF.FCF.

Local Open Scope nat_scope.

Theorem qam_count_gen : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S)(n : nat),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= n + (count x)) ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q * n + (count s).

Local Open Scope rat_scope.

Theorem evalDist_bind_event_le : 
  forall (A : Set)(c : Comp A)(f : A -> Comp bool)(evta : A -> bool) (k1 k2 : Rat),
    Pr[a <-$ c; ret (evta a)] <= k1 ->
    (forall a, In a (getSupport c) -> evta a = false -> Pr[f a] <= k2) ->
    Pr[a <-$ c; f a] <= k1 + k2.

Theorem oc_eventProb : 
  forall (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (count : S -> nat)(evt : S -> bool)(s : S)(k : nat -> Rat) i,
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (i + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= i + (count s))%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k (i * n + (count s))%nat).

Theorem oc_eventProb_0_1 : 
  forall (S : Set)(count : S -> nat)(evt : S -> bool)(k : nat -> Rat)
         (A B C : Set)(c : OracleComp A B C) n,
    queries_at_most c n ->
    forall
    (eqds : EqDec S)(o : S -> A -> Comp (B * S))
    (s : S),
      (forall (n1 n2 : nat), (n1 <= n2)%nat -> (k n1 <= k n2)) ->
      evt s = false ->
      (forall s a, evt s = false -> Pr[p <-$ o s a; ret (evt (snd p))] <= (k (1 + (count s))%nat)) ->
      (forall s s' a b, In (b, s') (getSupport (o s a)) ->
                        count s' <= 1 + (count s))%nat ->
      count s = 0%nat ->
      Pr[p <-$ c _ _ o s; ret (evt (snd p))] <= (n / 1) * (k n).  

Local Open Scope nat_scope.

Theorem qam_count : 
  forall (A B C : Set)(c : OracleComp A B C)(q : nat),
    queries_at_most c q ->
    forall (S : Set)(count : S -> nat)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b x y,
        In (a, b) (getSupport (o x y)) ->
          count b <= 1 + (count x)) ->
      count s = 0 ->
      forall a b, 
      In (a, b) (getSupport (c _ _ o s)) ->
      count b <= q.

Local Transparent evalDist.

Section RndInList.
  
  Variable eta : nat.

  Theorem RndInList_prob_h :
    forall (ls : list (Bvector eta)),
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.

  Theorem RndInList_prob :
    forall (ls : list (Bvector eta))(q : nat),
      length ls <= q ->
      (Pr[r <-$ {0, 1}^eta;
        ret (if (in_dec (EqDec_dec _) r ls) then true else false)
      ] <= q / 2 ^ eta)%rat.
  
End RndInList.

Local Open Scope rat_scope.

Theorem RndNat_eq_any : 
  forall (eta : nat)(x : Bvector eta),
    Pr  [a0 <-$ { 0 , 1 }^eta; ret (eqb x a0) ] == 1 / 2^eta.

Require Import FCF.CompFold.
Local Opaque evalDist.

Section FixedInRndList.
  
  Variable A : Set.
  Variable eta : nat.

  Theorem FixedInRndList_prob :
    forall (ls : list A)(x : Bvector eta),
      (Pr[lsR <-$ compMap _ (fun _ => {0, 1}^eta) ls; ret (if (in_dec (EqDec_dec _) x lsR) then true else false)
      ] <= (length ls) / 2 ^ eta)%rat.
  
End FixedInRndList.

Section RndInAdaptive.

  Variable A B C : Set.
  
  Local Open Scope rat_scope.

  Theorem orb_prob : 
    forall (A B : Set)(c : Comp A)(f : A -> Comp B) evt1 evt2 k1 k2,
      Pr[x <-$ c; ret (evt1 x)] <= k1 ->
      (forall a, In a (getSupport c) -> evt1 a = false -> Pr[y <-$ f a; ret (evt2 y)] <= k2) ->
      Pr[x <-$ c; y <-$ f x; ret (evt1 x || evt2 y)] <= k1 + k2.

  Theorem RndInAdaptive_prob : 
    forall (c : OracleComp A B C)(q : nat),
      queries_at_most c q ->
      forall (S : Set)(evt : S -> bool)(eqd : EqDec S)(o : S -> A -> Comp (B * S))(k : Rat),
        (forall a b, 
          evt a = false ->
          Pr[ d <-$ o a b; ret (evt (snd d))] <= k)->
        (forall a b x y,
          In (a, b) (getSupport (o x y)) -> evt x = true -> evt b = true) ->
        forall (s : S),
          evt s = false ->
          Pr[ d <-$ c _ _ o s; ret (evt (snd d))] <= q / 1 * k.

End RndInAdaptive. *)



Notation "'>>'" :=

  (@nil Boxer)

  (at level 0)

  : ltac_scope.

Notation "'>>' v1" :=

  ((boxer v1)::nil)

  (at level 0, v1 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2" :=

  ((boxer v1)::(boxer v2)::nil)

  (at level 0, v1 at level 0, v2 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7 v8" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::(boxer v8)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0,

   v8 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0,

   v8 at level 0, v9 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0,

   v8 at level 0, v9 at level 0, v10 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)

   ::(boxer v11)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0,

   v8 at level 0, v9 at level 0, v10 at level 0, v11 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)

   ::(boxer v11)::(boxer v12)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0,

   v8 at level 0, v9 at level 0, v10 at level 0, v11 at level 0,

   v12 at level 0)

  : ltac_scope.

Notation "'>>' v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13" :=

  ((boxer v1)::(boxer v2)::(boxer v3)::(boxer v4)::(boxer v5)

   ::(boxer v6)::(boxer v7)::(boxer v8)::(boxer v9)::(boxer v10)

   ::(boxer v11)::(boxer v12)::(boxer v13)::nil)

  (at level 0, v1 at level 0, v2 at level 0, v3 at level 0,

   v4 at level 0, v5 at level 0, v6 at level 0, v7 at level 0,

   v8 at level 0, v9 at level 0, v10 at level 0, v11 at level 0,

   v12 at level 0, v13 at level 0)

  : ltac_scope.



Ltac list_boxer_of E :=

  match type of E with

  | List.list Boxer => constr:(E)

  | _ => constr:((boxer E)::nil)

  end.



Definition ltac_database (D:Boxer) (T:Boxer) (A:Boxer) := True.



Notation "'Register' D T" := (ltac_database (boxer D) (boxer T) _)

  (at level 69, D at level 0, T at level 0).



Lemma ltac_database_provide : forall (A:Boxer) (D:Boxer) (T:Boxer),

  ltac_database D T A.

Proof. split. Qed.



Ltac Provide T := apply (@ltac_database_provide (boxer T)).



Ltac ltac_database_get D T :=

  let A := fresh "TEMP" in evar (A:Boxer);

  let H := fresh "TEMP" in

  assert (H : ltac_database (boxer D) (boxer T) A);

  [ subst A; auto

  | subst A; match type of H with ltac_database _ _ (boxer ?L) =>

               generalize L end; clear H ].



Definition rm (A:Type) (X:A) := X.



Ltac rm_term E :=

  let T := type of E in

  match goal with H: T |- _ => try clear H end.



Ltac rm_inside E :=

  let go E := rm_inside E in

  match E with

  | rm ?X => rm_term X

  | ?X1 ?X2 =>

     go X1; go X2

  | ?X1 ?X2 ?X3 =>

     go X1; go X2; go X3

  | ?X1 ?X2 ?X3 ?X4 =>

     go X1; go X2; go X3; go X4

  | ?X1 ?X2 ?X3 ?X4 ?X5 =>

     go X1; go X2; go X3; go X4; go X5

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 =>

     go X1; go X2; go X3; go X4; go X5; go X6

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 =>

     go X1; go X2; go X3; go X4; go X5; go X6; go X7

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X8 =>

     go X1; go X2; go X3; go X4; go X5; go X6; go X7; go X8

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X8 ?X9 =>

     go X1; go X2; go X3; go X4; go X5; go X6; go X7; go X8; go X9

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X8 ?X9 ?X10 =>

     go X1; go X2; go X3; go X4; go X5; go X6; go X7; go X8; go X9; go X10

  | _ => idtac

  end.



Ltac fast_rm_inside E :=

  rm_inside E.



Require Coq.NArith.BinPos Coq.ZArith.BinInt.



Definition ltac_nat_from_int (x:BinInt.Z) : nat :=

  match x with

  | BinInt.Z0 => 0%nat

  | BinInt.Zpos p => BinPos.nat_of_P p

  | BinInt.Zneg p => 0%nat

  end.



Ltac nat_from_number N :=

  match type of N with

  | nat => constr:(N)

  | BinInt.Z => let N' := constr:(ltac_nat_from_int N) in eval compute in N'

  end.



Tactic Notation "ltac_pattern" constr(E) "at" constr(K) :=

  match nat_from_number K with

  | 1 => pattern E at 1

  | 2 => pattern E at 2

  | 3 => pattern E at 3

  | 4 => pattern E at 4

  | 5 => pattern E at 5

  | 6 => pattern E at 6

  | 7 => pattern E at 7

  | 8 => pattern E at 8

  end.



Tactic Notation "ltac_pattern" constr(E) "at" constr(K) "in" hyp(H) :=

  match nat_from_number K with

  | 1 => pattern E at 1 in H

  | 2 => pattern E at 2 in H

  | 3 => pattern E at 3 in H

  | 4 => pattern E at 4 in H

  | 5 => pattern E at 5 in H

  | 6 => pattern E at 6 in H

  | 7 => pattern E at 7 in H

  | 8 => pattern E at 8 in H

  end.



Tactic Notation "show" tactic(tac) :=

  let R := tac in pose R.



Lemma dup_lemma : forall P, P -> P -> P.

Proof. auto. Qed.



Ltac dup_tactic N :=

  match nat_from_number N with

  | 0 => idtac

  | S 0 => idtac

  | S ?N' => apply dup_lemma; [ | dup_tactic N' ]

  end.



Tactic Notation "dup" constr(N) :=

  dup_tactic N.

Tactic Notation "dup" :=

  dup 2.



Ltac check_noevar M :=

  match M with M => idtac end.



Ltac check_noevar_hyp H := 

  let T := type of H in

  match type of H with T => idtac end.



Ltac check_noevar_goal := 

  match goal with |- ?G => match G with G => idtac end end.



Ltac get_last_hyp tt :=

  match goal with H: _ |- _ => constr:(H) end.



Definition ltac_tag_subst (A:Type) (x:A) := x.



Definition ltac_to_generalize (A:Type) (x:A) := x.



Ltac gen_to_generalize :=

  repeat match goal with

    H: ltac_to_generalize _ |- _ => generalize H; clear H end.



Ltac mark_to_generalize H :=

  let T := type of H in

  change T with (ltac_to_generalize T) in H.



Ltac get_head E :=

  match E with

  | ?P _ _ _ _ _ _ _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ _ => constr:(P)

  | ?P _ _ _ _ => constr:(P)

  | ?P _ _ _ => constr:(P)

  | ?P _ _ => constr:(P)

  | ?P _ => constr:(P)

  | ?P => constr:(P)

  end.



Ltac get_fun_arg E :=

  match E with

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X7 ?X => constr:((X1 X2 X3 X4 X5 X6,X))

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X6 ?X => constr:((X1 X2 X3 X4 X5,X))

  | ?X1 ?X2 ?X3 ?X4 ?X5 ?X => constr:((X1 X2 X3 X4,X))

  | ?X1 ?X2 ?X3 ?X4 ?X => constr:((X1 X2 X3,X))

  | ?X1 ?X2 ?X3 ?X => constr:((X1 X2,X))

  | ?X1 ?X2 ?X => constr:((X1,X))

  | ?X1 ?X => constr:((X1,X))

  end.



Tactic Notation "ltac_action_at" constr(K) "of" constr(E) "do" tactic(Tac) :=

  let p := fresh in ltac_pattern E at K;

  match goal with |- ?P _ => set (p:=P) end;

  Tac; unfold p; clear p.



Tactic Notation "ltac_action_at" constr(K) "of" constr(E) "in" hyp(H) "do" tactic(Tac) :=

  let p := fresh in ltac_pattern E at K in H;

  match type of H with ?P _ => set (p:=P) in H end;

  Tac; unfold p in H; clear p.



Tactic Notation "protects" constr(E) "do" tactic(Tac) :=

  

  let x := fresh "TEMP" in let H := fresh "TEMP" in

  set (X := E) in *; assert (H : X = E) by reflexivity;

  clearbody X; Tac; subst x.



Tactic Notation "protects" constr(E) "do" tactic(Tac) "/" :=

  protects E do Tac.



Definition eq' := @eq.



Hint Unfold eq'.



Notation "x '='' y" := (@eq' _ x y)

  (at level 70, arguments at next level).



Tactic Notation "rapply" constr(t) :=

  first  

  [ eexact (@t)

  | refine (@t)

  | refine (@t _)

  | refine (@t _ _)

  | refine (@t _ _ _)

  | refine (@t _ _ _ _)

  | refine (@t _ _ _ _ _)

  | refine (@t _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _ _ _ _ _ _)

  | refine (@t _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)

  ].



Tactic Notation "rapply_0" constr(t) :=

  refine (@t).

Tactic Notation "rapply_1" constr(t) :=

  refine (@t _).

Tactic Notation "rapply_2" constr(t) :=

  refine (@t _ _).

Tactic Notation "rapply_3" constr(t) :=

  refine (@t _ _ _).

Tactic Notation "rapply_4" constr(t) :=

  refine (@t _ _ _ _).

Tactic Notation "rapply_5" constr(t) :=

  refine (@t _ _ _ _ _).

Tactic Notation "rapply_6" constr(t) :=

  refine (@t _ _ _ _ _ _).

Tactic Notation "rapply_7" constr(t) :=

  refine (@t _ _ _ _ _ _ _).

Tactic Notation "rapply_8" constr(t) :=

  refine (@t _ _ _ _ _ _ _ _).

Tactic Notation "rapply_9" constr(t) :=

  refine (@t _ _ _ _ _ _ _ _ _).

Tactic Notation "rapply_10" constr(t) :=

  refine (@t _ _ _ _ _ _ _ _ _ _).



Ltac lets_base I E := generalize E; intros I.



Tactic Notation "applys_to" hyp(H) constr(E) :=

  let H' := fresh in rename H into H';

  (first [ lets_base H (E H')

         | lets_base H (E _ H')

         | lets_base H (E _ _ H')

         | lets_base H (E _ _ _ H')

         | lets_base H (E _ _ _ _ H')

         | lets_base H (E _ _ _ _ _ H')

         | lets_base H (E _ _ _ _ _ _ H')

         | lets_base H (E _ _ _ _ _ _ _ H')

         | lets_base H (E _ _ _ _ _ _ _ _ H')

         | lets_base H (E _ _ _ _ _ _ _ _ _ H') ]

  ); clear H'.



Tactic Notation "constructors" :=

  first [ constructor | econstructor ]; unfold eq'.



Tactic Notation "false_goal" :=

  elimtype False.



Ltac false_post :=

  solve [ assumption | discriminate | congruence ].



Tactic Notation "false" :=

  false_goal; try false_post.



Tactic Notation "tryfalse" :=

  try solve [ false ].



Tactic Notation "tryfalse" "by" tactic1(tac) "/" :=

  try solve [ false; instantiate; tac ].



Tactic Notation "false" constr(T) "by" tactic1(tac) "/" :=

  false_goal; first

    [ first [ apply T | eapply T | rapply T]; instantiate; tac  

    | let H := fresh in lets_base H T;

      first [ discriminate H  

            | false; instantiate; tac ] ].

   

Tactic Notation "false" constr(T) :=

  false T by idtac/.



Ltac false_invert_tactic :=

  match goal with H:_ |- _ =>

    solve [ inversion H

          | clear H; false_invert_tactic

          | fail 2 ] end.



Tactic Notation "false_invert" :=

  false_invert_tactic.



Tactic Notation "tryfalse_invert" :=

  try solve [ false | false_invert ].



Tactic Notation "asserts" simple_intropattern(I) ":" constr(T) :=

  let H := fresh in assert (H : T);

  [ | generalize H; clear H; intros I ].



Tactic Notation "asserts" simple_intropattern(I1)

 simple_intropattern(I2) ":" constr(T) :=

  asserts [I1 I2]: T.

Tactic Notation "asserts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) ":" constr(T) :=

  asserts [I1 [I2 I3]]: T.

Tactic Notation "asserts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) ":" constr(T) :=

  asserts [I1 [I2 [I3 I4]]]: T.

Tactic Notation "asserts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) simple_intropattern(I5) ":" constr(T) :=

  asserts [I1 [I2 [I3 [I4 I5]]]]: T.

Tactic Notation "asserts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) ":" constr(T) :=

  asserts [I1 [I2 [I3 [I4 [I5 I6]]]]]: T.



Tactic Notation "asserts" ":" constr(T) :=

  let H := fresh in asserts H : T.



Tactic Notation "cuts" simple_intropattern(I) ":" constr(T) :=

  cut (T); [ intros I | idtac ].



Tactic Notation "cuts" ":" constr(T) :=

  let H := fresh in cuts H: T.



Tactic Notation "cuts" simple_intropattern(I1)

 simple_intropattern(I2) ":" constr(T) :=

  cuts [I1 I2]: T.

Tactic Notation "cuts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) ":" constr(T) :=

  cuts [I1 [I2 I3]]: T.

Tactic Notation "cuts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) ":" constr(T) :=

  cuts [I1 [I2 [I3 I4]]]: T.

Tactic Notation "cuts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) simple_intropattern(I5) ":" constr(T) :=

  cuts [I1 [I2 [I3 [I4 I5]]]]: T.

Tactic Notation "cuts" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) ":" constr(T) :=

  cuts [I1 [I2 [I3 [I4 [I5 I6]]]]]: T.



Ltac app_assert t P cont :=

  let H := fresh "TEMP" in

  assert (H : P); [ | cont(t H); clear H ].



Ltac app_evar t A cont :=

  let x := fresh "TEMP" in

  evar (x:A);

  let t' := constr:(t x) in

  let t'' := (eval unfold x in t') in

  subst x; cont t''.



Ltac app_arg t P v cont :=

  let H := fresh "TEMP" in

  assert (H : P); [ apply v | cont(t H); try clear H ].



Ltac build_app_alls t final :=

  let rec go t :=

    match type of t with

    | ?P -> ?Q => app_assert t P go

    | forall _:?A, _ => app_evar t A go

    | _ => final t

    end in

  go t.



Ltac boxerlist_next_type vs :=

  match vs with

  | nil => constr:(ltac_wild)

  | (boxer ltac_wild)::?vs' => boxerlist_next_type vs'

  | (boxer ltac_wilds)::_ => constr:(ltac_wild)

  | (@boxer ?T _)::_ => constr:(T)

  end.



Ltac build_app_hnts t vs final :=

  let rec go t vs :=

    match vs with

    | nil => first [ final t | fail 1 ]

    | (boxer ltac_wilds)::_ => first [ build_app_alls t final | fail 1 ]

    | (boxer ?v)::?vs' =>

      let cont t' := go t' vs in

      let cont' t' := go t' vs' in

      let T := type of t in

      let T := eval hnf in T in

      match v with

      | ltac_wild =>

         first [ let U := boxerlist_next_type vs' in

           match U with

           | ltac_wild =>

             match T with

             | ?P -> ?Q => first [ app_assert t P cont' | fail 3 ]

             | forall _:?A, _ => first [ app_evar t A cont' | fail 3 ]

             end

           | _ =>

             match T with  

             | U -> ?Q => first [ app_assert t U cont' | fail 3 ]

             | forall _:U, _ => first [ app_evar t U cont' | fail 3 ]

             | ?P -> ?Q => first [ app_assert t P cont | fail 3 ]

             | forall _:?A, _ => first [ app_evar t A cont | fail 3 ]

             end

           end

         | fail 2 ]

      | _ =>

          match T with

          | ?P -> ?Q => first [ app_arg t P v cont'

                              | app_assert t P cont

                              | fail 3 ]

          | forall _:?A, _ => first [ cont' (t v)

                                    | app_evar t A cont

                                    | fail 3 ]

          end

      end

    end in

  go t vs.



Ltac build_app args final :=

  first [

    match args with (@boxer ?T ?t)::?vs =>

      let t := constr:(t:T) in

      build_app_hnts t vs final

    end

  | fail 1 "Instantiation fails for:" args].



Ltac unfold_head_until_product T :=

  eval hnf in T.



Ltac args_unfold_head_if_not_product args :=

  match args with (@boxer ?T ?t)::?vs =>

    let T' := unfold_head_until_product T in

    constr:((@boxer T' t)::vs)

  end.



Ltac args_unfold_head_if_not_product_but_params args :=

  match args with

  | (boxer ?t)::(boxer ?v)::?vs =>

     args_unfold_head_if_not_product args

  | _ => constr:(args)

  end.



Ltac lets_build I Ei :=

  let args := list_boxer_of Ei in

  let args := args_unfold_head_if_not_product_but_params args in



  build_app args ltac:(fun R => lets_base I R).



Tactic Notation "lets" simple_intropattern(I) ":" constr(E) :=

  lets_build I E; fast_rm_inside E.

Tactic Notation "lets" ":" constr(E) :=

  let H := fresh in lets H: E.

Tactic Notation "lets" ":" constr(E0)

 constr(A1) :=

  lets: (>> E0 A1).

Tactic Notation "lets" ":" constr(E0)

 constr(A1) constr(A2) :=

  lets: (>> E0 A1 A2).

Tactic Notation "lets" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets: (>> E0 A1 A2 A3).

Tactic Notation "lets" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets: (>> E0 A1 A2 A3 A4).

Tactic Notation "lets" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets: (>> E0 A1 A2 A3 A4 A5).



Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2)

 ":" constr(E) :=

  lets [I1 I2]: E.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) ":" constr(E) :=

  lets [I1 [I2 I3]]: E.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) ":" constr(E) :=

  lets [I1 [I2 [I3 I4]]]: E.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 ":" constr(E) :=

  lets [I1 [I2 [I3 [I4 I5]]]]: E.



Tactic Notation "lets" simple_intropattern(I) ":" constr(E0)

 constr(A1) :=

  lets I: (>> E0 A1).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) :=

  lets I: (>> E0 A1 A2).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets I: (>> E0 A1 A2 A3).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets I: (>> E0 A1 A2 A3 A4).

Tactic Notation "lets" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets I: (>> E0 A1 A2 A3 A4 A5).



Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2) ":" constr(E0)

 constr(A1) :=

  lets [I1 I2]: E0 A1.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2) ":" constr(E0)

 constr(A1) constr(A2) :=

  lets [I1 I2]: E0 A1 A2.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets [I1 I2]: E0 A1 A2 A3.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets [I1 I2]: E0 A1 A2 A3 A4.

Tactic Notation "lets" simple_intropattern(I1) simple_intropattern(I2) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets [I1 I2]: E0 A1 A2 A3 A4 A5.



Ltac forwards_build_app_arg Ei :=

  let args := list_boxer_of Ei in

  let args := (eval simpl in (args ++ ((boxer ___)::nil))) in

  let args := args_unfold_head_if_not_product args in

  args.



Ltac forwards_then Ei cont :=

  let args := forwards_build_app_arg Ei in

  let args := args_unfold_head_if_not_product_but_params args in

  build_app args cont.



Tactic Notation "forwards" simple_intropattern(I) ":" constr(Ei) :=

  let args := forwards_build_app_arg Ei in

  lets I: args.



Tactic Notation "forwards" ":" constr(E) :=

  let H := fresh in forwards H: E.

Tactic Notation "forwards" ":" constr(E0)

 constr(A1) :=

  forwards: (>> E0 A1).

Tactic Notation "forwards" ":" constr(E0)

 constr(A1) constr(A2) :=

  forwards: (>> E0 A1 A2).

Tactic Notation "forwards" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  forwards: (>> E0 A1 A2 A3).

Tactic Notation "forwards" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  forwards: (>> E0 A1 A2 A3 A4).

Tactic Notation "forwards" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  forwards: (>> E0 A1 A2 A3 A4 A5).



Tactic Notation "forwards" simple_intropattern(I1) simple_intropattern(I2)

 ":" constr(E) :=

  forwards [I1 I2]: E.

Tactic Notation "forwards" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) ":" constr(E) :=

  forwards [I1 [I2 I3]]: E.

Tactic Notation "forwards" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) ":" constr(E) :=

  forwards [I1 [I2 [I3 I4]]]: E.

Tactic Notation "forwards" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 ":" constr(E) :=

  forwards [I1 [I2 [I3 [I4 I5]]]]: E.



Tactic Notation "forwards" simple_intropattern(I) ":" constr(E0)

 constr(A1) :=

  forwards I: (>> E0 A1).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) :=

  forwards I: (>> E0 A1 A2).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  forwards I: (>> E0 A1 A2 A3).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  forwards I: (>> E0 A1 A2 A3 A4).

Tactic Notation "forwards" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  forwards I: (>> E0 A1 A2 A3 A4 A5).



Tactic Notation "forwards_nounfold" simple_intropattern(I) ":" constr(Ei) :=

  let args := list_boxer_of Ei in

  let args := (eval simpl in (args ++ ((boxer ___)::nil))) in

  build_app args ltac:(fun R => lets_base I R);

  fast_rm_inside Ei.



Ltac forwards_nounfold_then Ei cont :=

  let args := list_boxer_of Ei in

  let args := (eval simpl in (args ++ ((boxer ___)::nil))) in

  build_app args cont;

  fast_rm_inside Ei.



Ltac applys_build Ei :=

  let args := list_boxer_of Ei in

  let args := args_unfold_head_if_not_product_but_params args in

  build_app args ltac:(fun R =>

   first [ apply R | eapply R | rapply R ]).



Ltac applys_base E :=

  match type of E with

  | list Boxer => applys_build E

  | _ => first [ rapply E | applys_build E ]

  end; fast_rm_inside E.



Tactic Notation "applys" constr(E) :=

  applys_base E.

Tactic Notation "applys" constr(E0) constr(A1) :=

  applys (>> E0 A1).

Tactic Notation "applys" constr(E0) constr(A1) constr(A2) :=

  applys (>> E0 A1 A2).

Tactic Notation "applys" constr(E0) constr(A1) constr(A2) constr(A3) :=

  applys (>> E0 A1 A2 A3).

Tactic Notation "applys" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) :=

  applys (>> E0 A1 A2 A3 A4).

Tactic Notation "applys" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  applys (>> E0 A1 A2 A3 A4 A5).



Ltac fapplys_build Ei :=

  let args := list_boxer_of Ei in

  let args := (eval simpl in (args ++ ((boxer ___)::nil))) in

  let args := args_unfold_head_if_not_product_but_params args in

  build_app args ltac:(fun R => apply R).



Tactic Notation "fapplys" constr(E0) :=  

  match type of E0 with

  | list Boxer => fapplys_build E0

  | _ => fapplys_build (>> E0)

  end.

Tactic Notation "fapplys" constr(E0) constr(A1) :=

  fapplys (>> E0 A1).

Tactic Notation "fapplys" constr(E0) constr(A1) constr(A2) :=

  fapplys (>> E0 A1 A2).

Tactic Notation "fapplys" constr(E0) constr(A1) constr(A2) constr(A3) :=

  fapplys (>> E0 A1 A2 A3).

Tactic Notation "fapplys" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) :=

  fapplys (>> E0 A1 A2 A3 A4).

Tactic Notation "fapplys" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  fapplys (>> E0 A1 A2 A3 A4 A5).



Ltac specializes_build H Ei :=

  let H' := fresh "TEMP" in rename H into H';

  let args := list_boxer_of Ei in

  let args := constr:((boxer H')::args) in

  let args := args_unfold_head_if_not_product args in

  build_app args ltac:(fun R => lets H: R);

  clear H'.



Ltac specializes_base H Ei :=

  specializes_build H Ei; fast_rm_inside Ei.



Tactic Notation "specializes" hyp(H) :=

  specializes_base H (___).

Tactic Notation "specializes" hyp(H) constr(A) :=

  specializes_base H A.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) :=

  specializes H (>> A1 A2).

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) :=

  specializes H (>> A1 A2 A3).

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) constr(A4) :=

  specializes H (>> A1 A2 A3 A4).

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  specializes H (>> A1 A2 A3 A4 A5).



Tactic Notation "fapply" constr(E) :=

  let H := fresh in forwards H: E;

  first [ apply H | eapply H | rapply H | hnf; apply H

        | hnf; eapply H | applys H ].

   

Tactic Notation "sapply" constr(H) :=

  first [ apply H | eapply H | rapply H | applys H

        | hnf; apply H | hnf; eapply H | hnf; applys H

        | fapply H ].



Tactic Notation "lets_simpl" ident(H) ":" constr(E) :=

  lets H: E; simpl in H.



Tactic Notation "lets_hnf" ident(H) ":" constr(E) :=

  lets H: E; hnf in H.



Tactic Notation "lets_simpl" ":" constr(T) :=

  let H := fresh in lets_simpl H: T.



Tactic Notation "lets_hnf" ":" constr(T) :=

  let H := fresh in lets_hnf H: T.



Tactic Notation "put" ident(X) ":" constr(E) :=

  pose (X := E).

Tactic Notation "put" ":" constr(E) :=

  let X := fresh "X" in pose (X := E).



Ltac logic_base E cont :=

  assert (H:E); [ cont tt | eapply H; clear H ].



Tactic Notation "logic" constr(E) :=

  logic_base E ltac:(fun _ => tauto).



Section equatesLemma.

Variables

  (A0 A1 : Type)

  (A2 : forall (x1 : A1), Type)

  (A3 : forall (x1 : A1) (x2 : A2 x1), Type)

  (A4 : forall (x1 : A1) (x2 : A2 x1) (x3 : A3 x2), Type)

  (A5 : forall (x1 : A1) (x2 : A2 x1) (x3 : A3 x2) (x4 : A4 x3), Type)

  (A6 : forall (x1 : A1) (x2 : A2 x1) (x3 : A3 x2) (x4 : A4 x3) (x5 : A5 x4), Type).



Lemma equates_0 : forall (P Q:Prop),

  P -> P = Q -> Q.

Proof. intros. subst. auto. Qed.



Lemma equates_1 :

  forall (P:A0->Prop) x1 y1,

  P y1 -> x1 = y1 -> P x1.

Proof. intros. subst. auto. Qed.



Lemma equates_2 :

  forall y1 (P:A0->forall(x1:A1),Prop) x1 x2,

  P y1 x2 -> x1 = y1 -> P x1 x2.

Proof. intros. subst. auto. Qed.



Lemma equates_3 :

  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1),Prop) x1 x2 x3,

  P y1 x2 x3 -> x1 = y1 -> P x1 x2 x3.

Proof. intros. subst. auto. Qed.



Lemma equates_4 :

  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1)(x3:A3 x2),Prop) x1 x2 x3 x4,

  P y1 x2 x3 x4 -> x1 = y1 -> P x1 x2 x3 x4.

Proof. intros. subst. auto. Qed.



Lemma equates_5 :

  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1)(x3:A3 x2)(x4:A4 x3),Prop) x1 x2 x3 x4 x5,

  P y1 x2 x3 x4 x5 -> x1 = y1 -> P x1 x2 x3 x4 x5.

Proof. intros. subst. auto. Qed.



Lemma equates_6 :

  forall y1 (P:A0->forall(x1:A1)(x2:A2 x1)(x3:A3 x2)(x4:A4 x3)(x5:A5 x4),Prop)

  x1 x2 x3 x4 x5 x6,

  P y1 x2 x3 x4 x5 x6 -> x1 = y1 -> P x1 x2 x3 x4 x5 x6.

Proof. intros. subst. auto. Qed.



End equatesLemma.



Ltac equates_lemma n :=

  match nat_from_number n with

  | 0 => constr:(equates_0)

  | 1 => constr:(equates_1)

  | 2 => constr:(equates_2)

  | 3 => constr:(equates_3)

  | 4 => constr:(equates_4)

  | 5 => constr:(equates_5)

  | 6 => constr:(equates_6)

  end.



Ltac equates_one n :=

  let L := equates_lemma n in

  eapply L.



Ltac equates_several E cont :=

  let all_pos := match type of E with

    | List.list Boxer => constr:(E)

    | _ => constr:((boxer E)::nil)

    end in

  let rec go pos :=

     match pos with

     | nil => cont tt

     | (boxer ?n)::?pos' => equates_one n; [ instantiate; go pos' | ]

     end in

  go all_pos.



Tactic Notation "equates" constr(E) :=

  equates_several E ltac:(fun _ => idtac).

Tactic Notation "equates" constr(n1) constr(n2) :=

  equates (>> n1 n2).

Tactic Notation "equates" constr(n1) constr(n2) constr(n3) :=

  equates (>> n1 n2 n3).

Tactic Notation "equates" constr(n1) constr(n2) constr(n3) constr(n4) :=

  equates (>> n1 n2 n3 n4).



Tactic Notation "applys_eq" constr(H) constr(E) :=

  equates_several E ltac:(fun _ => sapply H).

Tactic Notation "applys_eq" constr(H) constr(n1) constr(n2) :=

  applys_eq H (>> n1 n2).

Tactic Notation "applys_eq" constr(H) constr(n1) constr(n2) constr(n3) :=

  applys_eq H (>> n1 n2 n3).

Tactic Notation "applys_eq" constr(H) constr(n1) constr(n2) constr(n3) constr(n4) :=

  applys_eq H (>> n1 n2 n3 n4).



Ltac introv_rec :=

  match goal with

  | |- ?P -> ?Q => idtac

  | |- forall _, _ => intro; introv_rec

  | |- _ => idtac

  end.



Ltac introv_noarg :=

  match goal with

  | |- ?P -> ?Q => idtac

  | |- forall _, _ => introv_rec

  | |- ?G => hnf;

     match goal with

     | |- ?P -> ?Q => idtac

     | |- forall _, _ => introv_rec

     end

  | |- _ => idtac

  end.



  Ltac introv_noarg_not_optimized :=

    intro; match goal with H:_|-_ => revert H end; introv_rec.



Ltac introv_arg H :=

  hnf; match goal with

  | |- ?P -> ?Q => intros H

  | |- forall _, _ => intro; introv_arg H

  end.



Tactic Notation "introv" :=

  introv_noarg.

Tactic Notation "introv" simple_intropattern(I1) :=

  introv_arg I1.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2) :=

  introv I1; introv I2.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) :=

  introv I1; introv I2 I3.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) :=

  introv I1; introv I2 I3 I4.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5) :=

  introv I1; introv I2 I3 I4 I5.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) :=

  introv I1; introv I2 I3 I4 I5 I6.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) simple_intropattern(I7) :=

  introv I1; introv I2 I3 I4 I5 I6 I7.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8) :=

  introv I1; introv I2 I3 I4 I5 I6 I7 I8.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)

 simple_intropattern(I9) :=

  introv I1; introv I2 I3 I4 I5 I6 I7 I8 I9.

Tactic Notation "introv" simple_intropattern(I1) simple_intropattern(I2)

 simple_intropattern(I3) simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) simple_intropattern(I7) simple_intropattern(I8)

 simple_intropattern(I9) simple_intropattern(I10) :=

  introv I1; introv I2 I3 I4 I5 I6 I7 I8 I9 I10.



Tactic Notation "intros_all" :=

  repeat intro.



Tactic Notation "intro_hnf" :=

  intro; match goal with H: _ |- _ => hnf in H end.



Tactic Notation "gen" ident(X1) :=

  generalize dependent X1.

Tactic Notation "gen" ident(X1) ident(X2) :=

  gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) :=

  gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4)  :=

  gen X4; gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5) :=

  gen X5; gen X4; gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)

 ident(X6) :=

  gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)

 ident(X6) ident(X7) :=

  gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)

 ident(X6) ident(X7) ident(X8) :=

  gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)

 ident(X6) ident(X7) ident(X8) ident(X9) :=

  gen X9; gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.

Tactic Notation "gen" ident(X1) ident(X2) ident(X3) ident(X4) ident(X5)

 ident(X6) ident(X7) ident(X8) ident(X9) ident(X10) :=

  gen X10; gen X9; gen X8; gen X7; gen X6; gen X5; gen X4; gen X3; gen X2; gen X1.



Tactic Notation "generalizes" hyp(X) :=

  generalize X; clear X.

Tactic Notation "generalizes" hyp(X1) hyp(X2) :=

  generalizes X1; generalizes X2.

Tactic Notation "generalizes" hyp(X1) hyp(X2) hyp(X3) :=

  generalizes X1 X2; generalizes X3.

Tactic Notation "generalizes" hyp(X1) hyp(X2) hyp(X3) hyp(X4) :=

  generalizes X1 X2 X3; generalizes X4.



Tactic Notation "sets" ident(X) ":" constr(E) :=

  set (X := E) in *.



Ltac def_to_eq X HX E :=

  assert (HX : X = E) by reflexivity; clearbody X.

Ltac def_to_eq_sym X HX E :=

  assert (HX : E = X) by reflexivity; clearbody X.



Tactic Notation "set_eq" ident(X) ident(HX) ":" constr(E) :=

  set (X := E); def_to_eq X HX E.

Tactic Notation "set_eq" ident(X) ":" constr(E) :=

  let HX := fresh "EQ" X in set_eq X HX: E.

Tactic Notation "set_eq" ":" constr(E) :=

  let X := fresh "X" in set_eq X: E.



Tactic Notation "set_eq" "<-" ident(X) ident(HX) ":" constr(E) :=

  set (X := E); def_to_eq_sym X HX E.

Tactic Notation "set_eq" "<-" ident(X) ":" constr(E) :=

  let HX := fresh "EQ" X in set_eq <- X HX: E.

Tactic Notation "set_eq" "<-" ":" constr(E) :=

  let X := fresh "X" in set_eq <- X: E.



Tactic Notation "sets_eq" ident(X) ident(HX) ":" constr(E) :=

  set (X := E) in *; def_to_eq X HX E.

Tactic Notation "sets_eq" ident(X) ":" constr(E) :=

  let HX := fresh "EQ" X in sets_eq X HX: E.

Tactic Notation "sets_eq" ":" constr(E) :=

  let X := fresh "X" in sets_eq X: E.



Tactic Notation "sets_eq" "<-" ident(X) ident(HX) ":" constr(E) :=

  set (X := E) in *; def_to_eq_sym X HX E.

Tactic Notation "sets_eq" "<-" ident(X) ":" constr(E) :=

  let HX := fresh "EQ" X in sets_eq <- X HX: E.

Tactic Notation "sets_eq" "<-" ":" constr(E) :=

  let X := fresh "X" in sets_eq <- X: E.



Tactic Notation "set_eq" ident(X) ident(HX) ":" constr(E) "in" hyp(H) :=

  set (X := E) in H; def_to_eq X HX E.

Tactic Notation "set_eq" ident(X) ":" constr(E) "in" hyp(H) :=

  let HX := fresh "EQ" X in set_eq X HX: E in H.

Tactic Notation "set_eq" ":" constr(E) "in" hyp(H) :=

  let X := fresh "X" in set_eq X: E in H.



Tactic Notation "set_eq" "<-" ident(X) ident(HX) ":" constr(E) "in" hyp(H) :=

  set (X := E) in H; def_to_eq_sym X HX E.

Tactic Notation "set_eq" "<-" ident(X) ":" constr(E) "in" hyp(H) :=

  let HX := fresh "EQ" X in set_eq <- X HX: E in H.

Tactic Notation "set_eq" "<-" ":" constr(E) "in" hyp(H) :=

  let X := fresh "X" in set_eq <- X: E in H.



Tactic Notation "set_eq" ident(X) ident(HX) ":" constr(E) "in" "|-" :=

  set (X := E) in |-; def_to_eq X HX E.

Tactic Notation "set_eq" ident(X) ":" constr(E) "in" "|-" :=

  let HX := fresh "EQ" X in set_eq X HX: E in |-.

Tactic Notation "set_eq" ":" constr(E) "in" "|-" :=

  let X := fresh "X" in set_eq X: E in |-.



Tactic Notation "set_eq" "<-" ident(X) ident(HX) ":" constr(E) "in" "|-" :=

  set (X := E) in |-; def_to_eq_sym X HX E.

Tactic Notation "set_eq" "<-" ident(X) ":" constr(E) "in" "|-" :=

  let HX := fresh "EQ" X in set_eq <- X HX: E in |-.

Tactic Notation "set_eq" "<-" ":" constr(E) "in" "|-" :=

  let X := fresh "X" in set_eq <- X: E in |-.



Tactic Notation "gen_eq" ident(X) ":" constr(E) :=

  let EQ := fresh in sets_eq X EQ: E; revert EQ.

Tactic Notation "gen_eq" ":" constr(E) :=

  let X := fresh "X" in gen_eq X: E.

Tactic Notation "gen_eq" ":" constr(E) "as" ident(X) :=

  gen_eq X: E.

Tactic Notation "gen_eq" ident(X1) ":" constr(E1) ","

  ident(X2) ":" constr(E2) :=

  gen_eq X2: E2; gen_eq X1: E1.

Tactic Notation "gen_eq" ident(X1) ":" constr(E1) ","

  ident(X2) ":" constr(E2) "," ident(X3) ":" constr(E3) :=

  gen_eq X3: E3; gen_eq X2: E2; gen_eq X1: E1.



Ltac sets_let_base tac :=

  match goal with

  | |- context[let _ := ?E in _] => tac E; cbv zeta

  | H: context[let _ := ?E in _] |- _ => tac E; cbv zeta in H

  end.



Ltac sets_let_in_base H tac :=

  match type of H with context[let _ := ?E in _] =>

    tac E; cbv zeta in H end.



Tactic Notation "sets_let" ident(X) :=

  sets_let_base ltac:(fun E => sets X: E).

Tactic Notation "sets_let" ident(X) "in" hyp(H) :=

  sets_let_in_base H ltac:(fun E => sets X: E).

Tactic Notation "sets_eq_let" ident(X) :=

  sets_let_base ltac:(fun E => sets_eq X: E).

Tactic Notation "sets_eq_let" ident(X) "in" hyp(H) :=

  sets_let_in_base H ltac:(fun E => sets_eq X: E).



Tactic Notation "rewrite_all" constr(E) :=

  repeat rewrite E.

Tactic Notation "rewrite_all" "<-" constr(E) :=

  repeat rewrite <- E.

Tactic Notation "rewrite_all" constr(E) "in" ident(H) :=

  repeat rewrite E in H.

Tactic Notation "rewrite_all" "<-" constr(E) "in" ident(H) :=

  repeat rewrite <- E in H.

Tactic Notation "rewrite_all" constr(E) "in" "*" :=

  repeat rewrite E in *.

Tactic Notation "rewrite_all" "<-" constr(E) "in" "*" :=

  repeat rewrite <- E in *.



Ltac asserts_rewrite_tactic E action :=

  let EQ := fresh in (assert (EQ : E);

  [ idtac | action EQ; clear EQ ]).



Tactic Notation "asserts_rewrite" constr(E) :=

  asserts_rewrite_tactic E ltac:(fun EQ => rewrite EQ).

Tactic Notation "asserts_rewrite" "<-" constr(E) :=

  asserts_rewrite_tactic E ltac:(fun EQ => rewrite <- EQ).

Tactic Notation "asserts_rewrite" constr(E) "in" hyp(H) :=

  asserts_rewrite_tactic E ltac:(fun EQ => rewrite EQ in H).

Tactic Notation "asserts_rewrite" "<-" constr(E) "in" hyp(H) :=

  asserts_rewrite_tactic E ltac:(fun EQ => rewrite <- EQ in H).



Ltac cuts_rewrite_tactic E action :=

  let EQ := fresh in (cuts EQ: E;

  [ action EQ; clear EQ | idtac ]).



Tactic Notation "cuts_rewrite" constr(E) :=

  cuts_rewrite_tactic E ltac:(fun EQ => rewrite EQ).

Tactic Notation "cuts_rewrite" "<-" constr(E) :=

  cuts_rewrite_tactic E ltac:(fun EQ => rewrite <- EQ).

Tactic Notation "cuts_rewrite" constr(E) "in" hyp(H) :=

  cuts_rewrite_tactic E ltac:(fun EQ => rewrite EQ in H).

Tactic Notation "cuts_rewrite" "<-" constr(E) "in" hyp(H) :=

  cuts_rewrite_tactic E ltac:(fun EQ => rewrite <- EQ in H).



Ltac rewrite_except H EQ :=

  let K := fresh in let T := type of H in

  set (K := T) in H;

  rewrite EQ in *; unfold K in H; clear K.



Tactic Notation "rewrites" constr(E) "at" constr(K) :=

  match type of E with ?T1 = ?T2 =>

    ltac_action_at K of T1 do (rewrite E) end.

Tactic Notation "rewrites" "<-" constr(E) "at" constr(K) :=

  match type of E with ?T1 = ?T2 =>

    ltac_action_at K of T2 do (rewrite <- E) end.

Tactic Notation "rewrites" constr(E) "at" constr(K) "in" hyp(H) :=

  match type of E with ?T1 = ?T2 =>

    ltac_action_at K of T1 in H do (rewrite E in H) end.

Tactic Notation "rewrites" "<-" constr(E) "at" constr(K) "in" hyp(H) :=

  match type of E with ?T1 = ?T2 =>

    ltac_action_at K of T2 in H do (rewrite <- E in H) end.



Tactic Notation "replaces" constr(E) "with" constr(F) :=

  let T := fresh in assert (T: E = F); [ | replace E with F; clear T ].



Tactic Notation "replaces" constr(E) "with" constr(F) "in" hyp(H) :=

  let T := fresh in assert (T: E = F); [ | replace E with F in H; clear T ].



Tactic Notation "replaces" constr(E) "at" constr(K) "with" constr(F) :=

  let T := fresh in assert (T: E = F); [ | rewrites T at K; clear T ].



Tactic Notation "replaces" constr(E) "at" constr(K) "with" constr(F) "in" hyp(H) :=

  let T := fresh in assert (T: E = F); [ | rewrites T at K in H; clear T ].



Tactic Notation "renames" ident(X1) "to" ident(Y1) :=

  rename X1 into Y1.

Tactic Notation "renames" ident(X1) "to" ident(Y1) ","

 ident(X2) "to" ident(Y2) :=

  renames X1 to Y1; renames X2 to Y2.

Tactic Notation "renames" ident(X1) "to" ident(Y1) ","

 ident(X2) "to" ident(Y2) "," ident(X3) "to" ident(Y3) :=

  renames X1 to Y1; renames X2 to Y2, X3 to Y3.

Tactic Notation "renames" ident(X1) "to" ident(Y1) ","

 ident(X2) "to" ident(Y2) "," ident(X3) "to" ident(Y3) ","

 ident(X4) "to" ident(Y4) :=

  renames X1 to Y1; renames X2 to Y2, X3 to Y3, X4 to Y4.

Tactic Notation "renames" ident(X1) "to" ident(Y1) ","

 ident(X2) "to" ident(Y2) "," ident(X3) "to" ident(Y3) ","

 ident(X4) "to" ident(Y4) "," ident(X5) "to" ident(Y5) :=

  renames X1 to Y1; renames X2 to Y2, X3 to Y3, X4 to Y4, X5 to Y5.

Tactic Notation "renames" ident(X1) "to" ident(Y1) ","

 ident(X2) "to" ident(Y2) "," ident(X3) "to" ident(Y3) ","

 ident(X4) "to" ident(Y4) "," ident(X5) "to" ident(Y5) ","

 ident(X6) "to" ident(Y6) :=

  renames X1 to Y1; renames X2 to Y2, X3 to Y3, X4 to Y4, X5 to Y5, X6 to Y6.



Ltac apply_to_head_of E cont :=

  let go E :=

    let P := get_head E in cont P in

  match E with

  | forall _,_ => intros; apply_to_head_of E cont

  | ?A = ?B => first [ go A | go B ]

  | ?A => go A

  end.



Ltac unfolds_base :=

  match goal with |- ?G =>

   apply_to_head_of G ltac:(fun P => unfold P) end.



Tactic Notation "unfolds" :=

  unfolds_base.



Ltac unfolds_in_base H :=

  match type of H with ?G =>

   apply_to_head_of G ltac:(fun P => unfold P in H) end.



Tactic Notation "unfolds" "in" hyp(H) :=

  unfolds_in_base H.



Tactic Notation "unfolds" reference(F1) :=

  unfold F1 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2) :=

  unfold F1,F2 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2)

 "," reference(F3) :=

  unfold F1,F2,F3 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2)

 "," reference(F3) "," reference(F4) :=

  unfold F1,F2,F3,F4 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2)

 "," reference(F3) "," reference(F4) "," reference(F5) :=

  unfold F1,F2,F3,F4,F5 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2)

 "," reference(F3) "," reference(F4) "," reference(F5) "," reference(F6) :=

  unfold F1,F2,F3,F4,F5,F6 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2)

 "," reference(F3) "," reference(F4) "," reference(F5)

 "," reference(F6) "," reference(F7) :=

  unfold F1,F2,F3,F4,F5,F6,F7 in *.

Tactic Notation "unfolds" reference(F1) "," reference(F2)

 "," reference(F3) "," reference(F4) "," reference(F5)

 "," reference(F6) "," reference(F7) "," reference(F8) :=

  unfold F1,F2,F3,F4,F5,F6,F7,F8 in *.



Tactic Notation "folds" constr(H) :=

  fold H in *.

Tactic Notation "folds" constr(H1) "," constr(H2) :=

  folds H1; folds H2.

Tactic Notation "folds" constr(H1) "," constr(H2) "," constr(H3) :=

  folds H1; folds H2; folds H3.

Tactic Notation "folds" constr(H1) "," constr(H2) "," constr(H3)

 "," constr(H4) :=

  folds H1; folds H2; folds H3; folds H4.

Tactic Notation "folds" constr(H1) "," constr(H2) "," constr(H3)

 "," constr(H4) "," constr(H5) :=

  folds H1; folds H2; folds H3; folds H4; folds H5.



Tactic Notation "simpls" :=

  simpl in *.



Tactic Notation "simpls" reference(F1) :=

  simpl F1 in *.

Tactic Notation "simpls" reference(F1) "," reference(F2) :=

  simpls F1; simpls F2.

Tactic Notation "simpls" reference(F1) "," reference(F2)

 "," reference(F3) :=

  simpls F1; simpls F2; simpls F3.

Tactic Notation "simpls" reference(F1) "," reference(F2)

 "," reference(F3) "," reference(F4) :=

  simpls F1; simpls F2; simpls F3; simpls F4.



Tactic Notation "unsimpl" constr(E) :=

  let F := (eval simpl in E) in change F with E.



Tactic Notation "unsimpl" constr(E) "in" hyp(H) :=

  let F := (eval simpl in E) in change F with E in H.



Tactic Notation "unsimpl" constr(E) "in" "*" :=

  let F := (eval simpl in E) in change F with E in *.

Tactic Notation "unsimpls" constr(E) :=

  unsimpl E in *.



Notation "'nosimpl' t" := (match tt with tt => t end)

  (at level 10).



Tactic Notation "hnfs" := hnf in *.



Tactic Notation "substs" :=

  repeat (match goal with H: ?x = ?y |- _ =>

            first [ subst x | subst y ] end).



Ltac substs_below limit :=

  match goal with H: ?T |- _ =>

  match T with

  | limit => idtac

  | ?x = ?y =>

    first [ subst x; substs_below limit

          | subst y; substs_below limit

          | generalizes H; substs_below limit; intro ]

  end end.



Tactic Notation "substs" "below" "body" constr(M) :=

  substs_below M.



Tactic Notation "substs" "below" hyp(H) :=

  match type of H with ?M => substs below body M end.



Ltac subst_hyp_base H :=

  match type of H with

  | ?x = ?y => first [ subst x | subst y ]

  end.



Tactic Notation "subst_hyp" hyp(H) := subst_hyp_base H.



Tactic Notation "intro_subst" :=

  let H := fresh "TEMP" in intros H; subst_hyp H.



Ltac subst_local :=

  repeat match goal with H:=_ |- _ => subst H end.



Ltac subst_eq_base E :=

  let H := fresh "TEMP" in lets H: E; subst_hyp H.



Tactic Notation "subst_eq" constr(E) :=

  subst_eq_base E.



Require Import ProofIrrelevance.



Ltac pi_rewrite_base E rewrite_tac :=

  let E' := fresh in let T := type of E in evar (E':T);

  rewrite_tac (@proof_irrelevance _ E E'); subst E'.



Tactic Notation "pi_rewrite" constr(E) :=

  pi_rewrite_base E ltac:(fun X => rewrite X).

Tactic Notation "pi_rewrite" constr(E) "in" hyp(H) :=

  pi_rewrite_base E ltac:(fun X => rewrite X in H).



Ltac fequal_base :=

  let go := f_equal; [ fequal_base | ] in

  match goal with

  | |- (_,_,_) = (_,_,_) => go

  | |- (_,_,_,_) = (_,_,_,_) => go

  | |- (_,_,_,_,_) = (_,_,_,_,_) => go

  | |- (_,_,_,_,_,_) = (_,_,_,_,_,_) => go

  | |- _ => f_equal

  end.



Tactic Notation "fequal" :=

  fequal_base.



Ltac fequal_post :=

  first [ reflexivity | congruence | apply proof_irrelevance | idtac ].



Tactic Notation "fequals" :=

  fequal; fequal_post.



Tactic Notation "fequals_rec" :=

  repeat (progress fequals).



Tactic Notation "invert" "keep" hyp(H) :=

  pose ltac_mark; inversion H; gen_until_mark.



Tactic Notation "invert" "keep" hyp(H) "as" simple_intropattern(I1) :=

  invert keep H; introv I1.

Tactic Notation "invert" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) :=

  invert keep H; introv I1 I2.

Tactic Notation "invert" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) :=

  invert keep H; introv I1 I2 I3.



Tactic Notation "invert" hyp(H) :=

  invert keep H; clear H.



Tactic Notation "invert_tactic" hyp(H) tactic(tac) :=

  let H' := fresh in rename H into H'; tac H'; clear H'.

Tactic Notation "invert" hyp(H) "as" simple_intropattern(I1) :=

  invert_tactic H (fun H => invert keep H as I1).

Tactic Notation "invert" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) :=

  invert_tactic H (fun H => invert keep H as I1 I2).

Tactic Notation "invert" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) :=

  invert_tactic H (fun H => invert keep H as I1 I2 I3).



Axiom inj_pair2 : forall (U : Type) (P : U -> Type) (p : U) (x y : P p),

       existT P p x = existT P p y -> x = y.



Ltac inverts_tactic H i1 i2 i3 i4 i5 i6 :=

  let rec go i1 i2 i3 i4 i5 i6 :=

    match goal with

    | |- (ltac_Mark -> _) => intros _

    | |- (?x = ?y -> _) => let H := fresh in intro H;

                           first [ subst x | subst y ];

                           go i1 i2 i3 i4 i5 i6

    | |- (existT ?P ?p ?x = existT ?P ?p ?y -> _) =>

         let H := fresh in intro H;

         generalize (@inj_pair2 _ P p x y H);

         clear H; go i1 i2 i3 i4 i5 i6

    | |- (?P -> ?Q) => i1; go i2 i3 i4 i5 i6 ltac:(intro)

    | |- (forall _, _) => intro; go i1 i2 i3 i4 i5 i6

    end in

  generalize ltac_mark; invert keep H; go i1 i2 i3 i4 i5 i6;

  unfold eq' in *.



Tactic Notation "inverts" "keep" hyp(H) :=

  inverts_tactic H ltac:(intro) ltac:(intro) ltac:(intro)

                   ltac:(intro) ltac:(intro) ltac:(intro).



Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I1) :=

  inverts_tactic H ltac:(intros I1)

   ltac:(intro) ltac:(intro) ltac:(intro) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) :=

  inverts_tactic H ltac:(intros I1) ltac:(intros I2)

   ltac:(intro) ltac:(intro) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) :=

  inverts_tactic H ltac:(intros I1) ltac:(intros I2) ltac:(intros I3)

   ltac:(intro) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4) :=

  inverts_tactic H ltac:(intros I1) ltac:(intros I2) ltac:(intros I3)

   ltac:(intros I4) ltac:(intro) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)

 simple_intropattern(I5) :=

  inverts_tactic H ltac:(intros I1) ltac:(intros I2) ltac:(intros I3)

   ltac:(intros I4) ltac:(intros I5) ltac:(intro).

Tactic Notation "inverts" "keep" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)

 simple_intropattern(I5) simple_intropattern(I6) :=

  inverts_tactic H ltac:(intros I1) ltac:(intros I2) ltac:(intros I3)

   ltac:(intros I4) ltac:(intros I5) ltac:(intros I6).



Tactic Notation "inverts" hyp(H) :=

  inverts keep H; clear H.



Tactic Notation "inverts_tactic" hyp(H) tactic(tac) :=

  let H' := fresh in rename H into H'; tac H'; clear H'.

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1) :=

  invert_tactic H (fun H => inverts keep H as I1).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) :=

  invert_tactic H (fun H => inverts keep H as I1 I2).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) :=

  invert_tactic H (fun H => inverts keep H as I1 I2 I3).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4) :=

  invert_tactic H (fun H => inverts keep H as I1 I2 I3 I4).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)

 simple_intropattern(I5) :=

  invert_tactic H (fun H => inverts keep H as I1 I2 I3 I4 I5).

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)

 simple_intropattern(I5) simple_intropattern(I6) :=

  invert_tactic H (fun H => inverts keep H as I1 I2 I3 I4 I5 I6).



Ltac inverts_as_tactic H :=

  let rec go tt :=

    match goal with

    | |- (ltac_Mark -> _) => intros _

    | |- (?x = ?y -> _) => let H := fresh "TEMP" in intro H;

                           first [ subst x | subst y ];

                           go tt

    | |- (existT ?P ?p ?x = existT ?P ?p ?y -> _) =>

         let H := fresh in intro H;

         generalize (@inj_pair2 _ P p x y H);

         clear H; go tt

    | |- (forall _, _) =>

       intro; let H := get_last_hyp tt in mark_to_generalize H; go tt

    end in

  pose ltac_mark; inversion H;

  generalize ltac_mark; gen_until_mark;

  go tt; gen_to_generalize; unfolds ltac_to_generalize;

  unfold eq' in *.



Tactic Notation "inverts" "keep" hyp(H) "as" :=

  inverts_as_tactic H.



Tactic Notation "inverts" hyp(H) "as" :=

  inverts_as_tactic H; clear H.



Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)

 simple_intropattern(I5) simple_intropattern(I6) simple_intropattern(I7) :=

  inverts H as; introv I1 I2 I3 I4 I5 I6 I7.

Tactic Notation "inverts" hyp(H) "as" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) simple_intropattern(I4)

 simple_intropattern(I5) simple_intropattern(I6) simple_intropattern(I7)

 simple_intropattern(I8) :=

  inverts H as; introv I1 I2 I3 I4 I5 I6 I7 I8.



Ltac injects_tactic H :=

  let rec go _ :=

    match goal with

    | |- (ltac_Mark -> _) => intros _

    | |- (?x = ?y -> _) => let H := fresh in intro H;

                           first [ subst x | subst y | idtac ];

                           go tt

    end in

  generalize ltac_mark; injection H; go tt.



Tactic Notation "injects" "keep" hyp(H) :=

  injects_tactic H.



Tactic Notation "injects" hyp(H) :=

  injects_tactic H; clear H.



Tactic Notation "inject" hyp(H) :=

  injection H.

Tactic Notation "inject" hyp(H) "as" ident(X1) :=

  injection H; intros X1.

Tactic Notation "inject" hyp(H) "as" ident(X1) ident(X2) :=

  injection H; intros X1 X2.

Tactic Notation "inject" hyp(H) "as" ident(X1) ident(X2) ident(X3) :=

  injection H; intros X1 X2 X3.

Tactic Notation "inject" hyp(H) "as" ident(X1) ident(X2) ident(X3)

 ident(X4) :=

  injection H; intros X1 X2 X3 X4.

Tactic Notation "inject" hyp(H) "as" ident(X1) ident(X2) ident(X3)

 ident(X4) ident(X5) :=

  injection H; intros X1 X2 X3 X4 X5.



Tactic Notation "inversions" "keep" hyp(H) :=

  inversion H; subst.



Tactic Notation "inversions" hyp(H) :=

  inversion H; subst; clear H.



Tactic Notation "injections" "keep" hyp(H) :=

  injection H; intros; subst.



Tactic Notation "injections" "keep" hyp(H) :=

  injection H; clear H; intros; subst.



Tactic Notation "cases" constr(E) "as" ident(H) :=

  let X := fresh "TEMP" in

  set (X := E) in *; def_to_eq_sym X H E;

  destruct X.



Tactic Notation "cases" constr(E) :=

  let x := fresh "Eq" in cases E as H.



Ltac case_if_post := idtac.



Ltac case_if_on_tactic E Eq :=

  match type of E with

  | {_}+{_} => destruct E as [Eq | Eq]

  | _ => let X := fresh in

         sets_eq <- X Eq: E;

         destruct X

  end; case_if_post.



Tactic Notation "case_if_on" constr(E) "as" simple_intropattern(Eq) :=

  case_if_on_tactic E Eq.



Tactic Notation "case_if" "as" simple_intropattern(Eq) :=

  match goal with

  | |- context [if ?B then _ else _] => case_if_on B as Eq

  | K: context [if ?B then _ else _] |- _ => case_if_on B as Eq

  end.



Tactic Notation "case_if" "in" hyp(H) "as" simple_intropattern(Eq) :=

  match type of H with context [if ?B then _ else _] =>

    case_if_on B as Eq end.



Tactic Notation "case_if" :=

  let Eq := fresh in case_if as Eq.



Tactic Notation "case_if" "in" hyp(H) :=

  let Eq := fresh in case_if in H as Eq.



Ltac cases_if_on_tactic E Eq :=

  match type of E with

  | {_}+{_} => destruct E as [Eq|Eq]; try subst_hyp Eq

  | _ => let X := fresh in

         sets_eq <- X Eq: E;

         destruct X

  end; case_if_post.



Tactic Notation "cases_if_on" constr(E) "as" simple_intropattern(Eq) :=

  cases_if_on_tactic E Eq.



Tactic Notation "cases_if" "as" simple_intropattern(Eq) :=

  match goal with

  | |- context [if ?B then _ else _] => case_if_on B as Eq

  | K: context [if ?B then _ else _] |- _ => case_if_on B as Eq

  end.



Tactic Notation "cases_if" "in" hyp(H) "as" simple_intropattern(Eq) :=

  match type of H with context [if ?B then _ else _] =>

    cases_if_on B as Eq end.



Tactic Notation "cases_if" :=

  let Eq := fresh in cases_if as Eq.



Tactic Notation "cases_if" "in" hyp(H) :=

  let Eq := fresh in cases_if in H as Eq.



Ltac destruct_if_post := tryfalse.



Tactic Notation "destruct_if"

 "as" simple_intropattern(Eq1) simple_intropattern(Eq2) :=

  match goal with

  | |- context [if ?B then _ else _] => destruct B as [Eq1|Eq2]

  | K: context [if ?B then _ else _] |- _ => destruct B as [Eq1|Eq2]

  end;

  destruct_if_post.



Tactic Notation "destruct_if" "in" hyp(H)

 "as" simple_intropattern(Eq1) simple_intropattern(Eq2) :=

  match type of H with context [if ?B then _ else _] =>

    destruct B as [Eq1|Eq2] end;

  destruct_if_post.



Tactic Notation "destruct_if" "as" simple_intropattern(Eq) :=

  destruct_if as Eq Eq.

Tactic Notation "destruct_if" "in" hyp(H) "as" simple_intropattern(Eq) :=

  destruct_if in H as Eq Eq.



Tactic Notation "destruct_if" :=

  let Eq := fresh "C" in destruct_if as Eq Eq.

Tactic Notation "destruct_if" "in" hyp(H) :=

  let Eq := fresh "C" in destruct_if in H as Eq Eq.



Ltac find_head_match T :=

  match T with context [?E] =>

    match T with

    | E => fail 1

    | _ => constr:(E)

    end

  end.



Ltac destruct_head_match_core cont :=

  match goal with

  | |- ?T1 = ?T2 => first [ let E := find_head_match T1 in cont E

		          | let E := find_head_match T2 in cont E ]

  | |- ?T1 => let E := find_head_match T1 in cont E

  end;

  destruct_if_post.



Tactic Notation "destruct_head_match" "as" simple_intropattern(I) :=

  destruct_head_match_core ltac:(fun E => destruct E as I).



Tactic Notation "destruct_head_match" :=

  destruct_head_match_core ltac:(fun E => destruct E).



Tactic Notation "cases'" constr(E) "as" ident(H) :=

  let X := fresh "TEMP" in

  set (X := E) in *; def_to_eq X H E;

  destruct X.



Tactic Notation "cases'" constr(E) :=

  let x := fresh "Eq" in cases' E as H.



Ltac cases_if_on' E Eq :=

  match type of E with

  | {_}+{_} => destruct E as [Eq|Eq]; try subst_hyp Eq

  | _ => let X := fresh in

         sets_eq X Eq: E;

         destruct X

  end; case_if_post.



Tactic Notation "cases_if'" "as" simple_intropattern(Eq) :=

  match goal with

  | |- context [if ?B then _ else _] => cases_if_on' B Eq

  | K: context [if ?B then _ else _] |- _ => cases_if_on' B Eq

  end.



Tactic Notation "cases_if'" :=

  let Eq := fresh in cases_if' as Eq.



Require Import Coq.Program.Equality.



Ltac inductions_post :=

  unfold eq' in *.



Tactic Notation "inductions" ident(E) :=

  dependent induction E; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) :=

  dependent induction E generalizing X1; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2) :=

  dependent induction E generalizing X1 X2; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2)

 ident(X3) :=

  dependent induction E generalizing X1 X2 X3; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2)

 ident(X3) ident(X4) :=

  dependent induction E generalizing X1 X2 X3 X4; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2)

 ident(X3) ident(X4) ident(X5) :=

  dependent induction E generalizing X1 X2 X3 X4 X5; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2)

 ident(X3) ident(X4) ident(X5) ident(X6) :=

  dependent induction E generalizing X1 X2 X3 X4 X5 X6; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2)

 ident(X3) ident(X4) ident(X5) ident(X6) ident(X7) :=

  dependent induction E generalizing X1 X2 X3 X4 X5 X6 X7; inductions_post.

Tactic Notation "inductions" ident(E) "gen" ident(X1) ident(X2)

 ident(X3) ident(X4) ident(X5) ident(X6) ident(X7) ident(X8) :=

  dependent induction E generalizing X1 X2 X3 X4 X5 X6 X7 X8; inductions_post.



Tactic Notation "induction_wf" ident(IH) ":" constr(E) ident(X) :=

  pattern X; apply (well_founded_ind E); clear X; intros X IH.

Tactic Notation "induction_wf" ":" constr(E) ident(X) :=

  let IH := fresh "IH" in induction_wf IH: E X.

Tactic Notation "induction_wf" ":" constr(E) ident(X) :=

  induction_wf: E X.



Ltac decides_equality_tactic :=

  first [ decide equality | progress(unfolds); decides_equality_tactic ].



Tactic Notation "decides_equality" :=

  decides_equality_tactic.



Lemma iff_intro_swap : forall (P Q : Prop),

  (Q -> P) -> (P -> Q) -> (P <-> Q).

Proof. intuition. Qed.



Tactic Notation "iff" simple_intropattern(H1) simple_intropattern(H2) :=

  split; [ intros H1 | intros H2 ].

Tactic Notation "iff" simple_intropattern(H) :=

  iff H H.

Tactic Notation "iff" :=

  let H := fresh "H" in iff H.



Tactic Notation "iff" "<-" simple_intropattern(H1) simple_intropattern(H2) :=

  apply iff_intro_swap; [ intros H1 | intros H2 ].

Tactic Notation "iff" "<-" simple_intropattern(H) :=

  iff <- H H.

Tactic Notation "iff" "<-" :=

  let H := fresh "H" in iff <- H.



Ltac splits_tactic N :=

  match N with

  | O => fail

  | S O => idtac

  | S ?N' => split; [| splits_tactic N']

  end.



Ltac unfold_goal_until_conjunction :=

  match goal with

  | |- _ /\ _ => idtac

  | _ => progress(unfolds); unfold_goal_until_conjunction

  end.



Ltac get_term_conjunction_arity T :=

  match T with

  | _ /\ _ /\ _ /\ _ /\ _ /\ _ /\ _ /\ _ => constr:(8)

  | _ /\ _ /\ _ /\ _ /\ _ /\ _ /\ _ => constr:(7)

  | _ /\ _ /\ _ /\ _ /\ _ /\ _ => constr:(6)

  | _ /\ _ /\ _ /\ _ /\ _ => constr:(5)

  | _ /\ _ /\ _ /\ _ => constr:(4)

  | _ /\ _ /\ _ => constr:(3)

  | _ /\ _ => constr:(2)

  | _ -> ?T' => get_term_conjunction_arity T'

  | _ => let P := get_head T in

         let T' := eval unfold P in T in

         match T' with

         | T => fail 1

         | _ => get_term_conjunction_arity T'

         end

         

  end.



Ltac get_goal_conjunction_arity :=

  match goal with |- ?T => get_term_conjunction_arity T end.



Tactic Notation "splits" :=

  unfold_goal_until_conjunction;

  let N := get_goal_conjunction_arity in

  splits_tactic N.



Tactic Notation "splits" constr(N) :=

  let N := nat_from_number N in

  splits_tactic N.



Ltac splits_all_base := repeat split.



Tactic Notation "splits_all" :=

  splits_all_base.



Ltac destructs_conjunction_tactic N T :=

  match N with

  | 2 => destruct T as [? ?]

  | 3 => destruct T as [? [? ?]]

  | 4 => destruct T as [? [? [? ?]]]

  | 5 => destruct T as [? [? [? [? ?]]]]

  | 6 => destruct T as [? [? [? [? [? ?]]]]]

  | 7 => destruct T as [? [? [? [? [? [? ?]]]]]]

  end.



Tactic Notation "destructs" constr(T) :=

  let TT := type of T in

  let N := get_term_conjunction_arity TT in

  destructs_conjunction_tactic N T.



Tactic Notation "destructs" constr(N) constr(T) :=

  let N := nat_from_number N in

  destructs_conjunction_tactic N T.



Ltac branch_tactic K N :=

  match constr:(K,N) with

  | (_,0) => fail 1

  | (0,_) => fail 1

  | (1,1) => idtac

  | (1,_) => left

  | (S ?K', S ?N') => right; branch_tactic K' N'

  end.



Ltac unfold_goal_until_disjunction :=

  match goal with

  | |- _ \/ _ => idtac

  | _ => progress(unfolds); unfold_goal_until_disjunction

  end.



Ltac get_term_disjunction_arity T :=

  match T with

  | _ \/ _ \/ _ \/ _ \/ _ \/ _ \/ _ \/ _ => constr:(8)

  | _ \/ _ \/ _ \/ _ \/ _ \/ _ \/ _ => constr:(7)

  | _ \/ _ \/ _ \/ _ \/ _ \/ _ => constr:(6)

  | _ \/ _ \/ _ \/ _ \/ _ => constr:(5)

  | _ \/ _ \/ _ \/ _ => constr:(4)

  | _ \/ _ \/ _ => constr:(3)

  | _ \/ _ => constr:(2)

  | _ -> ?T' => get_term_disjunction_arity T'

  | _ => let P := get_head T in

         let T' := eval unfold P in T in

         match T' with

         | T => fail 1

         | _ => get_term_disjunction_arity T'

         end

  end.



Ltac get_goal_disjunction_arity :=

  match goal with |- ?T => get_term_disjunction_arity T end.



Tactic Notation "branch" constr(K) :=

  let K := nat_from_number K in

  unfold_goal_until_disjunction;

  let N := get_goal_disjunction_arity in

  branch_tactic K N.



Tactic Notation "branch" constr(K) "of" constr(N) :=

  let N := nat_from_number N in

  let K := nat_from_number K in

  branch_tactic K N.



Ltac destructs_disjunction_tactic N T :=

  match N with

  | 2 => destruct T as [? | ?]

  | 3 => destruct T as [? | [? | ?]]

  | 4 => destruct T as [? | [? | [? | ?]]]

  | 5 => destruct T as [? | [? | [? | [? | ?]]]]

  end.



Tactic Notation "branches" constr(T) :=

  let TT := type of T in

  let N := get_term_disjunction_arity TT in

  destructs_disjunction_tactic N T.



Tactic Notation "branches" constr(N) constr(T) :=

  let N := nat_from_number N in

  destructs_disjunction_tactic N T.



Ltac get_term_existential_arity T :=

  match T with

  | exists x1 x2 x3 x4 x5 x6 x7 x8, _ => constr:(8)

  | exists x1 x2 x3 x4 x5 x6 x7, _ => constr:(7)

  | exists x1 x2 x3 x4 x5 x6, _ => constr:(6)

  | exists x1 x2 x3 x4 x5, _ => constr:(5)

  | exists x1 x2 x3 x4, _ => constr:(4)

  | exists x1 x2 x3, _ => constr:(3)

  | exists x1 x2, _ => constr:(2)

  | exists x1, _ => constr:(1)

  | _ -> ?T' => get_term_existential_arity T'

  | _ => let P := get_head T in

         let T' := eval unfold P in T in

         match T' with

         | T => fail 1

         | _ => get_term_existential_arity T'

         end

  end.



Ltac get_goal_existential_arity :=

  match goal with |- ?T => get_term_existential_arity T end.



Tactic Notation "exists_original" constr(T1) :=

  exists T1.

Tactic Notation "exists" constr(T1) :=

  match T1 with

  | ltac_wild => esplit

  | ltac_wilds => repeat esplit

  | _ => exists T1

  end.

Tactic Notation "exists" constr(T1) constr(T2) :=

  exists T1; exists T2.

Tactic Notation "exists" constr(T1) constr(T2) constr(T3) :=

  exists T1; exists T2; exists T3.

Tactic Notation "exists" constr(T1) constr(T2) constr(T3) constr(T4) :=

  exists T1; exists T2; exists T3; exists T4.

Tactic Notation "exists" constr(T1) constr(T2) constr(T3) constr(T4)

 constr(T5) :=

  exists T1; exists T2; exists T3; exists T4; exists T5.

Tactic Notation "exists" constr(T1) constr(T2) constr(T3) constr(T4)

 constr(T5) constr(T6) :=

  exists T1; exists T2; exists T3; exists T4; exists T5; exists T6.



Tactic Notation "exists___" constr(N) :=

  let rec aux N :=

    match N with

    | 0 => idtac

    | S ?N' => esplit; aux N'

    end in

  let N := nat_from_number N in aux N.



Tactic Notation "exists___" :=

  let N := get_goal_existential_arity in

  exists___ N.



Ltac intuit_core :=

  repeat match goal with

  | H: _ /\ _ |- _ => destruct H

  | H: exists a, _ |- _ => destruct H

  end.



Ltac intuit_from H :=

  first [ progress (intuit_core)

        | destruct H; intuit_core ].



Tactic Notation "intuit" :=

  intuit_core.

Tactic Notation "intuit" constr(H) :=

  intuit_from H.



Tactic Notation "typeclass" :=

  let go _ := eauto with typeclass_instances in

  solve [ go tt | constructor; go tt ].



Tactic Notation "solve_typeclass" :=

  solve [ eauto with typeclass_instances ].



Ltac jauto_set_hyps :=

  repeat match goal with H: ?T |- _ =>

    match T with

    | _ /\ _ => destruct H

    | exists a, _ => destruct H

    | _ => generalizes H

    end

  end.



Ltac jauto_set_goal :=

  repeat match goal with

  | |- exists a, _ => esplit

  | |- _ /\ _ => split

  end.



Ltac jauto_set :=

  intros; jauto_set_hyps;

  intros; jauto_set_goal;

  unfold not in *.



Tactic Notation "jauto" :=

  try solve [ jauto_set; eauto ].



Tactic Notation "jauto_fast" :=

  try solve [ auto | eauto | jauto ].



Tactic Notation "iauto" := try solve [intuition eauto].



Ltac auto_tilde_default := auto.

Ltac auto_tilde := auto_tilde_default.



Ltac auto_star_default := try solve [ auto | eauto | intuition eauto ].

  

Ltac auto_star := auto_star_default.



Tactic Notation "auto" "~" :=

  auto_tilde.

Tactic Notation "auto" "~" constr(E1) :=

  lets: E1; auto_tilde.

Tactic Notation "auto" "~" constr(E1) constr(E2) :=

  lets: E1; lets: E2; auto_tilde.

Tactic Notation "auto" "~" constr(E1) constr(E2) constr(E3) :=

  lets: E1; lets: E2; lets: E3; auto_tilde.



Tactic Notation "auto" "*" :=

  auto_star.

Tactic Notation "auto" "*" constr(E1) :=

  lets: E1; auto_star.

Tactic Notation "auto" "*" constr(E1) constr(E2) :=

  lets: E1; lets: E2; auto_star.

Tactic Notation "auto" "*" constr(E1) constr(E2) constr(E3) :=

  lets: E1; lets: E2; lets: E3; auto_star.



Ltac auto_false_base cont :=

  try solve [ cont tt | tryfalse by congruence/

            | try split; intros_all; tryfalse by congruence/ ].



Tactic Notation "auto_false" :=

   auto_false_base ltac:(fun tt => auto).

Tactic Notation "auto_false" "~" :=

   auto_false_base ltac:(fun tt => auto~).

Tactic Notation "auto_false" "*" :=

   auto_false_base ltac:(fun tt => auto*).



Tactic Notation "f_equal" :=

  f_equal.

Tactic Notation "constructor" :=

  constructor.

Tactic Notation "simple" :=

  simpl.



Tactic Notation "equates" "~" constr(E) :=

   equates E; auto~.

Tactic Notation "equates" "~" constr(n1) constr(n2) :=

  equates n1 n2; auto~.

Tactic Notation "equates" "~" constr(n1) constr(n2) constr(n3) :=

  equates n1 n2 n3; auto~.

Tactic Notation "equates" "~" constr(n1) constr(n2) constr(n3) constr(n4) :=

  equates n1 n2 n3 n4; auto~.



Tactic Notation "applys_eq" "~" constr(H) constr(E) :=

  applys_eq H E; auto_tilde.

Tactic Notation "applys_eq" "~" constr(H) constr(n1) constr(n2) :=

  applys_eq H n1 n2; auto_tilde.

Tactic Notation "applys_eq" "~" constr(H) constr(n1) constr(n2) constr(n3) :=

  applys_eq H n1 n2 n3; auto_tilde.

Tactic Notation "applys_eq" "~" constr(H) constr(n1) constr(n2) constr(n3) constr(n4) :=

  applys_eq H n1 n2 n3 n4; auto_tilde.



Tactic Notation "apply" "~" constr(H) :=

  sapply H; auto_tilde.



Tactic Notation "destruct" "~" constr(H) :=

  destruct H; auto_tilde.

Tactic Notation "destruct" "~" constr(H) "as" simple_intropattern(I) :=

  destruct H as I; auto_tilde.

Tactic Notation "f_equal" "~" :=

  f_equal; auto_tilde.

Tactic Notation "induction" "~" constr(H) :=

  induction H; auto_tilde.

Tactic Notation "inversion" "~" constr(H) :=

  inversion H; auto_tilde.

Tactic Notation "split" "~" :=

  split; auto_tilde.

Tactic Notation "subst" "~" :=

  subst; auto_tilde.

Tactic Notation "right" "~" :=

  right; auto_tilde.

Tactic Notation "left" "~" :=

  left; auto_tilde.

Tactic Notation "constructor" "~" :=

  constructor; auto_tilde.

Tactic Notation "constructors" "~" :=

  constructors; auto_tilde.



Tactic Notation "false" "~" :=

  false; auto_tilde.

Tactic Notation "false" "~" constr(T) :=

  false T by auto_tilde/.

Tactic Notation "tryfalse" "~" :=

  tryfalse by auto_tilde/.

Tactic Notation "tryfalse_invert" "~" :=

  first [ tryfalse~ | false_invert ].



Tactic Notation "asserts" "~" simple_intropattern(H) ":" constr(E) :=

  asserts H: E; [ auto_tilde | idtac ].

Tactic Notation "cuts" "~" simple_intropattern(H) ":" constr(E) :=

  cuts H: E; [ auto_tilde | idtac ].

Tactic Notation "cuts" "~" ":" constr(E) :=

  cuts: E; [ auto_tilde | idtac ].



Tactic Notation "lets" "~" simple_intropattern(I) ":" constr(E) :=

  lets I: E; auto_tilde.

Tactic Notation "lets" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) :=

  lets I: E0 A1; auto_tilde.

Tactic Notation "lets" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) :=

  lets I: E0 A1 A2; auto_tilde.

Tactic Notation "lets" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets I: E0 A1 A2 A3; auto_tilde.

Tactic Notation "lets" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets I: E0 A1 A2 A3 A4; auto_tilde.

Tactic Notation "lets" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets I: E0 A1 A2 A3 A4 A5; auto_tilde.



Tactic Notation "lets" "~" ":" constr(E) :=

  lets: E; auto_tilde.

Tactic Notation "lets" "~" ":" constr(E0)

 constr(A1) :=

  lets: E0 A1; auto_tilde.

Tactic Notation "lets" "~" ":" constr(E0)

 constr(A1) constr(A2) :=

  lets: E0 A1 A2; auto_tilde.

Tactic Notation "lets" "~" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets: E0 A1 A2 A3; auto_tilde.

Tactic Notation "lets" "~" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets: E0 A1 A2 A3 A4; auto_tilde.

Tactic Notation "lets" "~" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets: E0 A1 A2 A3 A4 A5; auto_tilde.



Tactic Notation "forwards" "~" simple_intropattern(I) ":" constr(E) :=

  forwards I: E; auto_tilde.

Tactic Notation "forwards" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) :=

  forwards I: E0 A1; auto_tilde.

Tactic Notation "forwards" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) :=

  forwards I: E0 A1 A2; auto_tilde.

Tactic Notation "forwards" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  forwards I: E0 A1 A2 A3; auto_tilde.

Tactic Notation "forwards" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  forwards I: E0 A1 A2 A3 A4; auto_tilde.

Tactic Notation "forwards" "~" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  forwards I: E0 A1 A2 A3 A4 A5; auto_tilde.



Tactic Notation "forwards" "~" ":" constr(E) :=

  forwards: E; auto_tilde.

Tactic Notation "forwards" "~" ":" constr(E0)

 constr(A1) :=

  forwards: E0 A1; auto_tilde.

Tactic Notation "forwards" "~" ":" constr(E0)

 constr(A1) constr(A2) :=

  forwards: E0 A1 A2; auto_tilde.

Tactic Notation "forwards" "~" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  forwards: E0 A1 A2 A3; auto_tilde.

Tactic Notation "forwards" "~" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  forwards: E0 A1 A2 A3 A4; auto_tilde.

Tactic Notation "forwards" "~" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  forwards: E0 A1 A2 A3 A4 A5; auto_tilde.



Tactic Notation "applys" "~" constr(H) :=

  sapply H; auto_tilde. 

Tactic Notation "applys" "~" constr(E0) constr(A1) :=

  applys E0 A1; auto_tilde.

Tactic Notation "applys" "~" constr(E0) constr(A1) :=

  applys E0 A1; auto_tilde.

Tactic Notation "applys" "~" constr(E0) constr(A1) constr(A2) :=

  applys E0 A1 A2; auto_tilde.

Tactic Notation "applys" "~" constr(E0) constr(A1) constr(A2) constr(A3) :=

  applys E0 A1 A2 A3; auto_tilde.

Tactic Notation "applys" "~" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) :=

  applys E0 A1 A2 A3 A4; auto_tilde.

Tactic Notation "applys" "~" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  applys E0 A1 A2 A3 A4 A5; auto_tilde.



Tactic Notation "specializes" "~" hyp(H) :=

  specializes H; auto_tilde.

Tactic Notation "specializes" "~" hyp(H) constr(A1) :=

  specializes H A1; auto_tilde.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) :=

  specializes H A1 A2; auto_tilde.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) :=

  specializes H A1 A2 A3; auto_tilde.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) constr(A4) :=

  specializes H A1 A2 A3 A4; auto_tilde.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  specializes H A1 A2 A3 A4 A5; auto_tilde.



Tactic Notation "fapply" "~" constr(E) :=

  fapply E; auto_tilde.

Tactic Notation "sapply" "~" constr(E) :=

  sapply E; auto_tilde.



Tactic Notation "logic" "~" constr(E) :=

  logic_base E ltac:(fun _ => auto_tilde).



Tactic Notation "intros_all" "~" :=

  intros_all; auto_tilde.



Tactic Notation "unfolds" "~" :=

  unfolds; auto_tilde.

Tactic Notation "unfolds" "~" reference(F1) :=

  unfolds F1; auto_tilde.

Tactic Notation "unfolds" "~" reference(F1) "," reference(F2) :=

  unfolds F1, F2; auto_tilde.

Tactic Notation "unfolds" "~" reference(F1) "," reference(F2) "," reference(F3) :=

  unfolds F1, F2, F3; auto_tilde.

Tactic Notation "unfolds" "~" reference(F1) "," reference(F2) "," reference(F3) ","

 reference(F4) :=

  unfolds F1, F2, F3, F4; auto_tilde.



Tactic Notation "simple" "~" :=

  simpl; auto_tilde.

Tactic Notation "simple" "~" "in" hyp(H) :=

  simpl in H; auto_tilde.

Tactic Notation "simpls" "~" :=

  simpls; auto_tilde.

Tactic Notation "hnfs" "~" :=

  hnfs; auto_tilde.

Tactic Notation "substs" "~" :=

  substs; auto_tilde.

Tactic Notation "intro_hyp" "~" hyp(H) :=

  subst_hyp H; auto_tilde.

Tactic Notation "intro_subst" "~" :=

  intro_subst; auto_tilde.

Tactic Notation "subst_eq" "~" constr(E) :=

  subst_eq E; auto_tilde.



Tactic Notation "rewrite" "~" constr(E) :=

  rewrite E; auto_tilde.

Tactic Notation "rewrite" "~" "<-" constr(E) :=

  rewrite <- E; auto_tilde.

Tactic Notation "rewrite" "~" constr(E) "in" hyp(H) :=

  rewrite E in H; auto_tilde.

Tactic Notation "rewrite" "~" "<-" constr(E) "in" hyp(H) :=

  rewrite <- E in H; auto_tilde.



Tactic Notation "rewrite_all" "~" constr(E) :=

  rewrite_all E; auto_tilde.

Tactic Notation "rewrite_all" "~" "<-" constr(E) :=

  rewrite_all <- E; auto_tilde.

Tactic Notation "rewrite_all" "~" constr(E) "in" ident(H) :=

  rewrite_all E in H; auto_tilde.

Tactic Notation "rewrite_all" "~" "<-" constr(E) "in" ident(H) :=

  rewrite_all <- E in H; auto_tilde.

Tactic Notation "rewrite_all" "~" constr(E) "in" "*" :=

  rewrite_all E in *; auto_tilde.

Tactic Notation "rewrite_all" "~" "<-" constr(E) "in" "*" :=

  rewrite_all <- E in *; auto_tilde.



Tactic Notation "asserts_rewrite" "~" constr(E) :=

  asserts_rewrite E; auto_tilde.

Tactic Notation "asserts_rewrite" "~" "<-" constr(E) :=

  asserts_rewrite <- E; auto_tilde.

Tactic Notation "asserts_rewrite" "~" constr(E) "in" hyp(H) :=

  asserts_rewrite E in H; auto_tilde.

Tactic Notation "asserts_rewrite" "~" "<-" constr(E) "in" hyp(H) :=

  asserts_rewrite <- E in H; auto_tilde.



Tactic Notation "cuts_rewrite" "~" constr(E) :=

  cuts_rewrite E; auto_tilde.

Tactic Notation "cuts_rewrite" "~" "<-" constr(E) :=

  cuts_rewrite <- E; auto_tilde.

Tactic Notation "cuts_rewrite" "~" constr(E) "in" hyp(H) :=

  cuts_rewrite E in H; auto_tilde.

Tactic Notation "cuts_rewrite" "~" "<-" constr(E) "in" hyp(H) :=

  cuts_rewrite <- E in H; auto_tilde.



Tactic Notation "fequal" "~" :=

  fequal; auto_tilde.

Tactic Notation "fequals" "~" :=

  fequals; auto_tilde.

Tactic Notation "pi_rewrite" "~" constr(E) :=

  pi_rewrite E; auto_tilde.

Tactic Notation "pi_rewrite" "~" constr(E) "in" hyp(H) :=

  pi_rewrite E in H; auto_tilde.



Tactic Notation "invert" "~" hyp(H) :=

  invert H; auto_tilde.

Tactic Notation "inverts" "~" hyp(H) :=

  inverts H; auto_tilde.

Tactic Notation "injects" "~" hyp(H) :=

  injects H; auto_tilde.

Tactic Notation "inversions" "~" hyp(H) :=

  inversions H; auto_tilde.



Tactic Notation "cases" "~" constr(E) "as" ident(H) :=

  cases E as H; auto_tilde.

Tactic Notation "cases" "~" constr(E) :=

  cases E; auto_tilde.

Tactic Notation "case_if" "~" :=

  case_if; auto_tilde.

Tactic Notation "case_if" "~" "in" hyp(H) :=

  case_if in H; auto_tilde.

Tactic Notation "cases_if" "~" :=

  cases_if; auto_tilde.

Tactic Notation "cases_if" "~" "in" hyp(H) :=

  cases_if in H; auto_tilde.

Tactic Notation "destruct_if" "~" :=

  destruct_if; auto_tilde.

Tactic Notation "destruct_if" "~" "in" hyp(H) :=

  destruct_if in H; auto_tilde.

Tactic Notation "destruct_head_match" "~" :=

  destruct_head_match; auto_tilde.



Tactic Notation "cases'" "~" constr(E) "as" ident(H) :=

  cases' E as H; auto_tilde.

Tactic Notation "cases'" "~" constr(E) :=

  cases' E; auto_tilde.

Tactic Notation "cases_if'" "~" "as" ident(H) :=

  cases_if' as H; auto_tilde.

Tactic Notation "cases_if'" "~" :=

  cases_if'; auto_tilde.



Tactic Notation "decides_equality" "~" :=

  decides_equality; auto_tilde.



Tactic Notation "iff" "~" :=

  iff; auto_tilde.

Tactic Notation "splits" "~" :=

  splits; auto_tilde.

Tactic Notation "splits" "~" constr(N) :=

  splits N; auto_tilde.

Tactic Notation "splits_all" "~" :=

  splits_all; auto_tilde.



Tactic Notation "destructs" "~" constr(T) :=

  destructs T; auto_tilde.

Tactic Notation "destructs" "~" constr(N) constr(T) :=

  destructs N T; auto_tilde.



Tactic Notation "branch" "~" constr(N) :=

  branch N; auto_tilde.

Tactic Notation "branch" "~" constr(K) "of" constr(N) :=

  branch K of N; auto_tilde.



Tactic Notation "branches" "~" constr(T) :=

  branches T; auto_tilde.

Tactic Notation "branches" "~" constr(N) constr(T) :=

  branches N T; auto_tilde.



Tactic Notation "exists___" "~" :=

  exists___; auto_tilde.

Tactic Notation "exists" "~" constr(T1) :=

  exists T1; auto_tilde.

Tactic Notation "exists" "~" constr(T1) constr(T2) :=

  exists T1 T2; auto_tilde.

Tactic Notation "exists" "~" constr(T1) constr(T2) constr(T3) :=

  exists T1 T2 T3; auto_tilde.

Tactic Notation "exists" "~" constr(T1) constr(T2) constr(T3) constr(T4) :=

  exists T1 T2 T3 T4; auto_tilde.

Tactic Notation "exists" "~" constr(T1) constr(T2) constr(T3) constr(T4)

 constr(T5) :=

  exists T1 T2 T3 T4 T5; auto_tilde.

Tactic Notation "exists" "~" constr(T1) constr(T2) constr(T3) constr(T4)

 constr(T5) constr(T6) :=

  exists T1 T2 T3 T4 T5 T6; auto_tilde.



Tactic Notation "equates" "*" constr(E) :=

   equates E; auto_star.

Tactic Notation "equates" "*" constr(n1) constr(n2) :=

  equates n1 n2; auto_star.

Tactic Notation "equates" "*" constr(n1) constr(n2) constr(n3) :=

  equates n1 n2 n3; auto_star.

Tactic Notation "equates" "*" constr(n1) constr(n2) constr(n3) constr(n4) :=

  equates n1 n2 n3 n4; auto_star.



Tactic Notation "applys_eq" "*" constr(H) constr(E) :=

  applys_eq H E; auto_star.

Tactic Notation "applys_eq" "*" constr(H) constr(n1) constr(n2) :=

  applys_eq H n1 n2; auto_star.

Tactic Notation "applys_eq" "*" constr(H) constr(n1) constr(n2) constr(n3) :=

  applys_eq H n1 n2 n3; auto_star.

Tactic Notation "applys_eq" "*" constr(H) constr(n1) constr(n2) constr(n3) constr(n4) :=

  applys_eq H n1 n2 n3 n4; auto_star.



Tactic Notation "apply" "*" constr(H) :=

  sapply H; auto_star.



Tactic Notation "destruct" "*" constr(H) :=

  destruct H; auto_star.

Tactic Notation "destruct" "*" constr(H) "as" simple_intropattern(I) :=

  destruct H as I; auto_star.

Tactic Notation "f_equal" "*" :=

  f_equal; auto_star.

Tactic Notation "induction" "*" constr(H) :=

  induction H; auto_star.

Tactic Notation "inversion" "*" constr(H) :=

  inversion H; auto_star.

Tactic Notation "split" "*" :=

  split; auto_star.

Tactic Notation "subs" "*" :=

  subst; auto_star.

Tactic Notation "subst" "*" :=

  subst; auto_star.

Tactic Notation "right" "*" :=

  right; auto_star.

Tactic Notation "left" "*" :=

  left; auto_star.

Tactic Notation "constructor" "*" :=

  constructor; auto_star.

Tactic Notation "constructors" "*" :=

  constructors; auto_star.



Tactic Notation "false" "*" :=

  false; auto_star.

Tactic Notation "false" "*" constr(T) :=

  false T by auto_star/.

Tactic Notation "tryfalse" "*" :=

  tryfalse by auto_star/.

Tactic Notation "tryfalse_invert" "*" :=

  first [ tryfalse* | false_invert ].



Tactic Notation "asserts" "*" simple_intropattern(H) ":" constr(E) :=

  asserts H: E; [ auto_star | idtac ].

Tactic Notation "cuts" "*" simple_intropattern(H) ":" constr(E) :=

  cuts H: E; [ auto_star | idtac ].

Tactic Notation "cuts" "*" ":" constr(E) :=

  cuts: E; [ auto_star | idtac ].



Tactic Notation "lets" "*" simple_intropattern(I) ":" constr(E) :=

  lets I: E; auto_star.

Tactic Notation "lets" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) :=

  lets I: E0 A1; auto_star.

Tactic Notation "lets" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) :=

  lets I: E0 A1 A2; auto_star.

Tactic Notation "lets" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets I: E0 A1 A2 A3; auto_star.

Tactic Notation "lets" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets I: E0 A1 A2 A3 A4; auto_star.

Tactic Notation "lets" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets I: E0 A1 A2 A3 A4 A5; auto_star.



Tactic Notation "lets" "*" ":" constr(E) :=

  lets: E; auto_star.

Tactic Notation "lets" "*" ":" constr(E0)

 constr(A1) :=

  lets: E0 A1; auto_star.

Tactic Notation "lets" "*" ":" constr(E0)

 constr(A1) constr(A2) :=

  lets: E0 A1 A2; auto_star.

Tactic Notation "lets" "*" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  lets: E0 A1 A2 A3; auto_star.

Tactic Notation "lets" "*" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  lets: E0 A1 A2 A3 A4; auto_star.

Tactic Notation "lets" "*" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  lets: E0 A1 A2 A3 A4 A5; auto_star.



Tactic Notation "forwards" "*" simple_intropattern(I) ":" constr(E) :=

  forwards I: E; auto_star.

Tactic Notation "forwards" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) :=

  forwards I: E0 A1; auto_star.

Tactic Notation "forwards" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) :=

  forwards I: E0 A1 A2; auto_star.

Tactic Notation "forwards" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  forwards I: E0 A1 A2 A3; auto_star.

Tactic Notation "forwards" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  forwards I: E0 A1 A2 A3 A4; auto_star.

Tactic Notation "forwards" "*" simple_intropattern(I) ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  forwards I: E0 A1 A2 A3 A4 A5; auto_star.



Tactic Notation "forwards" "*" ":" constr(E) :=

  forwards: E; auto_star.

Tactic Notation "forwards" "*" ":" constr(E0)

 constr(A1) :=

  forwards: E0 A1; auto_star.

Tactic Notation "forwards" "*" ":" constr(E0)

 constr(A1) constr(A2) :=

  forwards: E0 A1 A2; auto_star.

Tactic Notation "forwards" "*" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) :=

  forwards: E0 A1 A2 A3; auto_star.

Tactic Notation "forwards" "*" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) :=

  forwards: E0 A1 A2 A3 A4; auto_star.

Tactic Notation "forwards" "*" ":" constr(E0)

 constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  forwards: E0 A1 A2 A3 A4 A5; auto_star.



Tactic Notation "applys" "*" constr(H) :=

  sapply H; auto_star. 

Tactic Notation "applys" "*" constr(E0) constr(A1) :=

  applys E0 A1; auto_star.

Tactic Notation "applys" "*" constr(E0) constr(A1) :=

  applys E0 A1; auto_star.

Tactic Notation "applys" "*" constr(E0) constr(A1) constr(A2) :=

  applys E0 A1 A2; auto_star.

Tactic Notation "applys" "*" constr(E0) constr(A1) constr(A2) constr(A3) :=

  applys E0 A1 A2 A3; auto_star.

Tactic Notation "applys" "*" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) :=

  applys E0 A1 A2 A3 A4; auto_star.

Tactic Notation "applys" "*" constr(E0) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  applys E0 A1 A2 A3 A4 A5; auto_star.



Tactic Notation "specializes" "*" hyp(H) :=

  specializes H; auto_star.

Tactic Notation "specializes" "~" hyp(H) constr(A1) :=

  specializes H A1; auto_star.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) :=

  specializes H A1 A2; auto_star.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) :=

  specializes H A1 A2 A3; auto_star.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) constr(A4) :=

  specializes H A1 A2 A3 A4; auto_star.

Tactic Notation "specializes" hyp(H) constr(A1) constr(A2) constr(A3) constr(A4) constr(A5) :=

  specializes H A1 A2 A3 A4 A5; auto_star.



Tactic Notation "fapply" "*" constr(E) :=

  fapply E; auto_star.

Tactic Notation "sapply" "*" constr(E) :=

  sapply E; auto_star.



Tactic Notation "logic" constr(E) :=

  logic_base E ltac:(fun _ => auto_star).



Tactic Notation "intros_all" "*" :=

  intros_all; auto_star.



Tactic Notation "unfolds" "*" :=

  unfolds; auto_star.

Tactic Notation "unfolds" "*" reference(F1) :=

  unfolds F1; auto_star.

Tactic Notation "unfolds" "*" reference(F1) "," reference(F2) :=

  unfolds F1, F2; auto_star.

Tactic Notation "unfolds" "*" reference(F1) "," reference(F2) "," reference(F3) :=

  unfolds F1, F2, F3; auto_star.

Tactic Notation "unfolds" "*" reference(F1) "," reference(F2) "," reference(F3) ","

 reference(F4) :=

  unfolds F1, F2, F3, F4; auto_star.



Tactic Notation "simple" "*" :=

  simpl; auto_star.

Tactic Notation "simple" "*" "in" hyp(H) :=

  simpl in H; auto_star.

Tactic Notation "simpls" "*" :=

  simpls; auto_star.

Tactic Notation "hnfs" "*" :=

  hnfs; auto_star.

Tactic Notation "substs" "*" :=

  substs; auto_star.

Tactic Notation "intro_hyp" "*" hyp(H) :=

  subst_hyp H; auto_star.

Tactic Notation "intro_subst" "*" :=

  intro_subst; auto_star.

Tactic Notation "subst_eq" "*" constr(E) :=

  subst_eq E; auto_star.



Tactic Notation "rewrite" "*" constr(E) :=

  rewrite E; auto_star.

Tactic Notation "rewrite" "*" "<-" constr(E) :=

  rewrite <- E; auto_star.

Tactic Notation "rewrite" "*" constr(E) "in" hyp(H) :=

  rewrite E in H; auto_star.

Tactic Notation "rewrite" "*" "<-" constr(E) "in" hyp(H) :=

  rewrite <- E in H; auto_star.



Tactic Notation "rewrite_all" "*" constr(E) :=

  rewrite_all E; auto_star.

Tactic Notation "rewrite_all" "*" "<-" constr(E) :=

  rewrite_all <- E; auto_star.

Tactic Notation "rewrite_all" "*" constr(E) "in" ident(H) :=

  rewrite_all E in H; auto_star.

Tactic Notation "rewrite_all" "*" "<-" constr(E) "in" ident(H) :=

  rewrite_all <- E in H; auto_star.

Tactic Notation "rewrite_all" "*" constr(E) "in" "*" :=

  rewrite_all E in *; auto_star.

Tactic Notation "rewrite_all" "*" "<-" constr(E) "in" "*" :=

  rewrite_all <- E in *; auto_star.



Tactic Notation "asserts_rewrite" "*" constr(E) :=

  asserts_rewrite E; auto_star.

Tactic Notation "asserts_rewrite" "*" "<-" constr(E) :=

  asserts_rewrite <- E; auto_star.

Tactic Notation "asserts_rewrite" "*" constr(E) "in" hyp(H) :=

  asserts_rewrite E; auto_star.

Tactic Notation "asserts_rewrite" "*" "<-" constr(E) "in" hyp(H) :=

  asserts_rewrite <- E; auto_star.



Tactic Notation "cuts_rewrite" "*" constr(E) :=

  cuts_rewrite E; auto_star.

Tactic Notation "cuts_rewrite" "*" "<-" constr(E) :=

  cuts_rewrite <- E; auto_star.

Tactic Notation "cuts_rewrite" "*" constr(E) "in" hyp(H) :=

  cuts_rewrite E in H; auto_star.

Tactic Notation "cuts_rewrite" "*" "<-" constr(E) "in" hyp(H) :=

  cuts_rewrite <- E in H; auto_star.



Tactic Notation "fequal" "*" :=

  fequal; auto_star.

Tactic Notation "fequals" "*" :=

  fequals; auto_star.

Tactic Notation "pi_rewrite" "*" constr(E) :=

  pi_rewrite E; auto_star.

Tactic Notation "pi_rewrite" "*" constr(E) "in" hyp(H) :=

  pi_rewrite E in H; auto_star.



Tactic Notation "invert" "*" hyp(H) :=

  invert H; auto_star.

Tactic Notation "inverts" "*" hyp(H) :=

  inverts H; auto_star.

Tactic Notation "injects" "*" hyp(H) :=

  injects H; auto_star.

Tactic Notation "inversions" "*" hyp(H) :=

  inversions H; auto_star.



Tactic Notation "cases" "*" constr(E) "as" ident(H) :=

  cases E as H; auto_star.

Tactic Notation "cases" "*" constr(E) :=

  cases E; auto_star.

Tactic Notation "case_if" "*" :=

  case_if; auto_star.

Tactic Notation "case_if" "*" "in" hyp(H) :=

  case_if in H; auto_star.

Tactic Notation "cases_if" "*" :=

  cases_if; auto_star.

Tactic Notation "cases_if" "*" "in" hyp(H) :=

  cases_if in H; auto_star.

 Tactic Notation "destruct_if" "*" :=

  destruct_if; auto_star.

Tactic Notation "destruct_if" "*" "in" hyp(H) :=

  destruct_if in H; auto_star.

Tactic Notation "destruct_head_match" "*" :=

  destruct_head_match; auto_star.



Tactic Notation "cases'" "*" constr(E) "as" ident(H) :=

  cases' E as H; auto_star.

Tactic Notation "cases'" "*" constr(E) :=

  cases' E; auto_star.

Tactic Notation "cases_if'" "*" "as" ident(H) :=

  cases_if' as H; auto_star.

Tactic Notation "cases_if'" "*" :=

  cases_if'; auto_star.



Tactic Notation "decides_equality" "*" :=

  decides_equality; auto_star.



Tactic Notation "iff" "*" :=

  iff; auto_star.

Tactic Notation "splits" "*" :=

  splits; auto_star.

Tactic Notation "splits" "*" constr(N) :=

  splits N; auto_star.

Tactic Notation "splits_all" "*" :=

  splits_all; auto_star.



Tactic Notation "destructs" "*" constr(T) :=

  destructs T; auto_star.

Tactic Notation "destructs" "*" constr(N) constr(T) :=

  destructs N T; auto_star.



Tactic Notation "branch" "*" constr(N) :=

  branch N; auto_star.

Tactic Notation "branch" "*" constr(K) "of" constr(N) :=

  branch K of N; auto_star.



Tactic Notation "branches" "*" constr(T) :=

  branches T; auto_star.

Tactic Notation "branches" "*" constr(N) constr(T) :=

  branches N T; auto_star.



Tactic Notation "exists___" "*" :=

  exists___; auto_star.

Tactic Notation "exists" "*" constr(T1) :=

  exists T1; auto_star.

Tactic Notation "exists" "*" constr(T1) constr(T2) :=

  exists T1 T2; auto_star.

Tactic Notation "exists" "*" constr(T1) constr(T2) constr(T3) :=

  exists T1 T2 T3; auto_star.

Tactic Notation "exists" "*" constr(T1) constr(T2) constr(T3) constr(T4) :=

  exists T1 T2 T3 T4; auto_star.

Tactic Notation "exists" "*" constr(T1) constr(T2) constr(T3) constr(T4)

 constr(T5) :=

  exists T1 T2 T3 T4 T5; auto_star.

Tactic Notation "exists" "*" constr(T1) constr(T2) constr(T3) constr(T4)

 constr(T5) constr(T6) :=

  exists T1 T2 T3 T4 T5 T6; auto_star.



Definition ltac_something (P:Type) (e:P) := e.



Notation "'Something'" :=

  (@ltac_something _ _).



Lemma ltac_something_eq : forall (e:Type),

  e = (@ltac_something _ e).

Proof. auto. Qed.



Lemma ltac_something_hide : forall (e:Type),

  e -> (@ltac_something _ e).

Proof. auto. Qed.



Lemma ltac_something_show : forall (e:Type),

  (@ltac_something _ e) -> e.

Proof. auto. Qed.



Tactic Notation "hide_def" hyp(x) :=

  let x' := constr:(x) in

  let T := eval unfold x in x' in

  change T with (@ltac_something _ T) in x.



Tactic Notation "show_def" hyp(x) :=

  let x' := constr:(x) in

  let U := eval unfold x in x' in

  match U with @ltac_something _ ?T =>

    change U with T in x end.



Tactic Notation "show_def" :=

  unfold ltac_something.



Tactic Notation "show_def" "in" "*" :=

  unfold ltac_something in *.



Tactic Notation "hide_defs" :=

  repeat match goal with H := ?T |- _ =>

    match T with

    | @ltac_something _ _ => fail 1

    | _ => change T with (@ltac_something _ T) in H

    end

  end.



Tactic Notation "show_defs" :=

  repeat match goal with H := (@ltac_something _ ?T) |- _ =>

    change (@ltac_something _ T) with T in H end.



Tactic Notation "show_hyp" hyp(H) :=

  apply ltac_something_show in H.



Tactic Notation "hide_hyp" hyp(H) :=

  apply ltac_something_hide in H.



Tactic Notation "show_hyps" :=

  repeat match goal with

    H: @ltac_something _ _ |- _ => show_hyp H end.



Tactic Notation "hide_hyps" :=

  repeat match goal with H: ?T |- _ =>

    match type of T with

    | Prop =>

      match T with

      | @ltac_something _ _ => fail 2

      | _ => hide_hyp H

      end

    | _ => fail 1

    end

  end.



Tactic Notation "hide" hyp(H) :=

  first [hide_def H | hide_hyp H].



Tactic Notation "show" hyp(H) :=

  first [show_def H | show_hyp H].



Tactic Notation "hide_all" :=

  hide_hyps; hide_defs.



Tactic Notation "show_all" :=

  unfold ltac_something in *.



Tactic Notation "hide_term" constr(E) :=

  change E with (@ltac_something _ E).

Tactic Notation "show_term" constr(E) :=

  change (@ltac_something _ E) with E.

Tactic Notation "show_term" :=

  unfold ltac_something.



Tactic Notation "hide_term" constr(E) "in" hyp(H) :=

  change E with (@ltac_something _ E) in H.

Tactic Notation "show_term" constr(E) "in" hyp(H) :=

  change (@ltac_something _ E) with E in H.

Tactic Notation "show_term" "in" hyp(H) :=

  unfold ltac_something in H.



Ltac sort_tactic :=

  try match goal with H: ?T |- _ =>

  match type of T with Prop =>

    generalizes H; (try sort_tactic); intro

  end end.



Tactic Notation "sort" :=

  sort_tactic.



Tactic Notation "clears" ident(X1) :=

  let rec doit _ :=

  match goal with

  | H:context[X1] |- _ => clear H; try (doit tt)

  | _ => clear X1

  end in doit tt.

Tactic Notation "clears" ident(X1) ident(X2) :=

  clears X1; clears X2.

Tactic Notation "clears" ident(X1) ident(X2) ident(X3) :=

  clears X1; clears X2; clear X3.

Tactic Notation "clears" ident(X1) ident(X2) ident(X3) ident(X4) :=

  clears X1; clears X2; clear X3; clear X4.

Tactic Notation "clears" ident(X1) ident(X2) ident(X3) ident(X4)

 ident(X5) :=

  clears X1; clears X2; clear X3; clear X4; clear X5.

Tactic Notation "clears" ident(X1) ident(X2) ident(X3) ident(X4)

 ident(X5) ident(X6) :=

  clears X1; clears X2; clear X3; clear X4; clear X5; clear X6.



Ltac clears_tactic :=

  match goal with H: ?T |- _ =>

  match type of T with

  | Prop => generalizes H; (try clears_tactic); intro

  | ?TT => clear H; (try clears_tactic)

  | ?TT => generalizes H; (try clears_tactic); intro

  end end.



Tactic Notation "clears" :=

  clears_tactic.



Tactic Notation "clears_all" :=

  repeat match goal with H: _ |- _ => clear H end.



Tactic Notation "clears_last" :=

  match goal with H: ?T |- _ => clear H end.



Ltac clears_last_base N :=

  match nat_from_number N with

  | 0 => idtac

  | S ?p => clears_last; clears_last_base p

  end.



Tactic Notation "clears_last" constr(N) :=

  clears_last_base N.



Ltac skip_with_existential :=

  match goal with |- ?G =>

    let H := fresh in evar(H:G); eexact H end.



Variable skip_axiom : False.

  

Ltac skip_with_axiom :=

  elimtype False; apply skip_axiom.



Tactic Notation "skip" :=

   skip_with_axiom.

Tactic Notation "skip'" :=

   skip_with_existential.



Tactic Notation "skip" simple_intropattern(I) ":" constr(T) :=

  asserts I: T; [ skip | ].

Tactic Notation "skip" ":" constr(T) :=

  let H := fresh in skip H: T.



Tactic Notation "skip" simple_intropattern(I1)

 simple_intropattern(I2) ":" constr(T) :=

  skip [I1 I2]: T.

Tactic Notation "skip" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3) ":" constr(T) :=

  skip [I1 [I2 I3]]: T.

Tactic Notation "skip" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) ":" constr(T) :=

  skip [I1 [I2 [I3 I4]]]: T.

Tactic Notation "skip" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) simple_intropattern(I5) ":" constr(T) :=

  skip [I1 [I2 [I3 [I4 I5]]]]: T.

Tactic Notation "skip" simple_intropattern(I1)

 simple_intropattern(I2) simple_intropattern(I3)

 simple_intropattern(I4) simple_intropattern(I5)

 simple_intropattern(I6) ":" constr(T) :=

  skip [I1 [I2 [I3 [I4 [I5 I6]]]]]: T.



Tactic Notation "skip_asserts" simple_intropattern(I) ":" constr(T) :=

  skip I: T.

Tactic Notation "skip_asserts" ":" constr(T) :=

  skip: T.



Tactic Notation "skip_cuts" constr(T) :=

  cuts: T; [ skip | ].



Tactic Notation "skip_goal" ident(H) :=

  match goal with |- ?G => skip H: G end.



Tactic Notation "skip_goal" :=

  let IH := fresh "IH" in skip_goal IH.



Tactic Notation "skip_rewrite" constr(T) :=

  let M := fresh in skip_asserts M: T; rewrite M; clear M.



Tactic Notation "skip_rewrite" constr(T) "in" hyp(H) :=

  let M := fresh in skip_asserts M: T; rewrite M in H; clear M.



Tactic Notation "skip_rewrite_all" constr(T) :=

  let M := fresh in skip_asserts M: T; rewrite_all M; clear M.



Tactic Notation "skip_induction" constr(E) :=

  let IH := fresh "IH" in skip_goal IH; destruct E.



Tactic Notation "skip_induction" constr(E) "as" simple_intropattern(I) :=

  let IH := fresh "IH" in skip_goal IH; destruct E as I.



Module LibTacticsCompatibility.

  Tactic Notation "apply" "*" constr(H) :=

    sapply H; auto_star.

  Tactic Notation "subst" "*" :=

    subst; auto_star.

End LibTacticsCompatibility.



Open Scope nat_scope.

