

Set Implicit Arguments.



Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)



Definition D := evalDist.

Definition dist_iso := evalDist_iso.



Ltac r_ident_r :=

  symmetry;

  rewrite <- evalDist_right_ident;

  symmetry.



Ltac xorTac_once :=

  match goal with

    | [|- context[?x xor (?x xor ?x0)] ]=> rewrite <- BVxor_assoc; rewrite BVxor_same_id; rewrite BVxor_id_l

    | [|- context[(?x xor ?x0) xor ?x] ]=> rewrite <- BVxor_comm

  end.



Ltac xorTac := repeat xorTac_once;

              simpl; try reflexivity; try eapply in_getAllBvectors.



Section OTP.



  Variable T : Set.

  Hypothesis T_EqDec : EqDec T.

  Variable RndT : Comp T.

  Variable T_op : T -> T -> T.

  Hypothesis op_assoc : forall x y z, T_op (T_op x y) z = T_op x (T_op y z).

  Variable T_inverse : T -> T. 

  Variable T_ident : T.

  Hypothesis inverse_l_ident : forall x, T_op (T_inverse x) x = T_ident.

  Hypothesis inverse_r_ident : forall x, T_op x (T_inverse x) = T_ident.

  Hypothesis ident_l : forall x, T_op T_ident x = x.

  Hypothesis ident_r : forall x, T_op x T_ident = x.

  Hypothesis RndT_uniform : forall x y, comp_spec (fun a b => a = x <-> b = y) RndT RndT.



  Theorem all_in_support : 

    forall y, In y (getSupport RndT) ->

    forall x, In x (getSupport RndT).



    intuition.

    eapply getSupport_In_evalDist.

    intuition.

    eapply getSupport_In_evalDist.

    eapply H.

    rewrite <- H0.

    eapply comp_spec_impl_eq.

    trivial.

    

  Qed.

 

  Theorem OTP_inf_th_sec_l : 

    forall (x : T),

      comp_spec eq RndT (r <-$ RndT; ret (T_op x r)).



    intros.



    eapply (@comp_spec_eq_trans_l _ _ _ _ RndT (x <-$ RndT; ret x)).

    eapply comp_spec_eq_symm.

    eapply comp_spec_right_ident.

  

    eapply comp_spec_seq.

    trivial.

    trivial.

    

    eapply comp_spec_symm.

    eapply (comp_spec_iso (T_op x) (T_op (T_inverse x))); intuition.

    rewrite <- op_assoc.

    rewrite inverse_r_ident.

    eauto.

    rewrite <- op_assoc.

    rewrite inverse_l_ident.

    eauto.



    eapply all_in_support; eauto. 



    intuition.

    subst.

    eapply comp_spec_eq_refl.

    

  Qed.



  Theorem OTP_inf_th_sec_r : 

    forall (x : T),

      comp_spec eq RndT (r <-$ RndT; ret (T_op r x)).



    intros.



    eapply (@comp_spec_eq_trans_l _ _ _ _ RndT (x <-$ RndT; ret x)).

    eapply comp_spec_eq_symm.

    eapply comp_spec_right_ident.



    eapply comp_spec_seq.

    trivial.

    trivial.

 

    eapply comp_spec_symm.

    eapply (comp_spec_iso (fun b => T_op b x) (fun b => T_op b (T_inverse x))); intuition.

    rewrite op_assoc.

    rewrite inverse_l_ident.

    eauto.

    rewrite op_assoc.

    rewrite inverse_r_ident.

    eauto.



    eapply all_in_support; eauto.



    intuition.

    subst.

    eapply comp_spec_eq_refl.



  Qed.



End OTP.



Section xor_OTP.



  Variable n : nat.



  Theorem xor_OTP: 

    forall (x : Bvector n),

      comp_spec eq (Rnd n) (r <-$ Rnd n; ret (BVxor n x r)).



    eapply OTP_inf_th_sec_l; intuition.

    eapply BVxor_assoc.

    eapply BVxor_same_id.

    eapply BVxor_same_id.

    eapply BVxor_id_l.



    eapply comp_spec_rnd.

   

  Qed.



  Theorem xor_OTP_eq: 

    forall (x y : Bvector n),

       evalDist (r <-$ Rnd n; ret (BVxor n x r)) y ==

       evalDist (Rnd n) y.



    intuition.

    symmetry.

    eapply comp_spec_eq_impl_eq.

    eapply xor_OTP.



  Qed.



End xor_OTP.



Require Import FCF.RndNat.
(* FCF.RndNat:
Set Implicit Arguments.

Require Import FCF.Crypto.
Require Import Permutation.
Require Import FCF.NotationV1.
  
Definition RndNat_unchecked(n : nat) :=
  v <-$ {0,1} ^ (lognat n);
  let n := (bvToNat v) in
    ret n.

Definition ltNatBool := fun x1 x2 => if (lt_dec x1 x2) then true else false.

Definition RndNat(n : nat) :=
    (Repeat (RndNat_unchecked n) (fun x => (ltNatBool x n))).

Notation "[ 0 '..' n )" := (RndNat n)
  (right associativity, at level 77) : comp_scope.

Lemma well_formed_RndNat : forall n,
  n > O ->
  well_formed_comp (RndNat n).

Lemma RndNat_support_lt : forall n x,
  In x (getSupport (RndNat n)) ->
  x < n.

Hint Resolve well_formed_RndNat : wftac.

Lemma RndNat_unchecked_lt_support : forall n v,
  v < n ->
  In v (getSupport (RndNat_unchecked n)).

Local Open Scope rat_scope.

Lemma RndNat_uniform : forall v1 v2 n,
  v1 < n ->
  v2 < n -> 
  evalDist (RndNat n) v1 == evalDist (RndNat n) v2.

Lemma in_getSupport_RndNat : forall x k,
  x < k ->
  In x (getSupport (RndNat k)).

Lemma RndNat_support_length : 
  forall n, 
    length (getSupport (RndNat n)) = n.

Theorem RndNat_prob : 
  forall n i (nzn : nz n),
    i < n ->
    evalDist (RndNat n) i == 1 / n.

Theorem RndNat_seq : 
  forall (n : posnat)(A : Set)(c : nat -> Comp A) a,
    evalDist (x <-$ RndNat n; c x) a ==
    (1 / n) * sumList (allNatsLt n) (fun z => evalDist (c z) a).

Lemma rndNat_sumList : 
  forall (A : Set)(f : nat -> Comp A) n (nzn : nz n) x,
    evalDist (i <-$ RndNat n; f i) x == 
    sumList (forNats n) (fun i => (1 / n) * (evalDist (f i) x)). *)

Require Import FCF.RndGrpElem.
(* FCF.RndGrpElem:
Require Import FCF.FCF.
Require Export FCF.GroupTheory.

Local Open Scope group_scope.

Definition RndGrpElem`{FCG : FiniteCyclicGroup}{eqd : EqDec GroupElement} :=
    n <-$ [0 .. order);
    ret (g^n).

Section RndGrpElem.

  Context`{FCG : FiniteCyclicGroup}.
  Hypothesis GroupElement_EqDec : EqDec GroupElement. 

  Theorem RndGrpElem_wf : well_formed_comp RndGrpElem.

  Theorem groupExp_closed : forall k,
    In (g^k) (getSupport RndGrpElem).

  Theorem RndGrpElem_uniform : forall x y,
    evalDist RndGrpElem x == evalDist RndGrpElem y.

  Theorem RndGrpElem_spec : 
    forall x y,
      comp_spec (fun a b => a = x <-> b = y) RndGrpElem RndGrpElem.

End RndGrpElem.

Notation "'RndG'" := (RndGrpElem)
  (right associativity, at level 75) : comp_scope. *)



Local Open Scope group_scope.



Section Group_OTP.



  Context`{FCG : FiniteCyclicGroup}.



  Hypothesis GroupElement_EqDec : EqDec GroupElement.

 

  Theorem group_OTP_l : 

    forall (x : GroupElement),

      comp_spec eq (RndG) (r <-$ RndG; ret (groupOp x r)).



    eapply OTP_inf_th_sec_l; intuition.

    

    apply associativity.

    eapply left_inverse.

    eapply right_inverse.

    eapply left_identity.

   

    eapply RndGrpElem_spec.

  Qed.



  Theorem group_OTP_r : 

    forall (x : GroupElement),

      comp_spec eq (RndG) (r <-$ RndG; ret (groupOp r x)).



    eapply OTP_inf_th_sec_r; intuition.

    

    apply associativity.

    eapply left_inverse.

    eapply right_inverse.

    eapply right_identity.

    eapply RndGrpElem_spec.

  Qed.



End Group_OTP.



Hint Resolve RndGrpElem_wf : wftac.

