Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
(* mc_reify.bool_funcs:
Require Import VST.veric.expr.
Require Import VST.veric.SeparationLogic.
Require Import VST.floyd.local2ptree.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import Coq.Bool.Bool.
Require Import Coq.Lists.List.
Require Import mc_reify.clight_expr_eq.

Fixpoint denote_tc_assert_b_norho a:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| tc_orp' a b => orb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| _ => false
end.

Fixpoint denote_tc_assert_b_norho_forgive_isptr a e:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho_forgive_isptr a e)
                       (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_orp' a b => orb (denote_tc_assert_b_norho_forgive_isptr a e)
                     (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_isptr e0 => expr_beq e e0
| _ => false
end.

Lemma denote_tc_assert_b_norho_sound: forall a rho,
  denote_tc_assert_b_norho a = true -> denote_tc_assert a rho.

Lemma denote_tc_assert_b_norho_forgive_isptr_sound: forall a e rho,
  denote_tc_assert_b_norho_forgive_isptr a e = true ->
  isptr (expr.eval_expr e rho) ->

Definition tc_lvalue_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_lvalue Delta e).

Definition tc_expr_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_expr Delta e).

Definition tc_temp_id_b_norho id t Delta e:=
denote_tc_assert_b_norho (typecheck_temp_id id t Delta e).

Definition tc_lvalue_b_norho' Delta e :=
  match e with
  | Ederef e0 t => denote_tc_assert_b_norho_forgive_isptr
                     (typecheck_lvalue Delta e) e0
  | _ => denote_tc_assert_b_norho (typecheck_lvalue Delta e)
  end.

Lemma tc_lvalue_b_sound :
forall e Delta rho,
tc_lvalue_b_norho Delta e = true ->
tc_lvalue Delta e rho .

Lemma tc_expr_b_sound :
forall e Delta rho,
tc_expr_b_norho Delta e = true ->
tc_expr Delta e rho .

Lemma tc_temp_id_b_sound :
forall id t Delta e rho,
tc_temp_id_b_norho id t Delta e= true ->
tc_temp_id id t Delta e rho .

Lemma tc_lvalue_b'_sound :
forall e Delta rho,
tc_lvalue_b_norho' Delta e = true ->
isptr (expr.eval_lvalue e rho) ->

Fixpoint tc_efield_b_norho Delta efs :=
  match efs with
  | nil => true
  | eArraySubsc ei :: efs' =>
      (tc_expr_b_norho Delta ei && tc_efield_b_norho Delta efs')%bool
  | eStructField _ :: efs' => tc_efield_b_norho Delta efs'
  | eUnionField _ :: efs' => tc_efield_b_norho Delta efs'
  end.

Lemma tc_efield_b_sound: forall efs Delta rho,
  tc_efield_b_norho Delta efs = true -> tc_efield Delta efs rho.

Definition tc_LR_b_norho Delta e lr :=
  match lr with
  | LLLL => tc_lvalue_b_norho' Delta e
  | RRRR => tc_expr_b_norho Delta e
  end.

Definition type_is_int (e: Clight.expr) : bool :=
  match typeof e with
  | Tint _ _ _ => true
  | _ => false
  end. *)
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Require Export mc_reify.reify.
(* mc_reify.reify:
Require Import MirrorCore.syms.SymEnv.
Require Import MirrorCore.Reify.Reify.
Require Import MirrorCore.Lambda.ExprCore.
Require Import mc_reify.types.
Require Import mc_reify.funcs.
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import VST.floyd.local2ptree.
Require Import mc_reify.bool_funcs.
Require Import mc_reify.set_reif.

Local Notation "x @ y" := (@RApp x y) (only parsing, at level 30).
Local Notation "'!!' x" := (@RExact _ x) (only parsing, at level 25).
Local Notation "'?' n" := (@RGet n RIgnore) (only parsing, at level 25).
Local Notation "'?!' n" := (@RGet n RConst) (only parsing, at level 25).
Local Notation "'#'" := RIgnore (only parsing, at level 0).

Reify Declare Patterns patterns_vst_typ := typ.
Reify Declare Patterns patterns_vst := (ExprCore.expr typ func).
Reify Declare Patterns patterns_vst_hastype := (ExprCore.expr typ func).

Reify Declare Syntax reify_vst_typ :=
{ (@Patterns.CPatterns typ patterns_vst_typ) }.

Reify Declare Typed Table term_table : BinNums.positive => reify_vst_typ.

Reify Declare Syntax reify_vst :=
  { (@Patterns.CFirst _
      ((@Patterns.CVar _ (@ExprCore.Var typ func)) ::
       (@Patterns.CPatterns _ patterns_vst) ::
       (@Patterns.CApp _ (@ExprCore.App typ func)) ::
       (@Patterns.CAbs _ reify_vst_typ (@ExprCore.Abs typ func)) ::
       (@Patterns.CPatterns _ patterns_vst_hastype) ::
       (@Patterns.CTypedTable _ _ _ term_table func_defs.Ext) :: nil))
  }.

Reify Pattern patterns_vst_typ += (!!Values.val) => tyval.
Reify Pattern patterns_vst_typ += (@RImpl (?0) (?1)) =>
       (fun (a b : Patterns.function reify_vst_typ) => tyArr a b).

Reify Pattern patterns_vst_typ += (!!floyd.data_at_lemmas.reptype @ ?0) =>
(fun (a : id _) => (reptyp a)).

Reify Pattern patterns_vst_typ += (!!AST.ident) => tyident.
Reify Pattern patterns_vst_typ += (!!expr.environ) => tyenviron.
Reify Pattern patterns_vst_typ += (!!shares.share) => tyshare.
Reify Pattern patterns_vst_typ += (!!shares.Share.t) => tyshare.
Reify Pattern patterns_vst_typ += (!!list @ ?0) =>
       (fun (a : Patterns.function reify_vst_typ) => tylist a).
Reify Pattern patterns_vst_typ += (!!expr.mpred) => tympred.
Reify Pattern patterns_vst_typ += (!!Prop) => typrop.
Reify Pattern patterns_vst_typ += (!!juicy_extspec.OracleKind) => tyOracleKind.
Reify Pattern patterns_vst_typ += (!!bool) => tybool.
Reify Pattern patterns_vst_typ += (!!Integers.Int.int) => tyint.
Reify Pattern patterns_vst_typ += (!!Clight.expr) => tyc_expr.
Reify Pattern patterns_vst_typ += (!!Ctypes.type) => tyc_type.
Reify Pattern patterns_vst_typ += (!!expr.tycontext) => tytycontext.
Reify Pattern patterns_vst_typ += (!!BinNums.Z) => tyZ.
Reify Pattern patterns_vst_typ += (!!Datatypes.nat) => tynat.
Reify Pattern patterns_vst_typ += (!!BinNums.positive) => typositive.
Reify Pattern patterns_vst_typ += (!!expr.tc_assert) => tytc_assert.
Reify Pattern patterns_vst_typ += (!!Integers.comparison) => tycomparison.
Reify Pattern patterns_vst_typ += (!!Integers.int64) => tyint64.
Reify Pattern patterns_vst_typ += (!!Floats.float) => tyfloat.
Reify Pattern patterns_vst_typ += (!!Ctypes.typelist) => tytypelist.
Reify Pattern patterns_vst_typ += (!!Ctypes.fieldlist) => tyfieldlist.
Reify Pattern patterns_vst_typ += (!!Cop.binary_operation) => tybinary_operation.
Reify Pattern patterns_vst_typ += (!!Cop.unary_operation) => tyunary_operation.
Reify Pattern patterns_vst_typ += (!!BinNums.N ) => tyN.
Reify Pattern patterns_vst_typ += (!!option @ ?0) =>
    (fun (a : function reify_vst_typ) => tyoption a).
Reify Pattern patterns_vst_typ += (!!sum @ ?0 @ ?1) =>
    (fun (a b : function reify_vst_typ) => tysum a b).
Reify Pattern patterns_vst_typ += (!!prod @ ?0 @ ?1) =>
    (fun (a b : function reify_vst_typ) => typrod a b).
Reify Pattern patterns_vst_typ += (!!unit) => tyunit.
Reify Pattern patterns_vst_typ += (!!Clight.statement) => tystatement.
Reify Pattern patterns_vst_typ += (!!seplog.ret_assert) => tyret_assert.
Reify Pattern patterns_vst_typ += (!!SeparationLogic.ret_assert) => tyret_assert.

Reify Pattern patterns_vst_typ += (!!(lift.lifted (expr.LiftEnviron Prop))) =>
(tyArr tyenviron typrop).
Reify Pattern patterns_vst_typ += (!!(lift.lifted (expr.LiftEnviron expr.mpred))) =>
(tyArr tyenviron tympred).

Reify Pattern patterns_vst_typ += (!!expr.exitkind) => tyexitkind.

Reify Pattern patterns_vst_typ += (!!Maps.PTree.t @ ?0) =>
(fun (a : function reify_vst_typ) => (typtree a)).
Reify Pattern patterns_vst_typ += (!!floyd.nested_field_lemmas.gfield) => tygfield.
Reify Pattern patterns_vst_typ += (!!expr.funspec) => tyfunspec.
Reify Pattern patterns_vst_typ += (!!floyd.efield_lemmas.efield) => tyefield.
Reify Pattern patterns_vst_typ += (!!floyd.type_id_env.type_id_env) => tytype_id_env.
Reify Pattern patterns_vst_typ += (!!efield_lemmas.LLRR) => tyllrr.

Reify Pattern patterns_vst += (!!BinInt.Z.lt) => (@Inj typ func (inr (Zop fZ_lt))).
Reify Pattern patterns_vst += (!!BinInt.Z.le) => (@Inj typ func (inr (Zop fZ_le))).
Reify Pattern patterns_vst += (!!BinInt.Z.gt) => (@Inj typ func (inr (Zop fZ_gt))).
Reify Pattern patterns_vst += (!!BinInt.Z.ge) => (@Inj typ func (inr (Zop fZ_ge))).
Reify Pattern patterns_vst += (!!BinInt.Z.add) => (@Inj typ func (inr (Zop fZ_add))).
Reify Pattern patterns_vst += (!!BinInt.Z.sub) => (@Inj typ func (inr (Zop fZ_sub))).
Reify Pattern patterns_vst += (!!BinInt.Z.mul) => (@Inj typ func (inr (Zop fZ_mul))).
Reify Pattern patterns_vst += (!!BinInt.Z.div) => (@Inj typ func (inr (Zop fZ_div))).
Reify Pattern patterns_vst += (!!Zdiv.Zmod) => (@Inj typ func (inr (Zop fZ_mod))).
Reify Pattern patterns_vst += (!!BinInt.Z.max) => (@Inj typ func (inr (Zop fZ_max))).
Reify Pattern patterns_vst += (!!BinInt.Z.opp) => (@Inj typ func (inr (Zop fZ_opp))).

Reify Pattern patterns_vst += (!!Integers.Int.add) => (@Inj typ func (inr (Intop fint_add))).
Reify Pattern patterns_vst += (!!Integers.Int.lt) => (@Inj typ func (inr (Intop fint_lt))).
Reify Pattern patterns_vst += (!!Integers.Int.ltu) => (@Inj typ func (inr (Intop fint_ltu))).
Reify Pattern patterns_vst += (!!Integers.Int.mul) => (@Inj typ func (inr (Intop fint_mul))).
Reify Pattern patterns_vst += (!!Integers.Int.neg) => (@Inj typ func (inr (Intop fint_neg))).
Reify Pattern patterns_vst += (!!Integers.Int.sub) => (@Inj typ func (inr (Intop fint_sub))).
Reify Pattern patterns_vst += (!!Integers.Int.cmp) => (@Inj typ func (inr (Intop fint_cmp))).
Reify Pattern patterns_vst += (!!Integers.Int.cmpu) => (@Inj typ func (inr (Intop fint_cmpu))).
Reify Pattern patterns_vst += (!!Integers.Int.repr) => (@Inj typ func (inr (Intop fint_repr))).
Reify Pattern patterns_vst += (!!Integers.Int.signed) => (@Inj typ func (inr (Intop fint_signed))).
Reify Pattern patterns_vst += (!!Integers.Int.unsigned) => (@Inj typ func (inr (Intop fint_unsigned))).
Reify Pattern patterns_vst += (!!Integers.Int.max_unsigned) => (@Inj typ func (inr (Intop fint_max_unsigned))).
Reify Pattern patterns_vst += (!!Integers.Int.repr) => (@Inj typ func (inr (Intop fint_repr))).

Reify Pattern patterns_vst += (!!Values.Vint) => (@Inj typ func (inr (Value fVint))).
Reify Pattern patterns_vst += (!!Values.Vfloat) => (@Inj typ func (inr (Value fVfloat))).
Reify Pattern patterns_vst += (!!Values.Vlong) => (@Inj typ func (inr (Value fVlong))).
Reify Pattern patterns_vst += (!!Values.Vptr) => (@Inj typ func (inr (Value fVptr))).
Reify Pattern patterns_vst += (!!Values.Vundef) => (@Inj typ func (inr (Value fVundef))).
Reify Pattern patterns_vst += (!!expr.eval_cast @ ?0 @ ?1 ) =>
   (fun (a b: id Ctypes.type) => (@Inj typ func (inr (Eval_f (feval_cast a b))))).
Reify Pattern patterns_vst += (!!expr.deref_noload @ ?0 @ ?1) => (fun (a : id Ctypes.type) => (@Inj typ func (inr (Eval_f (fderef_noload a))))).
Reify Pattern patterns_vst += (!!expr.eval_field @ ?0 @ ?1) => (fun (a : id Ctypes.type) (b: id AST.ident) => (@Inj typ func (inr (Eval_f (feval_field a b))))).
Reify Pattern patterns_vst += (!!expr.eval_binop @ ?0 @ ?1 @ ?2) =>
(fun (a : id Cop.binary_operation) (b c : id Ctypes.type) => ((@Inj typ func (inr (Eval_f (feval_binop a b c)))))).
Reify Pattern patterns_vst += (!!expr.eval_unop @ ?0 @ ?1) => (fun (a : id Cop.unary_operation) (b : id Ctypes.type) =>  (@Inj typ func (inr (Eval_f (feval_unop a b))))).
Reify Pattern patterns_vst += (!!expr.eval_id @ ?0) => (fun (a : id AST.ident) => (@Inj typ func (inr (Eval_f (feval_id a))))).

Reify Pattern patterns_vst += (!!Zpower.two_power_nat) =>  (@Inj typ func (inr (Other ftwo_power_nat))).
Reify Pattern patterns_vst += (!!expr.force_ptr) =>  (@Inj typ func (inr (Other fforce_ptr))).
Reify Pattern patterns_vst += (!!and) =>  (@Inj typ func (inr (Other fand))).
Reify Pattern patterns_vst += (!!Coqlib.align) =>  (@Inj typ func (inr (Other falign))).
Reify Pattern patterns_vst += (!!seplog.typed_true) => (@Inj typ func (inr (Other ftyped_true))).
Reify Pattern patterns_vst +=
      (!!@eq @ ?0) => (fun (a : function reify_vst_typ)
                       => @Inj typ func (inr (Other (feq a)))).

Reify Pattern patterns_vst += (!!Clight.typeof) => (@Inj typ func (inr (Other ftypeof))).
Reify Pattern patterns_vst += (!!@Some @ ?0) => (fun (a : function reify_vst_typ) =>
     @Inj typ func (inr (Other (fsome a)))).
Reify Pattern patterns_vst += (!!@None @ ?0) => (fun (a : function reify_vst_typ) =>
     @Inj typ func (inr (Other (fnone a)))).

Reify Pattern patterns_vst +=
      (!!seplog.derives) => (fEntails (func := expr typ func) tympred).
Reify Pattern patterns_vst +=
      (!!seplog.sepcon) => (fStar (func := expr typ func) tympred).
Reify Pattern patterns_vst +=
      (!!seplog.emp) => (mkEmp (func := func) tympred).

Reify Pattern patterns_vst += (!!seplog.TT) => (mkTrue (func := func) tympred).
Reify Pattern patterns_vst += (!!seplog.FF) => (mkFalse (func := func) tympred).
Reify Pattern patterns_vst += (!!seplog.andp) => (fAnd (func := expr typ func) tympred).
Reify Pattern patterns_vst += (!!seplog.orp) => (fOr (func := expr typ func) tympred).
Reify Pattern patterns_vst += (!!SeparationLogic.local) => (@Inj typ func (inr (Sep flocal))).
Reify Pattern patterns_vst += (!!seplog.prop) => (@Inj typ func (inr (Sep fprop))).

Reify Pattern patterns_vst += (!!denote_tc_assert_b_norho) => (@Inj typ func (inr (Smx fdenote_tc_assert_b_norho))).
Reify Pattern patterns_vst += (!!tc_expr_b_norho) => (@Inj typ func (inr (Smx ftc_expr_b_norho))).

Reify Pattern patterns_vst += (!!tc_temp_id_b_norho @ ?0 @ ?1 ) =>
  (fun (a : id positive) (b : id Ctypes.type) =>
     (@Inj typ func (inr (Smx (ftc_temp_id_b_norho a b ))))).

Reify Pattern patterns_vst += (!!SeparationLogic.normal_ret_assert) => (@Inj typ func (inr (Smx fnormal_ret_assert))).
Reify Pattern patterns_vst += (!!seplog.normal_ret_assert) => (@Inj typ func (inr (Smx fnormal_ret_assert))).

Reify Pattern patterns_vst += (!!@SeparationLogicSoundness.SoundSeparationLogic.CSL.semax) => (@Inj typ func (inr (Smx fsemax))).

Reify Pattern patterns_vst += (!!semax.semax) => (@Inj typ func (inr (Smx fsemax))).

Reify Pattern patterns_vst += (!!(@seplog.exp expr.mpred SeparationLogic.Nveric) @ ?0) =>
     (fun (a : function reify_vst_typ) => (fExists (func := expr typ func) a tympred)).

Reify Pattern patterns_vst += (!!(@seplog.allp expr.mpred SeparationLogic.Nveric) @ ?0) =>
     (fun (a : function reify_vst_typ) => (fForall (func := expr typ func) a tympred)).

Reify Pattern patterns_vst +=
      (!!data_at_lemmas.data_at @ ?0 @ ?1) =>
         (fun (a : function reify_vst) (b : id Ctypes.type)  =>
              App (@Inj typ func (inr (Sep (fdata_at b )))) a).

Reify Pattern patterns_vst +=
      (!!sc_set_load_store.proj_val @ ?0) =>
         ((fun (a : id Ctypes.type)  =>
             @Inj typ func (inr (Sep (fproj_val a ))))).

Reify Pattern patterns_vst +=
      (!!sc_set_load_store.upd_val @ ?0) =>
         ((fun (a : id Ctypes.type)  =>
             @Inj typ func (inr (Sep (fupd_val a ))))).

Reify Pattern patterns_vst +=
      (!!@map @ ?0 @ ?1) => (fun (a b: function reify_vst_typ) =>
                          (@Inj typ func (inr (Data (fmap a b))))).

Reify Pattern patterns_vst +=
      (!!@Maps.PTree.empty @ ?0) => (fun (a : function reify_vst_typ) =>
                                       (@Inj typ func (inr (Data (fleaf a))))).

Reify Pattern patterns_vst +=
      (!!@Maps.PTree.get @ ?0 @ ?1) => (fun (a : function reify_vst_typ) (b : id positive) =>
                                         (@Inj typ func (inr (Data (fget a b))))).

Reify Pattern patterns_vst +=
      (!!@Maps.PTree.set @ ?0 @ ?1) => (fun (a : function reify_vst_typ) (b : id positive) =>
                                         (@Inj typ func (inr (Data (fset a b))))).

Reify Pattern patterns_vst +=
      (!!@Maps.PTree.Leaf @ ?0) => (fun (a : function reify_vst_typ) =>
                                 (@Inj typ func (inr (Data (fleaf a))))).

Reify Pattern patterns_vst +=
      (!!@Maps.PTree.Node @ ?0) => (fun (a : function reify_vst_typ) =>
                                 (@Inj typ func (inr (Data (fnode a))))).

Reify Pattern patterns_vst +=
      (!!@nil @ ?0) => (fun (a : function reify_vst_typ) =>
        (@Inj typ func (inr (Data (fnil a))))).

Reify Pattern patterns_vst +=
      (!!@fold_right @ ?0 @ ?1) => (fun (a b: function reify_vst_typ) =>
        (@Inj typ func (inr (Data (ffold_right a b))))).

Reify Pattern patterns_vst +=
      (!!@fold_left @ ?0 @ ?1) => (fun (a b: function reify_vst_typ) =>
        (@Inj typ func (inr (Data (ffold_left a b))))).

Reify Pattern patterns_vst +=
      (!!@cons @ ?0) => (fun (a : function reify_vst_typ) =>
        (@Inj typ func (inr (Data (fcons a))))).

Reify Pattern patterns_vst +=
      (!!@pair @ ?0 @ ?1) => (fun (a b : function reify_vst_typ) =>
        (@Inj typ func (inr (Data (fpair a b))))).

Reify Pattern patterns_vst +=
      (!!@app @ ?0) => (fun (a : function reify_vst_typ) =>
        (@Inj typ func (inr (Data (fappend a))))).

Reify Pattern patterns_vst +=
      (!!@nth_error @ ?0 @ ?1 @ ?2) =>
        (fun (a: function reify_vst_typ) (b: function reify_vst) (c: id nat)=>
        (App (@Inj typ func (inr (Data (fnth_error a c)))) b)).

Reify Pattern patterns_vst +=
      (!!@canon.replace_nth @ ?0 @ ?1) =>
        (fun (a: function reify_vst_typ) (b: id nat)=>
          (@Inj typ func (inr (Data (freplace_nth a b))))).

Reify Pattern patterns_vst +=
      (RHasType AST.ident (?0)) => (fun (a : id AST.ident)
                                       => (@Inj typ func (inr (Const (fident a))))).

Reify Pattern patterns_vst_hastype +=
      (RHasType bool (?0)) => (fun (a : id bool)
                                       => (@Inj typ func (inr (Const (fbool a))))).

Reify Pattern patterns_vst_hastype +=
      (RHasType Ctypes.type (?0)) => (fun (a : id Ctypes.type)
                                       => (@Inj typ func (inr (Const (fCtype a))))).

Reify Pattern patterns_vst +=
      (RHasType expr.environ (?0)) => (fun (a : id expr.environ)
                                       => (@Inj typ func (inr (Smx (fenviron a))))).

Reify Pattern patterns_vst +=
      (RHasType Clight.statement (?0)) => (fun (a : id Clight.statement)
                                       => (@Inj typ func (inr (Smx (fstatement a))))).

Reify Pattern patterns_vst +=
      (RHasType Clight.expr (?0)) => (fun (a : id Clight.expr)
                                       => (@Inj typ func (inr (Const (fCexpr a))))).

Reify Pattern patterns_vst +=
      (RHasType type_id_env.type_id_env (?0)) => (fun (a : id type_id_env.type_id_env)
                                       => (@Inj typ func (inr (Const (fenv a))))).

Reify Pattern patterns_vst +=
      (RHasType efield_lemmas.LLRR (?0)) => (fun (a : id efield_lemmas.LLRR)
                                       => (@Inj typ func (inr (Const (fllrr a))))).

Reify Pattern patterns_vst +=
      (!!expr.update_tycon) => (@Inj typ func (inr (Smx (fupdate_tycon)))).

Reify Pattern patterns_vst +=
(!!expr.mk_tycontext @ ?0 @ ?1 @ ?2 @ ?3 @ ?4) =>
(fun (a : id (Maps.PTree.t (Ctypes.type * bool)))
                                     (b : id (Maps.PTree.t Ctypes.type))
                                     (c : id Ctypes.type)
                                     (d : id (Maps.PTree.t Ctypes.type))
                                     (e : function reify_vst) =>
                             App (@Inj typ func (inr (Smx (ftycontext a b c d)))) e).

Reify Pattern patterns_vst += (RPi (?0) (?1)) => (fun (x : function reify_vst_typ) (y : function reify_vst) =>
  ExprCore.App (fForall (func := expr typ func) x typrop)
               (Abs x y)).

Reify Pattern patterns_vst += (!!localD) => (@Inj typ func (inr (Smx (flocalD)))).

Reify Pattern patterns_vst += (!!assertD) => (@Inj typ func (inr (Smx (fassertD)))).

Reify Pattern patterns_vst += (@RImpl (?0) (?1)) =>
       (fun (a b : Patterns.function reify_vst) => ((App (App (fImpl (func := expr typ func) typrop) a) b))).

Reify Pattern patterns_vst += (!!@ex @ ?0) => (fun (a : Patterns.function reify_vst_typ) => (fExists (func := expr typ func) a typrop )).

Reify Pattern patterns_vst += (!!(@msl.seplog.later veric.expr.mpred SeparationLogic.Nveric _)) => (@Inj typ func (inr (Smx (flater)))).
Reify Pattern patterns_vst += (!!(@msl.seplog.later (veric.expr.environ-> veric.expr.mpred) (@SeparationLogic.LiftNatDed' expr.mpred SeparationLogic.Nveric) _)) => (@Inj typ func (inr (Smx (flater_lift)))).
Reify Pattern patterns_vst += (!!nested_field_lemmas.nested_field_type2) => (@Inj typ func (inr (Smx (fnested_field_type2)))).
Reify Pattern patterns_vst += (!!expr.is_neutral_cast @ ?0 @ ?1) =>
  (fun (a b: id (Ctypes.type)) => App (App (@Inj typ func (inr (Smx (fis_neutral_cast))))
                                           (@Inj typ func (inr (Const (fCtype a)))))
                                      (@Inj typ func (inr (Const (fCtype b))))).
Reify Pattern patterns_vst += (!!msubst_efield_denote @ ?0 @ ?1 @ ?2) =>
  (fun (a b : Patterns.function reify_vst) (e : id (list floyd.efield_lemmas.efield)) =>
     App (App (@Inj typ func (inr (Smx (fmsubst_efield_denote e)))) a) b).

Reify Pattern patterns_vst += (!!efield_lemmas.legal_nested_efield @ ?0 @ ?1 @ ?2 @ ?3 @ ?4 @ ?5) =>
(fun (e t_root e1 gfs: function reify_vst) (tts: id (list Ctypes.type)) (lr: function reify_vst) =>
 (App (App (App (App (App (@Inj typ func (inr (Smx (flegal_nested_efield tts)))) e) t_root) e1) gfs) lr)).

Reify Pattern patterns_vst += (!!tc_LR_b_norho) => (@Inj typ func (inr (Smx (ftc_LR_b_norho)))).
Reify Pattern patterns_vst += (!!SeparationLogic.tc_environ) => (@Inj typ func (inr (Smx (ftc_environ)))).

Reify Pattern patterns_vst += (!!tc_efield_b_norho @ ?0 @ ?1) =>
(fun (a : function reify_vst) (e : id (list floyd.efield_lemmas.efield)) => App (@Inj typ func (inr (Smx (ftc_efield_b_norho e)))) a).

Reify Pattern patterns_vst += (!!efield_lemmas.nested_efield @ ?0 @ ?1 @ ?2) =>
(fun (e1 : id Clight.expr) (efs : id (list floyd.efield_lemmas.efield)) (tts : id (list Ctypes.type)) => (@Inj typ func (inr (Const (fCexpr (efield_lemmas.nested_efield e1 efs tts)))))).

Reify Pattern patterns_vst += (!!SeparationLogic.typeof_temp) => (@Inj typ func (inr (Smx (ftypeof_temp)))).
Reify Pattern patterns_vst += (!!veric.expr.tc_val) => (@Inj typ func (inr (Smx (ftc_val)))).
Reify Pattern patterns_vst += (!!nested_field_lemmas.legal_nested_field) => (@Inj typ func (inr (Smx (flegal_nested_field)))).
Reify Pattern patterns_vst += (!!local2ptree.msubst_eval_LR) => (@Inj typ func (inr (Smx (fmsubst_eval_LR)))).
Reify Pattern patterns_vst += (!!nested_field_lemmas.StructField) => (@Inj typ func (inr (Smx fstruct_field))).
Reify Pattern patterns_vst += (!!nested_field_lemmas.UnionField) => (@Inj typ func (inr (Smx funion_field))).
Reify Pattern patterns_vst += (!!nested_field_lemmas.ArraySubsc) => (@Inj typ func (inr (Smx farray_subsc))).
Reify Pattern patterns_vst += (!!SeparationLogic.writable_share) => (@Inj typ func (inr (Smx fwritable_share))).
Reify Pattern patterns_vst += (!!SeparationLogic.Tsh) => (@Inj typ func (inr (Smx fTsh))).
Reify Pattern patterns_vst += (!!assert_lemmas.Ews) => (@Inj typ func (inr (Smx fEws))).
Reify Pattern patterns_vst += (!!client_lemmas.type_is_by_value) => (@Inj typ func (inr (Smx ftype_is_by_value))).
Reify Pattern patterns_vst += (!!bool_funcs.type_is_int @ ?0) =>
  (fun (e: id Clight.expr) => (@Inj typ func (inr (Const (fbool (bool_funcs.type_is_int e)))))).
Ltac reify_typ trm :=
  let k ee :=
      pose ee
  in
  reify_expr reify_vst_typ k [ True ] [ trm ].

Ltac reify_aux reify term_table e n :=
  let k fs e :=
      pose e as n in
  reify_expr reify k
             [ (fun (y : @mk_dvar_map _ _ _ _ term_table func_defs.elem_ctor) => True) ]
             [ e ].

Ltac reify_vst eee :=
  let k fs eee :=
      pose eee in
  reify_expr reify_vst k
             [ (fun (y : @mk_dvar_map _ _ _  _ term_table func_defs.elem_ctor) => True) ]
             [ eee ].

Ltac get_tbl :=
match goal with
[ t := ?V : FMapPositive.PositiveMap.tree (SymEnv.function RType_typ) |- _ ] => V
end.

Definition reflect_prop' tbl e:= match
func_defs.reflect_prop tbl e with
| Some p => p
| None => False
end.

Ltac do_reify e :=
  let k fs e :=
     (apply e) in
  reify_expr reify_vst k
             [ (fun (y : @mk_dvar_map _ _ _ _ term_table func_defs.elem_ctor) => True) ]
             [ e ].

Goal forall (Delta: expr.tycontext), False.
intros.
reify_vst (data_at_lemmas.data_at SeparationLogic.Tsh Clightdefs.tint).
Abort. *)
Require Export mc_reify.bool_funcs.
(* mc_reify.bool_funcs:
Require Import VST.veric.expr.
Require Import VST.veric.SeparationLogic.
Require Import VST.floyd.local2ptree.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.efield_lemmas.
Require Import Coq.Bool.Bool.
Require Import Coq.Lists.List.
Require Import mc_reify.clight_expr_eq.

Fixpoint denote_tc_assert_b_norho a:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| tc_orp' a b => orb (denote_tc_assert_b_norho a) (denote_tc_assert_b_norho b)
| _ => false
end.

Fixpoint denote_tc_assert_b_norho_forgive_isptr a e:=
match a with
| tc_TT => true
| tc_andp' a b => andb (denote_tc_assert_b_norho_forgive_isptr a e)
                       (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_orp' a b => orb (denote_tc_assert_b_norho_forgive_isptr a e)
                     (denote_tc_assert_b_norho_forgive_isptr b e)
| tc_isptr e0 => expr_beq e e0
| _ => false
end.

Lemma denote_tc_assert_b_norho_sound: forall a rho,
  denote_tc_assert_b_norho a = true -> denote_tc_assert a rho.

Lemma denote_tc_assert_b_norho_forgive_isptr_sound: forall a e rho,
  denote_tc_assert_b_norho_forgive_isptr a e = true ->
  isptr (expr.eval_expr e rho) ->

Definition tc_lvalue_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_lvalue Delta e).

Definition tc_expr_b_norho Delta e :=
denote_tc_assert_b_norho (typecheck_expr Delta e).

Definition tc_temp_id_b_norho id t Delta e:=
denote_tc_assert_b_norho (typecheck_temp_id id t Delta e).

Definition tc_lvalue_b_norho' Delta e :=
  match e with
  | Ederef e0 t => denote_tc_assert_b_norho_forgive_isptr
                     (typecheck_lvalue Delta e) e0
  | _ => denote_tc_assert_b_norho (typecheck_lvalue Delta e)
  end.

Lemma tc_lvalue_b_sound :
forall e Delta rho,
tc_lvalue_b_norho Delta e = true ->
tc_lvalue Delta e rho .

Lemma tc_expr_b_sound :
forall e Delta rho,
tc_expr_b_norho Delta e = true ->
tc_expr Delta e rho .

Lemma tc_temp_id_b_sound :
forall id t Delta e rho,
tc_temp_id_b_norho id t Delta e= true ->
tc_temp_id id t Delta e rho .

Lemma tc_lvalue_b'_sound :
forall e Delta rho,
tc_lvalue_b_norho' Delta e = true ->
isptr (expr.eval_lvalue e rho) ->

Fixpoint tc_efield_b_norho Delta efs :=
  match efs with
  | nil => true
  | eArraySubsc ei :: efs' =>
      (tc_expr_b_norho Delta ei && tc_efield_b_norho Delta efs')%bool
  | eStructField _ :: efs' => tc_efield_b_norho Delta efs'
  | eUnionField _ :: efs' => tc_efield_b_norho Delta efs'
  end.

Lemma tc_efield_b_sound: forall efs Delta rho,
  tc_efield_b_norho Delta efs = true -> tc_efield Delta efs rho.

Definition tc_LR_b_norho Delta e lr :=
  match lr with
  | LLLL => tc_lvalue_b_norho' Delta e
  | RRRR => tc_expr_b_norho Delta e
  end.

Definition type_is_int (e: Clight.expr) : bool :=
  match typeof e with
  | Tint _ _ _ => true
  | _ => false
  end. *)
Require Import mc_reify.set_reif.
(* mc_reify.set_reif:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCore.Lambda.ExprCore.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.

Definition match_reif_option {B: Type} (e: expr typ func) (somef : typ -> expr typ func -> B)
           (nonef : typ -> B) (d : B) :=
match e with
| (App (Inj (inr (Other (fsome t)))) e) => somef t e
| (Inj (inr (Other (fnone t)))) => nonef t
| _ => d
end.

Inductive val_e :=
    Vundef : val_e
  | Vint : int -> val_e
  | Vlong : int64 -> val_e
  | Vfloat : float -> val_e
  | Vsingle : float32 -> val_e
  | Vexpr : expr typ func -> val_e
  | Vunop : Cop.unary_operation -> type ->  val_e -> val_e
  | Vbinop : Cop.binary_operation -> type -> type -> val_e -> val_e -> val_e
  | Veval_cast : type -> type -> val_e -> val_e
  | Vforce_ptr : val_e -> val_e
  | Veval_field : type -> ident -> val_e -> val_e.

Definition Vderef_noload (t: type) (e: val_e) : val_e :=
  match access_mode t with
  | By_reference => e
  | _ => Vundef
  end.

Definition val_e_binarith op ty1 ty2 e1 e2 :=
  match op, ty1, ty2, e1, e2 with
  | Oand, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_land) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_and) e1') e2')
      end
  | Oadd, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_add) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_add) e1') e2')
      end
  | _, _, _, _, _ => App (appR (Eval_f (feval_binop op
                                         ty1 ty2)) e1) e2
  end.

Fixpoint val_e_to_expr (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (appR (Intop fint_repr) (injR (Const (fZ (Int.unsigned i))))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr e)
  | Vbinop op ty1 ty2 e1 e2 => val_e_binarith op ty1 ty2 (val_e_to_expr e1) (val_e_to_expr e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr v)
end.

Definition msubst_var id T2 ty :=
match get_reif id T2 (typrod tyc_type tyval) with
  | App (Inj (inr (Other (fsome t))))
        (App (App (Inj (inr (Data (fpair t1 t2))))
                  (Inj (inr (Const (fCtype ty')))))
             v) =>
    if eqb_type ty ty'
    then Some (Vexpr v)
    else None
  | _ => None
end.

Fixpoint msubst_eval_expr_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option (val_e) :=
  match e with
  | Econst_int i ty => Some (Vint i)
  | Econst_long i ty => Some (Vlong i)
  | Econst_float f ty => Some (Vfloat f)
  | Econst_single f ty => Some (Vsingle f)
  | Etempvar id ty => match get_reif id T1 tyval with
                        | (App (Inj (inr (Other (fsome t)))) v) => Some (Vexpr v)
                        | _ => None
                      end
  | Eaddrof a ty => msubst_eval_lvalue_reif T1 T2 a
  | Eunop op a ty =>  option_map (Vunop op (typeof a)) (msubst_eval_expr_reif T1 T2 a)
  | Ebinop op a1 a2 ty => match (msubst_eval_expr_reif T1 T2 a1), (msubst_eval_expr_reif T1 T2 a2) with
                            | Some v1, Some v2 => Some (Vbinop op (typeof a1) (typeof a2) v1 v2)
                            | _, _ => None
                          end
  | Ecast a ty => option_map (Veval_cast (typeof a) ty) (msubst_eval_expr_reif T1 T2 a)
  | Evar id ty => option_map (Vderef_noload ty) (msubst_var id T2 ty)
  | Ederef a ty => option_map (Vderef_noload ty) (option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a))
  | Efield a i ty => option_map (Vderef_noload ty) (option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a))
  end
with
msubst_eval_lvalue_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option val_e :=
  match e with
  | Evar id ty => (msubst_var id T2 ty)
  | Ederef a ty => option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a)
  | Efield a i ty => option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a)
  | _  => Some Vundef
  end.

Definition rmsubst_eval_expr (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue T1 T2 e
| RRRR => rmsubst_eval_expr T1 T2 e
end.

Fixpoint msubst_efield_denote_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
  match efs with
  | nil => Some (injR (Data (fnil tygfield)))
  | cons (eStructField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx fstruct_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eUnionField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx funion_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eArraySubsc ei) efs0 =>
      match typeof ei, rmsubst_eval_expr T1 T2 ei with
      | Tint _ _ _,
        App (Inj (inr (Other (fsome _))))
         (App (Inj (inr (Value fVint))) i) =>
          match i with
          | App (Inj (inr (Intop fint_repr))) i' =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) i')))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          | _ =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) (appR (Intop fint_unsigned) i))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          end
      | _, _ => None
      end
  end.

Definition rmsubst_efield_denote (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
match msubst_efield_denote_reif T1 T2 efs with
| Some e => some_reif e (tylist tygfield)
| None => none_reif (tylist tygfield)
end.

Lemma Forall_reverse :
forall A P (l: list A),
Forall P l <->
Forall P (rev l).

Lemma in_fst :
forall T T2 (p : T) (v: T2) l,
In (p, v) l -> In p (map fst l).

Lemma elt_eq : forall T l p (v:T) v0 ls,
(p, v0) :: l = rev (PTree.elements (PTree.set p v ls)) ->

Definition tempD' := (fun Q i v => `(eq v) (eval_id i) :: Q).
Definition localD' := (fun Q i tv => `(eq (snd tv)) (eval_var i (fst tv)) :: Q).
Definition LocalD_app (T1: PTree.t val) (T2: PTree.t (type * val)) (Q: list (environ -> Prop)) :=
  (PTree.fold tempD' T1 nil) ++
 (PTree.fold localD' T2 nil) ++ Q.

Lemma localD_app_eq : forall t2 q, PTree.fold localD' t2 q = PTree.fold localD' t2 nil ++ q.

Lemma tempD_app_eq : forall t2 q, PTree.fold tempD' t2 q = PTree.fold tempD' t2 nil ++ q.

Lemma LocalD_app_eq :
forall t1 t2 q,
LocalD t1 t2 q = LocalD_app t1 t2 q.

Lemma fold_right_conj :
forall a b rho,
(fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) (a ++ b) rho) <-> ((fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) a rho /\ fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) b rho)).

Lemma LocalD_to_localD : forall P R t l,
PROPx (P) (LOCALx (LocalD t l []) (SEPx (R))) =
PROPx (P) (LOCALx (localD t l) (SEPx (R))).

Fixpoint val_e_to_expr_std (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (injR (Const (fint i))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr_std e)
  | Vbinop op ty1 ty2 e1 e2 => App (appR (Eval_f (feval_binop op ty1 ty2)) (val_e_to_expr_std e1)) (val_e_to_expr_std e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr_std v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr_std v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr_std v)
end.

Definition rmsubst_eval_expr_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue_std T1 T2 e
| RRRR => rmsubst_eval_expr_std T1 T2 e
end. *)
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
(* mc_reify.update_tycon:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.reify.
Require Import MirrorCore.Lambda.ExprCore.

Definition initialized_temp (id : positive) (t : PTree.t (type * bool)) :=
match (t ! id) with
| Some (ty, _) =>
  PTree.set id (ty, true) t
| None => t
end.

Fixpoint update_temp (t : PTree.t (type * bool)) (s : statement) :=
 match s with
 | Sskip | Scontinue | Sbreak => t
 | Sassign e1 e2 => t 
 | Sset id e2 => (initialized_temp id t)
 | Ssequence s1 s2 => let t' := update_temp t s1 in
                      update_temp t' s2
 | Sifthenelse b s1 s2 => join_te (update_temp t s1) (update_temp t s2)
 | Sloop _ _ => t
 | Sswitch e ls => update_temp_labeled t ls
 | Scall (Some id) _ _ => (initialized_temp id t)
 | _ => t  
end
with update_temp_labeled (t : PTree.t (type * bool)) (ls : labeled_statements) :=
       match ls with
         | LSnil => t
         | LScons _ s ls' =>
           join_te (update_temp t s) (update_temp_labeled t ls')
       end.

Lemma initialized_temp_eq : forall t v r gt gs i,
initialized i (mk_tycontext t v r gt gs) = mk_tycontext (initialized_temp i t) v r gt gs.

Lemma update_temp_eq : forall t v r gt gs s,
update_tycon (mk_tycontext t v r gt gs) s = (mk_tycontext (update_temp t s) v r gt gs)
with
update_temp_labeled_eq : forall t v r gt gs s,
join_tycon_labeled s (mk_tycontext t v r gt gs) = (mk_tycontext (update_temp_labeled t s) v r gt gs). *)
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
(* mc_reify.funcs:
Require Import MirrorCore.syms.SymEnv.
Require Import MirrorCore.Lambda.ExprCore.
Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import VST.floyd_funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import VST.floyd.local2ptree.
Require Import mc_reify.local2list.

Inductive const :=
| fN : nat -> const
| fZ : Z -> const
| fint : int -> const
| fint64 : int64 -> const
| fPos : positive -> const
| fident : ident -> const
| fCtype : type -> const
| fCexpr : expr -> const
| fComparison : comparison -> const
| fbool : bool -> const
| ffloat : float -> const
| ffloat32 : float32 -> const
| fenv : type_id_env -> const
| fllrr : LLRR -> const
.

Definition typeof_const (c : const) : typ :=
 match c with
| fN _ => tynat
| fZ _ => tyZ
| fPos _ => typositive
| fident _ => tyident
| fCtype _ => tyc_type
| fCexpr _ => tyc_expr
| fComparison _ => tycomparison
| fbool _ => tybool
| fint _ => tyint
| fint64 _ => tyint64
| ffloat _ => tyfloat
| ffloat32 _ => tyfloat32
| fenv _ => tytype_id_env
| fllrr _ => tyllrr
end.

Definition constD (c : const)
: typD (typeof_const c) :=
match c with
| fN c | fZ c | fPos c | fident c | fCtype c | fCexpr c | fComparison c | fbool c | fint c
| fint64 c | ffloat c | ffloat32 c | fenv c | fllrr c
                                          => c
end.

Inductive z_op :=
| fZ_lt
| fZ_le
| fZ_gt
| fZ_ge
| fZ_add
| fZ_sub
| fZ_mul
| fZ_div
| fZ_mod
| fZ_land
| fZ_max
| fZ_opp.

Definition typeof_z_op z : typ :=
match z with
| fZ_lt
| fZ_le
| fZ_gt
| fZ_ge => (tyArr tyZ (tyArr tyZ typrop))
| fZ_add
| fZ_sub
| fZ_mul
| fZ_div
| fZ_mod
| fZ_land
| fZ_max => (tyArr tyZ (tyArr tyZ tyZ))
| fZ_opp => (tyArr tyZ tyZ)
end.

Definition z_opD (z : z_op) : typD  (typeof_z_op z) :=
match z with
| fZ_lt => Z.lt
| fZ_le => Z.le
| fZ_gt => Z.gt
| fZ_ge => Z.ge
| fZ_add => Z.add
| fZ_sub => Z.sub
| fZ_mul => Z.mul
| fZ_div => Z.div
| fZ_mod => Zmod
| fZ_land => Z.land
| fZ_max => Z.max
| fZ_opp => Z.opp
end.

Inductive int_op :=
| fint_add
| fint_and
| fint_lt
| fint_ltu
| fint_mul
| fint_neg
| fint_sub
| fint_cmp
| fint_cmpu
| fint_repr
| fint_signed
| fint_unsigned
| fint_max_unsigned
| fint64_repr.

Definition typeof_int_op i : typ :=
match i with
| fint_lt
| fint_ltu => tyArr tyint (tyArr tyint tybool)
| fint_mul
| fint_sub
| fint_add => tyArr tyint (tyArr tyint tyint)
| fint_and => tyArr tyint (tyArr tyint tyint)
| fint_neg => tyArr tyint tyint
| fint_cmp
| fint_cmpu => tyArr tycomparison (tyArr tyint (tyArr tyint tybool))
| fint_repr => tyArr tyZ tyint
| fint_signed
| fint_unsigned  => tyArr tyint tyZ
| fint_max_unsigned => tyZ
| fint64_repr => tyArr tyZ tyint64
end.

Definition int_opD (i : int_op): typD  (typeof_int_op i) :=
match i with
| fint_add => Int.add
| fint_and => Int.and
| fint_lt => Int.lt
| fint_ltu => Int.ltu
| fint_mul => Int.mul
| fint_neg => Int.neg
| fint_sub => Int.sub
| fint_cmp => Int.cmp
| fint_cmpu => Int.cmpu
| fint_repr => Int.repr
| fint_signed => Int.signed
| fint_unsigned => Int.unsigned
| fint_max_unsigned => Int.max_unsigned
| fint64_repr => Int64.repr
end.

Inductive values :=
| fVint
| fVfloat
| fVlong
| fVptr
| fVundef
| fVsingle.

Definition typeof_value (v : values) :=
match v with
| fVint => tyArr tyint tyval
| fVfloat => tyArr tyfloat tyval
| fVlong => tyArr tyint64 tyval
| fVptr => tyArr typositive (tyArr tyint tyval)
| fVsingle => tyArr tyfloat32 tyval
| fVundef => tyval
end.

Definition valueD  (v : values): typD  (typeof_value v) :=
match v with
| fVint => Vint
| fVfloat => Vfloat
| fVlong => Vlong
| fVptr => Vptr
| fVsingle => Vsingle
| fVundef => Vundef
end.

Inductive eval :=
| feval_cast : type -> type -> eval
| fderef_noload : type -> eval
| feval_field : type -> ident -> eval
| feval_binop : binary_operation -> type -> type -> eval
| feval_unop : unary_operation -> type -> eval
| feval_id : ident -> eval.

Definition typeof_eval (e : eval) :=
 match e with
| feval_cast _ _ => (tyArr tyval tyval)
| fderef_noload _ => (tyArr tyval tyval)
| feval_field _ _ => (tyArr tyval tyval)
| feval_binop _ _ _=> (tyArr tyval (tyArr tyval tyval))
| feval_unop _ _ => (tyArr tyval tyval)
| feval_id _  => (tyArr tyenviron tyval)
end.

Definition evalD  (e : eval) : typD  (typeof_eval e) :=
match e with
| feval_id id => eval_id id
| feval_cast t1 t2 => eval_cast t1 t2
| fderef_noload t => deref_noload t
| feval_field t id => eval_field t id
| feval_binop op t1 t2 => eval_binop op t1 t2
| feval_unop op t => eval_unop op t
end.

Inductive other :=
| ftwo_power_nat
| fforce_ptr
| fand
| falign
| ftyped_true
| feq : typ -> other
| fnone : typ -> other
| fsome : typ -> other
| ftypeof
| fTrue
| fFalse
.

Definition typeof_other (o : other) :=
match o with
| ftwo_power_nat => tyArr tynat tyZ
| fforce_ptr  => tyArr tyval tyval
| fand => tyArr typrop (tyArr typrop typrop)
| falign => tyArr tyZ (tyArr tyZ tyZ)
| ftyped_true => tyArr tyc_type (tyArr tyval typrop)
| feq t => tyArr t (tyArr t typrop)
| fnone t => tyoption t
| fsome t => tyArr t (tyoption t)
| ftypeof => tyArr tyc_expr tyc_type
| fTrue | fFalse => typrop
end.

Definition otherD  (o : other) : typD  (typeof_other o) :=
match o with
| ftwo_power_nat => (two_power_nat : typD (typeof_other ftwo_power_nat))
| fforce_ptr => force_ptr
| fand => and
| falign => align
| ftyped_true => typed_true
| feq t => @eq (typD t)
| fsome t => @Some (typD t)
| fnone t => @None (typD t)
| ftypeof => typeof
| fTrue => True
| fFalse => False
end.

Inductive data :=
| fnil : typ -> data
| fmap : typ -> typ -> data
| ffold_right : typ -> typ -> data
| ffold_left : typ -> typ -> data
| fcons : typ -> data
| fappend : typ -> data
| fnth_error : typ -> nat -> data
| freplace_nth : typ -> nat -> data
| fpair : typ -> typ -> data
| fget : typ -> positive -> data
| fset : typ -> positive -> data
| fleaf : typ -> data
| fnode : typ -> data
| fempty : typ -> data
.

Definition typeof_data (l : data) :=
match l with
| fmap a b => tyArr (tyArr a b) (tyArr (tylist a) (tylist b))
| fnil a => (tylist a)
| ffold_right a b => tyArr (tyArr b (tyArr a a)) (tyArr a (tyArr (tylist b) a))
| ffold_left a b => tyArr (tyArr a (tyArr b a)) (tyArr (tylist b) (tyArr a a))
| fcons a => tyArr a (tyArr (tylist a) (tylist a))
| fappend a => tyArr (tylist a) (tyArr (tylist a) (tylist a))
| fnth_error a _ => tyArr (tylist a) (tyoption a)
| freplace_nth a _ => tyArr (tylist a) (tyArr a (tylist a))
| fpair t1 t2 => tyArr t1 (tyArr t2 (typrod t1 t2))
| fleaf t => typtree t
| fnode t => tyArr (typtree t) (tyArr (tyoption t) (tyArr (typtree t) (typtree t)))
| fset t _ => tyArr t (tyArr (typtree t) (typtree t))
| fget t _ => (tyArr (typtree t) (tyoption t))
| fempty t => typtree t
end.

Definition dataD (l : data) : typD (typeof_data l) :=
match l with
| fmap t1 t2 => @map (typD  t1) (typD  t2)
| fnil t => (@nil (typD t) : typD (typeof_data (fnil t)))
| ffold_right a b => @fold_right (typD a) (typD b)
| ffold_left a b => @fold_left (typD a) (typD b)
| fcons a => @cons (typD a)
| fappend a => @app (typD a)
| fnth_error a n => fun l => @nth_error (typD a) l n
| freplace_nth a n => @canon.replace_nth (typD a) n
| fpair a b => ((@pair (typD a) (typD b)) : typD (typeof_data (fpair a b)))
| fleaf t => @PTree.Leaf (typD t)
| fnode t => @PTree.Node (typD t)
| fset t p => @PTree.set (typD t) p
| fget t p => @PTree.get (typD t) p
| fempty t => @PTree.empty (typD t)
end.

Inductive sep :=
| flocal
| fprop
| fdata_at : type -> sep
| ffield_at : type -> list gfield -> sep
| fproj_val : type -> sep
| fupd_val : type -> sep

.

Fixpoint reptyp (ty: type) : typ :=
  match ty with
  | Tvoid => tyunit
  | Tint _ _ _ => tyval
  | Tlong _ _ => tyval
  | Tfloat _ _ => tyval
  | Tpointer t1 a => tyval
  | Tarray t1 sz a => tylist (reptyp t1)
  | Tfunction t1 t2 _ => tyunit
  | Tstruct id fld a => reptyp_structlist fld
  | Tunion id fld a => reptyp_unionlist fld
  | Tcomp_ptr id a => tyval
  end
with reptyp_structlist (fld: fieldlist) : typ :=
  match fld with
  | Fnil => tyunit
  | Fcons id ty fld' =>
    if is_Fnil fld'
      then reptyp ty
      else typrod (reptyp ty) (reptyp_structlist fld')
  end
with reptyp_unionlist (fld: fieldlist) : typ :=
  match fld with
  | Fnil => tyunit
  | Fcons id ty fld' =>
    if is_Fnil fld'
      then reptyp ty
      else tysum (reptyp ty) (reptyp_unionlist fld')
  end.

Definition typeof_sep (s : sep) : typ :=
match s with
| fdata_at t => tyArr tyshare (tyArr (reptyp t) (tyArr tyval tympred))
| ffield_at t gfs => tyArr tyshare (tyArr (reptyp (nested_field_type2 t gfs)) (tyArr tyval tympred))

| flocal => tyArr (tyArr tyenviron typrop) (tyArr tyenviron tympred)
| fprop => tyArr typrop tympred
| fproj_val t => tyArr (tylist tygfield)
                 (tyArr (reptyp t) tyval)
| fupd_val t => tyArr (tylist tygfield)
                 (tyArr (reptyp t)
                  (tyArr tyval (reptyp t)))
end.

Definition proj1T {A} {B} (x: A /\ B) :=
  match x with
  | conj y z => y
  end.

Definition proj2T {A} {B} (x: A /\ B) :=
  match x with
  | conj y z => z
  end.

Definition typD_reptyp_reptype: forall t, typD  (reptyp t) = reptype t.

Definition reptyp_reptype ty (v: typD  (reptyp ty)): reptype ty :=
  eq_rect_r (fun x => x) v (eq_sym (typD_reptyp_reptype ty)).

Definition reptype_reptyp ty (v: reptype ty): typD  (reptyp ty) :=
  eq_rect_r (fun x => x) v (typD_reptyp_reptype ty).

Lemma reptyp_reptype_reptype_reptyp: forall t v, reptyp_reptype t (reptype_reptyp t v) = v.

Definition sepD  (s : sep) : typD  (typeof_sep s).

Inductive smx :=
| fenviron : environ -> smx
| fsemax
| fstatement : statement -> smx
| fretassert : ret_assert -> smx
| ftycontext : PTree.t (type * bool) -> PTree.t type -> type -> PTree.t type ->  smx
| fupdate_tycon

| fnormal_ret_assert

| fassertD
| flocalD
| fvaltree : PTree.t val -> smx
| fdenote_tc_assert_b_norho
| ftc_expr_b_norho
| ftc_temp_id_b_norho : positive -> type ->  smx

| flater
| flater_lift
| fnested_field_type2
| fis_neutral_cast
| fmsubst_efield_denote : list efield -> smx
| flegal_nested_efield : list type -> smx
| fmsubst_eval_LR
| ftc_LR_b_norho
| ftc_environ
| ftc_efield_b_norho : list efield -> smx
| fnested_efield
| ftypeof_temp
| ftc_val
| flegal_nested_field
| fstruct_field
| funion_field
| farray_subsc
| fwritable_share
| fTsh
| fEws
| ftype_is_by_value
.

Definition typeof_smx (t : smx) :=
match t with
| fsemax => tyArr tyOracleKind (tyArr tytycontext (tyArr (tyArr tyenviron tympred) (tyArr tystatement (tyArr tyret_assert typrop))))
| fstatement s => tystatement
| fretassert r => tyret_assert
| ftycontext _ _ _ _ => tyArr (typtree tyfunspec) tytycontext

| fnormal_ret_assert => tyArr (tyArr tyenviron tympred) (tyret_assert)
| fenviron e => tyenviron
| flocalD  => tyArr (typtree tyval)
                    (tyArr (typtree (typrod tyc_type tyval)) (tylist (tyArr tyenviron typrop)))
| fupdate_tycon => tyArr tytycontext (tyArr tystatement tytycontext)
| fvaltree t => typtree tyval
| fassertD => tyArr  (tylist typrop) (tyArr (tylist (tyArr tyenviron typrop)) (tyArr (tylist tympred) (tyArr tyenviron tympred)))
| fdenote_tc_assert_b_norho => tyArr tytc_assert tybool
| ftc_expr_b_norho => tyArr tytycontext (tyArr tyc_expr tybool)
| ftc_temp_id_b_norho _ _  => tyArr tytycontext (tyArr tyc_expr tybool)

| flater => tyArr tympred tympred
| flater_lift => tyArr (tyArr tyenviron tympred) (tyArr tyenviron tympred)
| fnested_field_type2 => tyArr tyc_type (tyArr (tylist tygfield) tyc_type)
| fis_neutral_cast => tyArr tyc_type (tyArr tyc_type tybool)
| fmsubst_efield_denote _ => tyArr (typtree tyval)
                           (tyArr (typtree (typrod tyc_type tyval))
                                 (tyoption (tylist tygfield)))
| flegal_nested_efield _ => tyArr tytype_id_env
                          (tyArr tyc_type
                           (tyArr tyc_expr
                            (tyArr (tylist tygfield)
                              (tyArr tyllrr tybool))))
| fmsubst_eval_LR => tyArr (typtree tyval)
                     (tyArr (typtree (typrod tyc_type tyval))
                      (tyArr tyc_expr
                       (tyArr tyllrr (tyoption tyval))))
| ftc_LR_b_norho => tyArr tytycontext (tyArr tyc_expr (tyArr tyllrr tybool))
| ftc_environ => tyArr tytycontext (tyArr tyenviron typrop)
| ftc_efield_b_norho efs => tyArr tytycontext tybool
| fnested_efield => tyArr tyc_expr
                    (tyArr (tylist tyefield)
                     (tyArr (tylist tyc_type) tyc_expr))
| ftypeof_temp => tyArr tytycontext (tyArr tyident (tyoption tyc_type))
| ftc_val => tyArr tyc_type (tyArr tyval typrop)
| flegal_nested_field => tyArr tyc_type (tyArr (tylist tygfield) typrop)
| fstruct_field => tyArr tyident tygfield
| funion_field => tyArr tyident tygfield
| farray_subsc => tyArr tyZ tygfield
| fwritable_share => tyArr tyshare typrop
| fTsh => tyshare
| fEws => tyshare
| ftype_is_by_value => tyArr tyc_type tybool
end.

Definition smxD (t : smx) : typD (typeof_smx t) :=
match t with
| fsemax => (@semax : typD (typeof_smx fsemax))
| fstatement s | fretassert s  => s
| ftycontext t v r gt => fun gf => mk_tycontext t v r gt gf

| fnormal_ret_assert => normal_ret_assert
| fenviron e => (e : typD (typeof_smx (fenviron e)))
| flocalD => localD
| fupdate_tycon => update_tycon
| fvaltree t => t
| fassertD => assertD
| fdenote_tc_assert_b_norho => (denote_tc_assert_b_norho : typD (typeof_smx fdenote_tc_assert_b_norho))
| ftc_expr_b_norho => tc_expr_b_norho
| ftc_temp_id_b_norho id ty  => tc_temp_id_b_norho id ty

| flater => later
| flater_lift => later
| fnested_field_type2 => nested_field_type2
| fis_neutral_cast => is_neutral_cast
| fmsubst_efield_denote efs => (fun T1 T2 => msubst_efield_denote T1 T2 efs)
| flegal_nested_efield tts => (fun e t_root e1 gfs => legal_nested_efield e t_root e1 gfs tts)
| fmsubst_eval_LR => msubst_eval_LR
| ftc_LR_b_norho => tc_LR_b_norho
| ftc_environ => tc_environ
| ftc_efield_b_norho efs => (fun tycon => tc_efield_b_norho tycon efs)
| fnested_efield => nested_efield
| ftypeof_temp => typeof_temp
| ftc_val => tc_val
| flegal_nested_field => legal_nested_field
| fstruct_field => StructField
| funion_field => UnionField
| farray_subsc => ArraySubsc
| fwritable_share => writable_share
| fTsh => SeparationLogic.Tsh
| fEws => assert_lemmas.Ews
| ftype_is_by_value => client_lemmas.type_is_by_value
end.

Inductive func' :=
| Const : const -> func'
| Zop : z_op -> func'
| Intop : int_op -> func'
| Value : values -> func'
| Eval_f : eval -> func'
| Other : other -> func'
| Sep : sep -> func'
| Data : data -> func'
| Smx : smx -> func'.

Definition func := (SymEnv.func + @ilfunc typ + @bilfunc typ + func')%type.

Definition typeof_func (f: func') : typ :=
match f with
| Const c => typeof_const c
| Zop z => typeof_z_op z
| Intop i => typeof_int_op i
| Value v => typeof_value v
| Eval_f e => typeof_eval e
| Other o => typeof_other o
| Sep s => typeof_sep s
| Data l => typeof_data l
| Smx t => typeof_smx t
end.

Definition funcD  (f : func') : typD  (typeof_func f) :=
match f with
| Const c => constD  c
| Zop z => z_opD  z
| Intop i => int_opD  i
| Value v => valueD  v
| Eval_f e => evalD  e
| Other o => otherD  o
| Sep s => sepD  s
| Data l => dataD l
| Smx t => smxD t
end. *)
Require Import mc_reify.types.
(* mc_reify.types:
Require Import MirrorCore.Lambda.ExprCore.

Require Import VST.floyd_funcs.

Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import Coq.FSets.FMapPositive.

Inductive typ :=
| tyArr : typ -> typ -> typ
| tytycontext
| tyc_expr
| tyc_type
| tyenviron
| tyval
| tyshare
| tyident
| tylist : typ -> typ
| tyint
| tyZ
| tynat
| typositive
| tybool
| tycomparison
| tytc_assert
| tyint64
| tyfloat
| tyfloat32
| tyattr
| tysignedness
| tyintsize
| tyfloatsize
| tytypelist
| tyfieldlist
| tybinary_operation
| tyunary_operation
| tyN
| tyoption : typ -> typ
| typrop
| tympred
| tysum : typ -> typ -> typ
| typrod : typ -> typ -> typ
| tyunit

| tyOracleKind
| tystatement
| tyret_assert
| tyexitkind
| typtree : typ -> typ
| tygfield
| tyfunspec
| tyefield
| tytype_id_env
| tyllrr

.

Fixpoint typD (t : typ) : Type :=
    match t with
        | tyArr a b => typD a  -> typD b
        | tytycontext => tycontext
        | tyc_expr => expr
        | tyc_type => type
        | tyenviron => environ
        | tyval => val
        | tyshare => share
        | tyident => ident
        | tylist t => list (typD t )
        | tyint => int
        | tyZ => Z
        | tynat => nat
        | typositive => positive
        | tybool => bool
        | tycomparison => comparison
        | tytc_assert => tc_assert
        | tyint64 => int64
        | tyfloat => float
        | tyfloat32 => float32
        | tyattr => attr
        | tysignedness => signedness
        | tyintsize => intsize
        | tyfloatsize  => floatsize
        | tytypelist => typelist
        | tyfieldlist => fieldlist
        | tybinary_operation => Cop.binary_operation
        | tyunary_operation => Cop.unary_operation
        | tyN => N
        | tyoption t => option (typD t )
        | typrop => Prop
        | tympred => mpred
        | tysum t1 t2 => sum (typD  t1 ) (typD  t2 )
        | typrod t1 t2 => prod (typD  t1 ) (typD  t2 )
        | tyunit => unit
        
        | tyOracleKind => OracleKind
        | tystatement => statement
        | tyret_assert => ret_assert

        | tyexitkind => exitkind
        | typtree t => PTree.t (typD t)
        | tygfield => gfield
        | tyfunspec => funspec
        | tyefield => efield
        | tytype_id_env => type_id_env
        | tyllrr => LLRR
    end.

Definition typ_eq_dec : forall a b : typ, {a = b} + {a <> b}.

Instance Typ0_tyProp : Typ0 _ Prop :=
{| typ0 := typrop
 ; typ0_cast :=  eq_refl
 ; typ0_match := fun T  t =>
                   match t as t
                         return T Prop -> T (TypesI.typD  t) -> T (TypesI.typD  t)
                   with
                     | typrop => fun tr _ => tr
                     | _ => fun _ fa => fa
                   end
 |}. *)
Require Export mc_reify.reflexivity_tacs.
(* mc_reify.reflexivity_tacs:
Require Import mc_reify.func_defs.
Require Import mc_reify.list_ctype_eq.
Require Import mc_reify.get_set_reif.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCore.Lemma.
Require Import MirrorCore.RTac.Core.

Require Import mc_reify.update_tycon.
Require Import mc_reify.set_reif.
Require Import mc_reify.nth_reif.
Require Import mc_reify.solve_exprD.
Require Import ExtLib.Tactics.
Require Import MirrorCore.Lambda.ExprDsimul.
Require Import get_set_reif_soundness.
Import ExprDenote.

Section tbled.

Existing Instance SubstUpdate_ctx_subst.

Variable tbl : SymEnv.functions RType_typ.

Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Let RSym_sym := RSym_sym tbl.

Ltac solve_exprD := solve_exprD.solve_exprD tbl.
Opaque type_cast.

Definition AFTER_SET_LOAD : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App
      (App (App (Inj (inr (Smx fassertD))) P)
         (App
            (App (Inj (inr (Smx flocalD)))
               (App
                  (App (Inj (inr (Data (fset tyval id))))
                     v) T1)) T2)) R =>
    let l' :=
    App
      (App (App (Inj (inr (Smx fassertD))) P)
         (App
            (App (Inj (inr (Smx flocalD)))
                  (set_reif id v T1 tyval)) T2)) R
    in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Lemma AFTER_SET_LOAD_sound : rtac_sound AFTER_SET_LOAD.

Definition AFTER_STORE : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App
      (App (App (Inj (inr (Smx fassertD))) P) Q)
      (App
         (App (Inj (inr (Data (freplace_nth tympred n)))) R) Rn) =>
    let l' :=
    App
      (App (App (Inj (inr (Smx fassertD))) P) Q)
      (rreplace_nth tympred n R Rn)
    in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Lemma AFTER_STORE_sound : rtac_sound AFTER_STORE.

Definition REFLEXIVITYTAC : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l r ty s with
    | Some su => RTac.Core.Solved su
    | None =>  RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Lemma REFLEXIVITYTAC_sound  :
rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) REFLEXIVITYTAC.

Definition REFLEXIVITY := REFLEXIVITYTAC.

Definition REFLEXIVITYTAC_msubst : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App
      (App
         (App
            (App (Inj (inr (Smx fmsubst_eval_LR))) T1) T2)
         (Inj (inr (Const (fCexpr e1)))))
      (Inj (inr (Const (fllrr lr)))) =>
    let l' := rmsubst_eval_LR T1 T2 e1 lr in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Definition REFLEXIVITY_MSUBST := REFLEXIVITYTAC_msubst.

Definition REFLEXIVITYTAC_msubst_efield : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App (App (Inj (inr (Smx (fmsubst_efield_denote e)))) T1) T2 =>
    let l' := rmsubst_efield_denote T1 T2 e in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Definition REFLEXIVITY_MSUBST_EFIELD := REFLEXIVITYTAC_msubst_efield.

Definition REFLEXIVITYTAC_nth_error : rtac typ (expr typ func) :=
fun tus tvs n m c s e =>
  match e with
| (App (App (Inj (inr (Other (feq ty)))) l) r) =>
  match l with
  | App (Inj (inr (Data (fnth_error ty n)))) xs =>
    let l' := rnth_error ty xs n in
    match @exprUnify (ctx_subst c) typ func _ _ _ _ _ 3
                                 tus tvs 0 l' r ty s with
    | Some s => RTac.Core.Solved s
    | None =>  RTac.Core.Fail
    end
  | _ => RTac.Core.Fail
  end
| _ => RTac.Core.Fail
end.

Definition REFLEXIVITY_NTH_ERROR := REFLEXIVITYTAC_nth_error.

Definition REFLEXIVITY_DENOTE (rtype : typ) {H: @RelDec.RelDec (typD rtype) eq}
{H0: RelDec.RelDec_Correct H} tbl : rtac typ (expr typ func) :=
   fun tus tvs lus lvs c s e => (
match e with
| (App (App (Inj (inr (Other (feq _)))) l) r) =>
  match func_defs.reflect tbl nil nil l rtype, func_defs.reflect tbl nil nil r rtype with
  | Some v1, Some v2 => if @RelDec.rel_dec _ eq H v1 v2 then Solved s else Fail
  | _, _ => Fail
  end
| _ => Fail
end).

Lemma REFLEXIVITY_DENOTE_sound (rtype : typ) {H: @RelDec.RelDec (typD rtype) eq}
{H0: RelDec.RelDec_Correct H}:
rtac_sound (REFLEXIVITY_DENOTE rtype tbl).
unfold rtac_sound.
intros.
unfold REFLEXIVITY_DENOTE in H1.
repeat (match type of H1 with
          | match ?g with _ => _ end = _ => destruct g eqn:?;
                      try solve [simpl in H; subst;
                      try apply rtac_spec_Fail]
        end).
subst. simpl. intros.
split.
unfold func_defs.reflect, exprD in *. simpl in *.
solve_exprD.
forward. split. reflexivity.
intros.
unfold propD, exprD'_typ0 in *.  simpl in H4.
solve_exprD.
unfold exprT_App. simpl.
eapply Pure_pctxD. eauto.
intros.
unfold func_defs.reflect, exprD in *. simpl in *.
forward. inv_some.
inversion H0. rewrite rel_dec_correct in Heqb.
generalize (ExprFacts.exprD'_weaken    _ _ _ (getUVars ctx) (getVars ctx)  H4).
generalize (ExprFacts.exprD'_weaken    _ _ _ (getUVars ctx) (getVars ctx)  H5).

Definition REFLEXIVITY_BOOL := REFLEXIVITY_DENOTE tybool.

Definition REFLEXIVITY_BOOL_sound := REFLEXIVITY_DENOTE_sound tybool.

Definition REFLEXIVITY_CEXPR := REFLEXIVITY_DENOTE tyc_expr.

Definition REFLEXIVITY_CEXPR_sound := REFLEXIVITY_DENOTE_sound tyc_expr.

Definition REFLEXIVITY_CTYPE := REFLEXIVITY_DENOTE (tyc_type).

Definition REFLEXIVITY_CTYPE_sound := REFLEXIVITY_DENOTE_sound (tyc_type).

Instance RelDec_op_ctypes_beq : @RelDec.RelDec (option Ctypes.type) eq :=
  Option.RelDec_eq_option RelDec_ctype_beq.

Instance RelDec_Correct_op_ctypes_beq : RelDec.RelDec_Correct RelDec_op_ctypes_beq :=
  Option.RelDec_Correct_eq_option RelDec_Correct_ctype_beq.

Definition REFLEXIVITY_OP_CTYPE := REFLEXIVITY_DENOTE (tyoption tyc_type).

Definition REFLEXIVITY_OP_CTYPE_sound := REFLEXIVITY_DENOTE_sound (tyoption tyc_type).

End tbled. *)
Require Import mc_reify.get_set_reif.
(* mc_reify.get_set_reif:
Require Import  Coq.Numbers.BinNums.
Require Import compcert.lib.Maps.
Require Import mc_reify.func_defs.
Locate expr.
Definition as_tree (e : expr typ func) : option
  ((typ * expr typ func * expr typ func * expr typ func) + typ) :=
match e with
  | (App (App (App (Inj (inr (Data (fnode t)))) l) o) r) =>
    Some (inl (t, l, o, r))
  | (Inj (inr (Data (fleaf t)))) =>
    Some (inr t)
  | _ => None
end.

Fixpoint set_reif (i : positive) (v : expr typ func) (m : expr typ func) (ty : typ) :  expr typ func :=
match (as_tree m) with
  | Some (inl (t,l,o,r)) =>
    match i with
      | xH => node l (some_reif v t) r ty
      | xO ii => node (set_reif ii v l ty) o r t
      | xI ii => node l o (set_reif ii v r ty) t
    end
  | Some (inr t) =>
    match i with
      | xH => node (leaf t) (some_reif v t) (leaf t) ty
      | xO ii => node (set_reif ii v (leaf t) ty) (none_reif t) (leaf t) t
      | xI ii => node (leaf t) (none_reif t) (set_reif ii v (leaf t) ty) t
    end
  | _ => (App (App (Inj (inr (Data (fset ty i)))) v) m)
end.

Fixpoint get_reif (i : positive) (m : expr typ func) ty :  expr typ func :=
match (as_tree m) with
  | Some (inl (t,l,o,r)) =>
    match i with
      | xH => o
      | xO ii => get_reif ii l ty
      | xI ii => get_reif ii r ty
    end
  | Some (inr t) => none_reif t
  | _ => (App (Inj (inr (Data (fget ty i))))  m)
end. *)
Require Import mc_reify.func_defs.
(* mc_reify.func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)
Require Import mc_reify.typ_eq.
(* mc_reify.typ_eq:
Require Import types.
Import Coq.Bool.Bool.

Fixpoint typ_beq a b :=
match a, b with
| tytycontext, tytycontext
| tyc_expr, tyc_expr
| tyc_type, tyc_type
| tyenviron, tyenviron
| tyval, tyval
| tyshare, tyshare
| tyident, tyident
| tyint, tyint
| tyZ, tyZ
| tynat, tynat
| typositive, typositive
| tybool, tybool
| tycomparison, tycomparison
| tytc_assert, tytc_assert
| tyint64, tyint64
| tyfloat, tyfloat
| tyattr, tyattr
| tysignedness, tysignedness
| tyintsize, tyintsize
| tyfloatsize, tyfloatsize
| tytypelist, tytypelist
| tyfieldlist, tyfieldlist
| tybinary_operation, tybinary_operation
| tyunary_operation, tyunary_operation
| tyN, tyN
| typrop, typrop
| tympred, tympred
| tyunit, tyunit
| tyOracleKind, tyOracleKind
| tystatement, tystatement
| tygfield, tygfield
| tyfunspec, tyfunspec
| tyret_assert, tyret_assert => true

| tysum tl1 tr1, tysum tl2 tr2
| typrod tl1 tr1, typrod tl2 tr2
| tyArr tl1 tr1, tyArr tl2 tr2 => andb (typ_beq tl1 tl2) (typ_beq tr1 tr2)
| tyoption t1, tyoption t2 => typ_beq t1 t2
| tylist t1, tylist t2 => typ_beq t1 t2
| _, _ => false
end.

SearchAbout BinPos.Pos.eqb.
Hint Resolve expr.eqb_type_true : beq_sound.
Hint Resolve BinPos.Peqb_true_eq : beq_sound.

Ltac prove_beq_sound :=
try solve [try reflexivity; inversion H];
repeat
match goal with
 | [H : typ_beq _ _ = true |- _ ] => simpl in H; rewrite andb_true_iff in H; destruct H
 | [ |- _ _ _ = _ _ _ ] => try f_equal
 | [ |- _ _  = _ _  ] => try f_equal
 | [H : forall x, _ -> ?a = x |- ?a = _ ] => apply H
end;
auto with beq_sound.

Lemma typ_beq_sound : forall a b, typ_beq a b = true -> a = b. *)
Require Import mc_reify.rtac_base.
(* mc_reify.rtac_base:
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Import MirrorCore.RTac.Then.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.typ_eq.
Require Import mc_reify.func_defs.
Require Import MirrorCore.LemmaApply.
Require Import ExtLib.Tactics.
Require Import MirrorCore.Util.ListMapT.

Definition rtacP := sigT (fun tac: rtac typ (expr typ func) =>
  forall tbl: SymEnv.functions RType_typ, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac).

Definition my_lemma := lemma typ (ExprCore.expr typ func) (ExprCore.expr typ func).

Definition THEN' (r1 r2 : rtac typ (expr typ func)) := THEN r1 (runOnGoals r2).

Definition THEN (r1 r2 : rtac typ (expr typ func)) :=
  THEN' r1 (THEN' (INSTANTIATE typ func) r2).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.

Lemma THEN_sound : forall t1 t2,
rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t1 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t2 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) (THEN t1 t2).
intros. unfold THEN.
unfold THEN'.
apply THEN_sound; auto.
apply runOnGoals_sound; auto;
rtac_derive_soundness.
apply INSTANTIATE_sound.
apply runOnGoals_sound. auto.

Definition APPLY_sound := (@APPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _ _ ).

Definition EAPPLY_sound :=
  (@EAPPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _). 
Lemma APPLY_condition1: vars_to_uvars_spec vars_to_uvars.

Lemma APPLY_condition2:
 forall (subst : Type) (S : Subst subst (expr typ func))
   (SO : SubstOk S) (SU : SubstUpdate subst (expr typ func))
   (SUO : SubstUpdateOk SU SO),
 UnifyI.unify_sound

End tbled.

Definition thenP (t1 t2: rtacP) : rtacP :=
  match t1, t2 with
  | existT tac1 p1, existT tac2 p2 =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
   (THEN tac1 tac2) (fun tbl => THEN_sound tbl _ _ (p1 tbl) (p2 tbl))
  end.

Definition repeatP (n: nat) (t: rtacP) : rtacP :=
  match t with
  | existT tac p =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
        (REPEAT n tac)
        (fun tbl => @REPEAT_sound _ _ _ _ _ (Expr_ok_fs tbl) _ _ _ n _ (p tbl))
  end. *)
Require Import mc_reify.reified_ltac_lemmas.
(* mc_reify.reified_ltac_lemmas:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Lemma mpred_prop_right: forall (P: mpred) (Q: Prop), Q -> P |-- !! Q.

Lemma mpred_now_later: forall (P: mpred), P |-- |> P.

Lemma mpred_derives_refl: forall (P: mpred), P |-- P.

Lemma mpred_semax_post' : forall (R' : environ -> mpred) (Espec : OracleKind)
         (Delta : tycontext) (R P : environ -> mpred)
         (c : statement),
       (forall rho, R' rho |-- R rho) ->
       semax Delta P c (normal_ret_assert R') ->
       semax Delta P c (normal_ret_assert R).

Require Export mc_reify.reify.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.rtac_base.

Definition reify_prop_right: my_lemma.

Definition reify_now_later : my_lemma.

Definition reify_derives_refl : my_lemma.

Definition reify_semax_post' : my_lemma.

Definition writable_Tsh_lemma: my_lemma.

Definition writable_Ews_lemma: my_lemma.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma APPLY_sound_prop_right: rtac_sound (EAPPLY typ func reify_prop_right).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_now_later: rtac_sound (EAPPLY typ func reify_now_later).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_derives_refl: rtac_sound (EAPPLY typ func reify_derives_refl).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_semax_post': rtac_sound (EAPPLY typ func reify_semax_post').
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_writable_Tsh: rtac_sound (APPLY typ func writable_Tsh_lemma).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_writable_Ews: rtac_sound (APPLY typ func writable_Ews_lemma).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

End tbled. *)

Fixpoint rstrip_1_later_sep (R: expr typ func) : expr typ func :=
  match R with
  | Inj (inr (Data (fnil tympred))) => Inj (inr (Data (fnil tympred)))
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    match hd with
    | App (Inj (inr (Smx flater))) hd0 => App (App (Inj (inr (Data (fcons tympred)))) hd0) (rstrip_1_later_sep tl)
    | _ => App (App (Inj (inr (Data (fcons tympred)))) hd) (rstrip_1_later_sep tl)
    end
  | _ => R
  end.

Lemma SEPx_map_liftx: forall R, SEPx (map liftx R) = liftx (fold_right sepcon emp R).
Proof.
  intros.
  extensionality rho.
  unfold_lift; simpl.
  induction R.
  + reflexivity.
  + simpl.
    rewrite <- IHR.
    unfold SEPx.
    simpl.
    reflexivity.
Qed.

Lemma hoist_later_in_pre_aux:
    forall temp var ret gt s
      gs P T1 T2 R R' Post,
  forall {Espec: OracleKind},
      fold_right sepcon emp R |-- |> (fold_right sepcon emp R') ->
      semax (mk_tycontext temp var ret gt gs) (|> (assertD P (localD T1 T2) R')) s (normal_ret_assert Post) ->
      semax (mk_tycontext temp var ret gt gs) (assertD P (localD T1 T2) R) s (normal_ret_assert Post).
Proof.
  intros.
  eapply semax_pre0; [| exact H0].
  unfold assertD.
  apply PROP_later_derives.
  apply LOCAL_later_derives.
  rewrite !SEPx_map_liftx.
  intro.
  unfold_lift; simpl.
  exact H.
Qed.

Lemma fold_right_sepcon_later_derives: forall P P' Q Q' R,
  P |-- |> P' ->
  fold_right sepcon emp Q |-- |> (fold_right sepcon emp Q') ->
  (fold_right sepcon emp (P' :: Q')) = R ->
  fold_right sepcon emp (P :: Q) |-- |> R.
Proof.
  intros.
  subst.
  simpl.
  rewrite later_sepcon.
  apply sepcon_derives; auto.
Qed.

Definition reify_hlip_base (temp : PTree.t (type * bool)) (var : PTree.t type)
         (ret : type) (gt : PTree.t type) (s : statement) : my_lemma.
reify_lemma reify_vst (hoist_later_in_pre_aux temp var ret gt s).
Defined.

Definition reify_hlip_ind : my_lemma.
reify_lemma reify_vst (fold_right_sepcon_later_derives).
Defined.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.
Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Definition solve_hd_in_hlip (hd: expr typ func) : rtac typ (expr typ func) :=
  match hd with
  | App (Inj (inr (Smx flater))) _ => EAPPLY typ func reify_derives_refl
  | _ => EAPPLY typ func reify_now_later
  end.

Fixpoint solve_strip_1_later (R: expr typ func) : rtac typ (expr typ func) :=
  match R with
  | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN (EAPPLY typ func reify_hlip_ind)
     (THEN (TRY (REFLEXIVITY tbl))
           (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
  | _ => FAIL
  end.

Definition HLIP temp var ret gt R s :=
  THEN (EAPPLY typ func (reify_hlip_base temp var ret gt s))
       (TRY (solve_strip_1_later R)).

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma HLIP_sound_aux0: forall temp var ret gt s, rtac_sound (EAPPLY typ func (reify_hlip_base temp var ret gt s)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.
    unfold ExprDsimul.ExprDenote.exprT_App.
    simpl.
    unfold exprT_App, exprT_Inj, Rcast_val, Rcast in *. simpl in *.
    unfold BILogicFunc.typ2_cast_bin in *. simpl in *.
    eapply hoist_later_in_pre_aux; eauto.
Qed.

Lemma HLIP_sound_aux1: rtac_sound (EAPPLY typ func reify_hlip_ind).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.
    unfold ExprDsimul.ExprDenote.exprT_App.
    simpl.
    unfold exprT_App, exprT_Inj, Rcast_val, Rcast in *. simpl in *.
    unfold BILogicFunc.typ2_cast_bin in *. simpl in *.
    eapply fold_right_sepcon_later_derives; eauto.
Qed.

Definition HLIP_sound_aux2 (hd: expr typ func): rtac_sound (solve_hd_in_hlip hd) :=
    match hd as hd'
      return rtac_sound match hd' with
                        | App (Inj (inr (Smx flater))) _ => EAPPLY typ func reify_derives_refl
                        | _ => EAPPLY typ func reify_now_later
                        end
    with
    | App (Inj (inr (Smx flater))) _ => APPLY_sound_derives_refl tbl
    | _ => APPLY_sound_now_later tbl
    end.

Print Forall_cons.
Lemma tttt: Forall (fun x => In x [1; 3; 4]) [1; 3; 4].
constructor; [| constructor; [| constructor; [| constructor]]].
+ left. reflexivity.
+ right. left. reflexivity.
+ right. right. left. reflexivity.
Qed.

Lemma solve_strip_1_later_def: forall R,
  match R with
  | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN (EAPPLY typ func reify_hlip_ind)
     (THEN (TRY (REFLEXIVITY tbl))
           (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
  | _ => FAIL
  end =
  solve_strip_1_later R.
Proof.
  intros.
  repeat
  match goal with
  | [ |- context [match ?e with _ => _ end] ] => destruct e; auto
  end.
Qed. 

Fixpoint solve_strip_1_later_sound (R: expr typ func) : rtac_sound (solve_strip_1_later R) :=
  let res :=
  match R as R'
    return rtac_sound match R' with
                      | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
                      | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
                        THEN (EAPPLY typ func reify_hlip_ind)
                         (THEN (TRY (REFLEXIVITY tbl))
                               (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
                      | _ => FAIL
                      end
  with
  | Inj (inr (Data (fnil tympred))) => APPLY_sound_now_later tbl
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN_sound tbl _ _ HLIP_sound_aux1
     (THEN_sound tbl _ _ (TRY_sound (REFLEXIVITYTAC_sound tbl))
                        (FIRST_sound (Forall_cons _ (HLIP_sound_aux2 hd)
                                       (Forall_cons _ (solve_strip_1_later_sound tl) (Forall_nil _)))))
  | _ => FAIL_sound
  end in
  eq_rect_r rtac_sound res (eq_sym (solve_strip_1_later_def R)). 

Lemma HLIP_sound: forall temp var ret gt R s, rtac_sound (HLIP temp var ret gt R s).
Proof.
  intros.
  unfold HLIP.
  apply THEN_sound.
  + apply HLIP_sound_aux0.
  + apply TRY_sound.
    apply solve_strip_1_later_sound.
Qed.

End tbled.
