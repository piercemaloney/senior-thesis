
Set Implicit Arguments.

Require Import FCF.DistSem.
(* FCF.DistSem:
Set Implicit Arguments.

Require Export FCF.Comp.
Require Export FCF.Rat.
Require Import FCF.Fold.
Require Import List.
Require Import FCF.Blist.
Require Import Omega.
Require Import FCF.StdNat.
Require Import FCF.NotationV1.
 
Local Open Scope list_scope.
Local Open Scope rat_scope.

Ltac simp_in_support := 
  unfold setLet in *;
  match goal with
    | [H : In _ (getSupport (Bind _ _)) |- _ ] =>
      apply getSupport_Bind_In in H; destruct_exists; intuition
    | [H : In _ (getSupport (if ?t then _ else _)) |- _ ] => let x := fresh "x" in remember t as x; destruct x
    | [H : In _ (getSupport (ret _)) |- _ ] => apply getSupport_In_Ret in H; try pairInv; subst

    | [H : true = negb ?t |- _ ] => let x := fresh "x" in remember t as x; destruct x; simpl in H; try discriminate
  end.

Definition Distribution(A : Set) := A -> Rat.

Definition indicator(A : Set)(P : A -> bool) :=
  fun a => if (P a) then rat1 else rat0.

Fixpoint evalDist(A : Set)(c : Comp A) : Distribution A :=
  match c with
    | Ret eqd a => fun a' => if (eqd a a') then 1 else 0
    | Bind c1 c2 => fun a => 
      sumList (getSupport c1) (fun b => (evalDist c1 b) * (evalDist (c2 b) a))
    | Rnd n => fun v => 1 / (expnat 2 n)
    | Repeat c P => fun a => (indicator P a) * (ratInverse (sumList (filter P (getSupport c)) (evalDist c))) * (evalDist c a)
  end.

Definition dist_sem_eq(A : Set)(c1 c2 : Comp A) :=
  forall a, (evalDist c1 a) == (evalDist c2 a).

Definition Support(A : Set)(ls : list A)(d : Distribution A) :=
  NoDup ls /\
  (forall a, In a ls <-> ~((d a) == 0)).

Lemma getSupport_NoDup : forall (A : Set)(c : Comp A),
  NoDup (getSupport c).

Lemma filter_not_In : forall (A : Set)(ls : list A)(P : A -> bool) a,
                        (~In a ls) \/ P a = false <->
                        ~In a (filter P ls).

Theorem getSupport_In_evalDist : forall (A : Set)(c : Comp A)(a : A),
  In a (getSupport c) <-> ~(evalDist c a == 0).

Theorem getSupport_not_In_evalDist_h : forall (A : Set)(c : Comp A)(a : A),
~In a (getSupport c) -> (evalDist c a == 0).

Theorem getSupport_not_In_evalDist : forall (A : Set)(c : Comp A)(a : A),
  ~In a (getSupport c) <-> (evalDist c a == 0).

Theorem getSupport_correct : forall (A : Set)(c : Comp A),
  Support (getSupport c)(evalDist c).

Notation "'Pr' [ c  ] " := (evalDist c true) (at level 20).

Lemma evalDist_sum_bind_eq : forall (A B : Set)(eqdb : eq_dec B)(eqda : eq_dec A)(c1 : Comp B)(c2 : B -> Comp A),
  sumList (getSupport (Bind c1 c2)) (evalDist (Bind c1 c2)) ==
  sumList (getSupport c1) (fun b => evalDist c1 b * (sumList (getSupport (c2 b)) (evalDist (c2 b)))).
  
Lemma ratInverse_scale_sum_1 : forall (A : Set)(ls : list A)(f : A -> Rat),
  (forall a, In a ls -> ~f a == 0) ->
  length ls > O ->
  sumList ls (fun a => (ratInverse (sumList ls f)) * (f a)) == 1.

Lemma evalDist_lossless : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  sumList (getSupport c) (evalDist c) == 1.

Lemma sumList_filter_evalDist_le_1 : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  In a (filter P (getSupport c)) ->
  1 <= sumList (filter (fun a' => negb (P a')) (getSupport c)) (evalDist c) ->
  False.

Theorem sumList_support_bool : 
  forall (c : Comp bool),
    sumList (getSupport c) (evalDist c) ==
    evalDist c true + evalDist c false.
  
Lemma evalDist_sum_le_1 : forall (A : Set)(c : Comp A),
  sumList (getSupport c) (evalDist c) <= 1.

Lemma evalDist_le_1 : forall (A : Set)(c : Comp A) a,
  evalDist c a <= 1.

Theorem evalDist_complement : 
  forall (c : Comp bool),
    well_formed_comp c ->
    evalDist c false == ratSubtract 1 (Pr[c]).

Theorem evalDist_le_1_gen : 
  forall (A : Set)(eqd : EqDec A)(c : Comp A)(ls : list A),
    NoDup ls ->
    sumList ls (evalDist c) <= 1.

Theorem evalDist_1_0 : 
  forall (A : Set){eqd : EqDec A}(c : Comp A) a,
    well_formed_comp c ->
    evalDist c a == 1 ->
      (forall b, b <> a -> evalDist c b == 0).
   
Local Open Scope comp_scope.

Theorem EqDec_pair_l 
  : forall (A B : Set)(eqd : EqDec (A * B))(b : B),
    EqDec A.

Fixpoint evalDist_OC(A B C: Set)(c : OracleComp A B C): forall(S : Set), EqDec S -> (S -> A -> Comp (B * S)) -> S -> Comp (C * S) :=
  match c in (OracleComp A B C) return (forall(S : Set), EqDec S -> (S -> A -> Comp (B * S)) -> S -> Comp (C * S))
    with
    | @OC_Query A' B' a => 
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>  
        o s a
    | @OC_Run A'' B'' C' A' B' S' eqds' eqda'' eqdb'' c' o' s' =>
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>
      p <-$ evalDist_OC c' (pair_EqDec eqds' eqds) (fun x y => p <-$ evalDist_OC (o' (fst x) y) _ o (snd x); ret (fst (fst p), (snd (fst p), snd p))) (s', s);
      Ret 
      (EqDec_dec (pair_EqDec (pair_EqDec 
        (oc_EqDec c' (fun x => fst (oc_base_exists (o' s' x) (fun y => fst (comp_base_exists (o s y))))) (fun x => EqDec_pair_l (oc_EqDec (o' s' x) (fun y => fst (comp_base_exists (o s y))) (fun y => EqDec_pair_l (comp_EqDec (o s y)) s)) s' ))
        _) _ ))
      (fst p, fst (snd p), snd (snd p))

    | @OC_Ret A' B' C' c => 
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>
      x <-$ c; Ret 
      (EqDec_dec (pair_EqDec (comp_EqDec c) _ ))
      (x, s)
    | @OC_Bind A' B' C' C'' c' f' =>
      fun (S : Set)(eqds : EqDec S)(o : S -> A' -> Comp (B' * S))(s : S) =>
      [z, s'] <-$2 evalDist_OC c' _ o s;
      evalDist_OC (f' z) _ o s'
  end.

Coercion evalDist_OC : OracleComp >-> Funclass.

Inductive well_formed_oc : forall (A B C : Set), OracleComp A B C -> Prop :=
| well_formed_OC_Query :
  forall (A B : Set)(a : A),
    well_formed_oc (OC_Query B a)
| well_formed_OC_Run : 
  forall (A B C A' B' S : Set)
  (eqds : EqDec S)(eqdb : EqDec B)(eqda : EqDec A)(c : OracleComp A B C)
  (o : S -> A -> OracleComp A' B' (B * S))(s : S),
  well_formed_oc c ->
  (forall s a, well_formed_oc (o s a)) ->
  well_formed_oc (OC_Run eqds eqdb eqda c o s)
| well_formed_OC_Ret : 
  forall (A B C : Set)(c : Comp C),
      well_formed_comp c ->
      well_formed_oc (OC_Ret A B c)
| well_formed_OC_Bind : 
  forall (A B C C' : Set)(c : OracleComp A B C)(f : C -> OracleComp A B C'),
    well_formed_oc c ->
    (forall c, well_formed_oc (f c)) ->
    well_formed_oc (OC_Bind c f).

Local Open Scope nat_scope.

Definition in_oc_support(A B C : Set)(x : C)(c : OracleComp A B C) :=
  exists (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s s' : S),
    In (x, s') (getSupport (c _ _ o s)).

Inductive queries_at_most : forall (A B C : Set), OracleComp A B C -> nat -> Prop :=
| qam_Bind : 
  forall (A B C C' : Set)(c : OracleComp A B C')(f : C' -> OracleComp A B C) q1 q2,
    queries_at_most c q1 ->
    (forall c',
      in_oc_support c' c ->
       queries_at_most (f c') q2) ->
    queries_at_most (OC_Bind c f) (q1 + q2)
| qam_Query : 
  forall (A B : Set)(a : A),
  queries_at_most (OC_Query B a) 1
| qam_Ret : 
  forall (A B C : Set)(c : Comp C),
    queries_at_most (OC_Ret A B c) 0
| qam_Run :
  forall (A A' B B' C S : Set)(eqds : EqDec S)(eqda : EqDec A)(eqdb : EqDec B)
    (c : OracleComp A B C)(oc : S -> A -> OracleComp A' B' (B * S)) s q1 q2,
    queries_at_most c q1 ->
    (forall s a, queries_at_most (oc s a) q2) ->
    queries_at_most (OC_Run _ _ _ c oc s) (q1 * q2)
| qam_le : 
  forall (A B C : Set)(c : OracleComp A B C) q1 q2,
    queries_at_most c q1 ->
    q1 <= q2 ->
    queries_at_most c q2. *)
Require Import FCF.Fold.
(* FCF.Fold:
Set Implicit Arguments.

Require Import FCF.Rat.
Require Import List.
Require Import Permutation.
Require Import Arith.
Require Import FCF.EqDec.
Require Import FCF.StdNat.
Require Import Bool.

Local Open Scope rat_scope.

Definition unzip(A B : Set)(ls : list (A * B)) :=
  (map (@fst _ _) ls, map (@snd _ _) ls).

Fixpoint zip(A B : Set)(lsa : list A)(lsb : list B) :=
  match lsa with
    | nil => nil
    | a :: lsa' =>
      match lsb with
        | nil => nil
        | b :: lsb' =>
          (a, b) :: (zip lsa' lsb')
      end
  end.

Ltac pairInv := 
  match goal with
    | [H : (_, _) = (_, _) |- _] => 
      inversion H; clear H; subst
  end.

Section RemoveDups.

  Variable A : Set.
  Variable eqd : EqDec A.

  Fixpoint removeDups(ls : list A) :=
    match ls with
      | nil => nil
      | a' :: ls' =>
        if (in_dec (EqDec_dec _) a' ls') then (removeDups ls') else (a' :: (removeDups ls'))
    end.

  Theorem removeDups_in : 
    forall (ls : list A) a,
      In a (removeDups ls) ->
      In a ls.
  
  Theorem removeDups_NoDup :
    forall (ls : list A),
      NoDup (removeDups ls).

  Lemma in_removeDups : 
    forall (ls : list A) a,
      In a ls -> 
      In a (removeDups ls).
     
End RemoveDups.

Section ListReplace.

  Variable A : Set.

  Fixpoint listReplace (ls : list A)(i : nat)(a def : A) :=
    match i with
      | O => 
        match ls with
        | nil => a :: nil
        | a' :: ls' => a :: ls'
        end
      | S i' => 
        match ls with
        | nil => def :: (listReplace nil i' a def)
        | a' :: ls' =>
          a' :: (listReplace ls' i' a def)
        end
    end.

End ListReplace.

Section SumList.

  Variable A : Set.

  Definition sumList(ls : list A)(f : A -> Rat) := fold_left (fun a b => a + (f b)) ls 0.

  Theorem sumList_ne_0 : forall (ls : list A)(f : A -> Rat),
    ~ (sumList ls f) == 0 ->
    exists b : _,
      In b ls /\
      ~ ((f b) == 0).
  Abort.

  Theorem sumList_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    (forall b, (f1 b) == (f2 b)) ->
    (sumList ls1 f1) == (sumList ls2 f2).
  Abort.

  Lemma fold_add_init : forall (ls : list A)(f : A -> Rat) init1 init2,
    fold_left (fun (r : Rat) (a : A) => r + (f a)) ls (init1 + init2) == 
    init1 + (fold_left (fun (r : Rat) (a : A) => r + (f a)) ls init2).

  Lemma fold_add_body_eq : forall (ls : list A)(f1 f2 : A -> Rat) init1 init2,
    init1 == init2 ->
    (forall a, In a ls -> f1 a == f2 a) ->
    fold_left (fun r a => r + (f1 a)) ls init1 == fold_left (fun r a => r + (f2 a)) ls init2.

  Lemma fold_add_rat_perm : forall (ls1 ls2 : list A)(f1 f2 : A -> Rat),
    Permutation ls1 ls2 ->
    forall init1 init2, 
      init1 == init2 ->
      (forall (a : A), In a ls1 -> (f1 a) == (f2 a)) ->
      fold_left (fun r a => r + (f1 a)) ls1 init1 == fold_left (fun r a => r + (f2 a)) ls2 init2.

  Lemma fold_add_f_inverse : forall (B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A) fa init1 init2,
    (init1 == init2) ->
    (forall a, In a ls -> f_inv (f a) = a) ->
    fold_left (fun r b => r + fa (f_inv b)) (map f ls) init1 ==
    fold_left (fun r a => r + (fa a)) ls init2.

   Lemma sumList_0 : forall (ls : list A) f,
    (sumList ls f == 0) <-> (forall a, In a ls -> (f a) == 0).

  Lemma sumList_nz : forall (ls : list A) f,
    (~sumList ls f == 0) <-> exists a : _, In a ls /\ (~f a == 0).

End SumList.

Lemma fold_add_init_0 : forall (A : Set)(ls : list A) f init,
  fold_left (fun r a => r + (f a)) ls init == init + fold_left (fun r a => r + (f a)) ls 0.

Lemma fold_add_eq_init : forall (A : Set)(ls : list A) init,
  fold_left (fun r a => r + 0) ls init == init.

Lemma fold_add_eq_init_f : forall (A : Set)(ls : list A) f init,
  (forall a, In a ls -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls init == init.

Lemma fold_add_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat) init1 init2,
  fold_left (fun r a => r + (f1 a)) ls init1 + 
  fold_left (fun r a => r + (f2 a)) ls init2 ==
  fold_left (fun r a => r + (f1 a + f2 a)) ls (init1 + init2).

Lemma fold_add_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  fold_left (fun r1 a => r1 + (fold_left (fun r2 b => r2 + (f a b)) lsb 0)) lsa 0  == 
  fold_left (fun r1 b => r1 + (fold_left (fun r2 a => r2 + (f a b)) lsa 0)) lsb 0.

Lemma sumList_comm : forall (A B : Set)(lsa : list A)(lsb : list B) f,
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) == 
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma sumList_body_eq : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a == f2 a) ->
  sumList ls f1 == sumList ls f2.

Lemma fold_add_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) init c,
  fold_left (fun r a => r + (f a) * c) ls (init * c) == 
  (fold_left (fun r a => r + (f a)) ls init) * c.
    
Lemma sumList_factor_constant_r : forall (A : Set)(ls : list A)(f : A -> Rat) c,
  sumList ls (fun a => (f a) * c) == (sumList ls f) * c.
    
Lemma sumList_factor_constant_l:
  forall (A : Set) (ls : list A) (f : A -> Rat) (c : Rat),
    sumList ls (fun a : A => c * f a) == c * sumList ls f.

Lemma fold_add_body_const : forall (A : Set)(ls : list A) c init,
  fold_left (fun r a => r + c) ls init == c * (length ls / 1) + init.

Lemma sumList_body_const : forall (A : Set)(ls : list A) c,
  sumList ls (fun a => c) == c * (length ls / 1).

Lemma fold_add_iter_le : forall (A : Set)(ls : list A) f r init,
  fold_left (fun r a => r + (f a)) ls init <= r ->
  init <= r /\ 
  (forall a, In a ls -> f a <= r).

Lemma sumList_iter_le : forall (A : Set)(ls : list A) f r a,
  sumList ls f <= r ->
  In a ls ->
  f a <= r.

Fixpoint removeFirst(A : Set)(eqd : eq_dec A)(ls : list A) a :=
  match ls with
    | nil => nil
    | a' :: ls' =>
      if (eqd a a') then ls' else a' :: (removeFirst eqd ls' a)
  end.

Lemma removeFirst_permutation : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  In a ls ->
  Permutation ls (a :: (removeFirst eqd ls a)).

Lemma removeFirst_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  ~In a1 ls ->
  ~In a1 (removeFirst eqd ls a2).

Lemma removeFirst_NoDup_not_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a : A),
  NoDup ls ->
  ~In a (removeFirst eqd ls a).

Lemma removeFirst_NoDup : forall (A : Set)(eqd : eq_dec A)(ls : list A) a,
  NoDup ls ->
  NoDup (removeFirst eqd ls a).

Lemma removeFirst_in : forall (A : Set)(eqd : eq_dec A)(ls : list A)(a1 a2 : A),
  In a1 ls ->
  a1 <> a2 ->
  In a1 (removeFirst eqd ls a2).

Lemma removeFirst_in_iff : forall (A : Set)(eqd : eq_dec A)(ls : list A) a1 a2,
  In a1 (removeFirst eqd ls a2) ->
  In a1 ls.

Fixpoint matchOrder (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) :=
  match ls1 with
    | nil => ls2
    | a :: ls1' => 
      a :: (matchOrder eqd ls1' (removeFirst eqd ls2 a))
  end.

Lemma matchOrder_In : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 <-> In a (matchOrder eqd ls1 ls2)).

Lemma matchOrder_not_in_h : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  ~In a ls1 -> 
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_not_in : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  (forall a, In a ls1 -> In a ls2) ->
  ~In a ls2 ->
  ~In a (matchOrder eqd ls1 ls2).

Lemma matchOrder_NoDup : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  (forall a, In a ls1 -> In a ls2) ->
  NoDup ls2 ->
  NoDup ls1 ->
  NoDup (matchOrder eqd ls1 ls2).

Require Import Permutation.

Lemma matchOrder_permutation : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  Permutation ls2 (matchOrder eqd ls1 ls2).

Lemma matchOrder_firstn : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  firstn (length ls1) (matchOrder eqd ls1 ls2) = ls1.

Lemma fold_add_matchOrder : forall (A : Set)(ls : list A)(f : A -> Rat) n init1 init2,
  init1 == init2 ->
  NoDup ls ->
  (forall a, In a ls -> (~In a (firstn n ls)) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) (firstn n ls) init1 == fold_left (fun r a => r + (f a)) ls init2.

Lemma permutation_NoDup : forall (A : Type)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  NoDup ls1 ->
  NoDup ls2.

Lemma fold_add_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, (~In a ls1) -> (f a) == 0) ->
  sumList ls1 f == sumList ls2 f.

Fixpoint flatten(A : Type)(ls : list (list A)) :=
  match ls with
    | nil => nil
    | a :: ls' => a ++ (flatten ls')
  end.

Theorem in_flatten : forall (A : Set)(ls : list (list A)) a,
  In a (flatten ls) <->
  exists x : _, In x ls /\ In a x.

Theorem length_flatten_nz : forall (A : Type)(ls : list (list A)) ls',
  In ls' ls ->
  length ls' > 0 ->
  length (flatten ls) > 0.

Fixpoint getUnique(A : Set)(ls : list A)(pf : eq_dec A) : list A :=
  match ls with
    | nil => nil
    | a :: ls' => 
      let ls'' := (getUnique ls' pf) in
        if (in_dec pf a ls'') 
          then ls''
          else a :: ls''
  end.

Theorem in_getUnique_if : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a (getUnique ls eqd) ->
  In a ls.

Theorem in_getUnique : forall (A : Set)(ls : list A)(eqd : eq_dec A) a,
  In a ls ->
  In a (getUnique ls eqd).

Lemma getUnique_NoDup : forall (A : Set)(ls : list A)(eqd: eq_dec A),
  NoDup (getUnique ls eqd).

Theorem length_getUnique_nz : forall (A :Set)(eqd : eq_dec A)(ls : list A),
  length ls > 0 ->
  length (getUnique ls eqd) > 0.

Definition maxList(ls : list nat) : nat :=
  fold_left max ls O.

Lemma fold_left_max_ge_init : forall (ls : list nat)(n : nat),
  fold_left max ls n >= n.

Lemma maxList_correct_h : forall (ls : list nat)(n init : nat),
  In n ls ->
  fold_left max ls init >= n.

Theorem maxList_correct : forall (ls : list nat) n,
  In n ls ->
  maxList ls >= n.

Inductive pred_count(A : Type)(p : A -> Prop) : list A -> nat -> Prop :=
  | pc_nil : 
    pred_count p nil 0
  | pc_yes : 
    forall ls n a,
    pred_count p ls n ->
    p a ->
    pred_count p (a :: ls) (S n)
  | pc_no : forall ls n a,
    pred_count p ls n ->
    ~p a ->
    pred_count p (a :: ls) n.

Lemma pred_count_le_length : forall (A : Type)(P : A -> Prop) ls c,
  pred_count P ls c ->
  (c <= length ls)%nat.

Fixpoint listRepeat(A : Type)(a : A) n :=
  match n with
    | 0 => nil
    | S n' => a :: (listRepeat a n')
  end.

Lemma listRepeat_length : forall n (A : Type) (a : A),
  length (listRepeat a n) = n.

Lemma pred_count_listRepeat_eq_inv : forall n (A : Type)(a : A) count,
  pred_count (eq a) (listRepeat a n) count ->
  count = n.

Lemma pred_count_listRepeat_ne_inv : forall n (A : Type)(a1 a2 : A) count,
  a1 <> a2 ->
  pred_count (eq a1) (listRepeat a2 n) count ->
  count = O.

Lemma pred_count_func : forall (A : Type)(P : A -> Prop)(ls : list A) n1 n2,
  pred_count P ls n1 ->
  pred_count P ls n2 ->
  n1 = n2.

Lemma pred_count_eq_all_inv : forall (A : Type)(ls : list A)(P : A -> Prop) c,
  pred_count P ls c ->
  (forall a, In a ls -> P a) ->
  c = length ls.

Lemma pred_count_first_skip : forall (A : Type)(P : A -> Prop)(ls : list A)(c : nat),
  pred_count P ls c ->
  forall n,
    exists c1 c2,
      pred_count P (firstn n ls) c1 /\
      pred_count P (skipn n ls) c2 /\
      (c1 + c2 = c)%nat.

Lemma pred_count_eq_all : forall (A : Type)(P : A -> Prop)(ls : list A) n,
  (forall a, In a ls -> P a) ->
  n = length ls ->
  pred_count P ls n.

Lemma pred_count_eq_none : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, In a ls -> ~P a) ->
  pred_count P ls 0.

Lemma in_listRepeat_inv : forall n (A : Type)(a1 a2 : A),
  In a1 (listRepeat a2 n) ->
  a1 = a2.

Lemma pred_count_app : forall (A : Type)(P : A -> Prop)(ls1 ls2 : list A) n1 n2,
  pred_count P ls1 n1 ->
  pred_count P ls2 n2 ->
  pred_count P (ls1 ++ ls2) (n1 + n2).

Lemma pred_count_permutation : forall (A : Set)(P : A -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall c, 
    pred_count P ls1 c ->
    pred_count P ls2 c.

Lemma pred_count_eq_none_inv : forall (A : Set)(P : A -> Prop)(ls : list A) c,
  pred_count P ls c ->
  (forall a, In a ls -> ~P a) ->
  c = O.

Lemma pred_count_eq_1_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> Prop)(ls : list A) c a,
  pred_count P ls c ->
  NoDup ls ->
  P a ->
  In a ls ->
  (forall a', In a' ls -> a <> a' -> ~P a') ->
  c = (S O).

Lemma pred_count_left_total : forall (A : Type)(P : A -> Prop)(ls : list A),
  (forall a, P a \/ ~P a) ->
  exists c, pred_count P ls c.

Inductive rel_map(A B : Type)(r : A -> B -> Prop) : list A -> list B -> Prop :=
| rm_nil : 
  rel_map r nil nil
| rm_step : 
  forall lsa lsb a b,
    rel_map r lsa lsb ->
    r a b ->
    rel_map r (a :: lsa) (b :: lsb).

Theorem rel_map_map2 : forall (A B C D : Type)(ls_c : list C)(ls_d: list D)(P : A -> B -> Prop)(f1 : C -> A)(f2 : D -> B),
  rel_map (fun a b => P (f1 a) (f2 b)) ls_c ls_d ->
  rel_map P (map f1 ls_c) (map f2 ls_d).

Lemma rel_map_length : forall (A B : Type)(lsa : list A)(P : A -> B -> Prop)(lsb : list B),
  rel_map P lsa lsb ->
  length lsa = length lsb.

Lemma rel_map_unary_pred : forall (A B : Type)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(P' : B -> Prop),
  rel_map P lsa lsb ->
  (forall a b, P a b -> P' b) ->
  forall b, In b lsb -> P' b.

Lemma rel_map_eq_inv : forall (A B : Type)(ls1 ls2 : list A)(rel1 rel2 : A -> B -> Prop) ls1' ls2',
  ls1 = ls2 ->
  (forall a b1 b2, rel1 a b1 -> rel2 a b2 -> b1 = b2) ->
  rel_map rel1 ls1 ls1' ->
  rel_map rel2 ls2 ls2' ->
  ls1' = ls2'.

Lemma rel_map_eq : forall (A B : Type)(ls1 : list A)(rel1 : A -> B -> Prop) ls',
  rel_map rel1 ls1 ls' ->
  forall ls2 (rel2 : A -> B -> Prop), 
    ls1 = ls2 ->
    (forall a b, In a ls1 -> In b ls' -> rel1 a b -> rel2 a b) ->
    rel_map rel2 ls2 ls'.

Theorem pred_count_eq_0 : forall (A B : Set)(ls : list B)(ls' : list A)(f : B -> A -> Prop)(P : A -> Prop) v,
  (forall a b, In b ls -> f b a -> ~ P a) ->
  rel_map f ls ls' ->
  pred_count P ls' v ->
  v = O.

Lemma rel_map_app_inv : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb : list B),
  rel_map rel (lsa1 ++ lsa2) lsb ->
  (rel_map rel lsa1 (firstn (length lsa1) lsb) /\ rel_map rel lsa2 (skipn (length lsa1) lsb)).

Lemma rel_map_map_inv : forall (A B C : Type)(rel : B -> C -> Prop)(f : A -> B)(lsa : list A)(lsc : list C),
  rel_map rel (map f lsa) lsc ->
  rel_map (fun a c => rel (f a) c) lsa lsc.

Lemma rel_map_listRepeat : forall (A B : Set)(lsa : list A)(rel : A -> B -> Prop) b,
  (forall a, In a lsa -> rel a b) ->
  rel_map rel lsa (listRepeat b (length lsa)).

Lemma rel_map_app : forall (A B : Type)(rel : A -> B -> Prop)(lsa1 lsa2 : list A)(lsb1 lsb2 : list B),
  rel_map rel lsa1 lsb1 ->
  rel_map rel lsa2 lsb2 ->
  rel_map rel (lsa1 ++ lsa2) (lsb1 ++ lsb2).

Lemma rel_map_map : forall (A B C : Type)(f : A -> B)(rel : B -> C -> Prop) lsa lsc,
  rel_map (fun a c => rel (f a) c) lsa lsc ->
  rel_map rel (map f lsa) lsc.

Lemma rel_map_inverse : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb -> 
  forall b, 
    In b lsb ->
    exists a, In a lsa /\ rel a b.

Lemma ne_all_not_in : forall (A : Type)(ls : list A) a,
  (forall a', In a' ls -> a <> a') ->
  ~In a ls.

Lemma rel_map_NoDup : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  NoDup lsa ->
  (forall a1 a2 b1 b2, In a1 lsa -> In a2 lsa -> a1 <> a2 -> rel a1 b1 -> rel a2 b2 -> b1 <> b2) ->
  NoDup lsb.

Lemma rel_map_in : forall (A B : Type)(lsa : list A)(lsb : list B) rel,
  rel_map rel lsa lsb ->
  (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
  forall b a,
    In a lsa ->
    rel a b ->
    In b lsb.

Lemma rel_map_left_total : forall (A B : Type)(rel : A -> B -> Prop)(lsa : list A),
  (forall a, exists b, rel a b) ->
  exists lsb, rel_map rel lsa lsb.

Lemma rel_map_func : forall (A B : Type) (rel : A -> B -> Prop) lsa lsb1,
  rel_map rel lsa lsb1 ->
  forall lsb2,
    rel_map rel lsa lsb2 ->
    (forall a b1 b2, In a lsa -> rel a b1 -> rel a b2 -> b1 = b2) ->
    lsb1 = lsb2.

Lemma rel_map_permutation : forall (A B : Type) lsa1 lsa2,
  Permutation lsa1 lsa2 ->
  forall (rel : A -> B -> Prop),
    (forall a b1 b2, rel a b1 -> rel a b2 -> b1 = b2) ->
    (forall a, exists b, rel a b) ->
    forall lsb1 lsb2,
      rel_map rel lsa1 lsb1 ->
      rel_map rel lsa2 lsb2 ->     
      Permutation lsb1 lsb2.

Lemma rel_map_impl : forall (A B : Type)(rel1 rel2 : A -> B -> Prop) lsa lsb,
  rel_map rel1 lsa lsb ->
  (forall a b, In a lsa -> rel1 a b -> rel2 a b) ->
  rel_map rel2 lsa lsb.

Lemma rel_map_in_inv : forall (A B : Type)(rel : A -> B -> Prop) lsa lsb,
  rel_map rel lsa lsb ->
  forall a, In a lsa -> exists b, In b lsb /\ rel a b.

Inductive sumList_rel(A : Type)(rel : A -> Rat -> Prop) : list A -> Rat -> Prop :=
| slr_nil :
  forall r, 
    r == rat0 ->
    sumList_rel rel nil r
| slr_cons : 
  forall (ls : list A)(a : A) r1 r2 r3,
    sumList_rel rel ls r1 ->
    rel a r2 ->
    r3 == r2 + r1 ->
    sumList_rel rel (a :: ls) r3.

Lemma sumList_rel_distance : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r r1 r2,
  (forall a r1 r2, In a ls -> f1 a r1 -> f2 a r2 -> (ratDistance r1 r2) <= r) ->
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  ratDistance r1 r2 <= (r * (length ls / 1)).

Lemma sumList_rel_all_0_inv : forall (A : Set)(ls : list A)(r  : Rat)(rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a' v, In a' ls -> rel a' v -> v == 0) ->
  r == 0.

Lemma sumList_rel_only_one_inv : forall (A : Set)(rel : A -> Rat -> Prop)(ls : list A)(a : A) r r',
  sumList_rel rel ls r' ->
  In a ls ->
  NoDup ls -> 
  (forall a', In a' ls -> a <> a' -> forall v, rel a' v -> v == 0) ->
  (forall v, rel a v -> v == r) ->
  r' == r.

Lemma sumList_rel_body_eq : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma sumList_rel_plus_inv : forall (A : Type)(ls : list A) r (rel1 rel2 rel : A -> Rat -> Prop),
  sumList_rel rel ls r ->
  (forall a r, In a ls -> rel a r -> forall r1 r2, rel1 a r1 -> rel2 a r2 -> r == r1 + r2) ->
  forall r1 r2, sumList_rel rel1 ls r1 -> sumList_rel rel2 ls r2 -> r == r1 + r2.

Lemma sumList_rel_left_total : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> exists r, rel a r) ->
  exists r, sumList_rel rel ls r.

Lemma sumList_rel_factor_constant : forall (p1 p2 : posnat) (A : Type)(rel : A -> Rat -> Prop)(ls : list A) r,
  sumList_rel (fun a r' => rel a (r' * (RatIntro p1 p2))) ls (r * (RatIntro p2 p1)) ->
  sumList_rel rel ls r.

Lemma sumList_rel_permutation : forall (A : Type)(rel : A -> Rat -> Prop)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  forall r, 
    sumList_rel rel ls1 r ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_all_0 : forall (A : Type)(rel : A -> Rat -> Prop)(ls : list A),
  (forall a, In a ls -> rel a 0) ->
  sumList_rel rel ls 0.

Lemma sumList_rel_ls_intersect: forall (A : Set)(rel : A -> Rat -> Prop)(ls1 : list A) r,
  sumList_rel rel ls1 r ->
  forall ls2, 
    NoDup ls1 ->
    NoDup ls2 ->
    eq_dec A ->
    (forall a r1 r2, In a ls1 -> rel a r1 -> rel a r2 -> r1 == r2) -> 
    (forall a, In a ls1 -> ~In a ls2 -> rel a 0) ->
    (forall a, In a ls2 -> ~In a ls1 -> rel a 0) ->
    sumList_rel rel ls2 r.

Lemma sumList_rel_sumList : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a = r) ls
  (sumList ls f).

Lemma sumList_cons : forall (A : Set)(ls : list A) a f,
  sumList (a :: ls) f == f a + (sumList ls f).

Lemma sumList_sum : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  sumList ls (fun a => f1 a + f2 a) ==
  sumList ls f1 + sumList ls f2.

Lemma sumList_summation : forall (A B : Set) f (lsa : list A)(lsb : list B),
  sumList lsa (fun a => sumList lsb (fun b => (f a b))) ==
  sumList lsb (fun b => sumList lsa (fun a => (f a b))).

Lemma fold_add_subset' : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A)(f : A -> Rat) init1 init2,
  init1 == init2 ->
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> In a ls2) ->
  (forall a, In a ls2 -> (~In a ls1) -> (f a) == 0) ->
  fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_subset'
  : forall A : Set,
    eq_dec A ->
    forall (ls1 ls2 : list A) (f : A -> Rat),
      NoDup ls1 ->
      NoDup ls2 ->
      (forall a : A, In a ls1 -> In a ls2) ->
      (forall a : A, In a ls2 -> ~ In a ls1 -> f a == 0) ->
      sumList ls1 f == sumList ls2 f.

Lemma sumList_exactly_one : forall (A : Set) a (ls : list A) f,
  NoDup ls ->
  In a ls ->
  (forall b, In b ls -> a <> b -> f b == 0) ->
  sumList ls f == f a.

Lemma fold_add_permutation : forall (A : Set) ls1 ls2,
  Permutation ls1 ls2 ->
  forall (f : A -> Rat) init1 init2,
    init1 == init2 ->
    fold_left (fun r a => r + (f a)) ls1 init1 == fold_left (fun r a => r + (f a)) ls2 init2.

Lemma sumList_permutation : forall (A : Set)(f : A -> Rat) ls1 ls2,
  Permutation ls1 ls2 ->
  sumList ls1 f == sumList ls2 f.

Lemma sumList_rel_body_eq_strong : forall (A : Type)(rel1 rel2 : A -> Rat -> Prop)(ls1 : list A) r1,
  sumList_rel rel1 ls1 r1 ->
  forall ls2 r2, 
    (forall a r', In a ls1 -> rel1 a r' -> rel2 a r') ->
    r1 == r2 ->
    ls1 = ls2 ->
    sumList_rel rel2 ls2 r2.

Lemma rel_map_left_total_strong' : forall (A B : Type)(lsa : list A)(P : A -> Prop)(rel : A -> B -> Prop),
  (forall a, P a -> exists b, rel a b) ->
  (forall a, In a lsa -> P a) ->
  exists lsb, rel_map rel lsa lsb.

Lemma firstn_eq_all_gen : forall (A : Type)(ls : list A) n,
  n = length ls ->
  firstn n ls = ls.

Fixpoint getNats s n :=
  match n with 
    | O => nil
    | S n' => (s + n')%nat :: (getNats s n')
  end.

Lemma ratMult_sumList_rel_distrib : forall (A : Set)(ls : list A) f (x : Rat -> Prop) x' a,
  sumList_rel f ls a ->
  (forall i v1 v2, f i v1 -> f i v2 -> v1 == v2) ->
  (forall x1 x2, x x1 -> x x2 -> x1 == x2) ->
  x x' -> 
  sumList_rel (fun i => ratMult_rel x (f i)) ls (x' * a).

Lemma series_le : forall n (f1 f2 : nat -> Rat -> Prop) r1 r2,
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->
  sumList_rel f1 (getNats O n) r1 ->
  sumList_rel f2 (getNats O n) r2 ->
  r2 <= r1.

Lemma ratSubtract_series_map : forall n f1 f2 a1 a2,
  n > 0 ->
  sumList_rel f1 (getNats O n) a1 ->
  sumList_rel f2 (getNats O n) a2 ->
  (forall i x1 x2, f1 (S i) x1 -> f2 i x2 -> x1 == x2) ->
  (forall i v1 v2, f1 i v1 -> f1 i v2 -> v1 == v2) ->
  (forall i v1 v2, f2 i v1 -> f2 i v2 -> v1 == v2) ->
  (forall i v1 v2, f1 i v1 -> f2 i v2 -> v2 <= v1) ->  
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f1 i1 v1 -> f1 i2 v2 -> v2 <= v1) ->
  (forall i1 i2 v1 v2, (i1 <= i2)%nat -> f2 i1 v1 -> f2 i2 v2 -> v2 <= v1) ->
  forall x1 x2,
    f1 O x1 -> f2 (pred n) x2 ->
    ratSubtract a1 a2 == ratSubtract x1 x2.

Lemma sum_power_series : forall n (f : Rat -> Prop) a a',
  n > 0 ->
  (exists v, f v) ->
  (forall v1 v2, f v1 -> f v2 -> v1 == v2) ->
  (forall v, f v -> ~1 <= v) ->
  sumList_rel (fun i : nat => expRat_rel f i) (getNats 0 n) a ->
  ratMult_rel (ratSubtract_rel (eqRat 1) (expRat_rel f n))
         (ratInverse_rel (ratSubtract_rel (eqRat 1) f)) a' ->
         a == a'.

Lemma sumList_rel_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat -> Prop) r1 r2,
  sumList_rel f1 ls r1 ->
  sumList_rel f2 ls r2 ->
  (forall a v1 v2, In a ls -> f1 a v1 -> f2 a v2 -> v1 <= v2) ->
  r1 <= r2.

Lemma sumList_filter_le : forall (A : Set)(ls : list A)(f : A -> Rat)(P : A -> bool),
  sumList (filter P ls) f <= sumList ls f.

Lemma sumList_filter_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f == (sumList (filter P ls) f + (sumList (filter (fun a => negb (P a)) ls) f)).

Lemma sumList_rel_sumList_eqRat : forall (A : Set)(ls : list A)(f : A -> Rat),
  sumList_rel (fun a r => f a == r) ls
  (sumList ls f).

Lemma sumList_series_incr : forall n2 n1 (f f' : nat -> Rat),
  (forall n, (f n) == (f' (S n))) ->
  sumList (getNats n1 n2) f == sumList (getNats (S n1) n2) f'.

Lemma sumList_series_split_first : forall n f, 
  sumList (n :: getNats O n) f == f O + (sumList (getNats 1 n) f).

Lemma firstn_nil : forall (A : Set) n, 
  firstn n nil = (@nil A).

Lemma firstn_ge_all : forall n (A : Set) (ls : list A),
  n >= length ls ->
  firstn n ls = ls.

Lemma firstn_app : forall n (A : Set) (ls1 ls2 : list A),
  (n <= length ls1)%nat ->
  firstn n (ls1 ++ ls2) = firstn n ls1.

Lemma sumList_rel_func : forall (A : Set)(f : A -> Rat -> Prop) ls r1,
  sumList_rel f ls r1 ->
  forall r2,
  sumList_rel f ls r2 ->
  (forall a v1 v2, f a v1 -> f a v2 -> v1 == v2) ->
  r1 == r2.

Lemma sumList_partition : forall (A : Set)(P : A -> bool)(ls : list A)(f : A -> Rat),
  sumList ls f ==
  sumList ls (fun a => (f a) * (if (P a) then 1 else 0)) + 
  sumList ls (fun a => (f a) * (if (P a) then 0 else 1)).

Lemma sumList_le : forall (A : Set)(ls : list A)(f1 f2 : A -> Rat),
  (forall a, In a ls -> f1 a <= f2 a) ->
  sumList ls f1 <= sumList ls f2.

Lemma sumList_distance_prod : forall (A : Set)(ls : list A)(f f1 f2 : A -> Rat),
  | (sumList ls (fun a => (f a) * (f1 a))) - (sumList ls (fun a => (f a) * (f2 a))) | <= sumList ls (fun a => (f a) * | (f1 a) - (f2 a) |).

Theorem sumList_all : 
  forall (A : Set)(ls : list A)(f : A -> Rat) c,
    (forall a, In a ls -> (f a) == c) ->
    sumList ls f == (length ls)/1 * c.

Theorem filter_app : 
  forall (A : Set)(ls1 ls2 : list A)(f : A -> bool),
    filter f (ls1 ++ ls2) = filter f ls1 ++ filter f ls2.

Theorem filter_true : 
  forall (A : Set)(ls : list A)(f : A -> bool),
    (forall a, In a ls -> (f a) = true) ->
    filter f ls = ls.

Theorem sumList_subset_le : 
  forall (A : Set){eqd: EqDec A}(ls1 ls2 : list A)(f : A -> Rat),
    NoDup ls1 ->
    NoDup ls2 ->
    (forall a, In a ls1 -> In a ls2) ->
    sumList ls1 f <= sumList ls2 f.

Fixpoint allNatsLt (n : nat) :=
  match n with
    | 0 => nil
    | S n' => allNatsLt n' ++ (n' :: nil)
  end.

Lemma allNatsLt_length : 
  forall n, 
    length (allNatsLt n) = n.

Lemma allNatsLt_lt : 
  forall n v,
    In v (allNatsLt n) ->
    v < n.

Lemma app_NoDup : forall(A : Set)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  (forall a, In a ls1 -> ~In a ls2) ->
  (forall a, In a ls2 -> ~In a ls1) ->
  NoDup (ls1 ++ ls2).

Lemma allNatsLt_NoDup : 
  forall (n : nat),
    NoDup (allNatsLt n).

Lemma allNatsLt_lt_if : 
  forall (n i : nat), 
    i < n ->
    In i (allNatsLt n).

Lemma nth_allNatsLt_lt : 
  forall k n,
    n < k ->
    nth n (allNatsLt k) n = n.

Lemma nth_allNatsLt : 
  forall k n,
    nth n (allNatsLt k) n = n.

Theorem allNatsLt_filter_lt : 
  forall (p n : nat),
    (n <= p)%nat->
    filter (fun z => if (lt_dec z n) then true else false) (allNatsLt p) = 
    allNatsLt n.

Theorem map_eq_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    map f1 ls = map f2 ls ->
    (forall a, In a ls -> f1 a = f2 a).

Theorem map_eq_if_all : 
  forall (A B : Type)(ls : list A)(f1 f2 : A -> B),
    (forall a, In a ls -> f1 a = f2 a) ->
    map f1 ls = map f2 ls.

Theorem map_eq_subset : 
  forall (A B : Type)(ls2 ls1 : list A)(f1 f2 : A -> B),
    map f1 ls1 = map f2 ls1 ->
    (forall a, In a ls2 -> In a ls1) ->
    map f1 ls2 = map f2 ls2.

Fixpoint getSomes(A : Type)(ls : list (option A)) :=
  match ls with
    | nil => nil
    | o :: ls' =>
      match o with
        | None => getSomes ls'
        | Some x => x :: (getSomes ls')
      end
  end.

Lemma nth_nil:
  forall (A : Set)(i : nat)(def : A),
    nth i nil def = def.

Theorem listReplace_None_Permutation : 
  forall (A : Set) n ls (y : A),
    nth n ls None = None ->
    Permutation (getSomes (listReplace ls n (Some y) None)) (y :: (getSomes ls)).

Theorem listReplace_getSomes_Permutation_h : 
  forall (A : Set) l1' l2,
    Permutation l1' l2 ->
    forall l1 n2 (y : A),
      l1' = getSomes l1 ->
      nth n2 l1 None = None ->
      Permutation
        (getSomes
           (listReplace l1 n2
                        (Some y) None))
        (y :: l2).

Theorem listReplace_getSomes_Permutation : 
  forall (A : Set) l1 l2 n2 (y : A),
    nth n2 l1 None = None ->
    Permutation (getSomes l1) l2 ->
    Permutation
      (getSomes
         (listReplace l1 n2
                      (Some y) None))
      (y :: l2).

Lemma nth_listReplace_ne : 
  forall (i1 i2 : nat)(A : Set)(ls : list A)(a def : A),
    i1 <> i2 ->
    nth i1 (listReplace ls i2 a def) def = 
    nth i1 ls def.

Theorem listReplace_length :
  forall (A : Set)(ls : list A)(i : nat)(a def : A),
    i < length ls ->
    length (listReplace ls i a def) = length ls.

Lemma listReplace_in_nil : 
  forall (A : Set)(i : nat)(a1 a2 def : A),
    In a1 (listReplace nil i a2 def) ->
    a1 = a2 \/ a1 = def.

Lemma listReplace_in : 
  forall (A : Set)(ls : list A)(a1 a2 def : A)(i : nat),
    In a1 (listReplace ls i a2 def) ->
    (In a1 ls \/ a1 = a2 \/ a1 = def).

Theorem firstn_map : 
  forall (A B : Set)(f : A -> B)(ls : list A) n,
    firstn n (map f ls) = map f (firstn n ls).

Lemma firstn_app_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    firstn (length ls1) (ls1 ++ ls2) = ls1.

Theorem map_nth_in : 
  forall (A B : Set)(ls : list A)(f : A -> B) i defa defb,
    i < length ls ->
    nth i (map f ls) defb = f (nth i ls defa).

Lemma flatten_app : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    flatten (ls1 ++ ls2) = flatten ls1 ++ flatten ls2.

Inductive list_pred(A B : Set)(pred : A -> B -> Prop) : list A -> list B -> Prop :=
| list_pred_nil : 
    list_pred pred nil nil
| list_pred_cons : 
    forall a1 a2 ls1 ls2,
      pred a1 a2 ->
      list_pred pred ls1 ls2 ->
      list_pred pred (a1 :: ls1) (a2 :: ls2).

Lemma list_pred_eq_impl_eq : 
  forall (A : Set)(ls1 ls2 : list A),
    list_pred eq ls1 ls2 ->
    ls1 = ls2.

Lemma flatten_eq : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred eq ls1 ls2 ->
    flatten ls1 = flatten ls2.

Theorem app_cons_eq : 
  forall (A : Type) ls2 ls1 (a : A),
    ls2 ++ (a :: ls1) = (ls2 ++ (a :: nil)) ++ ls1.

Theorem skipn_nil : 
  forall (A : Type) n,
    skipn n (@nil A) = nil.

Theorem nth_In_exists : 
  forall (A : Type)(ls : list A) a def,
    In a ls ->
    exists n, nth n ls def = a.

Theorem nth_skipn_eq : 
  forall (A : Set)(y x: nat)(ls : list A)(def : A),
    nth x (skipn y ls) def = nth (x + y) ls def.

Theorem perm_flatten_listReplace_nil : 
  forall b (A : Set)(a : A),
    Permutation (flatten (listReplace nil b (a :: nil) nil)) (a :: nil).

Theorem perm_flatten_listReplace : 
  forall b (A : Set)(ls1 : list (list A))(ls2 : list A) (a : A),
    Permutation (flatten ls1) ls2 ->
    Permutation (flatten (listReplace ls1 b (nth b ls1 nil ++ (a :: nil)) nil))
                (a :: ls2).

Theorem map_cons : 
  forall (A B : Type)(f : A -> B)(ls : list A)(a : A),
    map f (a :: ls) = (f a) :: map f ls.

Theorem app_eq_inv : 
  forall (A : Type)(ls1 ls2 ls3 ls4 : list A),
    length ls1 = length ls3 ->
    (ls1 ++ ls2) = (ls3 ++ ls4) ->
    ls1 = ls3 /\ ls2 = ls4.

Theorem NoDup_app : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1 /\
    NoDup ls2 /\
    (forall a1 a2,
       In a1 ls1 ->
       In a2 ls2 ->
       a1 <> a2).

Theorem firstn_In : 
  forall (A : Type) n (ls : list A)(a : A),
             In a (firstn n ls) ->
             In a ls.

Theorem pred_firstn_In :
  forall (A : Set) ls1 ls2,
    list_pred (fun x0 y : list A => exists n : nat, y = firstn n x0) ls1 ls2 ->
    forall a,
      In a (flatten ls2) -> In a (flatten ls1).

Theorem firstn_NoDup : 
  forall (A : Type) n (ls : list A),
    NoDup ls ->
    NoDup (firstn n ls).
 
Theorem NoDup_flatten_subset : 
  forall (A : Set)(ls1 ls2 : list (list A)),
    list_pred (fun x y => exists n, y = firstn n x) ls1 ls2 ->
    NoDup (flatten ls1) ->
    NoDup (flatten ls2).

Theorem allNatsLt_nil_inv :
  forall n,
    allNatsLt n = nil ->
    n = O.
  
Theorem firstn_allNatsLt_h : 
  forall ls n1 n2,
    n2 >= n1 ->
    ls = (allNatsLt n2) ->
    firstn n1 ls = allNatsLt n1.

Theorem firstn_allNatsLt : 
  forall n1 n2,
    n2 >= n1 ->
    firstn n1 (allNatsLt n2) = allNatsLt n1.

Theorem NoDup_app_l : 
  forall (A : Type)(ls1 ls2 : list A),
    NoDup (ls1 ++ ls2) ->
    NoDup ls1.

Theorem NoDup_map : 
  forall (A B : Type)(f : A -> B)(ls : list A),
    NoDup (map f ls) ->
    (NoDup ls /\ (forall b1 b2, In b1 ls -> In b2 ls -> f b1 = f b2 -> b1 = b2)).

Theorem map_fst_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (fst x)) (combine ls lsc).

Theorem map_snd_eq : 
  forall (C : Set)(lsc : list C)(A B : Set)(ls : list A)(f : A -> B),
    (length ls = length lsc) ->
    map f ls = 
    map (fun x => f (snd x)) (combine lsc ls).

Theorem In_combine_NoDup_eq_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a1 a2 b,
    NoDup lsb ->
    In (a1, b) (combine lsa lsb) ->
    In (a2, b) (combine lsa lsb) ->
    a1 = a2.

Theorem In_combine_NoDup_eq_r : 
  forall (A B : Set)(lsa : list A)(lsb : list B) a b1 b2,
    NoDup lsa ->
    In (a, b1) (combine lsa lsb) ->
    In (a, b2) (combine lsa lsb) ->
    b1 = b2.

Theorem zip_eq_nil_l : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = nil ->
    length lsa = length lsb ->
    lsa = nil.

Theorem fst_split_app_eq : 
  forall (A B : Type)(ls1 ls2 : list (A * B)),
    fst (split (ls1 ++ ls2)) = 
    fst (split ls1) ++ fst (split ls2).

Theorem fst_split_flatten_eq : 
  forall (A B : Type)(ls : list (list (A * B))),
    fst (split (flatten ls)) = 
    flatten (map (fun x => fst (split x)) ls).

Theorem fst_split_map_eq : 
  forall (A B C : Type)(ls : list A)(f : A -> B * C),
    fst (split (map f ls)) = 
    map (fun a => fst (f a)) ls.

Theorem in_split_l_if : 
  forall (A B : Type)(ls : list (A * B)) a,  
    In a (fst (split ls)) -> 
    exists b,
      In (a, b) ls.

Theorem in_fst_split_if : 
  forall (A B : Type)(ls : list (A * B)) a b,
    In (a, b) ls ->
    In a (fst (split ls)).

Theorem map_pair_fst_eq : 
  forall (A B C D: Type)(f1 : B -> D)(f2 : C -> D)(ls1 : list B)(ls2 : list C)(a1 a2 : A),
    map (fun x => (a1, f1 x)) ls1 = map (fun x => (a2, f2 x)) ls2 ->
    ls1 <> nil ->
    a1 = a2.

Theorem In_zip_strong : 
  forall (A B : Set)(ls : list A) f a (b : B),
    In (a, b) (zip ls (map f ls)) ->
    (In a ls /\ b = f a).

Lemma list_pred_impl : 
  forall (A B : Set)(lsa : list A)(lsb : list B) (P1 : A -> B -> Prop),
       list_pred P1 lsa lsb ->
       forall (P2 : A -> B -> Prop), 
         (forall a b, P1 a b -> P2 a b) ->
         list_pred P2 lsa lsb.

Theorem list_pred_eq_in : 
  forall (A : Set)(ls : list A),
    list_pred (fun a b => a = b /\ In a ls /\ In b ls) ls ls.

Theorem zip_combine_eq : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    zip lsa lsb = combine lsa lsb.

Theorem list_pred_fst_split_eq : 
  forall (A B C : Set)(ls1 : list (A * B))(ls2 : list (A * C)),
    list_pred (fun a b => fst a = fst b) ls1 ls2 ->
    fst (split ls1)  = fst (split ls2).

Theorem unzip_eq_split : 
  forall (A B : Set)(ls : list (A * B)),
    unzip ls = split ls.

Theorem in_split_r_if:
  forall (A B : Type) (ls : list (A * B)) (b : B),
    In b (snd (split ls)) -> exists a : A, In (a, b) ls.

Fixpoint nth_option(A : Set)(ls : list A)(i : nat) :=
  match ls with 
    | nil => None
    | a :: ls' =>
      match i with
        | O => Some a
        | S i' =>
          nth_option ls' i'
          end
  end.

Theorem nth_option_app_Some : 
  forall (A : Set)(ls1 ls2 : list A) i a,
    nth_option ls1 i = Some a ->
    nth_option (ls1 ++ ls2) i = Some a.

Theorem nth_option_Some_lt : 
  forall (A : Set)(ls : list A) i a,
    nth_option ls i = Some a ->
    i < length ls.

Theorem nth_option_app_None : 
  forall (A : Set)(ls1 ls2 : list A) i,
    nth_option ls1 i = None ->
    nth_option (ls1 ++ ls2) i = nth_option ls2 (i - length ls1).

Theorem nth_option_None_ge : 
  forall (A : Set)(ls : list A) i,
    nth_option ls i = None ->
    i >= length ls.

Theorem skipn_S_eq : 
  forall (A : Set)(ls : list A) n a,
    nth_option ls n = Some a -> 
    skipn n ls = a :: (skipn (S n) ls).

Theorem nth_option_snd_split : 
  forall (A B : Set)(ls : list (A * B)) n a b,
    nth_option ls n = Some (a, b) ->
    nth_option (snd (split ls)) n = Some b.

Theorem snd_split_map_eq :
  forall (A B C : Set)(ls : list A)(f : A -> B * C),
    snd (split (map f ls)) =
    map (fun p => snd (f p)) ls.

Theorem cons_ne : 
  forall (A : Set)(eqda : eq_dec A)(a1 a2 : A)(ls1 ls2 : list A),
    ((a1 :: ls1) = (a2 :: ls2) -> False) ->
    (a1 <> a2) \/ (ls1 <> ls2).

Theorem map_ne_same_ex : 
  forall (A B : Set)(f1 f2 : A -> B)(ls : list A),
    eq_dec B ->
    map f1 ls <> map f2 ls ->
    exists a, In a ls /\ f1 a <> f2 a.

Theorem list_pred_I_in : 
  forall (A B : Set)(lsa : list A)(lsb : list B),
    length lsa = length lsb ->
    list_pred (fun a b => In a lsa /\ In b lsb) lsa lsb.

Theorem list_pred_fst_split_eq_l : 
  forall (A B : Set)(a : list (A * B))(b : list A),
    list_pred (fun a0 b0 => fst a0 = b0) a b ->
    b = fst (split a).

Theorem list_pred_fst_split_flatten_eq_l : 
  forall (A B : Set)(a : list (list (A * B)))(b : list (list A)),
    list_pred
      (list_pred
         (fun a0 b0 => fst a0 = b0)) a b ->
    flatten b = fst (split (flatten a)).

Theorem fold_add_const_mult : 
  forall (A : Type)(ls : list A)(c : nat) init,
    (fold_left (fun acc _ => acc + c) ls init = 
     (length ls) * c + init)%nat.

Theorem list_pred_snd_split_eq_l:
  forall (A B : Set) (a : list (B * A)) (b : list A),
    list_pred (fun (a0 : B * A) (b0 : A) => snd a0 = b0) a b ->
    b = snd (split a).

Theorem NoDup_snd_split_if : 
  forall (A B : Type)(ls : list (A * B)),
    NoDup (snd (split ls)) ->
    NoDup ls.

Fixpoint forNats(n : nat) :=
  match n with
      | 0 => nil
      | S n' =>
        cons n' (forNats n')
  end.

Lemma forNats_In : 
  forall n i,
    i < n <->
    In i (forNats n).

Lemma forNats_NoDup : 
  forall n,
    NoDup (forNats n).

Lemma forNats_length : 
  forall n,
    length (forNats n) = n.

Lemma sumList_forNats_first_ls : 
  forall (n : nat)(f : nat -> Rat),
    n <> O ->
    f O <= sumList (forNats n) f.

Lemma sumList_forNats_distance : 
  forall (n : nat)(f : nat -> Rat), 
    (| sumList (forNats n) f - sumList (forNats n) (fun i => f (S i)) |) == (| (f O) - (f n) |).

Lemma flatten_map_eq : 
  forall (A B : Set)(ls : list A)(f : A -> B),
    flatten (map (fun a => (f a) :: nil) ls) =
    map f ls.

Lemma app_NoDup_inv : 
    forall (A : Set)(ls1 ls2 : list A), 
      NoDup (ls1 ++ ls2) ->
      (forall a, In a ls1 -> In a ls2 -> False).

Lemma flatten_NoDup : 
  forall (A : Set)(ls : list (list A)),
    NoDup ls ->
    (forall x, In x ls -> NoDup x) ->
    (forall x1 x2, In x1 ls -> In x2 ls -> x1 <> x2 -> NoDup (x1 ++ x2)) ->
    NoDup (flatten ls).

Lemma map_NoDup'
: forall (A B : Set) (ls : list A) (f : A -> B),
    NoDup ls ->
    (forall a1 a2 : A, In a1 ls -> In a2 ls ->a1 <> a2 -> f a1 <> f a2) -> 
    NoDup (map f ls).

Lemma getUnique_cons : 
  forall (A : Set)(eqd : eq_dec A)(ls2 ls1 : list A) a,
    a :: ls1 = (getUnique ls2 eqd) ->
    exists ls3 ls4, 
      ls2 = ls3 ++ (a :: ls4) /\
      ls1 = (getUnique ls4 eqd).

Lemma getUnique_eq_inv : 
  forall (A : Set)(a : A)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
    getUnique ls1 eqd1 = getUnique ls2 eqd2 ->
    In a ls1 -> 
    In a ls2.

Lemma sumList_app :
  forall (A : Set)(ls1 ls2 : list A)(f : A -> Rat),
    sumList (ls1 ++ ls2) f == (sumList ls1 f) + (sumList ls2 f).

Lemma filter_all_true : 
  forall (A : Set)(ls : list A)(P : A -> bool), 
    (forall a, In a ls -> P a = true) ->
    filter P ls = ls.

Lemma sumList_map : 
  forall (A B : Set)(ls : list A)(f1 : A -> B)(f : B -> Rat),
    sumList (map f1 ls) f == 
    sumList ls (fun a => f (f1 a)).

Lemma sumList_filter_twice : 
  forall (A B : Set)(P : A -> bool)(ls : list A)(lsf : A -> list B)(f : A * B -> Rat),
    sumList (filter (fun p => P (fst p)) (flatten (map (fun a => map (fun b => (a, b)) (lsf a)) ls))) f ==  
    sumList (filter P ls) (fun a => sumList (lsf a) (fun b => f (a, b))).

Lemma filter_cons : 
  forall (A : Set)(P : A -> bool)(ls : list A) a,
    filter P (a :: ls) = 
    if (P a) then (a :: (filter P ls)) else (filter P ls).

Theorem sumList_1_mult : 
  forall (A : Set)(ls : list A),
    sumList ls (fun _ => 1) == length ls / 1.

Theorem fold_left_orb_true_init : 
  forall (A : Type)(f : A -> bool)(ls : list A),
    fold_left (fun b x => orb b (f x)) ls true = true.

Theorem fold_left_orb_true_in : 
  forall (A : Type)(f : A -> bool)(ls : list A) a init,
    In a ls ->
    f a = true ->
    fold_left (fun b x => orb b (f x)) ls init = true.

Theorem hd_error_Some_In : 
  forall (A : Type)(ls : list A) a,
    hd_error ls = Some a ->
    In a ls.

Theorem fold_and_false_init :
  forall (A : Type)(ls : list A) P,
    fold_left (fun b z => b && negb (P z)) ls false = false.

Theorem hd_filter_false_eq_and_false : 
  forall (A : Type)(ls : list A)(P : A -> bool),
    (if hd_error (filter P ls) then false else true) =
    fold_left (fun (b : bool) (z : A) => b && negb (P z)) ls true.

Theorem fst_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (A * B))(ls2 : list A),
    list_pred (fun a b => fst a = b) ls1 ls2 ->
    fst (split ls1) = ls2.

Theorem snd_split_eq_list_pred : 
  forall (A B : Set)(ls1 : list (B * A))(ls2 : list A),
    list_pred (fun a b => snd a = b) ls1 ls2 ->
    snd (split ls1) = ls2.

Theorem combine_map_eq : 
  forall (A B C : Type)(lsa : list A)(lsb : list B)(f : B -> C),
    combine lsa (map f lsb) = map (fun p => (fst p, f (snd p))) (combine lsa lsb).

Theorem map_ext_pred : 
  forall (A B C : Set)(P : A -> B -> Prop)(lsa : list A)(lsb : list B)(f1 : A -> C)(f2 : B -> C),
    list_pred P lsa lsb ->
    (forall a b, P a b -> (f1 a) = (f2 b)) ->
    map f1 lsa = map f2 lsb.

Theorem list_pred_combine_l_h : 
  forall (A C : Set)(lsa : list A)(lsc : list C) P1,
    list_pred P1 lsa lsc ->
    forall (B : Set)(lsb : list B) P2, 
      list_pred P2 lsb lsc ->
      list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Theorem list_pred_combine_l : 
  forall (A B C : Set)P1 P2 (lsa : list A)(lsb : list B)(lsc : list C),
    list_pred P1 lsa lsc -> 
    list_pred P2 lsb lsc ->
    list_pred (fun p c => P1 (fst p) c /\ P2 (snd p) c) (combine lsa lsb) lsc.

Lemma list_pred_symm : 
  forall (A B : Set)(P : A -> B -> Prop) lsa lsb,
    list_pred (fun b a => P a b) lsb lsa ->
    list_pred P lsa lsb.

Theorem list_pred_combine_r
: forall (A B C : Set) (P1 : A -> B -> Prop) (P2 : A -> C -> Prop)
         (lsa : list A) (lsb : list B) (lsc : list C),
    list_pred P1 lsa lsb ->
    list_pred P2 lsa lsc ->
    list_pred (fun a p => P1 a (fst p) /\ P2 a (snd p))
              lsa (combine lsb lsc). *)
Require Import Permutation.
Require Import FCF.SemEquiv.
(* FCF.SemEquiv:
Set Implicit Arguments.

Require Import FCF.Comp.
Require Import FCF.DetSem.
Require Import FCF.DistSem.
Require Import FCF.Rat.
Require Import Arith.
Require Import FCF.StdNat.
Require Import FCF.Fold.
Require Import FCF.Limit.
Require Import Permutation.

Local Open Scope rat_scope.
Local Open Scope list_scope.

Lemma evalDet_step_done_evalDist : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a a' s,
  evalDet_step c nil = (cs_done a s) ->
  evalDist c a' == if (eqd a a') then 1 else 0.

Lemma evalDet_step_nil_dist_preserved : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall c' a, 
    evalDet_step c nil = cs_more c' nil ->
    evalDist c a == evalDist c' a.

Lemma evalDet_steps_done_evalDist_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (eqd : eq_dec A)(c : Comp A) a a' s,
    x = (cs_more c nil) -> 
    y = (cs_done a s) -> 
    well_formed_comp c ->
    evalDist c a' == if (eqd a a') then 1 else 0.
  
Lemma evalDet_steps_done_evalDist : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a a' s,
  well_formed_comp c ->
  evalDet_steps (cs_more c nil) (cs_done a s) ->
  evalDist c a' == if (eqd a a') then 1 else 0.

Definition lowDistApprox (A : Set)(c : Comp A)(a : A)(n : nat)(v : Rat) :=
  exists vals count,
    rel_map (evalDet c) (getAllBlists n) vals /\
    pred_count (eq (ca_done a)) vals count  /\
    v == (count / expnat 2 n).

Lemma map_Ret_repeat : forall (A : Set)(eqd : eq_dec A)(a : A) ls ls',
  rel_map (evalDet (Ret eqd a)) ls ls' ->
  ls' = listRepeat (ca_done a) (length ls).

Theorem lowDistApprox_Ret_inv : forall (A : Set)(eqd : eq_dec A)(a a' : A) n v,
  lowDistApprox (Ret eqd a) a' n v ->
  v == (if (eqd a a') then 1 else 0).

Inductive lowDistApprox_bind (A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(a : A)(n : nat) : Rat -> Prop :=
| lda_b_intro : 
  forall v,
    sumList_rel (fun (b : B) r => forall r1 r2, lowDistApprox c1 b n r1 -> lowDistApprox (c2 b) a n r2 -> r == r1 * r2) (getSupport c1) v ->
    lowDistApprox_bind c1 c2  a n v.

Inductive DistApproxTree(A : Set) :=
| dat_leaf : option A -> DistApproxTree A
| dat_internal : DistApproxTree A -> DistApproxTree A -> DistApproxTree A.

Inductive dat_correct_h(A : Set)(c : Comp A)(s : Blist) : nat -> DistApproxTree A -> Prop :=
    | dat_correct_h_leaf_Some :
      forall a n, 
        evalDet c s (ca_done a) ->
        dat_correct_h c s n (dat_leaf (Some a))
    | dat_correct_h_leaf_None :
        (forall a, ~ evalDet c s (ca_done a)) ->
        dat_correct_h c s 0 (dat_leaf None)
    | dat_correct_h_internal :
      forall t1 t2 n, 
        (forall a, ~ evalDet c s (ca_done a)) ->
        dat_correct_h c (s ++ (true :: nil)) n t1 ->
        dat_correct_h c (s ++ (false :: nil)) n t2 ->
        dat_correct_h c s (S n) (dat_internal t1 t2).

Definition dat_correct(A : Set)(c : Comp A)(n : nat) :=
    dat_correct_h c nil n.

Lemma dat_correct_func : forall (A : Set)(c : Comp A) ls n t1,
  dat_correct_h c ls n t1 ->
  forall t2, 
    dat_correct_h c ls n t2 ->
    t1 = t2.

Fixpoint getTreeSupport_dups(A : Set)(t : DistApproxTree A) :=
  match t with
    | dat_leaf o =>
      match o with
        | None => nil
        | Some a => a :: nil
      end
    | dat_internal t1 t2 =>
      getTreeSupport_dups t1 ++ getTreeSupport_dups t2
  end.

Definition getTreeSupport(A : Set)(eqd : eq_dec A)(t : DistApproxTree A) : list A :=
  getUnique (getTreeSupport_dups t) eqd.

Lemma getTreeSupport_in : forall (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) n,
  dat_correct c n t ->
  forall a,
    In a (getTreeSupport eqd t) ->
    In a (getSupport c).

Lemma getTreeSupport_not_in : forall (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) n a,
  dat_correct c n t ->
  ~In a (getSupport c) ->
  ~In a (getTreeSupport eqd t).

Lemma dat_exists_h : forall n s (A : Set)(c : Comp A),
  well_formed_comp c ->
  exists t : DistApproxTree A,
    dat_correct_h c s n t.

Theorem dat_exists : forall n (A : Set)(c : Comp A),
  well_formed_comp c ->
  exists t : DistApproxTree A,
    dat_correct c n t.

Fixpoint lowDistApproxFromTree(A : Set)(eqd : eq_dec A)(t : DistApproxTree A)(a : A) :=
  match t with
    | dat_leaf o =>
      match o with
        | None => 0
        | Some a' => if (eqd a a') then 1 else 0
      end
    | dat_internal t1 t2 =>
      (lowDistApproxFromTree eqd t1 a) * (1 / 2) + (lowDistApproxFromTree eqd t2 a) * (1 / 2)
  end.

Definition lowDistApprox_ls (A : Set)(c : Comp A) a n (ls : Blist) r :=
  exists vals count,
    rel_map (fun s v => (evalDet c (ls ++ s) v)) (getAllBlists n) vals /\
    pred_count (eq (ca_done a)) vals count /\
    count /expnat 2 n == r.

Lemma lowDistApprox_ls_impl : forall n (A : Set)(c : Comp A) a r,
  lowDistApprox c a n r ->
  lowDistApprox_ls c a n nil r.

Lemma evalDet_lowDistApprox_ls_done_inv : forall (A : Set)(eqd : eq_dec A)(c : Comp A) s a1 a2 n r,
  evalDet c s (ca_done a1) ->
  lowDistApprox_ls c a2 n s r ->
  r == if (eqd a2 a1) then 1 else 0.
 
Lemma low_tree_approx_same_inv_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A) ls t,
  dat_correct_h c ls n t -> 
  forall a r, 
    lowDistApprox_ls c a n ls r ->
    lowDistApproxFromTree eqd t a == r.

Theorem low_tree_approx_same_inv : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) (a : A) r,
    dat_correct c n t -> 
    lowDistApprox c a n r ->
    lowDistApproxFromTree eqd t a == r.   

Theorem getSupport_not_In_lowDistApprox : forall n (A : Set)(c : Comp A)(a : A) r,
  ~In a (getSupport c) ->
  lowDistApprox c a n r ->
  r == 0.

Definition getSupport_bind (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) : list (B * (list A)) :=
  (map (fun b => (b , (getSupport (c2 b)))) (getSupport c1)).

Fixpoint flattenPair (A B : Type)(ls : list (A * list B)) :=
  match ls with
    | nil => nil
    | (a, ls_b) :: ls' =>
      (map (fun b => (a, b)) ls_b) ++ (flattenPair ls')
  end.

Theorem in_flattenPair : forall (A B : Type)(ls : list (A * (list B))) a b entryList,
  In (a, entryList) ls ->
  In b entryList ->
  In (a, b) (flattenPair ls).

Definition getSupport_bind_cp (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) : list (B * A) :=
  flattenPair (getSupport_bind c1 c2).

Lemma In_getSupport_bind_cp : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) b a,
  In b (getSupport c1) ->
  In a (getSupport (c2 b)) ->
  In (b, a) (getSupport_bind_cp c1 c2).

Lemma not_In_getSupport_bind_cp : forall (A B : Set)(eqda : eq_dec A)(eqdb : eq_dec B)(c1 : Comp B)(c2 : B -> Comp A) b a,
  ~ In (b, a) (getSupport_bind_cp c1 c2) ->
  ~ In b (getSupport c1) \/ 
  ~ In a (getSupport (c2 b)).

Lemma evalDet_lowDistApprox_ls_done:
  forall (A : Set) (eqd : eq_dec A) (c : Comp A) (s : Blist) 
    (a1 a2 : A) (n : nat),
    evalDet c s (ca_done a1) ->
    lowDistApprox_ls c a2 n s (if eqd a2 a1 then 1 else 0).

Lemma evalDet_lowDistApprox_ls_not_done:
  forall (A : Set) (c : Comp A) (s : Blist) 
    (a2 : A) (n : nat),
    well_formed_comp c ->
    (forall s' (a : A), In s' (getAllBlists n) -> evalDet c (s ++ s') (ca_done a) -> False) ->
    lowDistApprox_ls c a2 n s 0.

Lemma low_tree_approx_same_h : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A) ls,
                                 dat_correct_h c ls n t ->
                                 forall a, 
                                   well_formed_comp c ->
                                   lowDistApprox_ls c a n ls (lowDistApproxFromTree eqd t a).

Theorem low_tree_approx_same : forall n (A : Set)(eqd : eq_dec A)(c : Comp A)(t : DistApproxTree A),
  well_formed_comp c ->
  dat_correct c n t -> 
  forall a, 
    lowDistApprox c a n (lowDistApproxFromTree eqd t a).

Lemma lowDistApprox_left_total : forall (A : Set)(eqd : eq_dec A)(c : Comp A) a,
  well_formed_comp c ->
  left_total (lowDistApprox c a).

Inductive datMap(A B : Set)(f : A -> DistApproxTree B -> Prop) : DistApproxTree A -> DistApproxTree B  -> Prop :=
| datMap_leaf_None :
    datMap f (dat_leaf None) (dat_leaf None)
| datMap_leaf_Some : 
  forall a t,
    f a t ->
    datMap f (dat_leaf (Some a)) t
| datMap_internal : 
  forall t1a t2a t1b t2b,
    datMap f t1a t1b ->
    datMap f t2a t2b ->
    datMap f (dat_internal t1a t2a) (dat_internal t1b t2b).

Inductive datMap_depth(A B : Set)(f : nat -> A -> DistApproxTree B -> Prop) : nat -> DistApproxTree A -> DistApproxTree B -> Prop :=
| datMap_depth_leaf_None :
  forall n, 
    datMap_depth f n (dat_leaf None) (dat_leaf None)
| datMap_depth_leaf_Some :
  forall n a t,
    f n a t ->
    datMap_depth f n (dat_leaf (Some a)) t
| datMap_depth_internal :
  forall n t1a t2a t1b t2b,
    datMap_depth f n t1a t1b ->
    datMap_depth f n t2a t2b ->
    datMap_depth f (S n) (dat_internal t1a t2a) (dat_internal t1b t2b).

Definition dat_correct_bind(A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(n : nat)(t : DistApproxTree A) :=
  exists tb, dat_correct c1 n tb /\
    (datMap_depth (fun n' b ta => (dat_correct (c2 b) n' ta)) n tb t).

Definition dat_correct_bind2(A B : Set)(c1 : Comp B)(c2 : B -> Comp A)(n : nat)(t : DistApproxTree A) :=
  exists tb, dat_correct c1 n tb /\
    (datMap (fun b ta => (dat_correct (c2 b) n ta)) tb t).

Lemma lowDistApproxFromTree_eq_0 : forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) a,
  ~In a (getTreeSupport eqd t) ->
  lowDistApproxFromTree eqd t a == 0.

Lemma lowDistApproxFromTree_datMap_inv : forall (A B : Set)(eqda : eq_dec A)(eqdb : eq_dec B)(tb : DistApproxTree B)(ta : DistApproxTree A)(mapRel : B -> DistApproxTree A -> Prop),
  datMap mapRel tb ta ->
  (forall b, In b (getTreeSupport eqdb tb) -> exists t,  mapRel b t) ->
  (forall b t1 t2, mapRel b t1 -> mapRel b t2 -> t1 = t2) -> 
  forall a r, 
    sumList_rel 
    (fun b r' => 
      forall ta', mapRel b ta' ->  
        lowDistApproxFromTree eqdb tb b * lowDistApproxFromTree eqda ta' a == r')
    (getTreeSupport eqdb tb)
    r ->
    lowDistApproxFromTree eqda ta a == r.

Lemma getTreeSupport_approx_0: forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) a,
  ~In a (getTreeSupport eqd t) ->
  lowDistApproxFromTree eqd t a == 0.

Lemma lowDistApprox_le_1 : forall (A : Set)(c : Comp A) a n r,
  lowDistApprox c a n r ->
  r <= 1.

Theorem bind_low_tree_approx_same_inv : forall (A B : Set)(eqda : eq_dec A)(c1 : Comp B)(c2 : B -> Comp A) n a t r,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b))->
  lowDistApprox_bind c1 c2 a n r ->
  dat_correct_bind2 c1 c2 n t ->
  r == lowDistApproxFromTree eqda t a.

Lemma in_flattenPair_inv : forall (A B : Set)(ls : list (A * list B)) a b,
  In (a, b) (flattenPair ls) ->
  exists lsb,
    In b lsb /\ In (a , lsb) ls.

Lemma in_getSupport_bind_cp_fst : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a0,
  In a0 (getSupport_bind_cp c1 c2) -> 
  In (fst a0) (getSupport c1).

Lemma lowDistApprox_bind_evalDist_limit : forall (A B :Set)(c1 : Comp B)(c2 : B -> Comp A) a,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  (forall (a : B),
    rat_inf_limit (lowDistApprox c1 a) (evalDist c1 a)) ->
  (forall (b : B) (a : A),
    In b (getSupport c1) ->
    rat_inf_limit (lowDistApprox (c2 b) a) (evalDist (c2 b) a)) ->
  rat_inf_limit (lowDistApprox_bind c1 c2 a) (evalDist (Bind c1 c2) a).

Lemma datMap_left_total : forall (A B : Set)(eqdb : eq_dec A)(t : DistApproxTree A)(f : A -> DistApproxTree B -> Prop),
  (forall a, In a (getTreeSupport eqdb t) -> exists b, f a b) ->
  exists t',
    datMap f t t'.
    
Lemma dat_exists_bind2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  exists t, dat_correct_bind2 c1 c2 n t.

Inductive dat_better(A : Set) : DistApproxTree A -> DistApproxTree A -> Prop :=
| dat_better_leaf_None : forall t,
  dat_better t (dat_leaf None)
| dat_better_leaf_Some : forall a,
  dat_better (dat_leaf (Some a)) (dat_leaf (Some a))
| dat_better_internal : forall ta1 ta2 tb1 tb2,
  dat_better ta1 tb1 ->
  dat_better ta2 tb2 ->
  dat_better (dat_internal ta1 ta2) (dat_internal tb1 tb2).

Hint Constructors dat_better : dat.

Lemma dat_better_refl : forall (A : Set)(t : DistApproxTree A),
  dat_better t t.

Lemma dat_better_trans : forall (A : Set)(t1 t2 : DistApproxTree A),
  dat_better t1 t2 ->
  forall t3, 
    dat_better t2 t3 ->
    dat_better t1 t3.

Lemma dat_correct_dat_better : forall (A : Set)(c : Comp A) ls n1 t1,
  dat_correct_h c ls n1 t1 ->
  forall n2 t2,
    dat_correct_h c ls n2 t2 ->
    n1 >= n2 ->
    dat_better t1 t2.

Lemma lowDistApprox_dat_better_le : forall (A : Set)(eqd : eq_dec A)(t1 t2 : DistApproxTree A),
  dat_better t1 t2 ->
  forall (a : A), 
    lowDistApproxFromTree eqd t2 a <= lowDistApproxFromTree eqd t1 a.

Lemma datMap_better : forall (A B : Set)(t : DistApproxTree B) n (rel : nat -> B -> DistApproxTree A -> Prop) t1 t2,
  (forall n b t1 t2, rel n b t1 -> rel (pred n) b t2 -> dat_better t1 t2) ->
  datMap (rel n) t t1 ->
  datMap (rel (pred n)) t t2 ->
  dat_better t1 t2.

Lemma datMap_depth_better : forall (A B : Set)(tb1 tb2 : DistApproxTree B),
  dat_better tb1 tb2 ->
  forall  n1 n2 (f : nat -> B -> DistApproxTree A -> Prop) t1 t2,
    (forall n1 n2 b t1 t2, n1 >= n2 -> f n1 b t1 -> f n2 b t2 -> dat_better t1 t2) ->
    datMap (f n1) tb1 t1 ->
    datMap_depth f n2 tb2 t2 ->
    n1 >= n2 ->
    dat_better t1 t2.

Lemma dat_bind_2_better : forall (n : nat) (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) t1 t2,
  dat_correct_bind2 c1 c2 n t1 ->
  dat_correct_bind c1 c2 n t2 ->
  dat_better t1 t2.

Lemma dat_correct_h_bind_app : forall (A B : Set) t (c1 : Comp B)(c2 : B -> Comp A) n ls1 ls2 a,
  evalDet_steps (cs_more c1 ls1) (cs_done a nil) ->
  dat_correct_h (Bind c1 c2) (ls1 ++ ls2) n t ->
  dat_correct_h (c2 a) ls2 n t.

Lemma dat_correct_bind_same_h : forall n (A : Set)(c : Comp A) ls t,
  dat_correct_h c ls n t ->
  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) t1,
    c = Bind c1 c2 ->
    well_formed_comp c1 ->
    (forall a ls', evalDet_steps (cs_more c1 ls) (cs_done a ls') -> ls' = nil) -> 
    dat_correct_h c1 ls n t1 ->  
    datMap_depth
    (fun (depth : nat) (b : B) t2 => dat_correct_h (c2 b) nil depth t2) 
    n t1 t.

Lemma lowDistApprox_le_bind : forall n (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a r1 r2,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  lowDistApprox (Bind c1 c2) a n r1 -> 
  lowDistApprox_bind c1 c2 a n r2 ->
  r1 <= r2.

Lemma dat_correct_bind_same: forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n t,
  well_formed_comp c1 ->
  dat_correct (Bind c1 c2) n t ->
  dat_correct_bind c1 c2 n t.
    
Fixpoint datDepth (A : Set)(t : DistApproxTree A) : nat :=
  match t with
    | dat_leaf o => O
    | dat_internal t1 t2 =>
      S (max (datDepth t1) (datDepth t2))
  end.

Lemma datMap_depth_better' : forall (B : Set)(tb1 tb2 : DistApproxTree B),
  dat_better tb1 tb2 ->
  forall (A : Set)(rel : nat -> B -> DistApproxTree A -> Prop) n n' t1 t2,
    datMap_depth rel n tb1 t1 ->
    datMap (rel n') tb2 t2 ->
    n >= n' + (datDepth tb2) ->
    (forall b n1 n2 t1 t2, rel n1 b t1 -> rel n2 b t2 -> n1 >= n2 -> dat_better t1 t2) -> 
    dat_better t1 t2.

Lemma datCorrect_datDepth : forall (A : Set)(c : Comp A) n t,
  dat_correct c n t ->
  (datDepth t <= n)%nat.

Lemma dat_better_bind_div2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) n t1 t2,
  dat_correct_bind c1 c2 n t1 ->
  dat_correct_bind2 c1 c2 (div2 n) t2 ->
  dat_better t1 t2.

Lemma lowDistApprox_bind_le_div2 : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a n r1 r2,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  lowDistApprox_bind c1 c2 a (div2 n) r1 ->
  lowDistApprox (Bind c1 c2) a n r2 ->
  r1 <= r2.

Lemma lowDistApprox_func : forall (A : Set)(c : Comp A) a n r1 r2,
  well_formed_comp c ->
  lowDistApprox c a n r1 ->
  lowDistApprox c a n r2 ->
  r1 == r2.

Lemma lowDistApprox_bind_left_total : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) -> 
  left_total (lowDistApprox_bind c1 c2 a).

Lemma lowDistApprox_bind_div2_left_total : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a,
  well_formed_comp c1 ->
  (forall b, In b (getSupport c1) -> well_formed_comp (c2 b)) ->
  left_total (fun n => lowDistApprox_bind c1 c2 a (div2 n)).

Lemma rel_map_Rnd_NoDup : forall n ls,
  rel_map (evalDet (Rnd n)) (getAllBlists n) ls ->
  NoDup ls.

Lemma rel_map_Rnd_any_in : forall n ls (a : Bvector n),
  rel_map (evalDet (Rnd n)) (getAllBlists n) ls ->
  In (ca_done a) ls.

Theorem lowDistApprox_Rnd: forall n2 n1 (a : Bvector n1) r,
  lowDistApprox (Rnd n1) a (n1 + n2) r ->
  r == (1 / (expnat 2 n1)).

Definition indicator_rel (A : Set)(P : A -> bool) a (r : Rat) :=
  (P a = true /\ r == 1) \/ (P a = false /\ r == 0).

Definition lowDistApprox_repeat (A : Set)(c : Comp A)(P : A -> bool) a n : Rat -> Prop := 
  let approx := lowDistApprox c a n in
    let empty := sumList_rel (fun a => lowDistApprox c a n) (filter (fun a => negb (P a)) (getSupport c)) in
  ratMult_rel (ratMult_rel (indicator_rel P a)
    (sumList_rel (fun i => (expRat_rel empty i)) (getNats O (S n)))) 
  approx.

Lemma lowDistApprox_repeat_left_total : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  left_total (lowDistApprox_repeat c P a).

Lemma lowDistApprox_repeat_sqrt_div2_left_total : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  left_total (fun n => (lowDistApprox_repeat c P a (Nat.sqrt (div2 n)))).

Inductive datRepeat (A : Set)(f : DistApproxTree A -> Prop)(P : A -> bool) : nat -> DistApproxTree A -> DistApproxTree A -> Prop :=
  | datRepeat_leaf_None : forall n,
    datRepeat f P n (dat_leaf None) (dat_leaf None)
  | datRepeat_leaf_Some_yes : forall a n,
    P a = true ->
    datRepeat f P n (dat_leaf (Some a)) (dat_leaf (Some a))
  | datRepeat_leaf_Some_no : forall a,
    P a = false ->
    datRepeat f P O (dat_leaf (Some a)) (dat_leaf None)
  | datRepeat_leaf_Some_repeat : forall a t t' n,
    f t ->
    P a = false ->
    datRepeat f P n t t' ->
    datRepeat f P (S n) (dat_leaf (Some a)) t'
  | datRepeat_internal : forall n t1 t2 t1' t2',
    datRepeat f P n t1 t1' ->
    datRepeat f P n t2 t2' ->
    datRepeat f P n (dat_internal t1 t2) (dat_internal t1' t2').

Definition dat_correct_repeat2(A : Set)(c : Comp A)(P : A -> bool)(n : nat)(t : DistApproxTree A) :=
exists t1 : DistApproxTree A,
  dat_correct c n t1 /\
  datRepeat (dat_correct c n) P n t1 t. 

Lemma datRepeat_left_total : forall n (A : Set)(eqd : eq_dec A)(t : DistApproxTree A)(f : DistApproxTree A -> Prop) P,
   (exists b : DistApproxTree A, f b) ->
   exists t', datRepeat f P n t t'.

Lemma dat_exists_repeat2 : forall (A : Set)(c : Comp A)(P : A -> bool)(n : nat),
  well_formed_comp c ->
  exists t : DistApproxTree A, dat_correct_repeat2 c P n t.

Fixpoint computeEmptySpace(A : Set)(t : DistApproxTree A)(P : A -> bool) :=
  match t with
    | dat_leaf o =>
      match o with
        | Some a => indicator (fun a' => (negb (P a'))) a 
        | None => 0
      end
    | dat_internal t1 t2 =>
      (1 / 2) * (computeEmptySpace t1 P)  + (1 / 2) * (computeEmptySpace t2 P)
  end.

Lemma computeEmptySpace_correct : forall (A : Set)(eqd : eq_dec A)(t : DistApproxTree A) P,
  sumList (filter (fun a => negb (P a)) (getTreeSupport eqd t)) (lowDistApproxFromTree eqd t) == (computeEmptySpace t P).

Lemma lowDistApprox_val_eq : forall (A : Set)(c : Comp A) a n r1 r2,
  lowDistApprox c a n r1 ->
  r1 == r2 ->
  lowDistApprox c a n r2.

Lemma repeat_low_tree_approx_same_tree_inv : forall (A : Set)(eqd : eq_dec A)(P : A -> bool)(t1 t2 t3 : DistApproxTree A) n a,
  datRepeat (eq t3) P n t1 t2 ->
  lowDistApproxFromTree eqd t2 a == 
  indicator P a * 
  ((lowDistApproxFromTree eqd t1 a) + 
    (computeEmptySpace t1 P) * 
    sumList (getNats 0 n) (expRat (computeEmptySpace t3 P)) * (lowDistApproxFromTree eqd t3 a)).

Lemma datRepeat_func_eq : forall n (A : Set)(t1 t2 : DistApproxTree A) f P (P' : DistApproxTree A -> Prop),
  datRepeat f P n t1 t2 ->
  (forall t, f t -> P' t) ->
  datRepeat P' P n t1 t2.

Lemma repeat_low_tree_approx_same_inv
  : forall (A : Set) (eqd : eq_dec A)(c : Comp A)(P : A -> bool) (n : nat) (a : A) (t : DistApproxTree A) (r : Rat),
    well_formed_comp c ->
    (exists a, In a (filter P (getSupport c))) ->
    lowDistApprox_repeat c P a n r ->
    dat_correct_repeat2 c P n t -> 
    n > 0 ->
    r == lowDistApproxFromTree eqd t a.

Lemma dat_better_antisymm : forall (A : Set)(t1 t2 : DistApproxTree A),
  dat_better t1 t2 ->
  dat_better t2 t1 ->
  t1 = t2.

Lemma dat_correct_h_repeat_app : forall (A : Set) t (c : Comp A)(P : A -> bool) n ls1 ls2 a,
  evalDet_steps (cs_more c ls1) (cs_done a nil) ->
  P a = false ->
  dat_correct_h (Repeat c P) (ls1 ++ ls2) n t ->
  dat_correct_h (Repeat c P) ls2 n t.

Inductive datRepeat_depth (A : Set)(f : nat -> DistApproxTree A -> Prop)(P : A -> bool) : nat -> nat -> DistApproxTree A -> DistApproxTree A -> Prop :=
  | datRepeat_depth_leaf_None : forall n depth,
    datRepeat_depth f P n depth (dat_leaf None) (dat_leaf None)
  | datRepeat_depth_leaf_Some_yes : forall a n depth,
    P a = true ->
    datRepeat_depth f P n depth (dat_leaf (Some a)) (dat_leaf (Some a))
  | datRepeat_depth_leaf_Some_no : forall a depth,
    P a = false ->
    datRepeat_depth f P O depth (dat_leaf (Some a)) (dat_leaf None)
  | datRepeat_depth_leaf_Some_repeat : forall a t t' n depth,
    P a = false ->
    f depth t ->
    datRepeat_depth f P n depth t t' ->
    datRepeat_depth f P (S n) depth (dat_leaf (Some a)) t'
  | datRepeat_depth_internal : forall n depth t1 t2 t1' t2',
    datRepeat_depth f P n depth t1 t1' ->
    datRepeat_depth f P n depth t2 t2' ->
    datRepeat_depth f P n (S depth) (dat_internal t1 t2) (dat_internal t1' t2').

Definition dat_correct_repeat(A : Set) (c : Comp A)(P : A -> bool)(n : nat)(t : DistApproxTree A) :=
exists t1 : DistApproxTree A,
  dat_correct c n t1 /\
  datRepeat_depth (dat_correct c) P n n t1 t.

Lemma datRepeat_depth_0 : forall n2 n1 (A : Set)(f : nat -> DistApproxTree A -> Prop) P t1 t2,
  datRepeat_depth f P n1 O t1 t2 ->
  n2 >= n1 ->
  f O (dat_leaf None) ->
  datRepeat_depth f P n2 O t1 t2.

Lemma dat_correct_repeat_same_h : forall depth repeats (A : Set)(c : Comp A) P ls t a t1,
  dat_correct_h (Repeat c P) ls depth t ->
  well_formed_comp c ->
  In a (filter P (getSupport c)) ->
  (forall a' n' ls', 
    evalDet_steps (cs_more c (firstn n' ls)) (cs_done a' ls') -> 
    ls' = nil)  -> 
  dat_correct_h c ls depth t1 ->  
  repeats >= depth ->
  datRepeat_depth (dat_correct_h c nil) P repeats depth t1 t.

Lemma dat_correct_repeat_same:
  forall n (A : Set) (t : DistApproxTree A) (c : Comp A) (P : A -> bool),
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  dat_correct (Repeat c P) n t -> 
  dat_correct_repeat c P n t.

Lemma datRepeat_depth_better: forall (n2 : nat) (A : Set) (t2 t1 t1' : DistApproxTree A)(rel : nat -> DistApproxTree A -> Prop) reps depth (P : A -> bool),
  datRepeat_depth rel P reps depth t1 t1' ->
  forall n1 (t2' : DistApproxTree A),
    reps >= n2 ->
    datRepeat (rel n1) P n2 t2 t2' ->
    dat_better t1 t2 ->
    depth >= n1 * n2 + datDepth t2 -> 
    (forall (n1 n2: nat) (t3 t4 : DistApproxTree A),
      rel n1 t3 -> rel n2 t4 -> n1 >= n2 -> dat_better t3 t4) ->
    (forall a, rel 0%nat (dat_leaf (Some a)) -> P a = true) ->
    (forall n t, rel n t -> datDepth t <= n)%nat ->
    dat_better t1' t2'.

Lemma dat_better_repeat_sqrt : forall (A : Set) (c : Comp A)(P : A -> bool)(n : nat) (t1 t2 : DistApproxTree A),
  (exists a, In a (filter P (getSupport c))) ->
  dat_correct_repeat c P n t1 ->
  dat_correct_repeat2 c P (Nat.sqrt (div2 n)) t2 -> 

Lemma lowDistApprox_repeat_sqrt_le : forall n (A : Set)(c : Comp A)(P : A -> bool) a v1 v2,
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  lowDistApprox (Repeat c P) a n v1 ->
  lowDistApprox_repeat c P a (Nat.sqrt (div2 n)) v2 -> 

Lemma datRepeat_better_depth: forall (A : Set) n2 (t2 t1 t1' : DistApproxTree A)(rel : nat -> DistApproxTree A -> Prop) reps depth (P : A -> bool),
  forall n1 (t2' : DistApproxTree A),
    datRepeat (rel n1) P n2 t2 t2' ->
    datRepeat_depth rel P reps depth t1 t1' ->
    dat_better t2 t1 ->
    n1 >= depth ->
    n2 >= reps ->  
    (forall (n1 n2: nat) (t3 t4 : DistApproxTree A),
      rel n1 t3 -> rel n2 t4 -> n1 >= n2 -> dat_better t3 t4) ->
    (forall a, rel 0%nat (dat_leaf (Some a)) -> P a = true) ->
    (forall n t, rel n t -> datDepth t <= n)%nat ->
    dat_better t2' t1'.

Lemma dat_repeat_better:
  forall (A : Set) n (c : Comp A) (P : A -> bool)
    (t1 t2 : DistApproxTree A),
    (exists a : A, In a (filter P (getSupport c))) ->
    dat_correct_repeat c P n t1 ->
    dat_correct_repeat2 c P n t2 -> 
    dat_better t2 t1.

Lemma lowDistApprox_le_repeat:
  forall (n : nat) (A : Set) (c : Comp A) (P : A -> bool)(a : A) (v1 v2 : Rat),
    well_formed_comp c ->
    (exists a0 : A, In a0 (filter P (getSupport c))) ->
    lowDistApprox (Repeat c P) a n v1 ->
    lowDistApprox_repeat c P a n v2 -> 
    n > O ->
    v1 <= v2.

Lemma lowDistApprox_Rnd_lt : forall n1 n2 a r,
  lowDistApprox (Rnd n1) a n2 r ->
  n2 < n1 ->
  r == 0.

Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) a s,
  evalDet_step c nil = (cs_done a s) ->
  getSupport c = a :: nil.

Lemma lowDistApprox_low : forall (A : Set)(c : Comp A),
  well_formed_comp c -> 
  forall n a r, 
  lowDistApprox c a n r ->
  r <= evalDist c a.

Lemma lowDistApprox_repeat_scale_limit : forall (A : Set)(c : Comp A)(P : A -> bool),
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  (forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a)) -> 
  rat_inf_limit
     (fun n : nat =>
      sumList_rel
        (fun i : nat =>
         expRat_rel
           (sumList_rel (fun a0 : A => lowDistApprox c a0 n)
              (filter (fun a0 : A => negb (P a0)) (getSupport c))) i)
        (getNats O n))
     (ratInverse (sumList (filter P (getSupport c)) (evalDist c))).

Lemma lowDistApprox_repeat_limit : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  (exists b, In b (filter P (getSupport c))) ->
  (forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a)) ->
  rat_inf_limit (lowDistApprox_repeat c P a) (evalDist (Repeat c P) a).

Lemma lowDistApprox_limit_repeat : forall (A : Set)(c : Comp A)(P : A -> bool) a,
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  (forall a', rat_inf_limit (lowDistApprox c a') (evalDist c a')) ->
  rat_inf_limit (lowDistApprox (Repeat c P) a) (evalDist (Repeat c P) a).

Theorem evalDet_evalDist_equiv : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall a, rat_inf_limit (lowDistApprox c a) (evalDist c a).

Lemma evalDet_equiv_impl_lowDistApprox_equiv : 
  forall (A : Set)(c1 c2 : Comp A), 
    evalDet_equiv c1 c2 ->
    forall a n r,
      lowDistApprox c1 a n r <-> lowDistApprox c2 a n r.

Theorem det_eq_impl_dist_sem_eq : forall (A : Set)(c1 c2 : Comp A),
  well_formed_comp c1 ->
  well_formed_comp c2 -> 
  evalDet_equiv c1 c2 -> 
  dist_sem_eq c1 c2.

Print Assumptions det_eq_impl_dist_sem_eq. *)
Require Import FCF.DetSem.
(* FCF.DetSem:
Set Implicit Arguments.

Require Export FCF.Comp.
Require Import FCF.Blist.
Require Import FCF.Fold.
Require Import Permutation.
Require Import Omega.

Local Open Scope list_scope. 
Local Open Scope comp_scope.

Inductive comp_state(A : Set) :=
  | cs_done : A -> Blist -> comp_state A
  | cs_eof : comp_state A
  | cs_more : Comp A -> Blist -> comp_state A.

Inductive comp_answer(A : Set) :=
  | ca_done : A -> comp_answer A
  | ca_eof : comp_answer A.

Lemma comp_answer_eq_dec : forall (A : Set),
      eq_dec A ->
      eq_dec (comp_answer A).

Fixpoint evalDet_step(A : Set)(c : Comp A)(s : Blist) : comp_state A :=
  match c in Comp A return comp_state A with
    | Ret pf a => cs_done a s
    | Rnd n  => 
      match (shiftOut s n) with
        | Some (v, s') => cs_more (Ret (@Bvector_eq_dec n) v) s'
        | None => (@cs_eof (Bvector n))
      end
    | Bind c1 c2 =>     
      match (evalDet_step c1 s) with
        | cs_eof _ => (@cs_eof _)
        | cs_done b s' => cs_more (c2 b) s'
        | cs_more c1' s' => cs_more (Bind c1' c2) s'
      end
    | Repeat c P =>
      cs_more (Bind c (fun a => if (P a) then (Ret (comp_eq_dec c) a) else (Repeat c P))) s
   end.

Inductive evalDet_steps(A : Set) : comp_state A -> comp_state A -> Prop :=
  | evalDet_steps_refl : forall ans,
    evalDet_steps ans ans
  | evalDet_steps_step : 
    forall c s ans ans',
      (evalDet_step c s) = ans ->
      evalDet_steps ans ans' ->
      evalDet_steps (cs_more c s) ans'.

Hint Constructors evalDet_steps : evalDet.

Inductive evalDet(A : Set)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_done : forall a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    evalDet c s (ca_done a)
  | evalDet_eof :
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet c s (@ca_eof A).
    
Theorem evalDet_steps_trans : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall z, 
  evalDet_steps y z ->
  evalDet_steps x z.

Theorem evalDet_steps_bind_more_h : forall(A B : Set) x y,
  evalDet_steps x y ->
  forall (c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  x = (cs_more c1 s) ->
  y =  (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Theorem evalDet_steps_bind_more : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s c1' s',
  evalDet_steps (cs_more c1 s) (cs_more c1' s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (Bind c1' c2) s').

Lemma evalDet_steps_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a : A) s s',
  x = (cs_more c s) -> 
  y = (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_done_inv : forall (A : Set)(c : Comp A)(a : A) s s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (cs_done a s').

Lemma evalDet_steps_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s,
  x = (cs_more c s) -> 
  y = (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Lemma evalDet_steps_eof_inv : forall (A : Set)(c : Comp A) s,
  evalDet_steps (cs_more c s) (@cs_eof A) ->
  exists c'' s'', evalDet_steps (cs_more c s) (cs_more c'' s'') /\ evalDet_step c'' s'' = (@cs_eof A).

Theorem evalDet_steps_bind_done : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) a s s',
  evalDet_steps (cs_more c1 s) (cs_done a s') ->
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_more (c2 a) s').

Theorem evalDet_bind_eof : forall(A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more c1 s) (@cs_eof B) ->
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A).

Inductive comp_state_eq(A : Set) : comp_state A -> comp_state A -> Prop :=
  | cse_done : 
    forall a s, 
      comp_state_eq (cs_done a s) (cs_done a s)
  | cse_eof : 
    comp_state_eq (@cs_eof A) (@cs_eof A)
  | cse_more : 
    forall c1 c2 s,
      Comp_eq c1 c2 ->
      comp_state_eq (cs_more c1 s) (cs_more c2 s).

Theorem comp_state_eq_refl : forall (A : Set)(c : comp_state A),
  comp_state_eq c c.

Lemma evalDet_steps_done_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a a' s s',
  y1 = (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Theorem evalDet_steps_done_func : forall (A : Set) x (a a' : A) s s',
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (cs_done a' s') ->
  (a = a' /\ s = s').

Lemma evalDet_steps_done_eof_func_h : forall (A : Set)(x : comp_state A) y1,
  evalDet_steps x y1 ->
  forall a s,
  y1 = (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_steps_done_eof_func : forall (A : Set) x (a : A) s,
  evalDet_steps x (cs_done a s) ->
  evalDet_steps x (@cs_eof A) ->
  False.

Theorem evalDet_func : forall (A : Set)(c : Comp A)(s : Blist)(y1 y2 : comp_answer A),
  evalDet c s y1 ->
  evalDet c s y2 ->
  y1 = y2.

Definition evalDet_equiv(A : Set)(c1 c2 : Comp A) :=
  (forall s y, evalDet c1 s y <-> evalDet c2 s y).

Lemma evalDet_equiv_symm : forall (A : Set)(c1 c2 : Comp A),
  evalDet_equiv c1 c2 ->
  evalDet_equiv c2 c1.

Theorem evalDet_steps_bind_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
    x = (cs_more (Bind c1 c2) s) ->
    y = (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_done_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s s' a,
  evalDet_steps (cs_more (Bind c1 c2) s) (cs_done a s') ->
  exists b s'', evalDet_steps (cs_more c1 s) (cs_done b s'') /\
    evalDet_steps (cs_more (c2 b) s'') (cs_done a s').

Theorem evalDet_steps_bind_eof_inv_h : 
  forall (A : Set)(x y : comp_state A),
    evalDet_steps x y ->
    forall (B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
      x = (cs_more (Bind c1 c2) s) ->
      y = (@cs_eof A) ->
      evalDet_steps (cs_more c1 s) (@cs_eof B) \/
      exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
        evalDet_steps (cs_more (c2 b) s') (@cs_eof A).
  
Theorem evalDet_steps_bind_eof_inv : forall (A B : Set)(c1 : Comp B)(c2 : B -> Comp A) s,
  evalDet_steps (cs_more (Bind c1 c2) s) (@cs_eof A) ->
  evalDet_steps (cs_more c1 s) (@cs_eof B) \/
  exists b s', evalDet_steps (cs_more c1 s) (cs_done b s') /\ 
    evalDet_steps (cs_more (c2 b) s') (@cs_eof A).

Theorem evalDet_bind_assoc : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C),
  evalDet_equiv (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))).

Theorem evalDet_done_eof_func:
  forall (A : Set) (c : Comp A) (a : A) (s : Blist),
    evalDet c s (ca_done a) -> evalDet c s (@ca_eof A) -> False.

Lemma getSupport_In_evalDet_step_done : forall (A : Set)(c : Comp A) a s s',
  evalDet_step c s = cs_done a s' ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_step_more : forall (A : Set)(c c' : Comp A) s s' a,
  evalDet_step c s = cs_more c' s' ->
  In a (getSupport c') ->
  In a (getSupport c).

Lemma getSupport_In_evalDet_steps_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a s s',
    x = (cs_more c s)  ->
    y = (cs_done a s') -> 
    In a (getSupport c).

Lemma getSupport_In_evalDet_steps : forall (A : Set)(c : Comp A) a s s',
  evalDet_steps (cs_more c s) (cs_done a s') -> 
  In a (getSupport c).

Theorem getSupport_In_evalDet : forall (A : Set)(c : Comp A) a s,
  evalDet c s (ca_done a) -> 
  In a (getSupport c).

Inductive evalDet_repeat_steps (A : Set)(P : A -> bool) : comp_state A -> comp_state A -> Prop :=
| evalDet_repeat_steps_done : 
  forall c s a s',
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = true ->
    evalDet_repeat_steps P (cs_more c s) (cs_done a s')
| evalDet_repeat_steps_eof :
  forall c s,
    evalDet_steps (cs_more c s) (@cs_eof A) ->
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A)
| evalDet_repeat_steps_step :
  forall c s a s' y,
    evalDet_steps (cs_more c s) (cs_done a s') ->
    P a = false ->
    evalDet_repeat_steps P (cs_more c s') y ->
    evalDet_repeat_steps P (cs_more c s) y.

Inductive evalDet_repeat(A : Set)(P : A -> bool)(c : Comp A)(s : Blist) : comp_answer A -> Prop :=
  | evalDet_repeat_done : forall a s',
    evalDet_repeat_steps P (cs_more c s) (cs_done a s') ->
    evalDet_repeat P c s (ca_done a)
  | evalDet_repeat_eof :
    evalDet_repeat_steps P (cs_more c s) (@cs_eof A) ->
    evalDet_repeat P c s (@ca_eof A).

Lemma list_skipn_strong_ind_h : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  (forall n, P (skipn n l)).

Lemma list_skipn_strong_ind : forall (A : Type) l (P : list A -> Prop) ,
  P nil -> 
  (forall x, (forall n, n > 0 -> P (skipn n x)) -> P x) ->
  P l.

Lemma evalDet_step_nil_inv : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_step c nil = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_step c nil = (cs_done a ls) ->
  ls = nil.

Lemma evalDet_step_more_nil_inv : forall (A : Set)(c c' : Comp A) ls,
  evalDet_step c nil = (cs_more c' ls) ->
  ls = nil.

Lemma evalDet_step_done_support_singleton : forall (A : Set)(c : Comp A) s a,
  evalDet_step c s = cs_done a s ->
  getSupport c = (a :: nil).

Lemma getUnique_NoDup_eq : forall (A : Set)(eqd : eq_dec A)(ls : list A),
  NoDup ls ->
  getUnique ls eqd = ls.

Lemma getUnique_Permutation : forall (A : Set)(eqd1 eqd2 : eq_dec A)(ls1 ls2 : list A),
  Permutation ls1 ls2 ->
  Permutation (getUnique ls1 eqd1) (getUnique ls2 eqd2).

Lemma flatten_Permutation : forall (A : Type)(ls1 ls2 : list (list A)),
  Permutation ls1 ls2 ->
  Permutation (flatten ls1) (flatten ls2).

Lemma to_list_nil_inv : forall (A : Type)(n : nat)(v : Vector.t A n),

Lemma app_second_eq :
  forall (A : Type) (ls2 ls1 ls3 : list A),
    ls1 = ls2 ++ ls3 -> length ls1 = length ls3 -> ls1 = ls3 /\ ls2 = nil.

Lemma shiftOut_same_inv : forall s n v,
  shiftOut s n = Some (v, s) ->
  n = O.

Lemma filter_Permutation : forall (A : Set)(ls1 ls2 : list A)(P : A -> bool),
  Permutation ls1 ls2 ->
  Permutation (filter P ls1) (filter P ls2).

Lemma evalDet_step_more_support_preserved : forall (A : Set)(c c' : Comp A) s,
  evalDet_step c s = (cs_more c' s) ->
  Permutation (getSupport c) (getSupport c').

Lemma evalDet_steps_nil_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a1 a2 : A) s2,
  x = (cs_more c nil) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_steps_nil_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s2,
  evalDet_steps (cs_more c nil) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_val_eq : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  a1 = a2.

Lemma evalDet_step_done_ls_eq : forall (A : Set)(c : Comp A)(a2 : A) s1 s2,
  evalDet_step c s1 = (cs_done a2 s2) ->
  s1 = s2.

Lemma shiftOut_skipn : forall n (v : Bvector n) s s',
  shiftOut s n = Some (v, s') ->
  s' = skipn n s.

Lemma evalDet_step_more_skipn_eq : forall (A : Set)(c c' : Comp A)(a1 : A) s1 s2,
  evalDet_step c s1 = (cs_more c' s2) ->
  In a1 (getSupport c) ->
  (s1 = s2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_step_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_step  c s = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma skipn_sum : forall (A : Type)(n2 n1 : nat)(ls : list A),
  skipn n1 (skipn n2 ls) = skipn (n2 + n1) ls.

Lemma evalDet_step_more_skipn : forall (A : Set)(c c' : Comp A) s s',
  evalDet_step  c s = (cs_more c' s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s a s', 
    x = (cs_more c s) ->
    y = (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_done_skipn : forall (A : Set)(c : Comp A) s a s',
  evalDet_steps (cs_more c s) (cs_done a s') ->
  exists n, s' = skipn n s.

Lemma evalDet_steps_skipn_h : forall (A : Set) a1 (x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A)(a2 : A) s1 s2,
  x = (cs_more c s1) -> 
  y = (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_steps_skipn : forall (A : Set)(c : Comp A)(a1 a2 : A) s1 s2,
  evalDet_steps (cs_more c s1) (cs_done a2 s2) ->
  In a1 (getSupport c) ->
  (a1 = a2 \/ (exists n, n > 0 /\ s2 = skipn n s1)).

Lemma evalDet_repeat_steps_dec : forall (s : Blist)(A : Set)(c : Comp A)(P : A -> bool),
  (exists a, In a (getSupport c) /\ P a = true) ->
  (forall s', (exists a s'', evalDet_steps (cs_more c s') (cs_done a s'')) \/ evalDet_steps (cs_more c s') (@cs_eof A)) ->
  exists y, evalDet_repeat_steps P (cs_more c s) y.

Lemma evalDet_repeat_steps_done_inv_h : forall (A : Set)(P : A -> bool) x y,
  evalDet_repeat_steps P x y ->
  forall c s,
  x = (cs_more c s) -> 
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_done_inv : forall (A : Set)(c : Comp A)(P : A -> bool) s y,
  evalDet_repeat_steps P (cs_more c s) y ->
  evalDet_steps (cs_more (Repeat c P) s) y.

Lemma evalDet_repeat_steps_more_inv_h : forall (A : Set)(x y : comp_state A) P,
  evalDet_repeat_steps P x y ->
  forall (c: Comp A)(P : A -> bool) s,
  y = (cs_more c s) ->
  False.

Lemma evalDet_repeat_steps_more_inv : forall (A : Set) x (c : Comp A)(P : A -> bool) s,
  evalDet_repeat_steps P x (cs_more c s) ->
  False.

Lemma evalDet_steps_dec : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall s, 
  (exists a s', evalDet_steps (cs_more c s) (cs_done a s')) \/ 
  (evalDet_steps (cs_more c s) (@cs_eof A)).

Lemma evalDet_dec : forall (A : Set)(c : Comp A)(s : Blist),
  well_formed_comp c ->
  (exists a, evalDet c s (ca_done a)) \/ (evalDet c s (@ca_eof A)).

Lemma evalDet_step_app_done_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_step c s = (cs_done a s'') ->
  evalDet_step c (s ++ s') = (cs_done a (s'' ++ s')).

Lemma evalDet_step_app_more_eq : forall (A : Set)(c c': Comp A) s s' s'',
  evalDet_step c s = (cs_more c' s'') ->
  evalDet_step c (s ++ s') = (cs_more c' (s'' ++ s')).

Lemma evalDet_steps_app_eq_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) s s' s'' a,
    x = (cs_more c s) ->
    y = (cs_done a s'') ->
    evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_steps_app_eq : forall (A : Set)(c : Comp A) s s' s'' a,
  evalDet_steps (cs_more c s) (cs_done a s'') ->
  evalDet_steps (cs_more c (s ++ s')) (cs_done a (s'' ++ s')).

Lemma evalDet_app_eq : forall (A : Set)(c : Comp A) s s' a,
  evalDet c s (ca_done a) ->
  evalDet c (s ++ s') (ca_done a).

Lemma evalDet_steps_done_nil_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls,
    x = (cs_more c nil) ->
    y = (cs_done a ls) ->
    ls = nil.

Lemma evalDet_steps_done_nil_inv : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma app_eq_nil_inv : forall (A : Set)(ls2 ls1 ls3 : list A),
  ls1 = ls2 ++ ls3 ->
  length ls1 = length ls2 ->
  ls3 = nil.

Lemma evalDet_steps_repeat_done_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s a s',
  evalDet_steps x (cs_more (Repeat c P) s) ->
  y = (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_done_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s a s',
  evalDet_steps (cs_more (Repeat c P) s) (cs_done a s') ->
  evalDet_repeat_steps P (cs_more c s) (cs_done a s').

Lemma evalDet_steps_repeat_eof_inv_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (P : A -> bool)(c : Comp A) s,
    evalDet_steps x (cs_more (Repeat c P) s) ->
    y = (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_steps_repeat_eof_inv : forall (A : Set)(P : A -> bool)(c : Comp A) s,
  evalDet_steps (cs_more (Repeat c P) s) (cs_eof A)->
  evalDet_repeat_steps P (cs_more c s) (cs_eof A).

Lemma evalDet_repeat_steps_nil_inv_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall (P : A -> bool) c a ls',
  x = (cs_more c nil) ->
  y = (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_nil_inv : forall (A : Set)(P : A -> bool) c a ls',
  evalDet_repeat_steps P (cs_more c nil) (cs_done a ls') ->
  ls' = nil.

Lemma evalDet_repeat_steps_app_nil_h : forall (A : Set) P (x y : comp_state A),
  evalDet_repeat_steps P x y ->
  forall c ls1 ls2 b a,
    x = (cs_more c ls1) ->
    y = (cs_eof A) ->
    evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2)->
    (forall s s' b a,
      evalDet_steps (cs_more c s) (cs_eof A) ->
      evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
      s' = nil) ->
    ls2 = nil.

Lemma evalDet_repeat_steps_app_nil : forall (A : Set)(c : Comp A) P ls1 ls2 b a,
  evalDet_repeat_steps P (cs_more c ls1) (cs_eof A) ->
  evalDet_repeat_steps P (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  (forall s s' b a,
    evalDet_steps (cs_more c s) (cs_eof A) ->
    evalDet_steps (cs_more c (s ++ b :: nil)) (cs_done a s') ->
    s' = nil) ->
  ls2 = nil.

Lemma evalDet_app_nil : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall ls1 ls2 b a,
  evalDet c ls1 (ca_eof A) ->
  evalDet_steps (cs_more c (ls1 ++ b :: nil)) (cs_done a ls2) ->
  ls2 = nil.

Lemma evalDet_step_done_inv : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_step c ls = cs_done a ls' ->
  exists eqd, 
    c = Ret eqd a.

Lemma evalDet_step_more_sublist : forall (A : Set)(c : Comp A) c' ls ls',
  evalDet_step c ls = (cs_more c' ls') ->
  exists ls'', ls = ls'' ++ ls'.
    
Lemma evalDet_sublist_h : forall (A : Set)(x y : comp_state A),
  evalDet_steps x y ->
  forall (c : Comp A) a ls ls' ,
    x = (cs_more c ls) ->
    y = (cs_done a ls') ->
    exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_sublist : forall (A : Set)(c : Comp A) a ls ls',
  evalDet_steps (cs_more c ls) (cs_done a ls') ->
  exists ls'', ls = ls'' ++ ls'.

Lemma evalDet_nil : forall (A : Set)(c : Comp A) a ls,
  evalDet_steps (cs_more c nil) (cs_done a ls) ->
  ls = nil.

Lemma evalDet_left_total : forall (A : Set)(c : Comp A) s,
  well_formed_comp c ->
  exists ans, evalDet c s ans.
  
Lemma evalDet_steps_done_support_singleton_h : forall (A : Set)(x1 x2 : comp_state A),
  evalDet_steps x1 x2 ->
  forall (c : Comp A) a s,
    x1 = (cs_more c nil) ->
    x2 = (cs_done a s) ->
    getSupport c = a :: nil.

Lemma evalDet_steps_done_support_singleton : forall (A : Set)(c : Comp A) a s,
  evalDet_steps (cs_more c nil) (cs_done a s) ->
  getSupport c = a :: nil.

Lemma evalDet_step_well_formed_comp_preserved : forall (A : Set)(c : Comp A),
  well_formed_comp c ->
  forall c' s s',
    evalDet_step c s = (cs_more c' s') ->
    well_formed_comp c'. *)
Require Import FCF.NotationV1.
(* FCF.NotationV1:
Set Implicit Arguments.

Require Import FCF.Comp.

Local Open Scope comp_scope.

Notation "'ret' v" := (Ret (EqDec_dec _) v)
  (at level 75).

Notation "{ 0 , 1 } ^ n" := (Rnd n)
  (right associativity, at level 77) : comp_scope.

Notation "{ 0 , 1 }" := (Bind (Rnd 1) (fun m => ret (Vector.hd m)))
  (right associativity, at level 75) : comp_scope.

Notation "x <-$ c1 ; c2" := (@Bind _ _ c1%comp (fun x => c2)) 
  (right associativity, at level 81, c1 at next level) : comp_scope.

Notation "[ x1 , x2 ] <-$2 c1 ; c2" := 
  (Bind c1%comp (fun z => let '(x1, x2) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Notation "[ x1 , x2 , x3 ] <-$3 c1 ; c2" := 
  (Bind c1%comp (fun z => let '(x1, x2, x3) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Definition setLet(A : Set)(B : Type)(a : A)(f : A -> B) := f a.

Notation "x <- e1 ; e2" := (setLet e1 (fun x => e2)) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 ] <-2 e1 ; c2" := (let '(x1, x2) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 , x3 ] <-3 e1 ; c2" := (let '(x1, x2, x3) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 , x3 , x4 ] <-4 e1 ; c2" := (let '(x1, x2, x3, x4) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 , x3 , x4 , x5 ] <-5 e1 ; c2" := (let '(x1, x2, x3, x4, x5) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "x <--$ c1 ; c2" := (OC_Bind c1%comp (fun x => c2)) 
  (right associativity, at level 81, c1 at next level) : comp_scope.

Notation "[ x1 , x2 ] <--$2 c1 ; c2" := 
  (OC_Bind c1%comp (fun z => let '(x1, x2) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Notation "[ x1 , x2 , x3 ] <--$3 c1 ; c2" := 
  (OC_Bind c1%comp (fun z => let '(x1, x2, x3) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Notation "$ c" := (OC_Ret _ _ c) (at level 79) : comp_scope.

Notation "x <-? c1 ; c2" := (maybeBind c1 (fun x => (c2)))
                              (right associativity, at level 81, c1 at next level) : comp_scope.

Definition maybeBindComp(A B : Set)(eqdb : EqDec B)(c : Comp (option A))(f : A -> Comp B) : Comp (option B) :=
  opt_a <-$ c;
  match opt_a with
    | None => ret None
    | Some a => b <-$ (f a); ret (Some b)
  end.

Notation "x <-$? c1 ; c2" := 
   (maybeBindComp _ (c1)%comp (fun x => (c2)%comp))
                              (right associativity, at level 81, c1 at next level) : comp_scope.

Infix "xor" := (BVxor _) (at level 30). *)

Local Open Scope rat_scope.
Local Open Scope comp_scope.
Local Open Scope list_scope.

Theorem uniformity : forall n (x1 x2 : Bvector n),
  evalDist ({0, 1} ^ n) x1 == evalDist ({0, 1} ^ n) x2.

  intuition.
  unfold evalDist.
  eapply eqRat_refl.
Qed.

Lemma evalDist_in_f : forall (A B : Set)(c1 : Comp A)(c2 : Comp B)(f : A -> B),
  (forall a, eqRat (evalDist c1 a) (evalDist c2 (f a))) ->
  (forall a, In a (getSupport c1) <-> In (f a) (getSupport c2)).

  intros.
  specialize (getSupport_correct c1).
  specialize (getSupport_correct c2).
  intros.
  inversion H0; clear H0.
  inversion H1; clear H1.

  intuition.
  apply H3.
  intuition.
  eapply H4; eauto.
  eapply eqRat_trans.
  eapply H.
  eauto.

  eapply H4.
  intuition.
  eapply H3; eauto.
  eapply eqRat_trans.
  eapply eqRat_symm.
  eapply H.
  eauto.
Qed.

Lemma perm_map_in : forall (A B : Set)(lsa : list A)(lsb : list B)(f : A -> B)(f_inv : B -> A),
  (forall b, In b lsb -> f (f_inv b) = b) ->
  (forall a, In a lsa <-> In (f a) lsb) ->
  NoDup (map f lsa) ->
  NoDup lsb ->
  Permutation (map f lsa) lsb.

  intuition.
  eapply NoDup_Permutation; intuition.
  apply in_map_iff in H3.
  destruct H3.
  intuition.
  subst.
  eapply H0.
  trivial.

  eapply in_map_iff.
  econstructor.
  split.
  2:{
    eapply H0.
    assert (x = f (f_inv x)).
    symmetry.
    eapply H.
    trivial.
    rewrite H4 in H3.
    eapply H3.
  }
  eapply H.
  trivial.
Qed.

Lemma not_in_map : forall (A B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A)(a : A),
  (forall a, f_inv (f a) = a) -> 
  ~In a ls -> 
  ~In (f a) (map f ls).

  induction ls; intuition.
  simpl in *.

  intuition.
  
  eapply H1.
  rewrite <- (H a).
  rewrite <- (H a0).
  f_equal.
  trivial.

  eapply IHls; eauto.
Qed.

Lemma map_NoDup : forall (A B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A),
  (forall a, In a ls -> f_inv (f a) = a) ->
  NoDup ls ->
  NoDup (map f ls).

  induction ls; intuition; simpl in *.
  econstructor.

  inversion H0; clear H0; subst.
  econstructor; eauto.

  intuition.
  apply in_map_iff in H0.
  destruct H0.
  intuition.
  assert (x = a).
  rewrite <- (H x); intuition.
  rewrite <- (H a); intuition.
  f_equal.
  trivial.
  subst.
  intuition.
Qed.

Lemma support_NoDup : forall (A : Set)(c : Comp A),
  NoDup (getSupport c).

  intuition.
  specialize (getSupport_correct c); intuition.
  inversion H.
  eauto.
Qed.

Lemma filter_NoDup : forall (A : Set)(ls : list A)(P : A -> bool),
  NoDup ls ->
  NoDup (filter P ls).

  induction ls; simpl in *; intuition.
  
  inversion H; clear H; subst.
  destruct (P a).
  econstructor; eauto.
  intuition.
  eapply filter_In in H.
  intuition.

  eapply IHls; eauto.

Qed.

Lemma evalDist_getSupport_perm : forall (A B : Set)(c1 : Comp A)(c2 : Comp B) (f : A -> B)(f_inv : B -> A),
  (forall b, In b (getSupport c2) -> (f (f_inv b)) = b) ->
  (forall a, In a (getSupport c1) -> (f_inv (f a)) = a) -> 
  (forall a, In a (getSupport c1) -> eqRat (evalDist c1 a) (evalDist c2 (f a))) ->
  (forall a, In a (getSupport c2) -> eqRat (evalDist c2 a) (evalDist c1 (f_inv a))) ->
  Permutation (map f (getSupport c1)) (getSupport c2).

  intuition.
  eapply NoDup_Permutation.
  eapply map_NoDup.
  intuition.
  eapply getSupport_NoDup.
  eapply getSupport_NoDup.
  intuition.
  apply in_map_iff in H3.
  destruct H3.
  intuition.
  subst.
  eapply getSupport_In_evalDist.
  intuition.
  eapply getSupport_In_evalDist.
  eauto.
  eapply eqRat_trans.
  eapply H1.
  trivial.
  trivial.

  eapply in_map_iff.
  econstructor.
  split.
  eapply H.
  trivial.
  
  eapply getSupport_In_evalDist.
  intuition.
  eapply getSupport_In_evalDist.
  eapply H3.
  rewrite H2.
  trivial.
  trivial.

Qed.

Lemma evalDist_getSupport_filter_perm : forall (A: Set)(c1 : Comp A)(c2 : Comp A)(P : A -> bool),
  (forall a, P a = true -> eqRat (evalDist c1 a) (evalDist c2 a)) ->
  Permutation (filter P (getSupport c1)) (filter P (getSupport c2)).

  intuition.
  eapply NoDup_Permutation.
  eapply filter_NoDup.
  eapply support_NoDup.
  eapply filter_NoDup.
  eapply support_NoDup.

  intuition.
  eapply filter_In in H0.
  eapply filter_In.
  intuition.
  eapply getSupport_In_evalDist.
  apply getSupport_In_evalDist in H1.
  intuition.
  apply H1.
  eapply eqRat_trans.
  eapply H.
  trivial.
  trivial.

  intuition.
  eapply filter_In in H0.
  eapply filter_In.
  intuition.
  eapply getSupport_In_evalDist.
  apply getSupport_In_evalDist in H1.
  intuition.
  apply H1.
  eapply eqRat_trans.
  eapply eqRat_symm.
  eapply H.
  trivial.
  trivial.
Qed.

Lemma evalDist_getSupport_perm_id : forall (A : Set)(c1 c2 : Comp A),
  (forall a, eqRat (evalDist c1 a) (evalDist c2 a)) ->
  Permutation (getSupport c1) (getSupport c2).

  intuition.
  rewrite <- map_id.
  eapply Permutation_sym.
  eapply evalDist_getSupport_perm; intuition.
  symmetry.
  eauto.
Qed.

Lemma sumList_f_inverse : forall (A B : Set)(ls : list A)(f : A -> B)(f_inv : B -> A)(fa : A -> Rat),
    (forall a, In a ls -> f_inv (f a) = a) ->
    sumList (map f ls) (fun (b : B) => fa (f_inv b) ) ==
    sumList ls fa.
    
  intuition.
  unfold sumList.
  eapply fold_add_f_inverse;
  intuition.
Qed.

Theorem distro_iso_eq : forall (A B C D : Set)(f : C -> D)(f_inv : D -> C)(d : Comp D)(c : Comp C)(f1 : D -> Comp B)(f2 : C -> Comp A)(a : A)(b : B),
  (forall x, In x (getSupport d) -> f (f_inv x) = x) ->
  (forall x, In x (getSupport c) -> f_inv (f x) = x) ->
  (forall x, In x (getSupport d) -> In (f_inv x) (getSupport c)) ->
  (forall x, In x (getSupport c) -> (evalDist d (f x)) == (evalDist c x)) -> 
  (forall x, In x (getSupport c) -> (evalDist (f1 (f x)) b) == (evalDist (f2 x) a)) ->
  (evalDist (Bind d f1) b == evalDist (Bind c f2) a).

  intuition.
  simpl.

  eapply eqRat_trans.
  eapply fold_add_rat_perm.
  eapply Permutation_sym.
  eapply evalDist_getSupport_perm; eauto.

  intuition.
  symmetry.
  eauto.

  intuition.
  rewrite <- (H a0) at 1.
  eapply H2.
  eauto.
  trivial.

  eapply eqRat_refl.
  intuition.
  eapply ratMult_eqRat_compat.
  rewrite <- H at 1.
  eauto.
  trivial.
  rewrite <- H at 1.
  eapply H3.
  eauto.
  trivial.

  eapply eqRat_trans.
  2:{
    eapply fold_add_f_inverse; eauto.
    eapply eqRat_refl.
  }
  simpl.
  eapply eqRat_refl.

Qed.

Lemma evalDist_seq_eq : forall (A1 A2 B : Set)(c1 c2 : Comp B)(f1 : B -> Comp A1)(f2 : B -> Comp A2) y z,
  (forall x : B, evalDist c1 x == evalDist c2 x) ->
  (forall x : B, In x (getSupport c1) -> evalDist (f1 x) y == evalDist (f2 x) z) ->
  evalDist (x <-$ c1; f1 x) y == evalDist (x <-$ c2; f2 x) z.

  intuition.
  eapply (distro_iso_eq (fun b => b)(fun b => b)); intuition.

  eapply getSupport_In_evalDist.
  intuition.
  eapply getSupport_In_evalDist.
  eauto.
  rewrite H.
  trivial.

  eapply H0.
  eapply getSupport_In_evalDist.
  intuition.
  eapply getSupport_In_evalDist.
  eauto.
  rewrite <- H.
  trivial.
Qed.

Theorem distro_irr_eq : forall (A B : Set)(b : Comp B)(a : B -> Comp A)(y : A) v,
  well_formed_comp b ->
  (forall x, In x (getSupport b) -> (evalDist (a x) y) == v) -> 
  evalDist (Bind b a) y == v.
  
  intuition.
  simpl.
  rewrite sumList_body_eq.
  2:{
    intuition.
    rewrite H0 at 1.
    eapply eqRat_refl.
    trivial.
  }
  rewrite sumList_factor_constant_r.
  rewrite evalDist_lossless.
  eapply ratMult_1_l.
  trivial.
Qed.

Lemma sumList_filter : forall (A : Set)(ls : list A)(f : A -> Rat)(P : A -> bool) init,
  fold_left (fun r a => r + if (P a) then (f a) else 0) ls init  ==
  fold_left (fun r a => r + (f a)) (filter P ls) init.

  induction ls; simpl in *; intuition.

  destruct (P a); simpl.
  eapply IHls.
  rewrite fold_add_body_eq.
  eapply IHls.
  symmetry.
  eapply ratAdd_0_r.
  
  intuition.
Qed.

Theorem evalDist_left_ident_eq : forall (B : Set)(eqd : EqDec B)(b : B)(A : Set)(c2 : B -> Comp A)  a,
  (evalDist (x <-$ ret b; (c2 x)) a) == (evalDist (c2 b) a).

  intuition.
  simpl.
  unfold sumList.
  simpl.
  destruct (EqDec_dec eqd b b).
  rewrite <- ratAdd_0_l.
  rewrite ratMult_1_l.
  intuition.
  congruence.

Qed.

Theorem evalDist_assoc_eq : forall (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C),
  dist_sem_eq (Bind (Bind c1 c2) c3) (Bind c1 (fun a => (Bind (c2 a) c3))).

  unfold dist_sem_eq.
  intuition.
  assert (EqDec B).
  eapply bind_EqDec; eauto.
  simpl.
  eapply eqRat_trans.
  eapply sumList_body_eq.
  intuition.
  symmetry.
  eapply sumList_factor_constant_r.
  simpl.
  rewrite sumList_comm.
  eapply sumList_body_eq.
  intuition.
  rewrite <- sumList_factor_constant_l.
  eapply eqRat_trans.
  eapply (sumList_filter_partition (fun b => if (in_dec (EqDec_dec _) b (getSupport (c2 a0))) then true else false)).
  eapply eqRat_trans.
  eapply ratAdd_eqRat_compat.
  eapply eqRat_refl.
  eapply sumList_0.
  intuition.
  eapply filter_In in H1.
  intuition.
  destruct (in_dec (EqDec_dec H) a1 (getSupport (c2 a0))).
  simpl in H3.
  discriminate.
  assert (evalDist (c2 a0) a1 == 0).
  eapply getSupport_not_In_evalDist.
  trivial.
  rewrite H1.
  rewrite ratMult_0_r.
  eapply ratMult_0_l.
  rewrite <- ratAdd_0_r.
  eapply eqRat_trans.
  eapply sumList_permutation.
  2:{
    eapply sumList_body_eq.
    intuition.
    eapply ratMult_assoc.
  }
  eapply NoDup_Permutation.
  eapply filter_NoDup.
  eapply getUnique_NoDup.
  eapply getSupport_NoDup.
  intuition.
  apply filter_In in H1.
  intuition.
  destruct (in_dec (EqDec_dec H) x (getSupport (c2 a0))).
  trivial.
  discriminate.

  eapply filter_In.
  intuition.
  eapply in_getUnique.
  eapply in_flatten.
  econstructor.
  split.
  eapply in_map_iff.
  econstructor.
  split.
  eapply eq_refl.
  eauto.
  eauto.
  destruct (in_dec (EqDec_dec H) x (getSupport (c2 a0)) ).
  trivial.
  intuition.
Qed.

Theorem evalDist_commute_eq : forall (A B : Set)(c1 : Comp A)(c2 : Comp B)(C : Set)(c3 : A -> B -> Comp C),
  dist_sem_eq (a <-$ c1; b <-$ c2; (c3 a b)) (b <-$ c2; a <-$ c1; (c3 a b)). 
  
  intuition.
  unfold dist_sem_eq.
  intuition.
  simpl.
  eapply eqRat_trans.
  eapply sumList_body_eq.
  intuition.
  symmetry.
  eapply sumList_factor_constant_l.
  symmetry.
  eapply eqRat_trans.
  eapply sumList_body_eq.
  intuition.
  symmetry.
  eapply sumList_factor_constant_l.
  rewrite sumList_summation.
  eapply sumList_body_eq.
  intuition.
  eapply sumList_body_eq.
  intuition.
  repeat rewrite <- ratMult_assoc.
  eapply ratMult_eqRat_compat; intuition.
  eapply ratMult_comm.
Qed.

Lemma evalDist_Repeat_eq : forall (A : Set)(c1 c2 : Comp A)(P1 P2 : A -> bool) v1 v2,
  evalDist c1 v1 == evalDist c2 v2 ->
  P1 v1 = P2 v2 ->
  In v1 (filter P1 (getSupport c1)) ->
  sumList (filter P1 (getSupport c1)) (evalDist c1) == sumList (filter P2 (getSupport c2)) (evalDist c2) ->
  evalDist (Repeat c1 P1) v1 == evalDist (Repeat c2 P2) v2.
  
  intuition.
  simpl.
  eapply ratMult_eqRat_compat; intuition.
  eapply ratMult_eqRat_compat.
  unfold indicator.
  rewrite H0.
  intuition.
  eapply ratInverse_eqRat_compat.
  intuition.
  eapply getSupport_In_evalDist.
  eapply filter_In.
  eauto.
  eapply sumList_0 in H3; eauto.
  trivial.
  
Qed.

Definition intersect(A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) :=
  filter (fun x => if (in_dec eqd x ls1) then true else false) ls2.

Lemma in_intersect : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A) a,
  In a (intersect eqd ls1 ls2) <->
  In a ls1 /\ In a ls2.
  
  unfold intersect in *.
  
  intuition.
  apply filter_In in H.
  intuition.
  destruct (in_dec eqd a ls1).
  trivial.
  discriminate.
  apply filter_In in H.
  intuition.
  
  eapply filter_In.
  intuition.
  destruct (in_dec eqd a ls1); intuition.
Qed.

Lemma intersect_comm : forall (A : Set)(eqd : eq_dec A)(ls1 ls2 : list A),
  NoDup ls1 ->
  NoDup ls2 ->
  Permutation (intersect eqd ls1 ls2) (intersect eqd ls2 ls1).
  
  intuition.
  eapply NoDup_Permutation.
  apply filter_NoDup; trivial.
  apply filter_NoDup; trivial.
  
  unfold intersect in *.
  intuition.
  apply filter_In.
  apply filter_In in H1.
  intuition.
  destruct (in_dec eqd x ls1); intuition.
  discriminate.
  destruct (in_dec eqd x ls2); intuition.
  
  apply filter_In.
  apply filter_In in H1.
  intuition.
  destruct (in_dec eqd x ls2); intuition.
  discriminate.
  destruct (in_dec eqd x ls1); intuition.
  
Qed.

Theorem fundamental_lemma_h : forall (A : Set)(eqda : EqDec A)(c1 c2 : Comp (A * bool)),
  (evalDist (Bind c1 (fun x => ret snd x)) true == evalDist (Bind c2 (fun x => ret snd x)) true) ->
  (forall a, evalDist c1 (a, false) == evalDist c2 (a, false)) ->
  forall a, 
    ratDistance (evalDist (Bind c1 (fun x => ret (fst x))) a) (evalDist (Bind c2 (fun x => ret (fst x))) a) <= 
    evalDist (Bind c1 (fun x => ret snd x)) true.

  intuition.
  simpl in *.

  rewrite (sumList_filter_partition (@snd A bool)).
  rewrite (sumList_filter_partition (@snd A bool) (getSupport c2)).

  rewrite ratDistance_add_same_r_gen.

  eapply leRat_trans.
  eapply ratDistance_le_max_triv.
  eapply maxRat_leRat_same.

  eapply leRat_trans.
  2:{
    eapply sumList_filter_le.
  }

  eapply sumList_le; intuition.
  apply filter_In in H1.
  intuition.
  eapply ratMult_leRat_compat; intuition.
  destruct a0.
  simpl in *.
  subst.
  destruct (EqDec_dec bool_EqDec true true); try congruence.
  destruct (EqDec_dec eqda a0 a); intuition.

  eapply leRat_trans.
  2:{
    eapply eqRat_impl_leRat.
    symmetry.
    eapply H.
  }
  eapply leRat_trans.
  2:{
    eapply sumList_filter_le.
  }
  eapply sumList_le; intuition.
  apply filter_In in H1.
  intuition.
  eapply ratMult_leRat_compat; intuition.
  destruct a0.
  simpl in *.
  subst.
  destruct (EqDec_dec bool_EqDec true true); try congruence.
  destruct (EqDec_dec eqda a0 a); intuition.

  assert (eq_dec (A * bool)).
  unfold eq_dec.
  eapply (EqDec_dec (pair_EqDec _ _)).

  assert (NoDup (filter (fun a0 : A * bool => negb (snd a0)) (intersect H1 (getSupport c1) (getSupport c2)))).
  eapply filter_NoDup.
  eapply filter_NoDup; eapply getSupport_NoDup.
  
  eapply eqRat_trans.
  symmetry.
  eapply sumList_subset'.
  trivial.
  eapply H2.
  eapply filter_NoDup.
  eapply getSupport_NoDup.
  intuition.
  apply filter_In in H3.
  intuition.
  eapply filter_In.
  split.

  eapply in_intersect.
  eapply Permutation_in.
  eapply intersect_comm.
  eapply getSupport_NoDup.
  2:{
    eauto.
  }
  eapply getSupport_NoDup.
  trivial.

  intuition.
  apply filter_In in H3.
  intuition.
  destruct a0.
  simpl in *.
  destruct (EqDec_dec eqda a0 a); subst.
  rewrite ratMult_1_r.
  destruct b; simpl in *; try discriminate.
  rewrite H0.
  eapply getSupport_not_In_evalDist.
  intuition.
  eapply H4.
  eapply filter_In.
  intuition.
  eapply in_intersect.
  intuition.
  apply ratMult_0_r.

  symmetry.
  eapply eqRat_trans.
  symmetry.
  eapply sumList_subset'.
  trivial.
  eapply H2.
  eapply filter_NoDup.
  eapply getSupport_NoDup.
  intuition.
  apply filter_In in H3.
  intuition.
  eapply filter_In.
  split.

  eapply in_intersect.
  eauto.
  trivial.

  intuition.
  apply filter_In in H3.
  intuition.
  destruct a0.
  simpl in *.
  destruct (EqDec_dec eqda a0 a); subst.
  rewrite ratMult_1_r.
  destruct b; simpl in *; try discriminate.
  rewrite <- H0.
  eapply getSupport_not_In_evalDist.
  intuition.
  eapply H4.
  eapply filter_In.
  intuition.
  eapply in_intersect.
  intuition.
  apply ratMult_0_r.

  eapply sumList_body_eq.
  intuition.
  apply filter_In in H3.
  intuition.
  destruct a0; simpl in *.
  destruct b; simpl in *; try discriminate.
  rewrite H0.
  intuition.
Qed.

Theorem evalDist_right_ident : forall (A : Set)(eqd : EqDec A)(c : Comp A) a,
  evalDist (x <-$ c; ret x) a == evalDist c a.

  intuition.
  destruct (in_dec (EqDec_dec eqd) a (getSupport c)).
  simpl.
  eapply eqRat_trans.
  eapply sumList_exactly_one.
  eapply getSupport_NoDup.
  eauto.
  intuition.
  destruct (EqDec_dec eqd b a).
  subst.
  intuition.
  eapply ratMult_0_r.

  destruct (EqDec_dec eqd a a).
  eapply ratMult_1_r.
  congruence.

  simpl.
  eapply eqRat_trans.
  eapply sumList_0.
  intuition.
  destruct (EqDec_dec eqd a0 a).
  subst.
  intuition.
  eapply ratMult_0_r.
  symmetry.
  eapply getSupport_not_In_evalDist.
  trivial.
Qed.

Theorem fundamental_lemma : forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(c1 c2 : Comp A)(badness : A -> bool)(proj : A -> B),
  Pr [a <-$ c1; ret (badness a)] == Pr[a <-$ c2; ret (badness a)] ->
  (forall x, evalDist (a <-$ c1; ret (proj a, badness a)) (x, false) == evalDist (a <-$ c2; ret (proj a, badness a)) (x, false)) ->
  forall x, 
    | (evalDist (a <-$ c1; ret (proj a)) x)  - (evalDist (a <-$ c2; ret (proj a)) x) | <= 
    Pr [a <-$ c1; ret (badness a)].

  intuition.
  specialize (@fundamental_lemma_h B eqdb (a <-$ c1; ret (proj a, badness a)) (a <-$ c2; ret (proj a, badness a)) ); intuition.
  assert ( | evalDist (x <-$ (a0 <-$ c1; ret (proj a0, badness a0)); ret fst x) x -
       evalDist (x <-$ (a0 <-$ c2; ret (proj a0, badness a0)); ret fst x) x | ==
          | evalDist (a <-$ c1; ret proj a) x - evalDist (a <-$ c2; ret proj a) x |).
  eapply ratDistance_eqRat_compat.

  eapply eqRat_trans.
  eapply evalDist_assoc_eq.
  cbv beta.
  eapply eqRat_trans.
  eapply evalDist_seq_eq.
  intuition.
  eapply eqRat_refl.
  intuition.
  eapply eqRat_trans.
  eapply evalDist_left_ident_eq.
  eapply eqRat_refl.
  cbv beta.
  unfold fst.
  intuition.

  eapply eqRat_trans.
  eapply evalDist_assoc_eq.
  cbv beta.
  eapply evalDist_seq_eq; intuition.
  eapply evalDist_left_ident_eq.

  rewrite <- H2.
  rewrite H1.
  eapply leRat_trans.
  eapply eqRat_impl_leRat.
  eapply eqRat_trans.
  eapply evalDist_assoc_eq.
  cbv beta.
  eapply evalDist_seq_eq; intuition.
  eapply eqRat_refl.
  eapply eqRat_trans.
  eapply evalDist_left_ident_eq.
  cbv beta.
  eapply eqRat_refl.
  cbv beta.
  unfold snd.
  intuition.
  eapply eqRat_trans.
  eapply evalDist_assoc_eq.
  eapply eqRat_trans.
  eapply evalDist_seq_eq; intuition.
  eapply eqRat_refl.
  eapply eqRat_trans.
  eapply evalDist_left_ident_eq.
  cbv beta.
  eapply eqRat_refl.
  rewrite H.
  symmetry.
  eapply eqRat_trans.
  eapply evalDist_assoc_eq.
  eapply eqRat_trans.
  eapply evalDist_seq_eq; intuition.
  eapply eqRat_refl.
  eapply eqRat_trans.
  eapply evalDist_left_ident_eq.
  eapply eqRat_refl.
  cbv beta.

  simpl.
  intuition.
  intuition.
Qed.

Theorem repeat_unroll_eq: forall (A : Set)(eqd : EqDec A)(c : Comp A)(P : A -> bool) v,
  well_formed_comp c ->
  (exists a, In a (filter P (getSupport c))) ->
  evalDist (Repeat c P) v == evalDist (x <-$ c; if (P x) then ret x else (Repeat c P)) v.
  
  intuition.
  
  eapply det_eq_impl_dist_sem_eq; trivial.
  destruct H0.
  
  eapply well_formed_Repeat; trivial.
  unfold eq_dec.
  intuition.
  eapply (EqDec_dec _).
  eauto.
  econstructor; intuition.
  destruct (P b).
  econstructor.
  destruct H0.
  econstructor.
  unfold eq_dec.
  intuition.
  eapply (EqDec_dec _).
  trivial.
  eauto.
  
  unfold DetSem.evalDet_equiv.
  intuition.
  inversion H1; clear H1; subst.
  
  inversion H2; clear H2; subst.
  simpl in *.
  eapply evalDet_steps_bind_done_inv in H6.
  destruct H6.
  destruct H1.
  intuition.
  econstructor.
  eapply evalDet_steps_trans.
  eapply evalDet_steps_bind_done.
  eauto.
  destruct (P x).
  inversion H3; clear H3; subst.
  simpl in *.
  inversion H7; clear H7; subst.
  econstructor.
  eauto.
  simpl.
  2:eassumption.
  constructor.
  
  inversion H2; clear H2; subst.
  simpl in *.
  apply evalDet_steps_bind_eof_inv in H6.
  intuition.
  econstructor.
  eapply evalDet_bind_eof.
  trivial.
  destruct H1.
  destruct H1.
  intuition.
  econstructor.
  eapply evalDet_steps_trans.
  eapply evalDet_steps_bind_done.
  eauto.
  destruct (P x).
  inversion H3; clear H3; subst.
  simpl in *.
  inversion H7.
  trivial.
  
  inversion H1; clear H1; subst.
  eapply evalDet_steps_bind_done_inv in H2.
  destruct H2.
  destruct H1.
  intuition.
  econstructor.
  econstructor.
  eauto.
  simpl.
  eapply evalDet_steps_trans.
  eapply evalDet_steps_bind_done.
  eauto.
  destruct (P x).
  inversion H3; clear H3; subst.
  simpl in *.
  inversion H7; clear H7; subst.
  econstructor.
  eauto.
  simpl.
  2:eassumption.
  constructor.
  
  apply evalDet_steps_bind_eof_inv in H2.
  intuition.
  econstructor.
  econstructor.
  eauto.
  simpl.
  eapply evalDet_bind_eof.
  trivial.
  destruct H1.
  destruct H1.
  intuition.
  econstructor.
  econstructor.
  eauto.
  simpl.
  eapply evalDet_steps_trans.
  eapply evalDet_steps_bind_done.
  eauto.
  destruct (P x).
  inversion H3; clear H3; subst.
  simpl in *.
  inversion H7.
  trivial.
Qed.

Lemma evalDist_seq_case_split_eq : forall (B : Set)(e : B -> bool) v v1 v2 (A : Set)(c : Comp B)(f : B -> Comp A) a,
  well_formed_comp c ->
  Pr[b <-$ c; ret (e b)] == v ->
  (forall b, (e b) = true -> (evalDist (f b) a) == v1) ->
  (forall b, (e b) = false -> (evalDist (f b) a) == v2) ->
  (evalDist (Bind c f) a == v * v1 + (ratSubtract 1 v) * v2).
  
  intuition.
  simpl in *.
  rewrite (sumList_partition e).
  eapply ratAdd_eqRat_compat.
  
  rewrite (sumList_body_eq _ _ (fun b => ((evalDist c b) * (if (e b) then 1 else 0)) * v1)).
  rewrite sumList_factor_constant_r.
  eapply ratMult_eqRat_compat; intuition.
  rewrite <- H0.
  eapply sumList_body_eq; intuition.
  destruct (EqDec_dec bool_EqDec (e a0) true).
  rewrite e0.
  intuition.
  destruct (e a0); try congruence.
  intuition.
  
  intuition.
  case_eq (e a0); intuition.
  repeat rewrite ratMult_1_r.
  eapply ratMult_eqRat_compat; intuition.
  repeat rewrite ratMult_0_r.
  rewrite ratMult_0_l.
  intuition.
  
  rewrite (sumList_body_eq _ _ (fun b => ((evalDist c b) * (if (e b) then 0 else 1)) * v2)).
  rewrite sumList_factor_constant_r.
  eapply ratMult_eqRat_compat; intuition.
  rewrite <- H0.
  
  rewrite <- (@evalDist_lossless _ c).
  rewrite (sumList_partition e _ (evalDist c)).
  rewrite ratAdd_comm.
  rewrite ratSubtract_ratAdd_assoc.
  rewrite ratSubtract_0.
  rewrite <- ratAdd_0_r.
  intuition.
  eapply eqRat_impl_leRat.
  eapply sumList_body_eq; intuition.
  destruct (EqDec_dec bool_EqDec (e a0) true).
  rewrite e0.
  intuition.
  destruct (e a0); try congruence.
  intuition.
  eapply eqRat_impl_leRat.
  eapply sumList_body_eq; intuition.
  destruct (EqDec_dec bool_EqDec (e a0) true).
  rewrite e0.
  intuition.
  destruct (e a0); try congruence.
  intuition.
  trivial.
  
  intuition.
  case_eq (e a0); intuition.
  repeat rewrite ratMult_0_r.
  rewrite ratMult_0_l.
  intuition.
  repeat rewrite ratMult_1_r.
  eapply ratMult_eqRat_compat; intuition.
Qed.

Theorem evalDist_bind_distance : forall (A B : Set)(c1 c2 : Comp B)(c3 c4 : B -> Comp A) d,
  well_formed_comp c2 ->
  (forall b, evalDist c1 b == evalDist c2 b) ->
  (forall b a, In b (getSupport c1) -> | evalDist (c3 b) a - evalDist (c4 b) a | <= d) ->
  (forall a, | evalDist (Bind c1 c3) a - evalDist (Bind c2 c4) a | <= d).
  
  intuition.
  simpl.
  eapply leRat_trans.
  eapply eqRat_impl_leRat.
  rewrite sumList_body_eq.
  2:{
    intros.
    eapply ratMult_eqRat_compat.
    eapply H0.
    eapply eqRat_refl.
  }
  eapply eqRat_refl.
  
  assert (Permutation (getSupport c1) (getSupport c2)).
  eapply NoDup_Permutation; intuition; eauto using getSupport_NoDup.
  eapply getSupport_In_evalDist.
  rewrite <- H0.
  eapply getSupport_In_evalDist.
  trivial.
  eapply getSupport_In_evalDist.
  rewrite H0.
  eapply getSupport_In_evalDist.
  trivial.
  erewrite sumList_permutation; eauto.
  
  rewrite sumList_distance_prod.
  eapply leRat_trans.
  eapply sumList_le; intuition.
  eapply ratMult_leRat_compat.
  eapply leRat_refl.
  eapply H1.
  eapply getSupport_In_evalDist.
  rewrite H0.
  eapply getSupport_In_evalDist.
  trivial.

  rewrite sumList_factor_constant_r.
  rewrite evalDist_lossless.
  rewrite ratMult_1_l.
  intuition.
  trivial.
  
Qed.

Lemma evalDist_Bind_1_le_l : forall (A B : Set) (b : Comp B) (a : B -> Comp A) (y : A) (v : Rat),
  well_formed_comp b ->
  (forall x : B, In x (getSupport b) -> evalDist (a x) y <= v) ->
  evalDist (x <-$ b; a x) y <= v.
  
  intuition.
  simpl.
  eapply leRat_trans.
  eapply sumList_le; intuition.
  eapply ratMult_leRat_compat.
  eapply leRat_refl.
  eapply H0.
  trivial.
  rewrite sumList_factor_constant_r.
  rewrite evalDist_lossless.
  rewrite ratMult_1_l.
  intuition.
  trivial.
Qed.

Lemma evalDist_ret_1 : 
  forall (A : Set)(eqd : eq_dec A)(a1 a2 : A),
    a1 = a2 ->
    evalDist (Ret eqd a1) a2 = 1.
  
  intuition.
  subst.
  simpl.
  destruct (eqd a2 a2); subst; intuition.
  
Qed.

Lemma evalDist_ret_0 : 
  forall (A : Set)(eqd : eq_dec A)(a1 a2 : A),
    a1 <> a2 ->
    evalDist (Ret eqd a1) a2 = 0.
  
  intuition.
  simpl.
  destruct (eqd a1 a2); subst; intuition.
  
Qed.

Lemma evalDist_ret_eq : 
  forall (A : Set)(eqd1 eqd2 : eq_dec A) a1 a2 x,
    a1 = a2 ->
    evalDist (Ret eqd1 a1) x == evalDist (Ret eqd2 a2) x.
  
  intuition.
  simpl.
  subst.
  destruct (eqd1 a2 x); destruct (eqd2 a2 x); subst; intuition.
Qed.

Theorem evalDist_seq_step : 
  forall (A B :Set)(c : Comp A)(f : A -> Comp B) b,
    evalDist (Bind c f) b ==
    sumList (getSupport c) (fun a => evalDist c a * evalDist (f a) b).
  
  intuition.
  simpl.
  eapply sumList_body_eq; intuition.

Qed.

Theorem evalDist_1 : 
  forall (A : Set)(eqd : EqDec A)(c : Comp A) a,
    well_formed_comp c ->
    evalDist c a == 1 ->
    (getSupport c) = (a :: nil)%list.

  intuition.
  
  specialize (evalDist_getSupport_perm_id c (ret a)); intuition.
  assert (forall a0 : A, evalDist c a0 == evalDist (ret a) a0).
  intuition.
  case_eq (eqb a a0); intuition.
  rewrite eqb_leibniz in H2.
  subst.
  simpl.
  destruct (EqDec_dec eqd a0 a0); intuition.
  
  simpl.
  assert (evalDist c a0 == 0).
  eapply evalDist_1_0; intuition.
  eapply H0.
  subst.
  rewrite eqb_refl in H2.
  discriminate.
  rewrite H3.
  destruct ( EqDec_dec eqd a a0); subst; intuition.
  rewrite eqb_refl in H2.
  discriminate.
  
  intuition.
  simpl in *.
  
  eapply Permutation_length_1_inv.
  eapply Permutation_sym.
  trivial.
  
Qed.

Theorem evalDist_bool_equiv_all : 
  forall (c1 c2 : Comp bool),
    well_formed_comp c1 ->
    well_formed_comp c2 ->
    Pr[c1] == Pr[c2] -> 
    (forall b, evalDist c1 b == evalDist c2 b).
  
  intuition.
  destruct b.
  trivial.
  
  rewrite evalDist_complement.
  rewrite evalDist_complement.
  eapply ratSubtract_eqRat_compat; intuition.
  trivial.
  trivial.
Qed.

Require Import Coq.Classes.RelationClasses.
Require Import Coq.Classes.Morphisms.

Class RatRel (R : Rat -> Rat -> Prop) :=
{
  refl : forall r1 r2, r1 == r2 -> R r1 r2;
  trans : Transitive R;
  add_proper : Proper (R ==> R ==> R) ratAdd;
  mult_proper : Proper (R ==> R ==> R) ratMult
}.

Instance RatRel_trans : 
  forall (R : Rat -> Rat -> Prop),
    RatRel R -> Transitive R.

intuition.
destruct H.
intuition.

Qed.

Instance RatRel_flip : 
  forall R,
    RatRel R ->
    RatRel (Basics.flip R).

intuition.
econstructor; intuition.
unfold Basics.flip.
eapply refl.
eapply eqRat_symm.
intuition.

unfold Proper, respectful, Basics.flip in *; intuition.
eapply add_proper; trivial.
unfold Proper, respectful, Basics.flip in *; intuition.
eapply mult_proper; trivial.
Qed.

Instance eqRat_RatRel : RatRel eqRat.

econstructor;
eauto with typeclass_instances.

Qed.

Instance leRat_RatRel : RatRel leRat.

econstructor;
eauto with typeclass_instances.
eapply eqRat_impl_leRat.

Qed.

Instance eqRat_RatRel_1 : 
  RatRel (fun r r1 : Rat => r1 == r).

eapply RatRel_flip.
intuition.

Qed.

Theorem evalDist_left_ident : 
  forall rel (B : Set)(eqd : EqDec B)(b : B)(A : Set)(c2 : B -> Comp A) a,
    RatRel rel ->
    rel (evalDist (x <-$ ret b; (c2 x)) a) (evalDist (c2 b) a).

  intuition.
  eapply refl.
  eapply evalDist_left_ident_eq.
Qed.

Theorem evalDist_assoc : 
  forall rel (A : Set)(c1 : Comp A)(B C : Set)(c2 : A -> Comp B)(c3 : B -> Comp C) x,
    RatRel rel ->
    rel (evalDist (Bind (Bind c1 c2) c3) x) (evalDist (Bind c1 (fun a => (Bind (c2 a) c3))) x).

  intuition.
  eapply refl.
  eapply evalDist_assoc_eq.

Qed.

Theorem evalDist_commute: 
  forall rel  (A B : Set)(c1 : Comp A)(c2 : Comp B)(C : Set)(c3 : A -> B -> Comp C) x,
    RatRel rel ->
    rel (evalDist (a <-$ c1; b <-$ c2; (c3 a b)) x) (evalDist (b <-$ c2; a <-$ c1; (c3 a b)) x). 

  intuition.
  eapply refl.
  eapply evalDist_commute_eq.

Qed.

Lemma rel_sumList_compat : 
  forall (A : Set)(f1 f2 : A -> Rat) ls rel,
    RatRel rel ->
    (forall a, In a ls -> rel (f1 a) (f2 a)) ->
    rel (sumList ls f1) (sumList ls f2).
  
  induction ls; intuition; simpl in *.
  unfold sumList; simpl.
  eapply refl.
  intuition.
  
  eapply trans.
  eapply refl.
  eapply sumList_cons.
  eapply trans.
  2:{
    eapply refl.
    symmetry.
    eapply sumList_cons.
  }
  eapply add_proper.
  intuition.
  eapply IHls; intuition.
Qed.

Lemma rel_seq : 
  forall (A B C : Set)(c : Comp A)(f1 : A -> Comp B)(f2 : A -> Comp C) rel x1 x2,
    RatRel rel ->
    (forall a, In a (getSupport c) -> rel (evalDist (f1 a) x1) (evalDist (f2 a) x2)) ->
    rel (evalDist (a <-$ c; f1 a) x1) (evalDist (a <-$ c; f2 a) x2).
  
  intuition.
  simpl.
  eapply rel_sumList_compat; intuition.
  eapply mult_proper.
  eapply refl.
  intuition.
  intuition.
Qed.

Lemma evalDist_bind_case_split : 
  forall rel (B : Set)(e : B -> bool) v v1 v2 (A : Set)(c : Comp B)(f : B -> Comp A)  a,
    RatRel rel ->
    well_formed_comp c ->
    Pr[b <-$ c; ret (e b)] == v ->
    (forall b, (e b) = true -> rel (evalDist (f b) a) v1) ->
    (forall b, (e b) = false -> rel (evalDist (f b) a) v2) ->
    (rel (evalDist (Bind c f) a) (v * v1 + (ratSubtract 1 v) * v2)).

  intuition.
  simpl in *.
  eapply trans.
  eapply refl.
  rewrite (sumList_filter_partition e).
  eapply eqRat_refl.
  eapply add_proper.

  eapply trans.
  eapply (rel_sumList_compat); intuition.
  eapply mult_proper.
  eapply refl.
  eapply eqRat_refl.
  eapply H2.
  eapply filter_In.
  eauto.
  eapply refl.
  rewrite sumList_factor_constant_r.
  eapply ratMult_eqRat_compat; intuition.
  
  rewrite (sumList_filter_partition e) in H1.
  rewrite <- H1.
  rewrite ratAdd_0_r.
  eapply ratAdd_eqRat_compat.
  eapply sumList_body_eq; intuition.
  rewrite <- ratMult_1_r at 1.
  eapply ratMult_eqRat_compat.
  intuition.
  destruct ( EqDec_dec bool_EqDec (e a0) true); intuition.
  exfalso.
  eapply n.
  eapply filter_In.
  eauto.

  symmetry.
  eapply sumList_0; intuition.
  destruct (EqDec_dec bool_EqDec (e a0) true).
  apply filter_In in H4.
  intuition.
  rewrite e0 in H6.
  simpl in *.
  congruence.
  eapply ratMult_0_r.

  eapply trans.
  eapply (rel_sumList_compat); intuition.
  eapply mult_proper.
  eapply refl.
  eapply eqRat_refl.
  eapply H3.
  eapply filter_In in H4.
  intuition.
  destruct (e a0); intuition.
  eapply refl.
  rewrite sumList_factor_constant_r.
  eapply ratMult_eqRat_compat; intuition.
  
  rewrite <- H1.
  rewrite <- (@evalDist_lossless _ c); trivial.
  symmetry.
  rewrite (sumList_partition e _ (evalDist c)).
  rewrite ratAdd_comm.
  rewrite ratSubtract_ratAdd_assoc.
  rewrite ratSubtract_0.
  rewrite <- ratAdd_0_r.
  
  rewrite (sumList_filter_partition e).
  symmetry.
  rewrite ratAdd_0_l.
  eapply ratAdd_eqRat_compat.
  symmetry.
  eapply sumList_0; intuition.
  apply filter_In in H4.
  intuition.
  rewrite H6.
  eapply ratMult_0_r.
  eapply sumList_body_eq; intuition.
  apply filter_In in H4.
  intuition.
  destruct (e a0); simpl in *; try discriminate.
  symmetry.
  eapply ratMult_1_r.
  eapply sumList_le; intuition.
  destruct (EqDec_dec bool_EqDec (e a0) true).
  rewrite e0.
  intuition.
  destruct (e a0); intuition.

  eapply sumList_le; intuition.
  destruct ( EqDec_dec bool_EqDec (e a0) true).
  destruct (e a0); try discriminate.
  intuition.
  destruct (e a0); intuition.
Qed.

Lemma rel_sumList_factor_r : 
  forall (A : Set) (f : A -> Rat) (ls : list A) c rel,
    RatRel rel ->
    rel (sumList ls (fun a => (f a) * c)) ((sumList ls f) * c).

  induction ls; intuition; simpl in *.
  unfold sumList; simpl.
  eapply refl.
  symmetry.
  eapply ratMult_0_l.

  eapply trans.
  eapply refl.
  eapply sumList_cons.
  eapply trans.
  2:{
    eapply refl.
    symmetry.
    eapply eqRat_trans.
    eapply ratMult_eqRat_compat.
    eapply sumList_cons.
    eapply eqRat_refl.
    eapply ratMult_distrib_r.
  }
  eapply add_proper.
  eapply refl.
  intuition.
  eapply IHls; intuition.
Qed. 

Theorem evalDist_irr_l : 
  forall (A B : Set)(c : Comp A)(f : A -> Comp B)(y : B) rel v,
    RatRel rel ->
    well_formed_comp c ->
    (forall x, In x (getSupport c) -> rel (evalDist (f x) y) v) -> 
    rel (evalDist (Bind c f) y) v.

  intuition.
  simpl.
  eapply trans.
  eapply rel_sumList_compat;
  intuition.
  eapply mult_proper.
  eapply refl.
  eapply eqRat_refl.
  eapply H1.
  trivial.
 
  specialize (rel_sumList_factor_r (evalDist c) (getSupport c) v H); intuition.

  eapply trans.
  eapply H2.
  eapply refl.
  rewrite evalDist_lossless.
  eapply ratMult_1_l.
  trivial.
Qed.

Lemma rel_sumList_factor_r_r : 
  forall (A : Set) (f : A -> Rat) (ls : list A) c rel,
    RatRel rel ->
    rel ((sumList ls f) * c) (sumList ls (fun a => (f a) * c)).

  induction ls; intuition; simpl in *.
  unfold sumList; simpl.
  eapply refl.
  eapply ratMult_0_l.

  eapply trans.
  eapply refl.
  eapply eqRat_trans.
  eapply ratMult_eqRat_compat.
  eapply sumList_cons.
  eapply eqRat_refl.
  eapply ratMult_distrib_r.

  eapply trans.
  2:{
    eapply refl.
    symmetry.
    eapply sumList_cons.
  }
  simpl.
  eapply add_proper.
  eapply refl.
  intuition.
  eapply IHls; intuition.
Qed. 

Theorem evalDist_irr_r : 
  forall (A B : Set)(c : Comp A)(f : A -> Comp B)(y : B) rel v,
    RatRel rel ->
    well_formed_comp c ->
    (forall x, In x (getSupport c) -> rel v (evalDist (f x) y)) -> 
    rel v (evalDist (Bind c f) y).

  intuition.
  simpl.
  eapply trans.
  2:{
    eapply rel_sumList_compat;
    intuition.
    eapply mult_proper.
    eapply refl.
    eapply eqRat_refl.
    eapply H1.
    trivial.
  }
  
  specialize (rel_sumList_factor_r_r (evalDist c) (getSupport c) v H); intuition.

  eapply trans.
  2:{
    eapply H2.
  }
  eapply refl.
  rewrite evalDist_lossless.
  symmetry.
  eapply ratMult_1_l.
  trivial.
Qed.

Theorem evalDist_iso : 
  forall rel (A B C D : Set) (f : C -> D) (f_inv : D -> C) 
    (d : Comp D) (c : Comp C) (f1 : D -> Comp B) 
    (f2 : C -> Comp A) (a : A) (b : B),
    RatRel rel ->
    (forall x : D, In x (getSupport d) -> f (f_inv x) = x) ->
    (forall x : C, In x (getSupport c) -> f_inv (f x) = x) ->
    (forall x : D, In x (getSupport d) -> In (f_inv x) (getSupport c)) ->
    (forall x : C, In x (getSupport c) -> evalDist d (f x) == evalDist c x) ->
    (forall x : C,
      In x (getSupport c) -> rel (evalDist (f1 (f x)) b) (evalDist (f2 x) a)) ->
    rel (evalDist (x <-$ d; f1 x) b) (evalDist (x <-$ c; f2 x) a).

  intuition.
  eapply trans.
  eapply refl.
  eapply (distro_iso_eq); intros.
  eapply H0.
  trivial.
  eapply H1.
  eauto.
  eapply H2.
  eauto.

  eapply H3.
  trivial.
  eapply eqRat_refl.

  eapply rel_seq;
  intuition.

Qed.

Theorem evalDist_seq : 
forall rel (A1 A2 B : Set) (c1 c2 : Comp B) (f1 : B -> Comp A1)(f2 : B -> Comp A2) y z,
  RatRel rel ->
  (forall x : B, evalDist c1 x == evalDist c2 x) ->
  (forall x : B,
    In x (getSupport c1) -> rel (evalDist (f1 x) y) (evalDist (f2 x) z)) ->
  rel (evalDist (x <-$ c1; f1 x) y) (evalDist (x <-$ c2; f2 x) z).

  intuition.
  eapply (evalDist_iso (fun b => b)(fun b => b)); intuition.

  eapply getSupport_In_evalDist.
  intuition.
  eapply getSupport_In_evalDist.
  eauto.
  rewrite H0.
  trivial.
  eapply H1.
  eapply getSupport_In_evalDist.
  intuition.
  eapply getSupport_In_evalDist.
  eauto.
  rewrite <- H0.
  trivial.

Qed.

Theorem oc_comp_invariant : 
  forall (A B C : Set)(c : OracleComp A B C)(S : Set)(P : S -> Prop)
    (eqds : EqDec S)
    (o : S -> A -> Comp (B * S))(s : S),
    (forall a b c d, In (a, b) (getSupport (o c d)) -> P c -> P b) ->
      P s ->
      forall a b, In (a, b) (getSupport (c _ _ o s)) -> P b.
  
  Opaque getSupport.
  induction c; intuition; simpl in *.
  eapply H; eauto.

  Transparent getSupport.
  repeat simp_in_support.
  destruct x. 
  simpl in *.

  specialize (IHc (S * S0) (fun x => P (snd x)) _ 
  (fun (x : S * S0) (y : A) =>
                p <-$ (o (fst x) y) S0 eqds o0 (snd x);
                ret (fst (fst p), (snd (fst p), snd p))) (s, s0))%type.
  eapply IHc; intros.
  3:{
    eapply H3.
  }
  repeat simp_in_support.
  simpl.
  destruct c1.
  destruct x.
  eapply H.
  eapply H0.
  eapply H4. 
  eapply H5.
  trivial.

  repeat simp_in_support.
  trivial.

  repeat simp_in_support.
  destruct x.
  eapply H.
  eapply H0.
  eapply IHc.
  eapply H0.
  eapply H1.
  eauto.
  eauto.
Qed.

Theorem oc_comp_invariant_f : 
  forall (A B C : Set)(c : OracleComp A B C)(S : Set)(f : S -> bool)
    (eqds : EqDec S)
    (o : S -> A -> Comp (B * S))(s : S),
    (forall a b c d, In (a, b) (getSupport (o c d)) -> f c = true -> f b = true) ->
    f s = true ->
    forall a b, In (a, b) (getSupport (c _ _ o s)) -> f b = true.
  
  intuition.
  eapply (@oc_comp_invariant _ _ _ _ _ (fun x => f x = true)); intuition.
  eapply H.
  eapply H2.
  eapply H3.
  eapply H0.
  eapply H1.
Qed.

Theorem distro_irr_le
     : forall (A B : Set) (c : Comp A) (f : A -> Comp B) 
         (y : B) (v : Rat),
       (forall x : A, In x (getSupport c) -> (evalDist (f x) y) <=  v) ->
       (evalDist (x <-$ c; f x) y)  <= v.

  intuition.
  simpl.
  rewrite sumList_le.
  2:{
    intuition.
    rewrite H at 1.
    eapply leRat_refl.
    trivial.
  }
  rewrite sumList_factor_constant_r.
  eapply leRat_trans.
  eapply ratMult_leRat_compat.
  eapply evalDist_sum_le_1.
  eapply leRat_refl.
  rewrite ratMult_1_l.
  intuition.
Qed.

Theorem oc_comp_wf : 
  forall (A B C : Set)(c : OracleComp A B C),
    well_formed_oc c ->
    forall (S : Set)(eqds : EqDec S)(o : S -> A -> Comp (B * S))(s : S),
      (forall a b, well_formed_comp (o a b)) ->
      well_formed_comp (c _ _ o s).

  induction 1; intuition; simpl in *; intuition. 
  eapply well_formed_Bind; intuition.

  eapply IHwell_formed_oc; intuition.
  eapply well_formed_Bind; intuition.
  eapply well_formed_Ret.
  eapply well_formed_Ret.

  eapply well_formed_Bind; intuition.
  eapply well_formed_Ret.

  eapply well_formed_Bind; intuition.
  destruct b.
  eauto.
  
Qed.

Theorem repeat_fission : 
  forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(c : Comp A)(P : A -> bool)(f : A -> Comp B) x,
    well_formed_comp c ->
    (exists a, In a (filter P (getSupport c))) ->
    (forall a, In a (getSupport c) -> well_formed_comp (f a)) ->
    evalDist (a <-$ Repeat c P; b <-$ f a; ret (a, b)) x ==
    evalDist
      (Repeat (a <-$ c; b <-$ f a; ret (a, b)) (fun p => P (fst p))) x.

  intuition.

  case_eq (P a); intuition.

  simpl.
  symmetry.
  rewrite <- sumList_factor_constant_l.

  symmetry.
  rewrite (@sumList_subset' A (EqDec_dec _ ) _ (getSupport c)).
  
  eapply sumList_body_eq; intuition.
  unfold indicator.
  simpl.
  rewrite H2.
  case_eq (P a0); intuition.
  repeat rewrite ratMult_1_l.
  rewrite <- ratMult_assoc.
  eapply ratMult_eqRat_compat; intuition.
  eapply ratMult_eqRat_compat; intuition.
  eapply ratInverse_eqRat_compat.
  eapply sumList_nz.
  econstructor; intuition.
  eapply filter_In; intuition; eauto.
  eapply getSupport_In_evalDist;
  eauto.

  symmetry.

  assert ((getUnique
           (flatten
              (map
                 (fun b0 : A =>
                  getUnique
                    (flatten
                       (map (fun b1 : B => (b0, b1) :: nil)
                          (getSupport (f b0))))
                    (bind_eq_dec (f b0) (fun b1 : B => ret (b0, b1))))
                 (getSupport c)))
           (bind_eq_dec c (fun a1 : A => b0 <-$ f a1; ret (a1, b0)))) =
           (flatten
              (map
                 (fun b0 : A =>
                    (map (fun b1 : B => (b0, b1))
                         (getSupport (f b0))))
                 (getSupport c)))).

  rewrite DetSem.getUnique_NoDup_eq.
  f_equal.
  eapply map_ext; intuition.

  rewrite flatten_map_eq.
  rewrite DetSem.getUnique_NoDup_eq.
  intuition.

  eapply map_NoDup; intuition.
  assert (snd (a1, a2) = a2).
  trivial.
  eauto.
  eapply getSupport_NoDup.

  eapply flatten_NoDup;
    intuition.
  
  eapply map_NoDup'; intuition.
  eapply getSupport_NoDup.

  repeat rewrite flatten_map_eq in *.

  edestruct (@well_formed_val_exists _ (f a1)).
  intuition.

  eapply (getUnique_eq_inv (a1, x)) in H8.
  apply in_map_iff in H8.
  destruct H8.
  intuition.
  pairInv.
  intuition.
  eapply in_map_iff.
  econstructor.
  intuition.

  apply in_map_iff in H5.
  destruct H5.
  intuition.
  subst.
  eapply getUnique_NoDup.

  eapply in_map_iff in H5.
  destruct H5.
  intuition.
  eapply in_map_iff in H6.
  destruct H6.
  intuition.
  subst.
  repeat rewrite flatten_map_eq in *.
  eapply app_NoDup; intuition.
  eapply getUnique_NoDup.
  eapply getUnique_NoDup.

  apply in_getUnique_if in H5.
  apply in_getUnique_if in H6.
  apply in_map_iff in H5.
  apply in_map_iff in H6.
  destruct H5.
  destruct H6.
  intuition.
  subst.
  pairInv.
  intuition.

  apply in_getUnique_if in H5.
  apply in_getUnique_if in H6.
  apply in_map_iff in H5.
  apply in_map_iff in H6.
  destruct H5.
  destruct H6.
  intuition.
  subst.
  pairInv.
  intuition.

  rewrite H5.
  clear H5.

  rewrite sumList_filter_twice.
  eapply sumList_body_eq; intuition.
  apply filter_In in H5; intuition.
  eapply eqRat_trans.
  eapply sumList_body_eq; intuition.
  rewrite (@sumList_exactly_one _ a1) at 1.
  eapply eqRat_refl.
  eapply getSupport_NoDup.
  intuition.
  intuition.
  eapply eqRat_trans.
  eapply ratMult_eqRat_compat.
  eapply eqRat_refl.
  eapply sumList_0; intuition.
  destruct (EqDec_dec (pair_EqDec eqda eqdb) (b0, a3) (a1, a2)).
  pairInv.
  intuition.
  eapply ratMult_0_r.
  eapply ratMult_0_r.
  eapply eqRat_trans.
  eapply sumList_body_eq; intuition.
  eapply ratMult_eqRat_compat.
  eapply eqRat_refl.
  eapply (@sumList_exactly_one _ a2); intuition.
  eapply getSupport_NoDup.
  destruct (EqDec_dec (pair_EqDec eqda eqdb) (a1, b0) (a1, a2)).
  pairInv.
  intuition.
  eapply ratMult_0_r.
  
  rewrite sumList_factor_constant_l.
  symmetry.
  rewrite <- ratMult_1_r at 1.
  eapply ratMult_eqRat_compat; intuition.
  symmetry.
  eapply eqRat_trans.
  eapply sumList_body_eq; intuition.
  destruct (EqDec_dec (pair_EqDec eqda eqdb) (a1, a2) (a1, a2)).
  eapply ratMult_1_r.
  congruence.
  eapply evalDist_lossless.
  intuition.

  repeat rewrite ratMult_0_l.
  symmetry.
  rewrite ratMult_1_l.
  eapply eqRat_trans.
  eapply ratMult_eqRat_compat.
  eapply eqRat_refl.
  eapply ratMult_eqRat_compat.
  eapply eqRat_refl.
  eapply sumList_0; intuition.
  destruct (EqDec_dec (pair_EqDec eqda eqdb) (a0, a1) (a, b)).
  pairInv.
  congruence.
  eapply ratMult_0_r.
  repeat rewrite ratMult_0_r.
  intuition.
  eapply filter_NoDup.
  eapply getSupport_NoDup.
  eapply getSupport_NoDup.

  intuition.
  apply filter_In in H3; intuition.
  
  intuition.
  unfold indicator.
  case_eq (P a0); intuition.
  exfalso.
  eapply H4.
  eapply filter_In; intuition.
  repeat rewrite ratMult_0_l.
  intuition.

  destruct H0.
  eapply evalDist_irr_l; intuition.
  eapply well_formed_Repeat.
  unfold eq_dec; intuition.
  eapply (EqDec_dec _).
  trivial.
  eauto.

  eapply evalDist_irr_l; intuition.
  simpl in *.
  apply filter_In in H3.
  intuition.

  simpl in *.
  apply filter_In in H3.
  intuition.
  destruct (EqDec_dec (pair_EqDec eqda eqdb) (x0, x1) (a, b)).
  pairInv.
  congruence.

  unfold indicator.
  simpl.
  rewrite H2.
  repeat rewrite ratMult_0_l.
  intuition.
Qed.

Lemma evalDistRepeat_sup_0 : 
  forall (A : Set)(c : Comp A)(P : A -> bool) x,
    evalDist c x == 0 ->
    evalDist (Repeat c P) x == 0.
  
  intuition.
  simpl.
  rewrite H.
  rewrite ratMult_0_r.
  intuition.
  
Qed.

Lemma evalDistRepeat_pred_0 : 
  forall (A : Set)(c : Comp A)(P : A -> bool) x,
    P x = false ->
    evalDist (Repeat c P) x == 0.
  
  intuition.
  simpl.
  unfold indicator.
  rewrite H.
  repeat rewrite ratMult_0_l.
  intuition.
  
Qed.

Theorem repeat_snd_equiv : 
  forall (A B : Set)(eqd : EqDec B)(c : Comp (A * B))(P : B -> bool) x,
    evalDist (p <-$ Repeat c (fun p => P (snd p)); ret (snd p)) x ==
    evalDist (Repeat (p <-$ c; ret (snd p)) P) x.
  
  intuition.
  
  simpl.
  case_eq (P x); intuition.
  
  unfold indicator.
  rewrite H.
  rewrite ratMult_1_l.
  rewrite <- sumList_factor_constant_l.
  
  symmetry.
  rewrite (sumList_filter_partition (fun p : A * B => P (snd p))).
  symmetry.
  rewrite ratAdd_0_r.
  eapply ratAdd_eqRat_compat.
  eapply sumList_body_eq; intuition.
  apply filter_In in H0; intuition.
  rewrite H2.
  destruct (EqDec_dec eqd (snd a) x).
  rewrite ratMult_1_l.
  repeat rewrite ratMult_1_r.
  eapply ratMult_eqRat_compat; intuition.
  
  rewrite flatten_map_eq.
  eapply ratInverse_eqRat_compat.
  intuition.
  destruct a.
  simpl in *.
  subst.
  eapply sumList_nz; eauto.
  exists (a, x).
  intuition.
  eapply filter_In; intuition.
  eapply getSupport_In_evalDist; eauto.
  
  rewrite sumList_comm.
  symmetry.
  rewrite (sumList_filter_partition (fun p : A * B => P (snd p))).
  symmetry.
  rewrite ratAdd_0_r.
  eapply ratAdd_eqRat_compat.
  eapply sumList_body_eq; intuition.
  apply filter_In in H0; intuition.
  rewrite sumList_factor_constant_l.
  rewrite <- ratMult_1_r at 1.
  eapply ratMult_eqRat_compat; intuition.
  symmetry.
  destruct a0.
  simpl in *.
  rewrite (@sumList_exactly_one _ b).
  destruct (EqDec_dec eqd b b); intuition.
  eapply filter_NoDup.
  eapply getUnique_NoDup.
  eapply filter_In; intuition.
  eapply in_getUnique.
  eapply in_map_iff.
  econstructor. split; eauto.
  simpl.
  trivial.

  intuition.
  destruct (EqDec_dec eqd b b0); subst; intuition.

  symmetry.
  eapply sumList_0.
  intuition.
  eapply sumList_0; intuition.
  apply filter_In in H3; intuition.
  apply filter_In in H0; intuition.
  destruct a0.
  simpl in *.
  destruct (EqDec_dec eqd b a1); subst.
  destruct (P a1); simpl in *; discriminate.
  eapply ratMult_0_r.
  
  repeat rewrite ratMult_0_r.
  intuition.
  
  symmetry.
  eapply sumList_0; intuition.
  eapply filter_In in H0; intuition.
  destruct (EqDec_dec eqd (snd a) x); subst.
  destruct (P (snd a)); simpl in *; discriminate.
  
  repeat rewrite ratMult_0_r.
  intuition.
  
  unfold indicator.
  rewrite H.
  repeat rewrite ratMult_0_l.
  eapply sumList_0; intuition.
  apply filter_In in H0.
  intuition.
  rewrite H2.
  rewrite ratMult_1_l.
  destruct a.
  simpl in *.
  destruct (EqDec_dec eqd b x); subst; try congruence.
  rewrite ratMult_0_r.
  intuition.
  
Qed.

Theorem repeat_fst_equiv : 
  forall (A B : Set)(eqd : EqDec A)(c : Comp (A * B))(P : A -> bool) x,
    evalDist (p <-$ Repeat c (fun p => P (fst p)); ret (fst p)) x ==
    evalDist (Repeat (p <-$ c; ret (fst p)) P) x.
  
  intuition.
  
  simpl.
  case_eq (P x); intuition.
  
  unfold indicator.
  rewrite H.
  rewrite ratMult_1_l.
  rewrite <- sumList_factor_constant_l.
  
  symmetry.
  rewrite (sumList_filter_partition (fun p : A * B => P (fst p))).
  symmetry.
  rewrite ratAdd_0_r.
  eapply ratAdd_eqRat_compat.
  eapply sumList_body_eq; intuition.
  apply filter_In in H0; intuition.
  rewrite H2.
  destruct (EqDec_dec eqd (fst a) x).
  rewrite ratMult_1_l.
  repeat rewrite ratMult_1_r.
  eapply ratMult_eqRat_compat; intuition.
  
  rewrite flatten_map_eq.
  eapply ratInverse_eqRat_compat.
  intuition.
  destruct a.
  simpl in *.
  subst.
  eapply sumList_nz; eauto.
  exists (x, b).
  intuition.
  eapply filter_In; intuition.
  eapply getSupport_In_evalDist; eauto.
  
  rewrite sumList_comm.
  symmetry.
  rewrite (sumList_filter_partition (fun p : A * B => P (fst p))).
  symmetry.
  rewrite ratAdd_0_r.
  eapply ratAdd_eqRat_compat.
  eapply sumList_body_eq; intuition.
  apply filter_In in H0; intuition.
  rewrite sumList_factor_constant_l.
  rewrite <- ratMult_1_r at 1.
  eapply ratMult_eqRat_compat; intuition.
  symmetry.
  destruct a0.
  simpl in *.
  rewrite (@sumList_exactly_one _ a0).
  destruct (EqDec_dec eqd a0 a0); intuition.
  eapply filter_NoDup.
  eapply getUnique_NoDup.
  eapply filter_In; intuition.
  eapply in_getUnique.
  eapply in_map_iff.
  econstructor. split; eauto.
  simpl.
  trivial.
  
  intuition.
  destruct (EqDec_dec eqd a0 b0); subst; intuition.
  
  symmetry.
  eapply sumList_0.
  intuition.
  eapply sumList_0; intuition.
  apply filter_In in H3; intuition.
  apply filter_In in H0; intuition.
  destruct a0.
  simpl in *.
  destruct (EqDec_dec eqd a0 a1); subst.
  destruct (P a1); simpl in *; discriminate.
  eapply ratMult_0_r.
  
  repeat rewrite ratMult_0_r.
  intuition.

  symmetry.
  eapply sumList_0; intuition.
  eapply filter_In in H0; intuition.
  destruct (EqDec_dec eqd (fst a) x); subst.
  destruct (P (fst a)); simpl in *; discriminate.
  
  repeat rewrite ratMult_0_r.
  intuition.
  
  unfold indicator.
  rewrite H.
  repeat rewrite ratMult_0_l.
  eapply sumList_0; intuition.
  apply filter_In in H0.
  intuition.
  rewrite H2.
  rewrite ratMult_1_l.
  destruct a.
  simpl in *.
  destruct (EqDec_dec eqd a x); subst; try congruence.
  rewrite ratMult_0_r.
  intuition.
  
Qed.

Theorem repeat_fission' : 
  forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(c : Comp A)(P1 : A -> bool)(P2 : B -> bool)(f : A -> Comp B) x,
    well_formed_comp c ->
    (exists a, In a (filter P1 (getSupport c))) ->
    (forall a, In a (getSupport c) -> well_formed_comp (f a)) -> 
    (forall a b, In a (getSupport c) -> In b (getSupport (f a)) -> (P1 a = P2 b)) ->
    evalDist (a <-$ Repeat c P1; f a) x ==
    evalDist
      (Repeat (a <-$ c; f a) P2) x.

  intuition.

  assert (evalDist (a <-$ Repeat c P1; f a) x  == 
          evalDist (z <-$ (a <-$ Repeat c P1; b <-$ f a; ret (a, b)); ret (snd z)) x).

  rewrite evalDist_assoc.
  eapply evalDist_seq_eq; intuition.
  rewrite evalDist_assoc.
  rewrite <- evalDist_right_ident.
  eapply evalDist_seq_eq; intuition.
  rewrite evalDist_left_ident.
  simpl.
  reflexivity.
  intuition.
  intuition.
  intuition.

  rewrite H3.
  clear H3.

  assert (evalDist (z <-$ (a <-$ Repeat c P1; b <-$ f a; ret (a, b)); ret snd z) x ==
          evalDist (z <-$ (Repeat (a <-$ c; b <-$ f a; ret (a, b)) (fun p => P1 (fst p))); ret snd z) x).

  eapply evalDist_seq_eq; intuition.
  eapply repeat_fission; intuition.
  rewrite H3.
  clear H3.

  assert (evalDist
     (z <-$
      Repeat (a <-$ c; b <-$ f a; ret (a, b)) (fun p : A * B => P1 (fst p));
      ret snd z) x == 
          evalDist
     (z <-$
      Repeat (a <-$ c; b <-$ f a; ret (a, b)) (fun p : A * B => P2 (snd p));
      ret snd z) x).
  
  eapply evalDist_seq_eq; intuition.
  destruct (in_dec (EqDec_dec _ ) a (getSupport c)).
  destruct (in_dec (EqDec_dec _) b (getSupport (f a))).
  case_eq (P1 a); intuition.

  eapply evalDist_Repeat_eq; intuition.
  eapply filter_In; intuition.
  eapply getSupport_In_Seq; eauto.
  eapply getSupport_In_Seq; eauto.
  simpl; intuition.

  eapply sumList_permutation.
  eapply NoDup_Permutation; intuition.
  eapply filter_NoDup.
  eapply getSupport_NoDup.
  eapply filter_NoDup.
  eapply getSupport_NoDup.

  apply filter_In in H4.
  intuition.
  repeat simp_in_support.
  eapply filter_In; intuition.
  eapply getSupport_In_Seq; eauto.
  eapply getSupport_In_Seq; eauto.
  simpl.
  intuition.
  simpl in *.
  erewrite <- H2; eauto.

  apply filter_In in H4.
  intuition.
  repeat simp_in_support.
  eapply filter_In; intuition.
  eapply getSupport_In_Seq; eauto.
  eapply getSupport_In_Seq; eauto.
  simpl.
  intuition.
  simpl in *.
  erewrite H2; eauto.

  assert (P2 b = false).
  erewrite <- H2; eauto.

  repeat rewrite evalDistRepeat_pred_0; intuition.

  repeat rewrite evalDistRepeat_sup_0; intuition;
  eapply getSupport_not_In_evalDist; intuition;
  repeat simp_in_support; intuition.

  repeat rewrite evalDistRepeat_sup_0; intuition;
  eapply getSupport_not_In_evalDist; intuition;
  repeat simp_in_support; intuition.

  rewrite H3.
  clear H3.

  rewrite repeat_snd_equiv.

  assert (forall a, 
             evalDist (p <-$ (a0 <-$ c; b <-$ f a0; ret (a0, b)); ret snd p) a ==
   evalDist (a0 <-$ c; f a0) a).
  intuition.
  rewrite evalDist_assoc; intuition.
  eapply evalDist_seq_eq; intuition.
  rewrite evalDist_assoc; intuition.
  symmetry.
  rewrite <- evalDist_right_ident.
  eapply evalDist_seq_eq; intuition.
  rewrite evalDist_left_ident; intuition.
  simpl.
  reflexivity.

  case_eq (P2 x); intuition.
  destruct (in_dec (EqDec_dec _) x (getSupport (Bind c f))).
  eapply evalDist_Repeat_eq; intuition.
  
  eapply filter_In; intuition.
  repeat simp_in_support.
  eapply getSupport_In_Seq.
  eapply getSupport_In_Seq; eauto.
  eapply getSupport_In_Seq; eauto.
  simpl.
  intuition.
  simpl.
  intuition.

  rewrite sumList_permutation.
  2:{
    eapply (evalDist_getSupport_filter_perm _ (a <-$ c; f a)); intuition.
  }

  eapply sumList_body_eq; intuition.
  
  repeat rewrite evalDistRepeat_sup_0; intuition;
  eapply getSupport_not_In_evalDist; intuition;
  repeat simp_in_support; intuition.
  eapply n.
  eapply getSupport_In_Seq; eauto.

  repeat rewrite evalDistRepeat_pred_0; intuition.
Qed.

Theorem prob_or_le_sum : 
  forall (c1 c2 : Comp bool),
    Pr[x1 <-$ c1;
        x2 <-$ c2;
        ret (x1 || x2)] <= Pr[c1] + Pr[c2].
  
  intuition.
  Local Transparent evalDist.
  simpl.
  rewrite (sumList_partition (fun x => x)).
  eapply ratAdd_leRat_compat.
  
  eapply leRat_trans.
  2:{
    eapply eqRat_impl_leRat.
    eapply evalDist_right_ident.
  }
  simpl.
  eapply sumList_le.
  intuition.
  destruct a; simpl.
  destruct (EqDec_dec bool_EqDec true true).
  rewrite ratMult_1_r.
  eapply ratMult_leRat_compat; intuition.
  eapply leRat_trans.
  eapply sumList_le.
  intros.
  eapply eqRat_impl_leRat.
  eapply ratMult_1_r.
  eapply evalDist_sum_le_1.
  
  intuition.

  rewrite ratMult_0_r.
  eapply rat0_le_all.
  
  eapply leRat_trans.
  2:{
    eapply eqRat_impl_leRat.
    eapply evalDist_right_ident.
  }
  simpl.
  eapply leRat_trans.
  eapply sumList_le.
  intros.
  eapply eqRat_impl_leRat.
  eapply eqRat_trans.
  eapply ratMult_eqRat_compat.
  symmetry.
  eapply sumList_factor_constant_l.
  reflexivity.
  symmetry.
  eapply sumList_factor_constant_r.
  rewrite sumList_summation.
  eapply sumList_le.
  intuition.
  destruct a.
  destruct (EqDec_dec bool_EqDec true true); intuition.
  
  eapply leRat_trans.
  eapply eqRat_impl_leRat.
  eapply sumList_body_eq.
  intros.
  rewrite orb_true_r.
  destruct ( EqDec_dec bool_EqDec true true).
  rewrite ratMult_1_r at 1.
  rewrite ratMult_assoc at 1.
  rewrite ratMult_comm at 1.
  eapply ratMult_assoc.
  intuition.
  rewrite sumList_factor_constant_l.
  eapply ratMult_leRat_compat.
  intuition.
  eapply leRat_trans.
  eapply sumList_le.
  intros.
  assert ( (if a then 0 else 1) * evalDist c1 a <= evalDist c1 a).
  eapply leRat_trans.
  2:{
    eapply eqRat_impl_leRat.
    eapply ratMult_1_l.
  }
  eapply ratMult_leRat_compat.
  destruct a;
    intuition.
  reflexivity.
  eapply H1.
  eapply evalDist_sum_le_1.
  
  destruct ( EqDec_dec bool_EqDec false true).
  discriminate.
  eapply leRat_trans.
  eapply eqRat_impl_leRat.
  eapply sumList_0.
  intuition.
  destruct a; simpl.
  repeat rewrite ratMult_0_r.
  intuition.
  destruct (EqDec_dec bool_EqDec false true ); try discriminate.
  repeat rewrite ratMult_0_r.
  eapply ratMult_0_l.
  
  eapply rat0_le_all.
Qed.

Theorem evalDist_orb_le : 
  forall (A : Set)(c : Comp A) f1 f2,
    Pr [x <-$ c; ret (f1 x || f2 x)] <=
    Pr[ x <-$ c; ret (f1 x)] + Pr[x <-$ c; ret (f2 x)].

  intuition.
  simpl.
  rewrite (sumList_partition f1).
  eapply ratAdd_leRat_compat.

  eapply sumList_le.
  intuition.
  rewrite ratMult_assoc.
  eapply ratMult_leRat_compat; intuition.
  destruct (f1 a); simpl.
  rewrite ratMult_1_r.
  reflexivity.
  rewrite ratMult_0_r.
  eapply rat0_le_all.

  eapply sumList_le.
  intuition.
  rewrite ratMult_assoc.
  eapply ratMult_leRat_compat; intuition.
  destruct (f1 a); simpl.
  rewrite ratMult_0_r.
  eapply rat0_le_all.
  rewrite ratMult_1_r.
  reflexivity.
  
Qed.