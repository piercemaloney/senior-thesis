

Set Implicit Arguments.



Require Import FCF.FCF.
(* FCF.FCF:
Require Export FCF.Crypto.
Require Export FCF.ProgramLogic.
Require Export FCF.ProgTacs.
Require Export FCF.RndNat.
Require Export FCF.GenTacs.
Require Export FCF.NotationV1.
Require Export FCF.Tactics.

Open Scope eq_scope. *)

Require Import hmacfcf.HMAC_spec.
(* hmacfcf.HMAC_spec:
Set Implicit Arguments.

Require Import Bvector.
Require Import List.
Require Import Arith.

Definition Blist := list bool.

Fixpoint splitVector(A : Set)(n m : nat) : Vector.t A (n + m) -> (Vector.t A n * Vector.t A m) :=
  match n with
    | 0 =>
      fun (v : Vector.t A (O + m)) => (@Vector.nil A, v)
    | S n' =>
      fun (v : Vector.t A (S n' + m)) =>
        let (v1, v2) := splitVector _ _ (Vector.tl v) in
          (Vector.cons _ (Vector.hd v) _ v1, v2)
  end.

Section HMAC.

  Variable c p : nat.
  Definition b := c + p.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  
  Variable iv : Bvector c.
  
  Definition h_star k (m : list (Bvector b)) :=
    fold_left h m k.
  
  Definition hash_words := h_star iv.

  Variable Message : Set.
  Variable splitAndPad : Message -> list (Bvector b).
  Hypothesis splitAndPad_1_1 :
    forall b1 b2,
      splitAndPad b1 = splitAndPad b2 ->
      b1 = b2.

  Variable fpad : Bvector c -> Bvector p.
  Definition app_fpad (x : Bvector c) : Bvector b :=
    (Vector.append x (fpad x)).

  Definition h_star_pad k x :=
    app_fpad (h_star k x).

  Definition GNMAC k m :=
    let (k_Out, k_In) := splitVector c c k in
    h k_Out (app_fpad (h_star k_In m)).

  Definition GHMAC_2K (k : Bvector (b + b)) m :=
    let (k_Out, k_In) := splitVector b b k in
      let h_in := (hash_words (k_In :: m)) in
        hash_words (k_Out :: (app_fpad h_in) :: nil).

  Definition HMAC_2K (k : Bvector (b + b)) (m : Message) :=
    GHMAC_2K k (splitAndPad m).

  Variable opad ipad : Bvector b.
  Hypothesis opad_ne_ipad : opad <> ipad.

  Definition GHMAC (k : Bvector b) :=
    GHMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

  Definition HMAC (k : Bvector b) :=
    HMAC_2K (Vector.append (BVxor _ k opad) (BVxor _ k ipad)).

End HMAC. *)

Require Import FCF.PRF.
(* FCF.PRF:
Set Implicit Arguments.
Require Import FCF.FCF.
Require Import FCF.CompFold. 
Require Export FCF.Array.
Require Export FCF.Hybrid.

Local Open Scope list_scope.
Local Open Scope array_scope.

Definition oracleMap(D R S: Set)(eqds : EqDec S)(eqdr : EqDec R)(oracle : S  -> D -> Comp (R * S))(s : S)(ds : list D) :=
  compFold _ 
  (fun acc d => [rs, s] <-2 acc; [r, s] <-$2 oracle s d; ret (rs ++ r :: nil, s)) 
  (nil, s) ds.

Theorem oracleMap_wf : 
  forall (D R S : Set)(eqds : EqDec S)(eqdr : EqDec R) (oracle : S -> D -> Comp (R * S))ds s,
  (forall s x, well_formed_comp (oracle s x)) ->
  well_formed_comp (@oracleMap D R S _ _ oracle s ds).

  Hypothesis RndR_wf : well_formed_comp RndR.
  
  Definition randomFunc (f : (list (D * R))) (d : D) : Comp (R * list (D * R)) :=
      match (arrayLookup _ f d) with
        | None => (r <-$ RndR; ret (r, (d, r) :: f))
        | Some r => ret (r, f)
      end.  
  
  Lemma randomFunc_wf : forall f d, 
    well_formed_comp (randomFunc f d).
  
  Hint Resolve randomFunc_wf : wftac.

  Definition RndFunc(lsd : list D) : Comp (list (D * R)) :=
    compFold _ (fun f d => r <-$ RndR; ret (d, r)::f) nil lsd. 
  
End RandomFunc.

Local Open Scope type_scope.
Local Open Scope comp_scope.

Section PRF_concrete.
  
  Variable D R Key : Set.
  Variable RndKey : Comp Key.
  Variable RndR : Comp R.
  Variable f : Key -> D -> R.

  Hypothesis D_EqDec : EqDec D.
  Hypothesis R_EqDec : EqDec R.

  Definition RndR_func : (list (D * R) -> D -> Comp (R * list (D * R))) :=
    (randomFunc RndR _).

  Section PRF_NA_concrete.
  
    Variable State : Set.
    Variable A1 : Comp (list D * State).
    Variable A2 : State -> list R -> Comp bool.

    Definition PRF_NA_G_A : Comp bool := 
      [lsD, s_A] <-$2 A1; 
      lsR <-$ (k <-$ RndKey; ret (map (f k) lsD));
      A2 s_A lsR.
    
    Definition PRF_NA_G_B : Comp bool := 
      [lsD, s_A] <-$2 A1;
      [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD;
      A2 s_A lsR.
    
    Definition PRF_NA_Advantage := 
    | Pr[PRF_NA_G_A] - Pr[PRF_NA_G_B] |.  

  End PRF_NA_concrete.

  Section PRF_NAI_concrete.

    Variable A_state : Set.
    Variable A1 : Comp ((list (list D)) * A_state).
    Variable A2 : A_state -> list (list R) -> Comp bool.

    Definition PRF_NAI_G0 :=
      [lsDs, s_A] <-$2 A1;
      lsRs <-$ compMap _ (fun lsD => k <-$ RndKey; ret (map (f k) lsD)) lsDs;
      A2 s_A lsRs.

    Definition PRF_NAI_G1 :=
      [lsDs, s_A] <-$2 A1;
      lsRs <-$ compMap _ (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR) lsDs;
      A2 s_A lsRs.

    Definition PRF_NAI_Advantage := 
    | Pr[PRF_NAI_G0] - Pr[PRF_NAI_G1] |.   
                         
  Section PRF_NA_impl_NAI.

    Variable maxLists : nat.
    Hypothesis maxLists_correct : 
      forall ls s_A, 
        In (ls, s_A) (getSupport A1) ->
        (length ls <= maxLists)%nat.

    Hypothesis A_state_EqDec : EqDec A_state.
    Hypothesis RndR_wf : well_formed_comp RndR.
    Hypothesis RndKey_wf : well_formed_comp RndKey.

    Variable maxDistance : Rat.
    Hypothesis maxDistance_correct : 
      forall i, 
      PRF_NA_Advantage (B1 nil _ _ A1 i) (B2 (fun lsD => k <-$ RndKey; ret (map (f k) lsD))
              (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR)
              _ A2) <= maxDistance.

    Theorem PRF_NAI_Advantage_eq_Hybrid:
      PRF_NAI_Advantage == ListHybrid_Advantage 
                             (fun lsD => k <-$ RndKey; ret (map (f k) lsD))
                             (fun lsD => [lsR, _] <-$2 oracleMap _ _ RndR_func nil lsD; ret lsR)
                             _ A1 A2.

    Theorem PRF_NA_impl_NAI : 
      PRF_NAI_Advantage <= (maxLists / 1 * maxDistance)%rat.

  End PRF_NA_impl_NAI.

  End PRF_NAI_concrete.

  Section PRF_Full_concrete.
    
    Variable A : OracleComp D R bool.
    
    Definition f_oracle(k : Key)(x : unit)(d : D) :=
      ret (f k d, tt).
    
    Definition PRF_G_A : Comp bool := 
      k <-$ RndKey;
      [b, _] <-$2 A _ _ (f_oracle k) tt;
      ret b.
    
    Definition PRF_G_B : Comp bool := 
      [b, _] <-$2 A _ _ (RndR_func) nil;
      ret b.
    
    Definition PRF_Advantage := 
    | Pr[PRF_G_A] - Pr[PRF_G_B] |.  
    
  End PRF_Full_concrete.

  Section PRF_Finite_concrete.

    Variable dom : list D.
    Variable def : R.
    Variable A : (D -> R) -> Comp bool.

    Definition PRF_Fin_G_A : Comp bool := 
      k <-$ RndKey;
      A (f k).
    
    Definition PRF_Fin_G_B : Comp bool := 
      f <-$ @RndFunc D R RndR _ dom;
      A (fun d => arrayLookupDef _ f d def).

    Definition PRF_Fin_Advantage := 
    | Pr[PRF_Fin_G_A] - Pr[PRF_Fin_G_B] |.

  End PRF_Finite_concrete.
  
End PRF_concrete.

Require Import FCF.Asymptotic.
Require Import FCF.Admissibility.

Section PRF.

  Variable D R Key : DataTypeFamily.
  Variable RndKey : forall n, Comp (Key n).
  Variable RndR : forall n, Comp (R n).
  Variable f : forall n, Key n -> D n -> R n.

  Hypothesis D_EqDec : forall n, EqDec (D n).
  Hypothesis R_EqDec : forall n, EqDec (R n).

  Section PRF_NA.
    Variable admissible_A1 : pred_comp_fam.
    Variable admissible_A2 : pred_comp_func_2_fam.
    
    Definition PRF_NA :=
      forall (State : DataTypeFamily) A1 A2,
        admissible_A1 _ A1 -> 
        admissible_A2 State _ _ A2 ->
        negligible (fun n => PRF_NA_Advantage (RndKey n) (RndR n) (@f n) _ _ (A1 n) (@A2 n)).
  End PRF_NA.

  Section PRF_Full.
    Variable admissible_A : pred_oc_fam.
    
    Definition PRF :=
      forall (A : forall n, OracleComp (D n) (R n) bool),
        admissible_A _ _ _ A -> 
        negligible (fun n => PRF_Advantage (RndKey n) (RndR n) (@f n) _ _ (A n)).
  End PRF_Full.
      
End PRF. *)

Require Import hmacfcf.NMAC_to_HMAC.
(* hmacfcf.NMAC_to_HMAC:
Set Implicit Arguments.

Require Import FCF.FCF.
Require Import FCF.PRF.
Require Import hmacfcf.splitVector.

Require Import hmacfcf.HMAC_spec.

Section RelatedKeyAttack.

  Variable K D R Phi_s : Set.
  Variable K_EqDec : EqDec K.
  Variable D_EqDec : EqDec D.
  Variable R_EqDec : EqDec R.
  Variable RndK : Comp K.
  Variable RndR : Comp R.
  Variable f : K -> D -> R.
  Variable Phi : Phi_s -> K -> K.

  Variable A : OracleComp (Phi_s * D) R bool.

  Definition RKA_F k (s : unit) p :=
    [phi_s, x] <-2 p; ret (f (Phi phi_s k) x, tt).

  Definition RKA_randomFunc := @randomFunc (K * D) R RndR _.

  Definition RKA_R k s p :=
    [phi_s, x] <-2 p; (RKA_randomFunc s (Phi phi_s k, x)).

  Definition RKA_G0 :=
    k <-$ RndK;
    [b, _] <-$2 A _ _ (RKA_F k) tt;
    ret b.

  Definition RKA_G1 :=
    k <-$ RndK;
    [b, _] <-$2 A _ _ (RKA_R k) nil;
    ret b.

  Definition RKA_Advantage :=
    | Pr[RKA_G0] - Pr[RKA_G1] |.

End RelatedKeyAttack.

Definition dual_f (A B C : Set)(f : A -> B -> C) : B -> A -> C :=
  fun b a => f a b.

Section NMAC_to_HMAC.

  Variable c p : nat.
  Definition b := @b c p.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  Variable iv : Bvector c.
  Variable fpad : Bvector c -> Bvector p.

  Definition GHMAC_2K := GHMAC_2K h iv fpad.
  Variable opad ipad : Bvector b.
  Hypothesis opad_ne_ipad : opad <> ipad.

  Definition GHMAC := GHMAC h iv fpad opad ipad.

  Variable A : OracleComp (list (Bvector b)) (Bvector c) bool.

  Definition app_fpad := @app_fpad c p fpad.
  Definition h_star := h_star p h.

  Definition GNMAC := GNMAC h fpad.

  Definition A_NMAC :=
    x <-$ {0, 1}^(c + c);
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ x) tt;
    ret b.

  Definition A_HMAC :=
    x <-$ {0, 1}^b;
    [b, _] <-$2 A _ _ (f_oracle GHMAC _ x) tt;
    ret b.

  Theorem GHMAC_2K_GNMAC_equiv :
    forall k ls,
      let (k_Out, k_In) := splitVector b b k in
        let k' := Vector.append (h iv k_Out) (h iv k_In) in

  Definition HMAC_RKA_A : OracleComp (Bvector b * Bvector c) (Bvector c) bool :=
    k_Out <--$ OC_Query _ (opad, iv);
    k_In <--$ OC_Query _ (ipad, iv);
    [b, _] <--$2 $ A _ _ (f_oracle GNMAC _ (Vector.append k_Out k_In)) tt;
    $ ret b.

  Local Opaque evalDist.

  Theorem A_HMAC_RKA_equiv :
    Pr[A_HMAC] == Pr[RKA_G0 _ (Rnd b) (dual_f h) (BVxor b) HMAC_RKA_A].

  Definition A_NMAC_G1 :=
    x1 <-$ {0, 1}^c;
    x2 <-$ {0, 1}^c;
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt;
    ret b.

  Definition A_NMAC_G1_0 :=
    [x1, x2] <-$2 (
    x <-$ {0, 1}^(c + c);
    ret (splitVector c c x));
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt;
    ret b.

  Definition A_NMAC_G1_1 :=
    [x1, x2] <-$2 (
    x1 <-$ {0, 1}^c;
    x2 <-$ {0, 1}^c;
    ret (x1, x2));
    [b, _] <-$2 A _ _ (f_oracle GNMAC _ (Vector.append x1 x2)) tt;
    ret b.

  Theorem A_NMAC_G1_0_equiv :
    Pr[A_NMAC] == Pr[A_NMAC_G1_0].

  Theorem A_NMAC_G1_0_1_equiv :
    Pr[A_NMAC_G1_0] == Pr[A_NMAC_G1_1].

  Theorem  A_NMAC_G1_1_equiv :
    Pr[A_NMAC_G1_1] == Pr[A_NMAC_G1].

  Theorem A_NMAC_G1_equiv :
    Pr[A_NMAC] == Pr[A_NMAC_G1].

    Theorem xor_1_1 :
      forall (n : nat)(x y z : Bvector n),
        BVxor _ y x = BVxor _ z x ->
        y = z.

  Theorem A_NMAC_RKA_equiv :
    Pr[A_NMAC] == Pr[RKA_G1 _ _ _ (Rnd b) (Rnd c) (BVxor b) HMAC_RKA_A].

  Theorem A_HMAC_NMAC_close :
    | Pr[A_HMAC] - Pr[A_NMAC] | <=
      RKA_Advantage _ _ _ (Rnd b) (Rnd c) (dual_f h) (BVxor b) HMAC_RKA_A.

End NMAC_to_HMAC. *)

Require Import hmacfcf.hF.
(* hmacfcf.hF:
Set Implicit Arguments.

Require Import FCF.FCF.
Require Import FCF.PRF.
Require Import hmacfcf.splitVector.
Require Import hmacfcf.cAU.
Require Import FCF.CompFold.
Require Import FCF.DetSem FCF.SemEquiv.

Local Open Scope list_scope.

Section hF.

  Variable b k c : nat.

  Variable h : Bvector c -> Bvector b -> Bvector c.
  Variable F : Bvector k -> list (Bvector b) -> Bvector b.

  Definition hF key m :=
    [k_Out, k_In] <-2 splitVector c k key;
    h k_Out (F k_In m).

  Variable A : OracleComp (list (Bvector b)) (Bvector c) bool.
  Hypothesis A_wf : well_formed_oc A.

  Definition G0 :=
    k_in <-$ {0, 1}^k;
    k_out <-$ {0, 1}^c;
    [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt;
    ret b.

  Definition G1 :=
    k_in <-$ {0, 1}^k;
    [b, _] <-$2 A _ _
    (fun (s : list (Bvector b * Bvector c)) m =>
      randomFunc ({0, 1}^c) _ s (F k_in m)) nil;
    ret b.

  Definition G2 :=
    [b, _] <-$2 A _ _
    (fun (s : list (list (Bvector b) * Bvector c)) m =>
      randomFunc ({0, 1}^c) _ s m) nil;
    ret b.

  Definition G0_1 :=
    [k_out, k_in] <-$2 (
    key <-$ {0, 1}^(c + k);
    ret splitVector c k key);
    [b, _] <-$2 A _ _ (fun (_ : unit) m => ret (h k_out (F k_in m), tt)) tt;
    ret b.

  Theorem G0_1_equiv :
    Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0_1].

  Theorem G0_1_G0_equiv :
    Pr[G0_1] == Pr[G0].

  Theorem G0_equiv :
    Pr[PRF_G_A ({0, 1}^(c + k)) hF _ A] == Pr[G0].

  Definition hF_oracle k_in (s : unit) m : OracleComp (Bvector b) (Bvector c) (Bvector c * unit) :=
    r <--$ OC_Query _ (F k_in m);
    $ ret (r, tt).

  Definition PRF_h_A : OracleComp (Bvector b) (Bvector c) bool :=
    k_in <--$$ {0, 1}^k;
    [r, _] <--$2 OC_Run _ _ _ A (hF_oracle k_in) tt;
    $ ret r.

  Definition G1_1 :=
    k_out <-$ { 0 , 1 }^c;
    [b, _] <-$2 PRF_h_A _ _ (f_oracle h _ k_out) tt;
    ret b.

  Definition G1_2 :=
    [b, _] <-$2 PRF_h_A _ _ (randomFunc ({0, 1}^c) _) nil;
    ret b.

  Local Opaque evalDist.

  Theorem G0_G1_1_equiv :
    Pr[G0] == Pr[G1_1].

  Theorem G1_1_2_close :
    | Pr[G1_1] - Pr[G1_2] | <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A.

  Theorem G1_2_G1_equiv :
    Pr[G1_2] == Pr[G1].

  Theorem G0_G1_equiv :
    | Pr[G0] - Pr[G1] | <= PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A.

  Definition randomFunc_mem (D R : Set)(eqdd : EqDec D)(eqdr : EqDec R)(RndR : Comp R) (ls : list (D * R))d :=
    match (arrayLookup _ ls d) with
      | Some r =>
        ret (r, (d, r) :: ls)
      | None =>
        r <-$ RndR; ret (r, (d, r) :: ls)
    end.

    Theorem randomFunc_mem_spec :
    forall (D R : Set)(eqdd : EqDec D)(eqdr : EqDec R)(RndR : Comp R) (x1 x2 : list (D * R)) a,
      (forall z, arrayLookup _ x1 z = arrayLookup _ x2 z) ->
    comp_spec
     (fun y1 y2 =>
      fst y1 = fst y2 /\
      (forall x,
       arrayLookup _ (snd y1) x =
       arrayLookup _ (snd y2) x))
     (randomFunc_mem _ _ RndR x1 a)
     (randomFunc RndR _ x2 a).

  Definition G2_1 :=
    k_in <-$ {0, 1}^k;
    [b, _] <-$2 A _ _ (fun s d => randomFunc_mem _ _ ({0, 1}^c) s (F k_in d)) nil;
    ret b.

  Theorem G2_1_equiv :
    Pr[G1] == Pr[G2_1].

  Fixpoint arrayLookup_f (A B C : Set)(eqd : EqDec B)(ls : list ((A * B) * C))(a : B) :=
    match ls with
      | nil => None
      | ((x, z), y) :: ls' =>
        if (eqb a z) then (Some y) else (arrayLookup_f _ ls' a)
    end.

  Definition F_randomFunc k_in f d :=
    match arrayLookup_f _ f (F k_in d) with
      | Some r => ret (r, ((d, F k_in d), r) :: f)
      | None => r <-$ {0, 1}^c; ret (r, ((d, F k_in d), r) :: f)
    end.

  Definition G2_2 :=
    k_in <-$ {0, 1}^k;
    [b, _] <-$2 A _ _ (F_randomFunc k_in) nil;
    ret b.

    Theorem arrayLookup_f_equiv :
      forall (A B C : Set) (eqdb : EqDec B) (x1 : list (B * C)) (x2 : list (A * B * C)) (a : B),
      list_pred
         (fun c0 d =>
          fst c0 = snd (fst d) /\ snd c0 = snd d) x1 x2 ->
         arrayLookup _ x1 a = arrayLookup_f _ x2 a.

  Theorem G2_1_2_equiv :
    Pr[G2_1] == Pr[G2_2].

  Fixpoint findCollision_1 (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a : A)(b : B) :=
    match ls with
      | nil => None
      | (a', b') :: ls' => if
        (eqb b b' && (negb (eqb a a')))
        then (Some a') else (findCollision_1 _ _ ls' a b)
    end.

  Definition collidesWith (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a : A) b :=
    if (findCollision_1 _ _ ls a b) then true else false.

  Fixpoint findCollision(A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B)) : option (A * A * B) :=
    match ls with
      | nil => None
      | (a, b) :: ls' => let a' := (findCollision_1 _ _ ls' a b) in
        match a' with
          | None =>  (findCollision _ _ ls')
          | Some p' => Some (a, p', b)
        end
    end.

  Definition funcCollision (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B)) :=
    if (findCollision _ _ ls) then true else false.

  Definition G2_3 :=
    k_in <-$ {0, 1}^k;
    [b, f] <-$2 A _ _ (F_randomFunc k_in) nil;
    ret (b, funcCollision _ _ (fst (split f))).

  Theorem G2_2_3_equiv :
    Pr[G2_2] == Pr[x <-$ G2_3; ret fst x].

  Definition G2_4 :=
    k_in <-$ {0, 1}^k;
    [b, f] <-$2 A _ _ (fun s a => b <- F k_in a; randomFunc_mem _ _ ({0, 1}^c) s (a, b)) nil;
    ret (b, funcCollision _ _ (fst (split f))).

  Theorem arrayLookup_noCollision_eq :
    forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) a b0 b,
      arrayLookup _ x1 (a, b) = Some b0 ->
      collidesWith _ _ (fst (split x1)) a b = false ->
      arrayLookup_f _ x1 b = Some b0.

  Theorem in_impl_collidesWith :
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B)(ls : list (A * B))(a a': A) (b : B),
      In (a, b) ls ->
      a <> a' ->
      collidesWith _ _ ls a' b = true.

  Theorem funcCollision_false_impl_collidesWith_false :
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) ls (a : A) (b : B),
      funcCollision _ _ ls = false ->
      In (a, b) ls ->
      collidesWith _ _ ls a b = false.

  Theorem arrayLookup_Some_In_split:
    forall (A B : Set) (eqd : EqDec A) (arr : list (A * B)) (a : A) (b : B),
      arrayLookup eqd arr a = Some b -> In a (fst (split arr)).

  Theorem arrayLookup_noCollision_eq_f :
    forall (A B C : Set)(eqda : EqDec A)(eqdb : EqDec B)(x1 : list ((A * B) * C)) (a : A) (b : B) c,
      arrayLookup_f _ x1 b = Some c ->
      collidesWith _ _ (fst (split x1)) a b = false ->
      arrayLookup _ x1 (a, b) = Some c.

  Theorem funcCollision_true_cons :
    forall (A B : Set)(eqda : EqDec A)(eqdb : EqDec B) (ls : list (A * B)) a,
      funcCollision _ _ ls = true ->
      funcCollision _ _ (a :: ls) = true.

  Theorem F_randomFunc_preserves_coll :
    forall c0 x d a b0,
      funcCollision _ _ (fst (split c0)) = true ->
      In (a, b0) (getSupport (F_randomFunc x c0 d)) ->
      funcCollision _ _ (fst (split b0)) = true.

  Theorem randomFunc_mem_preserves_coll :
    forall (D1 D2 R : Set)(eqdd : EqDec D1)(eqdd2 : EqDec D2)(eqdr : EqDec R) (RndR : Comp R) (c0 : list ((D1 * D2) * R)) d a b0,
      funcCollision _ _ (fst (split c0)) = true ->
      In (a, b0) (getSupport (randomFunc_mem _ _  RndR c0 d)) ->
      funcCollision _ _ (fst (split b0)) = true.

  Theorem F_randomFunc_wf :
    forall x y z,
      well_formed_comp (F_randomFunc x y z).

  Theorem randomFunc_mem_wf :
    forall (A B : Set) x y z (w : list (A * B)) v,
      well_formed_comp z ->
      well_formed_comp (randomFunc_mem x y z w v).

  Theorem A_randomFunc_F_spec :
    forall x,
      comp_spec (fun y1 y2 =>
        funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)
       (fst (split (snd y1))) =
       funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)
       (fst (split (snd y2))) /\
        (funcCollision (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b)
       (fst (split (snd y1))) = false ->
       y1 = y2))
       (A (list (list (Bvector b) * Bvector b * Bvector c))
        (list_EqDec
           (pair_EqDec
              (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b))
              (Bvector_EqDec c))) (F_randomFunc x) nil)
     (A (list (list (Bvector b) * Bvector b * Bvector c))
        (list_EqDec
           (pair_EqDec
              (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b))
              (Bvector_EqDec c)))
        (fun (s : list (list (Bvector b) * Bvector b * Bvector c))
           (a : list (Bvector b)) =>
         randomFunc_mem
           (pair_EqDec (list_EqDec (Bvector_EqDec b)) (Bvector_EqDec b))
           (Bvector_EqDec c) ({ 0 , 1 }^c) s (a, F x a)) nil).

  Theorem G2_3_4_bad_eq :
    Pr[x <-$ G2_3; ret (snd x)] == Pr[x <-$ G2_4; ret (snd x)].

  Theorem G2_3_4_eq_until_bad :
    forall x,
      evalDist G2_3 (x, false) == evalDist G2_4 (x, false).

  Definition F_randomFunc_O f d :
    OracleComp
    (list (Bvector b))
    (Bvector b)
    (Bvector c * list ((list (Bvector b) * Bvector b) * Bvector c))  :=
    fd <--$ OC_Query _ d;
    match arrayLookup_f _ f fd with
      | Some r => $ ret (r, ((d, fd), r) :: f)
      | None => r <--$$ {0, 1}^c; $ ret (r, ((d, fd), r) :: f)
    end.

  Definition au_F_A : OracleComp (list (Bvector b)) (Bvector b) _ :=
    [_, p ] <--$2 OC_Run _ _ _ A F_randomFunc_O nil;
    let coll :=
      match (findCollision _ _ (fst (split p)) ) with
        | None => (nil, nil)
        | Some p => fst p
      end in
      $ ret (coll).

  Definition G2_3_bad :=
    k_in <-$ {0, 1}^k;
    [p, _] <-$2 au_F_A _ _ (WCR_Oracle _ F k_in) tt;
    [d1, d2] <-2 p;
    ret (negb (eqb d1 d2) && eqb (F k_in d1) (F k_in d2)).

  Theorem G2_3_bad_small :
    Pr[G2_3_bad] == Adv_WCR _ _ F (Rnd k) au_F_A.

    Theorem findCollision_1_correct :
      forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y,
      findCollision_1 eqd1 eqd2 ls x1 y =
       Some x2 ->
       x1 <> x2 /\
       In (x2, y) ls.

    Theorem findCollision_correct :
      forall (A B : Set) eqd1 eqd2 (ls : list (A * B)) (x1 x2 : A) y,
      findCollision eqd1 eqd2 ls =
       Some (x1, x2, y) ->
       x1 <> x2 /\
       In (x1, y) ls /\
       In (x2, y) ls.

  Theorem G2_3_bad_equiv :
    Pr[x <-$ G2_3; ret (snd x)] == Pr[G2_3_bad].

  Theorem G2_3_4_close :
    | Pr[x <-$ G2_3; ret fst x] - Pr[x <-$ G2_4; ret fst x] | <=
      Adv_WCR _ _ F (Rnd k) au_F_A.

  Definition G2_5 :=
    [b, _] <-$2 A _ _ (fun s a => randomFunc_mem _ _ ({0, 1}^c) s a) nil;
    ret b.

  Theorem G2_4_5_equiv :
    Pr[x <-$ G2_4; ret fst x] == Pr[G2_5].

  Theorem G2_5_equiv :
    Pr[G2_5] == Pr[G2].

  Theorem G1_G2_equiv :
    | Pr[G1] - Pr[G2] | <= Adv_WCR _ _ F (Rnd k) au_F_A.

  Theorem G2_equiv :
    Pr[G2] == Pr[PRF_G_B ({0, 1}^c) _ _ A].

  Theorem hF_PRF :
    PRF_Advantage ({0, 1}^(c + k)) ({0, 1}^c) hF _ _ A <=
    PRF_Advantage ({0, 1}^c) ({0, 1}^c) h _ _ PRF_h_A +
    Adv_WCR _ _ F (Rnd k) au_F_A.

End hF. *)

Require Import hmacfcf.GHMAC_PRF.
(* hmacfcf.GHMAC_PRF:
Set Implicit Arguments.

Require Import FCF.FCF.
Require Import hmacfcf.HMAC_spec.
Require Import FCF.PRF.
Require Import hmacfcf.NMAC_to_HMAC.
Require Import hmacfcf.hF.
Require Import hmacfcf.GNMAC_PRF.

Section GHMAC_PRF.

  Variable c p : nat.
  Definition b := @b c p.
  Variable h : Bvector c -> Bvector b -> Bvector c.
  Variable iv : Bvector c.

  Variable fpad : Bvector c -> Bvector p.
  Variable opad ipad : Bvector b.
  Hypothesis opad_ne_ipad : opad <> ipad.

  Definition GHMAC := GHMAC h iv fpad opad ipad.

  Variable A : OracleComp (list (Bvector b)) (Bvector c) bool.
  Hypothesis A_wf : well_formed_oc A.

  Theorem GHMAC_PRF :
    PRF_Advantage (Rnd b) (Rnd c) GHMAC _ _ A <=
     RKA_Advantage _ _ _  ({ 0 , 1 }^b) ({ 0 , 1 }^c)
     (dual_f h) (BVxor b) (HMAC_RKA_A h iv fpad opad ipad A) +
   (PRF_Advantage ({ 0 , 1 }^c) ({ 0 , 1 }^c) h _ _
     (PRF_h_A (h_star_pad h fpad) A) +
    cAU.Adv_WCR _ _

End GHMAC_PRF. *)



Section HMAC_PRF.



  Variable c p : nat.

  Definition b := @b c p.

  Variable h : Bvector c -> Bvector b -> Bvector c.

  Variable iv : Bvector c.



  Variable Message : Set.

  Hypothesis Message_EqDec : EqDec Message.

  Variable splitAndPad : Message -> list (Bvector b).



  Hypothesis splitAndPad_1_1 :

    forall b1 b2,

      splitAndPad b1 = splitAndPad b2 ->

      b1 = b2.



  Variable fpad : Bvector c -> Bvector p.

  Definition h_star_pad := h_star_pad h fpad.

  Variable opad ipad : Bvector b.

  Hypothesis opad_ne_ipad : opad <> ipad.



  Section h_star_WCR.



    Definition h_star := h_star _ h.



    Variable Z : OracleComp (list (Bvector (HMAC_spec.b c p))) (Bvector (HMAC_spec.b c p))

    (list (Bvector (HMAC_spec.b c p)) * list (Bvector (HMAC_spec.b c p))).



    Definition Y : OracleComp (list (Bvector (HMAC_spec.b c p))) (Bvector c)

    (list (Bvector (HMAC_spec.b c p)) * list (Bvector (HMAC_spec.b c p))) :=

      [x, _] <--$2 OC_Run _ _ _ Z (fun _ d => r <--$ OC_Query _ d; $ ret ((app_fpad fpad r), tt)) tt;

      $ ret x.



      Theorem Vector_append_inj_first :

        forall (A : Set)(a : nat)(a1 a2 : Vector.t A a)(b : nat)(b1 b2 : Vector.t A b),

          Vector.append a1 b1 = Vector.append a2 b2 ->

          a1 = a2.



        induction a1; intuition.

        rewrite vector_0 in *.

        trivial.

        destruct (vector_S a2).

        destruct H2.

        subst.

        repeat rewrite <- splitVector.Vector_cons_app_assoc in H.



        inversion H.

        apply vector_cons_eq in H.

        f_equal.

        eapply IHa1.

        eauto.

      Qed.



    Theorem WCR_h_star_pad_impl_h_star :

        cAU.Adv_WCR _ _ h_star_pad

                    ({ 0 , 1 }^c) Z <=

        cAU.Adv_WCR _ _ h_star

                    ({ 0 , 1 }^c) Y.



      unfold cAU.Adv_WCR, cAU.Adv_WCR_G.

      comp_skip.

      unfold Y.

      eapply comp_spec_impl_le.

      simpl.

      inline_first.

      comp_skip.

      eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _ (fun a b => fst b = a)).

      trivial.

      intuition.

      subst.

      unfold cAU.WCR_Oracle.

      inline_first.

      comp_simp.

      inline_first.

      comp_simp.

      simpl.

      eapply comp_spec_ret.

      intuition.

      simpl in *.

      intuition.

      destruct b2.

      simpl in *.

      subst.

      comp_simp.

      simpl.

      comp_simp.

      inline_first.

      comp_simp.

      eapply comp_spec_ret.

      intuition.

      unfold h_star_pad in *.

      case_eq (eqb a b1); intuition;

      rewrite H3 in H2;

      simpl in *.

      discriminate.

      apply eqbBvector_sound in H2.

      unfold HMAC_spec.h_star_pad, HMAC_spec.app_fpad in *.



      eapply Vector_append_inj_first in H2.

      unfold h_star, NMAC_to_HMAC.h_star.

      rewrite H2.

      eapply eqbBvector_complete.

    Qed.



  End h_star_WCR.



  Definition HMAC := HMAC h iv splitAndPad fpad opad ipad.

  Definition GHMAC := GHMAC h iv fpad opad ipad.



  Variable A : OracleComp Message (Bvector c) bool.

  Hypothesis A_wf : well_formed_oc A.



  Definition A_GHMAC : OracleComp (list (Bvector b)) (Bvector c) bool :=

    [b, _] <--$2 OC_Run _ _ _ A

    (fun _ q =>

      ls <- splitAndPad q;

      r <--$ OC_Query _ ls;

    $ ret (r, tt)) tt;

    $ ret b.



  Theorem GHMAC_to_HMAC :

    PRF_Advantage (Rnd b) (Rnd c) HMAC _ _ A ==

    PRF_Advantage (Rnd b) (Rnd c) GHMAC _ _ A_GHMAC.



    unfold PRF_Advantage.

    eapply ratDistance_eqRat_compat.



    unfold PRF_G_A, HMAC, HMAC_spec.HMAC, GHMAC, NMAC_to_HMAC.GHMAC.

    comp_skip.

    unfold A_GHMAC.

    eapply comp_spec_eq_impl_eq.

    simpl.

    inline_first.

    comp_skip.

    eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _  _ (fun a b => True)); intuition.

    unfold f_oracle.

    unfold HMAC_2K, HMAC_spec.GHMAC.

    inline_first.

    comp_simp.

    inline_first.

    comp_simp.

    simpl.

    eapply comp_spec_ret; intuition.



    simpl in *.

    comp_simp.

    simpl.

    inline_first.

    comp_simp.

    intuition; subst.

    eapply comp_spec_eq_refl.



    unfold PRF_G_B, A_GHMAC.

    eapply comp_spec_eq_impl_eq.



    simpl.

    inline_first.

    comp_skip.

    eapply (@oc_comp_spec_eq _ _ _ _ _ _ _ _ _ _ _ _ _ _

      (fun a b => forall x, arrayLookup _ (snd b) (splitAndPad x) = arrayLookup _ a x)).

    intuition.



    intuition.

    inline_first.

    unfold RndR_func, randomFunc.

    rewrite H.

    case_eq ( arrayLookup Message_EqDec x1 a ); intuition.

    comp_simp.

    inline_first.

    comp_simp.

    simpl.

    eapply comp_spec_ret; intuition.



    inline_first.

    comp_skip.

    comp_simp.

    inline_first.

    comp_simp.

    simpl.

    eapply comp_spec_ret; intuition.

    simpl.

    case_eq (eqb x a); intuition.

    rewrite eqb_leibniz in H5.

    subst.

    rewrite eqb_refl.

    trivial.



    case_eq (eqb (splitAndPad x) (splitAndPad a)); intuition.

    rewrite eqb_leibniz in H6.

    apply splitAndPad_1_1 in H6.

    subst.

    rewrite eqb_refl in H5.

    discriminate.



    simpl in *.

    intuition; subst.

    comp_simp.

    simpl.

    inline_first.

    comp_simp.

    eapply comp_spec_eq_refl.



  Qed.



  Theorem HMAC_PRF:

    PRF_Advantage (Rnd b) (Rnd c) HMAC _ _ A <=

    RKA_Advantage _ _ _  ({ 0 , 1 }^b)

     ({ 0 , 1 }^c) (dual_f h) (BVxor b)

     (HMAC_RKA_A h iv fpad opad ipad A_GHMAC) +

   (PRF_Advantage ({ 0 , 1 }^c) ({ 0 , 1 }^c) h _ _

      (PRF_h_A h_star_pad A_GHMAC) +

    cAU.Adv_WCR _ _ h_star

      ({ 0 , 1 }^c) (Y (au_F_A A_GHMAC))).



    rewrite GHMAC_to_HMAC.



    eapply leRat_trans.

    apply GHMAC_PRF.

    trivial.

    unfold A_GHMAC.

    econstructor.

    econstructor.

    trivial.

    intuition.

    econstructor.

    econstructor.

    intuition.

    econstructor.

    wftac.

    intuition.

    econstructor.

    wftac.



    eapply ratAdd_leRat_compat; try reflexivity.

    eapply ratAdd_leRat_compat; try reflexivity.

    eapply WCR_h_star_pad_impl_h_star.

  Qed.



  Print Assumptions HMAC_PRF.



End HMAC_PRF.
