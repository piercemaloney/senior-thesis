

Require Import VST.msl.base.
(* VST.msl.base:
Require Export VST.msl.Extensionality.
Require Export Coq.Lists.List.
Require Export Coq.Bool.Bool.
Require Export Coq.Relations.Relations.
Require Export Omega.

Definition compose (A B C:Type) (g:B -> C) (f:A -> B) := fun x => g (f x).
Arguments compose [A B C] _ _ _.
Infix "oo" := compose (at level 54, right associativity).

Lemma compose_assoc (A B C D:Type) (h:C->D) (g:B->C) (f:A->B) :
  (h oo g) oo f = h oo g oo f.

Lemma compose_rewr {A B C} (f : B -> C) (g : A -> B) x : f (g x) = (f oo g) x.

Definition id (A:Type) := fun x:A => x.

Lemma id_unit1 : forall A B (f:A->B), f oo id A = f.

Lemma id_unit2 : forall A B (f:A->B), id B oo f = f.

Record bijection (A B:Type) : Type := Bijection {
  bij_f: A -> B;
  bij_g: B -> A;
  bij_fg: forall x, bij_f (bij_g x) = x;
  bij_gf: forall x, bij_g (bij_f x) = x
}.

Lemma bij_f_inj {A} {B} (bij: bijection A B):
     forall x y, bij_f _ _ bij x = bij_f _ _ bij y -> x=y.

Lemma bij_g_inj {A} {B} (bij: bijection A B):
     forall x y, bij_g _ _ bij x = bij_g _ _ bij y -> x=y.

Lemma bij_fg_id: forall {A B} (f: bijection A B),
  (bij_f _ _ f) oo (bij_g _ _ f) = id _.

Lemma bij_gf_id: forall {A B} (f: bijection A B),
  (bij_g _ _ f) oo (bij_f _ _ f) = id _.

Definition bij_compose {A B C:Type} (g: bijection B C) (f: bijection A B):
  bijection A C.

Infix "ooo" := bij_compose (at level 54, right associativity).

Definition bij_refl (A: Type): bijection A A.

Definition bij_sym {A B} (f: bijection A B): bijection B A.

Definition func_bij {A1 A2 B1 B2} (f: bijection A1 A2) (g: bijection B1 B2):
  bijection (A1 -> B1) (A2 -> B2).

Definition unit_unit1 (A: Type): bijection A (A * unit).

Definition unit_unit2 (A: Type): bijection A (unit * A).

Definition prod_bij_comm (A B: Type): bijection (A * B) (B * A).

Tactic Notation "inv" hyp(H) := inversion H; clear H; subst.

Ltac detach H :=
  match goal with [ H : (?X -> ?Y) |- _ ] =>
    cut Y; [ clear H; intro H | apply H; clear H ]
  end.

Ltac spec H :=
  match type of H with ?a -> _ =>
    let H1 := fresh in (assert (H1: a); [|generalize (H H1); clear H H1; intro H]) end.

Tactic Notation "disc" := (try discriminate).

Tactic Notation "contr" := (try contradiction).

Tactic Notation "congr" := (try congruence).

Tactic Notation  "icase" constr(v) := (destruct v; disc; contr; auto).

Tactic Notation "omegac" := (elimtype False; omega).

Tactic Notation "copy" hyp(H) := (generalize H; intro). *)



Class EqDec (A : Type) : Type :=

  eq_dec : forall a a' : A, {a = a'} + {a <> a'}.



Instance EqDec_nat : EqDec nat := eq_nat_dec.



Definition upd {A} `{EqDec A} (B : Type) (f : A -> B) (a : A) (b : B) : A -> B :=

  fun a' => if eq_dec a a' then b else f a'.

Arguments upd [A H B] _ _ _ _.



Lemma upd_eq {A} `{EqDec A} : forall B (f : A -> B) a b,

  upd f a b a = b.

Proof with auto.

  intros.

  unfold upd.

  case (eq_dec a a)...

  intro.

  destruct n...

Qed.

Arguments upd_eq [A H B] _ _ _.



Lemma upd_eq' {A} `{EqDec A} : forall B (f : A -> B) a b a',

  a = a' ->

  upd f a b a' = b.

Proof.

  intros. subst a'. apply upd_eq.

Qed.

Arguments upd_eq' [A H B] _ _ _ _ _.



Lemma upd_neq {A} `{EqDec A} : forall B (f : A -> B) a b a',

  a <> a' ->

  upd f a b a' = f a'.

Proof with auto.

  intros.

  unfold upd.

  case (eq_dec a a')...

  intros.

  subst a'.

  destruct H0...

Qed.

Arguments upd_neq [A H B] _ _ _ _ _.



Instance nat_eq_dec: EqDec nat.

Proof.

  repeat intro.

 destruct (lt_eq_lt_dec a a') as [[?|?]| ?]; auto;

  right; intro; subst; eapply lt_irrefl; eauto.

Defined.



Instance EqDec_prod (A: Type) (EA: EqDec A) (B: Type) (EB: EqDec B) : EqDec (A*B).

Proof.

 hnf. decide equality; try apply eq_dec.

Defined.



Instance EqDec_list (A: Type) (EA: EqDec A) : EqDec (list A).

Proof.

 hnf. apply list_eq_dec; intros; apply EA.

Defined.



Instance EqDec_option (A: Type) (EA: EqDec A) : EqDec (option A).

Proof.

  hnf; decide equality.

Defined.

