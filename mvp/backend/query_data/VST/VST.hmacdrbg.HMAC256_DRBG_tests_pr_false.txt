Require Import Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.Strings.String.
Require Import Coq.Strings.Ascii.
Require Import sha.functional_prog.
(* sha.functional_prog:
Definition padlen (n: Z) : list Int.int :=
    let p := n/4+3 
    in let q := (p+15)/16*16 - p   
      in zeros q ++ [Int.repr (n * 8 / Int.modulus); Int.repr (n * 8)].

Fixpoint generate_and_pad' (n: list byte) len : list Int.int :=
  match n with
  | nil => bytes_to_Int (Byte.repr 128) Byte.zero Byte.zero Byte.zero :: padlen len
  | [h1]=> bytes_to_Int h1 (Byte.repr 128) Byte.zero Byte.zero :: padlen (len+1)
  | [h1; h2] => bytes_to_Int h1 h2 (Byte.repr 128) Byte.zero :: padlen (len+2)
  | [h1; h2; h3] => bytes_to_Int h1 h2 h3 (Byte.repr 128) :: padlen (len+3)
  | h1::h2::h3::h4::t => bytes_to_Int h1 h2 h3 h4 :: generate_and_pad' t (len+4)
  end.

Definition generate_and_pad_alt (n: list byte) : list Int.int :=
   generate_and_pad' n 0.

Definition Wnext (msg : list int) : int :=
 match msg with
 | x1::x2::x3::x4::x5::x6::x7::x8::x9::x10::x11::x12::x13::x14::x15::x16::_ =>
   (Int.add (Int.add (sigma_1 x2) x7) (Int.add (sigma_0 x15) x16))
 | _ => Int.zero  
 end.

Fixpoint generate_word (msg : list int) (n : nat) {struct n}: list int :=
  match n with
  |O   => msg
  |S n' => generate_word (Wnext msg :: msg) n'
  end.
Arguments generate_word msg n : simpl never.
Global Opaque generate_word. 
Fixpoint rnd_64 (x: registers) (k w : list int) : registers :=
  match k, w with
  | k1::k', w1::w' => rnd_64 (rnd_function x k1 w1) k' w'
  | _ , _ => x
  end.
Arguments rnd_64  x k w : simpl never.  

Definition process_block (r: registers) (block: list int) : registers :=
       (map2 Int.add r (rnd_64 r K256 (rev(generate_word block 48)))).

Fixpoint grab_and_process_block (n: nat) (r: registers) (firstrev msg: list int) : registers * list int :=
 match n, msg with
  | O, _ => (process_block r firstrev, msg)
  | S n', m1::msg' => grab_and_process_block n' r (m1::firstrev) msg'
  | _, nil => (r,nil) 
 end.

Definition SHA_256' (str : list byte) : list byte :=
    intlist_to_bytelist (process_msg init_registers (generate_and_pad_alt str)).

Fixpoint bytelist_eq (al bl: list byte) : bool :=
 match al, bl with
 | nil, nil => true
 | a::al', b::bl' => Byte.eq a b && bytelist_eq al' bl'
 | _, _ => false
  end.

Definition hexdigit(a: Z) : Z :=
 if Z.leb 48 a && Z.ltb a 58 then Z.sub a 48
 else if Z.leb 65 a && Z.ltb a 71 then Z.sub a 55
 else if Z.leb 97 a && Z.ltb a 103 then Z.sub a 87
 else 0%Z.

Fixpoint hexstring_to_bytelist (s: String.string): list byte  :=
 match s with
 | String.String a (String.String b r) => Byte.repr ((hexdigit (Z.of_N (Ascii.N_of_ascii a)) * 16
                                         + hexdigit (Z.of_N (Ascii.N_of_ascii b))))
                                          :: hexstring_to_bytelist r
 | _ => nil
 end.

Section CHECKS.
Import String.
Definition check m h :=
  bytelist_eq (SHA_256' (str_to_bytes m)) (hexstring_to_bytelist h) = true.

Goal  check   "The quick brown fox jumps over the lazy dog"
  "d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592".

Goal check "The Secure Hash Algorithm is a family of cryptographic hash functions published by the National Institute of Standards and Technology (NIST) as a U.S. Federal Information Processing Standard (FIPS)"
End CHECKS.

Require Import sha.common_lemmas.
Require Import VST.msl.Coqlib2.

Local Open Scope nat.

Lemma length_rnd_64:
  forall r k w, length r = 8 -> length (rnd_64 r k w) = 8.

Lemma length_rnd_64_inv:
  forall r k w, length (rnd_64 r k w) = 8 -> length r = 8.

Lemma length_process_block:
  forall r b, length r = 8 -> length (process_block r b) = 8.

Lemma length_map2_add_rnd_64:
 forall regs w,
  length regs = 8 ->
  length (map2 Int.add regs (rnd_64 regs K256 w)) = 8.

Lemma grab_and_process_block_length:
 forall n r firstr msg r' m',
    length r = 8 ->
    length msg >= n ->
    grab_and_process_block n r firstr msg  = (r',m') ->
    length r' = 8.

Lemma length_process_msg:
  forall b, length (process_msg init_registers b) = 8.

Lemma process_msg_eq2:
 forall regs hashed b,
  length b = 16 ->
 process_msg regs (b++hashed) =
  process_msg (process_block regs (rev b)) hashed.

Lemma rnd_64_S:
  forall regs i b k w,
    nth_error K256 i = Some k ->
    nth_error b i = Some w ->
    rnd_64 regs K256 (firstn (S i) b) =
    rnd_function (rnd_64 regs K256 (firstn i b)) k w.

Lemma Zlength_zeros:
    forall n, (n>=0)%Z -> Zlength (zeros n) = n.

Lemma length_zeros: forall n:Z, length (zeros n) = Z.to_nat n.

Hint Rewrite length_zeros : norm.

Local Open Scope Z.

Lemma Zlength_padlen:
 forall n,
  n>=0 ->
  Zlength (padlen n) = roundup (n/4+3) 16 - n/4 - 1.

Lemma zeros_app:
  forall n m, (n >= 0 -> m >=0 -> zeros n ++ zeros m = zeros (n+m))%Z.

Lemma zeros_Zsucc:
 forall n, n >= 0 -> zeros (Z.succ n) = Int.repr 0 :: zeros n.

Lemma intlist_to_bytelist_zeros:
  forall n:Z, intlist_to_bytelist (zeros n) = map Byte.repr (map Int.unsigned (zeros (4*n)%Z)).

Definition padlen' (n: Z) : list Int.int :=
     let q := (n+8)/64*16 + 15 - (n+8)/4   
      in zeros q ++ [Int.repr (n * 8 / Int.modulus); Int.repr (n * 8)].

Lemma padlen_eq: padlen=padlen'.

Lemma length_generate_and_pad'':
  forall (l: list byte) (k: Z),
     k >= 0 ->
     k + Zlength (generate_and_pad' l (k*4)) = roundup (((k*4+Zlength l)+12)/4) 16.

Lemma length_generate_and_pad':
  forall (l: list byte),
     Zlength (generate_and_pad' l 0) = roundup ((Zlength l +12)/4) 16.

Lemma roundup_ge:
 forall a b,  b > 0 -> roundup a b >= a.

Lemma generate_and_pad'_eq:
 generate_and_pad = generate_and_pad_alt.

Lemma roundup_divide:
 forall a b, b > 0 ->  (b | roundup a b).

Lemma length_generate_and_pad:
  forall (l: list byte),
     Zlength (generate_and_pad l) = roundup ((Zlength l +12)/4) 16.

Transparent generate_word.

Lemma generate_word_lemma1:
  forall b n, length b = 16%nat ->
   firstn 16 (rev (generate_word (rev b) n)) = b.

Lemma length_generate_word: forall b n,
  length (generate_word b n) = (length b + n)%nat.

Lemma nth_generate_word_S:
  forall k i n b',
   nth (i+k) (generate_word b' (n+k)) = nth i (generate_word b' n).

Lemma generate_word_small:
  forall i b n,
           length b = 16%nat ->
           (i < length b)%nat ->
           nth i (rev (generate_word (rev b) n)) = nth i b.

Lemma generate_word_plus:
  forall msg a b, (16 <= length msg)%nat ->
         generate_word msg (a+b) = generate_word (generate_word msg a) b.

Definition nthB (b: list int) (i: nat) (n: Z) :=
  nth (Z.to_nat (Z.of_nat i - 16 + n)) (rev (generate_word (rev b) 48)) Int.zero.

Lemma nth_rev_generate_word:
 forall i b,
   length b = 16%nat ->
   (16 <= i < 64)%nat ->
    nth i (rev (generate_word (rev b) 48)) Int.zero =

Opaque generate_word.

Definition c48 := 48%nat. Opaque c48.

Lemma generate_word_W:
 forall block n
 (LB: length block = 16%nat),
  0 <= n < 64 ->
  nthi (rev (generate_word (rev block) 48)) n =
  W (nthi block) n.

Lemma process_block_hash_block:
 forall regs block,
   length regs = 8%nat ->
   length block = 16%nat ->
   process_block regs (rev block) = hash_block regs block.

Lemma process_msg_hash_blocks:
  forall regs blocks,
    (16 | Zlength blocks) ->
    length regs = 8%nat ->
    process_msg regs blocks = hash_blocks regs blocks.

Lemma SHA_256'_eq:  SHA_256' = SHA_256. *)
Require Import hmacdrbg.HMAC256_DRBG_functional_prog.
(* hmacdrbg.HMAC256_DRBG_functional_prog:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import sha.HMAC256_functional_prog.
Require Import hmacdrbg.DRBG_functions.
Require Import hmacdrbg.HMAC_DRBG_algorithms.

Definition HMAC256_DRBG_update := HMAC_DRBG_update HMAC256.

Definition HMAC256_DRBG_instantiate_algorithm := HMAC_DRBG_instantiate_algorithm HMAC256.

Definition HMAC256_DRBG_instantiate_function := DRBG_instantiate_function HMAC256_DRBG_instantiate_algorithm.

Definition HMAC256_DRBG_generate_algorithm := HMAC_DRBG_generate_algorithm HMAC256.

Definition HMAC256_DRBG_generate_function := DRBG_generate_function HMAC256_DRBG_generate_algorithm.

Definition HMAC256_DRBG_reseed_algorithm := HMAC_DRBG_reseed_algorithm HMAC256.

Definition HMAC256_DRBG_reseed_function := DRBG_reseed_function HMAC256_DRBG_reseed_algorithm. *)
Require Import hmacdrbg.entropy.
(* hmacdrbg.entropy:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.Logic.FunctionalExtensionality.
Require Import VST.floyd.functional_base.

Require Import sha.ByteBitRelations. 

Module Type ABSTRACT_ENTROPY.

Parameter stream: Type.

Inductive error_code: Type :=
| catastrophic_error
| generic_error
.

Inductive result X: Type: Type :=
| success: X -> stream -> @result X
| error : error_code -> stream -> @result X
.

Arguments success {X} _ _.
Arguments error {X} _ _.

Parameter get_bytes: nat -> stream -> result (list byte).
Parameter get_bits: nat -> stream -> result (list bool).

End ABSTRACT_ENTROPY.

Module OPTIONAL_ENTROPY <: ABSTRACT_ENTROPY.

Definition stream: Type := nat -> option bool.

Inductive error_code: Type :=
| catastrophic_error
| generic_error
.

Inductive result X: Type: Type :=
| success: X -> stream -> @result X
| error : error_code -> stream -> @result X
.

Arguments success {X} _ _.
Arguments error {X} _ _.

Fixpoint get_bits (k: nat) (s: stream): result (list bool) :=
  match k with
    | O => success [] s
    | S k' => match get_bits k' s with
                | error e s' => error  e s'
                | success b s' =>
                  match s' O with
                    | None => error catastrophic_error (fun i => match Nat.compare i k' with

Definition get_bytes (k: nat) (s: stream): result (list byte) :=
  match get_bits (8 * k)%nat s with
    | success bits s' => success (bitsToBytes bits) s'
    | error e s' => error e s'
  end
.

End OPTIONAL_ENTROPY.

Module ENTROPY := OPTIONAL_ENTROPY.

Definition get_entropy (security_strength min_length max_length: Z) (prediction_resistance: bool) s :=
           ENTROPY.get_bytes (Z.to_nat min_length) s. *)
Require Import hmacdrbg.DRBG_functions.
(* hmacdrbg.DRBG_functions:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import hmacdrbg.entropy.
Require Import VST.floyd.functional_base.

Definition DRBG_working_state: Type := (list byte * list byte * Z)%type. 
Definition DRBG_state_handle: Type := (DRBG_working_state * Z * bool)%type. 

Definition DRBG_instantiate_function
            (instantiate_algorithm: list byte -> list byte -> list byte -> Z -> DRBG_working_state)
            (min_entropy_length max_entropy_length: Z) (provided_nonce: option (list byte))
            (highest_supported_security_strength: Z) (max_personalization_string_length: Z)
            (prediction_resistance_supported: bool) (entropy_stream: ENTROPY.stream)
            (requested_instantiation_security_strength: Z) (prediction_resistance_flag: bool)
            (personalization_string: list byte): ENTROPY.result DRBG_state_handle :=
  if requested_instantiation_security_strength >? highest_supported_security_strength then ENTROPY.error ENTROPY.generic_error entropy_stream
  else match prediction_resistance_flag, prediction_resistance_supported with
         | true, false => ENTROPY.error ENTROPY.generic_error entropy_stream
         | _,_ =>
           if (Zlength personalization_string) >? max_personalization_string_length then ENTROPY.error ENTROPY.generic_error entropy_stream
           else
             let security_strength := if requested_instantiation_security_strength <=? 14 then Some 14
                                      else if requested_instantiation_security_strength <=? 16 then Some 16
                                      else if requested_instantiation_security_strength <=? 24 then Some 24
                                      else if requested_instantiation_security_strength <=? 32 then Some 32
                                      else None in
             match security_strength with
               | None => ENTROPY.error ENTROPY.generic_error entropy_stream
               | Some security_strength =>
               match get_entropy security_strength min_entropy_length max_entropy_length prediction_resistance_flag entropy_stream with
                 | ENTROPY.error e s' => ENTROPY.error ENTROPY.catastrophic_error s'
                 | ENTROPY.success entropy_input entropy_stream =>
                   let nonce_result := match provided_nonce with
                                         | Some n => ENTROPY.success n entropy_stream
                                         | None => get_entropy (security_strength/2) (min_entropy_length/2) (max_entropy_length/2)
                                                               prediction_resistance_flag entropy_stream
                                       end in
                   match nonce_result with
                     | ENTROPY.error e s' => ENTROPY.error ENTROPY.catastrophic_error s'
                     | ENTROPY.success nonce entropy_stream =>
                       let initial_working_state := instantiate_algorithm entropy_input nonce personalization_string security_strength in
                       ENTROPY.success (initial_working_state, security_strength, prediction_resistance_flag) entropy_stream
                   end
               end
             end
       end.

Definition DRBG_reseed_function (reseed_algorithm: DRBG_working_state -> list byte -> list byte -> DRBG_working_state)
            (min_entropy_length max_entropy_length: Z) (max_additional_input_length: Z)
            (entropy_stream: ENTROPY.stream) (state_handle: DRBG_state_handle)
            (prediction_resistance_request: bool) (additional_input: list byte): ENTROPY.result DRBG_state_handle :=
  match state_handle with (working_state, security_strength, prediction_resistance_flag) =>
  if prediction_resistance_request && (negb prediction_resistance_flag) then ENTROPY.error ENTROPY.generic_error entropy_stream
  else
    if Zlength additional_input >? max_additional_input_length then ENTROPY.error ENTROPY.generic_error entropy_stream
    else
      match get_entropy security_strength min_entropy_length max_entropy_length prediction_resistance_request entropy_stream with
        | ENTROPY.error _ s => ENTROPY.error ENTROPY.catastrophic_error s
        | ENTROPY.success entropy_input entropy_stream =>
          let new_working_state := reseed_algorithm working_state entropy_input additional_input in
          ENTROPY.success (new_working_state, security_strength, prediction_resistance_flag) entropy_stream
      end
  end.

Inductive DRBG_generate_algorithm_result :=
| generate_algorithm_reseed_required: DRBG_generate_algorithm_result
| generate_algorithm_success: list byte -> DRBG_working_state -> DRBG_generate_algorithm_result.

Fixpoint DRBG_generate_function_helper (generate_algorithm: DRBG_working_state -> Z -> list byte -> DRBG_generate_algorithm_result)
          (reseed_function: ENTROPY.stream -> DRBG_state_handle -> bool -> list byte -> ENTROPY.result DRBG_state_handle)
          (entropy_stream: ENTROPY.stream) (state_handle: DRBG_state_handle) (requested_number_of_bytes: Z)
          (prediction_resistance_request: bool) (additional_input: list byte) (should_reseed: bool) (count: nat): ENTROPY.result (list byte * DRBG_working_state) :=
  let result := if should_reseed then
                        match reseed_function entropy_stream state_handle prediction_resistance_request additional_input with
                          | ENTROPY.success x entropy_stream => ENTROPY.success (x, []) entropy_stream
                          | ENTROPY.error e entropy_stream => ENTROPY.error e entropy_stream
                        end
                      else ENTROPY.success (state_handle, additional_input) entropy_stream in
  match result with
    | ENTROPY.error e s => ENTROPY.error e s
    | ENTROPY.success (state_handle, additional_input) entropy_stream =>
      match state_handle with (working_state, security_strength, prediction_resistance_flag) =>
        match generate_algorithm working_state requested_number_of_bytes additional_input with
          | generate_algorithm_reseed_required =>
            match count with
              | O => ENTROPY.error ENTROPY.generic_error entropy_stream 
              | S count' => DRBG_generate_function_helper generate_algorithm reseed_function
                                entropy_stream state_handle requested_number_of_bytes
                                prediction_resistance_request additional_input true count'
            end
          | generate_algorithm_success x y => ENTROPY.success (x, y) entropy_stream
        end
      end
    end.

Definition DRBG_generate_function (generate_algorithm: Z -> DRBG_working_state -> Z -> list byte -> DRBG_generate_algorithm_result)
             (reseed_function: ENTROPY.stream -> DRBG_state_handle -> bool -> list byte -> ENTROPY.result DRBG_state_handle)
             (reseed_interval: Z) (max_number_of_bytes_per_request: Z) (max_additional_input_length: Z)
             (entropy_stream: ENTROPY.stream) (state_handle: DRBG_state_handle)
             (requested_number_of_bytes requested_security_strength: Z)
             (prediction_resistance_request: bool) (additional_input: list byte): ENTROPY.result (list byte * DRBG_state_handle) :=
  match state_handle with (working_state, security_strength, prediction_resistance_flag) =>
    if requested_number_of_bytes >? max_number_of_bytes_per_request then ENTROPY.error ENTROPY.generic_error entropy_stream
    else
      if requested_security_strength >? security_strength then ENTROPY.error ENTROPY.generic_error entropy_stream
      else
        if (Zlength additional_input) >? max_additional_input_length then ENTROPY.error ENTROPY.generic_error entropy_stream
        else
          if prediction_resistance_request && (negb prediction_resistance_flag) then ENTROPY.error ENTROPY.generic_error entropy_stream
          else
            match DRBG_generate_function_helper (generate_algorithm reseed_interval) reseed_function
                       entropy_stream state_handle requested_number_of_bytes prediction_resistance_request
                       additional_input prediction_resistance_request 1%nat with
              | ENTROPY.error e s => ENTROPY.error e s
              | ENTROPY.success (output, new_working_state) entropy_stream =>
                  ENTROPY.success (output, (new_working_state, security_strength, prediction_resistance_flag)) entropy_stream
            end
  end. *)

Require Import sha.ByteBitRelations.
(* sha.ByteBitRelations:
Require Import compcert.lib.Coqlib.
Require Import List. Import ListNotations.
Require Import Coq.ZArith.BinInt. 
Require Import Coq.ZArith.Zcomplements. 
Require Import compcert.lib.Integers.          
Require Import Coq.Numbers.Natural.Peano.NPeano.

Require Import Coq.Strings.Ascii.
Require Import Coq.Program.Tactics.
Require Import sha.XorCorrespondence. 
Require Import sha.Bruteforce.
Require Import sha.general_lemmas.
Require Import sha.hmac_pure_lemmas.

Definition Blist := list bool.
Open Scope Z_scope.

Inductive InBlocks {A : Type} (n : nat) : list A -> Prop :=
  | InBlocks_nil : InBlocks n []
  | InBlocks_block : forall (front back full : list A),
                   length front = n ->
                   full = front ++ back ->
                   InBlocks n back ->
                   InBlocks n full.

Lemma InBlocks_len : forall {A : Type} (l : list A) (n : nat),
                       PeanoNat.Nat.divide (n) (length l) -> InBlocks n l.

Inductive bytes_bits_lists : Blist -> list byte -> Prop :=
  | eq_empty : bytes_bits_lists nil nil
  | eq_cons : forall (bits : Blist) (bytes : list byte)
                     (b0 b1 b2 b3 b4 b5 b6 b7 : bool) (b : byte),
                bytes_bits_lists bits bytes ->
                convertByteBits [b0; b1; b2; b3; b4; b5; b6; b7] b ->
                bytes_bits_lists (b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: bits)
                                 (b :: bytes).

Definition div_mod (num : Z) (denom : Z) : bool * Z :=
  (Z.gtb (num / denom) 0, num mod denom).

Definition byteToBits (byte : byte) : Blist :=
  let (b7, rem7) := div_mod (Byte.unsigned byte) 128 in
  let (b6, rem6) := div_mod rem7 64 in
  let (b5, rem5) := div_mod rem6 32 in
  let (b4, rem4) := div_mod rem5 16 in
  let (b3, rem3) := div_mod rem4 8 in
  let (b2, rem2) := div_mod rem3 4 in
  let (b1, rem1) := div_mod rem2 2 in
  let (b0, rem0) := div_mod rem1 1 in
  [b0; b1; b2; b3; b4; b5; b6; b7].

Fixpoint bytesToBits (bytes : list byte) : Blist :=
  match bytes with
    | [] => []
    | byte :: xs => byteToBits byte ++ bytesToBits xs
  end.

Definition bitsToByte (bits : Blist) : byte :=
  Byte.repr 
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: nil =>
      (1 * (asZ b0) + 2 * (asZ b1) + 4 * (asZ b2) + 8 * (asZ b3)
      + 16 * (asZ b4) + 32 * (asZ b5) + 64 * (asZ b6) + 128 * (asZ b7))
    | _ => -1                  
  end.

Fixpoint bitsToBytes (bits : Blist) : list byte :=
  match bits with
    | b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs =>
      bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] :: bitsToBytes xs
    | _ => []
  end.

Lemma byteToBits_length bt: length (byteToBits bt) = 8%nat.

Lemma bytes_bits_length : forall (bits : Blist) (bytes : list byte),
  bytes_bits_lists bits bytes -> length bits = (length bytes * 8)%nat.

Lemma bytesToBits_app : forall (l1 l2 : list byte),
                          bytesToBits (l1 ++ l2) = bytesToBits l1 ++ bytesToBits l2.

Lemma bytesToBits_len : forall (l : list byte),
                          length (bytesToBits l) = (length l * 8)%nat.

Theorem byte_bit_byte_id : forall (b : byte),
                                bitsToByte (byteToBits b) = b.

Theorem bits_byte_bits_id : forall (b0 b1 b2 b3 b4 b5 b6 b7 : bool),
                              [b0; b1; b2; b3; b4; b5; b6; b7] =
                              byteToBits (bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7]).

Theorem bytes_bits_bytes_id : forall (bytes : list byte),
                                bitsToBytes (bytesToBits bytes) = bytes.

Theorem bytes_bits_def_eq : forall (bytes : list byte),
                              bytes_bits_lists (bytesToBits bytes) bytes.

Theorem bytes_bits_comp_ind : forall (bits : Blist) (bytes : list byte),
                               bits = bytesToBits bytes ->
                               bytes_bits_lists bits bytes.

Theorem bytes_bits_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bytes = bitsToBytes bits.

Theorem bits_bytes_ind_comp : forall (bits : Blist) (bytes : list byte),
                                 bytes_bits_lists bits bytes ->
                                 bits = bytesToBits bytes.

Lemma bitsToBytes_app : forall (l m : Blist),
                          InBlocks 8 l ->
                          bitsToBytes (l ++ m) = bitsToBytes l ++ bitsToBytes m.

Lemma bitsToBytes_len_gen : forall (l : Blist) (n : nat),
                          length l = (n * 8)%nat ->
                          length (bitsToBytes l) = n.

Lemma bitsToBytes_len : forall (l : Blist),
                          length l = 512%nat ->
                          Zlength (bitsToBytes l) = 64%Z.

Lemma bits_bytes_bits_id : forall (l : Blist),
                             InBlocks 8 l ->
                             bytesToBits (bitsToBytes l) = l.

Lemma bytes_bits_lists_append:
  forall (l1 : Blist) (l2 : list byte) (m1 : Blist) (m2 : list byte),
    bytes_bits_lists l1 l2
    -> bytes_bits_lists m1 m2
    -> bytes_bits_lists (l1 ++ m1) (l2 ++ m2).

Lemma bytesToBits_nil_inv l: nil = bytesToBits l -> l = nil.

Lemma bytesToBits_cons b l:
      bytesToBits (b::l) = byteToBits b ++ bytesToBits l.

Lemma byteToBits_injective: forall a b,
      byteToBits a = byteToBits b ->
      a = b.

Lemma bytesToBits_injective: forall b1 b2, bytesToBits b1 = bytesToBits b2 ->
       b1=b2.

Lemma bitsToBytes_injective8 b1 b2 (B: bitsToBytes b1 = bitsToBytes b2)
       (L1: PeanoNat.Nat.divide 8 (length b1))

Lemma bitsToByte_cons: forall bits h t, (h::t) = bitsToBytes bits ->
      exists b0, exists b1, exists b2, exists b3,
      exists b4, exists b5, exists b6, exists b7, exists xs,
      bits = b0 :: b1 :: b2 :: b3 :: b4 :: b5 :: b6 :: b7 :: xs /\
      h = bitsToByte [b0; b1; b2; b3; b4; b5; b6; b7] /\
      t = bitsToBytes xs.

Definition intsToBits (l : list Int.int) : list bool :=
  bytesToBits (intlist_to_bytelist l).

Definition bitsToInts (l : Blist) : list Int.int :=
  bytelist_to_intlist (bitsToBytes l). *)

Definition stream_dummy (result: string) (n: nat) : option bool :=
  let hex := bytesToBits (hexstring_to_Zlist result) in
  if nth_ok n hex false then Some (nth n hex false)
  else None.

Definition get_nonce_dummy (result: string) (_: unit) := hexstring_to_Zlist result.

Definition noop_reseed_function (s: ENTROPY.stream) (x: DRBG_state_handle) (_: bool) (_: list Z) := ENTROPY.success x s.

Fixpoint DRBG_generate_check (state_handle: DRBG_state_handle) (internal_states: list (string * string * string)) (returned_bits: string) :=
  let test_HMAC256_DRBG_generate_function := HMAC256_DRBG_generate_function noop_reseed_function 1024 128 128 in
  match internal_states with
    | [] => True
    | (key, v, additional_input)::[] =>
      let key := hexstring_to_Zlist key in
      let value := hexstring_to_Zlist v in
      let additional_input := hexstring_to_Zlist additional_input in
      let returned_bits := hexstring_to_Zlist returned_bits in
      match test_HMAC256_DRBG_generate_function (stream_dummy "") state_handle 128 256 false additional_input with
        | ENTROPY.success (returned_bits', ((value', key', _), _, _)) _ => listZ_eq value value' = true /\ listZ_eq key key' = true /\ listZ_eq returned_bits returned_bits' = true
        | ENTROPY.error _ _ => False
      end
    | (key, v, additional_input)::tl =>
      let key := hexstring_to_Zlist key in
      let value := hexstring_to_Zlist v in
      let additional_input := hexstring_to_Zlist additional_input in
      match test_HMAC256_DRBG_generate_function (stream_dummy "") state_handle 128 256 false additional_input with
        | ENTROPY.success (_, ((value', key', x), y, z)) _ => listZ_eq value value' = true /\ listZ_eq key key' = true /\ DRBG_generate_check ((value', key', x), y, z) tl returned_bits
        | ENTROPY.error _ _ => False
      end
  end.

Definition DRBG_reseed_check (state_handle: DRBG_state_handle) (entropy_input_reseed additional_input_reseed key_reseed value_reseed: string) (internal_states: list (string * string * string)) (returned_bits: string) :=
  let key := hexstring_to_Zlist key_reseed in
  let value := hexstring_to_Zlist value_reseed in
  match HMAC256_DRBG_reseed_function 32 32 256 (stream_dummy entropy_input_reseed) state_handle false (hexstring_to_Zlist additional_input_reseed) with
    | ENTROPY.success ((value', key', x), y, z) _ => listZ_eq value value' = true /\ listZ_eq key key' = true /\ DRBG_generate_check ((value', key', x), y, z) internal_states returned_bits
    | _ => False
  end.

Definition DRBG_check (entropy_input nonce key value personalization_string: string) (entropy_input_reseed additional_input_reseed key_reseed value_reseed: string) (internal_states: list (string * string * string)) (returned_bits: string) :=
  let key := hexstring_to_Zlist key in
  let value := hexstring_to_Zlist value in
  let personalization_string := hexstring_to_Zlist personalization_string in
  match HMAC256_DRBG_instantiate_function 32 32 (get_nonce_dummy nonce) 256 256 false (stream_dummy entropy_input) 256 false personalization_string with
    | ENTROPY.success ((value', key', x), y, z) _ => listZ_eq value value' = true /\ listZ_eq key key' = true /\ DRBG_reseed_check ((value', key', x), y, z) entropy_input_reseed additional_input_reseed key_reseed value_reseed internal_states returned_bits
    | _ => False
  end.

Lemma test0: DRBG_check
               "06032cd5eed33f39265f49ecb142c511da9aff2af71203bffaf34a9ca5bd9c0d"
               "0e66f71edc43e42a45ad3c6fc6cdc4df"
               "17dc11c2389f5eeb9d0f6a5148a1ea83ee8a828f4f140ac78272a0da435fa121"
               "81e0d8830ed2d16f9b288a1cb289c5fab3f3c5c28131be7cafedcc7734604d34"
               ""
               "01920a4e669ed3a85ae8a33b35a74ad7fb2a6bb4cf395ce00334a9c9a5a5d552"
               ""
               "ca43e73325de43c41d7e0a7a3163fb04061b09fcee4c7b8884e969e3bdfdff9a"
               "c246fa97570ba2b9d9e5b453fe4632366f146fbd8491146563eb463c9eafe50c"
               [
                 ("8be4c7f9f249d5af2c6345a8f07af14be1d7adc2b9892286ffe37760d8aa5a1b"%string, "df67d0816d6a8f3b73ba7638ea113bef0e33a1da451272ef1472211fb31c1cd6"%string, ""%string);
                 ("5ed31bc06cc4f3a97f7f34929b0558b0c34de1f4bd1cef456a8364140e2d9f41"%string, "80524881711e89a61e6fe7169581e50fb9ad642f3dff48fba5773352fa04cec3"%string, ""%string)
               ]
               "76fc79fe9b50beccc991a11b5635783a83536add03c157fb30645e611c2898bb2b1bc215000209208cd506cb28da2a51bdb03826aaf2bd2335d576d519160842e7158ad0949d1a9ec3e66ea1b1a064b005de914eac2e9d4f2d72a8616a80225422918250ff66a41bd2f864a6a38cc5b6499dc43f7f2bd09e1e0f8f5885935124".
  vm_compute. repeat (split;auto). Qed.

Lemma test_with_additional_input0: DRBG_check
               "05ac9fc4c62a02e3f90840da5616218c6de5743d66b8e0fbf833759c5928b53d"
               "2b89a17904922ed8f017a63044848545"
               "8d3006bd33b7d8b935a8484b786850f107b731a7efc51521848b875c2214d154"
               "eaa29892ee1e46198ea68c07588ac12641fc901e484eda321c2f26a9ff328e3d"
               ""
               "2791126b8b52ee1fd9392a0a13e0083bed4186dc649b739607ac70ec8dcecf9b"
               "43bac13bae715092cf7eb280a2e10a962faf7233c41412f69bc74a35a584e54c"
               "3138df070c49f48b080004df669f386676b4cb92b40de4d021b2a9e4451e5013"
               "25d3b766cd9f8ad5c45efd7fa01cc08dbce8d0d3792ec2b59bfead7bce39ed01"
               [
                 ("cac850b111de755bb8a5ed1ebc052ed53ab1ff1b9d0fab2946a3728c7e9f43e4"%string, "06624fa590e1d63397b13a0e69081274434f793fdfc1e6298a7373834024da46"%string, "3f2fed4b68d506ecefa21f3f5bb907beb0f17dbc30f6ffbba5e5861408c53a1e"%string);
                 ("b15ae269570790a8c6a81c5be7aef33f645abb161d218761ff8739cb7997eed8"%string, "92971e96fc46608d4343821491990915cdb957ae983ab6cdab84fd094bce1380"%string, "529030df50f410985fde068df82b935ec23d839cb4b269414c0ede6cffea5b68"%string)
               ]
               "02ddff5173da2fcffa10215b030d660d61179e61ecc22609b1151a75f1cbcbb4363c3a89299b4b63aca5e581e73c860491010aa35de3337cc6c09ebec8c91a6287586f3a74d9694b462d2720ea2e11bbd02af33adefb4a16e6b370fa0effd57d607547bdcfbb7831f54de7073ad2a7da987a0016a82fa958779a168674b56524".
  vm_compute. repeat (split;auto). Qed.

Lemma test_with_additional_input_and_personalization0: DRBG_check
               "cdb0d9117cc6dbc9ef9dcb06a97579841d72dc18b2d46a1cb61e314012bdf416"
               "d0c0d01d156016d0eb6b7e9c7c3c8da8"
               "108a7674f3348216c91f5745dd87a919f552fc44373b84ad4b3b843a26b574cb"
               "6c02577c505aed360be7b1cecb61068d8765be1391bacb10f4180d91bd3915db"
               "6f0fb9eab3f9ea7ab0a719bfa879bf0aaed683307fda0c6d73ce018b6e34faaa"
               "8ec6f7d5a8e2e88f43986f70b86e050d07c84b931bcf18e601c5a3eee3064c82"
               "1ab4ca9014fa98a55938316de8ba5a68c629b0741bdd058c4d70c91cda5099b3"
               "e57f901d4bff2909f09467003096edfdb46c89af6bd82e904d11b6753d645c90"
               "21a645aeca821899e7e733a10f64565deee5ced3cd5c0356b66c76dc8a906e69"
               [
                 ("648f92d385c3fbf61526deef48ca5ca4dfe4646d82fe8e73bc1705824e181dc9"%string, "490c0b7786c80f16ad5ee1cc0efd29618968dce14cccebecec8964ea8a41b439"%string, "16e2d0721b58d839a122852abd3bf2c942a31c84d82fca74211871880d7162ff"%string);
                 ("db4853ca51700d43c5b6d63eb6cd20ea2dbe3dff512f2dc9531b5b3d9120121c"%string, "47390036d5cb308cf9592fdfe95bf19b8ed1a3db88ed8c3b2b2d77540dfb5470"%string, "53686f042a7b087d5d2eca0d2a96de131f275ed7151189f7ca52deaa78b79fb2"%string)
               ]
               "dda04a2ca7b8147af1548f5d086591ca4fd951a345ce52b3cd49d47e84aa31a183e31fbc42a1ff1d95afec7143c8008c97bc2a9c091df0a763848391f68cb4a366ad89857ac725a53b303ddea767be8dc5f605b1b95f6d24c9f06be65a973a089320b3cc42569dcfd4b92b62a993785b0301b3fc452445656fce22664827b88f".
  vm_compute. repeat (split;auto). Qed.