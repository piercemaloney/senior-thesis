
Require Import List Arith Omega Setoid String.
Require Import Coq.Logic.FunctionalExtensionality.

Require Import resourcemaps.
(* resourcemaps:
Require Import List Arith Omega Setoid String.
Require Import Coq.Logic.FunctionalExtensionality.

Fixpoint nth {A} (l : list A) i :=
  match l with
  | nil => None
  | x :: l =>
    match i with
    | O => Some x
    | S i => nth l i
    end
  end.

Fixpoint nth_upd {A} (l : list A) i x :=
  match l with
  | nil => nil
  | y :: l =>
    match i with
    | O => x :: l
    | S i => y :: nth_upd l i x
    end
  end.

Ltac ifeq :=
    match goal with
      [ H : context [ eq_nat_dec ?x ?x ] |- _ ] => destruct (eq_nat_dec x x) as [_|]; [|congruence]
    | [ |- context [ eq_nat_dec ?x ?x ] ] => destruct (eq_nat_dec x x) as [_|]; [|congruence]
    | [ H : context [ eq_nat_dec ?x ?y ] |- _ ] => destruct (eq_nat_dec x y)
    | [ |- context [ eq_nat_dec ?x ?y ] ] => destruct (eq_nat_dec x y)
    end.

Lemma nth_nth_upd {A} (l : list A) i x y j :
  nth l i = Some x ->
  nth (nth_upd l i y) j = if eq_nat_dec i j then Some y else nth l j.

Lemma nth_upd_app_1 {A} (l1 l2 : list A) i x y :
  nth l1 i = Some x ->
  nth_upd l1 i y ++ l2 = nth_upd (l1 ++ l2) i y.

Lemma nth_app_1 {A} (l1 l2 : list A) i x :
  nth l1 i = Some x ->
  nth (l1 ++ l2) i = Some x.

Lemma nth_snoc {A} i (l : list A) x :
  i <> List.length l ->

Lemma nth_snoc_len {A} (l : list A) x :
  nth (l ++ x :: nil) (List.length l) = Some x.

Lemma nth_len {A} (l : list A) :
  nth l (List.length l) = None.

Lemma length_nth_upd {A} (l : list A) i x : List.length (nth_upd l i x) = List.length l.

Lemma nth_nth_upd' {A} i j l (x : A) :
  j <> i ->
  nth (nth_upd l i x) j = nth l j.

Variable lock : Set.
Definition val := (nat + lock)%type.
Definition map := nat -> option val.
Variable interp_lock : lock -> (map -> Prop).

Definition emptymap : map := fun _ => None.

Definition eqmap (m m' : map) := forall x, m x = m' x.

Lemma eqmap_eq m m' : eqmap m m' -> m = m'.

Definition upd {A} (m : nat -> A) x e :=
  fun y => if eq_nat_dec x y then e else m y.

Definition updatemap (m : map) (x e : nat) : option map :=
  match m x with Some _ => Some (upd m x (Some (inl e))) | None => None end.

Definition assertmap (m : map) (x : nat) : Prop :=
  match m x with Some (inl (S _)) => True | _ => False end.

Definition joincell (a b : option val) : option (option val) :=
  match a, b with
    | None, None => Some None
    | Some a, None | None, Some a => Some (Some a)
    | Some _, Some _ => None
  end.

Definition join (m n o : map) : Prop := forall x, joincell (m x) (n x) = Some (o x).
Definition joins (m n : map) : Prop := exists o, join m n o.

Lemma join_eqmap_compat_l {m m' n o}  : eqmap m m' -> join m n o -> join m' n o.

Lemma join_eqmap_compat_r {m n n' o}  : eqmap n n' -> join m n o -> join m n' o.

Lemma join_eqmap {m n o o'}  : join m n o -> join m n o' -> eqmap o o'.

Lemma join_eqmap_r {m n n' o}  : join m n o -> join m n' o -> eqmap n n'.

Lemma join_eqmap_l {m m' n o}  : join m n o -> join m' n o -> eqmap m m'.

Definition joincell_split {a b ab c abc} :
  joincell a b = Some ab -> joincell ab c = Some abc ->
  { bc | joincell b c = Some bc /\ joincell a bc = Some abc }.

Lemma join_split a b ab c abc : join a b ab -> join ab c abc ->
  exists bc, join b c bc /\ join a bc abc.

Lemma join_emptymap_l a : join emptymap a a.

Lemma join_emptymap_r a : join a emptymap a.

Lemma joins_emptymap_l a : joins emptymap a.

Lemma joins_emptymap_r a : joins a emptymap.

Lemma join_comm a b c : join a b c -> join b a c.

Lemma joins_sym a b : joins a b -> joins b a.

Hint Resolve
     join_emptymap_l
     join_emptymap_r
     joins_emptymap_l
     joins_emptymap_r
     join_comm
     joins_sym.

Lemma joins_pointwise m n : joins m n <-> (forall x, joincell (m x) (n x) <> None).

Lemma join_joins_distrib a b ab : join a b ab -> forall c, joins ab c -> joins a c /\ joins b c.

Lemma join_joins_distrib' a b ab : join a b ab -> forall c, joins a c -> joins b c -> joins ab c.

Definition empty (m : map) : Prop := forall x, m x = None.

Lemma join_empty m n : empty n -> join m n m.

Definition nonempty (m : map) : Prop := exists x, m x <> None.

Lemma eqmap_joins m1 m2 : joins m1 m2 -> eqmap m1 m2 -> empty m1 /\ empty m2.

Definition pred := map -> Prop.

Definition sat (m : map) (P : pred) : Prop := P m.

Infix " |= " := sat (at level 40).

Definition emp : pred := fun m => forall n, m n = None.

Definition TT : pred := fun m => True.

Definition FF : pred := fun m => False.

Definition imp (P Q : pred) : Prop := forall m, m |= P -> m |= Q.

Definition sepcon (P Q : pred) : pred :=
  fun m => exists m1 m2, join m1 m2 m /\ P m1 /\ Q m2.

Infix "**" := sepcon (at level 30).

Lemma imp_sepcon P Q F : imp P Q -> imp (P ** F) (Q ** F).

Definition pequiv (P Q : pred) := forall m, P m <-> Q m.

Infix " == " := pequiv (at level 50, no associativity).

Lemma pequiv_sym P Q : P == Q -> Q == P.

Lemma pequiv_imp P Q : P == Q -> imp P Q.

Lemma sepcon_comm P Q : P ** Q == Q ** P.

Lemma sepcon_assoc P Q R : P ** (Q ** R) == (P ** Q) ** R.

Lemma sepcon_emp P : emp ** P == P.

Definition subheap m o := exists n, join m n o.

Definition precise (R : pred) : Prop := forall o m1 m2,
    m1 |= R -> m2 |= R ->
    subheap m1 o -> subheap m2 o -> eqmap m1 m2.

Lemma precise_FF : precise FF.

Definition mapsto x v : pred := fun m => forall n, m n = if eq_nat_dec x n then Some v else None.

Definition mapsto_ x : pred := fun m => forall n, if eq_nat_dec x n then m n <> None else m n = None.

Lemma mapsto_mapsto_ x n m : mapsto x n m -> mapsto_ x m.

Lemma precise_mapsto x n : precise (mapsto x n).

Lemma precise_mapsto_ x : precise (mapsto_ x).

Lemma precise_join R m1 m2 : precise R -> m1 |= R -> m2 |= R -> joins m1 m2 -> empty m1 /\ empty m2.

Definition selfjoins {A} (maps : A -> map) :=
  forall i j, i <> j -> joins (maps i) (maps j).

Definition sameperms (m n : map) := forall x, m x = None <-> n x = None.

Lemma sameperms_refl m : sameperms m m.

Lemma sameperms_sym m n : sameperms m n -> sameperms n m.

Lemma sameperms_trans m n o : sameperms m n -> sameperms n o -> sameperms m o.

Hint Resolve sameperms_refl sameperms_sym sameperms_trans.

Lemma sameperms_updatemap m x e m' : updatemap m x e = Some m' -> sameperms m m'.

Lemma sameperms_joins m m' n : sameperms m m' -> joins m n -> joins m' n.

Hint Resolve sameperms_updatemap.

Lemma selfjoins_sameperms_compat {A} maps1 maps2 : (forall i:A, sameperms (maps1 i) (maps2 i)) -> selfjoins maps1 -> selfjoins maps2.

Definition swapped {A} (m1 m2 : A -> map) i j a b c d :=
  m1 i = a /\
  m1 j = b /\
  m2 i = c /\
  m2 j = d /\
  forall k, k <> i -> k <> j -> m1 k = m2 k.

Lemma selfjoins_swapped {A} {m1 m2 : A -> map} (Adec:forall x y:A,{x=y}+{x<>y})
      i j (J:selfjoins m1) e a b c d :
  swapped m1 m2 i j a b c d ->
  join a b e ->
  join c d e ->
  selfjoins m2.

Tactic Notation "rewr" :=
  match goal with
  | H : ?f = _ |- context [?f] => rewrite H
  | H : ?f _ = ?f _ |- _ => try (injection H; repeat intros ->)
  end.

Tactic Notation "rewr" constr(e) :=
  match goal with E : e = _ |- _ => rewrite E | E : _ = e |- _ => rewrite <-E end.

Tactic Notation "rewr" constr(e) "in" "*" :=
  match goal with E : e = _ |- _ => rewrite E in * | E : _ = e |- _ => rewrite <-E in * end.

Tactic Notation "rewr" constr(e) "in" hyp(H) :=
  match goal with E : e = _ |- _ => rewrite E in H | E : _ = e |- _ => rewrite <-E in H end. *)

Definition interp_lock := resourcemaps.interp_lock.

Definition islock (l : nat) (R : map -> Prop) (m : map) :=
  exists lock, m l = Some (inr lock) /\ interp_lock lock = R.

Lemma islock_inj : forall v R1 R2 m, islock v R1 m -> islock v R2 m -> R1 = R2.
  intros v R1 R2 m [lock1 [E1 H1]] [lock2 [E2 H2]].
  congruence.
Qed.

Variable C' : Set.

Variable corestep : C' -> map -> C' -> map -> Prop.

Variable corestep_fun : forall c m c1 m1 c2 m2,
    corestep c m c1 m1 ->
    corestep c m c2 m2 ->
    c1 = c2 /\ m1 = m2.

Variable corestep_sameperms : forall c m c' m', corestep c m c' m' -> sameperms m m'.

Variable corestep_samelocks : forall c m c' m' l lock,
    corestep c m c' m' -> (m l = Some (inr lock) <-> m' l = Some (inr lock)).

Variable cancellative : forall m1 m1' m2 m3, join m1 m2 m3 -> join m1' m2 m3 -> m1 = m1'.

Inductive C : Set :=
  | acquire : nat -> C -> C
  | release : nat -> C -> C
  | normal : C' -> C.

Variable jointo : forall {A} (maps : A -> map) (m : map), Prop.

Axiom selfjoins_jointo : forall {A} (maps : A -> map),
    selfjoins maps -> exists m, jointo maps m.

Axiom jointo_selfjoins : forall {A} (maps : A -> map) m,
    jointo maps m -> selfjoins maps.

Axiom jointo_det : forall {A} (maps : A -> map) m1 m2,
    jointo maps m1 -> jointo maps m2 -> m1 = m2.

Axiom jointo_Some : forall {A} (maps : A -> map) m a addr v,
    jointo maps m -> maps a addr = Some v -> m addr = Some v.

Axiom jointo_Some_inv : forall {A} (maps : A -> map) m addr v,
    jointo maps m -> m addr = Some v -> exists a, maps a addr = Some v.

Lemma join_Some m1 m2 m addr v :
  join m1 m2 m ->
  m1 addr = Some v ->
  m addr = Some v.
Proof.
  intros J E; specialize (J addr).
  rewrite E in J.
  destruct (m2 addr); simpl in *; auto; congruence.
Qed.

Axiom jointo_swapped :
  forall {A} {m1 m2 : A -> map} (Adec:forall x y:A,{x=y}+{x<>y})
    i j Phi e a b a' b',
    swapped m1 m2 i j a b a' b' ->
    join a b e ->
    join a' b' e ->
    jointo m1 Phi ->
    jointo m2 Phi.

Definition Z := unit.

Record ext : Type := mkext {
    ext_type : Type;
    Pre : ext_type -> Z -> map -> Prop;
    Post : ext_type -> Z -> map -> Prop
  }.

Definition after_external : C -> option C :=
  fun c =>
    match c with
    | acquire _ k => Some k
    | release _ k => Some k
    | _ => None
    end.

Variable Hrel : nat -> map -> map -> Prop.
Axiom join_Hrel1 : forall m1 m2 m3 n, join m1 m2 m3 -> Hrel n m3 m1.
Axiom join_Hrel2 : forall m1 m2 m3 n, join m1 m2 m3 -> Hrel n m1 m3.

Inductive safeN_ (at_ext : C -> option ext) : nat -> Z -> C -> map -> Prop :=
    safeN_0 : forall (z : Z) (c : C) (m : map), safeN_ at_ext 0 z c m
  | safeN_step : forall (n : nat) (z : Z) (c c' : C') (m m' : map),
      corestep c m c' m' ->
      safeN_ at_ext n z (normal c') m' ->
      safeN_ at_ext (S n) z (normal c) m
  | safeN_external : forall (n : nat) (z : Z) (c : C) (m : map) (e : ext) (x : ext_type e),
      at_ext c = Some e ->
      Pre e x z m ->
      (forall (m' : map) (z' : Z) (n' : nat),
          n' <= n ->
          Hrel n' m m' ->
          Post e x z' m' ->
          exists c' : C,
            after_external c = Some c' /\
            safeN_ at_ext n' z' c' m') ->
      safeN_ at_ext (S n) z c m.

Lemma safeN_S at_ext n z c m : safeN_ at_ext (S n) z c m -> safeN_ at_ext n z c m.
Proof.
  revert z c m; induction n; intros z c m.
  - intros _. constructor.
  - intros H; inversion H; subst.
    + econstructor; eauto.
    + econstructor; eauto.
Qed.

Lemma strong_nat_ind (P : nat -> Prop) (IH : forall n, (forall i, i < n -> P i) -> P n) n : P n.
Proof.
  apply IH; induction n; intros i li; inversion li; eauto.
Qed.

Definition acquire_spec l : ext :=
  mkext
    (nat * (map -> Prop))
    (fun x 立 m =>
       match x with
       | (lx, Rx) =>
         lx = l /\
         islock l Rx m
       end)
    (fun x 立 m =>
       exists m1 m2,
         join m1 m2 m /\
         match x with
         | (lx, Rx) =>
           islock lx Rx m1 /\
           Rx m2
         end).

Definition release_spec l : ext :=
  mkext
    (nat * (map -> Prop))
    (fun x 立 m =>
       exists m1 m2,
         join m1 m2 m /\
         match x with
         | (lx, Rx) =>
           lx = l /\
           islock l Rx m1 /\
           precise Rx /\
           Rx m2
         end)
    (fun x 立 m =>
       match x with
       | (lock, Rx) =>
         islock lock Rx m
       end).

Definition at_ext : C -> option ext :=
  fun c =>
    match c with
    | acquire l _ => Some (acquire_spec l)
    | release l _ => Some (release_spec l)
    | _ => None
    end.

Definition schedule := list nat.

Definition threads := list (map * C).

Definition lockpool := nat -> option (option map).

Definition config := (schedule * threads * lockpool)%type.

Reserved Notation " c1 ===> c2 " (at level 50).

Definition there_is_a_lock_at (m : map) (l : nat) :=
  exists lock,
    m l = Some (inr lock).

Definition map_matches_lock_at (m : map) (l : nat) (mlock : map) :=
  exists lock,
    m l = Some (inr lock) /\
    interp_lock lock mlock.

Inductive machine : config -> config -> Prop :=
  | machine_outofschedule thd pool :
      (nil, thd, pool) ===>
      (nil, thd, pool)
  | machine_scheduleoutofbound i sch thd pool :
      nth thd i = None ->
      (i :: sch, thd, pool) ===>
      (sch, thd, pool)
  | machine_core i sch thd c c' m m' pool :
      corestep c m c' m' ->
      nth thd i = Some (m, normal c) ->
      (i :: sch, thd, pool) ===>
      (i :: sch, nth_upd thd i (m', normal c'), pool)
  | machine_release i sch thd m mlock m' l p pool :
      pool l <> None ->
      nth thd i = Some (m, release l p) ->
      
      map_matches_lock_at m l mlock ->
      join m' mlock m ->
      (i :: sch, thd, pool) ===>
      (sch, nth_upd thd i (m', p), upd pool l (Some (Some mlock)))
  | machine_acquire_failure i sch thd m l p pool :
      nth thd i = Some (m, acquire l p) ->
      pool l = Some (None)  ->
      (i :: sch, thd, pool) ===>
      (sch, thd, pool)
  | machine_acquire_success i sch thd m mlock m' l p pool :
      nth thd i = Some (m, acquire l p) ->
      pool l = Some (Some mlock)  ->
      join m mlock m' ->
      (i :: sch, thd, pool) ===>
      (i :: sch, nth_upd thd i (m', p), upd pool l (Some None))
where
" c1 ===> c2 " := (machine c1 c2).

Hint Constructors machine.

Definition reindex (thd:threads) pool : _ -> map :=
  fun x : nat + nat =>
           match x with
           | inl n =>
             match nth thd n with
             | Some (m, _) => m
             | None => emptymap
             end
           | inr n =>
             match pool n with
             | Some (Some m) => m
             | Some None => emptymap
             | None => emptymap
             end
           end.

Definition lockpool_matches_map (pool : lockpool) (Phi : map) :=
  forall l,
    match pool l with
    | Some (Some mlock) => map_matches_lock_at Phi l mlock
    | Some None => there_is_a_lock_at Phi l
    | None => True
    end.

Definition map_matches_lockpool (pool : lockpool) (Phi : map) :=
  forall l lock,
    Phi l = Some (inr lock) ->
    pool l <> None.

Definition invariant n (x : config) :=
  match x with (_, thd, pool) =>
    exists Phi,
      jointo (reindex thd pool) Phi /\
      lockpool_matches_map pool Phi /\
      map_matches_lockpool pool Phi /\
      (forall i oracle m p,
          nth thd i = Some (m, p) ->
          safeN_ at_ext n oracle p m)
  end.

Theorem progress n x : invariant (S n) x -> exists y, x ===> y.
Proof.
  destruct x as (([|i sch], thd), pool). eexists; constructor.
  intros (Phi & J & PM & MP & Safe).
  destruct (nth thd i) as [[m p]|] eqn:E; [ | eauto].
  destruct p as [v c | v c | c].

  - 

    pose proof (Safe i tt _ _ E) as Sa.
    inversion Sa as [ | | n0 z c0 m0 ex x atex PRE POST]; subst.
    inversion atex; subst.
    destruct x as [vx Rx].
    simpl in PRE.
    destruct PRE as (-> & isl).
    specialize (MP v).
    destruct isl as [lock [Ev At]].
    assert (EPhiv : Phi v = Some (inr lock)). {
      eapply jointo_Some with (a := inl i); eauto.
      simpl. rewrite E; auto.
    }
    specialize (MP lock EPhiv).
    destruct (pool v) as [ [ mlock | ] | ] eqn:Epoolv; [ | | congruence ].

    + 
      apply jointo_selfjoins in J.
      destruct (J (inl i) (inr v)) as [m' J']. congruence.
      simpl in J'. rewrite E in J'. rewr (pool v) in J'.
      eexists.
      eapply machine_acquire_success.
      now apply E.
      now apply Epoolv.
      now apply J'.

    + 
      eexists.
      eapply machine_acquire_failure. now apply E.
      assumption.

  - 

    pose proof (Safe i tt _ _ E) as Sa.
    inversion Sa as [ | | n0 z c0 m0 ex x atex PRE POST]; subst.
    inversion atex; subst.
    destruct x as [vx Rx].
    simpl in PRE.
    destruct PRE as (m1 & m2 & J12 & -> & isl & Rm2).

    specialize (MP v).
    destruct isl as [lock [Ev At]].
    pose proof (J12 v) as J12v.
    rewr (m1 v) in J12v. destruct (m2 v); inversion J12v.
    assert (EPhiv : Phi v = Some (inr lock)). {
      eapply jointo_Some with (a := inl i); eauto.
      simpl. rewrite E. auto.
    }
    simpl.
    specialize (MP lock EPhiv).

    eexists.
    match goal with |- _ ===> ?y => pose y end.
    eapply machine_release; [ apply MP | apply E | .. ].
    + unfold map_matches_lock_at.
      exists lock. split; auto.
      subst Rx.
      apply Rm2.
    + apply J12.

  - 
    pose proof (Safe i tt _ _ E) as Sa.
    inversion Sa; subst.
    + eexists; eapply machine_core; eassumption.
    + discriminate.

Qed.

Theorem preservation n x y : x ===> y -> invariant (S n) x -> invariant n y.
Proof.
  destruct x as (([|i sch], thd), pool);
    intros xy; inversion xy; subst; intros (Phi & J & PM & MP & Sa); simpl fst in *; simpl snd in *.
  - 
    hnf; intuition; eauto.
    exists Phi; intuition.
    eapply safeN_S.
    eapply Sa; eauto.

  - 
    hnf; intuition; eauto.
    exists Phi; intuition.
    eapply safeN_S.
    eapply Sa; eauto.

  - 
    assert (SJ : selfjoins (reindex (nth_upd thd i (m', normal c')) pool)). {
      apply jointo_selfjoins in J.
      eapply selfjoins_sameperms_compat; [..|apply J]; intros [k|]; simpl; eauto.
      erewrite nth_nth_upd; [|eassumption].
      ifeq; subst; auto.
      rewr (nth thd k).
      eapply corestep_sameperms; eassumption.
    }
    apply selfjoins_jointo in SJ.
    destruct SJ as [Phi' J'].
    exists Phi'.
    repeat split; auto.
    + intros l. specialize (PM l).
      destruct (pool l) as [[mlock|]|].
      * destruct PM as [lock [E asd]].
        exists lock; intuition.
        {
          destruct (jointo_Some_inv _ _ _ _ J E) as [ [x | x] Ex ]; simpl in Ex.
          - destruct (nth thd x) as [[m0 c0] | ] eqn:Emx.
            + destruct (eq_nat_dec i x).
              * subst x. assert (m0 = m) by congruence; subst m0.
                eapply (jointo_Some _ _ (inl i)). eassumption.
                simpl; erewrite nth_nth_upd; eauto.
                ifeq; eauto.
                rewrite <-corestep_samelocks; eauto.
              * eapply (jointo_Some _ _ (inl x)). eassumption. simpl.
                erewrite nth_nth_upd. ifeq. tauto. rewrite Emx. auto. eauto.
            + inversion Ex.
          - eapply (jointo_Some _ _ (inr x)). eassumption. simpl. auto.
        }
      * destruct PM as [lock E].
        exists lock; intuition.
        {
          destruct (jointo_Some_inv _ _ _ _ J E) as [ [x | x] Ex ]; simpl in Ex.
          - destruct (nth thd x) as [[m0 c0] | ] eqn:Emx.
            + destruct (eq_nat_dec i x).
              * subst x. assert (m0 = m) by congruence; subst m0.
                eapply (jointo_Some _ _ (inl i)). eassumption.
                simpl; erewrite nth_nth_upd; eauto.
                ifeq; eauto.
                rewrite <-corestep_samelocks; eauto.
              * eapply (jointo_Some _ _ (inl x)). eassumption. simpl.
                erewrite nth_nth_upd. ifeq. tauto. rewrite Emx. auto. eauto.
            + inversion Ex.
          - eapply (jointo_Some _ _ (inr x)). eassumption. simpl. auto.
        }
      * auto.
    + intros l lock AT. apply (MP _ lock).
      destruct (jointo_Some_inv _ _ _ _ J' AT) as [ [ x | x ] Ex ]; simpl in Ex.
      * erewrite nth_nth_upd in Ex; [ | eassumption ].
        {
          destruct (nth thd x) as [[m0 c0] | ] eqn:Emx.
          - destruct (eq_nat_dec i x).
            + subst x. assert (m0 = m) by congruence; subst m0.
              eapply (jointo_Some _ _ (inl i)). eassumption.
              simpl. rewr (nth thd i).
              revert Ex.
              match goal with |- ?P -> ?Q => cut (Q <-> P); [ intuition | ] end.
              eapply corestep_samelocks. eauto.
            + eapply (jointo_Some _ _ (inl x)). eassumption. simpl.
              rewr (nth thd x) in *. auto.
          - destruct (eq_nat_dec i x).
            + congruence.
            + inversion Ex.
        }
      * eapply (jointo_Some _ _ (inr x)). eassumption. simpl. auto.
    + intros j oracle; specialize (Sa j oracle).
      erewrite nth_nth_upd; [|eassumption].
      ifeq; subst; auto.
      * specialize (Sa _ _ H5).
        intros. rewr.
        intros <- <- .
        inversion Sa; subst. 2:inversion H1.
        destruct (corestep_fun _ _ _ _ _ _ H4 H2) as [<- <-].
        assumption.
      * intros; apply safeN_S; eauto.

  - 
    exists Phi. intuition.
    + 
      assert (Empl : match pool l with None => False | Some None => True | Some (Some ml) => empty ml end). {
        destruct (pool l) as [[ml|]|] eqn:E; auto.
        cut (empty ml /\ empty mlock);[intuition|].
        destruct H6 as [lock [Eml SAT]].

        assert (PR : precise (interp_lock lock)). {
          specialize (Sa i tt _ _ H5).
          inversion Sa as [ | | n0 z c m0 ex x ae PRE POST]; subst.
          assert (A:Hrel n m m') by (eapply join_Hrel1; eauto).
          inversion ae; subst.
          destruct x as [vx Rx].
          destruct PRE as (m1 & m2 & J12 & -> & isl & PreciseRx & Rm2).
          destruct isl as [lock' [Em1l <-]].
          assert (m l = Some (inr lock')). {
            specialize (J12 l).
            rewrite Em1l in *.
            simpl in J12.
            destruct (m2 l); congruence.
          }
          replace lock' with lock in * by congruence.
          assumption.
        }

        apply precise_join with (interp_lock lock); eauto.
        - specialize (PM l); rewrite E in PM; auto.
          hnf in PM.
          destruct PM as [lock' [El SAT']].
          assert (lock = lock'). {
            assert (Phi l = Some (inr lock)). {
              eapply jointo_Some with (a := inl i); eauto; simpl.
              rewr (nth thd i). auto.
            }
            congruence.
          }
          subst lock'.
          apply SAT'.
        - assert (D:inl i <> inr l) by congruence.
          apply jointo_selfjoins in J.
          specialize (J _ _ D); simpl in J.
          rewr (nth thd i) in J.
          rewr (pool l) in J.
          pose proof (join_joins_distrib m' mlock m H7 ml); intuition eauto.
      }
      eapply (jointo_swapped natnateqdec (inl i) (inr l) Phi); [ .. | eapply J].
      * unfold swapped, reindex, upd; repeat split.
        {
          intros [|] a b; [ | ifeq ].
          - erewrite nth_nth_upd;[|eassumption].
            ifeq; congruence.
          - subst. tauto.
          - destruct (pool n); reflexivity.
        }
      * apply join_empty; simpl.
        destruct (pool l) as [[ml|]|]; unfold empty; auto.
      * erewrite nth_nth_upd;[|eassumption].
        ifeq; ifeq.
        rewr; eauto.
    + intros k; unfold upd; ifeq; subst; auto.
      * hnf.
        destruct H6 as [lock [El SAT]].
        exists lock; intuition.
        eapply jointo_Some with (a := inl i); eauto; simpl.
        rewr (nth thd i). auto.
      * specialize (PM k); auto.
    + intros k lock Ek. unfold upd; ifeq.
      * congruence.
      * apply (MP k lock Ek).
    + erewrite nth_nth_upd in H. 2:eassumption.
      ifeq; [ | apply safeN_S; eapply Sa; eauto ].
      subst i0.
      specialize (Sa i tt _ _ H5). injection H as <- <-.
      inversion Sa as [ | | n0 z c m0 ex x ae PRE POST]; subst.
      assert (A:Hrel n m m') by (eapply join_Hrel1; eauto).
      specialize (POST m' oracle n (le_n _) A).
      destruct POST as [c' [E Sa']].
      * inversion ae; subst.
        destruct x as [vx Rx].
        simpl in PRE |- *.
        destruct PRE as (m1 & m2 & J12 & E & isl & PreciseRx & Rm2).
        intuition.
        subst.
        
        assert (m2 = mlock). {
          apply eqmap_eq.
          eapply PreciseRx; auto.
          - destruct H6 as [lock [Eml SAT]].
            destruct isl as [lock' [Em1l' <-]].
            assert (m l = Some (inr lock')). {
              eapply join_Some; eauto.
            }
            replace lock' with lock in * by congruence.
            auto.
          - exists m1. apply join_comm. apply J12.
          - exists m'. apply join_comm. assumption.
        }
        subst m2.
        assert (m' = m1) by (eapply cancellative; eauto).
        congruence.
      * inversion ae; subst.
        inversion E; subst.
        apply Sa'.

  - 
    exists Phi; intuition.
    apply safeN_S.
    eapply Sa; eauto.

  - 
    exists Phi; intuition.
    + eapply (jointo_swapped natnateqdec (inl i) (inr l) Phi); [ .. | apply J].
      * unfold swapped, reindex, upd; repeat split.
        intros [|] a b; try (ifeq; (congruence || subst; tauto)).
        erewrite nth_nth_upd;[|eassumption].
        ifeq; congruence.
      * rewr. rewr. eauto.
      * rewr. ifeq.
        erewrite nth_nth_upd;[|eassumption].
        ifeq. auto.
    + intros k; unfold upd; ifeq; subst; auto.
      * specialize (PM k). rewr (pool k) in PM. destruct PM as [lock []]; exists lock. assumption.
      * apply (PM k).
    + intros k lock Ek. unfold upd; ifeq.
      * subst k. specialize (PM l). congruence.
      * apply (MP k lock Ek).
    + erewrite nth_nth_upd in H. 2:eassumption.
      ifeq; [ | now apply safeN_S; eapply Sa; eauto ].
      subst i0.
      injection H as <- <-.
      specialize (Sa _ tt _ _ H4).
      inversion Sa as [ | | n0 z c m0 ex x ae PRE POST]; subst.
      assert (A:Hrel n m m') by (eapply join_Hrel2; eauto).
      specialize (POST m' oracle n (le_n _) A).
      destruct POST as [c' [E Sa']].
      * inversion ae; subst.
        destruct x as [vx Rx].
        simpl in PRE |- *.
        destruct PRE as [-> isl].
        exists m, mlock; intuition.
        destruct isl as [lock [Eml <-]].
        specialize (PM l). rewr (pool l) in PM.
        destruct PM as [lock' [E' SAT]].
        assert (Phi l = Some (inr lock)). {
          eapply jointo_Some with (a := inl i); eauto; simpl.
          rewr (nth thd i). auto.
        }
        congruence.
      * inversion ae; subst.
        inversion E; subst.
        apply Sa'.
Qed.

Inductive csafe : nat -> config -> Prop :=
| csafe_0 sch thd pool : csafe 0 (sch, thd, pool)
| csafe_halted n thd pool : csafe n (nil, thd, pool)
| csafe_core n sch thd pool thd' pool' :
    machine (sch, thd, pool) (sch, thd', pool') ->
    csafe n (sch, thd', pool') ->
    csafe (S n) (sch, thd, pool)
| csafe_sch n i sch thd pool thd' pool' :
    machine (i :: sch, thd, pool) (sch, thd', pool') ->
    (forall sch', csafe n (sch', thd', pool')) ->
    csafe (S n) (i :: sch, thd, pool).

Lemma safety_invariant n state :
  invariant n state -> csafe n state.
Proof.
  assert (forall n s s' t p, invariant n (s, t, p) -> invariant n (s', t, p))
    by (clear; intros n s s' t p (Phi & J & PM & MP & Safe); exists Phi; intuition).
  revert state; induction n; intros ((sch, thd), pool) Inv.
  now constructor.
  destruct (progress _ _ Inv) as (x, step).
  assert (pre : forall y, (sch, thd, pool) ===> y -> invariant n y)
    by (intros; eapply preservation; eauto).
  inversion Inv as (Phi & J & PM & MP & Safe).
  inversion step; subst.
  - constructor.
  - eapply csafe_sch; [ now eapply step | ]; eauto.
  - eapply csafe_core; eauto.
  - eapply csafe_sch; [ now eapply step | ]; eauto.
  - eapply csafe_sch; [ now eapply step | ]; eauto.
  - eapply csafe_core; eauto.
Qed.
