Require Import language.

Require Import msl.msl_direct.
(* msl.msl_direct:
Require Export VST.msl.Extensionality.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.sepalg.
Require Export VST.msl.predicates_sa.
Require Export VST.msl.corable_direct.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.corec.
Require Export VST.msl.eq_dec. *)

Require Import msl.env.
(* msl.env:
Require Import VST.msl.base.
Require Import VST.msl.boolean_alg.
Require Import VST.msl.sepalg.
Require Import VST.msl.functors.
Require Import VST.msl.sepalg_functors.
Require Import VST.msl.sepalg_generators.
Require Import VST.msl.shares.
Require Import VST.msl.cross_split.
Require Import VST.msl.psepalg.
Require Import VST.msl.pshares.
Require Import VST.msl.eq_dec.

Require VST.msl.predicates_sa.

Lemma in_app:   
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Definition list_disjoint {A: Type} (l1 l2: list A) : Prop :=   
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Inductive pshareval_join' {A}{JA: Join A}
  : option (pshare * A) ->  option (pshare * A) ->  option (pshare * A) -> Prop :=
  | pshareval_None1: forall x, pshareval_join' None x x
  | pshareval_None2: forall x, pshareval_join' x None x
  | pshareval_Some: forall x y z,
      join (fst x) (fst y) (fst z) ->
      join (snd x) (snd y) (snd z) ->
      pshareval_join' (Some x) (Some y) (Some z).

Lemma pshareval_join_e{A}{JA: Join A}:  forall a b c, join a b c -> pshareval_join' a b c.

Lemma pshareval_join_i{A}{JA: Join A}: forall a b c, pshareval_join' a b c -> join a b c.

Module Type ENV.

Parameter env: forall (key: Type) (A: Type), Type.

Section ENVSEC.
Context {key: Type}{A: Type}.

Instance JA: Join A := Join_equiv A. 
Parameter env_get: forall (rho: env key A) (id: key), option (pshare * A).
Parameter env_set_sh: forall {KE: EqDec key} (id: key) (v: option (pshare * A)) (rho: env key A), env key A.

Definition env_set  {KE: EqDec key} (id: key) (v: A) (rho: env key A) : env key A :=
     env_set_sh id (Some (pfullshare, v)) rho.

Axiom env_gss: forall {KE: EqDec key}  i a rho, env_get (env_set i a rho) i = Some (pfullshare, a).
Axiom env_gso: forall {KE: EqDec key}  i j a rho, i <> j -> env_get (env_set j a rho) i = env_get rho i.

Axiom env_gss_sh: forall {KE: EqDec key} i v rho,
  env_get (env_set_sh i v rho) i = v.

Axiom env_gso_sh: forall {KE: EqDec key} i j v rho, i <> j ->
   env_get (env_set_sh j v rho) i = env_get rho i.

Definition finite_idfun (f: key -> option (pshare * A)) :=
  exists l, forall a, ~In a l -> f a = None.

Parameter Canc_env: forall {PA: Perm_alg A}{CA: Canc_alg A}, Canc_alg (env key A). Existing Instance Canc_env.
Parameter Disj_env: forall {PA: Perm_alg A}{DA: Disj_alg A}, Disj_alg (env key A).   Existing Instance Disj_env.
Parameter Cross_env : Cross_alg (env key A).  Existing Instance Cross_env.

Import VST.msl.predicates_sa.

Parameter _env_mapsto: forall {KE: EqDec key}  (id: key) (sh: Share.t) (v: A), pred (env key A).

Axiom _env_mapsto_exists: forall {KE: EqDec key}  id sh v, exists rho, _env_mapsto id (pshare_sh sh) v rho.

Axiom _env_get_mapsto: forall {KE: EqDec key}  id v rho,
  (exists sh, env_get rho id = Some (sh,v)) =
  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Axiom _env_get_mapsto': forall {KE: EqDec key}  id (sh: pshare) v rho,
  env_get rho id = Some(pfullshare,v) ->
       (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Axiom _env_mapsto_set: forall {KE: EqDec key} id v,
  _env_mapsto id Share.top v (env_set id v empty_env).

Axiom _env_mapsto_set_sh: forall {KE: EqDec key} id (sh: pshare) v,
  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh, v)) empty_env).

Axiom _env_mapsto_get: forall {KE: EqDec key}  id sh v rho,
  _env_mapsto id sh v rho
   -> exists Pf,
        env_get rho id = Some (exist nonunit sh Pf, v).

Axiom _env_mapsto_get_neq: forall {KE: EqDec key}  (id1 id2: key) (sh: Share.t) (v: A) rho,
  id1 <> id2 -> _env_mapsto id1 sh v rho -> env_get rho id2 = None.

Axiom _env_mapsto_empty_env: forall {KE: EqDec key}  id v sh, ~(_env_mapsto id sh v empty_env).

Axiom _env_mapsto_splittable: forall {KE: EqDec key}  id v (sh sh1 sh2: pshare) rho,
  join sh1 sh2 sh
  -> (_env_mapsto id (pshare_sh sh) v rho
        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho).
End ENVSEC.

End ENV.

Module Env: ENV.

Section ENVSEC.
Context {key: Type}{A: Type}.
Instance JA: Join A := Join_equiv A.

Definition env := fpm key (pshare * A).

Definition env_get (rho: env) (id: key) : option (pshare * A) := lookup_fpm rho id.

Definition env_set_sh {KE: EqDec key} (id: key) (v: option (pshare * A)) (rho: env) : env :=
  insert'_fpm _ id v rho.

Definition env_set {KE: EqDec key} (id: key) (v: A) (rho: env) : env :=
  insert_fpm _ id (pfullshare,v) rho.

Lemma env_gss {KE: EqDec key} : forall i a rho, env_get (env_set i a rho) i = Some (pfullshare, a).

Lemma env_gso {KE: EqDec key}: forall i j a rho, i <> j -> env_get (env_set j a rho) i = env_get rho i.

Lemma env_gss_sh {KE: EqDec key}: forall i v rho, env_get (env_set_sh i v rho) i = v.

Lemma env_gso_sh {KE: EqDec key} : forall i j v rho, i <> j -> env_get (env_set_sh j v rho) i = env_get rho i.

Definition finite_idfun (f: key -> option (pshare * A)) :=
          (exists l, forall a, ~In a l -> f a = None).

Definition mk_env_aux: forall f, finite_idfun f -> finMap f.

Definition mk_env (f: key -> option (pshare * A))  (FIN: finite_idfun f):  env :=
   exist _ _ (mk_env_aux _ FIN).

Lemma env_get_mk_env: forall (f: key -> option (pshare * A)) P, env_get (mk_env f P) = f.

Lemma env_finite: forall rho, finite_idfun (env_get rho).

Lemma env_ext: forall rho1 rho2, env_get rho1 = env_get rho2 -> rho1=rho2.

Lemma env_funct: forall rho1 rho2,
  rho1 = rho2 -> forall id sh1 sh2 v1 v2, env_get rho1 id = Some(sh1, v1)
  -> env_get rho2 id = Some(sh2, v2)
  -> v1 = v2.

Lemma finite_idfun_empty: finite_idfun (fun _ => None).

Definition empty_env : env := mk_env _ finite_idfun_empty.

Lemma env_get_empty: forall id, env_get empty_env id = None.

Instance Join_env: Join env :=
    fun (rho1 rho2 rho3: env) => join (env_get rho1) (env_get rho2) (env_get rho3).

Lemma Join_env_eq: Join_env = Join_fpm (Join_prod _ Join_pshare _ JA).

Import VST.msl.predicates_sa.

Definition _env_mapsto {KE: EqDec key} (id: key) (sh: Share.t) (v: A) : pred env :=
    fun rho => exists p,
   forall id', env_get rho id' = if eq_dec id id' then Some (exist _ sh p,v) else None.

Lemma _env_mapsto_exists{KE: EqDec key}: forall id sh v, exists rho, _env_mapsto id (pshare_sh sh) v rho.

Lemma _env_get_mapsto {KE: EqDec key}:  forall (id: key) (v: A) (rho: env),
  (exists sh, env_get rho id = Some (sh,v)) =
  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Lemma _env_get_mapsto'  {KE: EqDec key}: forall id (sh: pshare) v rho,
  env_get rho id = Some(pfullshare,v) -> (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Lemma _env_mapsto_set{KE: EqDec key}: forall id v,
  _env_mapsto id Share.top v (env_set id v empty_env).

Lemma _env_mapsto_set_sh{KE: EqDec key}: forall id (sh: pshare) v,
  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh,v)) empty_env).

Lemma _env_mapsto_get{KE: EqDec key}: forall id sh v rho,
  _env_mapsto id sh v rho
   -> exists Pf: nonunit sh,
        env_get rho id = Some (exist nonunit sh Pf, v).

Lemma _env_mapsto_empty_env {KE: EqDec key} : forall id v sh,
  ~(_env_mapsto id sh v empty_env).

Lemma _env_mapsto_get_neq {KE: EqDec key} : forall (id1 id2: key) (sh: Share.t) (v: A) rho,

Lemma _env_mapsto_splittable1 {KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> (_env_mapsto id  (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho
  -> _env_mapsto id (pshare_sh sh) v rho.

Lemma _env_mapsto_splittable2{KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> _env_mapsto id (pshare_sh sh) v rho
  -> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2) v)%pred rho.

Lemma _env_mapsto_splittable {KE: EqDec key}: forall id v (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> (_env_mapsto id (pshare_sh sh) v rho
        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2)  v)%pred rho).

End ENVSEC.
End Env.
Export Env.

Module EnvSA.

Existing Instance Join_env.
Existing Instance Perm_env.
Existing Instance Sep_env.
Existing Instance Sing_env.
Existing Instance Canc_env.
Existing Instance Disj_env.
Existing Instance Cross_env.

Lemma empty_env_unit {key: Type}{A: Type}:
    forall rho: env key A, unit_for empty_env rho.

Lemma empty_env_unit' {key: Type}{A: Type}: forall rho: env key A, join empty_env rho rho.
Hint Resolve @empty_env_unit @empty_env_unit'.

Lemma env_join_sub1 {key: Type}{A: Type}:
  forall rho1 rho2: env key A, (forall id x, env_get rho1 id = Some x -> env_get rho2 id = Some x) ->
     join_sub rho1 rho2.

Lemma env_get_join_sub {key: Type}{A: Type}: forall (rho rho': env key A) id sh v,
   join_sub rho rho' -> env_get rho id = Some (sh,v) ->
     exists sh', env_get rho' id = Some (sh', v) /\ join_sub (pshare_sh sh)  (pshare_sh sh').

Lemma env_at_joins {key: Type}{A: Type}{KE: EqDec key}:
  forall rho1 rho2: env key A,
         (forall id, @joins _ (@Join_lower (pshare * A) (Join_prod pshare Join_pshare A (Join_equiv _))) (env_get rho1 id) (env_get rho2 id)) ->
               joins rho1 rho2.

Lemma env_at_join_sub {key: Type}{A: Type}{KE: EqDec key}:
  forall rho1 rho2, (forall id: key, @join_sub _ (@Join_lower (pshare * A) (Join_prod pshare Join_pshare A (Join_equiv _))) (env_get rho1 id) (env_get rho2 id)) -> join_sub rho1 rho2.

Lemma identity_empty_env {key: Type}{A: Type}{KE: EqDec key}:  forall rho: env key A, identity rho <-> rho = empty_env.

End EnvSA.

Module EnvSL.
Import EnvSA.
Import VST.msl.predicates_sa.

Definition env_mapsto: forall {key A}{KE: EqDec key} (id: key) (sh: Share.t) (v: A) , pred (env key A) := @_env_mapsto.
Arguments env_mapsto [key] [A] [KE] _ _ _ _.

Lemma env_mapsto_exists{key A}{KE: EqDec key}: forall id sh (v: A), exists rho, _env_mapsto id (pshare_sh sh) v rho.

Lemma env_get_mapsto {key A}{KE: EqDec key}:  forall (id: key) (v: A) (rho: env _ _),
  (exists sh, env_get rho id = Some (sh,v)) =
  (exp (fun sh => _env_mapsto id sh v) * TT)%pred rho.

Lemma env_get_mapsto'  {key A}{KE: EqDec key}: forall id (sh: pshare) (v: A) rho,
  env_get rho id = Some(pfullshare,v) -> (_env_mapsto id (pshare_sh sh) v * TT)%pred rho.

Lemma env_mapsto_set {key A}{KE: EqDec key}: forall id (v: A),
    env_mapsto id Share.top v (env_set id v empty_env).

Lemma env_mapsto_set_sh{key A}{KE: EqDec key}: forall id (sh: pshare) (v: A),
  _env_mapsto id (pshare_sh sh) v (env_set_sh id (Some (sh,v)) empty_env).

Lemma env_mapsto_get{key A}{KE: EqDec key}: forall id sh (v:A) rho,
  env_mapsto id sh v rho
   -> exists Pf: nonunit sh,
        env_get rho id = Some (exist nonunit sh Pf, v).

Lemma env_mapsto_empty_env {key A}{KE: EqDec key} : forall id (v:A) sh,
  ~(env_mapsto id sh v empty_env).

Lemma env_mapsto_get_neq {key A}{KE: EqDec key} : forall (id1 id2: key) (sh: Share.t) (v: A) rho,

Lemma env_mapsto_splittable {key A}{KE: EqDec key}: forall id (v:A) (sh sh1 sh2: pshare) rho,
  join (proj1_sig sh1) (proj1_sig sh2) (proj1_sig sh)
  -> (_env_mapsto id (pshare_sh sh) v rho
        <-> (_env_mapsto id (pshare_sh sh1) v * _env_mapsto id (pshare_sh sh2)  v)%pred rho).

Lemma env_mapsto_positive{key: Type}{A: Type}{KE: EqDec key}: forall id sh (v: A) rho,
  env_mapsto id sh v rho -> nonidentity sh.

Lemma emp_empty_env {key: Type}{A: Type}:  forall rho: env key A, emp rho <-> rho = empty_env.

Lemma emp_empty_env' {key}{A}: emp (@empty_env key A).
Hint Resolve @emp_empty_env'.

Lemma env_mapsto_cohere{key: Type}{A: Type}{KE: EqDec key}: forall id sh1 (v1: A) sh2 v2,
  (env_mapsto id sh1 v1 * TT) && (env_mapsto id sh2 v2 * TT)
    |-- !!(v1=v2).

Lemma env_mapsto_precise{key: Type}{A: Type}{KE: EqDec key}: forall id sh (v:A), precise (env_mapsto id sh v).

Definition own_var {key: Type}{A: Type}{KE: EqDec key} (sh: pshare) (id: key) : pred (env key A) :=
  exp (env_mapsto id (pshare_sh sh)).

Definition see_var {key: Type}{A: Type}{KE: EqDec key} (id: key) : pred (env key A) :=
  exp (fun sh: pshare => own_var sh id).

Definition own_all {key: Type}{A: Type}{KE: EqDec key} (l: list key) : pred (env key A) :=
   list_sepcon (map (own_var pfullshare) l).

Lemma own_all_nil {key: Type}{A: Type}{KE: EqDec key} : own_all nil = (emp: pred (env key A)).

Opaque env_mapsto.
End EnvSL.

Definition restrict_env' {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho: env key A) (id: key) : option (pshare * A) :=
  if  In_dec eq_dec id ids
                      then env_get rho id
                      else None.

Lemma restrict_env'_finite {key: Type}{A: Type}{KE: EqDec key} : forall ids (rho: env key A), finite_idfun (restrict_env' ids rho).

Definition restrict_env {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho:env key A) : env key A :=
  mk_env _ (restrict_env'_finite ids rho).

Definition restrict_env_comp' {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho: env key A) (id: key) : option (pshare * A) :=
  if  In_dec eq_dec id ids
                      then None
                      else env_get rho id.

Lemma restrict_env_comp'_finite {key: Type}{A: Type}{KE: EqDec key}:
    forall ids (rho: env key A), finite_idfun (restrict_env_comp' ids rho).

Definition restrict_env_comp  {key: Type}{A: Type}{KE: EqDec key} (ids: list key) (rho:env key A) : env key A:=
  mk_env _ (restrict_env_comp'_finite ids rho).

Lemma restrict_env_nil  {key: Type}{A: Type}{KE: EqDec key}:
  forall ge, restrict_env nil ge = (empty_env: env key A).

Lemma restrict_env_app  {key: Type}{A: Type}{KE: EqDec key} :
  forall ids1 ids2 (rho: env key A),  list_disjoint ids1 ids2 ->
    join (restrict_env ids1 rho) (restrict_env ids2 rho) (restrict_env (ids1++ids2) rho).

Lemma restrict_env_comp_join {key: Type}{A: Type}{KE: EqDec key}:
  forall ids (ge: env key A), join (restrict_env ids ge) (restrict_env_comp ids ge) ge.

Lemma restrict_env_rev {key: Type}{A: Type}{KE: EqDec key}:
    forall ids, @restrict_env key A _ (rev ids) = restrict_env ids. *)



Import EnvSA EnvSL.

Opaque env_mapsto.  



Definition stack := env var adr.

Definition heap := env adr adr.



Instance Join_stack : Join stack := Join_equiv _.

Instance Join_heap : Join heap := Join_env.

Definition world := (stack * heap)%type.



Instance Join_world: Join world := Join_prod _ Join_stack _ Join_heap.

Instance Perm_world : Perm_alg world := _.

Instance Sep_world : Perm_alg world := _.

Instance Canc_world : Perm_alg world := _.

Instance Disj_world : Perm_alg world := _.



Fixpoint den_env {key}{A}{KE: EqDec key} (rho: table key A)  : env key A :=

  match rho with

  | (x,v)::xs => env_set x v (den_env xs)

  | nil => empty_env

  end.



Definition den (s: state) : world := (den_env (fst s), den_env (snd s)).



Definition defined (y: var) : pred world :=

   fun w => exists v, env_get (fst w) y = Some v.



Definition subst (x y: var) (P: pred world) : pred world :=

   fun w => P (env_set_sh x (env_get (fst w) y) (fst w), snd w).



Definition mapsto (x: var) (sh: share) (y: var) : pred world :=

 fun w =>

    exists ax, env_get (fst w) x = Some (pfullshare, ax) /\

    exists ay, env_get (fst w) y = Some (pfullshare, ay) /\

    env_mapsto ax sh ay (snd w).



Definition equal (x y: var) : pred world :=

            fun w => env_get (fst w) x = env_get (fst w) y.



Inductive modvars : command -> var -> Prop :=

| mod_assign: forall x y, modvars (Assign x y) x

| mod_load: forall x y, modvars (Load x y) x

| mod_seq1: forall x c1 c2, modvars c1 x -> modvars (Seq c1 c2) x

| mod_seq2: forall x c1 c2, modvars c2 x -> modvars (Seq c1 c2) x.



Definition nonfreevars (P: pred world) (x: var) : Prop :=

  forall stk hp v, P (stk,hp) -> P (env_set x v stk, hp).



Definition subset (S1 S2: var -> Prop) :=

  forall x, S1 x -> S2 x.



