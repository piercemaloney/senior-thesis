Require Export mc_reify.reify.

Import VST.floyd.proofauto.

Require Export mc_reify.bool_funcs.

Require Import mc_reify.set_reif.
(* mc_reify.set_reif:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCore.Lambda.ExprCore.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.

Definition match_reif_option {B: Type} (e: expr typ func) (somef : typ -> expr typ func -> B)
           (nonef : typ -> B) (d : B) :=
match e with
| (App (Inj (inr (Other (fsome t)))) e) => somef t e
| (Inj (inr (Other (fnone t)))) => nonef t
| _ => d
end.

Inductive val_e :=
    Vundef : val_e
  | Vint : int -> val_e
  | Vlong : int64 -> val_e
  | Vfloat : float -> val_e
  | Vsingle : float32 -> val_e
  | Vexpr : expr typ func -> val_e
  | Vunop : Cop.unary_operation -> type ->  val_e -> val_e
  | Vbinop : Cop.binary_operation -> type -> type -> val_e -> val_e -> val_e
  | Veval_cast : type -> type -> val_e -> val_e
  | Vforce_ptr : val_e -> val_e
  | Veval_field : type -> ident -> val_e -> val_e.

Definition Vderef_noload (t: type) (e: val_e) : val_e :=
  match access_mode t with
  | By_reference => e
  | _ => Vundef
  end.

Definition val_e_binarith op ty1 ty2 e1 e2 :=
  match op, ty1, ty2, e1, e2 with
  | Oand, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_land) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_and) e1') e2')
      end
  | Oadd, Tint _ _ _, Tint _ _ _,
    App (Inj (inr (Value fVint))) e1',
    App (Inj (inr (Value fVint))) e2' =>
      match e1', e2' with
      | App (Inj (inr (Intop fint_repr))) e1'',
        App (Inj (inr (Intop fint_repr))) e2'' =>
                appR (Value fVint) (appR (Intop fint_repr) (App (appR (Zop fZ_add) e1'') e2''))
      | _, _ => appR (Value fVint) (App (appR (Intop fint_add) e1') e2')
      end
  | _, _, _, _, _ => App (appR (Eval_f (feval_binop op
                                         ty1 ty2)) e1) e2
  end.

Fixpoint val_e_to_expr (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (appR (Intop fint_repr) (injR (Const (fZ (Int.unsigned i))))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr e)
  | Vbinop op ty1 ty2 e1 e2 => val_e_binarith op ty1 ty2 (val_e_to_expr e1) (val_e_to_expr e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr v)
end.

Definition msubst_var id T2 ty :=
match get_reif id T2 (typrod tyc_type tyval) with
  | App (Inj (inr (Other (fsome t))))
        (App (App (Inj (inr (Data (fpair t1 t2))))
                  (Inj (inr (Const (fCtype ty')))))
             v) =>
    if eqb_type ty ty'
    then Some (Vexpr v)
    else None
  | _ => None
end.

Fixpoint msubst_eval_expr_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option (val_e) :=
  match e with
  | Econst_int i ty => Some (Vint i)
  | Econst_long i ty => Some (Vlong i)
  | Econst_float f ty => Some (Vfloat f)
  | Econst_single f ty => Some (Vsingle f)
  | Etempvar id ty => match get_reif id T1 tyval with
                        | (App (Inj (inr (Other (fsome t)))) v) => Some (Vexpr v)
                        | _ => None
                      end
  | Eaddrof a ty => msubst_eval_lvalue_reif T1 T2 a
  | Eunop op a ty =>  option_map (Vunop op (typeof a)) (msubst_eval_expr_reif T1 T2 a)
  | Ebinop op a1 a2 ty => match (msubst_eval_expr_reif T1 T2 a1), (msubst_eval_expr_reif T1 T2 a2) with
                            | Some v1, Some v2 => Some (Vbinop op (typeof a1) (typeof a2) v1 v2)
                            | _, _ => None
                          end
  | Ecast a ty => option_map (Veval_cast (typeof a) ty) (msubst_eval_expr_reif T1 T2 a)
  | Evar id ty => option_map (Vderef_noload ty) (msubst_var id T2 ty)
  | Ederef a ty => option_map (Vderef_noload ty) (option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a))
  | Efield a i ty => option_map (Vderef_noload ty) (option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a))
  end
with
msubst_eval_lvalue_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (e: Clight.expr) : option val_e :=
  match e with
  | Evar id ty => (msubst_var id T2 ty)
  | Ederef a ty => option_map Vforce_ptr (msubst_eval_expr_reif T1 T2 a)
  | Efield a i ty => option_map (Veval_field (typeof a) i) (msubst_eval_lvalue_reif T1 T2 a)
  | _  => Some Vundef
  end.

Definition rmsubst_eval_expr (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue T1 T2 e
| RRRR => rmsubst_eval_expr T1 T2 e
end.

Fixpoint msubst_efield_denote_reif (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
  match efs with
  | nil => Some (injR (Data (fnil tygfield)))
  | cons (eStructField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx fstruct_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eUnionField i) efs0 => option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx funion_field) (injR (Const (fident i))))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
  | cons (eArraySubsc ei) efs0 =>
      match typeof ei, rmsubst_eval_expr T1 T2 ei with
      | Tint _ _ _,
        App (Inj (inr (Other (fsome _))))
         (App (Inj (inr (Value fVint))) i) =>
          match i with
          | App (Inj (inr (Intop fint_repr))) i' =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) i')))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          | _ =>
                             option_map (App
                                (appR (Data (fcons tygfield))
                                      (appR (Smx farray_subsc) (appR (Intop fint_unsigned) i))))
                                 (msubst_efield_denote_reif T1 T2 efs0)
          end
      | _, _ => None
      end
  end.

Definition rmsubst_efield_denote (T1: ExprCore.expr typ func) (T2: ExprCore.expr typ func) (efs : list efield) :=
match msubst_efield_denote_reif T1 T2 efs with
| Some e => some_reif e (tylist tygfield)
| None => none_reif (tylist tygfield)
end.

Lemma Forall_reverse :
forall A P (l: list A),
Forall P l <->
Forall P (rev l).

Lemma in_fst :
forall T T2 (p : T) (v: T2) l,
In (p, v) l -> In p (map fst l).

Lemma elt_eq : forall T l p (v:T) v0 ls,
(p, v0) :: l = rev (PTree.elements (PTree.set p v ls)) ->

Definition tempD' := (fun Q i v => `(eq v) (eval_id i) :: Q).
Definition localD' := (fun Q i tv => `(eq (snd tv)) (eval_var i (fst tv)) :: Q).
Definition LocalD_app (T1: PTree.t val) (T2: PTree.t (type * val)) (Q: list (environ -> Prop)) :=
  (PTree.fold tempD' T1 nil) ++
 (PTree.fold localD' T2 nil) ++ Q.

Lemma localD_app_eq : forall t2 q, PTree.fold localD' t2 q = PTree.fold localD' t2 nil ++ q.

Lemma tempD_app_eq : forall t2 q, PTree.fold tempD' t2 q = PTree.fold tempD' t2 nil ++ q.

Lemma LocalD_app_eq :
forall t1 t2 q,
LocalD t1 t2 q = LocalD_app t1 t2 q.

Lemma fold_right_conj :
forall a b rho,
(fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) (a ++ b) rho) <-> ((fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) a rho /\ fold_right (fun (x0 x1 : environ -> Prop) (x2 : environ) => x0 x2 /\ x1 x2)
     (`True) b rho)).

Lemma LocalD_to_localD : forall P R t l,
PROPx (P) (LOCALx (LocalD t l []) (SEPx (R))) =
PROPx (P) (LOCALx (localD t l) (SEPx (R))).

Fixpoint val_e_to_expr_std (v : val_e) : (expr typ func) :=
match v with
  | Vundef => injR (Value fVundef)
  | Vlong l => (appR (Value fVlong) (injR (Const (fint64 l))))
  | Vint i => (appR (Value fVint) (injR (Const (fint i))))
  | Vfloat f => (appR (Value fVfloat) (injR (Const (ffloat f))))
  | Vsingle f => (appR (Value fVsingle) (injR (Const (ffloat32 f))))
  | Vexpr e => e
  | Vunop op ty e => appR (Eval_f (feval_unop op ty)) (val_e_to_expr_std e)
  | Vbinop op ty1 ty2 e1 e2 => App (appR (Eval_f (feval_binop op ty1 ty2)) (val_e_to_expr_std e1)) (val_e_to_expr_std e2)
  | Veval_cast ty1 ty2 v => (appR (Eval_f (feval_cast ty1 ty2))) (val_e_to_expr_std v)
  | Vforce_ptr v => (appR (Other (fforce_ptr))) (val_e_to_expr_std v)
  | Veval_field t id v => (appR (Eval_f (feval_field t id))) (val_e_to_expr_std v)
end.

Definition rmsubst_eval_expr_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_expr_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_lvalue_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) :=
match msubst_eval_lvalue_reif T1 T2 e with
| Some e => some_reif (val_e_to_expr_std e) tyval
| None => none_reif tyval
end.

Definition rmsubst_eval_LR_std (T1: (ExprCore.expr typ func)) (T2: ExprCore.expr typ func) (e: Clight.expr) (lr : LLRR) :=
match lr with
| LLLL => rmsubst_eval_lvalue_std T1 T2 e
| RRRR => rmsubst_eval_expr_std T1 T2 e
end. *)

Require Import MirrorCore.Lemma.

Require Import MirrorCharge.RTac.ReifyLemma.

Require Import mc_reify.update_tycon.
(* mc_reify.update_tycon:
Require Import VST.floyd.proofauto.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.reify.
Require Import MirrorCore.Lambda.ExprCore.

Definition initialized_temp (id : positive) (t : PTree.t (type * bool)) :=
match (t ! id) with
| Some (ty, _) =>
  PTree.set id (ty, true) t
| None => t
end.

Fixpoint update_temp (t : PTree.t (type * bool)) (s : statement) :=
 match s with
 | Sskip | Scontinue | Sbreak => t
 | Sassign e1 e2 => t 
 | Sset id e2 => (initialized_temp id t)
 | Ssequence s1 s2 => let t' := update_temp t s1 in
                      update_temp t' s2
 | Sifthenelse b s1 s2 => join_te (update_temp t s1) (update_temp t s2)
 | Sloop _ _ => t
 | Sswitch e ls => update_temp_labeled t ls
 | Scall (Some id) _ _ => (initialized_temp id t)
 | _ => t  
end
with update_temp_labeled (t : PTree.t (type * bool)) (ls : labeled_statements) :=
       match ls with
         | LSnil => t
         | LScons _ s ls' =>
           join_te (update_temp t s) (update_temp_labeled t ls')
       end.

Lemma initialized_temp_eq : forall t v r gt gs i,
initialized i (mk_tycontext t v r gt gs) = mk_tycontext (initialized_temp i t) v r gt gs.

Lemma update_temp_eq : forall t v r gt gs s,
update_tycon (mk_tycontext t v r gt gs) s = (mk_tycontext (update_temp t s) v r gt gs)
with
update_temp_labeled_eq : forall t v r gt gs s,
join_tycon_labeled s (mk_tycontext t v r gt gs) = (mk_tycontext (update_temp_labeled t s) v r gt gs). *)

Require Export MirrorCore.RTac.Repeat.

Require Import MirrorCore.RTac.Then.

Require Export MirrorCore.RTac.Try.

Require Export MirrorCore.RTac.First.

Require Import MirrorCore.RTac.Fail.

Require Import MirrorCore.RTac.Simplify.

Require Import MirrorCore.Lambda.RedAll.

Require Import MirrorCore.Lambda.ExprUnify_simul.

Require Import MirrorCore.RTac.RTac.

Require Import MirrorCharge.RTac.Instantiate.

Require Import MirrorCharge.RTac.Intro.

Require Import MirrorCharge.RTac.Apply.

Require Import MirrorCharge.RTac.EApply.

Require Export mc_reify.funcs.

Require Import mc_reify.types.
(* mc_reify.types:
Require Import MirrorCore.Lambda.ExprCore.

Require Import VST.floyd_funcs.

Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import Coq.FSets.FMapPositive.

Inductive typ :=
| tyArr : typ -> typ -> typ
| tytycontext
| tyc_expr
| tyc_type
| tyenviron
| tyval
| tyshare
| tyident
| tylist : typ -> typ
| tyint
| tyZ
| tynat
| typositive
| tybool
| tycomparison
| tytc_assert
| tyint64
| tyfloat
| tyfloat32
| tyattr
| tysignedness
| tyintsize
| tyfloatsize
| tytypelist
| tyfieldlist
| tybinary_operation
| tyunary_operation
| tyN
| tyoption : typ -> typ
| typrop
| tympred
| tysum : typ -> typ -> typ
| typrod : typ -> typ -> typ
| tyunit

| tyOracleKind
| tystatement
| tyret_assert
| tyexitkind
| typtree : typ -> typ
| tygfield
| tyfunspec
| tyefield
| tytype_id_env
| tyllrr

.

Fixpoint typD (t : typ) : Type :=
    match t with
        | tyArr a b => typD a  -> typD b
        | tytycontext => tycontext
        | tyc_expr => expr
        | tyc_type => type
        | tyenviron => environ
        | tyval => val
        | tyshare => share
        | tyident => ident
        | tylist t => list (typD t )
        | tyint => int
        | tyZ => Z
        | tynat => nat
        | typositive => positive
        | tybool => bool
        | tycomparison => comparison
        | tytc_assert => tc_assert
        | tyint64 => int64
        | tyfloat => float
        | tyfloat32 => float32
        | tyattr => attr
        | tysignedness => signedness
        | tyintsize => intsize
        | tyfloatsize  => floatsize
        | tytypelist => typelist
        | tyfieldlist => fieldlist
        | tybinary_operation => Cop.binary_operation
        | tyunary_operation => Cop.unary_operation
        | tyN => N
        | tyoption t => option (typD t )
        | typrop => Prop
        | tympred => mpred
        | tysum t1 t2 => sum (typD  t1 ) (typD  t2 )
        | typrod t1 t2 => prod (typD  t1 ) (typD  t2 )
        | tyunit => unit
        
        | tyOracleKind => OracleKind
        | tystatement => statement
        | tyret_assert => ret_assert

        | tyexitkind => exitkind
        | typtree t => PTree.t (typD t)
        | tygfield => gfield
        | tyfunspec => funspec
        | tyefield => efield
        | tytype_id_env => type_id_env
        | tyllrr => LLRR
    end.

Definition typ_eq_dec : forall a b : typ, {a = b} + {a <> b}.

Instance Typ0_tyProp : Typ0 _ Prop :=
{| typ0 := typrop
 ; typ0_cast :=  eq_refl
 ; typ0_match := fun T  t =>
                   match t as t
                         return T Prop -> T (TypesI.typD  t) -> T (TypesI.typD  t)
                   with
                     | typrop => fun tr _ => tr
                     | _ => fun _ fa => fa
                   end
 |}. *)

Require Import mc_reify.typ_eq.
(* mc_reify.typ_eq:
Require Import types.
Import Coq.Bool.Bool.

Fixpoint typ_beq a b :=
match a, b with
| tytycontext, tytycontext
| tyc_expr, tyc_expr
| tyc_type, tyc_type
| tyenviron, tyenviron
| tyval, tyval
| tyshare, tyshare
| tyident, tyident
| tyint, tyint
| tyZ, tyZ
| tynat, tynat
| typositive, typositive
| tybool, tybool
| tycomparison, tycomparison
| tytc_assert, tytc_assert
| tyint64, tyint64
| tyfloat, tyfloat
| tyattr, tyattr
| tysignedness, tysignedness
| tyintsize, tyintsize
| tyfloatsize, tyfloatsize
| tytypelist, tytypelist
| tyfieldlist, tyfieldlist
| tybinary_operation, tybinary_operation
| tyunary_operation, tyunary_operation
| tyN, tyN
| typrop, typrop
| tympred, tympred
| tyunit, tyunit
| tyOracleKind, tyOracleKind
| tystatement, tystatement
| tygfield, tygfield
| tyfunspec, tyfunspec
| tyret_assert, tyret_assert => true

| tysum tl1 tr1, tysum tl2 tr2
| typrod tl1 tr1, typrod tl2 tr2
| tyArr tl1 tr1, tyArr tl2 tr2 => andb (typ_beq tl1 tl2) (typ_beq tr1 tr2)
| tyoption t1, tyoption t2 => typ_beq t1 t2
| tylist t1, tylist t2 => typ_beq t1 t2
| _, _ => false
end.

SearchAbout BinPos.Pos.eqb.
Hint Resolve expr.eqb_type_true : beq_sound.
Hint Resolve BinPos.Peqb_true_eq : beq_sound.

Ltac prove_beq_sound :=
try solve [try reflexivity; inversion H];
repeat
match goal with
 | [H : typ_beq _ _ = true |- _ ] => simpl in H; rewrite andb_true_iff in H; destruct H
 | [ |- _ _ _ = _ _ _ ] => try f_equal
 | [ |- _ _  = _ _  ] => try f_equal
 | [H : forall x, _ -> ?a = x |- ?a = _ ] => apply H
end;
auto with beq_sound.

Lemma typ_beq_sound : forall a b, typ_beq a b = true -> a = b. *)

Require Export mc_reify.reflexivity_tacs.

Require Import mc_reify.func_defs.
(* mc_reify.func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)

Require Import MirrorCharge.RTac.Cancellation.

Require Import mc_reify.rtac_base.
(* mc_reify.rtac_base:
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Import MirrorCore.RTac.Then.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.typ_eq.
Require Import mc_reify.func_defs.
Require Import MirrorCore.LemmaApply.
Require Import ExtLib.Tactics.
Require Import MirrorCore.Util.ListMapT.

Definition rtacP := sigT (fun tac: rtac typ (expr typ func) =>
  forall tbl: SymEnv.functions RType_typ, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac).

Definition my_lemma := lemma typ (ExprCore.expr typ func) (ExprCore.expr typ func).

Definition THEN' (r1 r2 : rtac typ (expr typ func)) := THEN r1 (runOnGoals r2).

Definition THEN (r1 r2 : rtac typ (expr typ func)) :=
  THEN' r1 (THEN' (INSTANTIATE typ func) r2).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.

Lemma THEN_sound : forall t1 t2,
rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t1 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t2 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) (THEN t1 t2).
intros. unfold THEN.
unfold THEN'.
apply THEN_sound; auto.
apply runOnGoals_sound; auto;
rtac_derive_soundness.
apply INSTANTIATE_sound.
apply runOnGoals_sound. auto.

Definition APPLY_sound := (@APPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _ _ ).

Definition EAPPLY_sound :=
  (@EAPPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _). 
Lemma APPLY_condition1: vars_to_uvars_spec vars_to_uvars.

Lemma APPLY_condition2:
 forall (subst : Type) (S : Subst subst (expr typ func))
   (SO : SubstOk S) (SU : SubstUpdate subst (expr typ func))
   (SUO : SubstUpdateOk SU SO),
 UnifyI.unify_sound

End tbled.

Definition thenP (t1 t2: rtacP) : rtacP :=
  match t1, t2 with
  | existT tac1 p1, existT tac2 p2 =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
   (THEN tac1 tac2) (fun tbl => THEN_sound tbl _ _ (p1 tbl) (p2 tbl))
  end.

Definition repeatP (n: nat) (t: rtacP) : rtacP :=
  match t with
  | existT tac p =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
        (REPEAT n tac)
        (fun tbl => @REPEAT_sound _ _ _ _ _ (Expr_ok_fs tbl) _ _ _ n _ (p tbl))
  end. *)

Require Import mc_reify.reified_ltac_lemmas.
(* mc_reify.reified_ltac_lemmas:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Lemma mpred_prop_right: forall (P: mpred) (Q: Prop), Q -> P |-- !! Q.

Lemma mpred_now_later: forall (P: mpred), P |-- |> P.

Lemma mpred_derives_refl: forall (P: mpred), P |-- P.

Lemma mpred_semax_post' : forall (R' : environ -> mpred) (Espec : OracleKind)
         (Delta : tycontext) (R P : environ -> mpred)
         (c : statement),
       (forall rho, R' rho |-- R rho) ->
       semax Delta P c (normal_ret_assert R') ->
       semax Delta P c (normal_ret_assert R).

Require Export mc_reify.reify.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.rtac_base.

Definition reify_prop_right: my_lemma.

Definition reify_now_later : my_lemma.

Definition reify_derives_refl : my_lemma.

Definition reify_semax_post' : my_lemma.

Definition writable_Tsh_lemma: my_lemma.

Definition writable_Ews_lemma: my_lemma.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma APPLY_sound_prop_right: rtac_sound (EAPPLY typ func reify_prop_right).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_now_later: rtac_sound (EAPPLY typ func reify_now_later).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_derives_refl: rtac_sound (EAPPLY typ func reify_derives_refl).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_semax_post': rtac_sound (EAPPLY typ func reify_semax_post').
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_writable_Tsh: rtac_sound (APPLY typ func writable_Tsh_lemma).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_writable_Ews: rtac_sound (APPLY typ func writable_Ews_lemma).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

End tbled. *)

Require Import mc_reify.hoist_later_in_pre.
(* mc_reify.hoist_later_in_pre:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Require Export mc_reify.reify.
Require Export mc_reify.bool_funcs.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.rtac_base.
Require Import mc_reify.reified_ltac_lemmas.

Fixpoint rstrip_1_later_sep (R: expr typ func) : expr typ func :=
  match R with
  | Inj (inr (Data (fnil tympred))) => Inj (inr (Data (fnil tympred)))
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    match hd with
    | App (Inj (inr (Smx flater))) hd0 => App (App (Inj (inr (Data (fcons tympred)))) hd0) (rstrip_1_later_sep tl)
    | _ => App (App (Inj (inr (Data (fcons tympred)))) hd) (rstrip_1_later_sep tl)
    end
  | _ => R
  end.

Lemma SEPx_map_liftx: forall R, SEPx (map liftx R) = liftx (fold_right sepcon emp R).

Lemma hoist_later_in_pre_aux:
    forall temp var ret gt s
      gs P T1 T2 R R' Post,
  forall {Espec: OracleKind},
      fold_right sepcon emp R |-- |> (fold_right sepcon emp R') ->
      semax (mk_tycontext temp var ret gt gs) (|> (assertD P (localD T1 T2) R')) s (normal_ret_assert Post) ->
      semax (mk_tycontext temp var ret gt gs) (assertD P (localD T1 T2) R) s (normal_ret_assert Post).

Lemma fold_right_sepcon_later_derives: forall P P' Q Q' R,
  P |-- |> P' ->
  fold_right sepcon emp Q |-- |> (fold_right sepcon emp Q') ->
  (fold_right sepcon emp (P' :: Q')) = R ->
  fold_right sepcon emp (P :: Q) |-- |> R.

Definition reify_hlip_base (temp : PTree.t (type * bool)) (var : PTree.t type)

Definition reify_hlip_ind : my_lemma.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.
Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Definition solve_hd_in_hlip (hd: expr typ func) : rtac typ (expr typ func) :=
  match hd with
  | App (Inj (inr (Smx flater))) _ => EAPPLY typ func reify_derives_refl
  | _ => EAPPLY typ func reify_now_later
  end.

Fixpoint solve_strip_1_later (R: expr typ func) : rtac typ (expr typ func) :=
  match R with
  | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN (EAPPLY typ func reify_hlip_ind)
     (THEN (TRY (REFLEXIVITY tbl))
           (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
  | _ => FAIL
  end.

Definition HLIP temp var ret gt R s :=
  THEN (EAPPLY typ func (reify_hlip_base temp var ret gt s))
       (TRY (solve_strip_1_later R)).

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma HLIP_sound_aux0: forall temp var ret gt s, rtac_sound (EAPPLY typ func (reify_hlip_base temp var ret gt s)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma HLIP_sound_aux1: rtac_sound (EAPPLY typ func reify_hlip_ind).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Definition HLIP_sound_aux2 (hd: expr typ func): rtac_sound (solve_hd_in_hlip hd) :=
    match hd as hd'
      return rtac_sound match hd' with
                        | App (Inj (inr (Smx flater))) _ => EAPPLY typ func reify_derives_refl
                        | _ => EAPPLY typ func reify_now_later
                        end
    with
    | App (Inj (inr (Smx flater))) _ => APPLY_sound_derives_refl tbl
    | _ => APPLY_sound_now_later tbl
    end.

Print Forall_cons.
Lemma tttt: Forall (fun x => In x [1; 3; 4]) [1; 3; 4].

Lemma solve_strip_1_later_def: forall R,
  match R with
  | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN (EAPPLY typ func reify_hlip_ind)
     (THEN (TRY (REFLEXIVITY tbl))
           (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
  | _ => FAIL
  end =
  solve_strip_1_later R.

Fixpoint solve_strip_1_later_sound (R: expr typ func) : rtac_sound (solve_strip_1_later R) :=
  let res :=
  match R as R'
    return rtac_sound match R' with
                      | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
                      | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
                        THEN (EAPPLY typ func reify_hlip_ind)
                         (THEN (TRY (REFLEXIVITY tbl))
                               (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
                      | _ => FAIL
                      end
  with
  | Inj (inr (Data (fnil tympred))) => APPLY_sound_now_later tbl
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN_sound tbl _ _ HLIP_sound_aux1
     (THEN_sound tbl _ _ (TRY_sound (REFLEXIVITYTAC_sound tbl))
                        (FIRST_sound (Forall_cons _ (HLIP_sound_aux2 hd)
                                       (Forall_cons _ (solve_strip_1_later_sound tl) (Forall_nil _)))))
  | _ => FAIL_sound
  end in
  eq_rect_r rtac_sound res (eq_sym (solve_strip_1_later_def R)). 

Lemma HLIP_sound: forall temp var ret gt R s, rtac_sound (HLIP temp var ret gt R s).

End tbled. *)

Require Import mc_reify.set_load_store.
(* mc_reify.set_load_store:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Require Export mc_reify.reify.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.func_defs.
Require Import mc_reify.rtac_base.

Lemma semax_set_localD:
    forall temp var ret gt
      id (e: Clight.expr) ty gs P T1 T2 R Post v,

Definition set_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

Lemma tc_LR_b_sound: forall Delta P T1 T2 R e1 lr p,
  msubst_eval_LR T1 T2 e1 lr = Some p ->
  assertD P (localD T1 T2) R |-- !! (isptr p) ->
  tc_LR_b_norho Delta e1 lr = true ->
  assertD P (localD T1 T2) R |-- local (tc_LR Delta e1 lr).

Lemma nth_error_prop:
  forall P T1 T2 R Rn (n : nat) S,
  assertD P (localD T1 T2) [Rn] |-- !! S ->
  nth_error R n = Some Rn ->
  assertD P (localD T1 T2) R |-- !! S.

Lemma semax_load_localD:
forall (temp : PTree.t (type * bool)) (var : PTree.t type)

Definition load_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

Lemma semax_store_localD:
    forall (temp : PTree.t (type * bool)) (var : PTree.t type)

Definition store_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

Section tbled.
Variable n : nat.
Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma load_store_sound_aux:
  forall t_root, (@funcAs typ func RType_typ
              (func_defs.RSym_sym tbl)

Lemma APPLY_sound_store_lemma: forall (temp : PTree.t (type * bool)) (var : PTree.t type)
  (ret : type) (gt : PTree.t type) (t t_root : type)
  (e0 e1 e2 : Clight.expr) (efs : list efield) (tts : list type)
  (e : type_id_env) (lr : LLRR) (n : nat),
  rtac_sound (EAPPLY typ func (store_lemma temp var ret gt t t_root e0 e1 e2 efs tts e lr n)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env, Lemma.lemmaD'. simpl.

Lemma APPLY_sound_load_lemma: forall (temp : PTree.t (type * bool)) (var : PTree.t type)
  (ret : type) (gt : PTree.t type) (id : ident) (t t_root : type)
  (e0 e1 : Clight.expr) (efs : list efield) (tts : list type)
  (e : type_id_env) (lr : LLRR) (n : nat),
  rtac_sound (EAPPLY typ func (load_lemma temp var ret gt id t t_root e0 e1 efs tts e lr n)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env, Lemma.lemmaD'. simpl.

End tbled. *)



Local Open Scope logic.



Ltac reify_expr_tac :=

match goal with

| [ |- ?trm] => reify_vst trm

end.



Ltac do_local2ptree := do 2 (erewrite local2ptree_soundness; [ | repeat constructor ]);

repeat rewrite LocalD_to_localD.



Ltac pull_sep_lift R :=

match R with

| ((`?H) :: ?T) => let rest := pull_sep_lift T in constr:(cons H rest)

| (@nil _) => constr:(@nil mpred)

end.



Ltac extract_sep_lift_semax :=

  match goal with

      [ |- context [semax _ 

                 (PROPx ?P1 (LOCALx ?Q1 (SEPx ?R1))) _

                 (normal_ret_assert  _)]] =>

      let R1' := pull_sep_lift R1 in

      

      try (change (PROPx (P1) (LOCALx Q1 (SEPx (R1))))

      with (assertD nil Q1 R1'))


end.



Ltac hnf_tycontext :=

match goal with

[ |- context [semax ?s _ _ _] ] => let ss := eval hnf in s in change s with ss

end.



Ltac prepare_reify :=

do_local2ptree;

extract_sep_lift_semax;

hnf_tycontext.



Definition remove_global_spec (t : tycontext) :=

match t with

| mk_tycontext t v r gt gs => mk_tycontext t v r gt (PTree.empty _)

end.



Definition is_array_type (t: Ctypes.type) : bool :=

  match t with

  | Tarray _ _ _ => true

  | _ => false

  end.



Fixpoint no_load_expr_bool (e: Clight.expr) : bool :=

  match e with

  | Econst_int _ _ => true

  | Econst_float _ _ => true

  | Econst_single _ _ => true

  | Econst_long _ _ => true

  | Evar _ t => is_array_type t

  | Etempvar _ _ => true

  | Ederef _ _ => false

  | Eaddrof e0 _ => no_load_lvalue_bool e0

  | Eunop _ e0 _ => no_load_expr_bool e0

  | Ebinop _ e0 e1 _ => (no_load_expr_bool e0 && no_load_expr_bool e1)%bool

  | Ecast e0 _ => no_load_expr_bool e0

  | Efield e0 _ t => (is_array_type t && no_load_lvalue_bool e0)%bool

  end

with no_load_lvalue_bool (e: Clight.expr) : bool :=

  match e with

  | Econst_int _ _ => false

  | Econst_float _ _ => false

  | Econst_single _ _ => false

  | Econst_long _ _ => false

  | Evar _ _ => true

  | Etempvar _ _ => false

  | Ederef _ _ => false

  | Eaddrof _ _ => false

  | Eunop _ _ _ => false

  | Ebinop _ _ _ _ => false

  | Ecast _ _ => false

  | Efield e0 _ _ => no_load_lvalue_bool e0

  end.



Inductive ForwardRule : Type :=

| ForwardSet

| ForwardLoad

| ForwardCastLoad

| ForwardStore

| ForwardSeq: statement -> statement -> ForwardRule

| ForwardSkip.



Definition compute_forward_rule (s: statement) : option ForwardRule :=

  match s with

  | Sskip => Some ForwardSkip

  | Ssequence s1 s2 => Some (ForwardSeq s1 s2)

  | Sassign _ _ => Some ForwardStore

  | Sset _ e =>

    if no_load_expr_bool e

    then Some ForwardSet

    else match e with

         | Ecast _ _ => Some ForwardCastLoad

         | _ => Some ForwardLoad

         end

  | _ => None

  end.



Definition get_arguments_delta (e : expr typ func) :=

  match e with

  | App (Inj (inr (Smx (ftycontext t v r gt)))) gf => Some (t, v, r, gt, gf)

  | _ => None

  end.



Definition get_arguments_pre (e : expr typ func) :=

  match e with

  | App (App (App (Inj (inr (Smx fassertD))) P)

      (App (App (Inj (inr (Smx flocalD))) T1) T2)) R => Some (P, T1, T2, R, rstrip_1_later_sep R)

  | _ => None

  end.



Definition get_arguments_statement (e : expr typ func) :=

  match e with

  | Inj (inr (Smx (fstatement s))) => Some s

  | _ => None

  end.



Fixpoint get_arguments (e : expr typ func) :=

match e with

| App (App (App (App (App (Inj (inr (Smx fsemax))) _) Delta) Pre) CCmd) _ =>

  (get_arguments_delta Delta,

   get_arguments_pre Pre,

   get_arguments_statement CCmd)

| App _ e

| Abs _ e => get_arguments e

| _ => (None, None, None)

end.



Definition compute_hlip_arg (arg:

         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *

          expr typ func) *

       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *

       statement) :=

  match arg with

  | ((t, v, r, gt, _), (_, _, _, R, _), s) => (t, v, r, gt, s, R)

  end.



Definition compute_set_arg (arg:

         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *

          expr typ func) *

       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *

       statement) :=

  match arg with

  | ((t, v, r, gt, _), _, s) =>

    match s with

    | Sset i e0 =>

      match t ! i with

      | Some (ty, _) => Some (t, v, r, gt, i, e0, ty)

      | _ => None

      end

    | _ => None

    end

  end.



Section empty_RSym_sym.



Instance RSym_SymEnv_fun : RSym SymEnv.func := {

  typeof_sym := fun _ => None;

  symD := fun _ => tt;

  sym_eqb := fun x y => Some (Pos.eqb x y)

}.



Instance RSymOk_SymEnv_fun : RSymOk RSym_SymEnv_fun.

split.

intros.

simpl.

pose proof Pos.eqb_eq a b.

destruct (a =? b)%positive; intros.

+ apply H; auto.

+ intro.

  apply H in H0.

  congruence.

Defined.



Definition sem_eqb_func := @sym_eqb _ _ _ (SymSum.RSym_sum

  (SymSum.RSym_sum (SymSum.RSym_sum RSym_SymEnv_fun RSym_ilfunc) RSym_bilfunc)

  RSym_Func').



Fixpoint expr_beq (e1 e2: expr typ func) : bool :=

  match e1, e2 with

  | Var i1, Var i2 => beq_nat i1 i2

  | Inj f1, Inj f2 =>

    match sem_eqb_func f1 f2 with

    | Some true => true

    | _ => false

    end

  | App e11 e12, App e21 e22 => andb (expr_beq e11 e21) (expr_beq e12 e22)

  | Abs ty1 e11, Abs ty2 e21 => andb (expr_beq e11 e21) (typ_beq ty1 ty2)

  | UVar i1, UVar i2 => beq_nat i1 i2

  | _, _ => false

  end.



End empty_RSym_sym.



Fixpoint nth_solver_rec (R: expr typ func) (p: expr typ func) (n: nat) :=

match R with

| Inj (inr (Data (fnil tympred))) => None

| App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>

  match hd with

  | App (App (App (Inj (inr (Sep (fdata_at t_root)))) sh) v) p' =>

      if (expr_beq p p')

      then Some (t_root, n)

      else nth_solver_rec tl p (S n)

  | _ => nth_solver_rec tl p (S n)

  end

| _ => None

end.



Definition nth_solver R p := nth_solver_rec R p 0.



Definition compute_load_arg (arg:

         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *

          expr typ func) *

       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *

       statement) :=

  match arg with

  | ((t, v, r, gt, _), (_, T1, T2, _, R'), s) =>

    match s with

    | Sset i e0 =>

      match t ! i, compute_nested_efield e0 with

      | Some (ty, _), (e1, efs, tts) =>

        let lr := compute_lr e1 efs in

        match rmsubst_eval_LR T1 T2 e1 lr with

        | App (Inj (inr (Other (fsome tyval)))) p =>

          match nth_solver R' p with

          | Some (t_root, n) =>

              Some (t, v, r, gt, i, ty, t_root, e0, e1, efs, tts, lr, n)

          | _ => None

          end

        | _ => None

        end

      | _, _ => None

      end

    | _ => None

    end

  end.



Definition compute_store_arg (arg:

         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *

          expr typ func) *

       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *

       statement) :=

  match arg with

  | ((t, v, r, gt, _), (_, T1, T2, _, R'), s) =>

    match s with

    | Sassign e0 e2 =>

      match compute_nested_efield e0 with

      | (e1, efs, tts) =>

        let ty := typeof e0 in

        let lr := compute_lr e1 efs in

        match rmsubst_eval_LR T1 T2 e1 lr with

        | App (Inj (inr (Other (fsome tyval)))) p =>

          match nth_solver R' p with

          | Some (t_root, n) =>

              Some (t, v, r, gt, ty, t_root, e0, e1, e2, efs, tts, lr, n)

          | _ => None

          end

        | _ => None

        end

      end

    | _ => None

    end

  end.



Section tbled.



Variable n : nat.

Variable tbl : SymEnv.functions RType_typ.



Let RSym_sym := RSym_sym tbl.

Existing Instance RSym_sym.



Lemma semax_seq_reif c1 c2 : forall  (Espec : OracleKind)

         (P : environ -> mpred)  (P' : environ -> mpred)

          (Q : ret_assert) (Delta : tycontext) ,

       @semax Espec Delta P c1 (normal_ret_assert P') ->

       @semax Espec (update_tycon Delta c1) P' c2 Q ->

       @semax Espec Delta P (Ssequence c1 c2) Q.

intros.

eapply semax_seq'; eauto.

Qed.



Definition skip_lemma : my_lemma.

reify_lemma reify_vst

@semax_skip.

Defined.



Definition seq_lemma (s1 s2: statement)  : my_lemma.

reify_lemma reify_vst (semax_seq_reif s1 s2).

Defined.



Definition replace_set (e : expr typ func) : expr typ func :=

match e with

| App (App (App (App (App (Inj (inr (Smx fsemax))) es)

                     Delta) pre) s) post =>

  let newpre :=

      match pre with

        |  App (App (App (Inj (inr (Smx fassertD))) P)

                    (App (App (Inj (inr (Smx flocalD)))

                              T1) T2)) R =>

           let newT1 := match T1 with

                          | App (App

                                    (Inj (inr (Data (fset tyval n))))

                                    val) T1' =>

                            get_set_reif.set_reif n val T1' tyval

                          | _ => T1

                        end in

           App (App (App (Inj (inr (Smx fassertD))) P)

                    (App (App (Inj (inr (Smx flocalD)))

                              newT1) T2)) R

        | _ => pre

      end in

  App (App (App (App (App (Inj (inr (Smx fsemax))) es)

                     Delta) newpre) s) post

| _ => e

end.



Definition SIMPL_SET : rtac typ (ExprCore.expr typ func) :=

SIMPLIFY (fun _ _ _ _ => replace_set).



Definition update_tycon_tac (l : list (option (expr typ func)))

(e : expr typ func) (args : list (expr typ func))

	: expr typ func :=

match e with

    | (Inj (inr (Smx (fupdate_tycon)))) =>

      match args with

          | [App (Inj (inr (Smx (ftycontext t v r gt)))) gs; (Inj (inr (Smx (fstatement s))))] =>

            App (Inj (inr (Smx (ftycontext (update_temp t s) v r gt)))) gs

          | _ =>  AppN.apps e args

      end

    | _ => AppN.apps e args

end.



Definition SIMPL_DELTA : rtac typ (ExprCore.expr typ func) :=

SIMPLIFY (fun _ _ _ _=>beta_all update_tycon_tac).



Definition INTROS := (REPEAT 10 (INTRO typ func)).



Definition APPLY_SKIP :=  (APPLY typ func  skip_lemma).



Definition run_tac (t: rtac typ (ExprCore.expr typ func)) e :=

  t nil nil 0%nat 0%nat (CTop nil nil) (ctx_empty (expr := expr typ func)) e.



Definition run_tac_intros e :=

run_tac (THEN INTROS e).



Definition APPLY_SEQ' s1 s2 := (EAPPLY typ func (seq_lemma s1 s2)).



Definition APPLY_SEQ s1 s2 := THEN (APPLY_SEQ' s1 s2) (SIMPL_DELTA).



Definition FORWARD_SET Delta Pre s :=

  let _HLIP :=

  match compute_hlip_arg (Delta, Pre, s) with

  | (temp, var, ret, gt, s, R) => HLIP tbl temp var ret gt R s

  end in

  let _APPLY_SET :=

  match compute_set_arg (Delta, Pre, s) with

  | Some (temp, var, ret, gt, i, e0, ty) =>

      THEN (EAPPLY typ func (set_lemma temp var ret gt i e0 ty))

           (TRY (FIRST [REFLEXIVITY_OP_CTYPE tbl;

                        REFLEXIVITY_MSUBST tbl;

                        REFLEXIVITY_BOOL tbl;

                        AFTER_SET_LOAD tbl;

                        REFLEXIVITY tbl]))

  | _ => FAIL

  end in

  THEN _HLIP _APPLY_SET.



Definition FORWARD_LOAD Struct_env Delta Pre s :=

  let _HLIP :=

  match compute_hlip_arg (Delta, Pre, s) with

  | (temp, var, ret, gt, s, R) => HLIP tbl temp var ret gt R s

  end in

  let _APPLY_LOAD :=

  match compute_load_arg (Delta, Pre, s) with

  | Some (t, v, r, gt, i, ty, t_root, e0, e1, efs, tts, lr, n) =>

            (THEN (EAPPLY typ func (load_lemma t v r gt i ty t_root e0 e1 efs tts Struct_env lr n))

            (THEN (TRY (FIRST [REFLEXIVITY_OP_CTYPE tbl;

                               REFLEXIVITY_BOOL tbl;

                               REFLEXIVITY_CEXPR tbl;

                               AFTER_SET_LOAD tbl;

                               REFLEXIVITY tbl;

                               REFLEXIVITY_MSUBST tbl;

                               REFLEXIVITY_MSUBST_EFIELD tbl;

                               REFLEXIVITY_NTH_ERROR tbl]))

                  (TRY (THEN INTROS

                       (THEN (EAPPLY typ func reify_prop_right)

                             (REFLEXIVITY tbl))))))

  | _ => FAIL

  end in

  THEN _HLIP _APPLY_LOAD.



Definition FORWARD_STORE Struct_env Delta Pre s :=

  let _HLIP :=

  match compute_hlip_arg (Delta, Pre, s) with

  | (temp, var, ret, gt, s, R) => HLIP tbl temp var ret gt R s

  end in

  let _APPLY_STORE :=

  match compute_store_arg (Delta, Pre, s) with

  | Some (t, v, r, gt, ty, t_root, e0, e1, e2, efs, tts, lr, n) =>

            (THEN (EAPPLY typ func (store_lemma t v r gt ty t_root e0 e1 e2 efs tts Struct_env lr n))

            (THEN (TRY (FIRST [REFLEXIVITY_CTYPE tbl;

                               REFLEXIVITY_BOOL tbl;

                               REFLEXIVITY_CEXPR tbl;

                               AFTER_STORE tbl;

                               REFLEXIVITY tbl;

                               FIRST [APPLY typ func writable_Tsh_lemma; APPLY typ func writable_Ews_lemma];

                               REFLEXIVITY_MSUBST tbl;

                               REFLEXIVITY_MSUBST_EFIELD tbl;

                               REFLEXIVITY_NTH_ERROR tbl]))

                  (TRY (THEN INTROS

                       (THEN (EAPPLY typ func reify_prop_right)

                             (REFLEXIVITY tbl))))))

  | _ => FAIL

  end in

  THEN _HLIP _APPLY_STORE.



Definition SYMEXE_STEP Struct_env

: rtac typ (expr typ func)  :=

  THEN' (INSTANTIATE typ func)

  (Then.THEN (AT_GOAL

    (fun c s e =>

         match (get_arguments e) with

         | (Some Delta, Some Pre, Some s) =>

           match compute_forward_rule s with

           | Some ForwardSkip => APPLY_SKIP

           | Some (ForwardSeq s1 s2) => APPLY_SEQ s1 s2

           | Some ForwardSet => FORWARD_SET Delta Pre s

           | Some ForwardLoad => FORWARD_LOAD Struct_env Delta Pre s

           | Some ForwardStore => FORWARD_STORE Struct_env Delta Pre s

           | _ => FAIL

           end

         | _ => FAIL

         end)) (@RTac.Minify.MINIFY typ (expr typ func) _)).



Existing Instance func_defs.Expr_ok_fs.



Definition SYMEXE_TAC_n :=

  Then.THEN (

  THEN

   (THEN INTROS

   (THEN (EAPPLY typ func reify_semax_post')

         (TRY (AT_GOAL

                (fun c s e =>

                   match (get_arguments e) with

                   | (Some (A, B, C, D, _), _, _) =>

                     (REPEAT n (SYMEXE_STEP (compute_type_id_env (mk_tycontext A B C D (PTree.empty funspec)))))

                   | _ => FAIL

                   end)))))

   (TRY (THEN INTROS (EAPPLY typ func reify_derives_refl)))) (@RTac.Minify.MINIFY typ (expr typ func) _).



Definition rreflexivity e :=

run_tac (REFLEXIVITY tbl) e.



Definition test_lemma :=

  @lemmaD typ (expr typ func) RType_typ ExprD.Expr_expr (expr typ func)

          (fun tus tvs e => ExprDsimul.ExprDenote.exprD' tus tvs typrop e)

          _

          nil nil.



Fixpoint is_pure (e : expr typ func) :=

match e with

| App e1 e2 => is_pure e1

| (Inj (inr (Sep fprop))) => true

| _ => false

end.



Definition CANCEL e := run_tac (THEN INTROS (CANCELLATION typ func tympred is_pure)) e.



Let Expr_expr := (Expr_expr_fs tbl).

Existing Instance Expr_expr.



Definition run_tac' tac goal :=

  runOnGoals tac nil nil 0 0 (CTop nil nil)

    (ctx_empty (typ := typ) (expr := expr typ func)) goal.



Lemma run_rtac_More tac s goal e

  (Hsound : rtac_sound tac)

  (Hres : run_tac' tac (GGoal e) = More_ s goal) :

  goalD_Prop tbl nil nil goal -> exprD_Prop tbl nil nil e.

Proof.

  intros He'.

  apply runOnGoals_sound_ind with (g := GGoal e) (ctx := CTop nil nil)

  	(s0 := TopSubst (expr typ func) nil nil) in Hsound.

  unfold rtac_spec in Hsound. simpl in Hsound.

  unfold run_tac' in Hres. simpl in Hres.

  rewrite Hres in Hsound.

  assert (WellFormed_Goal nil nil (GGoal (typ := typ) e)) as H1 by constructor.

  assert (WellFormed_ctx_subst (TopSubst (expr typ func) nil (@nil typ))) as H2 by constructor.

  specialize (Hsound H1 H2).

  destruct Hsound as [Hwfs [Hwfg Hsound]].

  unfold propD, exprD'_typ0 in Hsound.

  simpl in Hsound. unfold exprD_Prop, exprD; simpl.

  Require Import ExtLib.Tactics.

  forward; inv_all; subst.



  destruct Hsound.

  inversion Hwfs; subst.

  simpl in H0; inv_all; subst.

  unfold pctxD in H0; inv_all; subst.

  apply H5.

  unfold goalD_Prop in He'. simpl in He'.

  destruct (goalD [] [] goal); congruence.

Qed.



Lemma run_rtac_Solved tac s e

  (Hsound : rtac_sound tac)

  (Hres : run_tac' tac (GGoal e) = Solved s) :

  exprD_Prop tbl nil nil e.

Proof.

  unfold run_tac' in Hres.

  unfold rtac_sound in Hsound.

  assert (WellFormed_Goal nil nil (GGoal (typ := typ) e)) as H1 by constructor.

  assert (WellFormed_ctx_subst (TopSubst (expr typ func) nil (@nil typ))) as H2 by constructor.

  specialize (Hsound _ _ _ _ Hres H1 H2).

  destruct Hsound as [Hwfs Hsound].

  simpl in Hsound.

  unfold propD, exprD'_typ0 in Hsound.

  unfold exprD_Prop.



  simpl in Hsound. unfold exprD. simpl. forward.

  destruct Hsound.

  inversion Hwfs; subst. simpl in H8. inv_all; subst.

  simpl in *.

  admit.

Qed.



End tbled.



Definition symexe tbl e :=

run_tac (SYMEXE_TAC_n 1000 tbl) e .



Definition symexe1 tbl e  :=

run_tac (SYMEXE_TAC_n 1 tbl ) e.



Goal forall (sh : share) (v1 v2 : val), False.

intros.

reify_vst (data_at sh tint v1 v2).

Abort.



Goal forall sh v1 v2, (data_at sh tint v1 v2) |-- (data_at sh tint v1 v2).

intros. simpl reptype in *.

reify_expr_tac.

Eval vm_compute in CANCEL tbl e.

Abort.



Goal forall P Q b,  !!b && P * Q |-- !!b && Q * P .

reify_expr_tac.

Abort.



Goal forall (sh : share), sh = sh.

reify_expr_tac.

Eval vm_compute in run_tac (THEN INTROS (REFLEXIVITYTAC tbl)) e.

Abort.



Existing Instance NullExtension.Espec.



Definition replace_set2 (e : expr typ func) : expr typ func :=

match e with

| App (App (App (App (App (Inj (inr (Smx fsemax))) es)

                     Delta) pre) s) post =>

  let newpre :=

      match pre with

        |  App (App (App (Inj (inr (Smx fassertD))) P)

                    (App (App (Inj (inr (Smx flocalD)))

                              T1) T2)) R =>

           let newT1 := match T1 with

                          | App (App

                                    (Inj (inr (Data (fset tyval n))))

                                    val) T1' =>

                            get_set_reif.set_reif n val T1' tyval

                          | _ => T1

                        end in

           App (App (App (Inj (inr (Smx fassertD))) P)

                    (App (App (Inj (inr (Smx flocalD)))

                              newT1) T2)) R

        | _ => pre

      end in

  App (App (App (App (App (Inj (inr (Smx fsemax))) es)

                     Delta) newpre) s) post

| _ => e

end.



Goal forall sh ty v1 v2, mapsto sh ty v1 v2 = mapsto sh ty v1 v2.

reify_expr_tac.

Eval vm_compute in run_tac (THEN INTROS (REFLEXIVITYTAC tbl)) e.

Abort.



