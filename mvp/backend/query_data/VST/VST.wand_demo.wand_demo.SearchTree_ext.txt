Require Import Perm.
(* Perm:
Check Nat.ltb.       
Locate "_ < _".  
Locate "<?".     

Check Nat.ltb_lt.

Notation  "a >=? b" := (Nat.leb b a)
                          (at level 70, only parsing) : nat_scope.
Notation  "a >? b"  := (Nat.ltb b a)
                       (at level 70, only parsing) : nat_scope.
Notation " a =? b"  := (beq_nat a b)
                       (at level 70) : nat_scope.

Print reflect.

Lemma beq_reflect : forall x y, reflect (x = y) (x =? y).

Lemma blt_reflect : forall x y, reflect (x < y) (x <? y).

Lemma ble_reflect : forall x y, reflect (x <= y) (x <=? y).

Ltac inv H := inversion H; clear H; subst. 

Module Exploration1.

Theorem omega_example1: 
 forall i j k,
    i < j ->
    ~ (k - 3 <= j) ->
   k > i.
Proof.
  intros.

  Search (~ _ <= _ -> _). 
  apply not_le in H0.
  
  Search (_ > _ -> _ > _ -> _ > _).  
  apply gt_trans with j.
  apply gt_trans with (k-3).
  Abort.

Theorem bogus_subtraction: ~ (forall k:nat, k > k - 3).

Theorem omega_example1: 
 forall i j k,
    i < j ->
    ~ (k - 3 <= j) ->
   k > i.

Theorem omega_example2: 
 forall i j k,
    i < j ->
    ~ (k - 3 <= j) ->
   k > i.

Definition maybe_swap (al: list nat) : list nat :=
  match al with
  | a :: b :: ar => if a >? b then b::a::ar else a::b::ar
  | _ => al
  end.

Check (1>2).  
Check (1>?2). 

Locate ">?".  

Print Nat.ltb.

Locate ">=?".

Locate leb.
Print leb.
Print Nat.leb.  

Theorem maybe_swap_idempotent:
  forall al, maybe_swap (maybe_swap al) = maybe_swap al.
Proof.
  intros.
  destruct al as [ | a al].
  simpl.
  reflexivity.
  destruct al as [ | b al].
  simpl.
  reflexivity.
  simpl.

  destruct (b <? a) eqn:H.
  simpl.
  destruct (a <? b) eqn:H0.

  try omega.

Abort.

Theorem maybe_swap_idempotent:
  forall al, maybe_swap (maybe_swap al) = maybe_swap al.

Theorem maybe_swap_idempotent':
  forall al, maybe_swap (maybe_swap al) = maybe_swap al.

Theorem maybe_swap_perm: forall al,
  Permutation al (maybe_swap al).

Definition first_le_second (al: list nat) : Prop :=
  match al with
  | a::b::_ => a <= b
  | _ => True
  end.

Theorem maybe_swap_correct: forall al,
    Permutation al (maybe_swap al) 
    /\ first_le_second (maybe_swap al).

End Exploration1.

Theorem Forall_perm: forall {A} (f: A -> Prop) al bl,
  Permutation al bl ->
  Forall f al -> Forall f bl. *)
Require Import FunctionalExtensionality.
Require Import VFA.SearchTree.

Arguments E {V}.
Arguments T {V} _ _ _ _.

Section TREES.

Variable V : Type.
Variable default: V.

Fixpoint pushdown_left (a: tree V) (bc: tree V) : tree V :=
 match bc with
 | E => a
 | T b y vy c => T (pushdown_left a b) y vy c
 end.

Fixpoint delete (x: key) (s: tree V) : tree V :=
 match s with
 | E => E
 | T a y v' b => if  x <? y then T (delete x a) y v' b
                        else if y <? x then T a y v' (delete x b)
                        else pushdown_left a b
 end.

End TREES.

Arguments insert {V} x v s.
Arguments lookup {V} default x t.
Arguments pushdown_left {V} a bc.
Arguments delete {V} x s.

Section PARTIAL_TREES.

Variable V : Type.
Variable default: V.

Inductive partial_tree : Type :=
 | H : partial_tree
 | L : partial_tree -> key -> V -> tree V -> partial_tree
 | R : tree V -> key -> V -> partial_tree -> partial_tree.

Fixpoint partial_tree_tree (pt: partial_tree): tree V -> tree V :=
  match pt with
  | H => fun t => t
  | L ptl k v t2 => fun t => T (partial_tree_tree ptl t) k v t2
  | R t1 k v pt2 => fun t => T t1 k v (partial_tree_tree pt2 t)
  end.

Fixpoint partial_tree_partial_tree (pt: partial_tree): partial_tree -> partial_tree :=
  match pt with
  | H => fun pt0 => pt0
  | L ptl k v t2 => fun pt0 => L (partial_tree_partial_tree ptl pt0) k v t2
  | R t1 k v pt2 => fun pt0 => R t1 k v (partial_tree_partial_tree pt2 pt0)
  end.

Lemma partial_tree_partial_tree_tree: forall pt1 pt2,
  partial_tree_tree (partial_tree_partial_tree pt1 pt2) = Basics.compose (partial_tree_tree pt1) (partial_tree_tree pt2).
Proof.
  intros.
  extensionality t.
  unfold Basics.compose.
  induction pt1.
  + reflexivity.
  + simpl.
    rewrite IHpt1; auto.
  + simpl.
    rewrite IHpt1; auto.
Qed.

End PARTIAL_TREES.

Arguments H {V}.
Arguments L {V} _ _ _ _.
Arguments R {V} _ _ _ _.
Arguments partial_tree_tree {V} _ _.
Arguments partial_tree_partial_tree {V} _ _.
