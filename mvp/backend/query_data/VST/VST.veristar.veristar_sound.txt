Load loadpath.
Require Import veristar.compare.
(* veristar.compare:
Load loadpath.
Require Import ZArith.
Require Import Coq.Lists.List.
Require Import Sorted.
Require Import Coq.Sorting.Mergesort.
Require Import Permutation.

Definition StrictCompSpec {A} (eq lt: A -> A -> Prop)
                          (cmp: A -> A -> comparison) :=
  StrictOrder lt /\ forall x y, CompSpec eq lt x y (cmp x y).

Definition CompSpec' {A} (cmp: A -> A -> comparison) :=
   StrictCompSpec (@Logic.eq A) (fun x y => Lt = cmp x y) cmp.

Ltac do_comp cspec x y := destruct (CompSpec2Type (proj2 cspec x y)).

Lemma lt_comp: forall {A} lt cmp,
             StrictCompSpec Logic.eq lt cmp ->

Lemma eq_comp: forall {A} lt cmp,
        StrictCompSpec Logic.eq lt cmp ->

Lemma gt_comp: forall {A} lt cmp,
        StrictCompSpec Logic.eq lt cmp ->

Lemma comp_refl: forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
      forall x, cmp x x = Eq.

Lemma comp_eq: forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
   forall x y, Eq = cmp x y -> x=y.

Lemma comp_trans:  forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
      forall x y z, Lt = cmp x y -> Lt = cmp y z -> Lt = cmp x z.

Definition isGe (c: comparison) := match c with Lt => False | _ => True end.
Definition isGeq cc := match cc with Lt => false | _ => true end.

Fixpoint insert {A: Type} (cmp: A -> A -> comparison) (a: A) (l: list A)
  : list A:=
  match l with
  | h :: t => if isGeq (cmp a h)
                 then a :: l
                 else h :: (insert cmp a t)
  | nil => a :: nil
  end.

Fixpoint rsort {A: Type} (cmp: A -> A -> comparison) (l: list A) : list A :=
  match l with nil => nil | h::t => insert cmp h (rsort cmp t)
  end.

Fixpoint insert_uniq {A: Type} (cmp: A -> A -> comparison) (a: A) (l: list A)
  : list A:=
  match l with
  | h :: t => match cmp a h with
              | Eq => l
              | Gt => a :: l
              | Lt => h :: (insert_uniq cmp a t)
              end
  | nil => a::nil
  end.

Fixpoint rsort_uniq {A: Type} (cmp: A -> A -> comparison) (l: list A)
  : list A :=
  match l with nil => nil | h::t => insert_uniq cmp h (rsort_uniq cmp t)
  end.

Lemma perm_insert {T} cmp (a : T) l : Permutation (insert cmp a l) (a :: l).

Fixpoint compare_list {A: Type} (f: A -> A -> comparison) (xl yl : list A)
  : comparison :=
  match xl , yl with
  | x :: xl', y :: yl' => match f x y with
                          | Eq => compare_list f xl' yl'
                          | c => c
                          end
  | nil , _ :: _ => Lt
  | _ :: _ , nil => Gt
  | nil, nil => Eq
  end.

Lemma list_cspec:
  forall  {A} (cmp: A -> A -> comparison) (cmp_spec: CompSpec' cmp),
    CompSpec' (compare_list cmp).

Hint Resolve @list_cspec.

Lemma comp_antisym:  forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
      forall x y, Lt = cmp x y <-> Gt = cmp y x.

Lemma NoDup_rsort_uniq:
  forall {A} (cmp: A -> A -> comparison) (cspec: CompSpec' cmp),
  forall  l, NoDup (rsort_uniq cmp l).

Lemma Forall_sortu:
  forall  {A} (f: A -> Prop) (cmp: A -> A -> comparison) l,
    Forall f l -> Forall f  (rsort_uniq cmp l).

Lemma rsort_uniq_in:
  forall {A} (R: A -> A -> comparison)
          (EQ: forall a b, (a=b) <-> (Eq = R a b))
          x l,
      List.In x (rsort_uniq  R l) <-> List.In x l. *)

Require Import ZArith Coq.Lists.List Permutation Classical.

Require Import VST.msl.Axioms VST.msl.predicates_sa VST.veric.Coqlib2.

Require Import veristar.datatypes veristar.clauses.
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.clauses:
Load loadpath.
Require Import ZArith List Recdef Coq.MSets.MSetInterface Coq.Sorting.Mergesort
               Permutation Coq.MSets.MSetAVL.
Require Import veristar.basic veristar.tactics veristar.variables veristar.datatypes
               veristar.compare veristar.redblack.

Inductive pure_atom := Eqv : expr -> expr -> pure_atom.

Let var1 : var := Z2id 1.
Let var0 : var := Z2id 0.
Let var2 : var := Z2id 2.

Fixpoint list_prio {A} (weight: var) (l: list A) (p: var) : var :=
  match l with
  | nil => p
  | _::l' => list_prio weight l' (add_id weight p)
  end.

Definition prio (gamma delta: list pure_atom) : var :=
    list_prio var2 gamma (list_prio var1 delta var0).

Inductive clause : Type :=
| PureClause : forall (gamma : list pure_atom) (delta : list pure_atom)
                         (priority : var)
                         (prio_ok: prio gamma delta = priority), clause
| PosSpaceClause : forall (gamma : list pure_atom) (delta : list pure_atom)
  (sigma : list space_atom), clause
| NegSpaceClause : forall (gamma : list pure_atom) (sigma : list space_atom)
  (delta : list pure_atom), clause.

Definition expr_cmp e e' :=
 match e, e' with
   | Nil , Nil => Eq
   | Nil, _ => Lt
   | _, Nil => Gt
   | Var v, Var v' => Ident.compare v v'
 end.

Lemma var_cspec : StrictCompSpec (@Logic.eq var) Ident.lt Ident.compare.

Hint Resolve var_cspec.

Lemma expr_cspec: CompSpec' expr_cmp.

Hint Resolve expr_cspec.

Definition pure_atom_cmp (a a': pure_atom) : comparison :=
 match a, a' with
   | Eqv e1 e2, Eqv e1' e2' =>
     match expr_cmp e1 e1' with
       Eq => expr_cmp e2 e2' | c => c
     end
 end.

Hint Rewrite @comp_refl using solve[auto] : comp.

Ltac comp_tac :=
    progress (autorewrite with comp in *; auto)
  || discriminate
  || solve [eapply comp_trans;  eauto]
  || subst
 || match goal with
  | H: Lt = ?A |- context [?A] => rewrite <- H
  | H: Gt = ?A |- context [?A] => rewrite <- H
  | H: Eq = ?A |- context [?A] => rewrite <- H
 end.

Lemma pure_atom_cspec: CompSpec' pure_atom_cmp.

Hint Resolve pure_atom_cspec.

Lemma pure_atom_cmp_eq a b : a = b <-> Eq = pure_atom_cmp a b.
Hint Resolve pure_atom_cmp_eq.

Definition expr_order (t t': expr) := isGe (expr_cmp t t').

Inductive max_expr (t : expr) : pure_atom -> Prop :=
| mexpr_left : forall t', expr_order t t' -> max_expr t (Eqv t t')
| mexpr_right : forall t', expr_order t t' -> max_expr t (Eqv t' t).

Definition order_eqv_pure_atom (a: pure_atom) :=
  match a with
    | Eqv i j => match expr_cmp i j with Lt => Eqv j i | _ => Eqv i j end
  end.

Definition nonreflex_atom a :=
  match a with Eqv i j => match expr_cmp i j with Eq => false | _ => true end
  end.

Definition normalize_atoms pa :=
  rsort_uniq pure_atom_cmp (map order_eqv_pure_atom pa).

Definition mkPureClause (gamma delta: list pure_atom) : clause :=
  PureClause gamma delta _ (eq_refl _).

Definition order_eqv_clause (c: clause) :=
  match c with
  | PureClause pa pa' _ _ =>
        mkPureClause (normalize_atoms (filter nonreflex_atom pa)) (normalize_atoms pa')
  | PosSpaceClause pa pa' sa' =>
    PosSpaceClause (normalize_atoms (filter nonreflex_atom pa))
                   (normalize_atoms pa') sa'
  | NegSpaceClause pa sa pa' =>
    NegSpaceClause (normalize_atoms (filter nonreflex_atom pa)) sa
                   (normalize_atoms pa')
  end.

Definition mk_pureL (a: pn_atom) : clause :=
 match a with
 | Equ x y => mkPureClause nil (order_eqv_pure_atom(Eqv x y)::nil)
 | Nequ x y => mkPureClause (order_eqv_pure_atom(Eqv x y)::nil) nil
 end.

Fixpoint mk_pureR (al: list pn_atom) : list pure_atom * list pure_atom :=
 match al with
 | nil => (nil,nil)
 | Equ x y :: l' => match mk_pureR l' with (p,n) =>
                      (order_eqv_pure_atom(Eqv x y)::p, n) end
 | Nequ x y :: l' => match mk_pureR l' with (p,n) =>
                       (p, order_eqv_pure_atom(Eqv x y)::n) end
 end.

Definition cnf (en: entailment) : list clause :=
 match en with
  Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
   match mk_pureR pureR with (p,n) =>
     map mk_pureL pureL ++ (PosSpaceClause nil nil spaceL :: nil) ++
       match spaceL, spaceR with
       | nil, nil => mkPureClause p n :: nil
       | _, _ => NegSpaceClause p spaceR n :: nil
       end
   end
  end.

Definition pure_atom_geq a b := isGeq (pure_atom_cmp a b).
Definition pure_atom_gt a b := match pure_atom_cmp a b with Gt => true | _ => false end.
Definition pure_atom_eq a b := match pure_atom_cmp a b with Eq => true | _ => false end.
Definition expr_lt a b := match expr_cmp a b with Lt => true | _ => false end.
Definition expr_eq a b := match expr_cmp a b with Eq => true | _ => false end.
Definition expr_geq a b := match expr_cmp a b with Lt => false | _ => true end.

Definition norm_pure_atom (a : pure_atom) :=
  match a with
    | Eqv i j => if expr_lt i j then Eqv j i else Eqv i j
  end.

Definition subst_pure (i: var) (t: expr) (a: pure_atom) :=
 match a with
   | Eqv t1 t2 => Eqv (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pures (i: var) (t: expr) (pa: list pure_atom)
  : list pure_atom := map (subst_pure i t) pa.

Definition compare_space_atom (a b : space_atom) : comparison :=
 match a , b with
  | Next i j , Next i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  | Next i j, Lseg i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Lt
    | Gt => Gt
    end
  | Lseg i j, Next i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Gt
    | Gt => Gt
    end
  | Lseg i j , Lseg i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  end.

Lemma space_atom_cspec: CompSpec' compare_space_atom.

Hint Resolve space_atom_cspec.

Definition compare_clause (cl1 cl2 : clause) : comparison :=
  match cl1 , cl2 with
  | PureClause neg pos _ _ , PureClause neg' pos' _ _ =>
    match compare_list pure_atom_cmp neg neg' with
    | Eq => compare_list pure_atom_cmp pos pos'
    | c => c
    end
  | PureClause _ _ _ _ , _ => Lt
  | _ , PureClause _ _ _ _ => Gt
  | PosSpaceClause gamma delta sigma , PosSpaceClause gamma' delta' sigma'
  | NegSpaceClause gamma sigma delta , NegSpaceClause gamma' sigma' delta' =>
    match compare_list pure_atom_cmp gamma gamma' with
    | Eq => match compare_list pure_atom_cmp delta delta' with
                 | Eq => compare_list compare_space_atom sigma sigma'
                 | c => c
                 end
    | c => c
    end
  | PosSpaceClause _ _ _ , NegSpaceClause _ _ _ => Lt
  | NegSpaceClause _ _ _ , PosSpaceClause _ _ _ => Gt
  end.

Lemma clause_cspec: CompSpec' compare_clause.

Hint Resolve clause_cspec.

Definition rev_cmp {A : Type} (cmp : A -> A -> comparison) :=
  fun a b => match cmp a b with Eq => Eq | Lt => Gt | Gt => Lt end.

Lemma rev_cmp_cspec {A} (c: A -> A -> comparison) :
  CompSpec' c -> CompSpec' (rev_cmp c).

Lemma rev_cmp_eq : forall {A : Type} (cmp : A -> A -> comparison) (x y : A),
  (forall x0 y0 : A, Eq = cmp x0 y0 -> x0 = y0) ->
  Eq = rev_cmp cmp x y -> x = y.

Definition prio1000 := Z2id 1000.
Definition prio1001 := Z2id 1001.

Definition clause_prio (cl : clause) : var :=
  match cl with
  | PureClause gamma delta prio _ => prio
  | PosSpaceClause _ _ _ => prio1000
  | NegSpaceClause gamma sigma delta => prio1001
  end%Z.

Definition compare_clause' (cl1 cl2 : clause) : comparison :=
  match Ident.compare (clause_prio cl1) (clause_prio cl2) with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec': CompSpec' compare_clause'.

Hint Resolve clause_cspec'.

Definition clause_length (cl : clause) : Z :=
  match cl with
  | PureClause gamma delta _ _ => Zlength gamma + Zlength delta
  | PosSpaceClause gamma delta sigma =>
      Zlength gamma + Zlength delta + Zlength sigma
  | NegSpaceClause gamma sigma delta =>
      Zlength gamma + Zlength sigma + Zlength delta
  end%Z.

Definition compare_clause_length (cl1 cl2 : clause) :=
   Zcompare (clause_length cl1) (clause_length cl2).

Definition compare_clause'1 (cl1 cl2 : clause) : comparison :=
  match compare_clause_length cl1 cl2 with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec'1: CompSpec' compare_clause'1.

Hint Resolve clause_cspec'1.

Module OrderedClause <: OrderedType
  with Definition t:=clause
  with Definition compare:=compare_clause'.

Definition t := clause.

Definition eq : clause -> clause -> Prop := Logic.eq.

Lemma eq_equiv : Equivalence eq.

Definition lt (c1 c2 : clause) := Lt = compare_clause' c1 c2.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.

Definition compare := compare_clause'.

Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).

Lemma eq_dec : forall x y, {eq x y}+{~eq x y}.

Lemma lt_strorder : StrictOrder lt.

End OrderedClause.

Module M1 : redblack.MSetPlus
   with Definition E.t := OrderedClause.t
   with Definition E.compare := OrderedClause.compare
   with Definition E.eq := OrderedClause.eq
   with Definition E.lt := OrderedClause.lt
   with Definition E.compare := OrderedClause.compare.
 Include MSetAVL.Make(OrderedClause).
 Definition delete_min (s: t) : option (elt * t) :=
   match min_elt s with
   | Some x => Some (x, remove x s)
   | None => None
  end.
 Lemma delete_min_spec1: forall (s: t) k s',
    delete_min s = Some (k,s') <->
    (min_elt s = Some k /\ remove k s = s').
 Lemma delete_min_spec2: forall s, delete_min s = None <-> Empty s.
Definition mem_add (x: elt) (s: t) : option t :=
 if mem x s then None else Some (add x s).

Lemma mem_add_spec:
    forall x s, mem_add x s = if mem x s then None else Some (add x s).
End M1.

Module M := redblack.Make(OrderedClause).

Definition clause_list2set (l : list clause) : M.t :=
  fold_left (fun s0 c => M.add c s0) l M.empty.

Definition empty_clause : clause := mkPureClause nil nil.

Definition remove_trivial_atoms := filter (fun a =>
  match a with
  | Eqv e1 e2 => match expr_cmp e1 e2 with
                 | Eq => false
                 | _ => true
                 end
  end).

Definition subst_pures_delete (i: var) (e: expr)
  : list pure_atom -> list pure_atom :=
  remove_trivial_atoms oo subst_pures i e.

Definition isEq cc := match cc with Eq => true | _ => false end.

Definition eq_space_atom (a b : space_atom) : bool :=
  isEq (compare_space_atom a b).

Definition eq_space_atomlist (a b : list space_atom) : bool :=
  isEq (compare_list compare_space_atom a b).

Definition eq_var i j : bool := isEq (Ident.compare i j).

Definition drop_reflex_lseg : list space_atom -> list space_atom :=
  filter (fun sa =>
                    match sa with
                    | Lseg (Var x) (Var y) => negb (eq_var x y)
                    | Lseg Nil Nil => false
                    | _ => true
                    end).

Definition order_eqv_pure_atoms := map order_eqv_pure_atom.

Definition greater_than_expr (i: var) (e: expr) :=
  match e with Var j => match Ident.compare i j with Gt => true | _ => false end
                        | Nil => true
  end.

Definition greatereq_than_expr (i: var) (e: expr) :=
  match e with
  | Var j => match Ident.compare i j with Gt => true | Eq => true | Lt => false
             end
  | Nil => true
  end.

Definition greater_than_atom (s u : pure_atom) :=
  match s , u with
  | Eqv s t , Eqv u v =>
    ((expr_lt u s && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v s && (expr_geq s u || expr_geq t u))) ||
    ((expr_lt u t && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v t && (expr_geq s u || expr_geq t u)))
  end.

Definition greater_than_atoms (s : pure_atom) (delta : list pure_atom) :=
  forallb (fun u => greater_than_atom s u) delta.

Definition greater_than_all (i: var) : list pure_atom -> bool :=
  forallb (fun a => match a with Eqv x y =>
             andb (greater_than_expr i x) (greater_than_expr i y) end).

Definition subst_clause i e cl : clause :=
  match cl with
  | PureClause pa pa' _ _ =>
      mkPureClause (subst_pures_delete i e pa) (subst_pures i e pa')
  | NegSpaceClause pa sa pa' =>
      NegSpaceClause (subst_pures_delete i e pa) (subst_spaces i e sa)
                     (subst_pures i e pa')
  | PosSpaceClause pa pa' sa' =>
      PosSpaceClause (subst_pures_delete i e pa) (subst_pures i e pa')
                     (subst_spaces i e sa')
  end.

Definition var_eqZ v v' := Ident.eq v v'.

Lemma eq_pos_var_eqZ v v' : true = eq_var v v' -> var_eqZ v v'.

Definition ocons {A : Type} (o : option A) l :=
  match o with Some a => a :: l | None => l end.

Fixpoint omapl {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | a :: l' => ocons (f a) (omapl f l')
  | nil => nil
  end.

Fixpoint merge {A: Type} (cmp : A -> A -> comparison) l1 l2 :=
  let fix merge_aux l2 :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      match cmp a1 a2 with
      | Eq => a1 :: merge cmp l1' l2'
      | Gt => a1 :: merge cmp l1' l2
      | _ => a2 :: merge_aux l2' end
  end
  in merge_aux l2.

Notation sortu_atms := (rsort_uniq pure_atom_cmp).
Notation insu_atm := (insert_uniq pure_atom_cmp).
Notation sortu_clauses := (rsort_uniq compare_clause).

Lemma compare_clause_eq_equivalence:
     RelationClasses.Equivalence (fun c1 c2 => Eq = compare_clause c1 c2).

Lemma pure_clause_ext:
  forall gamma delta p Pp p' Pp',
     PureClause gamma delta p Pp = PureClause gamma delta p' Pp'.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.

Lemma mem_spec': forall s x, M.mem x s = false <-> ~M.In x s.

Lemma is_empty_spec': forall s, M.is_empty s = false <-> ~M.Empty s.

Lemma empty_set_elems':
  forall s, M.Empty s <-> M.elements s = nil.

Lemma Melements_spec1: forall (s: M.t) x, List.In x (M.elements s) <-> M.In x s.

Require Import Finite_sets_facts.
Require Import VST.msl.Axioms.

Lemma Mcardinal_spec': forall s,   cardinal _ (Basics.flip M.In s) (M.cardinal s).

Lemma remove_decreases:
  forall giv unselected,
  M.In giv unselected ->

Definition pure_atom2pn_atom (b : bool) (a : pure_atom) :=
  match a with
  | Eqv e1 e2 => if b then Equ e1 e2 else Nequ e1 e2
  end.

Definition pn_atom_cmp (a1 a2 : pn_atom) : comparison :=
  match a1, a2 with
  | Equ e1 e2, Equ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Equ e1' e2' =>
    if expr_eq e1 e1' then Gt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Equ e1 e2, Nequ e1' e2' =>
    if expr_eq e1 e1' then Lt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Nequ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  end.

Definition pure_clause2pn_list (c : clause) :=
  match c with
  | PureClause gamma delta _ _ =>
    rsort pn_atom_cmp
      (map (pure_atom2pn_atom false) gamma ++ map (pure_atom2pn_atom true) delta)
  | _ => nil
  end.

Definition compare_clause2 (cl1 cl2 : clause) :=
  match cl1, cl2 with
  | PureClause _ _ _ _, PureClause _ _ _ _ =>
    compare_list pn_atom_cmp (pure_clause2pn_list cl1) (pure_clause2pn_list cl2)
  | _, _ => compare_clause cl1 cl2
  end.

Lemma compare_clause_eq cl1 cl2 : Eq = compare_clause cl1 cl2 -> cl1 = cl2.

Inductive ce_type := CexpL | CexpR | CexpEf.

Module DebuggingHooks.

Definition print_new_pures_set (s: M.t) := s.

Definition print_wf_set (s: M.t) := s.

Definition print_unfold_set (s: M.t) := s.

Definition print_inferred_list (l: list clause) := l.

Definition print_pures_list (l: list clause) := l.

Definition print_eqs_list (l: list clause) := l.

Definition print_spatial_model (c: clause) (R: list (var * expr)) := c.

Definition print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.

Definition print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
  := (R, cl, ct).

End DebuggingHooks.

Export DebuggingHooks.

Hint Unfold print_new_pures_set print_wf_set print_inferred_list print_spatial_model
            print_pures_list print_eqs_list
  : DEBUG_UNFOLD. *)

Require Import veristar.heapresolve veristar.veristar.
(* veristar.heapresolve:
Load loadpath.
Require Import ZArith Znumtheory Coq.Lists.List.
Require Import veristar.variables veristar.datatypes veristar.clauses
               veristar.superpose veristar.basic veristar.compare.
Import Superposition.
Require Recdef.

Module HeapResolve.

Definition normalize1_3 (pc sc : clause) : clause :=
  match pc , sc with
  | PureClause gamma (Eqv (Var x) y :: delta) _ _,
    PosSpaceClause gamma' delta' sigma =>
        PosSpaceClause (rsort_uniq pure_atom_cmp (gamma++gamma'))
                       (rsort_uniq pure_atom_cmp (delta++delta'))
                       (subst_spaces x y sigma)
  | PureClause gamma (Eqv (Var x) y :: delta) _ _,
    NegSpaceClause gamma' sigma delta' =>
         NegSpaceClause (rsort_uniq pure_atom_cmp (gamma++gamma'))
                        (subst_spaces x y sigma)
                        (rsort_uniq pure_atom_cmp (delta++delta'))
  | _ , _  => sc
  end.

Definition normalize2_4 (sc : clause) : clause :=
  match sc with
  | PosSpaceClause gamma delta sigma =>
        PosSpaceClause gamma delta (drop_reflex_lseg sigma)
  | NegSpaceClause gamma sigma delta =>
        NegSpaceClause gamma (drop_reflex_lseg sigma) delta
  | _ => sc
  end.

Definition norm (s:  M.t) (sc: clause) : clause :=
  normalize2_4 (List.fold_right normalize1_3 sc
    (rsort (rev_cmp compare_clause2) (M.elements s))).

Fixpoint do_well1_2 (sc: list space_atom) : list (list pure_atom) :=
  match sc with
  | Next Nil _ :: sc' => nil :: do_well1_2 sc'
  | Lseg Nil y :: sc' => [Eqv y Nil] :: do_well1_2 sc'
  | _ :: sc' => do_well1_2 sc'
  | nil => nil
  end.

Fixpoint next_in_dom (x : Ident.t) (sc : list space_atom) : bool :=
  match sc with
  | nil => false
  | Next (Var x') y :: sc' =>
    if Ident.eq_dec x x' then true
    else next_in_dom x sc'
  | _ :: sc' => next_in_dom x sc'
  end.

Fixpoint next_in_dom1 (x : Ident.t) (y : expr) (sc : list space_atom) : bool :=
  match sc with
  | nil => false
  | Next (Var x') y' :: sc' =>
    if Ident.eq_dec x x' then if expr_eq y y' then true
    else next_in_dom1 x y sc' else next_in_dom1 x y sc'
  | _ :: sc' => next_in_dom1 x y sc'
  end.

Fixpoint next_in_dom2 (x : Ident.t) (y : expr) (sc : list space_atom)
  : option expr :=
  match sc with
  | nil => None
  | Next (Var x') y' :: sc' =>
    if Ident.eq_dec x x' then if expr_eq y y' then next_in_dom2 x y sc'
                                 else Some y'
    else next_in_dom2 x y sc'
  | _ :: sc' => next_in_dom2 x y sc'
  end.

Fixpoint do_well3 (sc: list space_atom) : list (list pure_atom) :=
  match sc with
  | Next (Var x) y :: sc' =>
    if next_in_dom x sc'
      then nil :: do_well3 sc'
      else do_well3 sc'
  | _ :: sc' => do_well3 sc'
  | nil => nil
  end.

Fixpoint lseg_in_dom2 (x : Ident.t) (y : expr) (sc : list space_atom)
  : option expr :=
  match sc with
  | Lseg (Var x' as x0) y0 :: sc' =>
    if Ident.eq_dec x x'
      then if negb (expr_eq y0 y) then Some y0 else lseg_in_dom2 x y sc'
      else lseg_in_dom2 x y sc'
  | _ :: sc' => lseg_in_dom2 x y sc'
  | nil => None
  end.

Fixpoint lseg_in_dom_atoms (x : Ident.t) (sc : list space_atom)
  : list pure_atom :=
  match sc with
  | Lseg (Var x' as x0) y0 :: sc' =>
    if Ident.eq_dec x x'
      then order_eqv_pure_atom (Eqv x0 y0) :: lseg_in_dom_atoms x sc'
      else lseg_in_dom_atoms x sc'
  | _ :: sc' => lseg_in_dom_atoms x sc'
  | nil => nil
  end.

Fixpoint do_well4_5 (sc : list space_atom) : list (list pure_atom) :=
  match sc with
  | Next (Var x') y :: sc' =>
    let atms := map (fun a => [a]) (lseg_in_dom_atoms x' sc') in
      atms ++ do_well4_5 sc'
  | Lseg (Var x' as x0) y :: sc' =>
    let l0 := lseg_in_dom_atoms x' sc' in
      match l0 with
      | nil => do_well4_5 sc'
      | _ :: _ =>
        let atms := map (fun a => normalize_atoms [Eqv x0 y, a]) l0 in
          atms ++ do_well4_5 sc'
      end
  | _ as a :: sc' => do_well4_5 sc'
  | nil => nil
  end.

Definition do_well (sc : list space_atom) : list (list pure_atom) :=
  do_well1_2 sc ++ do_well3 sc ++ do_well4_5 sc.

Definition do_wellformed (sc: clause) : M.t :=
 match sc with
 | PosSpaceClause gamma delta sigma =>
   let sigma' := rsort (rev_cmp compare_space_atom) sigma in
     clause_list2set
       (map (fun ats => mkPureClause gamma (normalize_atoms (ats++delta)))
         (do_well sigma'))
 | _ => M.empty
 end.

Definition spatial_resolution (pc nc : clause) : M.t :=
  match pc , nc with
  | PosSpaceClause gamma' delta' sigma' , NegSpaceClause gamma sigma delta =>
    match eq_space_atomlist (rsort compare_space_atom sigma)
                            (rsort compare_space_atom sigma') with
    | true => M.singleton (order_eqv_clause (mkPureClause (gamma++gamma') (delta++delta')))
    | false => M.empty
      end
  | _ , _ => M.empty
  end.

Fixpoint unfolding1' (sigma0 sigma1 sigma2 : list space_atom)
  : list (pure_atom * list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) z :: sigma2' =>
    if next_in_dom1 x' z sigma1
          then
        (Eqv x z,
          insert (rev_cmp compare_space_atom) (Next x z) (rev sigma0 ++ sigma2'))
        :: unfolding1' (Lseg x z :: sigma0) sigma1 sigma2'
      else unfolding1' (Lseg x z :: sigma0) sigma1 sigma2'
  | a :: sigma2' => unfolding1' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfolding1 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding1' nil sigma1 sigma2 in
    let build_clause p :=
      match p with (atm, sigma2') =>
        NegSpaceClause gamma' sigma2'
          (insert_uniq pure_atom_cmp (order_eqv_pure_atom atm) delta')
      end in
      map build_clause l0
  | _ , _ => nil
  end.

Fixpoint unfolding2' (sigma0 sigma1 sigma2 : list space_atom)
  : list (pure_atom * list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) z :: sigma2' =>
    match next_in_dom2 x' z sigma1 with
    | Some y =>
      (Eqv x z,
          insert (rev_cmp compare_space_atom) (Next x y)
            (insert (rev_cmp compare_space_atom) (Lseg y z) (rev sigma0 ++ sigma2')))
        :: unfolding2' (Lseg x z :: sigma0) sigma1 sigma2'
    | None => unfolding2' (Lseg x z :: sigma0) sigma1 sigma2'
    end
  | a :: sigma2' => unfolding2' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfolding2 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding2' nil sigma1 sigma2 in
    let build_clause p :=
      match p with (atm, sigma2') =>
        NegSpaceClause gamma' sigma2'
          (insert_uniq pure_atom_cmp (order_eqv_pure_atom atm) delta')
      end in
      map build_clause l0
  | _ , _ => nil
  end.

Fixpoint unfolding3' (sigma0 sigma1 sigma2 : list space_atom) :
  list (list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) Nil :: sigma2' =>
    match lseg_in_dom2 x' Nil sigma1 with
    | Some y =>
          insert (rev_cmp compare_space_atom) (Lseg x y)
            (insert (rev_cmp compare_space_atom) (Lseg y Nil) (rev sigma0 ++ sigma2'))
        :: unfolding3' (Lseg x Nil :: sigma0) sigma1 sigma2'
    | None => unfolding3' (Lseg x Nil :: sigma0) sigma1 sigma2'
    end
  | a :: sigma2' => unfolding3' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfolding3 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding3' nil sigma1 sigma2 in
    let build_clause sigma2' := NegSpaceClause gamma' sigma2' delta' in
      map build_clause l0
  | _ , _ => nil
  end.

Fixpoint unfolding4NPR' (sigma0 sigma1 sigma2 : list space_atom)
  : list (list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) (Var z' as z) :: sigma2' =>
    match lseg_in_dom2 x' z sigma1 with
    | Some y =>
      if next_in_dom z' sigma1 then
          insert (rev_cmp compare_space_atom) (Lseg x y)
            (insert (rev_cmp compare_space_atom) (Lseg y z) (rev sigma0 ++ sigma2'))
        :: unfolding4NPR' (Lseg x z :: sigma0) sigma1 sigma2'
      else unfolding4NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    | None => unfolding4NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    end
  | a :: sigma2' => unfolding4NPR' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfoldingNPR4 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding4NPR' nil sigma1 sigma2 in
    let build_clause sigma2' := NegSpaceClause gamma' sigma2' delta' in
      map build_clause l0
  | _ , _ => nil
  end.

Definition unfolding4 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding4NPR' nil sigma1 sigma2 in
    let GG' := rsort_uniq pure_atom_cmp (gamma ++ gamma') in
    let DD' := rsort_uniq pure_atom_cmp (delta ++ delta') in
    let build_clause sigma2' := NegSpaceClause GG' sigma2' DD' in
      map build_clause l0
  | _ , _ => nil
  end.

Fixpoint unfolding5NPR' (sigma0 sigma1 sigma2 : list space_atom)
  : list (pure_atom * list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) (Var z' as z) :: sigma2' =>
    match lseg_in_dom2 x' z sigma1 with
    | Some y =>
      let atms := lseg_in_dom_atoms z' sigma1 in
      let build_res atm :=
        (atm,
          insert (rev_cmp compare_space_atom) (Lseg x y)
            (insert (rev_cmp compare_space_atom) (Lseg y z)
              (rev sigma0 ++ sigma2'))) in
        map build_res atms ++ unfolding5NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    | None => unfolding5NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    end
  | a :: sigma2' => unfolding5NPR' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfolding5NPR (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding5NPR' nil sigma1 sigma2 in
    let build_clause p :=
      match p with (atm, sigma2') =>
        NegSpaceClause gamma' sigma2'
          (insert_uniq pure_atom_cmp (order_eqv_pure_atom atm) delta')
      end in
      map build_clause l0
  | _ , _ => nil
  end.

Fixpoint unfolding5NPRALT' (sigma0 sigma1 sigma2 : list space_atom)
  : list (pure_atom * list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) (Var z' as z) :: sigma2' =>
    match lseg_in_dom2 x' z sigma1, lseg_in_dom2 x' z sigma1 with
    | Some y, _ =>
      let atms := lseg_in_dom_atoms z' sigma1 in
      let build_res atm :=
        (atm,
          insert (rev_cmp compare_space_atom) (Lseg x y)
            (insert (rev_cmp compare_space_atom) (Lseg y z)
              (rev sigma0 ++ sigma2'))) in
        map build_res atms ++ unfolding5NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    | None, _ => unfolding5NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    end
  | a :: sigma2' => unfolding5NPR' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfolding5 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding5NPR' nil sigma1 sigma2 in
    let GG' := rsort_uniq pure_atom_cmp (gamma ++ gamma') in
    let DD' := rsort_uniq pure_atom_cmp (delta ++ delta') in
    let build_clause p :=
      match p with (atm, sigma2') =>
        NegSpaceClause GG' sigma2'
          (insert_uniq pure_atom_cmp (order_eqv_pure_atom atm) DD')
      end in
      map build_clause l0
  | _ , _ => nil
  end.

Fixpoint unfolding6NPR' (sigma0 sigma1 sigma2 : list space_atom)
  : list (pure_atom * list space_atom) :=
  match sigma2 with
  | Lseg (Var x' as x) (Var z' as z) :: sigma2' =>
    if Ident.eq_dec x' z' then unfolding6NPR' sigma0 sigma1 sigma2' else
    match lseg_in_dom2 x' z sigma1 with
    | Some y =>
      let atms := lseg_in_dom_atoms z' sigma1 in
      let build_res atm :=
        (atm,
          insert (rev_cmp compare_space_atom) (Lseg x y)
            (insert (rev_cmp compare_space_atom) (Lseg y z)
              (rev sigma0 ++ sigma2'))) in
        map build_res atms ++ unfolding6NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    | None =>
       unfolding6NPR' (Lseg x z :: sigma0) sigma1 sigma2'
    end
  | a :: sigma2' => unfolding6NPR' (a :: sigma0) sigma1 sigma2'
  | nil => nil
  end.

Definition unfolding6 (sc1 sc2 : clause) : list clause :=
  match sc1 , sc2 with
  | PosSpaceClause gamma delta sigma1 , NegSpaceClause gamma' sigma2 delta' =>
    let l0 := unfolding6NPR' nil sigma1 sigma2 in
    let GG' := rsort_uniq pure_atom_cmp (gamma ++ gamma') in
    let DD' := rsort_uniq pure_atom_cmp (delta ++ delta') in
    let build_clause p :=
      match p with (atm, sigma2') =>
        NegSpaceClause GG' sigma2'
          (insert_uniq pure_atom_cmp (order_eqv_pure_atom atm) DD')
      end in
      (map build_clause l0)
  | _ , _ => nil
  end.

Definition mem_add (x: M.elt) (s: M.t) : option M.t :=
 if M.mem x s then None else Some (M.add x s).

Definition add_list_to_set_simple (l: list M.elt) (s: M.t) : M.t :=
  fold_left (Basics.flip M.add) l s.

Fixpoint add_list_to_set (l: list M.elt) (s: M.t) : option M.t :=
 match l with
 | x::xs => match mem_add x s with
                  | None => add_list_to_set xs s
                  | Some s' => Some (add_list_to_set_simple xs s')
                  end
 | nil => None
 end.

Definition do_unfold' pc nc l :=
  unfolding1 pc nc ++
  unfolding2 pc nc ++ unfolding3 pc nc ++
  unfolding4 pc nc ++ unfolding6 pc nc ++ l.

Fixpoint do_unfold (n: nat) (pc : clause) (s : M.t) : M.t :=
  match n with
  | O => s
  | S n' =>
   match add_list_to_set  (M.fold (do_unfold' pc) s nil)  s with
   | Some s'' => do_unfold n' pc s''
   | None => s
   end
  end.

Definition unfolding (pc nc : clause) : M.t :=
  M.fold (fun c => M.union (spatial_resolution pc c))
            (do_unfold 500 pc (M.add nc M.empty)) M.empty.

End HeapResolve. *)
(* veristar.veristar:
Load loadpath.
Require Import ZArith Znumtheory Coq.Lists.List.
Require Import veristar.variables veristar.datatypes veristar.clauses
               veristar.heapresolve.

Require Import veristar.superpose_modelsat.

Import Superposition. Import HeapResolve.
Require Recdef.

Inductive veristar_result :=
| Valid : veristar_result
| C_example : model -> veristar_result
| Aborted : list clause -> clause -> veristar_result.

Module Type VERISTAR.

Parameter check_entailment : entailment -> veristar_result.

End VERISTAR.

Module VeriStar.

Inductive veristar_result :=
| Valid : veristar_result
| C_example : model -> veristar_result
| Aborted : list clause -> clause -> veristar_result.

Definition pureb c := match c with PureClause _ _ _ _ => true | _ => false end.

Definition pure_clauses := filter pureb.

Definition is_empty_clause (c : clause) :=
  match c with PureClause nil nil _ _ => true | _ => false end.

Definition pures := M.filter pureb.

Lemma Ppred_decrease n :
  (n<>1)%positive -> (nat_of_P (Ppred n)<nat_of_P n)%nat.

Section RedundancyElim.
Context {A: Type}.
Variable (cmp: A -> A->comparison).

Definition naive_sublist (l1 l2: list A) :=
  forallb (fun a => existsb (fun b => isEq (cmp a b)) l2) l1.

Fixpoint sublistg (l1 l2: list A) :=
  match l1, l2 with
  | a::l1', b::l2' => andb (isEq (cmp a b)) (sublistg l1' l2')
  | nil, _ => true
  | _::_, nil => false
  end.

Fixpoint sublist (l1 l2: list A) :=
  match l1, l2 with
  | a::l1', b::l2' =>
    if isEq (cmp a b) then sublistg l1' l2' else sublist l1 l2'
  | nil, _ => true
  | _::_, nil => false
  end.

End RedundancyElim.

Definition impl_pure_clause (c d: clause) :=
  match c, d with PureClause gamma delta _ _, PureClause gamma' delta' _ _ =>
    andb (sublist pure_atom_cmp gamma gamma')
             (sublist pure_atom_cmp delta delta')
  | _, _ => false
  end.

Definition relim1 (c: clause) (s: M.t) :=
  M.filter (fun d => negb (impl_pure_clause c d)) s.

Definition incorp (s t : M.t) :=

Implicit Arguments eq_sym.

Definition check_entailment (ent: entailment) : veristar_result :=
  let s := clause_list2set (pure_clauses (map order_eqv_clause (cnf ent)))
  in match ent with
     | Entailment (Assertion pi sigma) (Assertion pi' sigma') =>
       match mk_pureR pi, mk_pureR pi' with
       | (piplus, piminus), (pi'plus, pi'minus) =>
           the_loop 1000000 sigma (NegSpaceClause pi'plus sigma' pi'minus)
             (print_new_pures_set s) empty_clause
       end
     end.

End VeriStar. *)

Require Import veristar.superpose_modelsat.
(* veristar.superpose_modelsat:
Load loadpath.
Require Import ZArith List Bool Recdef.
Require Import Coqlib.
Require Import veristar.variables veristar.datatypes veristar.clauses
               veristar.cclosure veristar.basic veristar.compare.

Module Type SUPERPOSITION.

Definition model := list (var * expr).

Inductive superposition_result : Type :=
| Valid : superposition_result
| C_example : model -> M.t -> superposition_result
| Aborted : list clause -> superposition_result.

Parameter check : entailment -> superposition_result * list clause * M.t*M.t.

Parameter check_clauseset : M.t -> superposition_result * list clause * M.t*M.t.

Parameter is_model_of_PI : model -> clause -> bool.

Parameter rewrite_by : expr -> expr -> pure_atom -> pure_atom.

Parameter demodulate : clause -> clause -> clause.

Parameter simplify : list clause -> clause -> clause.

Parameter simplify_atoms : list clause -> list space_atom -> list space_atom.

End SUPERPOSITION.

Module Superposition <: SUPERPOSITION.

Definition model := list (var * expr).

Inductive superposition_result : Type :=
| Valid : superposition_result
| C_example : model -> M.t -> superposition_result
| Aborted : list clause -> superposition_result.

Definition pure_atom_gt1 a (l: list pure_atom) :=
  match l with b :: _ => pure_atom_gt a b | _ => true end.

Fixpoint ef_aux neg u0 u v pos0 pos l0 : list clause :=
  match pos with
  | (Eqv s t as a2) :: pos' =>
    if expr_eq s u && greater_than_all u0 neg
    then mkPureClause
           (insu_atm (norm_pure_atom (Eqv v t)) neg)
           (insu_atm (norm_pure_atom (Eqv u t))
                 (merge pure_atom_cmp (List.rev pos0) pos)) ::
             ef_aux neg u0 u v (insu_atm a2 pos0) pos' l0
    else l0
  | nil => l0
  end.

Definition ef (cty : ce_type) (c : clause) l0 : list clause :=
  match cty, c with
  | CexpEf, PureClause neg (Eqv (Var u0 as u) v :: pos) _ _ =>
    if greater_than_all u0 neg then ef_aux neg u0 u v nil pos l0
    else l0
  | _, _ => l0
  end.

Definition sp (cty : ce_type) (c d : clause) l0 : list clause :=
  match cty, c, d with
  
  | CexpL, PureClause (Eqv s' v :: neg') pos' _ _,
           PureClause neg (Eqv (Var s0 as s) t :: pos) _ _ =>
    if expr_eq s s' && expr_lt t s && expr_lt v s' &&
       pure_atom_gt1 (Eqv s t) pos && greater_than_all s0 neg
    then mkPureClause
      (insu_atm (norm_pure_atom (Eqv t v)) (merge pure_atom_cmp neg neg'))
      (merge pure_atom_cmp pos pos') :: l0
    else l0
  
  | CexpR, PureClause neg (Eqv (Var s0 as s) t :: pos) _ _,
           PureClause neg' (Eqv (Var s'0 as s') v :: pos') _ _ =>
    if expr_eq s s' && expr_lt t s && expr_lt v s' &&
       pure_atom_gt1 (Eqv s t) pos && pure_atom_gt1 (Eqv s' v) pos' &&
       pure_atom_gt (Eqv s t) (Eqv s' v) &&
       greater_than_all s0 neg && greater_than_all s'0 neg'
    then mkPureClause
      (merge pure_atom_cmp neg neg')
      (insu_atm (norm_pure_atom (Eqv t v)) (merge pure_atom_cmp pos pos')) :: l0
    else l0
  | _, _, _ => l0
  end.

Definition rewrite_expr s t u := if expr_eq s u then t else u.

Definition rewrite_by s t atm :=
  match atm with Eqv u v =>
    if expr_eq s u then if expr_eq s v then norm_pure_atom (Eqv t t)
                        else norm_pure_atom (Eqv t v)
    else if expr_eq s v then norm_pure_atom (Eqv u t)
         else atm
  end.

Definition rewrite_in_space s t atm :=
  match atm with
  | Next u v => Next (rewrite_expr s t u) (rewrite_expr s t v)
  | Lseg u v => Lseg (rewrite_expr s t u) (rewrite_expr s t v)
  end.

Definition rewrite_clause_in_space c atm :=
  match c with
  | PureClause nil [Eqv s t] _ _ => rewrite_in_space s t atm
  | _ => atm
  end.

Definition demodulate (c d : clause) : clause :=
  match c, d with
  | PureClause nil [Eqv s t] _ _, PureClause neg pos _ _ =>
      mkPureClause (map (rewrite_by s t) neg) (map (rewrite_by s t) pos)
  | PureClause nil [Eqv s t] _ _, PosSpaceClause neg pos space =>
      PosSpaceClause (map (rewrite_by s t) neg) (map (rewrite_by s t) pos)
          (map (rewrite_in_space s t) space)
  | PureClause nil [Eqv s t] _ _, NegSpaceClause neg space pos =>
      NegSpaceClause (map (rewrite_by s t) neg) (map (rewrite_in_space s t) space)
          (map (rewrite_by s t) pos)
  | _, _ => d
  end.

Definition delete_resolved (c : clause) : clause :=
  match c with
  | PureClause neg pos _ _ =>
     mkPureClause (sortu_atms (remove_trivial_atoms neg)) (sortu_atms pos)
  | _ => c

  end.

Definition not_taut (c: clause) :=
  negb (match c with
        | PureClause neg pos _ _ =>
          existsb (fun a => existsb (fun b =>
                     pure_atom_eq a b) pos) neg ||
          existsb (fun a =>
            match a with Eqv e1 e2 => expr_eq e1 e2 end) pos
        | _ => false end).

Definition simplify (l : list clause) (c : clause) : clause :=
  delete_resolved (fold_left (fun d c => demodulate c d) l c).

Definition simplify_atoms (l : list clause) (atms : list space_atom)
  : list space_atom :=
  fold_left (fun atms d => map (rewrite_clause_in_space d) atms) l atms.

Definition infer (cty : ce_type) (c : clause) (l : list clause) : list clause :=
  print_inferred_list (rsort_uniq compare_clause
    (filter not_taut (map (simplify nil)
      (ef cty c (fold_left (fun l0 d => sp cty c d l0) l nil))))).

Definition apply_model (R : model) (cl : clause) : clause :=
  fold_right (fun ve => subst_clause (fst ve) (snd ve)) cl R.

Definition is_model_of (R : model) (gamma delta : list pure_atom) : bool :=
  match fold_right (fun ve => subst_pures_delete (fst ve) (snd ve))
               (remove_trivial_atoms gamma) R,
          fold_right (fun ve => subst_pures (fst ve) (snd ve)) delta R with
  | _::_, _ => true
  | nil , delta' => negb (forallb nonreflex_atom delta')
  end.

Definition is_model_of_PI (R: model) (nc :  clause) : bool :=
 match nc with NegSpaceClause pi_plus _ pi_minus =>
  match fold_right (fun ve =>
          subst_pures_delete (fst ve) (snd ve)) (remove_trivial_atoms pi_plus) R,
        fold_right (fun ve =>
          subst_pures (fst ve) (snd ve)) pi_minus R with
  | nil , pi_minus' => forallb nonreflex_atom pi_minus'
  | _ :: _ , _ => false
  end
 | _ => false
 end.

Definition reduces (R: model) (v : var) :=
  existsb (fun ve' => if Ident.eq_dec v (fst ve') then true else false) R.

Definition clause_generate (R : model) (cl : clause)
  : (var * expr * clause) + ce_type :=
  match cl with
  | PureClause gamma (Eqv (Var l' as l) r :: delta) _ _ as c' =>
      if greater_than_expr l' r && greater_than_all l' gamma &&
         greater_than_atoms (Eqv l r) delta
      then if reduces R l' then inr _ CexpR
           else if is_model_of (List.rev R) nil (map (rewrite_by l r) delta)
                then inr _ CexpEf else inl _ (l', r, cl)
      else inr _ CexpL
  | _ => inr _ CexpL
  end.

Fixpoint partial_mod (R : model) (acc l : list clause)
  : (model * list clause) + (model * clause * ce_type) :=
  match l with
  | nil => inl _ (R, acc)
  | (PureClause gamma delta _ _) as cl :: l' =>
      if is_model_of (List.rev R) gamma delta then partial_mod R acc l'
      else match clause_generate R cl with
           | (inl (v, exp, cl')) => partial_mod ((v, exp) :: R) (cl' :: acc) l'
           | (inr cty) => inr _ (print_ce_clause R cl cty)
           end
  | _ => inl _ (R, acc)
  end.

Definition is_empty_clause (cl : clause) :=
  match cl with PureClause nil nil _ _ => true | _ => false end.

Definition is_unit_clause (cl : clause) :=
  match cl with PureClause nil (a :: nil) _ _ => true | _ => false end.

Lemma Ppred_decrease n : (n<>1)%positive -> (nat_of_P (Ppred n)<nat_of_P n)%nat.

Definition purecnf (en: entailment) : M.t :=
  match en with
    Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
    match mk_pureR pureL, mk_pureR pureR with (p, n), (p', n') =>
      let pureplus :=
        map (fun a => mkPureClause nil (norm_pure_atom a::nil)) p in
      let pureminus :=
        map (fun a => mkPureClause (norm_pure_atom a::nil) nil) n in
      let pureplus' := rsort_uniq pure_atom_cmp (map norm_pure_atom p') in
      let pureminus' := rsort_uniq pure_atom_cmp (map norm_pure_atom n') in
      let cl := mkPureClause pureplus' pureminus' in
        clause_list2set (cl :: pureplus ++ pureminus)
    end
  end.

Definition check (ent : entailment)
  : superposition_result * list clause * M.t*M.t :=
  main 1000000 nil (print_pures_list
    (rsort (rev_cmp compare_clause2) (M.elements (purecnf ent)))).

Definition check_clauseset (s : M.t)
  : superposition_result * list clause * M.t*M.t :=
  main 1000000 nil (print_pures_list
    (rsort (rev_cmp compare_clause2) (M.elements (M.filter not_taut s)))).

End Superposition. *)

Require Import veristar.model_type veristar.model.
(* veristar.model_type:
Load loadpath.
Require Import VST.msl.base VST.msl.sepalg.
Require Import veristar.variables.

Module Type VERISTAR_LOGIC.

Parameters loc val : Type.
Declare Instance Join_val: Join val.
Declare Instance Perm_val: Perm_alg val.
Declare Instance Sep_val: Sep_alg val.
Declare Instance Canc_val: Canc_alg val.
Parameter val2loc : val -> option loc.
Parameter nil_val : val.
Axiom nil_not_loc : val2loc nil_val = None.

Parameter empty_val : val.
Axiom emp_empty_val : forall v, identity v <-> v = empty_val.
Definition full (v : val) := forall v2, joins v v2 -> identity v2.
Axiom val2loc_full : forall v l, val2loc v = Some l -> full v.
Axiom nil_full : full nil_val.
Axiom empty_not_full : ~full empty_val.
Axiom val2loc_inj : forall v1 v2 l,
  val2loc v1 = Some l ->  val2loc v2 = Some l -> v1=v2.
Axiom loc_eq_dec : forall l1 l2 : loc, Decidable.decidable (l1=l2).
Axiom nil_dec : forall v, Decidable.decidable (v=nil_val).

Definition var : Type := Ident.t.
Parameter env : Type.
Parameter env_get : env -> var -> val.
Parameter env_set : var -> val -> env -> env.
Axiom gss_env : forall (x : var) (v : val) (s : env),
  v<>empty_val -> env_get (env_set x v s) x = v.
Axiom gso_env : forall (x y : var) (v : val) (s : env),
  x<>y -> env_get (env_set x v s) y = env_get s y.

Axiom env_reset : forall s x, env_set x (env_get s x) s = s.
Axiom env_reset2 : forall s x z, env_set x (env_get s x) (env_set x z s) = s.

Parameter heap : Type.
Declare Instance Join_heap: Join heap.
Declare Instance Perm_heap: Perm_alg heap.
Declare Instance Sep_heap: Sep_alg heap.
Declare Instance Canc_heap: Canc_alg heap.
Parameter rawnext: forall (x: loc) (y : val) (s : heap), Prop.
Parameter emp_at : forall (l: loc) (h: heap), Prop.
Axiom heap_gempty : forall h l, identity h -> emp_at l h.
Definition nil_or_loc (v: val) := v=nil_val \/ exists l, val2loc v = Some l.
Axiom mk_heap_rawnext : forall h x0 x y, val2loc (x0) = Some x ->
  nil_or_loc y -> exists h', rawnext x y h' /\ comparable h h'.
Axiom rawnext_out : forall {x x0 x' y h},
  rawnext x y h -> val2loc x0 = Some x' -> x'<>x -> emp_at x' h.

Definition rawnext' x y h := exists h0, join_sub h0 h /\ rawnext x y h0.

Axiom rawnext_at1 : forall {x y h1 h2 h},
  rawnext' x y h1 -> join h1 h2 h -> emp_at x h2 /\ rawnext' x y h.

Axiom rawnext_at2 : forall {x y h1 h2 h},
  join h1 h2 h -> rawnext' x y h -> emp_at x h2 -> rawnext' x y h1.

Axiom  rawnext_not_emp : forall {x y h}, rawnext' x y h -> ~emp_at x h.

Axiom emp_at_join: forall {h1 h2 h},
  join h1 h2 h -> forall l, (emp_at l h1 /\ emp_at l h2) <-> emp_at l h.

Axiom rawnext_unique : forall x z z' s s' t t' r,
  rawnext x z s -> rawnext x z' s' -> join s t r -> join s' t' r ->
  z' = z /\ s'=s.

Axiom vars_defined_locs : forall z (e : env),
  exists v, env_get e z = v /\ nil_or_loc v.

End VERISTAR_LOGIC. *)
(* veristar.model:
Load loadpath.
Require Import Coq.ZArith.ZArith Coq.Lists.List.
Require Import VST.msl.base msl.sepalg VST.msl.sepalg_generators msl.Axioms
               VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses veristar.model_type veristar.list_denote.

Module Type VERISTAR_MODEL.
Declare Module VeriStarLogic : VERISTAR_LOGIC.
Import VeriStarLogic.

Inductive lseg : val -> val -> heap -> Prop :=
| lseg_nil : forall x s, identity s -> nil_or_loc x -> lseg x x s
| lseg_cons : forall x x' y s h0 h1 z,
  x<>y -> val2loc x = Some x' ->
  rawnext x' z h0 -> lseg z y h1 -> join h0 h1 s ->
  lseg x y s.

Axiom rawnext2rawnext' : forall {x y h}, rawnext x y h -> rawnext' x y h.

Notation stack := env.

Instance Join_stack : Join stack := Join_equiv stack.
Instance Perm_stack : Perm_alg stack := Perm_equiv stack.
Instance Sep_stack : Sep_alg stack := Sep_equiv stack.
Instance Canc_stack : Canc_alg stack := Canc_equiv stack.

Definition stack_get (s : stack) (x : option var) : val :=
  match x with
  | Some i => env_get s i
  | None => empty_val
  end.

Definition upd_stack (x : var) (v : val) (s : stack) : stack :=
 env_set x v s.

Axiom stack_nil : forall s : stack, stack_get s None = empty_val.

Inductive state := State: forall (s: stack) (h: heap), state.

Definition stk (st : state) := match st with State s h => s end.

Definition hp  (st : state) := match st with State s h => h end.

Instance Join_state : Join state :=
   fun (s1 s2 s3 : state) =>
    join (stk s1) (stk s2) (stk s3) /\ join (hp s1) (hp s2) (hp s3).

Definition state_bij: bijection (heap * stack) state.

Axiom join_state_eq:
  Join_state = Join_bij _ _ _ state_bij.

Declare Instance Perm_state: Perm_alg state.
Declare Instance Sep_state: Sep_alg state.
Declare Instance Canc_state: Canc_alg state.

Definition expr_denote (e : expr) (s : state) : val :=
  match e with Nil => nil_val | Var x => stack_get (stk s) (Some x) end.

Definition var_eq (x y : expr) (s : state) := expr_denote x s = expr_denote y s.
Hint Unfold var_eq : spred.
Infix "===" := var_eq (at level 35, no associativity).

Axiom var_eq_refl : forall x s, (x === x) s.

Axiom var_eq_trans : forall x y z s, (x === y) s -> (y === z) s -> (x === z) s.

Axiom var_eq_sym : forall x y s, (x === y) s -> (y === x) s.

Axiom var_eq_sym' : forall x y, (x === y) = (y === x).

Notation spred := (state -> Prop).

Definition neg (P : spred) : spred := fun s : state => ~P s.
Hint Unfold neg : spred.

Axiom empstate_empheap: forall (s:state), emp s <-> emp (hp s).

Definition pn_atom_denote (a : pn_atom) : spred :=
  match a with Equ e1 e2 => e1 === e2 | Nequ e1 e2 => neg (e1 === e2) end.

Definition pure_atom_denote (a : pure_atom) : spred :=
  match a with Eqv e1 e2 => e1 === e2 end.

Definition space_atom_denote (a : space_atom) : spred :=
  match a with
  | Next x y =>
      fun s => match val2loc (expr_denote x s) with
      | Some l' =>  rawnext l' (expr_denote y s) (hp s)
                          /\ nil_or_loc (expr_denote y s)
      | None => False
      end
  | Lseg x y =>
      fun s => lseg (expr_denote x s) (expr_denote y s) (hp s)
  end.

Definition space_denote (sigma : list space_atom) : spred :=
  list_denote space_atom_denote sepcon emp sigma.

Definition clause_denote (c : clause) : spred := fun s : state =>
  match c with
  | PureClause p p' _ _ =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | NegSpaceClause p space p' =>
      list_denote pure_atom_denote (@andp state) (space_denote space) p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | PosSpaceClause p p' space' =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) (space_denote space') p' s
  end.

Definition assertion_denote (f : assertion) : spred :=
  match f with Assertion pi space =>
    let sd := space_denote space in
    list_denote pn_atom_denote (@andp state) sd pi
  end.

Definition entailment_denote (e : entailment) : Prop :=
  match e with
  | Entailment F G => assertion_denote F |-- assertion_denote G
  end.

Axiom var_nil_or_loc : forall (z : var) (e : env), nil_or_loc (env_get e z).

End VERISTAR_MODEL.

Module VeriStarModel (VSLog : VERISTAR_LOGIC) : VERISTAR_MODEL
  with Module VeriStarLogic := VSLog.

Module VeriStarLogic := VSLog. Import VSLog.

Inductive lseg : val -> val -> heap -> Prop :=
| lseg_nil : forall x s, identity s -> nil_or_loc x -> lseg x x s
| lseg_cons : forall x x' y s h0 h1 z,
  x<>y -> val2loc x = Some x' ->
  rawnext x' z h0 -> lseg z y h1 -> join h0 h1 s ->
  lseg x y s.

Lemma rawnext2rawnext' : forall {x y h}, rawnext x y h -> rawnext' x y h.

Lemma var_nil_or_loc : forall (z : var) (e : env), nil_or_loc (env_get e z).

Notation stack := env.

Instance Join_stack : Join stack := Join_equiv stack.
Instance Perm_stack : Perm_alg stack := Perm_equiv stack.
Instance Sep_stack : Sep_alg stack := Sep_equiv stack.
Instance Canc_stack : Canc_alg stack := Canc_equiv stack.

Definition stack_get (s: stack) (x: option var) : val :=
  match x with
  | Some i => env_get s i
  | None => empty_val
  end.

Definition upd_stack (x : var) (v : val) (s : stack) : stack :=
  env_set x v s.

Lemma stack_nil : forall s : stack, stack_get s None = empty_val.

Inductive state := State: forall (s: stack) (h: heap), state.

Definition stk (st : state) := match st with State s h => s end.

Definition hp  (st : state) := match st with State s h => h end.

Instance Join_state : Join state :=
   fun (s1 s2 s3 : state) =>
    join (stk s1) (stk s2) (stk s3) /\ join (hp s1) (hp s2) (hp s3).

Definition state_bij: bijection (heap * stack) state.

Lemma join_state_eq:
  Join_state = Join_bij _ _ _ state_bij.

Definition expr_denote (e : expr) (s : state) : val :=
  match e with Nil => nil_val | Var x => stack_get (stk s) (Some x) end.

Definition var_eq (x y : expr) (s : state) := expr_denote x s = expr_denote y s.
Hint Unfold var_eq : spred.

Infix "===" := var_eq (at level 35, no associativity).

Lemma var_eq_refl : forall x s, (x === x) s.

Lemma var_eq_trans : forall x y z s, (x === y) s -> (y === z) s -> (x === z) s.

Lemma var_eq_sym : forall x y s, (x === y) s -> (y === x) s.

Lemma var_eq_sym' : forall x y, (x === y) = (y === x).

Notation spred := (state -> Prop).

Lemma empstate_empheap : forall (s:state), emp s <-> emp (hp s).

Definition neg (P : spred) : spred := fun s : state => ~P s.
Hint Unfold neg : spred.

Definition pn_atom_denote (a : pn_atom) : spred :=
  match a with Equ e1 e2 => e1 === e2 | Nequ e1 e2 => neg (e1 === e2) end.

Definition pure_atom_denote (a : pure_atom) : spred :=
  match a with Eqv e1 e2 => e1 === e2 end.

Definition space_atom_denote (a : space_atom) : spred :=
  match a with
  | Next x y =>
      fun s => match val2loc (expr_denote x s) with
      | Some l' =>  rawnext l' (expr_denote y s) (hp s)
                          /\ nil_or_loc (expr_denote y s)
      | None => False
      end
  | Lseg x y =>
      fun s => lseg (expr_denote x s) (expr_denote y s) (hp s)
  end.

Definition space_denote (sigma : list space_atom) : spred :=
  list_denote space_atom_denote sepcon emp sigma.

Definition clause_denote (c : clause) : spred := fun s : state =>
  match c with
  | PureClause p p' _ _ =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | NegSpaceClause p space p' =>
      list_denote pure_atom_denote (@andp state) (space_denote space) p s ->
      list_denote pure_atom_denote (@orp state) FF p' s
  | PosSpaceClause p p' space' =>
      list_denote pure_atom_denote (@andp state) TT p s ->
      list_denote pure_atom_denote (@orp state) (space_denote space') p' s
  end.

Definition assertion_denote (f : assertion) : spred :=
  match f with Assertion pi space =>
    let sd := space_denote space in
    list_denote pn_atom_denote (@andp state) sd pi
  end.

Definition entailment_denote (e : entailment) : Prop :=
  match e with
  | Entailment F G => assertion_denote F |-- assertion_denote G
  end.

End VeriStarModel. *)

Require Import veristar.clausify_sound veristar.norm_sound
(* veristar.clausify_sound:
Load loadpath.
Require Import Coq.ZArith.ZArith Coq.Lists.List Coq.Sorting.Permutation
               Coq.Logic.Classical.
Require Import VST.msl.Axioms VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses veristar.list_denote
               veristar.model_type veristar.model veristar.spred_lemmas
               veristar.basic.

Module Type CLAUSIFY_SOUND.
Declare Module VSM : VERISTAR_MODEL.
Import VSM VeriStarLogic.

Axiom cnf_correct : forall (e : entailment),
  entailment_denote e =
  forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s.

End CLAUSIFY_SOUND.

Module Clausify_Sound (VSM : VERISTAR_MODEL) : CLAUSIFY_SOUND
  with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic.

Module SPredLems := SPredLemmas VSM. Import SPredLems.

Lemma clausify_single_purepos : forall purea,
  listd pure_atom_denote (@andp state) TT (purea :: nil) =
  clause_denote (mkPureClause nil (order_eqv_pure_atom purea :: nil)).

Lemma clausify_single_pureneg : forall purea,
  list_denote (neg oo pure_atom_denote) (@andp state) TT (purea :: nil) =
  clause_denote (mkPureClause (order_eqv_pure_atom purea :: nil) nil).

Lemma clausify_purepos : forall l : list pure_atom,
  list_denote pure_atom_denote (@andp state) TT l =
  list_denote clause_denote (@andp state) TT
    (map (fun a => mkPureClause nil (order_eqv_pure_atom a::nil)) l).

Lemma clausify_pureposP : forall (l : list pure_atom) P,
  list_denote pure_atom_denote (@andp state) P l =
  list_denote clause_denote (@andp state) P
    (map (fun a => mkPureClause nil (order_eqv_pure_atom a::nil)) l).

Lemma clausify_pureneg : forall l : list pure_atom,
  list_denote (neg oo pure_atom_denote) (@andp state) TT l =
  list_denote clause_denote (@andp state) TT
    (map (fun a => mkPureClause (order_eqv_pure_atom a::nil) nil) l).

Lemma clausify_space : forall l : list space_atom,
  space_denote l = clause_denote (PosSpaceClause nil nil l).

Lemma pure_atom_list_neg2 : forall (l: list pure_atom) s,
  (~(list_denote pure_atom_denote (@orp state) FF l s)) =
  list_denote (neg oo pure_atom_denote) (@andp state) TT l s.

Lemma mk_pureR_denote1: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pn_atom_denote inter P pnatoms s ->
  (listd pure_atom_denote inter P purepos s /\
    ~listd pure_atom_denote (@orp state) FF pureneg s).

Lemma mk_pureR_denote2: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pure_atom_denote inter P purepos s ->
  ~ listd pure_atom_denote (@orp state) FF pureneg s ->
  listd pn_atom_denote inter P pnatoms s.

Lemma mk_pureR_denote: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pn_atom_denote inter P pnatoms s =
  (listd pure_atom_denote inter P purepos s /\
    ~listd pure_atom_denote (@orp state) FF pureneg s).

Lemma mk_pureR_denote3: forall pnatoms purepos pureneg P s,
  mk_pureR pnatoms = (purepos, pureneg) ->
  listd pure_atom_denote inter P purepos s ->
  ~ listd pn_atom_denote inter P pnatoms s ->
  listd pure_atom_denote (@orp state) FF pureneg s.

Lemma clausify_succ : forall pnatoms (purepos pureneg : list pure_atom)
  (space : list space_atom) (s : state)
  (Hyp: mk_pureR pnatoms = (purepos, pureneg)),
  (~assertion_denote (Assertion pnatoms space) s) =
  (clause_denote (NegSpaceClause purepos space pureneg) s).

Lemma clausify_succClassic : forall pnatoms (purepos pureneg : list pure_atom)
  (space : list space_atom) (s : state)
  (Hyp: mk_pureR pnatoms = (purepos, pureneg)),
   (assertion_denote (Assertion pnatoms space) s) =
  (~clause_denote (NegSpaceClause purepos space pureneg) s).

Lemma mk_pureL_denote: forall a s,
  clause_denote (mk_pureL a) s -> pn_atom_denote a s.

Lemma mk_pureL_denoteInv: forall a s,
  pn_atom_denote a s -> clause_denote (mk_pureL a) s.

Lemma mk_pureL_denoteEq: forall a,
  pn_atom_denote a = clause_denote (mk_pureL a).

Lemma mk_pureL_clause_denote: forall pi P s,
  listd clause_denote inter P (map mk_pureL pi) s ->
  listd pn_atom_denote inter P pi s.

Lemma mk_pureL_clause_denoteInv: forall pi P s,
  listd pn_atom_denote inter P pi s ->
  listd clause_denote inter P (map mk_pureL pi) s.

Lemma mk_pureL_clause_denoteEq:forall pi P,
  listd pn_atom_denote inter P pi =
  listd clause_denote inter P (map mk_pureL pi).

Lemma listd_pure_atoms_heap_expand atms :
  listd pure_atom_denote inter emp atms |--
  listd pure_atom_denote inter TT atms.

Theorem cnf_correct1 : forall (e : entailment),
  entailment_denote e ->
  forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s.

Theorem cnf_correct2 : forall (e : entailment),
  (forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s) ->
   entailment_denote e.

Theorem cnf_correct : forall (e : entailment),
  entailment_denote e =
  forall s, ~ list_denote clause_denote (@andp state) TT (cnf e) s.

End Clausify_Sound. *)
(* veristar.norm_sound:
Load loadpath.
Require Import ZArith Coq.Lists.List Permutation.
Require Import VST.msl.Axioms veric.Coqlib2.
Require Import VST.msl.predicates_sa.
Require Import veristar.variables veristar.datatypes veristar.list_denote
               veristar.heapresolve veristar.model_type veristar.model
               veristar.superpose veristar.clauses.

Import HeapResolve.

Module Type NORM_SOUND.
Declare Module VSM: VERISTAR_MODEL.
Import VSM VeriStarLogic Superposition.

Axiom norm_sound : forall sigma sc s,
  clause_denote sc s -> setd clause_denote (@andp _) TT sigma s ->
  clause_denote (HeapResolve.norm sigma sc) s.

End NORM_SOUND.

Module Norm_Sound (VSM: VERISTAR_MODEL) : NORM_SOUND with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic Superposition.

Import sepalg.

Lemma subst_expr_sound v e e' s :
  (Var v === e) s -> (expr_denote e' s = expr_denote (subst_expr v e e') s).

Lemma join_var_eq : forall (s0 s1 s : state) x y,
  join s0 s1 s -> (x === y) s0 -> (x === y) s.

Lemma join_var_eq' : forall (s0 s1 s : state) x y,
  join s0 s1 s -> (x === y) s -> (x === y) s0.

Lemma subst_space_atom_sound:
   forall (v : datatypes.var) (e : expr) (s : state) (Heq : (Var v === e) s) sa,

Lemma subst_space_atoms_sound v e sigma s :
  (Var v === e) s ->
  space_denote sigma s = space_denote (map (subst_space v e) sigma) s.

Lemma normalize1_3_sound pc sc s :
  clause_denote pc s -> clause_denote sc s ->
  clause_denote (normalize1_3 pc sc) s.

Require Import Bool.

Lemma empty_state (s : state) : exists s0, emp s0 /\ join s0 s s.

Lemma lseg_nilnil sigma s :
  space_denote sigma s =
  (space_atom_denote (Lseg Nil Nil) * space_denote sigma)%pred s.

Lemma lseg_vv sigma v s :
  space_denote sigma s =
  (space_atom_denote (Lseg (Var v) (Var v)) * space_denote sigma)%pred s.

Lemma drop_reflex_lseg_sound sigma s :
  space_denote sigma s = space_denote (drop_reflex_lseg sigma) s.

Lemma normalize2_4_sound sc s :
  clause_denote sc s -> clause_denote (normalize2_4 sc) s.

Lemma norm_sound sigma sc s :
  clause_denote sc s -> setd clause_denote (@andp _) TT sigma s ->
  clause_denote (norm sigma sc) s.

End Norm_Sound. *)
               veristar.wellformed_sound veristar.unfold_sound.

Require Import veristar.superpose_modelsat_sound.
(* veristar.superpose_modelsat_sound:
Load loadpath.
Require Import ZArith Coq.Lists.List Permutation.
Require Import VST.msl.Axioms VST.veric.Coqlib2.
Require Import VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses veristar.clause_lemmas
               veristar.cclosure veristar.list_denote veristar.superpose_modelsat
               veristar.basic veristar.compare.
Import Superposition.
Require Import veristar.model_type veristar.model.

Module Type SP_SOUND.
Declare Module VSM : VERISTAR_MODEL.
Import VSM VeriStarLogic.

Axiom check_clauseset_Valid_sound: forall init units g u,
  check_clauseset init = (Valid, units, g, u) ->
  setd clause_denote inter TT init |-- clause_denote empty_clause.

Axiom check_clauseset_Cexample_sound: forall init units final empty R selected,
  check_clauseset init = (C_example R selected, units, final, empty) ->
  setd clause_denote inter TT init |--
    setd clause_denote inter TT selected &&
    setd clause_denote inter TT final &&
    listd clause_denote inter TT units.

Axiom simplify_sound : forall l c s,
  listd clause_denote inter TT l s -> clause_denote c s ->
  clause_denote (simplify l c) s.

Axiom simplify_atoms_sound : forall l sigma s,
  listd clause_denote inter TT l s -> space_denote sigma s ->
  space_denote (simplify_atoms l sigma) s.

End SP_SOUND.

Module SP_Sound (VSM : VERISTAR_MODEL) : SP_SOUND with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic.

Module CCS := CCSound VSM. Import CCS.

Implicit Arguments list_denote [A T].
Local Notation "'listd'" := list_denote.

Implicit Arguments andp [A].
Local Notation "'inter'" := (@andp _). 

Require Import Bool.

Definition reflexivity_resolution (d : clause) l0 : list clause :=
  match d with
  | PureClause (Eqv u v :: neg) pos _ _ =>
    if expr_eq u v then mkPureClause neg pos :: l0 else l0
  | _ => l0
  end.

Definition ordered_factoring (c : clause) l0 : list clause :=
  match c with
  | PureClause nil (Eqv s t :: Eqv u v :: pos) _ _ =>
    if pure_atom_eq (Eqv s t) (Eqv u v)
    then mkPureClause nil (insert_uniq pure_atom_cmp
              (norm_pure_atom (Eqv s t)) pos)
                     :: l0
    else l0
  | _ => l0
  end.

Definition positive_superposition (c d : clause) l0 : list clause :=
  match c, d with
  
  | PureClause neg (Eqv (Var s0 as s) t :: pos) _ _,
           PureClause neg' (Eqv (Var s'0 as s') v :: pos') _ _ =>
    if expr_eq s s' && expr_lt t s && expr_lt v s' &&
       pure_atom_gt1 (Eqv s t) pos && pure_atom_gt1 (Eqv s' v) pos' &&
       pure_atom_gt (Eqv s t) (Eqv s' v) &&
       greater_than_all s0 neg && greater_than_all s'0 neg'
    then mkPureClause
      (merge pure_atom_cmp neg neg')
      (insu_atm (norm_pure_atom (Eqv t v)) (merge pure_atom_cmp pos pos')) :: l0
    else l0
  | _, _ => l0
  end.

Definition negative_superposition (c d : clause) l0 : list clause :=
  match c, d with
  
  | PureClause (Eqv s' v :: neg') pos' _ _,
        PureClause neg (Eqv (Var s0 as s) t :: pos) _ _ =>
    if expr_eq s s' && expr_lt t s && expr_lt v s' &&
       pure_atom_gt1 (Eqv s t) pos && greater_than_all s0 neg
    then mkPureClause
      (insu_atm (norm_pure_atom (Eqv t v)) (merge pure_atom_cmp neg neg'))
      (merge pure_atom_cmp pos pos') :: l0
    else l0
  | _, _ => l0
  end.

Lemma positive_superposition_sound c d l0 s :
  clause_denote c s -> clause_denote d s -> listd clause_denote inter TT l0 s ->
  listd clause_denote inter TT (positive_superposition c d l0) s.

Lemma negative_superposition_sound c d l0 s :
  clause_denote c s -> clause_denote d s -> listd clause_denote inter TT l0 s ->
  listd clause_denote inter TT (negative_superposition c d l0) s.

Lemma reflexivity_resolution_sound c l0 s :
  clause_denote c s -> listd clause_denote inter TT l0 s ->
  listd clause_denote inter TT (reflexivity_resolution c l0) s.

Lemma ordered_factoring_sound c l0 s :
  clause_denote c s -> listd clause_denote inter TT l0 s ->
  listd clause_denote inter TT (ordered_factoring c l0) s.

Lemma sp_sound ce c d l0 s :
  clause_denote c s -> clause_denote d s -> listd clause_denote inter TT l0 s ->
  listd clause_denote inter TT (sp ce c d l0) s.

Lemma ef_aux_sound neg u0 u v pos0 pos l0 s :
  (listd pure_atom_denote inter TT neg s ->
    listd pure_atom_denote un FF
        (merge pure_atom_cmp (List.rev pos0) (Eqv (Var u0) v :: pos)) s) ->

Lemma ef_sound ce c l0 s :
  clause_denote c s -> listd clause_denote inter TT l0 s ->
  listd clause_denote inter TT (ef ce c l0) s.

Lemma remove_trivial_atoms_sound b atms s :
  listd pure_atom_denote inter b atms s ->
  listd pure_atom_denote inter b (remove_trivial_atoms atms) s.

Lemma remove_trivial_atoms_equiv b atms s :
  listd pure_atom_denote inter b (remove_trivial_atoms atms) s <->
  listd pure_atom_denote inter b atms s.

Lemma delete_resolved_sound c s :
  clause_denote c s -> clause_denote (delete_resolved c) s.

Lemma rewrite_by_eqv s t atm st :
  (s === t) st ->
  pure_atom_denote atm st = pure_atom_denote (rewrite_by s t atm) st.

Lemma rewrite_by_sound s t atm st :
  (s === t) st -> pure_atom_denote atm st ->
  pure_atom_denote (rewrite_by s t atm) st.

Lemma rewrite_by_complete s t atm st :
  (s === t) st -> pure_atom_denote (rewrite_by s t atm) st ->
  pure_atom_denote atm st.

Lemma clause_denote_foldl (f: clause -> clause -> clause) l c0 s :
  listd clause_denote inter TT l s -> clause_denote c0 s ->
  (forall c d, clause_denote c s -> clause_denote d s ->
               clause_denote (f c d) s) ->
  clause_denote (fold_left f l c0) s.

Lemma rewrite_expr_eqv s t u st : (s === t) st -> (u === rewrite_expr s t u) st.

Lemma var_eq_join_sub e1 e2 (x y s : state) :
  sepalg.join x y s -> ((e1 === e2) s <-> (e1 === e2) x).

Lemma rewrite_clause_in_space_sound a b p1 p2 sigma0 st :
  clause_denote (PureClause nil [Eqv a b] p1 p2) st ->
  space_denote sigma0 st ->
  space_denote (map (rewrite_clause_in_space (PureClause nil [Eqv a b] p1 p2))
    sigma0) st.

Lemma rewrite_in_space_eqv e1 e2 a st :
  (e1 === e2) st ->
  (space_atom_denote (rewrite_in_space e1 e2 a) st <-> space_atom_denote a st).

Lemma rewrite_in_space_sound e1 e2 sigma0 st :
  (e1 === e2) st ->
  space_denote sigma0 st ->
  space_denote (map (rewrite_in_space e1 e2) sigma0) st.

Lemma demodulate_sound c d s :
  clause_denote c s -> clause_denote d s -> clause_denote (demodulate c d) s.

Lemma simplify_sound l c s :
  listd clause_denote inter TT l s -> clause_denote c s ->
  clause_denote (simplify l c) s.

Lemma space_denote_foldl
  (f: list space_atom -> clause -> list space_atom) l sigma0 s :
    listd clause_denote inter TT l s -> space_denote sigma0 s ->
    (forall c sigma, clause_denote c s -> space_denote sigma s ->
                 space_denote (f sigma c) s) ->
  space_denote (fold_left f l sigma0) s.

Lemma space_denote_map_id sigma0 st :
  space_denote sigma0 st ->
  space_denote (map (fun atm : space_atom => atm) sigma0) st.

Lemma simplify_atoms_sound l sigma st :
  listd clause_denote inter TT l st -> space_denote sigma st ->
  space_denote (simplify_atoms l sigma) st.

Lemma infer_list_sound ce c l s :
  clause_denote c s -> listd clause_denote inter TT l s ->
  listd clause_denote inter TT (infer ce c l) s.

Lemma clause_generate_sound R c c' v e s :
  clause_denote c s -> clause_generate R c = inl _ (v, e, c') ->
  clause_denote c' s.

Lemma partial_mod_sound1 R R' acc l l' s :
  listd clause_denote inter TT l s -> listd clause_denote inter TT acc s ->
  partial_mod R acc l = inl _ (R', l') ->
  listd clause_denote inter TT l' s.

Lemma partial_mod_sound2 R R' acc l c ce s :
  listd clause_denote inter TT l s -> listd clause_denote inter TT acc s ->
  partial_mod R acc l = inr _ (R', c, ce) -> clause_denote c s.

Lemma main_sound n l r units0 units given unselected s :
  listd clause_denote inter TT l s ->
  listd clause_denote inter TT units0 s ->
  main n units0 l = (r, units, given, unselected) ->
  setd clause_denote inter TT given s /\ listd clause_denote inter TT units s.

Lemma main_Cexample_sound n l R sel units given unselected s :
  listd clause_denote inter TT l s ->
  main n nil l = (C_example R sel, units, given, unselected) ->
  setd clause_denote inter TT sel s.

Lemma empty_clause_False c s :
  is_empty_clause c = true -> ~(clause_denote c s).

Lemma main_Valid_empty_clause n l units final empty s :
  listd clause_denote inter TT l s ->
  ~(main n nil l = (Valid, units, final, empty)).

Lemma check_clauseset_Valid_sound init units g u :
  check_clauseset init = (Valid, units, g, u) ->
  setd clause_denote inter TT init |-- clause_denote empty_clause.

Lemma check_clauseset_Cexample_sound init units final empty R selected :
  check_clauseset init = (C_example R selected, units, final, empty) ->
  setd clause_denote inter TT init |--
    setd clause_denote inter TT selected &&
    setd clause_denote inter TT final &&
    listd clause_denote inter TT units.

End SP_Sound. *)

Require Import veristar.list_denote veristar.clause_lemmas.
(* veristar.list_denote:
Load loadpath.
Require Import Coq.Lists.List Permutation veric.Coqlib2.
Require Import VST.msl.Axioms msl.sepalg VST.msl.predicates_sa msl.base
               veristar.variables veristar.datatypes
               veristar.clauses veristar.basic veristar.compare.

Section ListDenote.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Fixpoint list_denote l : T :=
  match l with nil => b | x :: l' => g (f x) (list_denote l')
  end.

Local Notation "'listd'" := (list_denote).

Lemma listd_fold_right l :
  listd l = fold_right (fun x y  => g (f x) y) b l.

End ListDenote.

Notation "'listd'" := (list_denote).

Lemma listd_app {A T} f g (b : T) (l l' : list A) :
  listd f g b (l ++ l') =
  listd f g (listd f g b l') l.

Section ListDenoteLems.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).

Lemma listd_nil : listd f g b nil = b.

Lemma listd_cons a l :
  listd f g b (a :: l) = g (f a) (listd f g b l).

Lemma listd_map h l (Hgh_eq : forall a b', g (f (h a)) b' = g (f a) b') :
  listd f g b (map h l) = listd f g b l.

Lemma listd_filter h l (H : forall a b', false=h a -> g (f a) b' = b') :
  listd f g b (filter h l) = listd f g b l.

Lemma listd_flat_map h l (H : forall a b', g (f a) b' = listd f g b' (h a)) :
  listd f g b l = listd f g b (flat_map h l).

Lemma listd_compose h1 h2 l
  (Hh1 : forall l, listd f g b l = listd f g b (h1 l))
  (Hh2 : forall l, listd f g b l = listd f g b (h2 l)) :
  listd f g b l = listd f g b ((h1 oo h2) l).

End ListDenoteLems.

Section ListDenoteAS.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma fgAS b' (t t' : T) : g t (g t' b') = g t' (g t b').

Lemma listdAS a l : listd f g (g (f a) b) l = g (f a) (listd f g b l).

Lemma listd_AS_unit un l (un_unit : forall x, g x un = x) :
  listd f g b l = g b (listd f g un l).

Lemma listd_perm l l' (Hperm : Permutation l l') :
  listd f g b l = listd f g b l'.

End ListDenoteAS.

Section ListDenoteConj.
Context {A : Type}.
Variables (f : A -> Prop) (g : Prop -> Prop -> Prop) (b : Prop).
Variable (gconj : forall x y, g x y -> y).

Lemma listd_conj a l : listd f g b (a :: l) -> listd f g b l.

Context {B : Type}.
Variables (h : A -> pred B) (k : pred B -> pred B -> pred B) (b0 : pred B).
Variable (hconj : forall x y b, k x y b -> y b).

Lemma listd_conjP a l : forall b, listd h k b0 (a :: l) b -> listd h k b0 l b.

End ListDenoteConj.

Section ListDenoteProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).

Lemma andS (x y : Prop) : and x y = and y x.

Lemma andA x y z : and x (and y z) = and (and x y) z.

Lemma orS (x y : Prop) : or x y = or y x.

Lemma orA x y z : or x (or y z) = or (or x y) z.

Lemma listd_conj_and a l : listd f and True (a :: l) -> listd f and True l.

Lemma listd_unfold_and l : listd f and b l = (listd f and True l /\ b).

Lemma listd_unfold_or l : listd f or b l = (listd f or False l \/ b).

Lemma listd_flat_map_and h l
  (H : forall a b', and (f a) b' -> listd f and b' (h a)) :
  listd f and b l -> listd f and b (flat_map h l).

Lemma listd_In_prop l : (forall a, In a l -> f a) -> listd f and True l.

Lemma listd_In_inv_prop a l : listd f and True l -> In a l -> f a.

End ListDenoteProp.

Section ListDenoteProp1.
Context {A : Type}.
Variables (f : A -> Prop).

Lemma listd_unfold_app_and b l l' :
  listd f and b (l ++ l') = (listd f and True l /\ listd f and b l').

Lemma listd_unfold_app_or b l l' :
  listd f or b (l ++ l') = (listd f or False l \/ listd f or b l').

End ListDenoteProp1.

Lemma union_com {A} : forall (P Q: pred A), ((P || Q) = (Q || P))%pred.

Lemma union_assoc {A} : forall (P Q R: pred A),
  ((P || Q) || R = P || (Q || R))%pred.

Notation "'inter'" := (@andp _).
Notation "'un'" := (@orp _).

Section ListDenotePred.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).

Lemma listd_conj_inter a l :
  forall b', listd f inter TT (a :: l) b' -> listd f inter TT l b'.

Lemma listd_unfold_inter l : listd f inter b l = (listd f inter TT l && b)%pred.

Lemma listd_unfold_un l : listd f un b l = (listd f un FF l || b)%pred.

Lemma listd_flat_map_inter h l s
  (H : forall a b', inter (f a) b' s -> listd f inter b' (h a) s) :
  listd f inter b l s -> listd f inter b (flat_map h l) s.

Lemma listd_In_pred l s :
  (forall a, In a l -> f a s) -> b s -> listd f inter b l s.

Lemma listd_In_inv_pred a l s : listd f inter TT l s -> In a l -> f a s.

Lemma listd_In_pred_un l s :
  (exists a, In a l /\ f a s) \/ b s -> listd f un b l s.

Lemma listd_In_inv_pred_un l s :
  listd f un b l s -> (exists a, In a l /\ f a s) \/ b s.

Lemma listd_map_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> g (h a) s) :
  listd f inter TT l s -> listd g inter TT (map h l) s.

Lemma listd_omapl_pred {C : Type} h (g : C -> pred B) l s
  (H : forall a, f a s -> match h a with Some a' => g a' s | None => True end) :
  listd f inter TT l s -> listd g inter TT (omapl h l) s.

Lemma listd_foldr_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h a x) s) :
  f c0 s -> listd f inter TT l s -> f (fold_right h c0 l) s.

Lemma listd_foldl_pred h c0 l s
  (H : forall a x, f a s -> f x s -> f (h x a) s) :
  f c0 s -> listd f inter TT l s -> f (fold_left h l c0) s.

Lemma listd_filter_pred h l s :
  listd f inter TT l s -> listd f inter TT (filter h l) s.

Lemma listd_partition_pred h l xs ys s (H : partition h l = (xs, ys)) :
  listd f inter TT l s ->
    listd f inter TT xs s /\ listd f inter TT ys s.

End ListDenotePred.

Section ListDenotePred1.
Context {A B : Type}.
Variables (f : A -> pred B).

Lemma listd_unfold_app_inter b l l' :
  listd f inter b (l ++ l') = (listd f inter TT l && listd f inter b l')%pred.

Lemma listd_unfold_app_un b l l' :
  listd f un b (l ++ l') = (listd f un FF l || listd f un b l')%pred.

End ListDenotePred1.

Section ListDenoteInsert.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).

Lemma listd_insert cmp a l :
  listd f g b (insert cmp a l) = g (f a) (listd f g b l).

Lemma listd_sort cmp l : listd f g b (rsort cmp l) = listd f g b l.

End ListDenoteInsert.

Section ListDenoteInsertUniq.
Context {A T : Type}.
Variables (f : A -> T) (g : T -> T -> T) (b : T).
Variable (gS : forall x y, g x y = g y x).
Variable (gA : forall x y z, g x (g y z) = g (g x y) z).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y ->
  forall b, g (f x) (g (f y) b) = g (f y) b).

Lemma listd_insert_uniq a l :
  listd f g b (insert_uniq cmp a l) = g (f a) (list_denote f g b l).

Lemma listd_sort_uniq l : listd f g b (rsort_uniq cmp l) = listd f g b l.

End ListDenoteInsertUniq.

Section ListDenoteSortProp.
Context {A : Type}.
Variable (f : A -> Prop) (b : Prop).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_and cmp a l :
  listd f and b (insert cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_and cmp l :
  listd f and b (rsort cmp l) = listd f and b l.

Lemma listd_insert_or cmp a l :
  listd f or b (insert cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_or cmp l :
  listd f or b (rsort cmp l) = listd f or b l.

End ListDenoteSortProp.

Section ListDenoteInsertPred.

Context {A B : Type}.
Variable (f : A -> pred B) (b : pred B).

Lemma interS (x y : pred B) : inter x y = inter y x.

Lemma interA (x y z : pred B) : inter x (inter y z) = inter (inter x y) z.

Lemma unS (x y : pred B) : un x y = un y x.

Lemma unA (x y z : pred B) : un x (un y z) = un (un x y) z.

Variables (JB: Join B) (PB: Perm_alg B)(SB: Sep_alg B).

Lemma sepconS (x y : pred B) : sepcon x y = sepcon y x.

Lemma sepconA (x y z : pred B) :
  sepcon x (sepcon y z) = sepcon (sepcon x y) z.

Local Hint Resolve interS interA unS unA sepconS sepconA.

Lemma listd_insert_inter cmp a l :
  listd f inter b (insert cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_inter cmp l :
  listd f inter b (rsort cmp l) = listd f inter b l.

Lemma listd_insert_un cmp a l :
  listd f un b (insert cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_un cmp l : listd f un b (rsort cmp l) = listd f un b l.

Lemma listd_insert_sepcon cmp a l :
  listd f sepcon b (insert cmp a l) = sepcon (f a) (listd f sepcon b l).

Lemma listd_sort_sepcon cmp l :
  listd f sepcon b (rsort cmp l) = listd f sepcon b l.

End ListDenoteInsertPred.

Section ListDenoteSortUniqProp.
Context {A : Type}.
Variables (f : A -> Prop) (b : Prop).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve andS andA orS orA.

Lemma listd_insert_uniq_and a l :
  listd f and b (insert_uniq cmp a l) = and (f a) (listd f and b l).

Lemma list_sort_uniq_and l :
  listd f and b (rsort_uniq cmp l) = listd f and b l.

Lemma listd_insert_uniq_or a l :
  listd f or b (insert_uniq cmp a l) = or (f a) (listd f or b l).

Lemma listd_sort_uniq_or l :
  listd f or b (rsort_uniq cmp l) = listd f or b l.

End ListDenoteSortUniqProp.

Section ListDenoteSortUniqPreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Local Hint Resolve (@interS B) (@interA B) (@unS B) (@unA B).

Lemma listd_insert_uniq_inter a l :
  listd f inter b (insert_uniq cmp a l) = inter (f a) (listd f inter b l).

Lemma listd_sort_uniq_inter l :
  listd f inter b (rsort_uniq cmp l) = listd f inter b l.

Lemma listd_insert_uniq_un a l :
  listd f un b (insert_uniq cmp a l) = un (f a) (listd f un b l).

Lemma listd_sort_uniq_un l :
  listd f un b (rsort_uniq cmp l) = listd f un b l.

End ListDenoteSortUniqPreds.

Section ListDenoteMergePreds.
Context {A B : Type}.
Variables (f : A -> pred B) (b : pred B).
Variable (cmp : A -> A -> comparison).
Variable (Hcmp : forall x y, Eq = cmp x y -> x = y).

Lemma listd_merge_inter l1 l2 s :
  listd f inter TT l1 s -> listd f inter TT l2 s ->
  listd f inter TT (merge cmp l1 l2) s.

Lemma merge_nil l : merge cmp l nil = l.

Lemma merge_nil' l : merge cmp nil l = l.

Lemma merge_cons_unfold a1 a2 l1 l2 :
  merge cmp (a1 :: l1) (a2 :: l2) = match cmp a1 a2 with
                                      | Eq => a1 :: merge cmp l1 l2
                                      | Gt => a1 :: merge cmp l1 (a2 :: l2)
                                      | Lt => a2 :: merge cmp (a1 :: l1) l2
                                    end.

Lemma merge_elems a l1 l2 : In a l1 \/ In a l2 <-> In a (merge cmp l1 l2).

Lemma listd_merge_inter' l1 l2 s :
  listd f inter TT (merge cmp l1 l2) s ->
  listd f inter TT l1 s /\ listd f inter TT l2 s.

Lemma listd_merge_un1 l1 l2 s :
  listd f un FF l1 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un2 l1 l2 s :
  listd f un FF l2 s -> listd f un FF (merge cmp l1 l2) s.

Lemma listd_merge_un' l1 l2 s :
  listd f un FF (merge cmp l1 l2) s ->
  listd f un FF l1 s \/ listd f un FF l2 s.

End ListDenoteMergePreds.

Section ListDenoteSeparate.
Context {X Y B : Type}.
Variables (f : X -> pred B) (g : Y -> pred B) (b : pred B) (l1 : list X)
          (l2 : list Y).

Lemma listd_separate :
  listd f inter (listd g inter b l2) l1 =
  andp (listd f inter TT l1) (andp (listd g inter TT l2) b).

Lemma listd_prop:
listd f inter b l1 =
(andp (listd f inter TT l1) b).

End ListDenoteSeparate.

Section SetDenote.

Definition setd {T} (f : M.elt -> T) (g : T -> T -> T) (b : T) (s : M.t) :=
  listd f g b (M.elements s).

End SetDenote.

Section SetLems.
Variables (s : M.t) (x y : clause).

Lemma setd_add_In_refl : M.In x (M.add x s).

Lemma setd_add_In_refl_elems : In x (M.elements (M.add x s)).

Lemma setd_add_In : x = y \/ M.In y s -> M.In y (M.add x s).

Lemma setd_add_In_inv : M.In y (M.add x s) -> x = y \/ M.In y s.

Lemma elements_In {s0} : In y (M.elements s0) = M.In y s0.

Lemma empty_set_elems : M.elements M.empty = nil. 

Lemma setd_add_In_inv_elems :
  In y (M.elements (M.add x s)) -> x = y \/ M.In y s.

Lemma setd_rem_In_inv : M.In y (M.remove x s) -> M.In y s.

Lemma setd_rem_In_inv_elems :
  In y (M.elements (M.remove x s)) -> In y (M.elements s).

End SetLems.

Section SetDenoteLems.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : M.t -> clause -> M.t).
Variable (H : forall c cls s, setd f inter b cls s -> f c s ->
                              setd f inter b (h cls c) s).

Lemma setd_fold_left cls0 l s :
  listd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (fold_left h l cls0) s.

Lemma setd_fold cls0 l s :
  setd f inter b l s -> setd f inter b cls0 s ->
  setd f inter b (M.fold (Basics.flip h) cls0 l) s.

Lemma setd_un cls1 cls2 s :
  setd f inter TT cls1 s -> setd f inter TT cls2 s ->
  setd f inter TT (M.union cls1 cls2) s.

Lemma setd_base_separate:
   forall {A} f (b: pred A) cls,
    setd f inter b cls = andp b (setd f inter (@TT A) cls).

Lemma setd_add c cls s :
  setd f inter b cls s -> f c s -> setd f inter b (M.add c cls) s.

Lemma setd_remove c cls s :
  setd f inter TT cls s -> setd f inter TT (M.remove c cls) s.

Lemma setd_empty_set s : setd f inter TT M.empty s.

Require Import MSetFacts Logic.

Lemma setd_filter bf cls s :
  setd f inter TT cls s -> setd f inter TT (M.filter bf cls) s.

End SetDenoteLems.

Section FoldLem.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).

Lemma listd_fold_left cls0 l s
  (H : forall c cls, listd f inter b cls s -> f c s ->
                     listd f inter b (h cls c) s) :
  listd f inter b l s -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLem.

Section FoldLemWeak.
Context (B : Type). Variables (f : clause -> pred B) (b : pred B).
Variable (h : list clause -> clause -> list clause).
Variable (H : forall c cls s, listd f inter b cls s -> (forall s, f c s) ->
                              listd f inter b (h cls c) s).

Lemma listd_fold_left_wk cls0 l s :
  listd (fun c => forall s, f c s) and True l -> listd f inter b cls0 s ->
  listd f inter b (fold_left h l cls0) s.

End FoldLemWeak.

Lemma listd_inter_map: forall {A B C} (l:list A) (f:B -> C -> Prop) h s,
(forall x, In x l -> f (h x) s) ->
inter
  (listd f inter TT (map h l)) TT s.

Lemma listd_inter_rev: forall {A B} (f: A -> B -> Prop) l,
  listd f inter TT (rev  l) = listd f inter TT l.

Lemma orp_FF {A} (p : pred A) : orp p FF = p.

Lemma listd_un_rev:
  forall {A B} (f: A -> B -> Prop) l, listd f un FF (rev  l) = listd f un FF l.

Lemma setd_filter_pred:
  forall {B: Type} (f: M.elt -> pred B) (h: M.elt -> bool) (s: M.t), *)
(* veristar.clause_lemmas:
Load loadpath.
Require Import ZArith Coq.Lists.List Permutation.
Require Import VST.msl.Axioms msl.Coqlib2.
Require Import VST.msl.predicates_sa.
Require Import veristar.datatypes veristar.clauses
               veristar.list_denote veristar.heapresolve
               veristar.model_type veristar.model veristar.compare.
Require Import veristar.superpose.

Module Type CL_SOUND.

Declare Module VSM : VERISTAR_MODEL. Import VSM VeriStarLogic.

Axiom order_eqv_sound : forall a,
  pure_atom_denote a = pure_atom_denote (order_eqv_pure_atom a).

Axiom order_eqv_clause_sound : forall c s,
  clause_denote (order_eqv_clause c) s <-> clause_denote c s.

Axiom clause_setd_listd : forall l b s,
  listd clause_denote inter b l s ->
  setd clause_denote inter b (clause_list2set l) s.

Axiom rev_cmp_eq : forall {A:Type} (f : A -> A -> comparison) (a1 a2 : A),
  Eq = rev_cmp f a1 a2 -> rev_cmp f a1 a2 = f a1 a2.

Axiom in_sort_uniq : forall c l,
  In c (rsort_uniq (rev_cmp compare_clause) l) -> In c l.

End CL_SOUND.

Module CL_Sound (VSM : VERISTAR_MODEL) : CL_SOUND with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic.

Import sepalg.

Lemma order_eqv_sound a :
  pure_atom_denote a = pure_atom_denote (order_eqv_pure_atom a).

Lemma list_denote_intersection_filter_nonreflex (B: spred) (l: list pure_atom) :
  listd pure_atom_denote inter B l =
  listd pure_atom_denote inter B (filter nonreflex_atom l).

Lemma list_denote_normalize_pure_atoms :
  forall Q (B:spred) (l:list pure_atom)
     (Qassoc: forall x y z , Q x (Q y z) = Q (Q x y) z)
     (Qsymm: forall x y, Q x y = Q y x)
     (Hcmp: forall x y, Eq = pure_atom_cmp x y ->
       (forall P, Q (pure_atom_denote x) (Q (pure_atom_denote y) P) =
                  Q (pure_atom_denote y) P)),
  list_denote pure_atom_denote Q B l =
  list_denote pure_atom_denote Q B (normalize_atoms l).

Lemma list_denote_intersection_normalize_pure_atoms B l :
  list_denote pure_atom_denote inter B l =
  list_denote pure_atom_denote inter B (normalize_atoms l).

Lemma list_denote_union_normalize_pure_atoms B l :
  list_denote pure_atom_denote un B l =
  list_denote pure_atom_denote un B (normalize_atoms l).

Lemma list_denote_normalize_filter_nonreflex_atom B l :
  list_denote pure_atom_denote inter B
      (normalize_atoms (filter nonreflex_atom l)) =
  list_denote pure_atom_denote inter B l.

Lemma order_eqv_clause_sound c s :
  clause_denote (order_eqv_clause c) s <-> clause_denote c s.

Lemma clause_setd_listd l b s :
  listd clause_denote inter b l s ->
  setd clause_denote inter b (clause_list2set l) s.

Lemma rev_cmp_eq {A:Type} (f : A -> A -> comparison) (a1 a2 : A) :
  Eq = rev_cmp f a1 a2 -> rev_cmp f a1 a2 = f a1 a2.

Lemma in_insert_uniq c c' l :
  In c (insert_uniq (rev_cmp compare_clause) c' l) ->
  c' = c \/ In c l.

Lemma compare_clause_refl d : Eq = rev_cmp compare_clause d d.

Lemma in_sort_uniq c l :
  In c (rsort_uniq (rev_cmp compare_clause) l) -> In c l.

End CL_Sound.

Lemma positive_base_case: forall n, 0 = nat_of_P n - 1 -> n=1%positive. *)

Module Type VERISTAR_SOUND.
Declare Module VSM : VERISTAR_MODEL.
Import VSM.

Axiom check_entailment_sound: forall (e: entailment),
  VeriStar.check_entailment e = VeriStar.Valid -> entailment_denote e.

End VERISTAR_SOUND.

Module VeriStarSound (VSM: VERISTAR_MODEL) : VERISTAR_SOUND
  with Module VSM := VSM.

Module VSM := VSM.  Import VSM. Import VeriStarLogic.
Module CS  := Clausify_Sound VSM. Import CS.
Module SPS := SP_Sound VSM.       Import SPS.
Module NS  := Norm_Sound VSM.     Import NS.
Module WFS := WF_Sound VSM.       Import WFS.
Module UFS := UF_Sound VSM.       Import UFS.
Module CL  := CL_Sound VSM.       Import CL.

Import HeapResolve.
Import VeriStar.

Lemma relim1_sound c s st :
  clause_denote c st -> setd clause_denote inter TT s st ->
  setd clause_denote inter TT (relim1 c s) st.
Proof. intros; apply setd_filter_pred; auto. Qed.

Lemma incorp_sound s t st :
  setd clause_denote inter TT s st -> setd clause_denote inter TT t st ->
  setd clause_denote inter TT (incorp s t) st.
Proof.
intros; apply setd_un; auto. apply setd_fold; auto.
intros. apply relim1_sound; auto.
Qed.

Local Open Scope nat_scope.

Lemma positive_base_case : forall n: positive,
  O = nat_of_P n - 1 -> n=1%positive.
Proof. intros. generalize (lt_O_nat_of_P n); intro.
 assert (nat_of_P n = 1) by omega.
 assert (nat_of_P 1%positive = 1) by reflexivity.
 rewrite <- H2 in H1.
 generalize (nat_of_P_inj n 1 H1); intro; subst n; auto.
Qed.

Local Coercion bool2Prop (b: bool) := b = true.

Lemma loop_sound n sigma nc s cl st :
  clause_denote nc st -> space_denote sigma st ->
  setd clause_denote inter TT s st -> the_loop n sigma nc s cl = Valid ->
  clause_denote empty_clause st.
Proof with simpl in *; auto; try solve[congruence].
remember (nat_of_P n - 1)%nat as nn.
revert n Heqnn sigma nc s cl; induction nn; intros ? ?.

apply positive_base_case in Heqnn; subst.
intros; rewrite the_loop_equation in H2; rewrite Coqlib.peq_true in H2.
inversion H2.

assert (Hnnx: nn = nat_of_P (Ppred n) - 1).
 rewrite Ppred_minus;
   rewrite nat_of_P_minus_morphism by
    (clear - Heqnn; destruct n; simpl in *; auto; discriminate);
   unfold nat_of_P at 2; simpl; omega.
specialize (IHnn _ Hnnx). clear Hnnx.
intros sigma nc s cl H0 H1 H2; rewrite the_loop_equation.
rewrite if_false by (clear - Heqnn; intro H; subst;  inversion Heqnn).
clear nn Heqnn.
remember (Superposition.check_clauseset s) as S.
  destruct S as [res s']; symmetry in HeqS.
destruct res... destruct p... destruct s0... intros H3 _.
apply (check_clauseset_Valid_sound _ _ _ _ HeqS)...
assert (H3: setd clause_denote inter TT t st).
  apply (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS st)...
remember (M.mem empty_clause t) as E; destruct E as [E|E].
assert (H4: In empty_clause (M.elements t)).
  clear - HeqE H3. symmetry in HeqE.
rewrite M.mem_spec in HeqE. rewrite <- Melements_spec1 in HeqE. auto.
unfold setd in H3; apply listd_In_inv_pred with (a := empty_clause) in H3...
if_tac... if_tac... if_tac... apply IHnn...
 assert (H4: listd clause_denote inter TT
   (rsort_uniq (rev_cmp compare_clause) (M.elements t)) st).
   rewrite (@listd_sort_uniq_inter _ state)...
   intros x y H4; rewrite rev_cmp_eq in H4...
   apply comp_eq in H4; auto.
   apply simplify_sound...
   edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS); eauto.
   apply simplify_atoms_sound...
   edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS); eauto.
 apply setd_un.
   apply setd_filter_pred.
   apply unfolding_sound.
   apply norm_sound. intro; auto.
   apply check_clauseset_Cexample_sound in HeqS.
   specialize (HeqS st H2). destruct HeqS...
   apply simplify_atoms_sound...
   edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS); eauto.
   autounfold with DEBUG_UNFOLD.
   destruct H...
   apply norm_sound...
   apply check_clauseset_Cexample_sound in HeqS.
   specialize (HeqS st H2). destruct HeqS...
   apply simplify_sound...
   edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS)
     as [[H4 H5]]; eauto.
 apply setd_fold.
   intros. apply relim1_sound; auto.
   apply incorp_sound... apply do_wellformed_sound... apply norm_sound...
   apply check_clauseset_Cexample_sound in HeqS.
   specialize (HeqS st H2). destruct HeqS...
   intros; apply simplify_atoms_sound...
   edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS)
     as [[H4 H5]]; eauto.
   apply setd_filter_pred... apply unfolding_sound...
   apply norm_sound...
   apply check_clauseset_Cexample_sound in HeqS.
   specialize (HeqS st H2). destruct HeqS...
   intros; apply simplify_atoms_sound...
   edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS)
     as [[H4 H5]]; eauto.
   apply check_clauseset_Cexample_sound in HeqS.
   specialize (HeqS st H2). destruct HeqS...
   apply norm_sound...
   apply simplify_sound... destruct H...
apply IHnn...
  assert (H4: listd clause_denote inter TT
    (rsort_uniq (rev_cmp compare_clause) (M.elements t)) st).
    rewrite (@listd_sort_uniq_inter _ state)...
    intros x y H4; rewrite rev_cmp_eq in H4...  apply comp_eq in H4; auto.
  apply simplify_sound...
  edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS); eauto.
  apply simplify_atoms_sound...
  edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS); eauto.
  apply setd_un.
  apply do_wellformed_sound... apply norm_sound...
  apply check_clauseset_Cexample_sound in HeqS.
  specialize (HeqS st H2). destruct HeqS...
  intros; apply simplify_atoms_sound...
  edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS)
    as [[H4 H5]]; eauto.
  apply setd_fold... intros; apply relim1_sound...
  apply do_wellformed_sound... apply norm_sound...
  apply check_clauseset_Cexample_sound in HeqS.
  specialize (HeqS st H2). destruct HeqS...
  intros; apply simplify_atoms_sound...
  edestruct (check_clauseset_Cexample_sound _ _ _ _ _ _ HeqS)
    as [[H4 H5]]; eauto.
Qed.

Theorem check_entailment_sound: forall (e: entailment),
  VeriStar.check_entailment e = VeriStar.Valid -> entailment_denote e.
Proof with simpl; auto.
intros e H1. rewrite cnf_correct. intros st H2.
destruct e as [[pi sigma] [pi' sigma']].
  unfold check_entailment in H1. simpl in H2.
destruct sigma, sigma'.

remember (mk_pureR pi') as PI'; destruct PI' as [pi'plus pi'minus].
destruct (mk_pureR pi).
cut (clause_denote empty_clause st). simpl; intros H3. spec H3...
apply loop_sound with (st:=st) in H1; auto.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... intros H5. simpl in H3, H4.
apply H4. clear -H5. induction pi'plus...
solve[destruct H5; split; auto].
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl in H3...
unfold pure_clauses.
apply clause_setd_listd.
 apply listd_filter_pred.
apply listd_map_pred with (f := fun c => clause_denote c)...
intros a; rewrite order_eqv_clause_sound...
remember (mk_pureR pi') as b; destruct b... inversion HeqPI'; subst.
rewrite listd_app, (@listd_unfold_inter _ state); split.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl; split... split...

remember (s :: sigma') as sigma'0.
remember (mk_pureR pi') as PI'; destruct PI' as [pi'plus pi'minus].
destruct (mk_pureR pi).
cut (clause_denote empty_clause st). simpl; intros H3. spec H3...
apply loop_sound with (st:=st) in H1; auto.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl in H3...
unfold pure_clauses.
apply clause_setd_listd.
 apply listd_filter_pred.
apply listd_map_pred with (f := fun c => clause_denote c)...
intros a; rewrite order_eqv_clause_sound...
remember (mk_pureR pi') as b; destruct b... inversion HeqPI'; subst.
rewrite listd_app, (@listd_unfold_inter _ state); split.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl; split... split...

remember (s :: sigma) as sigma0.
remember (mk_pureR pi') as PI'; destruct PI' as [pi'plus pi'minus].
destruct (mk_pureR pi).
cut (clause_denote empty_clause st). simpl; intros H3. spec H3...
apply loop_sound with (st:=st) in H1; auto.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl in H3...
unfold pure_clauses.
apply clause_setd_listd.
 apply listd_filter_pred.
apply listd_map_pred with (f := fun c => clause_denote c)...
intros a; rewrite order_eqv_clause_sound...
remember (mk_pureR pi') as b; destruct b... inversion HeqPI'; subst.
rewrite listd_app, (@listd_unfold_inter _ state); split.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl; split... split...

remember (mk_pureR pi') as PI'; destruct PI' as [pi'plus pi'minus].
destruct (mk_pureR pi).
cut (clause_denote empty_clause st). simpl; intros H3. spec H3...
apply loop_sound with (st:=st) in H1; auto.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl in H3...
unfold pure_clauses.
apply clause_setd_listd.
 apply listd_filter_pred.
apply listd_map_pred with (f := fun c => clause_denote c)...
intros a; rewrite order_eqv_clause_sound...
remember (mk_pureR pi') as b; destruct b... inversion HeqPI'; subst.
rewrite listd_app, (@listd_unfold_inter _ state); split.
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]...
rewrite listd_app, (@listd_unfold_inter _ state) in H2.
destruct H2 as [H2 [H3 [H4 _]]]... simpl; split... split...
Qed.

End VeriStarSound.

