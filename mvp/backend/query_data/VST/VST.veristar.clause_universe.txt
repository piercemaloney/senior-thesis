Load loadpath.
Require MSets.
Require Coq.Structures.Orders.
Require Coq.Structures.OrdersFacts.
Require Import Morphisms.
Require Import ProofIrrelevance.
Require Import List.
Require Import Relation_Definitions.
Require Import Sorting.
Require Recdef.
Require Omega.
Require Import VST.msl.Axioms VST.msl.Coqlib2.
Require Import NArith veristar.variables veristar.datatypes veristar.clauses.
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.clauses:
Load loadpath.
Require Import ZArith List Recdef Coq.MSets.MSetInterface Coq.Sorting.Mergesort
               Permutation Coq.MSets.MSetAVL.
Require Import veristar.basic veristar.tactics veristar.variables veristar.datatypes
               veristar.compare veristar.redblack.

Inductive pure_atom := Eqv : expr -> expr -> pure_atom.

Let var1 : var := Z2id 1.
Let var0 : var := Z2id 0.
Let var2 : var := Z2id 2.

Fixpoint list_prio {A} (weight: var) (l: list A) (p: var) : var :=
  match l with
  | nil => p
  | _::l' => list_prio weight l' (add_id weight p)
  end.

Definition prio (gamma delta: list pure_atom) : var :=
    list_prio var2 gamma (list_prio var1 delta var0).

Inductive clause : Type :=
| PureClause : forall (gamma : list pure_atom) (delta : list pure_atom)
                         (priority : var)
                         (prio_ok: prio gamma delta = priority), clause
| PosSpaceClause : forall (gamma : list pure_atom) (delta : list pure_atom)
  (sigma : list space_atom), clause
| NegSpaceClause : forall (gamma : list pure_atom) (sigma : list space_atom)
  (delta : list pure_atom), clause.

Definition expr_cmp e e' :=
 match e, e' with
   | Nil , Nil => Eq
   | Nil, _ => Lt
   | _, Nil => Gt
   | Var v, Var v' => Ident.compare v v'
 end.

Lemma var_cspec : StrictCompSpec (@Logic.eq var) Ident.lt Ident.compare.

Hint Resolve var_cspec.

Lemma expr_cspec: CompSpec' expr_cmp.

Hint Resolve expr_cspec.

Definition pure_atom_cmp (a a': pure_atom) : comparison :=
 match a, a' with
   | Eqv e1 e2, Eqv e1' e2' =>
     match expr_cmp e1 e1' with
       Eq => expr_cmp e2 e2' | c => c
     end
 end.

Hint Rewrite @comp_refl using solve[auto] : comp.

Ltac comp_tac :=
    progress (autorewrite with comp in *; auto)
  || discriminate
  || solve [eapply comp_trans;  eauto]
  || subst
 || match goal with
  | H: Lt = ?A |- context [?A] => rewrite <- H
  | H: Gt = ?A |- context [?A] => rewrite <- H
  | H: Eq = ?A |- context [?A] => rewrite <- H
 end.

Lemma pure_atom_cspec: CompSpec' pure_atom_cmp.

Hint Resolve pure_atom_cspec.

Lemma pure_atom_cmp_eq a b : a = b <-> Eq = pure_atom_cmp a b.
Hint Resolve pure_atom_cmp_eq.

Definition expr_order (t t': expr) := isGe (expr_cmp t t').

Inductive max_expr (t : expr) : pure_atom -> Prop :=
| mexpr_left : forall t', expr_order t t' -> max_expr t (Eqv t t')
| mexpr_right : forall t', expr_order t t' -> max_expr t (Eqv t' t).

Definition order_eqv_pure_atom (a: pure_atom) :=
  match a with
    | Eqv i j => match expr_cmp i j with Lt => Eqv j i | _ => Eqv i j end
  end.

Definition nonreflex_atom a :=
  match a with Eqv i j => match expr_cmp i j with Eq => false | _ => true end
  end.

Definition normalize_atoms pa :=
  rsort_uniq pure_atom_cmp (map order_eqv_pure_atom pa).

Definition mkPureClause (gamma delta: list pure_atom) : clause :=
  PureClause gamma delta _ (eq_refl _).

Definition order_eqv_clause (c: clause) :=
  match c with
  | PureClause pa pa' _ _ =>
        mkPureClause (normalize_atoms (filter nonreflex_atom pa)) (normalize_atoms pa')
  | PosSpaceClause pa pa' sa' =>
    PosSpaceClause (normalize_atoms (filter nonreflex_atom pa))
                   (normalize_atoms pa') sa'
  | NegSpaceClause pa sa pa' =>
    NegSpaceClause (normalize_atoms (filter nonreflex_atom pa)) sa
                   (normalize_atoms pa')
  end.

Definition mk_pureL (a: pn_atom) : clause :=
 match a with
 | Equ x y => mkPureClause nil (order_eqv_pure_atom(Eqv x y)::nil)
 | Nequ x y => mkPureClause (order_eqv_pure_atom(Eqv x y)::nil) nil
 end.

Fixpoint mk_pureR (al: list pn_atom) : list pure_atom * list pure_atom :=
 match al with
 | nil => (nil,nil)
 | Equ x y :: l' => match mk_pureR l' with (p,n) =>
                      (order_eqv_pure_atom(Eqv x y)::p, n) end
 | Nequ x y :: l' => match mk_pureR l' with (p,n) =>
                       (p, order_eqv_pure_atom(Eqv x y)::n) end
 end.

Definition cnf (en: entailment) : list clause :=
 match en with
  Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
   match mk_pureR pureR with (p,n) =>
     map mk_pureL pureL ++ (PosSpaceClause nil nil spaceL :: nil) ++
       match spaceL, spaceR with
       | nil, nil => mkPureClause p n :: nil
       | _, _ => NegSpaceClause p spaceR n :: nil
       end
   end
  end.

Definition pure_atom_geq a b := isGeq (pure_atom_cmp a b).
Definition pure_atom_gt a b := match pure_atom_cmp a b with Gt => true | _ => false end.
Definition pure_atom_eq a b := match pure_atom_cmp a b with Eq => true | _ => false end.
Definition expr_lt a b := match expr_cmp a b with Lt => true | _ => false end.
Definition expr_eq a b := match expr_cmp a b with Eq => true | _ => false end.
Definition expr_geq a b := match expr_cmp a b with Lt => false | _ => true end.

Definition norm_pure_atom (a : pure_atom) :=
  match a with
    | Eqv i j => if expr_lt i j then Eqv j i else Eqv i j
  end.

Definition subst_pure (i: var) (t: expr) (a: pure_atom) :=
 match a with
   | Eqv t1 t2 => Eqv (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pures (i: var) (t: expr) (pa: list pure_atom)
  : list pure_atom := map (subst_pure i t) pa.

Definition compare_space_atom (a b : space_atom) : comparison :=
 match a , b with
  | Next i j , Next i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  | Next i j, Lseg i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Lt
    | Gt => Gt
    end
  | Lseg i j, Next i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Gt
    | Gt => Gt
    end
  | Lseg i j , Lseg i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  end.

Lemma space_atom_cspec: CompSpec' compare_space_atom.

Hint Resolve space_atom_cspec.

Definition compare_clause (cl1 cl2 : clause) : comparison :=
  match cl1 , cl2 with
  | PureClause neg pos _ _ , PureClause neg' pos' _ _ =>
    match compare_list pure_atom_cmp neg neg' with
    | Eq => compare_list pure_atom_cmp pos pos'
    | c => c
    end
  | PureClause _ _ _ _ , _ => Lt
  | _ , PureClause _ _ _ _ => Gt
  | PosSpaceClause gamma delta sigma , PosSpaceClause gamma' delta' sigma'
  | NegSpaceClause gamma sigma delta , NegSpaceClause gamma' sigma' delta' =>
    match compare_list pure_atom_cmp gamma gamma' with
    | Eq => match compare_list pure_atom_cmp delta delta' with
                 | Eq => compare_list compare_space_atom sigma sigma'
                 | c => c
                 end
    | c => c
    end
  | PosSpaceClause _ _ _ , NegSpaceClause _ _ _ => Lt
  | NegSpaceClause _ _ _ , PosSpaceClause _ _ _ => Gt
  end.

Lemma clause_cspec: CompSpec' compare_clause.

Hint Resolve clause_cspec.

Definition rev_cmp {A : Type} (cmp : A -> A -> comparison) :=
  fun a b => match cmp a b with Eq => Eq | Lt => Gt | Gt => Lt end.

Lemma rev_cmp_cspec {A} (c: A -> A -> comparison) :
  CompSpec' c -> CompSpec' (rev_cmp c).

Lemma rev_cmp_eq : forall {A : Type} (cmp : A -> A -> comparison) (x y : A),
  (forall x0 y0 : A, Eq = cmp x0 y0 -> x0 = y0) ->
  Eq = rev_cmp cmp x y -> x = y.

Definition prio1000 := Z2id 1000.
Definition prio1001 := Z2id 1001.

Definition clause_prio (cl : clause) : var :=
  match cl with
  | PureClause gamma delta prio _ => prio
  | PosSpaceClause _ _ _ => prio1000
  | NegSpaceClause gamma sigma delta => prio1001
  end%Z.

Definition compare_clause' (cl1 cl2 : clause) : comparison :=
  match Ident.compare (clause_prio cl1) (clause_prio cl2) with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec': CompSpec' compare_clause'.

Hint Resolve clause_cspec'.

Definition clause_length (cl : clause) : Z :=
  match cl with
  | PureClause gamma delta _ _ => Zlength gamma + Zlength delta
  | PosSpaceClause gamma delta sigma =>
      Zlength gamma + Zlength delta + Zlength sigma
  | NegSpaceClause gamma sigma delta =>
      Zlength gamma + Zlength sigma + Zlength delta
  end%Z.

Definition compare_clause_length (cl1 cl2 : clause) :=
   Zcompare (clause_length cl1) (clause_length cl2).

Definition compare_clause'1 (cl1 cl2 : clause) : comparison :=
  match compare_clause_length cl1 cl2 with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec'1: CompSpec' compare_clause'1.

Hint Resolve clause_cspec'1.

Module OrderedClause <: OrderedType
  with Definition t:=clause
  with Definition compare:=compare_clause'.

Definition t := clause.

Definition eq : clause -> clause -> Prop := Logic.eq.

Lemma eq_equiv : Equivalence eq.

Definition lt (c1 c2 : clause) := Lt = compare_clause' c1 c2.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.

Definition compare := compare_clause'.

Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).

Lemma eq_dec : forall x y, {eq x y}+{~eq x y}.

Lemma lt_strorder : StrictOrder lt.

End OrderedClause.

Module M1 : redblack.MSetPlus
   with Definition E.t := OrderedClause.t
   with Definition E.compare := OrderedClause.compare
   with Definition E.eq := OrderedClause.eq
   with Definition E.lt := OrderedClause.lt
   with Definition E.compare := OrderedClause.compare.
 Include MSetAVL.Make(OrderedClause).
 Definition delete_min (s: t) : option (elt * t) :=
   match min_elt s with
   | Some x => Some (x, remove x s)
   | None => None
  end.
 Lemma delete_min_spec1: forall (s: t) k s',
    delete_min s = Some (k,s') <->
    (min_elt s = Some k /\ remove k s = s').
 Lemma delete_min_spec2: forall s, delete_min s = None <-> Empty s.
Definition mem_add (x: elt) (s: t) : option t :=
 if mem x s then None else Some (add x s).

Lemma mem_add_spec:
    forall x s, mem_add x s = if mem x s then None else Some (add x s).
End M1.

Module M := redblack.Make(OrderedClause).

Definition clause_list2set (l : list clause) : M.t :=
  fold_left (fun s0 c => M.add c s0) l M.empty.

Definition empty_clause : clause := mkPureClause nil nil.

Definition remove_trivial_atoms := filter (fun a =>
  match a with
  | Eqv e1 e2 => match expr_cmp e1 e2 with
                 | Eq => false
                 | _ => true
                 end
  end).

Definition subst_pures_delete (i: var) (e: expr)
  : list pure_atom -> list pure_atom :=
  remove_trivial_atoms oo subst_pures i e.

Definition isEq cc := match cc with Eq => true | _ => false end.

Definition eq_space_atom (a b : space_atom) : bool :=
  isEq (compare_space_atom a b).

Definition eq_space_atomlist (a b : list space_atom) : bool :=
  isEq (compare_list compare_space_atom a b).

Definition eq_var i j : bool := isEq (Ident.compare i j).

Definition drop_reflex_lseg : list space_atom -> list space_atom :=
  filter (fun sa =>
                    match sa with
                    | Lseg (Var x) (Var y) => negb (eq_var x y)
                    | Lseg Nil Nil => false
                    | _ => true
                    end).

Definition order_eqv_pure_atoms := map order_eqv_pure_atom.

Definition greater_than_expr (i: var) (e: expr) :=
  match e with Var j => match Ident.compare i j with Gt => true | _ => false end
                        | Nil => true
  end.

Definition greatereq_than_expr (i: var) (e: expr) :=
  match e with
  | Var j => match Ident.compare i j with Gt => true | Eq => true | Lt => false
             end
  | Nil => true
  end.

Definition greater_than_atom (s u : pure_atom) :=
  match s , u with
  | Eqv s t , Eqv u v =>
    ((expr_lt u s && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v s && (expr_geq s u || expr_geq t u))) ||
    ((expr_lt u t && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v t && (expr_geq s u || expr_geq t u)))
  end.

Definition greater_than_atoms (s : pure_atom) (delta : list pure_atom) :=
  forallb (fun u => greater_than_atom s u) delta.

Definition greater_than_all (i: var) : list pure_atom -> bool :=
  forallb (fun a => match a with Eqv x y =>
             andb (greater_than_expr i x) (greater_than_expr i y) end).

Definition subst_clause i e cl : clause :=
  match cl with
  | PureClause pa pa' _ _ =>
      mkPureClause (subst_pures_delete i e pa) (subst_pures i e pa')
  | NegSpaceClause pa sa pa' =>
      NegSpaceClause (subst_pures_delete i e pa) (subst_spaces i e sa)
                     (subst_pures i e pa')
  | PosSpaceClause pa pa' sa' =>
      PosSpaceClause (subst_pures_delete i e pa) (subst_pures i e pa')
                     (subst_spaces i e sa')
  end.

Definition var_eqZ v v' := Ident.eq v v'.

Lemma eq_pos_var_eqZ v v' : true = eq_var v v' -> var_eqZ v v'.

Definition ocons {A : Type} (o : option A) l :=
  match o with Some a => a :: l | None => l end.

Fixpoint omapl {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | a :: l' => ocons (f a) (omapl f l')
  | nil => nil
  end.

Fixpoint merge {A: Type} (cmp : A -> A -> comparison) l1 l2 :=
  let fix merge_aux l2 :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      match cmp a1 a2 with
      | Eq => a1 :: merge cmp l1' l2'
      | Gt => a1 :: merge cmp l1' l2
      | _ => a2 :: merge_aux l2' end
  end
  in merge_aux l2.

Notation sortu_atms := (rsort_uniq pure_atom_cmp).
Notation insu_atm := (insert_uniq pure_atom_cmp).
Notation sortu_clauses := (rsort_uniq compare_clause).

Lemma compare_clause_eq_equivalence:
     RelationClasses.Equivalence (fun c1 c2 => Eq = compare_clause c1 c2).

Lemma pure_clause_ext:
  forall gamma delta p Pp p' Pp',
     PureClause gamma delta p Pp = PureClause gamma delta p' Pp'.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.

Lemma mem_spec': forall s x, M.mem x s = false <-> ~M.In x s.

Lemma is_empty_spec': forall s, M.is_empty s = false <-> ~M.Empty s.

Lemma empty_set_elems':
  forall s, M.Empty s <-> M.elements s = nil.

Lemma Melements_spec1: forall (s: M.t) x, List.In x (M.elements s) <-> M.In x s.

Require Import Finite_sets_facts.
Require Import VST.msl.Axioms.

Lemma Mcardinal_spec': forall s,   cardinal _ (Basics.flip M.In s) (M.cardinal s).

Lemma remove_decreases:
  forall giv unselected,
  M.In giv unselected ->

Definition pure_atom2pn_atom (b : bool) (a : pure_atom) :=
  match a with
  | Eqv e1 e2 => if b then Equ e1 e2 else Nequ e1 e2
  end.

Definition pn_atom_cmp (a1 a2 : pn_atom) : comparison :=
  match a1, a2 with
  | Equ e1 e2, Equ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Equ e1' e2' =>
    if expr_eq e1 e1' then Gt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Equ e1 e2, Nequ e1' e2' =>
    if expr_eq e1 e1' then Lt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Nequ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  end.

Definition pure_clause2pn_list (c : clause) :=
  match c with
  | PureClause gamma delta _ _ =>
    rsort pn_atom_cmp
      (map (pure_atom2pn_atom false) gamma ++ map (pure_atom2pn_atom true) delta)
  | _ => nil
  end.

Definition compare_clause2 (cl1 cl2 : clause) :=
  match cl1, cl2 with
  | PureClause _ _ _ _, PureClause _ _ _ _ =>
    compare_list pn_atom_cmp (pure_clause2pn_list cl1) (pure_clause2pn_list cl2)
  | _, _ => compare_clause cl1 cl2
  end.

Lemma compare_clause_eq cl1 cl2 : Eq = compare_clause cl1 cl2 -> cl1 = cl2.

Inductive ce_type := CexpL | CexpR | CexpEf.

Module DebuggingHooks.

Definition print_new_pures_set (s: M.t) := s.

Definition print_wf_set (s: M.t) := s.

Definition print_unfold_set (s: M.t) := s.

Definition print_inferred_list (l: list clause) := l.

Definition print_pures_list (l: list clause) := l.

Definition print_eqs_list (l: list clause) := l.

Definition print_spatial_model (c: clause) (R: list (var * expr)) := c.

Definition print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.

Definition print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
  := (R, cl, ct).

End DebuggingHooks.

Export DebuggingHooks.

Hint Unfold print_new_pures_set print_wf_set print_inferred_list print_spatial_model
            print_pures_list print_eqs_list
  : DEBUG_UNFOLD. *)
Require Import veristar.fresh.
(* veristar.fresh:
Load loadpath.
Require Import Coq.Lists.List.
Require Import veristar.variables veristar.datatypes.
Require Import Coqlib.
Require Import VST.msl.Coqlib2.
Require Import ZArith.
Require Import veristar.compare.
Require Import veristar.clauses.

Fixpoint freshmax_expr (e: expr) : var :=
  match e with
  | Nil => minid
  | Var v => v
  end.

Definition var_max (x y : var) : var :=
 match Ident.compare x y with Lt => y | _ => x end.

Definition freshmax_pn_atom (a: pn_atom) : var :=
  match a with
  | Equ e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  | Nequ e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  end.

Definition freshmax_space_atom (a: space_atom) : var :=
  match a with
  | Next e1 e2 =>  var_max (freshmax_expr e1) (freshmax_expr e2)
  | Lseg e1 e2 =>  var_max (freshmax_expr e1) (freshmax_expr e2)
 end.

Definition freshmax_list {A} (f: A -> var) (l: list A) : var :=
  fold_right (fun a i => var_max (f a) i) minid l.

Definition freshmax_assertion (a: assertion) : var :=
  match a with
  | Assertion pi sigma =>
     var_max (freshmax_list freshmax_pn_atom pi)
            (freshmax_list freshmax_space_atom sigma)
  end.

Definition freshmax_pure_atom (a: pure_atom) : var :=
  match a with
  | Eqv e1 e2 => var_max (freshmax_expr e1) (freshmax_expr e2)
  end.

Definition freshmax_clause (c : clause) : var :=
 match c with
 | PureClause pi pi' _ _ =>  var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi')
 | PosSpaceClause pi pi' sigma =>
     var_max (var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi'))
                       (freshmax_list freshmax_space_atom sigma)
 | NegSpaceClause pi sigma pi' =>
     var_max (var_max (freshmax_list freshmax_pure_atom pi)
                                     (freshmax_list freshmax_pure_atom pi'))
                       (freshmax_list freshmax_space_atom sigma)
 end.

Lemma varmax_minid: forall x, var_max minid x = x.

Lemma varmax_minid': forall x, var_max x minid = x.

Lemma var_max_intro:
  forall a b c, Ident.lt a c -> Ident.lt b c -> Ident.lt (var_max a b) c.

Lemma Ile_var_max1:  forall a b, Ile a (var_max a b).

Lemma Ile_var_max2:  forall a b, Ile b (var_max a b).

Lemma Ile_trans: forall a b c, Ile a b -> Ile b c -> Ile a c.

Lemma Ile_minid: forall m, Ile minid m.

Lemma var_max_intro':
  forall a b c, Ile a c -> Ile b c -> Ile (var_max a b) c.

Lemma var_max_split': forall a b c, Ile (var_max a b) c -> Ile a c /\ Ile b c.

Lemma id_compare_refl: forall z, Ident.compare z z = Eq.

Lemma id_compare_lt: forall x y, Ident.lt x y -> Ident.compare x y = Lt.

Lemma id_compare_gt: forall x y, Ident.lt y x -> Ident.compare x y = Gt.

Lemma var_max_assoc: forall x y z, var_max x (var_max y z) = var_max (var_max x y) z.

Lemma var_max_com: forall x y, var_max x y = var_max y x.

Lemma var_max_split: forall a b c, Ident.lt (var_max a b) c -> Ident.lt a c /\ Ident.lt b c.

Lemma freshmax_list_app:
 forall {A} (f: A -> var) l1 l2,
    freshmax_list f (l1++l2) = var_max (freshmax_list f l1) (freshmax_list f l2).

Lemma freshmax_list_rev:
 forall {A} (f: A -> var) l,
    freshmax_list f (rev l) = freshmax_list f l.

Lemma Ile_freshmax_i3:
  forall s m,
    (forall x, M.In x s -> Ile (freshmax_clause x) m) ->

Lemma merge_nil1:
  forall {A} (f: A -> A -> comparison) l, merge f nil l = l.

Lemma freshmax_list_merge:
  forall m al bl,
     Ile (freshmax_list freshmax_pure_atom al) m ->
     Ile (freshmax_list freshmax_pure_atom bl) m ->
     Ile (freshmax_list freshmax_pure_atom (merge pure_atom_cmp al bl)) m.

Lemma Ile_freshmax_list:
  forall A (f: A -> var) m (s: list A),
    Ile (freshmax_list f s) m <-> (forall x, List.In x s -> Ile (f x) m).

Lemma freshmax_list_insu:
   forall A (f: A -> var) (cmp: A -> A -> comparison)
      (CMP_EQ: forall a b, a=b <-> Eq = cmp a b)
      a s,
      freshmax_list f (insert_uniq cmp a s) = var_max (f a) (freshmax_list f s).

Lemma freshmax_list_sort:
  forall A (f: A -> var) (cmp: A -> A -> comparison)
      (CMP_EQ: forall a b, a=b <-> Eq = cmp a b)
      (s: list A),
    freshmax_list f (rsort_uniq cmp s) = freshmax_list f s.

Lemma freshmax_insu:
  forall m a pi,
       Ile (freshmax_pure_atom a) m ->
       Ile (freshmax_list freshmax_pure_atom pi) m ->
       Ile (freshmax_list freshmax_pure_atom
              (insert_uniq pure_atom_cmp a pi)) m. *)
Require Import Finite_sets_facts.
Require Import VST.msl.base.

Definition list_bound {A: Type} (f: A -> Prop) (l: list A):=
  Forall f l /\  NoDup l.

Definition vset := Ensemble var.

Definition expr_bound (n: vset) (e: expr) :=
 match e with Nil => True | Var v => n v end.

Definition pure_bound (n: vset) (a : pure_atom) :=
 match a with
 | Eqv e e' => expr_bound n e /\ expr_bound n e'
 end.

Definition space_bound (n: vset) (a: space_atom) :=
 match a with
 | Next e e' =>  expr_bound n e /\ expr_bound n e'
 | Lseg e e' =>  expr_bound n e /\ expr_bound n e'
 end.

Definition pures_bound n := list_bound (pure_bound n).
Definition spaces_bound n := list_bound (space_bound n).

Definition pures_bound' n := Forall (pure_bound n).
Definition spaces_bound' n := Forall (space_bound n).

Definition clause_bound' (n: vset)  (cl: clause) :=
 match cl with
 | PureClause pi pi' _ _ =>  pures_bound' n pi /\ pures_bound' n pi'
 | PosSpaceClause pi pi' sigma =>
    pures_bound' n pi /\ pures_bound' n pi'/\ spaces_bound' n sigma
 | NegSpaceClause pi sigma pi' =>
    pures_bound' n pi /\ pures_bound' n pi'/\ spaces_bound' n sigma
 end.

Definition clause_bound (n: vset)  (cl: clause) :=
 match cl with
 | PureClause pi pi' _ _ =>  pures_bound n pi /\ pures_bound n pi'
 | PosSpaceClause pi pi' sigma =>
    pures_bound n pi /\ pures_bound n pi'/\ spaces_bound n sigma
 | NegSpaceClause pi sigma pi' =>
    pures_bound n pi /\ pures_bound n pi'/\ spaces_bound n sigma
 end.

Lemma expr_bound_more: forall  n n' e,
    Included _ n n' -> expr_bound n e -> expr_bound n' e.
Proof.
 unfold expr_bound; intros; auto.
 destruct e; auto. apply H; auto.
Qed.

Lemma pure_bound_more:
  forall n n' a, Included _ n n' -> pure_bound n a -> pure_bound n' a.
Proof.
 intros.
 unfold pure_bound in *.
 destruct a;  destruct H0; split; eapply expr_bound_more; eauto.
Qed.

Lemma pures_bound'_more:
  forall n n' gamma, Included _ n n' -> pures_bound' n gamma -> pures_bound' n' gamma.
Proof.
 unfold pures_bound'; intros.
 rewrite Forall_forall in *.
  intros.
 eapply pure_bound_more; eauto.
Qed.

Lemma space_bound_more:
  forall n n' a, Included _ n n' -> space_bound n a -> space_bound n' a.
Proof.
 intros.
 unfold space_bound in *.
 destruct a;  destruct H0; split; eapply expr_bound_more; eauto.
Qed.

Lemma spaces_bound'_more:
  forall n n' gamma, Included _ n n' -> spaces_bound' n gamma -> spaces_bound' n' gamma.
Proof.
 unfold spaces_bound'; intros.
 rewrite Forall_forall in *.
 intros.
 eapply space_bound_more; eauto.
Qed.

Lemma clause_bound'_more:
  forall n n' c, Included _ n n' -> clause_bound' n c -> clause_bound' n' c.
Proof.
 intros.
 destruct c; simpl in *.
  destruct H0; split; eapply pures_bound'_more; eauto.
  destruct H0 as [? [? ?]];
  split; [|split]; try  eapply pures_bound'_more; eauto;  eapply spaces_bound'_more; eauto.
  destruct H0 as [? [? ?]];
  split; [|split]; try  eapply pures_bound'_more; eauto;  eapply spaces_bound'_more; eauto.
Qed.

Definition var_upto (v: var): Ensemble var := fun x => Ile x v.

Lemma expr_bound_freshmax:
  forall e, expr_bound (var_upto (freshmax_expr e)) e.
 Proof.
 destruct e; intros; simpl; auto.
 right; reflexivity.
Qed.

Lemma S_nat_of_P_id2pos_le:
 forall x y, Ile x y -> S (nat_of_P (id2pos x)) <= S (nat_of_P (id2pos y)).
Proof.
 intros.
 generalize (nat_of_P_id2pos_le x y H); intro; omega.
Qed.

Lemma included_var_upto:
  forall a b, Ile a b -> Included _ (var_upto a) (var_upto b).
Proof. unfold var_upto; repeat intro; unfold In in *. eapply Ile_trans; eauto.
Qed.

Lemma pure_bound_freshmax:
 forall a, pure_bound (var_upto (freshmax_pure_atom a)) a.
 unfold pure_bound. destruct a.
 split.
 simpl.
 apply expr_bound_more with (var_upto (freshmax_expr e)).
 apply included_var_upto.  apply Ile_var_max1.
 apply expr_bound_freshmax.
 simpl.
 apply expr_bound_more with (var_upto (freshmax_expr e0)).
 apply included_var_upto.  apply Ile_var_max2.
  apply expr_bound_freshmax.
Qed.

Lemma pures_bound_freshmax:
  forall gamma,
  pures_bound' (var_upto (freshmax_list freshmax_pure_atom gamma)) gamma.
Proof.
 intros.
 unfold pures_bound'.
 induction gamma; simpl; intros.
 constructor.
 constructor; auto.
 eapply pure_bound_more; try apply pure_bound_freshmax.
 apply included_var_upto;  apply Ile_var_max1.
 rewrite Forall_forall in *; intros.
 specialize (IHgamma _ H).
 eapply pure_bound_more; try apply pure_bound_freshmax.
 apply included_var_upto;  eapply Ile_trans; [ | apply Ile_var_max2].
 revert H; clear; induction gamma; simpl; intros; auto.
 contradiction.
 destruct H; subst.
 apply Ile_var_max1.
 eapply Ile_trans; [ auto | apply Ile_var_max2].
Qed.

Lemma space_bound_freshmax:
 forall a, space_bound (var_upto (freshmax_space_atom a)) a.
 unfold space_bound. destruct a.
 split.
 simpl.
 apply expr_bound_more with (var_upto (freshmax_expr e)).
 apply included_var_upto; apply Ile_var_max1.
  apply expr_bound_freshmax.
 simpl.
 apply expr_bound_more with (var_upto (freshmax_expr e0)).
  apply included_var_upto; apply Ile_var_max2.
  apply expr_bound_freshmax.
 split.
 simpl.
 apply expr_bound_more with (var_upto (freshmax_expr e)).
  apply included_var_upto;  apply Ile_var_max1.
  apply expr_bound_freshmax.
 simpl.
 apply expr_bound_more with (var_upto (freshmax_expr e0)).
  apply included_var_upto;  apply Ile_var_max2.
  apply expr_bound_freshmax.
Qed.

Lemma spaces_bound'_freshmax:
  forall gamma,
  spaces_bound' (var_upto (freshmax_list freshmax_space_atom gamma)) gamma.
Proof.
 intros.
 unfold spaces_bound'.
 induction gamma; simpl; intros.
 constructor.
 constructor; auto.
 eapply space_bound_more; try apply space_bound_freshmax.
 apply included_var_upto;  apply Ile_var_max1.
 rewrite Forall_forall in *; intros.
 specialize (IHgamma _ H).
 eapply space_bound_more; try apply space_bound_freshmax.
 eapply included_var_upto; eapply Ile_trans; [ | apply Ile_var_max2].
 revert H; clear; induction gamma; simpl; intros; auto.
 contradiction.
 destruct H; subst.
 apply Ile_var_max1.
 eapply Ile_trans; [ | apply Ile_var_max2].
 auto.
Qed.

Lemma clause_bound'_freshmax:
  forall c, clause_bound' (var_upto (freshmax_clause c)) c.
Proof.
 intros.
 destruct c; simpl.
 split.
 apply pures_bound'_more with
   (var_upto (freshmax_list freshmax_pure_atom gamma)).
 apply included_var_upto.
 apply Ile_var_max1.
 apply pures_bound_freshmax.
 apply pures_bound'_more with
   (var_upto (freshmax_list freshmax_pure_atom delta)).
 apply included_var_upto.
 apply Ile_var_max2.
 apply pures_bound_freshmax.
 split; [|split].
 apply pures_bound'_more
   with (var_upto (freshmax_list freshmax_pure_atom gamma)).
 apply included_var_upto;  eapply Ile_trans; [ | apply Ile_var_max1].
 apply Ile_var_max1.
 apply pures_bound_freshmax.
 apply pures_bound'_more
   with (var_upto (freshmax_list freshmax_pure_atom delta)).
 apply included_var_upto;  eapply Ile_trans; [ | apply Ile_var_max1].
 apply Ile_var_max2.
 apply pures_bound_freshmax.
 apply spaces_bound'_more
   with (var_upto (freshmax_list freshmax_space_atom sigma)).
  apply included_var_upto;  apply Ile_var_max2.
 apply spaces_bound'_freshmax.
 split; [|split].
 apply pures_bound'_more
   with (var_upto (freshmax_list freshmax_pure_atom gamma)).
 apply included_var_upto;  eapply Ile_trans; [ | apply Ile_var_max1].
 apply Ile_var_max1.
 apply pures_bound_freshmax.
 apply pures_bound'_more
   with (var_upto (freshmax_list freshmax_pure_atom delta)).
 apply included_var_upto;  eapply Ile_trans; [ | apply Ile_var_max1].
 apply Ile_var_max2.
 apply pures_bound_freshmax.
 apply spaces_bound'_more
   with (var_upto (freshmax_list freshmax_space_atom sigma)).
  apply included_var_upto;  apply Ile_var_max2.
 apply spaces_bound'_freshmax.
Qed.

Module Type CLAUSE_UNIVERSE_FINITE.

 Axiom Finite_var_upto:  forall v, Finite _ (var_upto v).
 Axiom clause_bound_finite: forall n, Finite _ n -> Finite _ (clause_bound n).
End CLAUSE_UNIVERSE_FINITE.

Module ClauseUniverseFinite : CLAUSE_UNIVERSE_FINITE.

Require Import Image.

Implicit Arguments Finite.
Implicit Arguments Union.
Implicit Arguments Intersection.
Implicit Arguments Im.
Implicit Arguments In.
Implicit Arguments Add.
Implicit Arguments Subtract.
Implicit Arguments Singleton.
Implicit Arguments injective.
Implicit Arguments Included.
Implicit Arguments Power_set.

Ltac inv H := inversion H; clear H; subst.

Lemma finite_pair:
  forall U V (S : Ensemble U) (T: Ensemble V),
         Finite S -> Finite T ->
         Finite (fun xy => S (fst xy) /\ T (snd xy)).
Proof.
 intros.
 revert T H0; induction H; intros.
 replace (fun xy : U * V => Empty_set U (fst xy) /\ T (snd xy))
   with (Empty_set (U*V)).
 constructor.
 clear; extensionality x; apply prop_ext; split; intros H; inv H. inv H0.
 unfold Add.
  apply Finite_downward_closed
    with (Union (fun xy => A (fst xy) /\ T (snd xy))
                       (fun xy => Singleton x (fst xy) /\ T (snd xy))).
 apply Union_preserves_Finite.
 auto.
 apply Finite_downward_closed
    with (Im T (fun y => (x,y))).
 apply finite_image; auto.
 clear.
 intros [x' y] [? ?]. inv H. simpl in *. unfold In.
 econstructor; eauto.
 clear.
 intros [x' y] ?. unfold In in *.
 inv H; simpl in *.
 inv H0; [left | right]; unfold In in *; auto.
Qed.

Definition pures_bound2 n pi2 :=
      pures_bound n (fst pi2) /\ pures_bound n (snd pi2).

Lemma finite_unimage :
    forall {U V} (X:Ensemble U) (f:U -> V),
       injective f ->
       Finite (Im X f) -> Finite X.
Proof.
 intros.
 remember (Im X f) as Y.
 assert (Included (Im X f) Y).
subst; intros ? ?; auto.
clear HeqY.
 revert X H1; induction H0; intros.
 apply Finite_downward_closed with (Empty_set U).
 constructor.
 intros ? ?.
 unfold injective in H.
 assert (~ Im X f (f x)). intro.  apply H1 in H2. inv H2.
 contradiction H2.
 apply Im_intro with x; auto.
 apply Finite_downward_closed
   with  (Union (fun z => f z =x) (fun y : U => X y /\ f y <> x)).
 apply Union_preserves_Finite; auto.
 destruct (Classical_Prop.classic (exists z, f z = x)) as [[y ?]|?].
 apply Finite_downward_closed
   with (Singleton y).
 apply Singleton_is_finite.
 intros ? ?; unfold In in *.
 apply Singleton_intro; apply H. congruence.
 apply Finite_downward_closed with (Empty_set _).
 apply Empty_is_finite.
 intros ? ?. unfold In in H4. contradiction H3; eauto.
 apply IHFinite.
 intros ? ?. destruct H3.
 destruct H3.
 specialize (H2 y).
 subst.
 spec H2.
 apply Im_intro with x0; auto.
 unfold In, Add in H2. destruct H2; auto.
 apply Singleton_inv in H2. contradiction H5; auto.
 intros z ?.
 specialize (H2 (f z)).
 destruct (Classical_Prop.classic (x = f z)).
 subst. left. unfold In; auto.
 right.
 split; auto.
Qed.

Lemma Power_set_finite:
  forall U (F: Ensemble U), Finite F -> Finite (Power_set F).
Proof.
 intros.
 induction H.
 apply Finite_downward_closed
  with  (Singleton (Empty_set U)).
 apply Singleton_is_finite.
 intros ? ?. inv H. apply Singleton_intro.
 unfold Included in H0.
 extensionality y. apply prop_ext; intuition. apply H0 in H. inv H.
 apply Finite_downward_closed
   with (Union (Power_set A)
               (Im (Power_set A) (fun s => Add s x))).
 apply Union_preserves_Finite; auto.
 apply finite_image; auto.
 intros y ?.
 unfold In, Add in H1.
 destruct (Classical_Prop.classic (y x)); [right | left].
 unfold In.
 apply Im_intro with (Subtract y x).
Focus 2.
 clear - H2.
 extensionality z; unfold Add, Subtract. unfold Setminus.
 apply prop_ext; intuition.
 destruct (Classical_Prop.classic (x=z)). right. apply Singleton_intro; auto.
 left; auto. split; auto.  intro.  apply Singleton_inv in H1. contradiction.
 destruct H. destruct H. apply H. apply Singleton_inv in H. subst; auto.
 
 clear - H1 H2 H0.
 inv H1. constructor.
 intros z ?. specialize (H z).
 unfold In, Subtract in H1. destruct H1.
 specialize (H H1).
 unfold In in H. destruct H; auto.
 contradiction.
 unfold In.
 constructor.
 inv H1.
 intros z H4; specialize (H3 _ H4).
 unfold In in *. destruct H3; auto.
 apply Singleton_inv in H1. subst. contradiction.
Qed.

Definition list2set {U} (l: list U) : Ensemble U :=
  fun x => List.In x l.

Program Definition ff U (F: Ensemble U) (l : sig (@NoDup (sig F))) : sig (@NoDup U) :=
 (map (@proj1_sig _ _) (proj1_sig l)).
 Next Obligation.
 induction H. constructor.
 simpl.
 constructor.
 contradict H.
 clear - H.
 induction l; simpl in H. contradiction.
 destruct H; simpl; [left | right].
 destruct a; destruct x; simpl. apply exist_ext; auto.
 apply IHl. auto.
 auto.
Qed.

Lemma NoDup_finite:
  forall U (F: Ensemble U), Finite F -> Finite (fun l: sig (@NoDup _) => Forall F (proj1_sig l)).
Proof.
intros.
 destruct (finite_cardinal _ _ H) as [n ?].
 apply Finite_downward_closed
  with (Im (fun l => length (proj1_sig l) <= n) (ff _ F)).
 apply finite_image.
 apply finite_unimage with (@proj1_sig _ _).
 intros ? ? ?. destruct x; destruct y; simpl in *; subst; apply exist_ext; auto.
 apply Finite_downward_closed
  with (fun l => length l <= n).
 clear H0.
 induction n.
 apply Finite_downward_closed with (Singleton nil).
 apply Singleton_is_finite.
 intros ? ?. unfold In in *. destruct x; inv H0.
 apply Singleton_intro; auto.
 pose (gg (_: sig F) := True).
 pose (hh (l: list (sig F)) := length l <= n).
 apply Finite_downward_closed
  with (Union (Singleton nil)
           (Im (fun xy => gg (fst xy) /\ hh (snd xy)) (fun xy => fst xy :: snd xy))).
 apply Union_preserves_Finite.
 apply Singleton_is_finite.
 apply finite_image.
 apply finite_pair.
 unfold gg.
 apply finite_unimage with (@proj1_sig _ _).
 intros ? ? ?. destruct x; destruct y; simpl in *; subst; apply exist_ext; auto.
 apply Finite_downward_closed with F; auto.
 intros ? ?.  unfold In in *.  inv H0.  destruct x0; simpl; auto.
 apply IHn.
 intros ? ?. unfold In in *.
 destruct x; [left | right].
 apply Singleton_intro; auto.
 unfold In. apply Im_intro with (s,x); simpl; auto.
 unfold hh, In. simpl.
 simpl in H0. unfold gg. split; auto; omega.
 intros ? ?.
 unfold In in *. inv H1. unfold In in *. auto.

 intros ? ?.
 unfold In in *.
 assert (exists x' : sig (@NoDup (sig F)),
                map (@proj1_sig _ _) (proj1_sig x') = proj1_sig x).
 clear - H1.
 destruct x as [l H].
 revert H H1; induction l; simpl; intros.
  exists (exist (@NoDup _) _ (NoDup_nil _)).
  simpl. auto.
 inv H. inv H1.
  specialize (IHl H4 H5).
 destruct IHl as [l' ?].
  assert (NoDup (exist F a H2 :: (proj1_sig l'))).
 constructor. contradict H3.
 clear - H H3.
 destruct l' as [l' H1].
 revert l H1 H4 H H3; induction l'; simpl; intros. contradiction.
 destruct H3.
 subst. simpl in *. left; auto.
 subst. simpl. right.
 inv H1.
 inv H4.
 apply (IHl' (map (@proj1_sig _ _) l') H6 H7).
 simpl. auto.
 simpl. auto.
 simpl in *. subst.
 clear - H4.
 revert H4; induction l'; simpl; intros; auto.
 exists (exist (@NoDup _) _ H0).
 simpl. f_equal. simpl in H; auto.
 destruct H2 as [x' ?].
 apply Im_intro with x'.
 2: unfold ff; destruct x as [x ?];  simpl in *; apply exist_ext; auto.
 unfold In.
 destruct x as [l' ?].
 simpl in *.
 replace (length (proj1_sig x')) with (length l') by (rewrite <- H2; apply map_length).
 clear - n0 H1 H0.
 rename l' into l.
 revert F n n0 H0 H1; induction l; simpl; intros.
 omega.
 inv n0. inv H1.
 assert (length l <= pred n).
  (apply (IHl (Subtract F a))); auto.
 apply card_soustr_1; auto.
 rewrite Forall_forall in H6|-*.
 intros.
 split; auto. apply H6; auto.
 intro. apply Singleton_inv in H1. subst. contradiction.
 assert (n >0).
 clear - H0 H5.
 eapply inh_card_gt_O; try eassumption. exists a; apply H5.
 omega.
Qed.

Lemma finite_list_bound:
 forall U (F: Ensemble U), Finite F -> Finite (list_bound F).
Proof.
 unfold list_bound; intros.
 apply Finite_downward_closed
    with   (Im (fun l: sig (@NoDup _) => Forall F (proj1_sig l)) (@proj1_sig _ _)).
 apply finite_image.
 apply NoDup_finite; auto.
 intros ? ?. destruct H0; unfold In;
     apply Im_intro with (exist (@NoDup _) x H1); [apply H0 |  reflexivity].
Qed.

Lemma finite_expr_bound:
  forall n, Finite n -> Finite (expr_bound n).
Proof.
 unfold expr_bound; intros.
 apply Finite_downward_closed
   with (Union (Singleton Nil) (Im n Var)).
 apply Union_preserves_Finite.
 apply Singleton_is_finite.
 apply finite_image; auto.
 intros ? ?. destruct x.
 left; apply Singleton_intro; auto.
 right. apply Im_intro with v; auto.
Qed.

Lemma finite_pure_bound: forall n, Finite n -> Finite (pure_bound n).
Proof.
 unfold pure_bound;  intros.
 apply Finite_downward_closed
    with (Im (fun xy => expr_bound n (fst xy) /\ expr_bound n (snd xy))
                  (fun xy => Eqv (fst xy) (snd xy))).
 apply finite_image.
 apply finite_pair; apply finite_expr_bound; auto.
 intros ? ?. destruct x. unfold In in H0. destruct H0.
 unfold In.
 apply Im_intro with (e,e0). split; auto. simpl; auto.
Qed.

Lemma finite_space_bound: forall n, Finite n -> Finite (space_bound n).
Proof. intros n FIN.
 unfold space_bound; intros.
 apply Finite_downward_closed
   with (Union
              (Intersection (space_bound n)
                         (fun a => match a with Next _ _ => True | _ => False end))
              (Intersection (space_bound n)
                         (fun a => match a with Lseg _ _ => True | _ => False end))).
 2: intros a H; unfold In in *; destruct a; [left | right]; unfold In; split; unfold In; simpl; auto.
 apply Union_preserves_Finite.
 apply Finite_downward_closed
    with  (Im (fun xy => expr_bound n (fst xy) /\ expr_bound n (snd xy))
                   (fun xy : expr * expr => Next (fst xy) (snd xy))).
 apply finite_image.
 apply finite_pair; apply finite_expr_bound; auto.
 intros ? ?; unfold In in *. destruct H. destruct x; simpl in H0; try contradiction.
 unfold In, space_bound in H; destruct H.
 apply Im_intro with (e,e0); split; auto.
 apply Finite_downward_closed
    with  (Im (fun xy => expr_bound n (fst xy) /\ expr_bound n (snd xy))
                   (fun xy : expr * expr => Lseg (fst xy) (snd xy))).
 apply finite_image.
 apply finite_pair; apply finite_expr_bound; auto.
 intros ? ?; unfold In in *. destruct H. destruct x; simpl in H0; try contradiction.
 unfold In, space_bound in H; destruct H.
 apply Im_intro with (e,e0); split; auto.
Qed.

Lemma finite_pures_bound: forall n, Finite n -> Finite (pures_bound n).
Proof.
intros. apply finite_list_bound.
apply finite_pure_bound; auto.
Qed.

Lemma finite_spaces_bound: forall n, Finite n -> Finite (spaces_bound n).
Proof.
intros. apply finite_list_bound.
apply finite_space_bound; auto.
Qed.

Lemma clause_bound_finite: forall n, Finite n -> Finite (clause_bound n).
Proof.
intros n FIN.
assert (clause_bound n =
               Union
                   (Intersection (clause_bound n)
                       (fun cl => match cl with PureClause _ _ _ _ => True | _ => False end))
               (Union
                  (Intersection (clause_bound n)
                           (fun cl => match cl with PosSpaceClause _ _ _ => True | _ => False end))
                (Intersection (clause_bound n)
                           (fun cl => match cl with NegSpaceClause _ _ _ => True | _ => False end)))).
 set (g:= clause_bound n); clearbody g.
 extensionality x.
 Hint Unfold In.
 apply prop_ext; destruct x; simpl; intuition. left. split; auto.
 repeat destruct H; auto.
 right; left; split; auto.
 repeat destruct H; auto.
 right; right; split; auto.
 repeat destruct H; auto.
 rewrite H.
 apply Union_preserves_Finite.
 apply Finite_downward_closed
    with  (Im (pures_bound2 n)
                             (fun pi2 : list pure_atom * list pure_atom =>
                                                mkPureClause (fst pi2) (snd pi2))).
  apply finite_image.
  apply finite_pair;   apply finite_pures_bound; auto.
  clear.
  intros x H;  destruct H; unfold In in *; destruct x; try contradiction; simpl in *.
  apply Im_intro with (gamma,delta); auto.
  simpl.
  apply pure_clause_ext.
  apply Union_preserves_Finite.
  apply Finite_downward_closed
    with (Im (fun pi3 => pures_bound2 n (fst pi3) /\ spaces_bound n (snd pi3))
                  (fun pi3 => PosSpaceClause  (fst (fst pi3)) (snd (fst pi3)) (snd pi3))).
   apply finite_image.
   apply finite_pair.
   apply finite_pair; apply finite_pures_bound; auto.
   apply finite_spaces_bound; auto.
   clear.
   intros x H;  destruct H; unfold In in *; destruct x; try contradiction; simpl in *.
  apply Im_intro with ((gamma,delta),sigma); auto.
  unfold In. simpl in H. simpl. unfold pures_bound2; intuition.
  apply Finite_downward_closed
    with (Im (fun pi3 => pures_bound2 n (fst pi3) /\ spaces_bound n (snd pi3))
                  (fun pi3 => NegSpaceClause  (fst (fst pi3)) (snd pi3) (snd (fst pi3)))).
   apply finite_image.
   apply finite_pair.
   apply finite_pair; apply finite_pures_bound; auto.
   apply finite_spaces_bound; auto.
  clear.
  intros x H;  destruct H; unfold In in *; destruct x; try contradiction; simpl in *.
  apply Im_intro with ((gamma,delta),sigma); auto.
  unfold In. simpl in H. simpl. unfold pures_bound2; intuition.
Qed.

Definition var2nat v := nat_of_P (id2pos v).

Lemma Finite_var_upto:
  forall v, Finite (var_upto v).
Proof.
 intros.
 apply finite_unimage with var2nat.
 intros ? ? ?. unfold var2nat in *.
 apply Pnat.nat_of_P_inj in H.
 apply id2pos_inj in H; auto.
 apply Finite_downward_closed
  with (fun i => i <= var2nat v).
remember (var2nat v) as n.
clear.
induction n.
apply Finite_downward_closed with (Add (Empty_set _) O).
repeat constructor.
intro H; inversion H.
intros ? ?; unfold In in *.
assert (x=0) by omega. subst. right. apply Singleton_intro; auto.
apply Finite_downward_closed with (Add (fun i => i<=n) (S n)).
constructor; auto.
unfold In; omega.
repeat intro. unfold In in *.
assert (x <= n \/ x = S n) by omega.
destruct H0; [ left | right]; auto.
apply Singleton_intro; auto.
repeat intro; unfold In in *.
inversion H; clear H; subst.
unfold In, var_upto in *.
apply S_nat_of_P_id2pos_le in H0.
unfold var2nat; omega.
Qed.

End ClauseUniverseFinite.

