Require Import VST.floyd.proofauto.
Require Import MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Import MirrorCore.RTac.Try.
Require Import MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.RTac.RTac.
Require Import mc_reify.types.
(* mc_reify.types:
Require Import MirrorCore.Lambda.ExprCore.

Require Import VST.floyd_funcs.

Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import Coq.FSets.FMapPositive.

Inductive typ :=
| tyArr : typ -> typ -> typ
| tytycontext
| tyc_expr
| tyc_type
| tyenviron
| tyval
| tyshare
| tyident
| tylist : typ -> typ
| tyint
| tyZ
| tynat
| typositive
| tybool
| tycomparison
| tytc_assert
| tyint64
| tyfloat
| tyfloat32
| tyattr
| tysignedness
| tyintsize
| tyfloatsize
| tytypelist
| tyfieldlist
| tybinary_operation
| tyunary_operation
| tyN
| tyoption : typ -> typ
| typrop
| tympred
| tysum : typ -> typ -> typ
| typrod : typ -> typ -> typ
| tyunit

| tyOracleKind
| tystatement
| tyret_assert
| tyexitkind
| typtree : typ -> typ
| tygfield
| tyfunspec
| tyefield
| tytype_id_env
| tyllrr

.

Fixpoint typD (t : typ) : Type :=
    match t with
        | tyArr a b => typD a  -> typD b
        | tytycontext => tycontext
        | tyc_expr => expr
        | tyc_type => type
        | tyenviron => environ
        | tyval => val
        | tyshare => share
        | tyident => ident
        | tylist t => list (typD t )
        | tyint => int
        | tyZ => Z
        | tynat => nat
        | typositive => positive
        | tybool => bool
        | tycomparison => comparison
        | tytc_assert => tc_assert
        | tyint64 => int64
        | tyfloat => float
        | tyfloat32 => float32
        | tyattr => attr
        | tysignedness => signedness
        | tyintsize => intsize
        | tyfloatsize  => floatsize
        | tytypelist => typelist
        | tyfieldlist => fieldlist
        | tybinary_operation => Cop.binary_operation
        | tyunary_operation => Cop.unary_operation
        | tyN => N
        | tyoption t => option (typD t )
        | typrop => Prop
        | tympred => mpred
        | tysum t1 t2 => sum (typD  t1 ) (typD  t2 )
        | typrod t1 t2 => prod (typD  t1 ) (typD  t2 )
        | tyunit => unit
        
        | tyOracleKind => OracleKind
        | tystatement => statement
        | tyret_assert => ret_assert

        | tyexitkind => exitkind
        | typtree t => PTree.t (typD t)
        | tygfield => gfield
        | tyfunspec => funspec
        | tyefield => efield
        | tytype_id_env => type_id_env
        | tyllrr => LLRR
    end.

Definition typ_eq_dec : forall a b : typ, {a = b} + {a <> b}.

Instance Typ0_tyProp : Typ0 _ Prop :=
{| typ0 := typrop
 ; typ0_cast :=  eq_refl
 ; typ0_match := fun T  t =>
                   match t as t
                         return T Prop -> T (TypesI.typD  t) -> T (TypesI.typD  t)
                   with
                     | typrop => fun tr _ => tr
                     | _ => fun _ fa => fa
                   end
 |}. *)
Require Import mc_reify.funcs.
(* mc_reify.funcs:
Require Import MirrorCore.syms.SymEnv.
Require Import MirrorCore.Lambda.ExprCore.
Require Import ExtLib.Core.RelDec.
Require Import MirrorCore.TypesI.
Require Import ExtLib.Tactics.
Require Import ExtLib.Data.Fun.

Require Import VST.floyd_funcs.
Require Import mc_reify.types.
Require Import mc_reify.bool_funcs.
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import VST.floyd.local2ptree.
Require Import mc_reify.local2list.

Inductive const :=
| fN : nat -> const
| fZ : Z -> const
| fint : int -> const
| fint64 : int64 -> const
| fPos : positive -> const
| fident : ident -> const
| fCtype : type -> const
| fCexpr : expr -> const
| fComparison : comparison -> const
| fbool : bool -> const
| ffloat : float -> const
| ffloat32 : float32 -> const
| fenv : type_id_env -> const
| fllrr : LLRR -> const
.

Definition typeof_const (c : const) : typ :=
 match c with
| fN _ => tynat
| fZ _ => tyZ
| fPos _ => typositive
| fident _ => tyident
| fCtype _ => tyc_type
| fCexpr _ => tyc_expr
| fComparison _ => tycomparison
| fbool _ => tybool
| fint _ => tyint
| fint64 _ => tyint64
| ffloat _ => tyfloat
| ffloat32 _ => tyfloat32
| fenv _ => tytype_id_env
| fllrr _ => tyllrr
end.

Definition constD (c : const)
: typD (typeof_const c) :=
match c with
| fN c | fZ c | fPos c | fident c | fCtype c | fCexpr c | fComparison c | fbool c | fint c
| fint64 c | ffloat c | ffloat32 c | fenv c | fllrr c
                                          => c
end.

Inductive z_op :=
| fZ_lt
| fZ_le
| fZ_gt
| fZ_ge
| fZ_add
| fZ_sub
| fZ_mul
| fZ_div
| fZ_mod
| fZ_land
| fZ_max
| fZ_opp.

Definition typeof_z_op z : typ :=
match z with
| fZ_lt
| fZ_le
| fZ_gt
| fZ_ge => (tyArr tyZ (tyArr tyZ typrop))
| fZ_add
| fZ_sub
| fZ_mul
| fZ_div
| fZ_mod
| fZ_land
| fZ_max => (tyArr tyZ (tyArr tyZ tyZ))
| fZ_opp => (tyArr tyZ tyZ)
end.

Definition z_opD (z : z_op) : typD  (typeof_z_op z) :=
match z with
| fZ_lt => Z.lt
| fZ_le => Z.le
| fZ_gt => Z.gt
| fZ_ge => Z.ge
| fZ_add => Z.add
| fZ_sub => Z.sub
| fZ_mul => Z.mul
| fZ_div => Z.div
| fZ_mod => Zmod
| fZ_land => Z.land
| fZ_max => Z.max
| fZ_opp => Z.opp
end.

Inductive int_op :=
| fint_add
| fint_and
| fint_lt
| fint_ltu
| fint_mul
| fint_neg
| fint_sub
| fint_cmp
| fint_cmpu
| fint_repr
| fint_signed
| fint_unsigned
| fint_max_unsigned
| fint64_repr.

Definition typeof_int_op i : typ :=
match i with
| fint_lt
| fint_ltu => tyArr tyint (tyArr tyint tybool)
| fint_mul
| fint_sub
| fint_add => tyArr tyint (tyArr tyint tyint)
| fint_and => tyArr tyint (tyArr tyint tyint)
| fint_neg => tyArr tyint tyint
| fint_cmp
| fint_cmpu => tyArr tycomparison (tyArr tyint (tyArr tyint tybool))
| fint_repr => tyArr tyZ tyint
| fint_signed
| fint_unsigned  => tyArr tyint tyZ
| fint_max_unsigned => tyZ
| fint64_repr => tyArr tyZ tyint64
end.

Definition int_opD (i : int_op): typD  (typeof_int_op i) :=
match i with
| fint_add => Int.add
| fint_and => Int.and
| fint_lt => Int.lt
| fint_ltu => Int.ltu
| fint_mul => Int.mul
| fint_neg => Int.neg
| fint_sub => Int.sub
| fint_cmp => Int.cmp
| fint_cmpu => Int.cmpu
| fint_repr => Int.repr
| fint_signed => Int.signed
| fint_unsigned => Int.unsigned
| fint_max_unsigned => Int.max_unsigned
| fint64_repr => Int64.repr
end.

Inductive values :=
| fVint
| fVfloat
| fVlong
| fVptr
| fVundef
| fVsingle.

Definition typeof_value (v : values) :=
match v with
| fVint => tyArr tyint tyval
| fVfloat => tyArr tyfloat tyval
| fVlong => tyArr tyint64 tyval
| fVptr => tyArr typositive (tyArr tyint tyval)
| fVsingle => tyArr tyfloat32 tyval
| fVundef => tyval
end.

Definition valueD  (v : values): typD  (typeof_value v) :=
match v with
| fVint => Vint
| fVfloat => Vfloat
| fVlong => Vlong
| fVptr => Vptr
| fVsingle => Vsingle
| fVundef => Vundef
end.

Inductive eval :=
| feval_cast : type -> type -> eval
| fderef_noload : type -> eval
| feval_field : type -> ident -> eval
| feval_binop : binary_operation -> type -> type -> eval
| feval_unop : unary_operation -> type -> eval
| feval_id : ident -> eval.

Definition typeof_eval (e : eval) :=
 match e with
| feval_cast _ _ => (tyArr tyval tyval)
| fderef_noload _ => (tyArr tyval tyval)
| feval_field _ _ => (tyArr tyval tyval)
| feval_binop _ _ _=> (tyArr tyval (tyArr tyval tyval))
| feval_unop _ _ => (tyArr tyval tyval)
| feval_id _  => (tyArr tyenviron tyval)
end.

Definition evalD  (e : eval) : typD  (typeof_eval e) :=
match e with
| feval_id id => eval_id id
| feval_cast t1 t2 => eval_cast t1 t2
| fderef_noload t => deref_noload t
| feval_field t id => eval_field t id
| feval_binop op t1 t2 => eval_binop op t1 t2
| feval_unop op t => eval_unop op t
end.

Inductive other :=
| ftwo_power_nat
| fforce_ptr
| fand
| falign
| ftyped_true
| feq : typ -> other
| fnone : typ -> other
| fsome : typ -> other
| ftypeof
| fTrue
| fFalse
.

Definition typeof_other (o : other) :=
match o with
| ftwo_power_nat => tyArr tynat tyZ
| fforce_ptr  => tyArr tyval tyval
| fand => tyArr typrop (tyArr typrop typrop)
| falign => tyArr tyZ (tyArr tyZ tyZ)
| ftyped_true => tyArr tyc_type (tyArr tyval typrop)
| feq t => tyArr t (tyArr t typrop)
| fnone t => tyoption t
| fsome t => tyArr t (tyoption t)
| ftypeof => tyArr tyc_expr tyc_type
| fTrue | fFalse => typrop
end.

Definition otherD  (o : other) : typD  (typeof_other o) :=
match o with
| ftwo_power_nat => (two_power_nat : typD (typeof_other ftwo_power_nat))
| fforce_ptr => force_ptr
| fand => and
| falign => align
| ftyped_true => typed_true
| feq t => @eq (typD t)
| fsome t => @Some (typD t)
| fnone t => @None (typD t)
| ftypeof => typeof
| fTrue => True
| fFalse => False
end.

Inductive data :=
| fnil : typ -> data
| fmap : typ -> typ -> data
| ffold_right : typ -> typ -> data
| ffold_left : typ -> typ -> data
| fcons : typ -> data
| fappend : typ -> data
| fnth_error : typ -> nat -> data
| freplace_nth : typ -> nat -> data
| fpair : typ -> typ -> data
| fget : typ -> positive -> data
| fset : typ -> positive -> data
| fleaf : typ -> data
| fnode : typ -> data
| fempty : typ -> data
.

Definition typeof_data (l : data) :=
match l with
| fmap a b => tyArr (tyArr a b) (tyArr (tylist a) (tylist b))
| fnil a => (tylist a)
| ffold_right a b => tyArr (tyArr b (tyArr a a)) (tyArr a (tyArr (tylist b) a))
| ffold_left a b => tyArr (tyArr a (tyArr b a)) (tyArr (tylist b) (tyArr a a))
| fcons a => tyArr a (tyArr (tylist a) (tylist a))
| fappend a => tyArr (tylist a) (tyArr (tylist a) (tylist a))
| fnth_error a _ => tyArr (tylist a) (tyoption a)
| freplace_nth a _ => tyArr (tylist a) (tyArr a (tylist a))
| fpair t1 t2 => tyArr t1 (tyArr t2 (typrod t1 t2))
| fleaf t => typtree t
| fnode t => tyArr (typtree t) (tyArr (tyoption t) (tyArr (typtree t) (typtree t)))
| fset t _ => tyArr t (tyArr (typtree t) (typtree t))
| fget t _ => (tyArr (typtree t) (tyoption t))
| fempty t => typtree t
end.

Definition dataD (l : data) : typD (typeof_data l) :=
match l with
| fmap t1 t2 => @map (typD  t1) (typD  t2)
| fnil t => (@nil (typD t) : typD (typeof_data (fnil t)))
| ffold_right a b => @fold_right (typD a) (typD b)
| ffold_left a b => @fold_left (typD a) (typD b)
| fcons a => @cons (typD a)
| fappend a => @app (typD a)
| fnth_error a n => fun l => @nth_error (typD a) l n
| freplace_nth a n => @canon.replace_nth (typD a) n
| fpair a b => ((@pair (typD a) (typD b)) : typD (typeof_data (fpair a b)))
| fleaf t => @PTree.Leaf (typD t)
| fnode t => @PTree.Node (typD t)
| fset t p => @PTree.set (typD t) p
| fget t p => @PTree.get (typD t) p
| fempty t => @PTree.empty (typD t)
end.

Inductive sep :=
| flocal
| fprop
| fdata_at : type -> sep
| ffield_at : type -> list gfield -> sep
| fproj_val : type -> sep
| fupd_val : type -> sep

.

Fixpoint reptyp (ty: type) : typ :=
  match ty with
  | Tvoid => tyunit
  | Tint _ _ _ => tyval
  | Tlong _ _ => tyval
  | Tfloat _ _ => tyval
  | Tpointer t1 a => tyval
  | Tarray t1 sz a => tylist (reptyp t1)
  | Tfunction t1 t2 _ => tyunit
  | Tstruct id fld a => reptyp_structlist fld
  | Tunion id fld a => reptyp_unionlist fld
  | Tcomp_ptr id a => tyval
  end
with reptyp_structlist (fld: fieldlist) : typ :=
  match fld with
  | Fnil => tyunit
  | Fcons id ty fld' =>
    if is_Fnil fld'
      then reptyp ty
      else typrod (reptyp ty) (reptyp_structlist fld')
  end
with reptyp_unionlist (fld: fieldlist) : typ :=
  match fld with
  | Fnil => tyunit
  | Fcons id ty fld' =>
    if is_Fnil fld'
      then reptyp ty
      else tysum (reptyp ty) (reptyp_unionlist fld')
  end.

Definition typeof_sep (s : sep) : typ :=
match s with
| fdata_at t => tyArr tyshare (tyArr (reptyp t) (tyArr tyval tympred))
| ffield_at t gfs => tyArr tyshare (tyArr (reptyp (nested_field_type2 t gfs)) (tyArr tyval tympred))

| flocal => tyArr (tyArr tyenviron typrop) (tyArr tyenviron tympred)
| fprop => tyArr typrop tympred
| fproj_val t => tyArr (tylist tygfield)
                 (tyArr (reptyp t) tyval)
| fupd_val t => tyArr (tylist tygfield)
                 (tyArr (reptyp t)
                  (tyArr tyval (reptyp t)))
end.

Definition proj1T {A} {B} (x: A /\ B) :=
  match x with
  | conj y z => y
  end.

Definition proj2T {A} {B} (x: A /\ B) :=
  match x with
  | conj y z => z
  end.

Definition typD_reptyp_reptype: forall t, typD  (reptyp t) = reptype t.

Definition reptyp_reptype ty (v: typD  (reptyp ty)): reptype ty :=
  eq_rect_r (fun x => x) v (eq_sym (typD_reptyp_reptype ty)).

Definition reptype_reptyp ty (v: reptype ty): typD  (reptyp ty) :=
  eq_rect_r (fun x => x) v (typD_reptyp_reptype ty).

Lemma reptyp_reptype_reptype_reptyp: forall t v, reptyp_reptype t (reptype_reptyp t v) = v.

Definition sepD  (s : sep) : typD  (typeof_sep s).

Inductive smx :=
| fenviron : environ -> smx
| fsemax
| fstatement : statement -> smx
| fretassert : ret_assert -> smx
| ftycontext : PTree.t (type * bool) -> PTree.t type -> type -> PTree.t type ->  smx
| fupdate_tycon

| fnormal_ret_assert

| fassertD
| flocalD
| fvaltree : PTree.t val -> smx
| fdenote_tc_assert_b_norho
| ftc_expr_b_norho
| ftc_temp_id_b_norho : positive -> type ->  smx

| flater
| flater_lift
| fnested_field_type2
| fis_neutral_cast
| fmsubst_efield_denote : list efield -> smx
| flegal_nested_efield : list type -> smx
| fmsubst_eval_LR
| ftc_LR_b_norho
| ftc_environ
| ftc_efield_b_norho : list efield -> smx
| fnested_efield
| ftypeof_temp
| ftc_val
| flegal_nested_field
| fstruct_field
| funion_field
| farray_subsc
| fwritable_share
| fTsh
| fEws
| ftype_is_by_value
.

Definition typeof_smx (t : smx) :=
match t with
| fsemax => tyArr tyOracleKind (tyArr tytycontext (tyArr (tyArr tyenviron tympred) (tyArr tystatement (tyArr tyret_assert typrop))))
| fstatement s => tystatement
| fretassert r => tyret_assert
| ftycontext _ _ _ _ => tyArr (typtree tyfunspec) tytycontext

| fnormal_ret_assert => tyArr (tyArr tyenviron tympred) (tyret_assert)
| fenviron e => tyenviron
| flocalD  => tyArr (typtree tyval)
                    (tyArr (typtree (typrod tyc_type tyval)) (tylist (tyArr tyenviron typrop)))
| fupdate_tycon => tyArr tytycontext (tyArr tystatement tytycontext)
| fvaltree t => typtree tyval
| fassertD => tyArr  (tylist typrop) (tyArr (tylist (tyArr tyenviron typrop)) (tyArr (tylist tympred) (tyArr tyenviron tympred)))
| fdenote_tc_assert_b_norho => tyArr tytc_assert tybool
| ftc_expr_b_norho => tyArr tytycontext (tyArr tyc_expr tybool)
| ftc_temp_id_b_norho _ _  => tyArr tytycontext (tyArr tyc_expr tybool)

| flater => tyArr tympred tympred
| flater_lift => tyArr (tyArr tyenviron tympred) (tyArr tyenviron tympred)
| fnested_field_type2 => tyArr tyc_type (tyArr (tylist tygfield) tyc_type)
| fis_neutral_cast => tyArr tyc_type (tyArr tyc_type tybool)
| fmsubst_efield_denote _ => tyArr (typtree tyval)
                           (tyArr (typtree (typrod tyc_type tyval))
                                 (tyoption (tylist tygfield)))
| flegal_nested_efield _ => tyArr tytype_id_env
                          (tyArr tyc_type
                           (tyArr tyc_expr
                            (tyArr (tylist tygfield)
                              (tyArr tyllrr tybool))))
| fmsubst_eval_LR => tyArr (typtree tyval)
                     (tyArr (typtree (typrod tyc_type tyval))
                      (tyArr tyc_expr
                       (tyArr tyllrr (tyoption tyval))))
| ftc_LR_b_norho => tyArr tytycontext (tyArr tyc_expr (tyArr tyllrr tybool))
| ftc_environ => tyArr tytycontext (tyArr tyenviron typrop)
| ftc_efield_b_norho efs => tyArr tytycontext tybool
| fnested_efield => tyArr tyc_expr
                    (tyArr (tylist tyefield)
                     (tyArr (tylist tyc_type) tyc_expr))
| ftypeof_temp => tyArr tytycontext (tyArr tyident (tyoption tyc_type))
| ftc_val => tyArr tyc_type (tyArr tyval typrop)
| flegal_nested_field => tyArr tyc_type (tyArr (tylist tygfield) typrop)
| fstruct_field => tyArr tyident tygfield
| funion_field => tyArr tyident tygfield
| farray_subsc => tyArr tyZ tygfield
| fwritable_share => tyArr tyshare typrop
| fTsh => tyshare
| fEws => tyshare
| ftype_is_by_value => tyArr tyc_type tybool
end.

Definition smxD (t : smx) : typD (typeof_smx t) :=
match t with
| fsemax => (@semax : typD (typeof_smx fsemax))
| fstatement s | fretassert s  => s
| ftycontext t v r gt => fun gf => mk_tycontext t v r gt gf

| fnormal_ret_assert => normal_ret_assert
| fenviron e => (e : typD (typeof_smx (fenviron e)))
| flocalD => localD
| fupdate_tycon => update_tycon
| fvaltree t => t
| fassertD => assertD
| fdenote_tc_assert_b_norho => (denote_tc_assert_b_norho : typD (typeof_smx fdenote_tc_assert_b_norho))
| ftc_expr_b_norho => tc_expr_b_norho
| ftc_temp_id_b_norho id ty  => tc_temp_id_b_norho id ty

| flater => later
| flater_lift => later
| fnested_field_type2 => nested_field_type2
| fis_neutral_cast => is_neutral_cast
| fmsubst_efield_denote efs => (fun T1 T2 => msubst_efield_denote T1 T2 efs)
| flegal_nested_efield tts => (fun e t_root e1 gfs => legal_nested_efield e t_root e1 gfs tts)
| fmsubst_eval_LR => msubst_eval_LR
| ftc_LR_b_norho => tc_LR_b_norho
| ftc_environ => tc_environ
| ftc_efield_b_norho efs => (fun tycon => tc_efield_b_norho tycon efs)
| fnested_efield => nested_efield
| ftypeof_temp => typeof_temp
| ftc_val => tc_val
| flegal_nested_field => legal_nested_field
| fstruct_field => StructField
| funion_field => UnionField
| farray_subsc => ArraySubsc
| fwritable_share => writable_share
| fTsh => SeparationLogic.Tsh
| fEws => assert_lemmas.Ews
| ftype_is_by_value => client_lemmas.type_is_by_value
end.

Inductive func' :=
| Const : const -> func'
| Zop : z_op -> func'
| Intop : int_op -> func'
| Value : values -> func'
| Eval_f : eval -> func'
| Other : other -> func'
| Sep : sep -> func'
| Data : data -> func'
| Smx : smx -> func'.

Definition func := (SymEnv.func + @ilfunc typ + @bilfunc typ + func')%type.

Definition typeof_func (f: func') : typ :=
match f with
| Const c => typeof_const c
| Zop z => typeof_z_op z
| Intop i => typeof_int_op i
| Value v => typeof_value v
| Eval_f e => typeof_eval e
| Other o => typeof_other o
| Sep s => typeof_sep s
| Data l => typeof_data l
| Smx t => typeof_smx t
end.

Definition funcD  (f : func') : typD  (typeof_func f) :=
match f with
| Const c => constD  c
| Zop z => z_opD  z
| Intop i => int_opD  i
| Value v => valueD  v
| Eval_f e => evalD  e
| Other o => otherD  o
| Sep s => sepD  s
| Data l => dataD l
| Smx t => smxD t
end. *)
Require Import mc_reify.func_defs.
(* mc_reify.func_defs:
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import MirrorCharge.SynSepLog.
Require Import MirrorCharge.SepLogFold.
Require Export MirrorCore.RTac.RTac.
Require Export MirrorCore.RTac.Core.

Require Export mc_reify.bool_funcs.
Require MirrorCore.syms.SymEnv.
Require MirrorCore.syms.SymSum.
Require Import MirrorCore.Subst.FMapSubst.

Require Import VST.floyd_funcs.
Require Export MirrorCore.Lambda.Expr.
Require Export mc_reify.types.
Require Export mc_reify.func_eq.
Require Export mc_reify.funcs.

Definition typeof_func_opt t := Some (typeof_func t).

Definition eqb_sym a b := match func_beq a b with
                        | true => Some true
                        | false => None
end.

Global Instance RSym_Func' : SymI.RSym func' := {
   typeof_sym := typeof_func_opt;
   symD := funcD;
   sym_eqb := eqb_sym
}.

Global Instance RSymOk_Func' : SymI.RSymOk RSym_Func'.

Definition appR (e1 : func') e2 :=
App (@Inj typ func (inr e1)) (e2).
Definition injR (e1 : func') := @Inj typ func (inr e1).

Definition ilops : @logic_ops _ RType_typ :=
fun t =>
  match t
          return option (ILogic.ILogicOps (typD t))
  with
  | tympred => Some _
  | typrop => Some _
  | _ => None
end.

Definition bilops : @bilogic_ops _ RType_typ :=
fun t =>
  match t
          return option (BILogic.BILOperators (typD t))
  with
  | tympred => Some _
  | _ => None
end.

Instance RSym_ilfunc : RSym (@ilfunc typ) :=
	RSym_ilfunc _ _ ilops.
Instance RSym_bilfunc : RSym (@bilfunc typ) :=
	RSym_bilfunc _ bilops.

Existing Instance SymSum.RSym_sum.
Existing Instance SymSum.RSymOk_sum.

Definition subst : Type :=
  FMapSubst.SUBST.raw (expr typ func).
Instance SS : SubstI.Subst subst (expr typ func) :=
  @FMapSubst.SUBST.Subst_subst _.

Definition RSym_sym fs := SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum (SymEnv.RSym_func fs) RSym_ilfunc) RSym_bilfunc)
  RSym_Func'.

SearchAbout Expr.
Definition Expr_expr_fs fs: ExprI.Expr _ (ExprCore.expr typ func) := @ExprD.Expr_expr typ func _ _ (RSym_sym fs).
Definition Expr_ok_fs fs: @ExprI.ExprOk typ RType_typ (ExprCore.expr typ func) (Expr_expr_fs fs) := ExprD.ExprOk_expr.

Definition reflect ft tus tvs e (ty : typ)
 := @exprD _ _ _ (Expr_expr_fs ft) tus tvs e ty.

Definition reflect_prop tbl e := reflect tbl nil nil e (typrop).

Definition reflect_prop' tbl e := match (reflect tbl nil nil e typrop) with
| Some p => p
| None => False
end.

Definition node l o r t : expr typ func :=
(App (App (App (Inj (inr (Data (fnode t)))) l) o) r).

Definition leaf t : expr typ func:=
(Inj (inr (Data (fleaf t)))).

Definition some_reif e t : expr typ func :=
(App (Inj (inr (Other (fsome t)))) e).

Definition none_reif t : expr typ func :=
(Inj (inr (Other (fnone t)))).

Instance MA : MentionsAny (expr typ func) := {
  mentionsAny := ExprCore.mentionsAny
}.

Let elem_ctor : forall x : typ, typD x -> @SymEnv.function typ _ :=
  @SymEnv.F _ _.

Let Ext x := @ExprCore.Inj typ func (inl (inl (inl x))).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.
Let Expr_expr := Expr_expr_fs tbl.
Existing Instance Expr_expr.
Existing Instance Expr_ok_fs.

Definition exprD_Prop (uvar_env var_env : EnvI.env) (e : expr typ func) :=
  match exprD uvar_env var_env e typrop with
    | Some e' => e'
    | None => True
  end.

Definition goalD_Prop (uvar_env var_env : EnvI.env) goal :=
  let (tus, us) := split_env uvar_env in
  let (tvs, vs) := split_env var_env in
  match goalD tus tvs goal with
    | Some e => e us vs
    | None => False
  end.

Definition goalD_aux tus tvs goal (us : HList.hlist typD tus) (vs : HList.hlist typD tvs) :=
  match goalD tus tvs goal with
    | Some e => Some (e us vs)
    | None => None
  end.

End tbled. *)
Require Import mc_reify.app_lemmas.
(* mc_reify.app_lemmas:
Require Import MirrorCore.Lambda.ExprCore.
Require Import MirrorCore.Lambda.Expr.
Require Import MirrorCore.ExprI.
Require Import MirrorCore.Lambda.ExprDsimul.
Import ExprDenote.

Section Expr.

  Context {typ : Type}
          {func : Type}.
  Context {RT : RType typ}
          {T2 : Typ2 _ PreFun.Fun}
          {RS : RSym func}.
Locate exprD'.
Check exprD'.
  Instance Expr_expr : @Expr typ _ (@expr typ func) :=
  { exprD' := fun tus tvs e t => @exprD' _ _ _ _ _ tus tvs t e
  ; wf_Expr_acc := @wf_expr_acc typ func

  }.

  Context {RTOk : RTypeOk}
          {T2Ok : Typ2Ok T2}
          {RSOk : RSymOk RS}.

Lemma exprD'_App_L_rw
: forall tus tvs td t e1 e2 e1D e2D,
    typeof_expr tus tvs e1 = Some (typ2 td t) ->
    exprD' tus tvs (typ2 td t) e1 = Some e1D ->
    exprD' tus tvs td e2 = Some e2D ->
    exprD' tus tvs t (App e1 e2) = Some (exprT_App e1D e2D).

Lemma exprD'_App_R_rw
: forall tus tvs td t e1 e2 e1D e2D,
    typeof_expr tus tvs e2 = Some td ->
    exprD' tus tvs td e2 = Some e2D ->
    exprD' tus tvs (typ2 td t) e1 = Some e1D ->
    exprD' tus tvs t (App e1 e2) = Some (exprT_App e1D e2D).

End Expr. *)
Require Import MirrorCore.LemmaApply.
Require Import ExtLib.Tactics.
Require Import MirrorCore.Util.ListMapT.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Import mc_reify.rtac_base.
(* mc_reify.rtac_base:
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Import MirrorCore.RTac.Then.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.typ_eq.
Require Import mc_reify.func_defs.
Require Import MirrorCore.LemmaApply.
Require Import ExtLib.Tactics.
Require Import MirrorCore.Util.ListMapT.

Definition rtacP := sigT (fun tac: rtac typ (expr typ func) =>
  forall tbl: SymEnv.functions RType_typ, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac).

Definition my_lemma := lemma typ (ExprCore.expr typ func) (ExprCore.expr typ func).

Definition THEN' (r1 r2 : rtac typ (expr typ func)) := THEN r1 (runOnGoals r2).

Definition THEN (r1 r2 : rtac typ (expr typ func)) :=
  THEN' r1 (THEN' (INSTANTIATE typ func) r2).

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.

Lemma THEN_sound : forall t1 t2,
rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t1 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) t2 -> rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) (THEN t1 t2).
intros. unfold THEN.
unfold THEN'.
apply THEN_sound; auto.
apply runOnGoals_sound; auto;
rtac_derive_soundness.
apply INSTANTIATE_sound.
apply runOnGoals_sound. auto.

Definition APPLY_sound := (@APPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _ _ ).

Definition EAPPLY_sound :=
  (@EAPPLY_sound _ (expr typ func) _ _ _ _ _ _ _ _ _ _). 
Lemma APPLY_condition1: vars_to_uvars_spec vars_to_uvars.

Lemma APPLY_condition2:
 forall (subst : Type) (S : Subst subst (expr typ func))
   (SO : SubstOk S) (SU : SubstUpdate subst (expr typ func))
   (SUO : SubstUpdateOk SU SO),
 UnifyI.unify_sound

End tbled.

Definition thenP (t1 t2: rtacP) : rtacP :=
  match t1, t2 with
  | existT tac1 p1, existT tac2 p2 =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
   (THEN tac1 tac2) (fun tbl => THEN_sound tbl _ _ (p1 tbl) (p2 tbl))
  end.

Definition repeatP (n: nat) (t: rtacP) : rtacP :=
  match t with
  | existT tac p =>
      @existT (rtac typ (expr typ func))
        (fun tac => forall tbl, rtac_sound (Expr_expr := func_defs.Expr_expr_fs tbl) tac)
        (REPEAT n tac)
        (fun tbl => @REPEAT_sound _ _ _ _ _ (Expr_ok_fs tbl) _ _ _ n _ (p tbl))
  end. *)
Require Import mc_reify.reified_ltac_lemmas.
(* mc_reify.reified_ltac_lemmas:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Lemma mpred_prop_right: forall (P: mpred) (Q: Prop), Q -> P |-- !! Q.

Lemma mpred_now_later: forall (P: mpred), P |-- |> P.

Lemma mpred_derives_refl: forall (P: mpred), P |-- P.

Lemma mpred_semax_post' : forall (R' : environ -> mpred) (Espec : OracleKind)
         (Delta : tycontext) (R P : environ -> mpred)
         (c : statement),
       (forall rho, R' rho |-- R rho) ->
       semax Delta P c (normal_ret_assert R') ->
       semax Delta P c (normal_ret_assert R).

Require Export mc_reify.reify.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.rtac_base.

Definition reify_prop_right: my_lemma.

Definition reify_now_later : my_lemma.

Definition reify_derives_refl : my_lemma.

Definition reify_semax_post' : my_lemma.

Definition writable_Tsh_lemma: my_lemma.

Definition writable_Ews_lemma: my_lemma.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma APPLY_sound_prop_right: rtac_sound (EAPPLY typ func reify_prop_right).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_now_later: rtac_sound (EAPPLY typ func reify_now_later).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_derives_refl: rtac_sound (EAPPLY typ func reify_derives_refl).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_semax_post': rtac_sound (EAPPLY typ func reify_semax_post').
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_writable_Tsh: rtac_sound (APPLY typ func writable_Tsh_lemma).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma APPLY_sound_writable_Ews: rtac_sound (APPLY typ func writable_Ews_lemma).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

End tbled. *)
Require Import mc_reify.hoist_later_in_pre.
(* mc_reify.hoist_later_in_pre:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Require Export mc_reify.reify.
Require Export mc_reify.bool_funcs.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.rtac_base.
Require Import mc_reify.reified_ltac_lemmas.

Fixpoint rstrip_1_later_sep (R: expr typ func) : expr typ func :=
  match R with
  | Inj (inr (Data (fnil tympred))) => Inj (inr (Data (fnil tympred)))
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    match hd with
    | App (Inj (inr (Smx flater))) hd0 => App (App (Inj (inr (Data (fcons tympred)))) hd0) (rstrip_1_later_sep tl)
    | _ => App (App (Inj (inr (Data (fcons tympred)))) hd) (rstrip_1_later_sep tl)
    end
  | _ => R
  end.

Lemma SEPx_map_liftx: forall R, SEPx (map liftx R) = liftx (fold_right sepcon emp R).

Lemma hoist_later_in_pre_aux:
    forall temp var ret gt s
      gs P T1 T2 R R' Post,
  forall {Espec: OracleKind},
      fold_right sepcon emp R |-- |> (fold_right sepcon emp R') ->
      semax (mk_tycontext temp var ret gt gs) (|> (assertD P (localD T1 T2) R')) s (normal_ret_assert Post) ->
      semax (mk_tycontext temp var ret gt gs) (assertD P (localD T1 T2) R) s (normal_ret_assert Post).

Lemma fold_right_sepcon_later_derives: forall P P' Q Q' R,
  P |-- |> P' ->
  fold_right sepcon emp Q |-- |> (fold_right sepcon emp Q') ->
  (fold_right sepcon emp (P' :: Q')) = R ->
  fold_right sepcon emp (P :: Q) |-- |> R.

Definition reify_hlip_base (temp : PTree.t (type * bool)) (var : PTree.t type)

Definition reify_hlip_ind : my_lemma.

Section tbled.

Variable tbl : SymEnv.functions RType_typ.
Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Definition solve_hd_in_hlip (hd: expr typ func) : rtac typ (expr typ func) :=
  match hd with
  | App (Inj (inr (Smx flater))) _ => EAPPLY typ func reify_derives_refl
  | _ => EAPPLY typ func reify_now_later
  end.

Fixpoint solve_strip_1_later (R: expr typ func) : rtac typ (expr typ func) :=
  match R with
  | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN (EAPPLY typ func reify_hlip_ind)
     (THEN (TRY (REFLEXIVITY tbl))
           (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
  | _ => FAIL
  end.

Definition HLIP temp var ret gt R s :=
  THEN (EAPPLY typ func (reify_hlip_base temp var ret gt s))
       (TRY (solve_strip_1_later R)).

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma HLIP_sound_aux0: forall temp var ret gt s, rtac_sound (EAPPLY typ func (reify_hlip_base temp var ret gt s)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Lemma HLIP_sound_aux1: rtac_sound (EAPPLY typ func reify_hlip_ind).
Proof.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env. simpl. intros.

Definition HLIP_sound_aux2 (hd: expr typ func): rtac_sound (solve_hd_in_hlip hd) :=
    match hd as hd'
      return rtac_sound match hd' with
                        | App (Inj (inr (Smx flater))) _ => EAPPLY typ func reify_derives_refl
                        | _ => EAPPLY typ func reify_now_later
                        end
    with
    | App (Inj (inr (Smx flater))) _ => APPLY_sound_derives_refl tbl
    | _ => APPLY_sound_now_later tbl
    end.

Print Forall_cons.
Lemma tttt: Forall (fun x => In x [1; 3; 4]) [1; 3; 4].

Lemma solve_strip_1_later_def: forall R,
  match R with
  | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN (EAPPLY typ func reify_hlip_ind)
     (THEN (TRY (REFLEXIVITY tbl))
           (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
  | _ => FAIL
  end =
  solve_strip_1_later R.

Fixpoint solve_strip_1_later_sound (R: expr typ func) : rtac_sound (solve_strip_1_later R) :=
  let res :=
  match R as R'
    return rtac_sound match R' with
                      | Inj (inr (Data (fnil tympred))) => EAPPLY typ func reify_now_later
                      | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
                        THEN (EAPPLY typ func reify_hlip_ind)
                         (THEN (TRY (REFLEXIVITY tbl))
                               (FIRST [solve_hd_in_hlip hd; solve_strip_1_later tl]))
                      | _ => FAIL
                      end
  with
  | Inj (inr (Data (fnil tympred))) => APPLY_sound_now_later tbl
  | App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
    THEN_sound tbl _ _ HLIP_sound_aux1
     (THEN_sound tbl _ _ (TRY_sound (REFLEXIVITYTAC_sound tbl))
                        (FIRST_sound (Forall_cons _ (HLIP_sound_aux2 hd)
                                       (Forall_cons _ (solve_strip_1_later_sound tl) (Forall_nil _)))))
  | _ => FAIL_sound
  end in
  eq_rect_r rtac_sound res (eq_sym (solve_strip_1_later_def R)). 

Lemma HLIP_sound: forall temp var ret gt R s, rtac_sound (HLIP temp var ret gt R s).

End tbled. *)
Require Import mc_reify.set_load_store.
(* mc_reify.set_load_store:
Require Import VST.floyd.proofauto.
Require Import mc_reify.bool_funcs.
Require Import Coq.Logic.JMeq.
Local Open Scope logic.

Require Export mc_reify.reify.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.get_set_reif.
Require Import mc_reify.func_defs.
Require Import mc_reify.typ_eq.
Require Import mc_reify.func_defs.
Require Import mc_reify.rtac_base.

Lemma semax_set_localD:
    forall temp var ret gt
      id (e: Clight.expr) ty gs P T1 T2 R Post v,

Definition set_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

Lemma tc_LR_b_sound: forall Delta P T1 T2 R e1 lr p,
  msubst_eval_LR T1 T2 e1 lr = Some p ->
  assertD P (localD T1 T2) R |-- !! (isptr p) ->
  tc_LR_b_norho Delta e1 lr = true ->
  assertD P (localD T1 T2) R |-- local (tc_LR Delta e1 lr).

Lemma nth_error_prop:
  forall P T1 T2 R Rn (n : nat) S,
  assertD P (localD T1 T2) [Rn] |-- !! S ->
  nth_error R n = Some Rn ->
  assertD P (localD T1 T2) R |-- !! S.

Lemma semax_load_localD:
forall (temp : PTree.t (type * bool)) (var : PTree.t type)

Definition load_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

Lemma semax_store_localD:
    forall (temp : PTree.t (type * bool)) (var : PTree.t type)

Definition store_lemma (temp : PTree.t (type * bool)) (var : PTree.t type)

Section tbled.
Variable n : nat.
Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Lemma load_store_sound_aux:
  forall t_root, (@funcAs typ func RType_typ
              (func_defs.RSym_sym tbl)

Lemma APPLY_sound_store_lemma: forall (temp : PTree.t (type * bool)) (var : PTree.t type)
  (ret : type) (gt : PTree.t type) (t t_root : type)
  (e0 e1 e2 : Clight.expr) (efs : list efield) (tts : list type)
  (e : type_id_env) (lr : LLRR) (n : nat),
  rtac_sound (EAPPLY typ func (store_lemma temp var ret gt t t_root e0 e1 e2 efs tts e lr n)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env, Lemma.lemmaD'. simpl.

Lemma APPLY_sound_load_lemma: forall (temp : PTree.t (type * bool)) (var : PTree.t type)
  (ret : type) (gt : PTree.t type) (id : ident) (t t_root : type)
  (e0 e1 : Clight.expr) (efs : list efield) (tts : list type)
  (e : type_id_env) (lr : LLRR) (n : nat),
  rtac_sound (EAPPLY typ func (load_lemma temp var ret gt id t t_root e0 e1 efs tts e lr n)).
Proof.
  intros.
  apply EAPPLY_sound; auto with typeclass_instances.
  + apply APPLY_condition1.
  + apply APPLY_condition2.
  + unfold Lemma.lemmaD, split_env, Lemma.lemmaD'. simpl.

End tbled. *)
Require Import mc_reify.symexe.
(* mc_reify.symexe:
Require Export mc_reify.reify.
Import VST.floyd.proofauto.
Require Export mc_reify.bool_funcs.
Require Import mc_reify.set_reif.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Import mc_reify.update_tycon.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Import mc_reify.typ_eq.
Require Export mc_reify.reflexivity_tacs.
Require Import mc_reify.func_defs.
Require Import MirrorCharge.RTac.Cancellation.
Require Import mc_reify.rtac_base.
Require Import mc_reify.reified_ltac_lemmas.
Require Import mc_reify.hoist_later_in_pre.
Require Import mc_reify.set_load_store.

Local Open Scope logic.

Ltac reify_expr_tac :=
match goal with
| [ |- ?trm] => reify_vst trm
end.

Ltac do_local2ptree := do 2 (erewrite local2ptree_soundness; [ | repeat constructor ]);
repeat rewrite LocalD_to_localD.

Ltac pull_sep_lift R :=
match R with
| ((`?H) :: ?T) => let rest := pull_sep_lift T in constr:(cons H rest)
| (@nil _) => constr:(@nil mpred)
end.

Ltac extract_sep_lift_semax :=
  match goal with
      [ |- context [semax _ 
                 (PROPx ?P1 (LOCALx ?Q1 (SEPx ?R1))) _
                 (normal_ret_assert  _)]] =>
      let R1' := pull_sep_lift R1 in
      
      try (change (PROPx (P1) (LOCALx Q1 (SEPx (R1))))
      with (assertD nil Q1 R1'))
end.

Ltac hnf_tycontext :=
match goal with
[ |- context [semax ?s _ _ _] ] => let ss := eval hnf in s in change s with ss
end.

Ltac prepare_reify :=
do_local2ptree;
extract_sep_lift_semax;
hnf_tycontext.

Definition remove_global_spec (t : tycontext) :=
match t with
| mk_tycontext t v r gt gs => mk_tycontext t v r gt (PTree.empty _)
end.

Definition is_array_type (t: Ctypes.type) : bool :=
  match t with
  | Tarray _ _ _ => true
  | _ => false
  end.

Fixpoint no_load_expr_bool (e: Clight.expr) : bool :=
  match e with
  | Econst_int _ _ => true
  | Econst_float _ _ => true
  | Econst_single _ _ => true
  | Econst_long _ _ => true
  | Evar _ t => is_array_type t
  | Etempvar _ _ => true
  | Ederef _ _ => false
  | Eaddrof e0 _ => no_load_lvalue_bool e0
  | Eunop _ e0 _ => no_load_expr_bool e0
  | Ebinop _ e0 e1 _ => (no_load_expr_bool e0 && no_load_expr_bool e1)%bool
  | Ecast e0 _ => no_load_expr_bool e0
  | Efield e0 _ t => (is_array_type t && no_load_lvalue_bool e0)%bool
  end
with no_load_lvalue_bool (e: Clight.expr) : bool :=
  match e with
  | Econst_int _ _ => false
  | Econst_float _ _ => false
  | Econst_single _ _ => false
  | Econst_long _ _ => false
  | Evar _ _ => true
  | Etempvar _ _ => false
  | Ederef _ _ => false
  | Eaddrof _ _ => false
  | Eunop _ _ _ => false
  | Ebinop _ _ _ _ => false
  | Ecast _ _ => false
  | Efield e0 _ _ => no_load_lvalue_bool e0
  end.

Inductive ForwardRule : Type :=
| ForwardSet
| ForwardLoad
| ForwardCastLoad
| ForwardStore
| ForwardSeq: statement -> statement -> ForwardRule
| ForwardSkip.

Definition compute_forward_rule (s: statement) : option ForwardRule :=
  match s with
  | Sskip => Some ForwardSkip
  | Ssequence s1 s2 => Some (ForwardSeq s1 s2)
  | Sassign _ _ => Some ForwardStore
  | Sset _ e =>
    if no_load_expr_bool e
    then Some ForwardSet
    else match e with
         | Ecast _ _ => Some ForwardCastLoad
         | _ => Some ForwardLoad
         end
  | _ => None
  end.

Definition get_arguments_delta (e : expr typ func) :=
  match e with
  | App (Inj (inr (Smx (ftycontext t v r gt)))) gf => Some (t, v, r, gt, gf)
  | _ => None
  end.

Definition get_arguments_pre (e : expr typ func) :=
  match e with
  | App (App (App (Inj (inr (Smx fassertD))) P)
      (App (App (Inj (inr (Smx flocalD))) T1) T2)) R => Some (P, T1, T2, R, rstrip_1_later_sep R)
  | _ => None
  end.

Definition get_arguments_statement (e : expr typ func) :=
  match e with
  | Inj (inr (Smx (fstatement s))) => Some s
  | _ => None
  end.

Fixpoint get_arguments (e : expr typ func) :=
match e with
| App (App (App (App (App (Inj (inr (Smx fsemax))) _) Delta) Pre) CCmd) _ =>
  (get_arguments_delta Delta,
   get_arguments_pre Pre,
   get_arguments_statement CCmd)
| App _ e
| Abs _ e => get_arguments e
| _ => (None, None, None)
end.

Definition compute_hlip_arg (arg:
         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *
          expr typ func) *
       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *
       statement) :=
  match arg with
  | ((t, v, r, gt, _), (_, _, _, R, _), s) => (t, v, r, gt, s, R)
  end.

Definition compute_set_arg (arg:
         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *

Definition sem_eqb_func := @sym_eqb _ _ _ (SymSum.RSym_sum
  (SymSum.RSym_sum (SymSum.RSym_sum RSym_SymEnv_fun RSym_ilfunc) RSym_bilfunc)
  RSym_Func').

Fixpoint expr_beq (e1 e2: expr typ func) : bool :=
  match e1, e2 with
  | Var i1, Var i2 => beq_nat i1 i2
  | Inj f1, Inj f2 =>
    match sem_eqb_func f1 f2 with
    | Some true => true
    | _ => false
    end
  | App e11 e12, App e21 e22 => andb (expr_beq e11 e21) (expr_beq e12 e22)
  | Abs ty1 e11, Abs ty2 e21 => andb (expr_beq e11 e21) (typ_beq ty1 ty2)
  | UVar i1, UVar i2 => beq_nat i1 i2
  | _, _ => false
  end.

End empty_RSym_sym.

Fixpoint nth_solver_rec (R: expr typ func) (p: expr typ func) (n: nat) :=
match R with
| Inj (inr (Data (fnil tympred))) => None
| App (App (Inj (inr (Data (fcons tympred)))) hd) tl =>
  match hd with
  | App (App (App (Inj (inr (Sep (fdata_at t_root)))) sh) v) p' =>
      if (expr_beq p p')
      then Some (t_root, n)
      else nth_solver_rec tl p (S n)
  | _ => nth_solver_rec tl p (S n)
  end
| _ => None
end.

Definition nth_solver R p := nth_solver_rec R p 0.

Definition compute_load_arg (arg:
         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *
          expr typ func) *
       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *
       statement) :=
  match arg with
  | ((t, v, r, gt, _), (_, T1, T2, _, R'), s) =>
    match s with
    | Sset i e0 =>
      match t ! i, compute_nested_efield e0 with
      | Some (ty, _), (e1, efs, tts) =>
        let lr := compute_lr e1 efs in
        match rmsubst_eval_LR T1 T2 e1 lr with
        | App (Inj (inr (Other (fsome tyval)))) p =>
          match nth_solver R' p with
          | Some (t_root, n) =>
              Some (t, v, r, gt, i, ty, t_root, e0, e1, efs, tts, lr, n)
          | _ => None
          end
        | _ => None
        end
      | _, _ => None
      end
    | _ => None
    end
  end.

Definition compute_store_arg (arg:
         (PTree.t (type * bool) * PTree.t type * type * PTree.t type *
          expr typ func) *
       (expr typ func * expr typ func * expr typ func * expr typ func * expr typ func) *
       statement) :=
  match arg with
  | ((t, v, r, gt, _), (_, T1, T2, _, R'), s) =>
    match s with
    | Sassign e0 e2 =>
      match compute_nested_efield e0 with
      | (e1, efs, tts) =>
        let ty := typeof e0 in
        let lr := compute_lr e1 efs in
        match rmsubst_eval_LR T1 T2 e1 lr with
        | App (Inj (inr (Other (fsome tyval)))) p =>
          match nth_solver R' p with
          | Some (t_root, n) =>
              Some (t, v, r, gt, ty, t_root, e0, e1, e2, efs, tts, lr, n)
          | _ => None
          end
        | _ => None
        end
      end
    | _ => None
    end
  end.

Section tbled.

Variable n : nat.
Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Lemma semax_seq_reif c1 c2 : forall  (Espec : OracleKind)
         (P : environ -> mpred)  (P' : environ -> mpred)
          (Q : ret_assert) (Delta : tycontext) ,
       @semax Espec Delta P c1 (normal_ret_assert P') ->
       @semax Espec (update_tycon Delta c1) P' c2 Q ->
       @semax Espec Delta P (Ssequence c1 c2) Q.

Definition skip_lemma : my_lemma.

Definition seq_lemma (s1 s2: statement)  : my_lemma.

Definition replace_set (e : expr typ func) : expr typ func :=
match e with
| App (App (App (App (App (Inj (inr (Smx fsemax))) es)
                     Delta) pre) s) post =>
  let newpre :=
      match pre with
        |  App (App (App (Inj (inr (Smx fassertD))) P)
                    (App (App (Inj (inr (Smx flocalD)))
                              T1) T2)) R =>
           let newT1 := match T1 with
                          | App (App
                                    (Inj (inr (Data (fset tyval n))))
                                    val) T1' =>
                            get_set_reif.set_reif n val T1' tyval
                          | _ => T1
                        end in
           App (App (App (Inj (inr (Smx fassertD))) P)
                    (App (App (Inj (inr (Smx flocalD)))
                              newT1) T2)) R
        | _ => pre
      end in
  App (App (App (App (App (Inj (inr (Smx fsemax))) es)
                     Delta) newpre) s) post
| _ => e
end.

Definition SIMPL_SET : rtac typ (ExprCore.expr typ func) :=
SIMPLIFY (fun _ _ _ _ => replace_set).

Definition update_tycon_tac (l : list (option (expr typ func)))
(e : expr typ func) (args : list (expr typ func))
	: expr typ func :=
match e with
    | (Inj (inr (Smx (fupdate_tycon)))) =>
      match args with
          | [App (Inj (inr (Smx (ftycontext t v r gt)))) gs; (Inj (inr (Smx (fstatement s))))] =>
            App (Inj (inr (Smx (ftycontext (update_temp t s) v r gt)))) gs
          | _ =>  AppN.apps e args
      end
    | _ => AppN.apps e args
end.

Definition SIMPL_DELTA : rtac typ (ExprCore.expr typ func) :=
SIMPLIFY (fun _ _ _ _=>beta_all update_tycon_tac).

Definition INTROS := (REPEAT 10 (INTRO typ func)).

Definition APPLY_SKIP :=  (APPLY typ func  skip_lemma).

Definition run_tac (t: rtac typ (ExprCore.expr typ func)) e :=
  t nil nil 0%nat 0%nat (CTop nil nil) (ctx_empty (expr := expr typ func)) e.

Definition run_tac_intros e :=
run_tac (THEN INTROS e).

Definition APPLY_SEQ' s1 s2 := (EAPPLY typ func (seq_lemma s1 s2)).

Definition APPLY_SEQ s1 s2 := THEN (APPLY_SEQ' s1 s2) (SIMPL_DELTA).

Definition FORWARD_SET Delta Pre s :=
  let _HLIP :=
  match compute_hlip_arg (Delta, Pre, s) with
  | (temp, var, ret, gt, s, R) => HLIP tbl temp var ret gt R s
  end in
  let _APPLY_SET :=
  match compute_set_arg (Delta, Pre, s) with
  | Some (temp, var, ret, gt, i, e0, ty) =>
      THEN (EAPPLY typ func (set_lemma temp var ret gt i e0 ty))
           (TRY (FIRST [REFLEXIVITY_OP_CTYPE tbl;
                        REFLEXIVITY_MSUBST tbl;
                        REFLEXIVITY_BOOL tbl;
                        AFTER_SET_LOAD tbl;
                        REFLEXIVITY tbl]))
  | _ => FAIL
  end in
  THEN _HLIP _APPLY_SET.

Definition FORWARD_LOAD Struct_env Delta Pre s :=
  let _HLIP :=
  match compute_hlip_arg (Delta, Pre, s) with
  | (temp, var, ret, gt, s, R) => HLIP tbl temp var ret gt R s
  end in
  let _APPLY_LOAD :=
  match compute_load_arg (Delta, Pre, s) with
  | Some (t, v, r, gt, i, ty, t_root, e0, e1, efs, tts, lr, n) =>
            (THEN (EAPPLY typ func (load_lemma t v r gt i ty t_root e0 e1 efs tts Struct_env lr n))
            (THEN (TRY (FIRST [REFLEXIVITY_OP_CTYPE tbl;
                               REFLEXIVITY_BOOL tbl;
                               REFLEXIVITY_CEXPR tbl;
                               AFTER_SET_LOAD tbl;
                               REFLEXIVITY tbl;
                               REFLEXIVITY_MSUBST tbl;
                               REFLEXIVITY_MSUBST_EFIELD tbl;
                               REFLEXIVITY_NTH_ERROR tbl]))
                  (TRY (THEN INTROS
                       (THEN (EAPPLY typ func reify_prop_right)
                             (REFLEXIVITY tbl))))))
  | _ => FAIL
  end in
  THEN _HLIP _APPLY_LOAD.

Definition FORWARD_STORE Struct_env Delta Pre s :=
  let _HLIP :=
  match compute_hlip_arg (Delta, Pre, s) with
  | (temp, var, ret, gt, s, R) => HLIP tbl temp var ret gt R s
  end in
  let _APPLY_STORE :=
  match compute_store_arg (Delta, Pre, s) with
  | Some (t, v, r, gt, ty, t_root, e0, e1, e2, efs, tts, lr, n) =>
            (THEN (EAPPLY typ func (store_lemma t v r gt ty t_root e0 e1 e2 efs tts Struct_env lr n))
            (THEN (TRY (FIRST [REFLEXIVITY_CTYPE tbl;
                               REFLEXIVITY_BOOL tbl;
                               REFLEXIVITY_CEXPR tbl;
                               AFTER_STORE tbl;
                               REFLEXIVITY tbl;
                               FIRST [APPLY typ func writable_Tsh_lemma; APPLY typ func writable_Ews_lemma];
                               REFLEXIVITY_MSUBST tbl;
                               REFLEXIVITY_MSUBST_EFIELD tbl;
                               REFLEXIVITY_NTH_ERROR tbl]))
                  (TRY (THEN INTROS
                       (THEN (EAPPLY typ func reify_prop_right)
                             (REFLEXIVITY tbl))))))
  | _ => FAIL
  end in
  THEN _HLIP _APPLY_STORE.

Definition SYMEXE_STEP Struct_env
: rtac typ (expr typ func)  :=
  THEN' (INSTANTIATE typ func)
  (Then.THEN (AT_GOAL
    (fun c s e =>
         match (get_arguments e) with
         | (Some Delta, Some Pre, Some s) =>
           match compute_forward_rule s with
           | Some ForwardSkip => APPLY_SKIP
           | Some (ForwardSeq s1 s2) => APPLY_SEQ s1 s2
           | Some ForwardSet => FORWARD_SET Delta Pre s
           | Some ForwardLoad => FORWARD_LOAD Struct_env Delta Pre s
           | Some ForwardStore => FORWARD_STORE Struct_env Delta Pre s
           | _ => FAIL
           end
         | _ => FAIL
         end)) (@RTac.Minify.MINIFY typ (expr typ func) _)).

Existing Instance func_defs.Expr_ok_fs.

Definition SYMEXE_TAC_n :=
  Then.THEN (
  THEN
   (THEN INTROS
   (THEN (EAPPLY typ func reify_semax_post')
         (TRY (AT_GOAL
                (fun c s e =>
                   match (get_arguments e) with
                   | (Some (A, B, C, D, _), _, _) =>
                     (REPEAT n (SYMEXE_STEP (compute_type_id_env (mk_tycontext A B C D (PTree.empty funspec)))))
                   | _ => FAIL
                   end)))))
   (TRY (THEN INTROS (EAPPLY typ func reify_derives_refl)))) (@RTac.Minify.MINIFY typ (expr typ func) _).

Definition rreflexivity e :=
run_tac (REFLEXIVITY tbl) e.

Definition test_lemma :=
  @lemmaD typ (expr typ func) RType_typ ExprD.Expr_expr (expr typ func)
          (fun tus tvs e => ExprDsimul.ExprDenote.exprD' tus tvs typrop e)
          _
          nil nil.

Fixpoint is_pure (e : expr typ func) :=
match e with
| App e1 e2 => is_pure e1
| (Inj (inr (Sep fprop))) => true
| _ => false
end.

Definition CANCEL e := run_tac (THEN INTROS (CANCELLATION typ func tympred is_pure)) e.

Let Expr_expr := (Expr_expr_fs tbl).
Existing Instance Expr_expr.

Definition run_tac' tac goal :=
  runOnGoals tac nil nil 0 0 (CTop nil nil)
    (ctx_empty (typ := typ) (expr := expr typ func)) goal.

Lemma run_rtac_More tac s goal e
  (Hsound : rtac_sound tac)
  (Hres : run_tac' tac (GGoal e) = More_ s goal) :
  goalD_Prop tbl nil nil goal -> exprD_Prop tbl nil nil e.
Proof.
  intros He'.
  apply runOnGoals_sound_ind with (g := GGoal e) (ctx := CTop nil nil)
  	(s0 := TopSubst (expr typ func) nil nil) in Hsound.
  unfold rtac_spec in Hsound. simpl in Hsound.
  unfold run_tac' in Hres. simpl in Hres.
  rewrite Hres in Hsound.
  assert (WellFormed_Goal nil nil (GGoal (typ := typ) e)) as H1 by constructor.

Lemma run_rtac_Solved tac s e
  (Hsound : rtac_sound tac)
  (Hres : run_tac' tac (GGoal e) = Solved s) :
  exprD_Prop tbl nil nil e.
Proof.
  unfold run_tac' in Hres.
  unfold rtac_sound in Hsound.
  assert (WellFormed_Goal nil nil (GGoal (typ := typ) e)) as H1 by constructor.

End tbled.

Definition symexe tbl e :=
run_tac (SYMEXE_TAC_n 1000 tbl) e .

Definition symexe1 tbl e  :=
run_tac (SYMEXE_TAC_n 1 tbl ) e.

Goal forall (sh : share) (v1 v2 : val), False.
intros.
reify_vst (data_at sh tint v1 v2).
Abort.

Goal forall sh v1 v2, (data_at sh tint v1 v2) |-- (data_at sh tint v1 v2).
intros. simpl reptype in *.
reify_expr_tac.
Eval vm_compute in CANCEL tbl e.
Abort.

Goal forall P Q b,  !!b && P * Q |-- !!b && Q * P .
reify_expr_tac.
Abort.

Goal forall (sh : share), sh = sh.
reify_expr_tac.
Eval vm_compute in run_tac (THEN INTROS (REFLEXIVITYTAC tbl)) e.
Abort.

Existing Instance NullExtension.Espec.

Definition replace_set2 (e : expr typ func) : expr typ func :=
match e with
| App (App (App (App (App (Inj (inr (Smx fsemax))) es)
                     Delta) pre) s) post =>
  let newpre :=
      match pre with
        |  App (App (App (Inj (inr (Smx fassertD))) P)
                    (App (App (Inj (inr (Smx flocalD)))
                              T1) T2)) R =>
           let newT1 := match T1 with
                          | App (App
                                    (Inj (inr (Data (fset tyval n))))
                                    val) T1' =>
                            get_set_reif.set_reif n val T1' tyval
                          | _ => T1
                        end in
           App (App (App (Inj (inr (Smx fassertD))) P)
                    (App (App (Inj (inr (Smx flocalD)))
                              newT1) T2)) R
        | _ => pre
      end in
  App (App (App (App (App (Inj (inr (Smx fsemax))) es)
                     Delta) newpre) s) post
| _ => e
end.

Goal forall sh ty v1 v2, mapsto sh ty v1 v2 = mapsto sh ty v1 v2.
reify_expr_tac.
Eval vm_compute in run_tac (THEN INTROS (REFLEXIVITYTAC tbl)) e.
Abort. *)

Section tbled.
Variable n : nat.
Variable tbl : SymEnv.functions RType_typ.

Let RSym_sym := RSym_sym tbl.
Existing Instance RSym_sym.

Let Expr_expr_fs := Expr_expr_fs tbl.
Existing Instance Expr_expr_fs.

Let Expr_ok_fs := Expr_ok_fs tbl.
Existing Instance Expr_ok_fs.

Let ExprVar_expr := @ExprVariables.ExprVar_expr typ func.
Existing Instance ExprVar_expr.

Existing Instance MA.

Existing Instance rtac_base.MentionsAnyOk.

Axiom set_reif_eq2 :
forall i tus tvs typ vr tr val,
exprD' tus tvs (typtree typ) tr = Some val ->
exprD' tus tvs (typtree typ) (App (App (Inj (inr (Data (fset typ i)))) vr) tr)  =
exprD' tus tvs (typtree typ) (get_set_reif.set_reif i vr tr typ).

Lemma SIMPL_DELTA_sound : rtac_sound SIMPL_DELTA.
Proof.

unfold SIMPL_DELTA.
apply SIMPLIFY_sound.
intros.
forward.
admit.
Qed.

Lemma replace_set_sound : forall tus tvs e,
exprD' tus tvs typrop e = exprD' tus tvs typrop (replace_set e).
intros.
destruct e; auto. simpl.
repeat
match goal with
| [ |- context [match ?e with _ => _ end] ] => destruct e; auto
end.
admit.
Admitted.

Lemma SIMPL_SET_sound : rtac_sound SIMPL_SET.
Proof.
apply SIMPLIFY_sound. intros.
forward. subst.
unfold propD in *. simpl. unfold exprD'_typ0 in *. simpl. simpl in H3.
rewrite <- replace_set_sound. forward. fold func in *. inv H3.
unfold RSym_sym.
rewrite H.
intros.
eapply Pure_pctxD. eauto. intros. eauto.
Qed.

Lemma FORWARD_SET_sound: forall Delta Pre s, rtac_sound (FORWARD_SET tbl Delta Pre s).
Proof.
  intros.
  unfold FORWARD_SET.
  apply THEN_sound.
  + destruct (compute_hlip_arg (Delta, Pre, s)) as [[[[[? ?] ?] ?] ?] ?].
    apply HLIP_sound.
  + destruct (compute_set_arg (Delta, Pre, s)) as [[[[[[[? ?] ?] ?] ?] ?] ?]|]; [| apply FAIL_sound].
    apply THEN_sound.
    - eapply EAPPLY_sound; auto with typeclass_instances.
      * apply APPLY_condition1.
      * apply APPLY_condition2.
      * unfold Lemma.lemmaD, split_env. simpl. intros.
        unfold ExprDsimul.ExprDenote.exprT_App.
        simpl.
        unfold exprT_App, exprT_Inj, Rcast_val, Rcast in *. simpl in *.
        unfold BILogicFunc.typ2_cast_bin in *. simpl in *.
        eapply semax_set_localD; eauto.
    - apply TRY_sound.
      apply FIRST_sound; repeat constructor.
      * apply REFLEXIVITY_OP_CTYPE_sound.
      * admit .
      * apply REFLEXIVITY_BOOL_sound.
      * apply AFTER_SET_LOAD_sound .
      * apply REFLEXIVITYTAC_sound.
Qed.

Lemma FORWARD_LOAD_sound: forall Struct_env Delta Pre s, rtac_sound (FORWARD_LOAD tbl Struct_env Delta Pre s).
Proof.
  intros.
  unfold FORWARD_LOAD.
  apply THEN_sound.
  + destruct (compute_hlip_arg (Delta, Pre, s)) as [[[[[? ?] ?] ?] ?] ?].
    apply HLIP_sound.
  + destruct (compute_load_arg (Delta, Pre, s)) as [[[[[[[[[[[[[? ?] ?] ?] ?] ?] ?] ?] ?] ?] ?] ?] ?]|]; [| apply FAIL_sound].
    apply THEN_sound.
    - apply APPLY_sound_load_lemma.
    - apply THEN_sound; apply TRY_sound; [apply FIRST_sound; repeat constructor | repeat apply THEN_sound].
      * apply REFLEXIVITY_OP_CTYPE_sound.
      * apply REFLEXIVITY_BOOL_sound.
      * apply REFLEXIVITY_CEXPR_sound.
      * apply AFTER_SET_LOAD_sound.
      * apply REFLEXIVITYTAC_sound.
      * admit .
      * admit .
      * admit .
      * admit. 
      * apply APPLY_sound_prop_right.
      * apply REFLEXIVITYTAC_sound.
Qed.

Lemma FORWARD_STORE_sound: forall Struct_env Delta Pre s, rtac_sound (FORWARD_STORE tbl Struct_env Delta Pre s).
Proof.
  intros.
  unfold FORWARD_STORE.
  apply THEN_sound.
  + destruct (compute_hlip_arg (Delta, Pre, s)) as [[[[[? ?] ?] ?] ?] ?].
    apply HLIP_sound.
  + destruct (compute_store_arg (Delta, Pre, s)) as [[[[[[[[[[[[[? ?] ?] ?] ?] ?] ?] ?] ?] ?] ?] ?] ?]|]; [| apply FAIL_sound].
    apply THEN_sound.
    - apply APPLY_sound_store_lemma.
    - apply THEN_sound; apply TRY_sound; [apply FIRST_sound; repeat constructor | repeat apply THEN_sound].
      * apply REFLEXIVITY_CTYPE_sound.
      * apply REFLEXIVITY_BOOL_sound.
      * apply REFLEXIVITY_CEXPR_sound.
      * admit .
      * apply REFLEXIVITYTAC_sound.
      * apply FIRST_sound; repeat constructor.
        apply APPLY_sound_writable_Tsh.
        apply APPLY_sound_writable_Ews.
      * admit .
      * admit .
      * admit .
      * admit. 
      * apply APPLY_sound_prop_right.
      * apply REFLEXIVITYTAC_sound.
Qed.

Lemma SYMEXE_STEP_sound: forall Struct_env, rtac_sound (SYMEXE_STEP tbl Struct_env).
Proof.
intros.
unfold SYMEXE_STEP.
apply Then.THEN_sound; [apply INSTANTIATE_sound |].
apply runOnGoals_sound.
apply Then.THEN_sound.
eapply AT_GOAL_sound.
intros.
destruct (get_arguments e);
repeat match goal with
         | |- context [ match ?X with _ => _ end ] =>
           destruct X; try apply FAIL_sound
       end.
+ apply FORWARD_SET_sound.
+ apply FORWARD_LOAD_sound.
+ apply FORWARD_STORE_sound.
+ unfold APPLY_SEQ.
  apply THEN_sound.
  unfold APPLY_SEQ'.
  apply EAPPLY_sound; auto with typeclass_instances.
  apply APPLY_condition1.
  apply APPLY_condition2.
  unfold Lemma.lemmaD. unfold split_env. simpl.
  unfold exprT_App, exprT_Inj. simpl.
  intros.
  eapply semax_seq'. eauto. eauto.
  apply SIMPL_DELTA_sound.
+ unfold APPLY_SKIP.
  apply APPLY_sound.
  apply APPLY_condition1.
  apply APPLY_condition2.
  - unfold skip_lemma.
    unfold Lemma.lemmaD, split_env. simpl. intros.
    unfold ExprDsimul.ExprDenote.exprT_App.
    simpl.
    unfold exprT_Inj. apply semax_skip.
+ admit.
Qed.

Theorem SYMEXE_sound : rtac_sound (SYMEXE_TAC_n n tbl).
Proof.
  apply Then.THEN_sound.
  + repeat apply THEN_sound.
    - admit. 
    - apply APPLY_sound_semax_post'.
    - apply TRY_sound.
      eapply AT_GOAL_sound.
      intros.
      destruct (get_arguments e) as [[[[[[[? ?] ?] ?] ?]|] ?] ?]; [| apply FAIL_sound].
      apply REPEAT_sound.
      apply SYMEXE_STEP_sound.
    - apply TRY_sound.
      apply THEN_sound.
      * admit. 
      * apply APPLY_sound_derives_refl.
  + admit .
Qed.

End tbled.

Require Import denote_tac.
(* denote_tac:
Require Import MirrorCore.Lambda.ExprDsimul.
Require Import MirrorCore.Lemma.
Require Import MirrorCharge.RTac.ReifyLemma.
Require Export MirrorCore.RTac.Repeat.
Require Import MirrorCore.RTac.Then.
Require Export MirrorCore.RTac.Try.
Require Export MirrorCore.RTac.First.
Require Import MirrorCore.RTac.Fail.
Require Import MirrorCore.RTac.Simplify.
Require Import MirrorCore.Lambda.RedAll.
Require Import MirrorCore.Lambda.ExprUnify_simul.
Require Import MirrorCore.RTac.RTac.
Require Import MirrorCharge.RTac.Instantiate.
Require Import MirrorCharge.RTac.Intro.
Require Import MirrorCharge.RTac.Apply.
Require Import MirrorCharge.RTac.EApply.
Require Export mc_reify.funcs.
Require Import mc_reify.types.
Require Import MirrorCharge.RTac.Tactics.
Import ExprDenote.
Require Import MirrorCharge.ModularFunc.ILogicFunc.
Require Import MirrorCharge.ModularFunc.BILogicFunc.
Require Import func_defs.
Require Import funcs.
Require Import types.

Ltac cbv_denote g' e :=
eval cbv [
              g'
          reflect_prop reflect Expr_expr_fs RType_typ Typ2_tyArr RSym_sym
                      RSym_Func'

          ExprI.exprD' funcAs  typeof_sym typeof_func
          typeof_func_opt
          type_cast 
          exprD'_simul func_simul
          ExprD.Expr_expr
          ExprDsimul.ExprDenote.exprD'
          
          SymSum.RSym_sum Rcast Relim Rsym eq_sym symD 
          Rcast_val eq_rect_r eq_rect Datatypes.id

          Monad.bind Monad.ret

          OptionMonad.Monad_option

          HList.hlist_hd HList.hlist_tl

          TypesI.typD
          typ2_match typ2 typ2_cast
          typ0_match typ0 typ0_cast 
          
          MirrorCore.VariablesI.Var ExprVariables.ExprVar_expr
          MirrorCore.VariablesI.UVar
          MirrorCore.Lambda.ExprVariables.ExprUVar_expr
          ExprI.exprT_Inj ExprI.exprT_UseV ExprI.exprT_UseU
          exprT_App ExprI.exprT OpenT
          nth_error_get_hlist_nth

          exprT_GetVAs exprT_GetUAs

          ILogicFunc.mkEntails ILogicFunc.mkTrue ILogicFunc.mkFalse
          ILogicFunc.mkAnd ILogicFunc.mkOr ILogicFunc.mkImpl
          ILogicFunc.mkExists ILogicFunc.mkForall

          ILogicFunc.fEntails ILogicFunc.fTrue ILogicFunc.fFalse ILogicFunc.fAnd
          ILogicFunc.fOr ILogicFunc.fImpl ILogicFunc.fExists ILogicFunc.fForall
          ILogicFuncSumL ILogicFuncSumR ILogicFuncExpr
          ILogicFunc.RSym_ilfunc
          MirrorCharge.ModularFunc.ILogicFunc.ILogicFuncInst

          ILogicFunc.funcD ILogicFunc.typ2_cast_quant ILogicFunc.typ2_cast_bin

          BILogicFunc.mkEmp BILogicFunc.mkStar BILogicFunc.mkWand

          BILogicFunc.fEmp BILogicFunc.fStar BILogicFunc.fWand

          BILogicFuncSumL BILogicFuncSumR BILogicFuncExpr
          BILogicFunc.RSym_bilfunc BILogicFunc.BILogicFuncInst

          BILogicFunc.funcD BILogicFunc.typ2_cast_bin

          BILogicFunc.typeof_bilfunc

          LaterFunc.mkLater

          LaterFunc.fLater

          LaterFunc.LaterFuncSumL LaterFunc.LaterFuncSumR LaterFunc.LaterFuncExpr
          LaterFunc.RSym_later_func LaterFunc.LaterFuncInst

          LaterFunc.funcD LaterFunc.typ2_cast'

          LaterFunc.typeof_later_func

          EmbedFunc.mkEmbed

          EmbedFunc.fEmbed

          EmbedFunc.EmbedFuncSumL EmbedFunc.EmbedFuncSumR EmbedFunc.EmbedFuncExpr
          EmbedFunc.RSym_embed_func EmbedFunc.EmbedFuncInst

          EmbedFunc.funcD EmbedFunc.typ2_cast_bin

          EmbedFunc.typeof_embed_func

          BaseFunc.BaseFuncSumL BaseFunc.BaseFuncSumR BaseFunc.BaseFuncExpr

          BaseFunc.BaseFuncInst
          BaseFunc.mkNat BaseFunc.mkString BaseFunc.mkBool
          BaseFunc.mkEq BaseFunc.mkPair

          BaseFunc.fNat BaseFunc.fString BaseFunc.fBool
          BaseFunc.fEq BaseFunc.fPair

          BaseFunc.RSym_BaseFunc

          BaseFunc.typeof_base_func BaseFunc.base_func_eq BaseFunc.base_func_symD
          BaseFunc.RelDec_base_func

          ListFunc.ListFuncSumL ListFunc.ListFuncSumR ListFunc.ListFuncExpr

          ListFunc.ListFuncInst
          ListFunc.mkNil ListFunc.mkCons ListFunc.mkLength
          ListFunc.mkZip ListFunc.mkMap ListFunc.mkFold

          ListFunc.fNil ListFunc.fCons ListFunc.fLength
          ListFunc.fZip ListFunc.fMap ListFunc.fFold

          ListFunc.typeof_list_func ListFunc.list_func_eq ListFunc.list_func_symD
          ListFunc.RelDec_list_func

		  OpenFunc.mkConst OpenFunc.mkAp OpenFunc.mkVar OpenFunc.mkNull OpenFunc.mkStackGet
		  OpenFunc.mkStackSet OpenFunc.mkApplySubst OpenFunc.mkSingleSubst OpenFunc.mkSubst
		  OpenFunc.mkTruncSubst
		
		  OpenFunc.fConst OpenFunc.fAp OpenFunc.fVar OpenFunc.fNull OpenFunc.fStackGet
		  OpenFunc.fApplySubst OpenFunc.fSingleSubst OpenFunc.fSubst OpenFunc.fTruncSubst
		
		  OpenFunc.OpenFuncSumL OpenFunc.OpenFuncSumR OpenFunc.OpenFuncExpr
		  OpenFunc.OpenFuncInst
		
		  OpenFunc.typeof_open_func OpenFunc.RSym_OpenFunc
		  OpenFunc.typ2_cast_bin OpenFunc.typ3_cast_bin
		  OpenFunc.RelDec_open_func
		
		  OpenFunc.RSym_OpenFunc_obligation_1

          BaseType.tyPair BaseType.tyNat BaseType.tyString BaseType.tyBool
          BaseType.btPair BaseType.btNat BaseType.btBool BaseType.btString

          ListType.tyList ListType.btList

          SubstType.tyVar SubstType.tyVal SubstType.tySubst
          SubstType.stSubst

constD
z_opD
int_opD
valueD
evalD
otherD
sepD
dataD
typD
funcs.funcD
smxD

typeof_func
typeof_const
typeof_z_op
typeof_int_op
typeof_value
typeof_eval
typeof_other
typeof_sep
typeof_data
typeof_smx

          goalD propD exprD'_typ0 exprD split_env

          amap_substD
          substD
          FMapSubst.SUBST.raw_substD
          UVarMap.MAP.fold
          FMapPositive.PositiveMap.fold
          FMapPositive.PositiveMap.xfoldi
          FMapPositive.append
          UVarMap.MAP.from_key
          pred
          plus
          Pos.to_nat
          Pos.iter_op
          app
          HList.hlist_app
          Quant._foralls
          Quant._exists
          goalD_Prop

typ_eq_dec typ_rec typ_rect sumbool_rec sumbool_rect eq_rec eq_rect eq_rec_r eq_rect_r False_ind eq_ind expr.eqb_type expr.eqb_intsize expr.eqb_signedness expr.eqb_attr
expr.eqb_option expr.eqb_floatsize Bool.eqb BinNat.N.eqb expr.eqb_calling_convention expr.eqb_ident
f_equal False_rect False_rec

SymEnv.funcD
SymEnv.fdenote
SymEnv.RSym_func
SymEnv.func_typeof_sym
SymEnv.ftype
FMapPositive.PositiveMap.find
elem_ctor
Tactics.elem_ctor

Ext
func_defs.reflect

exprD_Prop
Tactics.exprD_Prop

goalD_Prop
Tactics.exprD_Prop

goalD_aux
Tactics.goalD_aux
Typ0_tyProp

func_defs.RSym_ilfunc
func_defs.ilops
ILogic.lforall
ILogic.ILogicOps_Prop
ILogic.lentails
ILogicOps_mpred

ILogic.land

reptyp_reptype
reptype_reptyp
typD_reptyp_reptype
data_at_lemmas.type_mut
proj1T
proj2T
data_at_lemmas.is_Fnil
ModularFunc.ILogicFunc.typeof_func
reptyp
reptyp_structlist
reptyp_unionlist

 exportclight.Clightdefs.tvoid
 exportclight.Clightdefs.tschar
 exportclight.Clightdefs.tuchar
 exportclight.Clightdefs.tshort
 exportclight.Clightdefs.tushort
 exportclight.Clightdefs.tint
 exportclight.Clightdefs.tuint
 exportclight.Clightdefs.tbool
 exportclight.Clightdefs.tlong
 exportclight.Clightdefs.tulong
 exportclight.Clightdefs.tfloat
 exportclight.Clightdefs.tdouble
 exportclight.Clightdefs.tptr
 exportclight.Clightdefs.tarray

eq_ind_r
eq_ind
          ] in e.

Ltac cbv_denote_goal :=
match goal with
[ |- ?G] => let x := cbv_denote hd G in change x
end.

Require Import VST.floyd.proofauto. *)
Require Import Timing.

Ltac clear_tbl :=
match goal with
[ t := ?V : FMapPositive.PositiveMap.tree (SymEnv.function RType_typ) |- _ ] => clear t
end.

Require Import Timing.
Ltac run_rtac reify term_table tac_sound reduce :=
start_timer "total";
start_timer "02 match_tactic";
  lazymatch type of tac_sound with
    | forall t, @rtac_sound _ _ _ _ _ _ (?tac _) =>
	  let namee := fresh "e" in
	  match goal with
	    | |- ?P =>
              stop_timer "02 match_tactic";
              start_timer "03 reification";
	      reify_aux reify term_table P namee;
              stop_timer "03 reification";
              start_timer "04 match type";
              let tbl := get_tbl in
	      let t :=  constr:(Some typrop) in
	      let goal := namee in
	      match t with
	        | Some ?t =>
	          let goal_result := constr:(run_tac' (tac tbl) (GGoal namee)) in
                  stop_timer"04 match type";
                  start_timer "05 vm_compute";
	          let result := eval vm_compute in goal_result in
                  stop_timer "05 vm_compute";
                  start_timer "06 match result";
	          match result with
	            | More_ ?s ?g =>
                      set (g' := g);
                      set (sv := s);
                      stop_timer "06 match result";
                      start_timer "07 goalD";
                      let gd_prop :=
                          constr:(goalD_Prop tbl nil nil g') in
                      stop_timer "07 goalD";
                      start_timer "08 reduce";
                      let gd' :=
                        reduce g' gd_prop in
                      stop_timer "08 reduce";
                      start_timer "09 cut1";
	              cut (gd');  [ stop_timer "09 cut1";
                                    start_timer "10 change";
                          change (gd_prop ->
                                  exprD_Prop tbl nil nil namee);

                          stop_timer "10 change";
                          start_timer "11 cut2";
	                  cut (goal_result = More_ sv g');
                          [ stop_timer "11 cut2";
                            start_timer "12 exact";
                            
                             exact_no_check
                               (@run_rtac_More tbl (tac tbl)
                                 sv g' namee (tac_sound tbl))
                                                      | stop_timer "12 exact";
                             start_timer "13 VM_CAST";
                             vm_cast_no_check
                               (@eq_refl _ (More_ sv g'))
                             ]
	                | stop_timer "13 VM_CAST"; clear  sv ]
	            | Solved ?s =>
	              exact_no_check (@run_rtac_Solved tbl (tac tbl) s namee (tac_sound tbl)
	                (@eq_refl (Result (CTop nil nil)) (Solved s) <: run_tac' (tac tbl) (GGoal goal) = Solved s))
	            | Fail => idtac "Tactic" tac "failed."
	            | _ => idtac "Error: run_rtac could not resolve the result from the tactic :" tac
	          end
	        | None => idtac "expression " goal "is ill typed" t
	      end
	  end; try (clear namee; clear_tbl)
	| _ => idtac tac_sound "is not a soudness theorem."
  end; stop_timer "total".

Ltac rforward := run_rtac reify_vst term_table (SYMEXE_sound 1000) cbv_denote.

Ltac rforward_admit := run_rtac reify_vst term_table (SYMEXE_sound 1000) admit.

Local Open Scope logic.

Require Import reverse_defs.
(* reverse_defs:
Definition sum_int := fold_right Int.add Int.zero.
Check var_types.
Definition Delta : tycontext :=
mk_tycontext
             (PTree.Node
                (PTree.Node PTree.Leaf None
                   (PTree.Node
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some (tptr t_struct_list, false)) PTree.Leaf)
                            None PTree.Leaf)) None PTree.Leaf)) None
                (PTree.Node
                   (PTree.Node PTree.Leaf None
                      (PTree.Node
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some (tptr t_struct_list, true)) PTree.Leaf)
                            None PTree.Leaf) None PTree.Leaf)) None
                   (PTree.Node
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some (tptr t_struct_list, true)) PTree.Leaf)
                            None PTree.Leaf)) None
                      (PTree.Node
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some (tptr t_struct_list, false)) PTree.Leaf)
                            None PTree.Leaf) None PTree.Leaf))))
             (PTree.empty type) (tptr t_struct_list)
             (PTree.Node
                (PTree.Node
                   (PTree.Node PTree.Leaf None
                      (PTree.Node
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some (Tarray t_struct_list 3 noattr))
                               PTree.Leaf) None PTree.Leaf) None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some
                                  (Tfunction
                                     (Tcons (tptr t_struct_list) Tnil)
                                     (tptr t_struct_list) cc_default))
                               PTree.Leaf) None PTree.Leaf))) None
                   (PTree.Node PTree.Leaf None
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some (Tfunction Tnil tint cc_default))
                               PTree.Leaf) None PTree.Leaf)))) None
                (PTree.Node
                   (PTree.Node
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some
                                  (Tfunction
                                     (Tcons (tptr t_struct_list) Tnil) tint
                                     cc_default)) PTree.Leaf) None PTree.Leaf))
                      None PTree.Leaf) None PTree.Leaf))
             (PTree.Node
                (PTree.Node
                   (PTree.Node PTree.Leaf None
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some
                                  (WITH x : share * list val * val PRE
                                   [(_p, tptr t_struct_list)]
                                   (let (p0, p1) := x in
                                    let (sh0, contents0) := p0 in
                                    PROP  (writable_share sh0)
                                    LOCAL  (temp _p p1)
                                    SEP
                                    (`(lseg LS sh0 contents0 p1 nullval)))
                                   POST  [tptr t_struct_list]
                                   (let (p0, _) := x in
                                    let (sh0, contents0) := p0 in
                                    `(lseg LS sh0 (rev contents0)) retval
                                      `nullval))) PTree.Leaf) None PTree.Leaf)))
                   None
                   (PTree.Node PTree.Leaf None
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some
                                  (WITH u : unit PRE  []
                                   main_pre prog u POST  [tint]
                                   main_post prog u)) PTree.Leaf) None
                            PTree.Leaf)))) None
                (PTree.Node
                   (PTree.Node
                      (PTree.Node PTree.Leaf None
                         (PTree.Node
                            (PTree.Node PTree.Leaf
                               (Some
                                  (WITH x : share * list int * val PRE
                                   [(_p, tptr t_struct_list)]
                                   (let (p0, p1) := x in
                                    let (sh0, contents0) := p0 in
                                    PROP  ()
                                    LOCAL  (temp _p p1)
                                    SEP
                                    (`(lseg LS sh0
                                         (map Vint contents0) p1 nullval)))
                                   POST  [tint]
                                   (let (p0, _) := x in
                                    let (_, contents0) := p0 in
                                    local
                                      (`(eq (Vint (sum_int contents0)))
                                         retval)))) PTree.Leaf) None
                            PTree.Leaf)) None PTree.Leaf) None PTree.Leaf)).

Definition Struct_env := (@PTree.Node type (@PTree.Leaf type)
                     (@None type)
                     (@PTree.Node type
                        (@PTree.Node type
                           (@PTree.Node type
                              (@PTree.Node type
                                 (@PTree.Node type
                                    (@PTree.Leaf type)
                                    (@Some type
                                       (Tstruct _struct_list
                                          (Fcons _head tint
                                             (Fcons _tail
                                                (Tcomp_ptr _struct_list
                                                  noattr) Fnil)) noattr))
                                    (@PTree.Leaf type))
                                 (@None type) (@PTree.Leaf type))
                              (@None type) (@PTree.Leaf type))
                           (@None type) (@PTree.Leaf type))
                        (@None type) (@PTree.Leaf type))). *)
Existing Instance NullExtension.Espec.

Fixpoint lots_of_sets' n p :=
match n with
| O => (Sset p (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid)))
| S n' => Ssequence (Sset p (Ecast (Econst_int (Int.repr 0) tint) (tptr tvoid))) (lots_of_sets' n' (Psucc p))
end.

Definition lots_of_sets n := lots_of_sets' (pred n) 1%positive.

Fixpoint lots_temps' n p :=
match n with
| O => (PTree.empty _)
| S n' =>  PTree.set p (tptr t_struct_list, true) (lots_temps' n' (Psucc p))
end.

Definition lots_temps (n : nat) : PTree.t (type * bool) := lots_temps' (n) (1%positive).

Fixpoint lots_locals' n p :=
match n with
| O => (PTree.empty _)
| S n' =>  PTree.set p (Vint (Int.repr 0%Z)) (lots_locals' n' (Psucc p))
end.

Definition lots_locals (n : nat):= lots_locals' (n) (1%positive).

Fixpoint lots_vars' n p :=
match n with
| O => (PTree.empty _)
| S n' =>  PTree.set p (tptr t_struct_list, Vint (Int.repr 0%Z)) (lots_vars' n' (Psucc p))
end.

Definition lots_vars (n : nat):= lots_vars' (n) (1%positive).

Fixpoint lots_data_at n sh v :=
match n with
| O => nil
| S n' => data_at sh t_struct_list (Vundef, Vint Int.zero) (force_ptr v) ::
                  lots_data_at n' sh v
end.

Definition test_semax sets temps_tycon temps_local vars_local seps :=
forall post v sh,  (semax
     (mk_tycontext (lots_temps temps_tycon) (PTree.empty type) Tvoid
                   (PTree.empty type) (PTree.empty funspec))
     (assertD [] (localD (lots_locals temps_local) (lots_vars vars_local))
       (lots_data_at seps sh v))
      (lots_of_sets sets)
     (normal_ret_assert  post)).

Definition sets := 1%nat.
Definition temps_tycon := sets.
Definition temps_local := 10%nat.
Definition vars_local := temps_local.
Definition seps := vars_local.

Clear Timing Profile.
Ltac forward := start_timer "LTac"; repeat forward.forward; stop_timer "LTac".

Goal test_semax sets temps_tycon temps_local vars_local seps.
cbv [ sets temps_tycon temps_local vars_local seps
      test_semax lots_temps lots_temps' PTree.empty
      lots_of_sets lots_of_sets' lots_data_at Pos.succ PTree.set
      lots_locals lots_locals' lots_vars lots_vars' pred].
intros.
rforward.
admit.
Time Qed. 

Print Timing Profile.

