
Require Import msl.msl_standard.
(* msl.msl_standard:
Require Export VST.msl.Extensionality.
Require Export VST.msl.ageable.
Require Export VST.msl.age_sepalg.
Require Export VST.msl.base.
Require Export VST.msl.boolean_alg.
Require Export VST.msl.knot_full_variant.
Require Export VST.msl.knot_shims.
Require Export VST.msl.knot_full_sa.
Require Export VST.msl.knot_shims.
Require Export VST.msl.predicates_hered.
Require Export VST.msl.predicates_sl.
Require Export VST.msl.corable.
Require Export VST.msl.subtypes.
Require Export VST.msl.subtypes_sl.
Require Export VST.msl.predicates_rec.
Require Export VST.msl.contractive.
Require Export VST.msl.sepalg.
Require Export VST.msl.functors.
Require Export VST.msl.sepalg_functors.
Require Export VST.msl.sepalg_generators.
Require Export VST.msl.combiner_sa.
Require Export VST.msl.shares.
Require Export VST.msl.cross_split.
Require Export VST.msl.psepalg.
Require Export VST.msl.pshares.
Require Export VST.msl.eq_dec.

Export MixVariantFunctor.
Export MixVariantFunctorLemmas.
Export MixVariantFunctorGenerator. *)

Require Import lam_ref_tcb.
(* lam_ref_tcb:
Require Export EqNat.

Require Import msl.Extensionality.

Definition var_t : Type := nat.

Definition addr : Type := nat.

Inductive expr : Type :=
 | Nat : forall n : nat, expr
 | Prim : forall (f:nat -> expr) (e:expr), expr
 | Var : forall n : var_t, expr
 | Loc : forall l : addr, expr
 | Lam : forall e : expr, expr 
 | App : forall e1 e2 : expr, expr
 | New : forall e : expr, expr
 | Deref : forall e : expr, expr
 | Update : forall e1 e2 e3 : expr, expr. 

Fixpoint closed' (n : nat) (e : expr) : Prop :=
  match e with
   | Var n' => n' < n
   | Prim f e => closed' n e
   | Lam e => closed' (n + 1) e
   | Nat _ => True
   | Loc _ => True
   | App e1 e2 => closed' n e1 /\ closed' n e2
   | New e => closed' n e
   | Deref e => closed' n e
   | Update e1 e2 e3 => closed' n e1 /\ closed' n e2 /\ closed' n e3
  end.

Definition closed (e : expr) : Prop :=
  closed' 0 e.

Definition openValue (e:expr) : Prop :=
  match e with
   | Nat _ => True
   | Loc _ => True
   | Lam _ => True
   | _ => False
  end.

Definition isValue (e : expr) : Prop :=
  closed e /\ openValue e.

Definition value : Type :=
  {v : expr | isValue v}.

Definition val_to_exp : value -> expr :=
  @projT1 expr isValue.
Definition exp_to_val (e : expr) (H : isValue e) : value :=
  existT isValue e H.

Definition mem : Type :=
  (nat * (addr -> value))%type.

Definition new (m : mem) (v : value) : (mem * addr) :=
  match m with (n, m') =>
    ((S n, fun a => if beq_nat a n then v else m' a), n)
  end.

Definition deref (m : mem) (a : addr) : value :=
  (snd m) a.

Definition update (m : mem) (a : addr) (v : value) : mem :=
  match m with (n, m') =>
    (n, fun a' => if beq_nat a a' then v else m' a')
  end.

Definition state : Type :=
  (mem * expr)%type.

Fixpoint subst (var : var_t) (v : value) (e : expr) : expr :=
  match e with
   | Nat n => Nat n
   | Prim f e => Prim f (subst var v e)
   | Loc l => Loc l
   | Var var' => if (beq_nat var var') then val_to_exp v else Var var'
   | Lam e => Lam (subst (var + 1) v e)
   | App e1 e2 => App (subst var v e1) (subst var v e2)
   | New e => New (subst var v e)
   | Deref e => Deref (subst var v e)
   | Update e1 e2 e3 => Update (subst var v e1) (subst var v e2) (subst var v e3)
  end.

Inductive step : state -> state -> Prop :=

 | st_App1 : forall m e1 e2 m' e1',
     step (m, e1) (m', e1') ->
     step (m, App e1 e2) (m', App e1' e2)
 | st_App2 : forall m e1 e2 m' e2',
     step (m, e2) (m', e2') ->
     step (m, App (Lam e1) e2) (m', App (Lam e1) e2')
 | st_App3 : forall m e1 e2,
     forall (H : isValue e2),
     step (m, App (Lam e1) e2) (m, subst 0 (exp_to_val e2 H) e1)

 | st_New1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, New e) (m', New e')
 | st_New2 : forall m e m' l,
     forall (H : isValue e),
     new m (exp_to_val e H) = (m', l) ->
     step (m, New e) (m', Loc l)

 | st_Deref1 : forall m e m' e',
     step (m, e) (m', e') ->
     step (m, Deref e) (m', Deref e')
 | st_Deref2 : forall m l v,
     deref m l = v ->
     step (m, Deref (Loc l)) (m, val_to_exp v)

 | st_Upd1 : forall m e1 e2 e3 m' e1',
     step (m, e1) (m', e1') ->
     step (m, Update e1 e2 e3) (m', Update e1' e2 e3)
 | st_Upd2 : forall m l e2 e3 m' e2',
     step (m, e2) (m', e2') ->
     step (m, Update (Loc l) e2 e3) (m', Update (Loc l) e2' e3)
 | st_Upd3 : forall m l e2 e3 m',
     forall (H : isValue e2),
     update m l (exp_to_val e2 H) = m' ->
     step (m, Update (Loc l) e2 e3) (m', e3)

 | st_Prim1 : forall m m' e e' f,
     step (m, e) (m', e') ->
     step (m, Prim f e) (m', Prim f e')
 | st_Prim2 : forall m n f,
     isValue (f n) ->
     step (m, Prim f (Nat n)) (m, f n).

Inductive stepstar : state -> state -> Prop :=
  | step_refl : forall st, stepstar st st
  | step_trans: forall st1 st2 st3,
       stepstar st1 st2 ->
       stepstar st2 st3 ->
       stepstar st1 st3
  | step1 : forall st st',
       step st st' ->
       stepstar st st'.

Definition can_step (st : state) : Prop :=
  exists st', step st st'.

Definition at_value (st : state) : Prop :=
  isValue (snd st).

Definition safe (st : state) : Prop :=
  forall st',
    stepstar st st' ->
    can_step st' \/ at_value st'.

Definition safe_prog (e:expr) : Prop :=
  forall m, safe (m, e). *)
Require Import lam_ref_eval.
(* lam_ref_eval:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.

Require Import msl.msl_standard.

Section eval.
  Variable eval : mem -> expr -> (mem * expr).

  Definition eval' (m:mem) (e0:expr) : mem * expr :=
  match e0 with
  | App e1 e2 =>
      match eval m e1 with
      | (m', Lam e1') =>
          let (m'',e2') := eval m' e2 in
            match value_dec e2' with
            | left H => eval m'' (subst 0 (exp_to_val e2' H) e1')
            | _ => (m'',App (Lam e1') e2')
            end
      | (m',e1') => (m',App e1' e2)
      end
  | Prim f e1 =>
      match eval m e1 with
      | (m', Nat x) =>
        match value_dec (f x) with
        | left H => (m',f x)
        | _ => (m',Prim f (Nat x))
        end
      | (m',e1') => (m',Prim f e1')
      end
  | New e1 =>
      let (m',e') := eval m e1 in
      match value_dec e' with
      | left H =>
           let (m'',l) := new m' (exp_to_val e' H) in (m'',Loc l)
      | _ => (m',New e')
      end
  | Deref e1 =>
      match eval m e1 with
      | (m',Loc l) => eval m' (val_to_exp (deref m' l))
      | (m',e1') => (m',Deref e1')
      end
  | Update e1 e2 e3 =>
      match eval m e1 with
      | (m',Loc l) =>
          let (m'',e2') := eval m' e2 in
          match value_dec e2' with
          | left H =>
              eval (update m'' l (exp_to_val e2' H)) e3
          | _ => (m'',Update (Loc l) e2' e3)
          end
      | (m',x) => (m',Update x e2 e3)
      end
  | x => (m,x)
  end.

  Hypothesis Heval :
    forall m e m' e',
      eval m e = (m',e') ->
      stepstar (m,e) (m',e').

  Lemma eval'_correct :
    forall m e m' e',
      eval' m e = (m',e') ->
      stepstar (m,e) (m',e').
End eval.

Definition eval (x:Z) := Zmisc.iter x _ eval' (fun m e => (m,e)).

Lemma eval_correct : forall x m e m' e',
  eval x m e = (m',e') ->
  stepstar (m,e) (m',e'). *)
Require Import lam_ref_mach_defs.
(* lam_ref_mach_defs:
Require Import lam_ref_tcb.
Require Import msl.msl_standard.

Tactic Notation "omegac" :=
  (elimtype False; omega).

Lemma IF_then_else_True:
  forall a b c : Prop, a -> (IF a then b else c) = b.
Lemma IF_then_else_False:
  forall a b c : Prop, ~a -> (IF a then b else c) = c.

Ltac IF_tac :=
match goal with |- context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H := fresh "H" in intro H; destruct H;
     [try (rewrite IF_then_else_True;[|auto]) | try (rewrite IF_then_else_False; [|auto])]
   | ]
end.

Ltac IF_tac_in H :=
match type of H with context [IF ?a then _ else _] =>
   cut (a \/ ~a);
   [ let H' := fresh "H" in intro H'; destruct H';
     [try (rewrite IF_then_else_True in H ;[|auto]) | try (rewrite IF_then_else_False in H; [|auto])]
   | ]
end.

Lemma isvNat: forall n,
  isValue (Nat n).

Lemma isvLoc: forall l,
  isValue (Loc l).

Lemma isvLam: forall e,
  closed' 1 e ->
  isValue (Lam e).

Definition v_Nat (n : nat) : value :=
  exp_to_val (Nat n) (isvNat n).

Definition v_Loc (l : addr) : value :=
  exp_to_val (Loc l) (isvLoc l).

Definition v_Lam (e : expr) (H: closed' 1 e) : value :=
  exp_to_val (Lam e) (isvLam e H).

Definition stopped (m : mem) (e : expr) : Prop :=
  ~ exists m', exists e', step (m, e) (m', e').

Definition env : Type := list value.

Fixpoint subst_env' (n : nat) (rho : env) (exp : expr) : expr :=
  match rho with
   | nil => exp
   | v :: vx => subst n v (subst_env' (n + 1) vx exp)
  end.

Definition subst_env (rho : env) (exp : expr) : expr :=
  subst_env' 0 rho exp.

Definition empty_mem : mem := (0, fun _ => v_Nat 0).

Inductive stepn : nat -> state -> state -> Prop :=
 | step0 : forall st,
   stepn 0 st st
 | stepS : forall n st st' st'',
   step st st' ->
   stepn n st' st'' ->
   stepn (S n) st st''.

Definition safen (n : nat) (st : state) : Prop :=
  forall n', n' < n ->
    forall st',
      stepn n' st st' ->
        can_step st' \/ at_value st'. *)
Require Import lam_ref_mach_lemmas.
(* lam_ref_mach_lemmas:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Lemma isVal_val2exp : forall v, isValue (val_to_exp v).

Lemma closed_dec : forall e n,
  { closed' n e} + { ~closed' n e}.

Lemma value_dec : forall e,
  { isValue e } + { ~isValue e }.

Ltac show_stopped :=
  let m' := fresh "m'" in
  let e' := fresh "e'" in
  let H := fresh "H" in
  right; intros [m' [e' H]]; inv H.

Lemma stopped_dec : forall e m,
  { st | step (m,e) st} + { stopped m e }.

Lemma closed'_S : forall n e,
  closed' n e ->
  closed' (S n) e.

Lemma closed'_le : forall m n,
  m <= n ->
  forall e,
  closed' m e ->
  closed' n e.

Lemma closed'_subst: forall m e x v,
  closed' m e ->
  subst (x + m) v e = e.

Lemma closed_closed_subst: forall x v e,
  closed e ->
  closed (subst x v e).

Lemma closed_Lam_subst: forall e x v,
  closed (Lam e) ->
  subst x v (Lam e) = Lam e.

Lemma subst_env'_Nat: forall rho m n,
  subst_env' m rho (Nat n) = Nat n.

Lemma subst_env'_Loc: forall rho m l,
  subst_env' m rho (Loc l) = Loc l.

Lemma subst_env'_Var': forall n m rho,
  subst_env' (S (n + m)) rho (Var n) = Var n.

Lemma subst_env'_Var: forall rho n v m,
  nth_error rho n = Some v ->
  subst_env' m rho (Var (n + m)) = val_to_exp v.

Lemma subst_env'_New: forall rho m e,
  subst_env' m rho (New e) = New (subst_env' m rho e).

Lemma subst_env'_Deref: forall rho m e,
  subst_env' m rho (Deref e) = Deref (subst_env' m rho e).

Lemma subst_env'_Update: forall rho m e1 e2 e3,
  subst_env' m rho (Update e1 e2 e3) =
  Update (subst_env' m rho e1) (subst_env' m rho e2) (subst_env' m rho e3).

Lemma subst_env_New: forall rho e,
  subst_env rho (New e) = New (subst_env rho e).

Lemma subst_env_Deref: forall rho e,
  subst_env rho (Deref e) = Deref (subst_env rho e).

Lemma subst_env_Update: forall rho e1 e2 e3,
  subst_env rho (Update e1 e2 e3) =
  Update (subst_env rho e1) (subst_env rho e2) (subst_env rho e3).

Lemma subst_env_App : forall env e1 e2,
  subst_env env (App e1 e2) = App (subst_env env e1) (subst_env env e2).

Lemma subst_env_Prim : forall env f e,
  subst_env env (Prim f e) = Prim f (subst_env env e).

Lemma subst_subst_neq : forall e n m v1 v2,
  n <> m ->
  subst n v1 (subst m v2 e) =
  subst m v2 (subst n v1 e).

Lemma subst_env_split : forall env1 env2 n e,
  subst_env' n (env1 ++ env2) e =
  subst_env' n env1 (subst_env' (length env1 + n) env2 e).

Lemma subst_subst_env_lt : forall env n m v e,
  n < m ->
  subst n v (subst_env' m env e) =
  subst_env' m env (subst n v e).

Lemma subst_closed' :
  forall e n v,
    closed' (S n) e ->
    closed' n (subst n v e).

Lemma closed_subst_env : forall env e x n,
   closed' (length env + x) e ->
   closed' (x + n) (subst_env' (x + n) env e).

Lemma closed_step : forall x y ,
  step x y ->
  closed (snd x) ->
  closed (snd y).

Lemma values_stopped: forall e,
  isValue e ->
  forall m,
  stopped m e.

Lemma stopped_New: forall m e,
  stopped m (New e) ->
  stopped m e.

Lemma stopped_Deref: forall m e,
  stopped m (Deref e) ->
  stopped m e.

Lemma stopped_Update: forall m e1 e2 e3,
  stopped m (Update e1 e2 e3) ->
  stopped m e1 \/ (isValue e1 /\ stopped m e2).

Lemma step_deterministic: forall m e m1 e1 m2 e2,
  step (m,e) (m1,e1) ->
  step (m,e) (m2,e2) ->
  m1 = m2 /\ e1 = e2.

Lemma stepn_value: forall j m v st,
  isValue v ->
  stepn j (m, v) st ->
  st = (m, v).

Lemma stepstar_search : forall f m e m' e',
  (forall m e m' e',
    step (m,e) (m',e') -> step (m,f e) (m',f e')) ->
  stepstar (m,e) (m',e') ->
  stepstar (m,f e) (m', f e').

Lemma stepn_trans : forall n m st1 st2 st3,
  stepn n st1 st2 ->
  stepn m st2 st3 ->
  stepn (n+m) st1 st3.

Lemma stepstar_stepn : forall st st',
  stepstar st st' <-> exists n, stepn n st st'. *)
Require Import lam_ref_type_defs.
(* lam_ref_type_defs:
Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import msl.msl_standard.

Require Export lam_ref_type_prelim.

Open Scope pred.

Definition forces (psi : mtype) (v : value) (tau : pred world) :=
  tau (psi, v).

Program Definition ty_nat : pred world :=
  fun w => match w with (k, v) =>
    exists n, v = v_Nat n
  end.

Lemma ty_nat_extends :
  boxy extendM ty_nat.

Program Definition type_at (l:addr) (tau:pred world) : pred world :=
  fun w:world =>
    let (n,psi) := unsquash (fst w) in
      match psi l with
        | None => False
        | Some p => approx_eq n p tau
      end.

Lemma type_at_extends : forall l tau,
  %(type_at l tau) = type_at l tau.

Program Definition just (v:value) : pred world :=
  fun w => snd w = v.

Program Definition with_val (v:value) (p:pred world) : pred world :=
  fun w => p (fst w,v).

Definition ty_ref (tau: pred world) : pred world :=
  EX a:addr, just (v_Loc a) && type_at a tau.

Program Definition mtype_valid (m : mem) : pred world :=
  fun w =>
  match w with (k, v) =>
   let (n,phi) := unsquash k in
    forall (a : addr),
      match phi a with
      | None => fst m <= a
      | Some tau => fst m > a /\ forces k (deref m a) (%|>tau)
      end
  end.

Definition expr_typeF (tau:pred world) (F: expr -> pred world) (e : expr) : pred world :=
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && F e'))) &&
    (!!(stopped m e) --> EX H:isValue e,
         with_val (exp_to_val e H) (%tau)).

Lemma sub_with_val : forall G P P' e,
  G |-- P >=> P' ->
  G |-- with_val e P >=> with_val e P'.

Lemma extend_level : forall w1 w2,
  R_extends w1 w2 -> level w1 = level w2.

Lemma sub_extend :
  forall G P Q,
    G |-- P >=> Q  ->
    G |-- %P >=> %Q.

Lemma sub_contract :
  forall G P Q,
    G |-- P >=> Q ->
    G |-- predicates_hered.diamond contractsM P >=>

Lemma expr_type_sub1 :
  forall tau P Q,
    ALL e:expr, |>(P e >=> Q e)
      |-- ALL e:expr, expr_typeF tau P e >=> expr_typeF tau Q e.

Lemma expr_type_cont : forall tau, HOcontractive (expr_typeF tau).

Definition expr_type e tau := HORec (expr_typeF tau) e.

Lemma expr_type_eqn : forall tau e,
  expr_type e tau =
  %ALL m:mem, mtype_valid m -->
    (ALL m':mem, ALL e':expr, !!(step (m,e) (m',e')) -->
      |>(predicates_hered.diamond contractsM (mtype_valid m' && expr_type e' tau)))

Definition ty_lam (tau1 tau2 : pred world) : pred world :=
  EX e:expr, EX H:closed' 1 e, just (v_Lam e H) &&
  |>%(ALL v':value, with_val v' (%tau1) --> expr_type (subst 0 v' e) tau2).

Definition etype : Type := list (pred world).

Fixpoint etype_valid (e : env) (G : etype) : pred world :=
  match (e,G) with
   | (v :: es, tau :: Gs) => with_val v (%tau) && etype_valid es Gs
   | (nil, nil) => TT
   | _ => FF
  end.

Definition Typ (G : etype) (exp : expr) (tau : pred world) : Prop :=
  closed' (length G) exp  /\
  forall env, etype_valid env G |-- expr_type (subst_env env exp) tau.

Lemma expr_type_sub2 :
  forall X e P Q,
    P >=> Q |-- expr_typeF P X e >=> expr_typeF Q X e.

Lemma subp_expr_type : forall G P P',
  G |-- P >=> P' ->
  G |-- ALL e:expr, expr_type e P >=> expr_type e P'.

Lemma ty_lam_sub : forall G P P' Q Q',
  G |-- |>(P' >=> P) ->
  G |-- |>(Q >=> Q') ->
  G |-- (ty_lam P Q) >=> (ty_lam P' Q').

Lemma subp_type_at : forall G P Q l,
  G |-- |>(P <=> Q) ->
  G |-- type_at l P >=> type_at l Q.

Lemma ty_ref_sub : forall G P Q,
  G |-- |>(P <=> Q) ->
  G |-- ty_ref P >=> ty_ref Q.

Lemma extend_nonexpansive : forall F,
  nonexpansive F ->
  nonexpansive (fun X => %(F X)).

Lemma with_val_nonexpansive : forall F v,
  nonexpansive F ->
  nonexpansive (fun X => with_val v (F X)).

Lemma expr_type_nonexpansive : forall F e,
  nonexpansive F ->
  nonexpansive (fun X => (expr_type e (F X))).

Lemma ty_lam_contractive : forall F G,
  nonexpansive F ->
  nonexpansive G ->
  contractive (fun X => ty_lam (F X) (G X)).

Lemma type_at_contractive : forall l F,
  nonexpansive F ->
  contractive (fun X => type_at l (F X)).

Lemma ty_ref_contractive : forall F,
  nonexpansive F ->
  contractive (fun X => ty_ref (F X)).

Lemma just_extends : forall v,
  %just v = just v.

Lemma ty_ref_extends : forall tau,
  %(ty_ref tau) = ty_ref tau.

Lemma with_val_extends : forall v P,
  %(with_val v P) = with_val v (%P).

Lemma expr_type_extends : forall e tau,
  %expr_type e tau = expr_type e tau.

Lemma etype_valid_extends : forall G env,
  %etype_valid env G = etype_valid env G.

Lemma ty_lam_extends : forall sigma tau,
  %ty_lam sigma tau = ty_lam sigma tau. *)
Require Import lam_ref_type_safety.
(* lam_ref_type_safety:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.

Lemma expr_type_safen: forall k v e tau,
  expr_type e tau (k,v) ->
    forall m, mtype_valid m (k,v) ->
      safen (level k) (m,e).

Theorem typing_implies_safety: forall e tau,
  Typ nil e tau ->
  safe_prog e. *)
Require Import lam_ref_type_rules.
(* lam_ref_type_rules:
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.
Require Import lam_ref_type_safety.
Require Import lam_ref_type_lemmas.

Lemma T_weaken : forall G G' e tau,
  Typ G e tau ->
  Typ (G++G') e tau.

Lemma T_weaken_nil : forall G e tau,
  Typ nil e tau ->
  Typ G e tau.

Fixpoint gamma_sub (G G':etype) {struct G} : Prop :=
  match G, G' with
  | nil, nil => True
  | x::xs, y::ys => TT |-- y >=> x /\ gamma_sub xs ys
  | _, _ => False
  end.

Lemma etype_valid_sub : forall G G' env a,
  gamma_sub G G' ->
  etype_valid env G' a ->
  etype_valid env G  a.

Lemma T_weaken_sub : forall G G' e tau,
  gamma_sub G G' ->
  Typ G  e tau ->
  Typ G' e tau.

Lemma T_sub : forall G tau tau' e,
  TT |-- tau >=> tau' ->
  Typ G e tau ->
  Typ G e tau'.

Lemma T_Nat : forall G n,
  Typ G (Nat n) ty_nat.

Lemma T_Var: forall G x tau,
  nth_error G x = Some tau -> 
  Typ G (Var x) tau.

Lemma T_Abs: forall G sigma e tau,
  Typ (sigma :: G) e tau ->
  Typ G (Lam e) (ty_lam sigma tau).

Definition prim (f:nat -> value) : expr -> expr :=
  Prim (val_to_exp oo f).

Lemma T_Prim : forall G f e sigma,
  (forall n, Typ nil (val_to_exp (f n)) sigma) ->
  Typ G e ty_nat ->
  Typ G (prim f e) sigma.

Lemma T_New: forall G e tau,
  Typ G e tau ->
  Typ G (New e) (ty_ref tau).

Lemma T_App: forall G e1 sigma tau e2,
  Typ G e1 (ty_lam sigma tau) ->
  Typ G e2 sigma ->
  Typ G (App e1 e2) tau.

Lemma T_Deref: forall G e tau,
  Typ G e (ty_ref tau) ->
  Typ G (Deref e) tau.

Lemma T_Update: forall G e1 tau e2 e3 sigma,
  Typ G e1 (ty_ref tau) ->
  Typ G e2 tau ->
  Typ G e3 sigma ->
  Typ G (Update e1 e2 e3) sigma.

Definition AllBnd (T:pred world) (X:pred world -> pred world)
  := ALL tau:pred world, !!(TT |-- tau >=> T) --> X tau.

Lemma sub_AllBnd : forall T1 T2 (X1 X2:pred world -> pred world),
  TT |-- T2 >=> T1 ->
  (forall x, TT |-- x >=> T2 -> TT |-- X1 x >=> X2 x) ->
  TT |-- AllBnd T1 X1 >=> AllBnd T2 X2.

Lemma AllBnd_ALL : forall (X:pred world -> pred world),
  allp X = AllBnd TT X.

Lemma T_UnivBoundedI : forall G e T (X:pred world -> pred world),
  openValue e ->
  (forall tau, TT |-- tau >=> T -> Typ G e (X tau)) ->
  Typ G e (AllBnd T X).

Lemma T_UnivBoundedE : forall G e T (X:pred world -> pred world) tau,
  TT |-- tau >=> T ->
  Typ G e (AllBnd T X) ->
  Typ G e (X tau).

Lemma T_UnivI : forall G e (X:pred world -> pred world),
  openValue e ->
  (forall tau, Typ G e (X tau)) ->
  Typ G e (allp X).

Lemma T_UnivE : forall G e (X:pred world -> pred world) tau,
  Typ G e (allp X) ->
  Typ G e (X tau).

Definition ty_ex (F:pred world -> pred world) : pred world :=
  EX tau:pred world, !!(boxy extendM tau) && F tau.

Lemma T_ExtI : forall G e (X:pred world -> pred world) tau
  (Hext : forall tau, boxy extendM tau -> boxy extendM (X tau)),
  boxy extendM tau ->
  Typ G e (X tau) ->
  Typ G e (ty_ex X).

Lemma T_ExtE : forall G e f (X:pred world -> pred world) sigma
  (Hext : forall tau, boxy extendM tau -> boxy extendM (X tau)),
  Typ G e (ty_ex X) ->
  (forall tau, Typ (X tau::G) f sigma) ->
  Typ G (App (Lam f) e) sigma. *)

Require Import programs.

Definition bad_UnivI_rule :=
  forall G e (X:pred world -> pred world),
    (forall tau, Typ G e (X tau)) ->
    Typ G e (allp X).

Definition crash :=
  e_let
    
    ( e_let  (New none) 
       (Lam 
          (Update (Var 1 )
              (App some (Var 0 ))
              (Var 1 ))))
    
    ( e_let  (App (Var 0 ) (Lam (Var 0))) 
     (e_let  (App (Var 1 ) (Nat 5))       
       (App (App (App out (Lam (Var 0))) (Deref (Var 1 ))) (Nat 42))
     )).

Lemma crash_steps : exists m,
  stepstar (empty_mem, crash) (m, App (Nat 5) (Nat 42)).
Proof.
  intros.
  case_eq (eval 100 empty_mem crash); intros.
  exists m.
  apply eval_correct with 100%Z.
  compute in *; congruence.
Qed.

Lemma crash_unsafe : ~safe_prog crash.
Proof.
  intros H.
  destruct crash_steps as [m Hst].
  spec H empty_mem (m,App (Nat 5) (Nat 42)) Hst.
  destruct H; inv H.
  inv H0.
  inv H4.
  simpl in H1; auto.
Qed.

Lemma bad_rule_crash :
  bad_UnivI_rule -> Typ nil crash ty_nat.
Proof.
  intros.
  unfold crash.
  unfold e_let at 1.
  apply T_App with (ALL tau:pred world, ty_lam tau (ty_ref (option tau))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option (ty_lam ty_nat ty_nat))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option ty_nat)).
  apply T_Abs.
  apply T_App with ty_nat.
  apply T_App with (option (ty_lam ty_nat ty_nat)).
  apply T_App with (ty_lam ty_nat ty_nat).
  apply T_weaken_nil.
  change (ty_lam (ty_lam ty_nat ty_nat)
    (ty_lam (option (ty_lam ty_nat ty_nat)) (ty_lam ty_nat ty_nat)))
  with ((fun t => ty_lam t (ty_lam (option t) t)) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply out_typ.
  apply T_Abs.
  apply T_Var; simpl; auto.
  apply T_Deref.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_App with ty_nat.
  change (ty_lam ty_nat (ty_ref (option ty_nat)))
    with ((fun t => ty_lam t (ty_ref (option t))) ty_nat).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Nat.

  apply T_App with (ty_lam ty_nat ty_nat).
  change (ty_lam (ty_lam ty_nat ty_nat) (ty_ref (option (ty_lam ty_nat ty_nat))))
    with ((fun t => ty_lam t (ty_ref (option t))) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Abs.
  apply T_Var; simpl; auto.

  unfold bad_UnivI_rule in H.
  apply H; intros.
  apply T_App with (ty_ref (option tau)).
  apply T_Abs.
  apply T_Abs.
  apply T_Update with (option tau).
  apply T_Var; simpl; auto.
  apply T_App with tau.
  change (ty_lam tau (option tau))
    with ((fun t => ty_lam t (option t)) tau).
  apply T_UnivE.
  apply T_weaken_nil.
  apply some_typ.
  apply T_Var; simpl; auto.
  apply T_Var; simpl; auto.
  apply T_New.
  apply T_UnivE.
  apply none_typ.
Qed.

Theorem unrestricted_universals_inconsistent : ~bad_UnivI_rule.
Proof.
  intro H.
  apply crash_unsafe.
  apply typing_implies_safety with ty_nat.
  apply bad_rule_crash.
  assumption.
Qed.

Definition ok_program :=
  e_let
    
    (Lam
    ( e_let  (New none) 
       (Lam 
          (Update (Var 1 )
              (App some (Var 0 ))
              (Var 1 )))))
    
    ( e_let  (App (App (Var 0 ) (Nat 0)) (Lam (Var 0))) 
     (e_let  (App (App (Var 1 ) (Nat 0)) (Nat 5))       
       (App (App (App out (Lam (Var 0))) (Deref (Var 1 ))) (Nat 42))
     )).

Lemma ok_program_types :
  Typ nil ok_program ty_nat.
Proof.
  intros.
  unfold ok_program.
  unfold e_let at 1.
  apply T_App with (ALL tau:pred world, ty_lam ty_nat (ty_lam tau (ty_ref (option tau)))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option (ty_lam ty_nat ty_nat))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option ty_nat)).
  apply T_Abs.
  apply T_App with ty_nat.
  apply T_App with (option (ty_lam ty_nat ty_nat)).
  apply T_App with (ty_lam ty_nat ty_nat).
  apply T_weaken_nil.
  change (ty_lam (ty_lam ty_nat ty_nat)
    (ty_lam (option (ty_lam ty_nat ty_nat)) (ty_lam ty_nat ty_nat)))
  with ((fun t => ty_lam t (ty_lam (option t) t)) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply out_typ.
  apply T_Abs.
  apply T_Var; simpl; auto.
  apply T_Deref.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_App with ty_nat.
  apply T_App with ty_nat.
  change (ty_lam ty_nat (ty_lam ty_nat (ty_ref (option ty_nat))))
    with ((fun t => ty_lam ty_nat (ty_lam t (ty_ref (option t)))) ty_nat).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_Nat.

  apply T_App with (ty_lam ty_nat ty_nat).
  apply T_App with ty_nat.
  change (ty_lam ty_nat (ty_lam (ty_lam ty_nat ty_nat) (ty_ref (option (ty_lam ty_nat ty_nat)))))
    with ((fun t => ty_lam ty_nat (ty_lam t (ty_ref (option t)))) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_Abs.
  apply T_Var; simpl; auto.

  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  apply T_App with (ty_ref (option tau)).
  apply T_Abs.
  apply T_Abs.
  apply T_Update with (option tau).
  apply T_Var; simpl; auto.
  apply T_App with tau.
  change (ty_lam tau (option tau))
    with ((fun t => ty_lam t (option t)) tau).
  apply T_UnivE.
  apply T_weaken_nil.
  apply some_typ.
  apply T_Var; simpl; auto.
  apply T_Var; simpl; auto.
  apply T_New.
  apply T_UnivE.
  apply T_weaken_nil.
  apply none_typ.
Qed.

Theorem ok_program_safe :
  safe_prog ok_program.
Proof.
  eapply typing_implies_safety; apply ok_program_types.
Qed.

Eval vm_compute in (snd (eval 100 empty_mem crash)).
Eval vm_compute in (snd (eval 100 empty_mem ok_program)).

