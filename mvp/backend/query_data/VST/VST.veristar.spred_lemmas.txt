Load loadpath.
Require Import ZArith Coq.Lists.List Permutation.
Require Import VST.msl.Axioms.
Require Import VST.msl.predicates_sa.
Require Import VST.veric.Coqlib2.
Require Import veristar.variables veristar.datatypes veristar.clauses
(* veristar.variables:
Add LoadPath "..".
Require Import ZArith List Orders POrderedType.
Require Import veristar.tactics.

Module Ident : UsualOrderedType.
  Parameter t: Type.
  Definition eq := @Logic.eq t.
  Definition eq_equiv := @eq_equivalence t.
  Parameter lt : t -> t -> Prop.
  Parameter lt_strorder : StrictOrder lt.
  Parameter lt_compat : Proper (eq==>eq==>iff) lt.
  Parameter compare : forall x y : t, comparison.
  Axiom compare_spec: forall s s' : t, CompSpec eq lt s s' (compare s s').
  Parameter eq_dec : forall x y : t, {eq x y} + {~ eq x y}.
End Ident.

Parameter minid : Ident.t.
Parameter id2pos: Ident.t -> positive.
Parameter pos2id: positive -> Ident.t.
Axiom pos2id_inj: forall x y, pos2id x = pos2id y -> x = y.
Axiom minid_eq: id2pos minid = 1%positive.
Axiom Ilt_morphism: forall x y, Ident.lt x y -> Plt (id2pos x) (id2pos y).
Parameter another_id: Ident.t -> Ident.t.

Parameter Z2id: Z -> Ident.t.
Parameter add_id: Ident.t -> Ident.t -> Ident.t.
Parameter mult_id: Ident.t -> Ident.t -> Ident.t.

Lemma minid_min x : Ident.lt x minid -> False.

Ltac id_compare x y :=
  destruct (CompSpec2Type (Ident.compare_spec x y)).

Ltac id_comp x y H1 H2 H3 :=
  destruct (CompSpec2Type (Ident.compare_spec x y)) as [H1|H2|H3].

Lemma id2pos_inj x y : id2pos x = id2pos y -> x=y.

Lemma Ilt_irrefl : forall {x}, ~ Ident.lt x x.

Lemma Ilt_trans : forall {x y z}, Ident.lt x y -> Ident.lt y z -> Ident.lt x z.

Definition Ile x y := Ident.lt x y \/ Ident.eq x y.

Lemma Ile_refl x : Ile x x.

Hint Resolve Ile_refl.

Lemma Ilt_Zpos i j :
  Ident.lt i j <-> Z.lt (Zpos (id2pos i)) ((Zpos (id2pos j))).

Lemma nat_of_P_id2pos_le x y :
  Ile x y -> nat_of_P (id2pos x) <= nat_of_P (id2pos y). *)
(* veristar.datatypes:
Require Import ZArith List.
Require Import veristar.variables.

Definition var : Type := Ident.t.

Inductive expr := Nil | Var : var -> expr.

Inductive pn_atom := Equ : expr -> expr -> pn_atom | Nequ : expr -> expr -> pn_atom.

Inductive space_atom :=
| Next : expr -> expr -> space_atom
| Lseg : expr -> expr -> space_atom.

Inductive assertion : Type :=
  Assertion : forall (pi : list pn_atom) (sigma : list space_atom), assertion.

Inductive entailment : Type :=
  Entailment : assertion -> assertion -> entailment.

Definition subst_var (i: var) (t: expr) (j: var) :=
  if Ident.eq_dec i j then t else Var j.

Definition subst_expr (i: var) (t: expr) (t': expr) :=
  match t' with
    | Nil => Nil
    | Var j => if Ident.eq_dec i j then t else t'
  end.

Definition subst_pn (i: var) (t: expr) (a: pn_atom) :=
 match a with
   | Equ t1 t2 => Equ (subst_expr i t t1) (subst_expr i t t2)
   | Nequ t1 t2 => Nequ (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pns (i: var) (t: expr) (pa: list pn_atom)
  : list pn_atom := map (subst_pn i t) pa.

Definition subst_space (i: var) (t: expr) (a: space_atom) :=
  match a with
    | Next t1 t2 => Next (subst_expr i t t1) (subst_expr i t t2)
    | Lseg t1 t2 => Lseg (subst_expr i t t1) (subst_expr i t t2)
  end.

Definition subst_spaces (i: var) (t: expr)
  : list space_atom -> list space_atom := map (subst_space i t).

Definition subst_assertion (i: var) (e: expr) (a: assertion) :=
 match a with Assertion pi sigma =>
   Assertion (subst_pns i e pi) (subst_spaces i e sigma)
 end. *)
(* veristar.clauses:
Load loadpath.
Require Import ZArith List Recdef Coq.MSets.MSetInterface Coq.Sorting.Mergesort
               Permutation Coq.MSets.MSetAVL.
Require Import veristar.basic veristar.tactics veristar.variables veristar.datatypes
               veristar.compare veristar.redblack.

Inductive pure_atom := Eqv : expr -> expr -> pure_atom.

Let var1 : var := Z2id 1.
Let var0 : var := Z2id 0.
Let var2 : var := Z2id 2.

Fixpoint list_prio {A} (weight: var) (l: list A) (p: var) : var :=
  match l with
  | nil => p
  | _::l' => list_prio weight l' (add_id weight p)
  end.

Definition prio (gamma delta: list pure_atom) : var :=
    list_prio var2 gamma (list_prio var1 delta var0).

Inductive clause : Type :=
| PureClause : forall (gamma : list pure_atom) (delta : list pure_atom)
                         (priority : var)
                         (prio_ok: prio gamma delta = priority), clause
| PosSpaceClause : forall (gamma : list pure_atom) (delta : list pure_atom)
  (sigma : list space_atom), clause
| NegSpaceClause : forall (gamma : list pure_atom) (sigma : list space_atom)
  (delta : list pure_atom), clause.

Definition expr_cmp e e' :=
 match e, e' with
   | Nil , Nil => Eq
   | Nil, _ => Lt
   | _, Nil => Gt
   | Var v, Var v' => Ident.compare v v'
 end.

Lemma var_cspec : StrictCompSpec (@Logic.eq var) Ident.lt Ident.compare.

Hint Resolve var_cspec.

Lemma expr_cspec: CompSpec' expr_cmp.

Hint Resolve expr_cspec.

Definition pure_atom_cmp (a a': pure_atom) : comparison :=
 match a, a' with
   | Eqv e1 e2, Eqv e1' e2' =>
     match expr_cmp e1 e1' with
       Eq => expr_cmp e2 e2' | c => c
     end
 end.

Hint Rewrite @comp_refl using solve[auto] : comp.

Ltac comp_tac :=
    progress (autorewrite with comp in *; auto)
  || discriminate
  || solve [eapply comp_trans;  eauto]
  || subst
 || match goal with
  | H: Lt = ?A |- context [?A] => rewrite <- H
  | H: Gt = ?A |- context [?A] => rewrite <- H
  | H: Eq = ?A |- context [?A] => rewrite <- H
 end.

Lemma pure_atom_cspec: CompSpec' pure_atom_cmp.

Hint Resolve pure_atom_cspec.

Lemma pure_atom_cmp_eq a b : a = b <-> Eq = pure_atom_cmp a b.
Hint Resolve pure_atom_cmp_eq.

Definition expr_order (t t': expr) := isGe (expr_cmp t t').

Inductive max_expr (t : expr) : pure_atom -> Prop :=
| mexpr_left : forall t', expr_order t t' -> max_expr t (Eqv t t')
| mexpr_right : forall t', expr_order t t' -> max_expr t (Eqv t' t).

Definition order_eqv_pure_atom (a: pure_atom) :=
  match a with
    | Eqv i j => match expr_cmp i j with Lt => Eqv j i | _ => Eqv i j end
  end.

Definition nonreflex_atom a :=
  match a with Eqv i j => match expr_cmp i j with Eq => false | _ => true end
  end.

Definition normalize_atoms pa :=
  rsort_uniq pure_atom_cmp (map order_eqv_pure_atom pa).

Definition mkPureClause (gamma delta: list pure_atom) : clause :=
  PureClause gamma delta _ (eq_refl _).

Definition order_eqv_clause (c: clause) :=
  match c with
  | PureClause pa pa' _ _ =>
        mkPureClause (normalize_atoms (filter nonreflex_atom pa)) (normalize_atoms pa')
  | PosSpaceClause pa pa' sa' =>
    PosSpaceClause (normalize_atoms (filter nonreflex_atom pa))
                   (normalize_atoms pa') sa'
  | NegSpaceClause pa sa pa' =>
    NegSpaceClause (normalize_atoms (filter nonreflex_atom pa)) sa
                   (normalize_atoms pa')
  end.

Definition mk_pureL (a: pn_atom) : clause :=
 match a with
 | Equ x y => mkPureClause nil (order_eqv_pure_atom(Eqv x y)::nil)
 | Nequ x y => mkPureClause (order_eqv_pure_atom(Eqv x y)::nil) nil
 end.

Fixpoint mk_pureR (al: list pn_atom) : list pure_atom * list pure_atom :=
 match al with
 | nil => (nil,nil)
 | Equ x y :: l' => match mk_pureR l' with (p,n) =>
                      (order_eqv_pure_atom(Eqv x y)::p, n) end
 | Nequ x y :: l' => match mk_pureR l' with (p,n) =>
                       (p, order_eqv_pure_atom(Eqv x y)::n) end
 end.

Definition cnf (en: entailment) : list clause :=
 match en with
  Entailment (Assertion pureL spaceL) (Assertion pureR spaceR) =>
   match mk_pureR pureR with (p,n) =>
     map mk_pureL pureL ++ (PosSpaceClause nil nil spaceL :: nil) ++
       match spaceL, spaceR with
       | nil, nil => mkPureClause p n :: nil
       | _, _ => NegSpaceClause p spaceR n :: nil
       end
   end
  end.

Definition pure_atom_geq a b := isGeq (pure_atom_cmp a b).
Definition pure_atom_gt a b := match pure_atom_cmp a b with Gt => true | _ => false end.
Definition pure_atom_eq a b := match pure_atom_cmp a b with Eq => true | _ => false end.
Definition expr_lt a b := match expr_cmp a b with Lt => true | _ => false end.
Definition expr_eq a b := match expr_cmp a b with Eq => true | _ => false end.
Definition expr_geq a b := match expr_cmp a b with Lt => false | _ => true end.

Definition norm_pure_atom (a : pure_atom) :=
  match a with
    | Eqv i j => if expr_lt i j then Eqv j i else Eqv i j
  end.

Definition subst_pure (i: var) (t: expr) (a: pure_atom) :=
 match a with
   | Eqv t1 t2 => Eqv (subst_expr i t t1) (subst_expr i t t2)
 end.

Definition subst_pures (i: var) (t: expr) (pa: list pure_atom)
  : list pure_atom := map (subst_pure i t) pa.

Definition compare_space_atom (a b : space_atom) : comparison :=
 match a , b with
  | Next i j , Next i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  | Next i j, Lseg i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Lt
    | Gt => Gt
    end
  | Lseg i j, Next i' j' =>
    match expr_cmp i i' with
    | Lt => Lt
    | Eq => Gt
    | Gt => Gt
    end
  | Lseg i j , Lseg i' j' => match expr_cmp i i' with Eq => expr_cmp j j' | c => c end
  end.

Lemma space_atom_cspec: CompSpec' compare_space_atom.

Hint Resolve space_atom_cspec.

Definition compare_clause (cl1 cl2 : clause) : comparison :=
  match cl1 , cl2 with
  | PureClause neg pos _ _ , PureClause neg' pos' _ _ =>
    match compare_list pure_atom_cmp neg neg' with
    | Eq => compare_list pure_atom_cmp pos pos'
    | c => c
    end
  | PureClause _ _ _ _ , _ => Lt
  | _ , PureClause _ _ _ _ => Gt
  | PosSpaceClause gamma delta sigma , PosSpaceClause gamma' delta' sigma'
  | NegSpaceClause gamma sigma delta , NegSpaceClause gamma' sigma' delta' =>
    match compare_list pure_atom_cmp gamma gamma' with
    | Eq => match compare_list pure_atom_cmp delta delta' with
                 | Eq => compare_list compare_space_atom sigma sigma'
                 | c => c
                 end
    | c => c
    end
  | PosSpaceClause _ _ _ , NegSpaceClause _ _ _ => Lt
  | NegSpaceClause _ _ _ , PosSpaceClause _ _ _ => Gt
  end.

Lemma clause_cspec: CompSpec' compare_clause.

Hint Resolve clause_cspec.

Definition rev_cmp {A : Type} (cmp : A -> A -> comparison) :=
  fun a b => match cmp a b with Eq => Eq | Lt => Gt | Gt => Lt end.

Lemma rev_cmp_cspec {A} (c: A -> A -> comparison) :
  CompSpec' c -> CompSpec' (rev_cmp c).

Lemma rev_cmp_eq : forall {A : Type} (cmp : A -> A -> comparison) (x y : A),
  (forall x0 y0 : A, Eq = cmp x0 y0 -> x0 = y0) ->
  Eq = rev_cmp cmp x y -> x = y.

Definition prio1000 := Z2id 1000.
Definition prio1001 := Z2id 1001.

Definition clause_prio (cl : clause) : var :=
  match cl with
  | PureClause gamma delta prio _ => prio
  | PosSpaceClause _ _ _ => prio1000
  | NegSpaceClause gamma sigma delta => prio1001
  end%Z.

Definition compare_clause' (cl1 cl2 : clause) : comparison :=
  match Ident.compare (clause_prio cl1) (clause_prio cl2) with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec': CompSpec' compare_clause'.

Hint Resolve clause_cspec'.

Definition clause_length (cl : clause) : Z :=
  match cl with
  | PureClause gamma delta _ _ => Zlength gamma + Zlength delta
  | PosSpaceClause gamma delta sigma =>
      Zlength gamma + Zlength delta + Zlength sigma
  | NegSpaceClause gamma sigma delta =>
      Zlength gamma + Zlength sigma + Zlength delta
  end%Z.

Definition compare_clause_length (cl1 cl2 : clause) :=
   Zcompare (clause_length cl1) (clause_length cl2).

Definition compare_clause'1 (cl1 cl2 : clause) : comparison :=
  match compare_clause_length cl1 cl2 with
  | Eq => compare_clause cl1 cl2
  | c => c
  end.

Lemma clause_cspec'1: CompSpec' compare_clause'1.

Hint Resolve clause_cspec'1.

Module OrderedClause <: OrderedType
  with Definition t:=clause
  with Definition compare:=compare_clause'.

Definition t := clause.

Definition eq : clause -> clause -> Prop := Logic.eq.

Lemma eq_equiv : Equivalence eq.

Definition lt (c1 c2 : clause) := Lt = compare_clause' c1 c2.

Lemma lt_compat : Proper (eq ==> eq ==> iff) lt.

Definition compare := compare_clause'.

Lemma compare_spec : forall x y, CompSpec eq lt x y (compare x y).

Lemma eq_dec : forall x y, {eq x y}+{~eq x y}.

Lemma lt_strorder : StrictOrder lt.

End OrderedClause.

Module M1 : redblack.MSetPlus
   with Definition E.t := OrderedClause.t
   with Definition E.compare := OrderedClause.compare
   with Definition E.eq := OrderedClause.eq
   with Definition E.lt := OrderedClause.lt
   with Definition E.compare := OrderedClause.compare.
 Include MSetAVL.Make(OrderedClause).
 Definition delete_min (s: t) : option (elt * t) :=
   match min_elt s with
   | Some x => Some (x, remove x s)
   | None => None
  end.
 Lemma delete_min_spec1: forall (s: t) k s',
    delete_min s = Some (k,s') <->
    (min_elt s = Some k /\ remove k s = s').
 Lemma delete_min_spec2: forall s, delete_min s = None <-> Empty s.
Definition mem_add (x: elt) (s: t) : option t :=
 if mem x s then None else Some (add x s).

Lemma mem_add_spec:
    forall x s, mem_add x s = if mem x s then None else Some (add x s).
End M1.

Module M := redblack.Make(OrderedClause).

Definition clause_list2set (l : list clause) : M.t :=
  fold_left (fun s0 c => M.add c s0) l M.empty.

Definition empty_clause : clause := mkPureClause nil nil.

Definition remove_trivial_atoms := filter (fun a =>
  match a with
  | Eqv e1 e2 => match expr_cmp e1 e2 with
                 | Eq => false
                 | _ => true
                 end
  end).

Definition subst_pures_delete (i: var) (e: expr)
  : list pure_atom -> list pure_atom :=
  remove_trivial_atoms oo subst_pures i e.

Definition isEq cc := match cc with Eq => true | _ => false end.

Definition eq_space_atom (a b : space_atom) : bool :=
  isEq (compare_space_atom a b).

Definition eq_space_atomlist (a b : list space_atom) : bool :=
  isEq (compare_list compare_space_atom a b).

Definition eq_var i j : bool := isEq (Ident.compare i j).

Definition drop_reflex_lseg : list space_atom -> list space_atom :=
  filter (fun sa =>
                    match sa with
                    | Lseg (Var x) (Var y) => negb (eq_var x y)
                    | Lseg Nil Nil => false
                    | _ => true
                    end).

Definition order_eqv_pure_atoms := map order_eqv_pure_atom.

Definition greater_than_expr (i: var) (e: expr) :=
  match e with Var j => match Ident.compare i j with Gt => true | _ => false end
                        | Nil => true
  end.

Definition greatereq_than_expr (i: var) (e: expr) :=
  match e with
  | Var j => match Ident.compare i j with Gt => true | Eq => true | Lt => false
             end
  | Nil => true
  end.

Definition greater_than_atom (s u : pure_atom) :=
  match s , u with
  | Eqv s t , Eqv u v =>
    ((expr_lt u s && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v s && (expr_geq s u || expr_geq t u))) ||
    ((expr_lt u t && (expr_geq s v || expr_geq t v)) ||
      (expr_lt v t && (expr_geq s u || expr_geq t u)))
  end.

Definition greater_than_atoms (s : pure_atom) (delta : list pure_atom) :=
  forallb (fun u => greater_than_atom s u) delta.

Definition greater_than_all (i: var) : list pure_atom -> bool :=
  forallb (fun a => match a with Eqv x y =>
             andb (greater_than_expr i x) (greater_than_expr i y) end).

Definition subst_clause i e cl : clause :=
  match cl with
  | PureClause pa pa' _ _ =>
      mkPureClause (subst_pures_delete i e pa) (subst_pures i e pa')
  | NegSpaceClause pa sa pa' =>
      NegSpaceClause (subst_pures_delete i e pa) (subst_spaces i e sa)
                     (subst_pures i e pa')
  | PosSpaceClause pa pa' sa' =>
      PosSpaceClause (subst_pures_delete i e pa) (subst_pures i e pa')
                     (subst_spaces i e sa')
  end.

Definition var_eqZ v v' := Ident.eq v v'.

Lemma eq_pos_var_eqZ v v' : true = eq_var v v' -> var_eqZ v v'.

Definition ocons {A : Type} (o : option A) l :=
  match o with Some a => a :: l | None => l end.

Fixpoint omapl {A B : Type} (f : A -> option B) (l : list A) : list B :=
  match l with
  | a :: l' => ocons (f a) (omapl f l')
  | nil => nil
  end.

Fixpoint merge {A: Type} (cmp : A -> A -> comparison) l1 l2 :=
  let fix merge_aux l2 :=
  match l1, l2 with
  | [], _ => l2
  | _, [] => l1
  | a1::l1', a2::l2' =>
      match cmp a1 a2 with
      | Eq => a1 :: merge cmp l1' l2'
      | Gt => a1 :: merge cmp l1' l2
      | _ => a2 :: merge_aux l2' end
  end
  in merge_aux l2.

Notation sortu_atms := (rsort_uniq pure_atom_cmp).
Notation insu_atm := (insert_uniq pure_atom_cmp).
Notation sortu_clauses := (rsort_uniq compare_clause).

Lemma compare_clause_eq_equivalence:
     RelationClasses.Equivalence (fun c1 c2 => Eq = compare_clause c1 c2).

Lemma pure_clause_ext:
  forall gamma delta p Pp p' Pp',
     PureClause gamma delta p Pp = PureClause gamma delta p' Pp'.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.

Lemma mem_spec': forall s x, M.mem x s = false <-> ~M.In x s.

Lemma is_empty_spec': forall s, M.is_empty s = false <-> ~M.Empty s.

Lemma empty_set_elems':
  forall s, M.Empty s <-> M.elements s = nil.

Lemma Melements_spec1: forall (s: M.t) x, List.In x (M.elements s) <-> M.In x s.

Require Import Finite_sets_facts.
Require Import VST.msl.Axioms.

Lemma Mcardinal_spec': forall s,   cardinal _ (Basics.flip M.In s) (M.cardinal s).

Lemma remove_decreases:
  forall giv unselected,
  M.In giv unselected ->

Definition pure_atom2pn_atom (b : bool) (a : pure_atom) :=
  match a with
  | Eqv e1 e2 => if b then Equ e1 e2 else Nequ e1 e2
  end.

Definition pn_atom_cmp (a1 a2 : pn_atom) : comparison :=
  match a1, a2 with
  | Equ e1 e2, Equ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Equ e1' e2' =>
    if expr_eq e1 e1' then Gt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Equ e1 e2, Nequ e1' e2' =>
    if expr_eq e1 e1' then Lt else pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  | Nequ e1 e2, Nequ e1' e2' => pure_atom_cmp (Eqv e1 e2) (Eqv e1' e2')
  end.

Definition pure_clause2pn_list (c : clause) :=
  match c with
  | PureClause gamma delta _ _ =>
    rsort pn_atom_cmp
      (map (pure_atom2pn_atom false) gamma ++ map (pure_atom2pn_atom true) delta)
  | _ => nil
  end.

Definition compare_clause2 (cl1 cl2 : clause) :=
  match cl1, cl2 with
  | PureClause _ _ _ _, PureClause _ _ _ _ =>
    compare_list pn_atom_cmp (pure_clause2pn_list cl1) (pure_clause2pn_list cl2)
  | _, _ => compare_clause cl1 cl2
  end.

Lemma compare_clause_eq cl1 cl2 : Eq = compare_clause cl1 cl2 -> cl1 = cl2.

Inductive ce_type := CexpL | CexpR | CexpEf.

Module DebuggingHooks.

Definition print_new_pures_set (s: M.t) := s.

Definition print_wf_set (s: M.t) := s.

Definition print_unfold_set (s: M.t) := s.

Definition print_inferred_list (l: list clause) := l.

Definition print_pures_list (l: list clause) := l.

Definition print_eqs_list (l: list clause) := l.

Definition print_spatial_model (c: clause) (R: list (var * expr)) := c.

Definition print_spatial_model2 (c c': clause) (R: list (var * expr)) := c'.

Definition print_ce_clause (R: list (var * expr)) (cl : clause) (ct : ce_type)
  := (R, cl, ct).

End DebuggingHooks.

Export DebuggingHooks.

Hint Unfold print_new_pures_set print_wf_set print_inferred_list print_spatial_model
            print_pures_list print_eqs_list
  : DEBUG_UNFOLD. *)
               veristar.list_denote veristar.model_type veristar.model
               veristar.basic veristar.compare.

Module Type SPRED_LEMMAS.
Declare Module VSM : VERISTAR_MODEL.
Import VSM VeriStarLogic.

End SPRED_LEMMAS.

Module SPredLemmas (VSM : VERISTAR_MODEL) <: SPRED_LEMMAS
  with Module VSM := VSM.
Module VSM := VSM.
Import VSM VeriStarLogic.

Import sepalg.

Module spred. Section spred.
Variables x y z : spred.

Local Open Scope pred.

Lemma andpN : x && TT = x.
Proof. apply andp_TT. Qed.

Lemma andpS : x && y = y && x.
Proof. apply andp_comm. Qed.

Lemma andpA : x && (y && z) = (x && y) && z.
Proof. rewrite andp_assoc; auto. Qed.

Lemma orpN : x || FF = x.
Proof.
extensionality; apply prop_ext; split; [solve[intros [H|H]; [auto|case H]; auto]
|solve[left; auto]].
Qed.

Lemma orpS : x || y = y || x.
Proof. apply union_com. Qed.

Lemma orpA : x || (y || z) = (x || y) || z.
Proof. rewrite union_assoc; auto. Qed.

Lemma sepconS : sepcon x y = sepcon y x.
Proof. apply sepcon_comm. Qed.

Lemma sepconA : x * (y * z) = (x * y) * z.
Proof. rewrite sepcon_assoc; auto. Qed.

End spred. End spred.

Lemma emp_sep_emp h h1 h2 : join h h1 h2 -> emp h -> emp h1 -> emp h2.
Proof. intros; rewrite <-(emp_sepcon emp); exists h; exists h1; split; auto. Qed.

Lemma space_denote_permute l l' :
  Permutation l l' -> space_denote l = space_denote l'.
Proof.
intros;
apply (listd_perm space_atom_denote _ emp spred.sepconS spred.sepconA l l' H).
Qed.

Lemma space_insert sa l :
  space_denote (insert (rev_cmp compare_space_atom) sa l) =
  space_denote (sa :: l).
Proof.
intros; eapply listd_perm;
[apply spred.sepconS|apply spred.sepconA|apply perm_insert].
Qed.

Lemma eq_space_atomlist_sound (al bl : list space_atom) :
  true = eq_space_atomlist al bl ->
  space_denote al = space_denote bl.
Proof.
intros H; unfold eq_space_atomlist, isEq in H.
remember (compare_list compare_space_atom al bl) as j; destruct j; inversion H.
solve[apply comp_eq in Heqj; subst; auto].
Qed.

Lemma expr_eq_eq' : forall e1 e2, true = expr_eq e1 e2 -> e1=e2.
Proof.
unfold expr_eq; intros; do_comp expr_cspec e1 e2; subst; auto; congruence.
Qed.

Lemma pure_atom_denote_order_eqv_pure_atom : forall a,
  pure_atom_denote a = pure_atom_denote (order_eqv_pure_atom a).
Proof.
intros; destruct a; unfold pure_atom_denote in *; simpl in *.
remember (expr_cmp e e0) as b; destruct b; try reflexivity.
solve[apply var_eq_sym'].
Qed.

Lemma list_denote_normalize_pure_atoms:
 forall Q (B:spred) (l:list pure_atom)
     (Qassoc: forall x y z , Q x (Q y z) = Q (Q x y) z)
     (Qsymm: forall x y, Q x y = Q y x)
     (Hcmp: forall x y, Eq = pure_atom_cmp x y ->
                        (forall P, Q (pure_atom_denote x) (Q (pure_atom_denote y) P) = Q (pure_atom_denote y) P)),
list_denote pure_atom_denote Q B l =
list_denote pure_atom_denote Q B (normalize_atoms l).
Proof.
intros.
unfold normalize_atoms.
  rewrite listd_sort_uniq.
    rewrite listd_map.
      reflexivity.
      intros. rewrite <- pure_atom_denote_order_eqv_pure_atom. trivial.
      apply Qsymm.
      apply Qassoc.
    apply Hcmp.
Qed.

Lemma union_contractive:
forall {A} x, (@orp A) x x = x.
Proof.
intros. unfold orp.
extensionality a. apply prop_ext. split; intros.
 destruct H; assumption. left; assumption.
Qed.

Lemma list_denote_union_normalize_pure_atoms:
 forall(B:spred) (l:list pure_atom),
list_denote pure_atom_denote (@orp state) B l =
list_denote pure_atom_denote (@orp state) B (normalize_atoms l).
Proof.
intros.
apply list_denote_normalize_pure_atoms.
  intros. rewrite union_assoc; trivial.
  intros. rewrite union_com; trivial.
  intros. rewrite <- pure_atom_cmp_eq in H. rewrite H.
      rewrite <- union_assoc.
      rewrite union_contractive. reflexivity.
Qed.

Lemma intersection_contractive:
forall {A} x, (@andp A) x x = x.
Proof.
intros. unfold andp.
extensionality a. apply prop_ext. split; intros. destruct H; assumption. split; assumption.
Qed.

Lemma list_denote_intersection_normalize_pure_atoms:
 forall(B:spred) (l:list pure_atom),
list_denote pure_atom_denote (@andp state) B l =
list_denote pure_atom_denote (@andp state) B (normalize_atoms l).
Proof.
intros.
apply list_denote_normalize_pure_atoms.
  intros. rewrite andp_assoc; trivial.
  intros. rewrite andp_comm; trivial.
  intros.
  rewrite <- pure_atom_cmp_eq in H. rewrite H.
      rewrite <- andp_assoc.
      rewrite intersection_contractive. reflexivity.
Qed.

Lemma expr_cmp_eq: forall e e',
  expr_cmp e e' = Eq -> (e === e') = TT.
Proof.
intros.
extensionality s; apply prop_ext.
split; intros; trivial.
clear H0.
destruct e; simpl.
  destruct e'; simpl. reflexivity. inversion H.
  destruct e'; simpl. inversion H.
    inversion H.
symmetry in H. apply comp_eq in H; auto.
inversion H; subst; reflexivity.
Qed.

Lemma expr_cmp_eq': forall e e' s,
  expr_cmp e e' = Eq -> (e === e') s.
Proof.
intros.
rewrite (expr_cmp_eq _ _ H). trivial.
Qed.

Lemma list_denote_intersection_filter_nonreflex:
 forall(B:spred) (l:list pure_atom),
list_denote pure_atom_denote (@andp state) B l =
list_denote pure_atom_denote (@andp state) B (filter nonreflex_atom l).
Proof.
intros.
induction l; simpl. reflexivity.
rewrite IHl. clear IHl.
remember (nonreflex_atom a) as b; destruct b; simpl.
  reflexivity.
destruct a; simpl in *.
  assert (expr_cmp e e0 = Eq).
    remember (expr_cmp e e0) as b; destruct b; try reflexivity.
    inversion Heqb. inversion Heqb.
  clear Heqb.
rewrite (expr_cmp_eq _ _ H). rewrite TT_and. reflexivity.
Qed.

Lemma list_denote_normalize_filter_nonreflex_atom:
forall B l,
list_denote pure_atom_denote (@andp state) B
            (normalize_atoms (filter nonreflex_atom l))
= list_denote pure_atom_denote (@andp state) B l.
Proof.
intros.
rewrite <- list_denote_intersection_normalize_pure_atoms.
rewrite <- list_denote_intersection_filter_nonreflex; reflexivity.
Qed.

Lemma list_denote_inter_app : forall {A} (f: A -> spred) cs1 cs2 s,
  list_denote f (@andp state) TT (cs1 ++ cs2) s ->
  (list_denote f (@andp state) TT cs1 s /\
   list_denote f (@andp state) TT cs2 s).
Proof.
intros A f.
induction cs1; simpl; intros.
  split. trivial. assumption.
destruct H as [H1 H2].
 destruct (IHcs1 _ _ H2) as [H3 H4].
 split. split; assumption. assumption.
Qed.

Lemma list_denote_assoc_sym_id : forall {A T} (E: A -> T) Q B C l
  (CID : forall x, Q x C = x)
  (QSYM : forall x y, Q x y = Q y x)
  (QASSOC : forall x y z, Q x (Q y z) = Q (Q x y) z),
  list_denote E Q B l = Q B (list_denote E Q C l).
Proof.
intros.
induction l; simpl; intros; auto.
rewrite IHl. rewrite QSYM. rewrite <- QASSOC.
pattern (Q (list_denote E Q C l) (E a)).
rewrite QSYM. auto.
Qed.

Lemma list_denote_union_left : forall {A} (f: A -> spred) cs1 cs2 s,
  list_denote f (@orp state) FF cs1 s ->
  list_denote f (@orp state) FF (cs1 ++ cs2) s.
Proof.
intros.
rewrite listd_app.
rewrite (@listd_unfold_un _ state).
left. assumption.
Qed.

Lemma list_denote_union_right : forall {A} (f: A -> spred) cs1 cs2 s,
  list_denote f (@orp state) FF cs2 s ->
  list_denote f (@orp state) FF (cs1 ++ cs2) s.
Proof.
intros.
rewrite listd_app.
rewrite (@listd_unfold_un _ state).
right. assumption.
Qed.

Lemma list_denote_sepcon_sort :
  forall {A} (E:A -> spred) (B:spred) (l:list A) cmp s,
    list_denote E sepcon B l s <->
    list_denote E sepcon B (rsort cmp l) s.
Proof.
intros.
rewrite (listd_sort). split; trivial.
intros; rewrite sepcon_comm; auto.
intros; rewrite sepcon_assoc; auto.
Qed.

Lemma empty_not_singleton: forall c, M.empty <> M.singleton c.
 Proof. intros. intro.
   contradiction (@M.empty_spec c).
   rewrite H. rewrite M.singleton_spec. auto.
Qed.

Lemma singleton_inv:
  forall x y, M.singleton x = M.singleton y -> x=y.
Proof.
intros.
apply (M.singleton_spec y).
rewrite <- H. apply M.singleton_spec. auto.
Qed.

Lemma elements_singleton: forall c, M.elements (M.singleton c) = [c].
Proof.
intros.
assert (X:= M.singleton_spec c).
assert (ND := M.elements_spec2w (M.singleton c)).
inversion ND; clear ND.
  apply False_ind.
  remember (M.elements (M.singleton c)) as l.
  destruct l.
    apply eq_sym in Heql.
    apply empty_set_elems' in Heql.
    unfold M.Empty in Heql. apply (Heql c). apply X. trivial.
  inversion H0.
assert (x = c).
  apply X. rewrite <- elements_In. rewrite <- H. left. trivial.
subst.
destruct l. trivial.
assert (c0 = c).
  apply X. rewrite <- elements_In. rewrite <- H. right. left. trivial.
subst. exfalso. apply H0. left. trivial.
Qed.

Lemma var_eq_Next: forall e e' g g' s, (e === e') s -> (g === g') s ->
space_atom_denote (Next e g) s = space_atom_denote (Next e' g') s.
Proof.
intros; simpl.
apply prop_ext; split; intros.
  rewrite H in H1. rewrite H0 in H1. assumption.
  rewrite H. rewrite H0. assumption.
Qed.

Lemma var_eq_Lseg1: forall e e' g s, (e === e') s ->
space_atom_denote (Lseg e g) s = space_atom_denote (Lseg e' g) s.
Proof.
intros; simpl.
rewrite H; auto.
Qed.

Lemma var_eq_Lseg2: forall g e e' s, (e === e') s ->
space_atom_denote (Lseg g e) s = space_atom_denote (Lseg g e') s.
Proof.
intros; simpl.
rewrite H; auto.
Qed.

Lemma var_eq_Lseg: forall e e' g g' s, (e === e') s -> (g === g') s ->
space_atom_denote (Lseg e g) s = space_atom_denote (Lseg e' g') s.
Proof.
intros.
eapply eq_trans. apply var_eq_Lseg2. apply H0.
apply var_eq_Lseg1. apply H.
Qed.

Lemma join_stacks_eq : forall s0 s1 s : state,
  join s0 s1 s -> stk s0=stk s1 /\ stk s0=stk s.
Proof.
intros.
destruct H. destruct H.
subst; split; auto.
transitivity (stk s1); auto.
Qed.

Lemma expr_denote_join: forall e s r t,
join s r t -> expr_denote e t = expr_denote e s.
Proof.
intros.
destruct e; simpl in H; simpl; intros. trivial.
destruct (join_stacks_eq _ _ _ H) as [_ D].
rewrite <- D. trivial.
Qed.

Lemma expr_denote_eq_dec_loc:
   forall x y s,
        nil_or_loc (expr_denote x s) ->
        Decidable.decidable (expr_denote x s = expr_denote y s).
Proof.
intros.
destruct H.
rewrite H.
destruct (nil_dec (expr_denote y s)); [left | right]; auto.
destruct H as [l ?].
case_eq (val2loc (expr_denote y s)); intros.
destruct (loc_eq_dec l l0).
left; subst.
eapply val2loc_inj; eauto.
right.
contradict H1. rewrite H1 in *. congruence.
right.
intro.
rewrite H1 in *; congruence.
Qed.

Lemma expr_denote_heap_ind : forall x s h h',
  expr_denote x (State s h)=expr_denote x (State s h').
Proof.
intros. destruct x; auto.
Qed.

Lemma state_join_var_eq : forall (s0 s1 s : state) x y,
  join s0 s1 s ->
  (x === y) s0 ->
  (x === y) s.
Proof.
intros.
destruct s; destruct s0; destruct s1. destruct H. simpl in *. destruct H.
unfold var_eq in *; subst; auto.
Qed.

Lemma state_join_var_eq' : forall (s0 s1 s : state) x y,
  join s0 s1 s ->
  (x === y) s ->
  (x === y) s0.
Proof.
intros.
destruct s; destruct s0; destruct s1. destruct H. simpl in *. destruct H.
unfold var_eq in *; subst; auto.
Qed.

Lemma unXX {A:Type} (P: pred A) b : un P (un P b) = un P b.
Proof.
extensionality a; apply prop_ext; split; firstorder.
Qed.

Lemma lseg_appN: forall x y s r t,
 lseg x y s -> lseg y nil_val r -> join s r t -> lseg x nil_val t.
Proof.
intros.
revert r H0 t H1; induction H; intros.
apply join_unit1_e in H2; auto. subst; auto.
specialize (IHlseg _ H4).
destruct (join_assoc H3 H5) as [hf [? ?]].
specialize (IHlseg _ H6).
econstructor 2; eauto.
intro; subst. rewrite nil_not_loc in H0; inversion H0.
Qed.

Lemma pure_atom_denote_heap_ind: forall a s h h',
pure_atom_denote a (State s h) = pure_atom_denote a (State s h').
Proof.
intros.
destruct a; simpl.
unfold var_eq. simpl.
rewrite (expr_denote_heap_ind e s h h').
rewrite (expr_denote_heap_ind e0 s h h').
reflexivity.
Qed.

Lemma pure_atoms_denote_intersection_heap_ind: forall Delta s h h',
list_denote pure_atom_denote (@andp state) TT Delta (State s h) =
list_denote pure_atom_denote (@andp state) TT Delta (State s h').
Proof.
intros Delta.
induction Delta; simpl; intros.
  reflexivity.
apply prop_ext.
split; intros; destruct H.
  split. rewrite <- (pure_atom_denote_heap_ind a s h h'). assumption.
  rewrite <- (IHDelta s h h'). assumption.
split. rewrite (pure_atom_denote_heap_ind a s h h'). assumption.
  rewrite (IHDelta s h h'). assumption.
Qed.

Lemma pure_atoms_denote_union_heap_ind: forall Delta s h h',
list_denote pure_atom_denote (@orp state) FF Delta (State s h) =
list_denote pure_atom_denote (@orp state) FF Delta (State s h').
Proof.
intros Delta.
induction Delta; simpl; intros.
  reflexivity.
apply prop_ext.
split; intros; destruct H.
  left. rewrite <- (pure_atom_denote_heap_ind a s h h'). assumption.
  right. rewrite <- (IHDelta s h h'). assumption.
left. rewrite (pure_atom_denote_heap_ind a s h h'). assumption.
  right. rewrite (IHDelta s h h'). assumption.
Qed.

Lemma lseg_nil_or_loc:
  forall x y h, lseg x y h -> nil_or_loc y.
Proof.
induction 1; auto.
Qed.

Lemma lseg_end: forall x y h,
  lseg x y h -> (x = y /\ emp h) \/ y = nil_val \/
     (exists l, val2loc y = Some l /\ emp_at l h).
Proof.
induction 1; intros; auto.
right.
destruct IHlseg as [[? ?] | [?|[l [? ?]]]]; auto.
subst.
apply join_unit2_e in H3; auto. subst h0.
apply lseg_nil_or_loc in H2.
clear H5.
destruct H2; auto; right.
destruct H2 as [l ?]; exists l.
split; auto.
apply (rawnext_out H1 H2).
contradict H.
subst l.
apply val2loc_inj with x'; auto.
right; exists l.
split; auto.
apply emp_at_join with l in H3.
apply H3. split; auto.
assert (l<>x') by (contradict H; subst; eapply val2loc_inj; eauto).
eapply rawnext_out; eauto.
Qed.

Lemma lseg_lseg_app: forall x y z h1 h2 h tz,
  lseg x y h1 ->
  lseg y z h2 ->
  join h2 h1 h ->
 val2loc z = Some tz ->
  emp_at tz h ->
  lseg x z h.
Proof.
intros.
revert z h2 H0 h H1 tz H2 H3; induction H; intros.
apply join_unit2_e in H2; auto; subst; auto.
specialize (IHlseg _ _ H4).
destruct (join_assoc H3 (join_comm H5)) as [hf [? ?]].
specialize (IHlseg _ (@join_comm _ _ Perm_heap _ _ _ H8) _ H6).
assert (emp_at tz hf). apply emp_at_join with tz in H9. apply H9 in H7. destruct H7; auto.
specialize (IHlseg H10).
eapply lseg_cons; eauto.
intro; subst z0.
assert (x'=tz) by congruence. subst x'.
clear H6.
apply emp_at_join with tz in H9.
apply H9 in H7. destruct H7.
clear - H1 H6. eapply rawnext_not_emp; eauto.
eapply rawnext2rawnext'; eauto.
Qed.

Lemma Space_denote_cons: forall a L,
space_denote (a::L) = sepcon (space_atom_denote a) (space_denote L).
Proof.
intros.
apply listd_cons.
Qed.

Lemma Space_denote_app: forall M L,
space_denote (M ++ L) = sepcon (space_denote M) (space_denote L).
Proof.
intros M.
induction M; simpl.
  intros. rewrite (emp_sepcon (space_denote L)). trivial.
intros.
  rewrite (IHM L). rewrite sepconA; auto with typeclass_instances.
Qed.

Lemma Space_denote_rev: forall L,
space_denote (rev L) = (space_denote L).
Proof.
intros.
apply space_denote_permute. apply Permutation_sym.  apply Permutation_rev.
Qed.

End SPredLemmas.
