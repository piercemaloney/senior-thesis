

Require Import Coq.Strings.String.



Require Import compcert.common.AST.
(* compcert.common.AST:
Require Import String.
Require Import Coqlib Maps Errors Integers Floats.
Require Archi.

Set Implicit Arguments.

Definition ident := positive.

Definition ident_eq := peq.

Inductive typ : Type :=
  | Tint                
  | Tfloat              
  | Tlong               
  | Tsingle             
  | Tany32              
  | Tany64.             

Lemma typ_eq: forall (t1 t2: typ), {t1=t2} + {t1<>t2}.
Global Opaque typ_eq.

Definition opt_typ_eq: forall (t1 t2: option typ), {t1=t2} + {t1<>t2}
                     := option_eq typ_eq.

Definition list_typ_eq: forall (l1 l2: list typ), {l1=l2} + {l1<>l2}
                     := list_eq_dec typ_eq.

Definition Tptr : typ := if Archi.ptr64 then Tlong else Tint.

Definition typesize (ty: typ) : Z :=
  match ty with
  | Tint => 4
  | Tfloat => 8
  | Tlong => 8
  | Tsingle => 4
  | Tany32 => 4
  | Tany64 => 8
  end.

Lemma typesize_pos: forall ty, typesize ty > 0.

Lemma typesize_Tptr: typesize Tptr = if Archi.ptr64 then 8 else 4.

Definition subtype (ty1 ty2: typ) : bool :=
  match ty1, ty2 with
  | Tint, Tint => true
  | Tlong, Tlong => true
  | Tfloat, Tfloat => true
  | Tsingle, Tsingle => true
  | (Tint | Tsingle | Tany32), Tany32 => true
  | _, Tany64 => true
  | _, _ => false
  end.

Fixpoint subtype_list (tyl1 tyl2: list typ) : bool :=
  match tyl1, tyl2 with
  | nil, nil => true
  | ty1::tys1, ty2::tys2 => subtype ty1 ty2 && subtype_list tys1 tys2
  | _, _ => false
  end.

Record calling_convention : Type := mkcallconv {
  cc_vararg: bool;                      
  cc_unproto: bool;                     
  cc_structret: bool                    
}.

Definition cc_default :=
  {| cc_vararg := false; cc_unproto := false; cc_structret := false |}.

Definition calling_convention_eq (x y: calling_convention) : {x=y} + {x<>y}.
Global Opaque calling_convention_eq.

Record signature : Type := mksignature {
  sig_args: list typ;
  sig_res: option typ;
  sig_cc: calling_convention
}.

Definition proj_sig_res (s: signature) : typ :=
  match s.(sig_res) with
  | None => Tint
  | Some t => t
  end.

Definition signature_eq: forall (s1 s2: signature), {s1=s2} + {s1<>s2}.
Global Opaque signature_eq.

Definition signature_main :=
  {| sig_args := nil; sig_res := Some Tint; sig_cc := cc_default |}.

Inductive memory_chunk : Type :=
  | Mint8signed     
  | Mint8unsigned   
  | Mint16signed    
  | Mint16unsigned  
  | Mint32          
  | Mint64          
  | Mfloat32        
  | Mfloat64        
  | Many32          
  | Many64.         

Definition chunk_eq: forall (c1 c2: memory_chunk), {c1=c2} + {c1<>c2}.
Global Opaque chunk_eq.

Definition Mptr : memory_chunk := if Archi.ptr64 then Mint64 else Mint32.

Definition type_of_chunk (c: memory_chunk) : typ :=
  match c with
  | Mint8signed => Tint
  | Mint8unsigned => Tint
  | Mint16signed => Tint
  | Mint16unsigned => Tint
  | Mint32 => Tint
  | Mint64 => Tlong
  | Mfloat32 => Tsingle
  | Mfloat64 => Tfloat
  | Many32 => Tany32
  | Many64 => Tany64
  end.

Lemma type_of_Mptr: type_of_chunk Mptr = Tptr.

Definition chunk_of_type (ty: typ) :=
  match ty with
  | Tint => Mint32
  | Tfloat => Mfloat64
  | Tlong => Mint64
  | Tsingle => Mfloat32
  | Tany32 => Many32
  | Tany64 => Many64
  end.

Lemma chunk_of_Tptr: chunk_of_type Tptr = Mptr.

Inductive init_data: Type :=
  | Init_int8: int -> init_data
  | Init_int16: int -> init_data
  | Init_int32: int -> init_data
  | Init_int64: int64 -> init_data
  | Init_float32: float32 -> init_data
  | Init_float64: float -> init_data
  | Init_space: Z -> init_data
  | Init_addrof: ident -> ptrofs -> init_data.  

Definition init_data_size (i: init_data) : Z :=
  match i with
  | Init_int8 _ => 1
  | Init_int16 _ => 2
  | Init_int32 _ => 4
  | Init_int64 _ => 8
  | Init_float32 _ => 4
  | Init_float64 _ => 8
  | Init_addrof _ _ => if Archi.ptr64 then 8 else 4
  | Init_space n => Z.max n 0
  end.

Fixpoint init_data_list_size (il: list init_data) {struct il} : Z :=
  match il with
  | nil => 0
  | i :: il' => init_data_size i + init_data_list_size il'
  end.

Lemma init_data_size_pos:
  forall i, init_data_size i >= 0.

Lemma init_data_list_size_pos:
  forall il, init_data_list_size il >= 0.

Record globvar (V: Type) : Type := mkglobvar {
  gvar_info: V;                    
  gvar_init: list init_data;       
  gvar_readonly: bool;             
  gvar_volatile: bool              
}.

Inductive globdef (F V: Type) : Type :=
  | Gfun (f: F)
  | Gvar (v: globvar V).

Arguments Gfun [F V].
Arguments Gvar [F V].

Record program (F V: Type) : Type := mkprogram {
  prog_defs: list (ident * globdef F V);
  prog_public: list ident;
  prog_main: ident
}.

Definition prog_defs_names (F V: Type) (p: program F V) : list ident :=
  List.map fst p.(prog_defs).

Definition prog_defmap (F V: Type) (p: program F V) : PTree.t (globdef F V) :=
  PTree_Properties.of_list p.(prog_defs).

Section DEFMAP.

Variables F V: Type.
Variable p: program F V.

Lemma in_prog_defmap:
  forall id g, (prog_defmap p)!id = Some g -> In (id, g) (prog_defs p).

Lemma prog_defmap_dom:
  forall id, In id (prog_defs_names p) -> exists g, (prog_defmap p)!id = Some g.

Lemma prog_defmap_unique:
  forall defs1 id g defs2,
  prog_defs p = defs1 ++ (id, g) :: defs2 ->
  ~In id (map fst defs2) ->
  (prog_defmap p)!id = Some g.

Lemma prog_defmap_norepet:
  forall id g,
  list_norepet (prog_defs_names p) ->
  In (id, g) (prog_defs p) ->
  (prog_defmap p)!id = Some g.

End DEFMAP.

Section TRANSF_PROGRAM.

Variable A B V: Type.
Variable transf: A -> B.

Definition transform_program_globdef (idg: ident * globdef A V) : ident * globdef B V :=
  match idg with
  | (id, Gfun f) => (id, Gfun (transf f))
  | (id, Gvar v) => (id, Gvar v)
  end.

Definition transform_program (p: program A V) : program B V :=
  mkprogram
    (List.map transform_program_globdef p.(prog_defs))
    p.(prog_public)
    p.(prog_main).

End TRANSF_PROGRAM.

Local Open Scope error_monad_scope.

Section TRANSF_PROGRAM_GEN.

Variables A B V W: Type.
Variable transf_fun: ident -> A -> res B.
Variable transf_var: ident -> V -> res W.

Definition transf_globvar (i: ident) (g: globvar V) : res (globvar W) :=
  do info' <- transf_var i g.(gvar_info);
  OK (mkglobvar info' g.(gvar_init) g.(gvar_readonly) g.(gvar_volatile)).

Fixpoint transf_globdefs (l: list (ident * globdef A V)) : res (list (ident * globdef B W)) :=
  match l with
  | nil => OK nil
  | (id, Gfun f) :: l' =>
    match transf_fun id f with
      | Error msg => Error (MSG "In function " :: CTX id :: MSG ": " :: msg)
      | OK tf =>
        do tl' <- transf_globdefs l'; OK ((id, Gfun tf) :: tl')
    end
  | (id, Gvar v) :: l' =>
    match transf_globvar id v with
      | Error msg => Error (MSG "In variable " :: CTX id :: MSG ": " :: msg)
      | OK tv =>
        do tl' <- transf_globdefs l'; OK ((id, Gvar tv) :: tl')
    end
  end.

Definition transform_partial_program2 (p: program A V) : res (program B W) :=
  do gl' <- transf_globdefs p.(prog_defs);
  OK (mkprogram gl' p.(prog_public) p.(prog_main)).

End TRANSF_PROGRAM_GEN.

Section TRANSF_PARTIAL_PROGRAM.

Variable A B V: Type.
Variable transf_fun: A -> res B.

Definition transform_partial_program (p: program A V) : res (program B V) :=
  transform_partial_program2 (fun i f => transf_fun f) (fun i v => OK v) p.

End TRANSF_PARTIAL_PROGRAM.

Lemma transform_program_partial_program:
  forall (A B V: Type) (transf_fun: A -> B) (p: program A V),
  transform_partial_program (fun f => OK (transf_fun f)) p = OK (transform_program transf_fun p).

Inductive external_function : Type :=
  | EF_external (name: string) (sg: signature)
       | EF_builtin (name: string) (sg: signature)
       | EF_runtime (name: string) (sg: signature)
       | EF_vload (chunk: memory_chunk)
       | EF_vstore (chunk: memory_chunk)
       | EF_malloc
       | EF_free
       | EF_memcpy (sz: Z) (al: Z)
     
  | EF_annot (kind: positive) (text: string) (targs: list typ)
       | EF_annot_val (kind: positive) (text: string) (targ: typ)
       | EF_inline_asm (text: string) (sg: signature) (clobbers: list string)
       | EF_debug (kind: positive) (text: ident) (targs: list typ).
     Definition ef_sig (ef: external_function): signature :=
  match ef with
  | EF_external name sg => sg
  | EF_builtin name sg => sg
  | EF_runtime name sg => sg
  | EF_vload chunk => mksignature (Tptr :: nil) (Some (type_of_chunk chunk)) cc_default
  | EF_vstore chunk => mksignature (Tptr :: type_of_chunk chunk :: nil) None cc_default
  | EF_malloc => mksignature (Tptr :: nil) (Some Tptr) cc_default
  | EF_free => mksignature (Tptr :: nil) None cc_default
  | EF_memcpy sz al => mksignature (Tptr :: Tptr :: nil) None cc_default
  | EF_annot kind text targs => mksignature targs None cc_default
  | EF_annot_val kind text targ => mksignature (targ :: nil) (Some targ) cc_default
  | EF_inline_asm text sg clob => sg
  | EF_debug kind text targs => mksignature targs None cc_default
  end.

Definition ef_inline (ef: external_function) : bool :=
  match ef with
  | EF_external name sg => false
  | EF_builtin name sg => true
  | EF_runtime name sg => false
  | EF_vload chunk => true
  | EF_vstore chunk => true
  | EF_malloc => false
  | EF_free => false
  | EF_memcpy sz al => true
  | EF_annot kind text targs => true
  | EF_annot_val kind Text rg => true
  | EF_inline_asm text sg clob => true
  | EF_debug kind text targs => true
  end.

Definition ef_reloads (ef: external_function) : bool :=
  match ef with
  | EF_annot kind text targs => false
  | EF_debug kind text targs => false
  | _ => true
  end.

Definition external_function_eq: forall (ef1 ef2: external_function), {ef1=ef2} + {ef1<>ef2}.
Global Opaque external_function_eq.

Inductive fundef (F: Type): Type :=
  | Internal: F -> fundef F
  | External: external_function -> fundef F.

Arguments External [F].

Section TRANSF_FUNDEF.

Variable A B: Type.
Variable transf: A -> B.

Definition transf_fundef (fd: fundef A): fundef B :=
  match fd with
  | Internal f => Internal (transf f)
  | External ef => External ef
  end.

End TRANSF_FUNDEF.

Section TRANSF_PARTIAL_FUNDEF.

Variable A B: Type.
Variable transf_partial: A -> res B.

Definition transf_partial_fundef (fd: fundef A): res (fundef B) :=
  match fd with
  | Internal f => do f' <- transf_partial f; OK (Internal f')
  | External ef => OK (External ef)
  end.

End TRANSF_PARTIAL_FUNDEF.

Set Contextual Implicit.

Inductive rpair (A: Type) : Type :=
  | One (r: A)
  | Twolong (rhi rlo: A).

Definition typ_rpair (A: Type) (typ_of: A -> typ) (p: rpair A): typ :=
  match p with
  | One r => typ_of r
  | Twolong rhi rlo => Tlong
  end.

Definition map_rpair (A B: Type) (f: A -> B) (p: rpair A): rpair B :=
  match p with
  | One r => One (f r)
  | Twolong rhi rlo => Twolong (f rhi) (f rlo)
  end.

Definition regs_of_rpair (A: Type) (p: rpair A): list A :=
  match p with
  | One r => r :: nil
  | Twolong rhi rlo => rhi :: rlo :: nil
  end.

Fixpoint regs_of_rpairs (A: Type) (l: list (rpair A)): list A :=
  match l with
  | nil => nil
  | p :: l => regs_of_rpair p ++ regs_of_rpairs l
  end.

Lemma in_regs_of_rpairs:
  forall (A: Type) (x: A) p, In x (regs_of_rpair p) -> forall l, In p l -> In x (regs_of_rpairs l).

Lemma in_regs_of_rpairs_inv:
  forall (A: Type) (x: A) l, In x (regs_of_rpairs l) -> exists p, In p l /\ In x (regs_of_rpair p).

Definition forall_rpair (A: Type) (P: A -> Prop) (p: rpair A): Prop :=
  match p with
  | One r => P r
  | Twolong rhi rlo => P rhi /\ P rlo
  end.

Inductive builtin_arg (A: Type) : Type :=
  | BA (x: A)
  | BA_int (n: int)
  | BA_long (n: int64)
  | BA_float (f: float)
  | BA_single (f: float32)
  | BA_loadstack (chunk: memory_chunk) (ofs: ptrofs)
  | BA_addrstack (ofs: ptrofs)
  | BA_loadglobal (chunk: memory_chunk) (id: ident) (ofs: ptrofs)
  | BA_addrglobal (id: ident) (ofs: ptrofs)
  | BA_splitlong (hi lo: builtin_arg A)
  | BA_addptr (a1 a2: builtin_arg A).

Inductive builtin_res (A: Type) : Type :=
  | BR (x: A)
  | BR_none
  | BR_splitlong (hi lo: builtin_res A).

Fixpoint globals_of_builtin_arg (A: Type) (a: builtin_arg A) : list ident :=
  match a with
  | BA_loadglobal chunk id ofs => id :: nil
  | BA_addrglobal id ofs => id :: nil
  | BA_splitlong hi lo => globals_of_builtin_arg hi ++ globals_of_builtin_arg lo
  | BA_addptr a1 a2 => globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2
  | _ => nil
  end.

Definition globals_of_builtin_args (A: Type) (al: list (builtin_arg A)) : list ident :=
  List.fold_right (fun a l => globals_of_builtin_arg a ++ l) nil al.

Fixpoint params_of_builtin_arg (A: Type) (a: builtin_arg A) : list A :=
  match a with
  | BA x => x :: nil
  | BA_splitlong hi lo => params_of_builtin_arg hi ++ params_of_builtin_arg lo
  | BA_addptr a1 a2 => params_of_builtin_arg a1 ++ params_of_builtin_arg a2
  | _ => nil
  end.

Definition params_of_builtin_args (A: Type) (al: list (builtin_arg A)) : list A :=
  List.fold_right (fun a l => params_of_builtin_arg a ++ l) nil al.

Fixpoint params_of_builtin_res (A: Type) (a: builtin_res A) : list A :=
  match a with
  | BR x => x :: nil
  | BR_none => nil
  | BR_splitlong hi lo => params_of_builtin_res hi ++ params_of_builtin_res lo
  end.

Fixpoint map_builtin_arg (A B: Type) (f: A -> B) (a: builtin_arg A) : builtin_arg B :=
  match a with
  | BA x => BA (f x)
  | BA_int n => BA_int n
  | BA_long n => BA_long n
  | BA_float n => BA_float n
  | BA_single n => BA_single n
  | BA_loadstack chunk ofs => BA_loadstack chunk ofs
  | BA_addrstack ofs => BA_addrstack ofs
  | BA_loadglobal chunk id ofs => BA_loadglobal chunk id ofs
  | BA_addrglobal id ofs => BA_addrglobal id ofs
  | BA_splitlong hi lo =>
      BA_splitlong (map_builtin_arg f hi) (map_builtin_arg f lo)
  | BA_addptr a1 a2 =>
      BA_addptr (map_builtin_arg f a1) (map_builtin_arg f a2)
  end.

Fixpoint map_builtin_res (A B: Type) (f: A -> B) (a: builtin_res A) : builtin_res B :=
  match a with
  | BR x => BR (f x)
  | BR_none => BR_none
  | BR_splitlong hi lo =>
      BR_splitlong (map_builtin_res f hi) (map_builtin_res f lo)
  end.

Inductive builtin_arg_constraint : Type :=
  | OK_default
  | OK_const
  | OK_addrstack
  | OK_addressing
  | OK_all. *)

Require Import compcert.common.Globalenvs.
(* compcert.common.Globalenvs:
Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module Senv.

Record t: Type := mksenv {
  
  find_symbol: ident -> option block;
  public_symbol: ident -> bool;
  invert_symbol: block -> option ident;
  block_is_volatile: block -> bool;
  nextblock: block;
  
  find_symbol_injective:
    forall id1 id2 b, find_symbol id1 = Some b -> find_symbol id2 = Some b -> id1 = id2;
  invert_find_symbol:
    forall id b, invert_symbol b = Some id -> find_symbol id = Some b;
  find_invert_symbol:
    forall id b, find_symbol id = Some b -> invert_symbol b = Some id;
  public_symbol_exists:
    forall id, public_symbol id = true -> exists b, find_symbol id = Some b;
  find_symbol_below:
    forall id b, find_symbol id = Some b -> Plt b nextblock;
  block_is_volatile_below:
    forall b, block_is_volatile b = true -> Plt b nextblock
}.

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Definition equiv (se1 se2: t) : Prop :=
     (forall id, find_symbol se2 id = find_symbol se1 id)
  /\ (forall id, public_symbol se2 id = public_symbol se1 id)
  /\ (forall b, block_is_volatile se2 b = block_is_volatile se1 b).

End Senv.

Module Genv.

Section GENV.

Variable F: Type.  
Variable V: Type.  

Record t: Type := mkgenv {
  genv_public: list ident;              
  genv_symb: PTree.t block;             
  genv_defs: PTree.t (globdef F V);     
  genv_next: block;                     
  genv_symb_range: forall id b, PTree.get id genv_symb = Some b -> Plt b genv_next;
  genv_defs_range: forall b g, PTree.get b genv_defs = Some g -> Plt b genv_next;
  genv_vars_inj: forall id1 id2 b,
    PTree.get id1 genv_symb = Some b -> PTree.get id2 genv_symb = Some b -> id1 = id2
}.

Definition find_symbol (ge: t) (id: ident) : option block :=
  PTree.get id ge.(genv_symb).

Definition symbol_address (ge: t) (id: ident) (ofs: ptrofs) : val :=
  match find_symbol ge id with
  | Some b => Vptr b ofs
  | None => Vundef
  end.

Definition public_symbol (ge: t) (id: ident) : bool :=
  match find_symbol ge id with
  | None => false
  | Some _ => In_dec ident_eq id ge.(genv_public)
  end.

Definition find_def (ge: t) (b: block) : option (globdef F V) :=
  PTree.get b ge.(genv_defs).

Definition find_funct_ptr (ge: t) (b: block) : option F :=
  match find_def ge b with Some (Gfun f) => Some f | _ => None end.

Definition find_funct (ge: t) (v: val) : option F :=
  match v with
  | Vptr b ofs => if Ptrofs.eq_dec ofs Ptrofs.zero then find_funct_ptr ge b else None
  | _ => None
  end.

Definition invert_symbol (ge: t) (b: block) : option ident :=
  PTree.fold
    (fun res id b' => if eq_block b b' then Some id else res)
    ge.(genv_symb) None.

Definition find_var_info (ge: t) (b: block) : option (globvar V) :=
  match find_def ge b with Some (Gvar v) => Some v | _ => None end.

Definition block_is_volatile (ge: t) (b: block) : bool :=
  match find_var_info ge b with
  | None => false
  | Some gv => gv.(gvar_volatile)
  end.

Program Definition add_global (ge: t) (idg: ident * globdef F V) : t :=
  @mkgenv
    ge.(genv_public)

Definition add_globals (ge: t) (gl: list (ident * globdef F V)) : t :=
  List.fold_left add_global gl ge.

Lemma add_globals_app:
  forall gl2 gl1 ge,
  add_globals ge (gl1 ++ gl2) = add_globals (add_globals ge gl1) gl2.

Program Definition empty_genv (pub: list ident): t :=
  @mkgenv pub (PTree.empty _) (PTree.empty _) 1%positive _ _ _.

Definition globalenv (p: program F V) :=
  add_globals (empty_genv p.(prog_public)) p.(prog_defs).

Section GLOBALENV_PRINCIPLES.

Variable P: t -> Prop.

Lemma add_globals_preserves:
  forall gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  P ge -> P (add_globals ge gl).

Lemma add_globals_ensures:
  forall id g gl ge,
  (forall ge id g, P ge -> In (id, g) gl -> P (add_global ge (id, g))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> P (add_globals ge gl).

Lemma add_globals_unique_preserves:
  forall id gl ge,
  (forall ge id1 g, P ge -> In (id1, g) gl -> id1 <> id -> P (add_global ge (id1, g))) ->
  ~In id (map fst gl) -> P ge -> P (add_globals ge gl).

Lemma add_globals_unique_ensures:
  forall gl1 id g gl2 ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl2 -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  ~In id (map fst gl2) -> P (add_globals ge (gl1 ++ (id, g) :: gl2)).

Remark in_norepet_unique:
  forall id g (gl: list (ident * globdef F V)),
  In (id, g) gl -> list_norepet (map fst gl) ->
  exists gl1 gl2, gl = gl1 ++ (id, g) :: gl2 /\ ~In id (map fst gl2).

Lemma add_globals_norepet_ensures:
  forall id g gl ge,
  (forall ge id1 g1, P ge -> In (id1, g1) gl -> id1 <> id -> P (add_global ge (id1, g1))) ->
  (forall ge, P (add_global ge (id, g))) ->
  In (id, g) gl -> list_norepet (map fst gl) -> P (add_globals ge gl).

End GLOBALENV_PRINCIPLES.

Theorem public_symbol_exists:
  forall ge id, public_symbol ge id = true -> exists b, find_symbol ge id = Some b.

Theorem shift_symbol_address:
  forall ge id ofs delta,
  symbol_address ge id (Ptrofs.add ofs delta) = Val.offset_ptr (symbol_address ge id ofs) delta.

Theorem shift_symbol_address_32:
  forall ge id ofs n,
  Archi.ptr64 = false ->

Theorem shift_symbol_address_64:
  forall ge id ofs n,
  Archi.ptr64 = true ->

Theorem find_funct_inv:
  forall ge v f,
  find_funct ge v = Some f -> exists b, v = Vptr b Ptrofs.zero.

Theorem find_funct_find_funct_ptr:
  forall ge b,
  find_funct ge (Vptr b Ptrofs.zero) = find_funct_ptr ge b.

Theorem find_funct_ptr_iff:
  forall ge b f, find_funct_ptr ge b = Some f <-> find_def ge b = Some (Gfun f).

Theorem find_var_info_iff:
  forall ge b v, find_var_info ge b = Some v <-> find_def ge b = Some (Gvar v).

Theorem find_def_symbol:
  forall p id g,
  (prog_defmap p)!id = Some g <-> exists b, find_symbol (globalenv p) id = Some b /\ find_def (globalenv p) b = Some g.

Theorem find_symbol_exists:
  forall p id g,
  In (id, g) (prog_defs p) ->
  exists b, find_symbol (globalenv p) id = Some b.

Theorem find_symbol_inversion : forall p x b,
  find_symbol (globalenv p) x = Some b ->
  In x (prog_defs_names p).

Theorem find_def_inversion:
  forall p b g,
  find_def (globalenv p) b = Some g ->
  exists id, In (id, g) (prog_defs p).

Corollary find_funct_ptr_inversion:
  forall p b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Corollary find_funct_inversion:
  forall p v f,
  find_funct (globalenv p) v = Some f ->
  exists id, In (id, Gfun f) (prog_defs p).

Theorem find_funct_ptr_prop:
  forall (P: F -> Prop) p b f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct_ptr (globalenv p) b = Some f ->
  P f.

Theorem find_funct_prop:
  forall (P: F -> Prop) p v f,
  (forall id f, In (id, Gfun f) (prog_defs p) -> P f) ->
  find_funct (globalenv p) v = Some f ->
  P f.

Theorem global_addresses_distinct:
  forall ge id1 id2 b1 b2,
  id1 <> id2 ->
  find_symbol ge id1 = Some b1 ->
  find_symbol ge id2 = Some b2 ->
  b1 <> b2.

Theorem invert_find_symbol:
  forall ge id b,
  invert_symbol ge b = Some id -> find_symbol ge id = Some b.

Theorem find_invert_symbol:
  forall ge id b,
  find_symbol ge id = Some b -> invert_symbol ge b = Some id.

Definition advance_next (gl: list (ident * globdef F V)) (x: positive) :=
  List.fold_left (fun n g => Pos.succ n) gl x.

Remark genv_next_add_globals:
  forall gl ge,
  genv_next (add_globals ge gl) = advance_next gl (genv_next ge).

Remark genv_public_add_globals:
  forall gl ge,
  genv_public (add_globals ge gl) = genv_public ge.

Theorem globalenv_public:
  forall p, genv_public (globalenv p) = prog_public p.

Theorem block_is_volatile_below:
  forall ge b, block_is_volatile ge b = true ->  Plt b ge.(genv_next).

Definition to_senv (ge: t) : Senv.t :=
 @Senv.mksenv
    (find_symbol ge)
    (public_symbol ge)
    (invert_symbol ge)
    (block_is_volatile ge)
    ge.(genv_next)
    ge.(genv_vars_inj)
    (invert_find_symbol ge)
    (find_invert_symbol ge)
    (public_symbol_exists ge)
    ge.(genv_symb_range)
    (block_is_volatile_below ge).

Section INITMEM.

Variable ge: t.

Definition store_init_data (m: mem) (b: block) (p: Z) (id: init_data) : option mem :=
  match id with
  | Init_int8 n => Mem.store Mint8unsigned m b p (Vint n)
  | Init_int16 n => Mem.store Mint16unsigned m b p (Vint n)
  | Init_int32 n => Mem.store Mint32 m b p (Vint n)
  | Init_int64 n => Mem.store Mint64 m b p (Vlong n)
  | Init_float32 n => Mem.store Mfloat32 m b p (Vsingle n)
  | Init_float64 n => Mem.store Mfloat64 m b p (Vfloat n)
  | Init_addrof symb ofs =>
      match find_symbol ge symb with
      | None => None
      | Some b' => Mem.store Mptr m b p (Vptr b' ofs)
      end
  | Init_space n => Some m
  end.

Fixpoint store_init_data_list (m: mem) (b: block) (p: Z) (idl: list init_data)
                              {struct idl}: option mem :=
  match idl with
  | nil => Some m
  | id :: idl' =>
      match store_init_data m b p id with
      | None => None
      | Some m' => store_init_data_list m' b (p + init_data_size id) idl'
      end
  end.

Definition perm_globvar (gv: globvar V) : permission :=
  if gv.(gvar_volatile) then Nonempty
  else if gv.(gvar_readonly) then Readable
  else Writable.

Definition alloc_global (m: mem) (idg: ident * globdef F V): option mem :=
  match idg with
  | (id, Gfun f) =>
      let (m1, b) := Mem.alloc m 0 1 in
      Mem.drop_perm m1 b 0 1 Nonempty
  | (id, Gvar v) =>
      let init := v.(gvar_init) in
      let sz := init_data_list_size init in
      let (m1, b) := Mem.alloc m 0 sz in
      match store_zeros m1 b 0 sz with
      | None => None
      | Some m2 =>
          match store_init_data_list m2 b 0 init with
          | None => None
          | Some m3 => Mem.drop_perm m3 b 0 sz (perm_globvar v)
          end
      end
  end.

Fixpoint alloc_globals (m: mem) (gl: list (ident * globdef F V))
                       {struct gl} : option mem :=
  match gl with
  | nil => Some m
  | g :: gl' =>
      match alloc_global m g with
      | None => None
      | Some m' => alloc_globals m' gl'
      end
  end.

Lemma alloc_globals_app : forall gl1 gl2 m m1,
  alloc_globals m gl1 = Some m1 ->
  alloc_globals m1 gl2 = alloc_globals m (gl1 ++ gl2).

Remark store_zeros_nextblock:
  forall m b p n m', store_zeros m b p n = Some m' -> Mem.nextblock m' = Mem.nextblock m.

Remark store_init_data_list_nextblock:
  forall idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  Mem.nextblock m' = Mem.nextblock m.

Remark alloc_global_nextblock:
  forall g m m',
  alloc_global m g = Some m' ->
  Mem.nextblock m' = Pos.succ(Mem.nextblock m).

Remark alloc_globals_nextblock:
  forall gl m m',
  alloc_globals m gl = Some m' ->
  Mem.nextblock m' = advance_next gl (Mem.nextblock m).

Remark store_zeros_perm:
  forall k prm b' q m b p n m',
  store_zeros m b p n = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_perm:
  forall k prm b' q i b m p m',
  store_init_data m b p i = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark store_init_data_list_perm:
  forall k prm b' q idl b m p m',
  store_init_data_list m b p idl = Some m' ->
  (Mem.perm m b' q k prm <-> Mem.perm m' b' q k prm).

Remark alloc_global_perm:
  forall k prm b' q idg m m',
  alloc_global m idg = Some m' ->
  Mem.valid_block m b' ->

Remark alloc_globals_perm:
  forall k prm b' q gl m m',
  alloc_globals m gl = Some m' ->
  Mem.valid_block m b' ->

Remark store_zeros_unchanged:
  forall (P: block -> Z -> Prop) m b p n m',
  store_zeros m b p n = Some m' ->
  (forall i, p <= i < p + n -> ~ P b i) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_unchanged:
  forall (P: block -> Z -> Prop) b i m p m',
  store_init_data m b p i = Some m' ->
  (forall ofs, p <= ofs < p + init_data_size i -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Remark store_init_data_list_unchanged:
  forall (P: block -> Z -> Prop) b il m p m',
  store_init_data_list m b p il = Some m' ->
  (forall ofs, p <= ofs -> ~ P b ofs) ->
  Mem.unchanged_on P m m'.

Definition readbytes_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall p n,
  ofs <= p -> p + Z.of_nat n <= ofs + len ->
  Mem.loadbytes m b p (Z.of_nat n) = Some (list_repeat n (Byte Byte.zero)).

Lemma store_zeros_loadbytes:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  readbytes_as_zero m' b p n.

Definition bytes_of_init_data (i: init_data): list memval :=
  match i with
  | Init_int8 n => inj_bytes (encode_int 1%nat (Int.unsigned n))
  | Init_int16 n => inj_bytes (encode_int 2%nat (Int.unsigned n))
  | Init_int32 n => inj_bytes (encode_int 4%nat (Int.unsigned n))
  | Init_int64 n => inj_bytes (encode_int 8%nat (Int64.unsigned n))
  | Init_float32 n => inj_bytes (encode_int 4%nat (Int.unsigned (Float32.to_bits n)))
  | Init_float64 n => inj_bytes (encode_int 8%nat (Int64.unsigned (Float.to_bits n)))
  | Init_space n => list_repeat (Z.to_nat n) (Byte Byte.zero)
  | Init_addrof id ofs =>
      match find_symbol ge id with
      | Some b => inj_value (if Archi.ptr64 then Q64 else Q32) (Vptr b ofs)
      | None   => list_repeat (if Archi.ptr64 then 8%nat else 4%nat) Undef
      end
  end.

Remark init_data_size_addrof:
  forall id ofs, init_data_size (Init_addrof id ofs) = size_chunk Mptr.

Lemma store_init_data_loadbytes:
  forall m b p i m',
  store_init_data m b p i = Some m' ->
  readbytes_as_zero m b p (init_data_size i) ->
  Mem.loadbytes m' b p (init_data_size i) = Some (bytes_of_init_data i).

Fixpoint bytes_of_init_data_list (il: list init_data): list memval :=
  match il with
  | nil => nil
  | i :: il => bytes_of_init_data i ++ bytes_of_init_data_list il
  end.

Lemma store_init_data_list_loadbytes:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  readbytes_as_zero m b p (init_data_list_size il) ->
  Mem.loadbytes m' b p (init_data_list_size il) = Some (bytes_of_init_data_list il).

Definition read_as_zero (m: mem) (b: block) (ofs len: Z) : Prop :=
  forall chunk p,
  ofs <= p -> p + size_chunk chunk <= ofs + len ->
  (align_chunk chunk | p) ->
  Mem.load chunk m b p =
  Some (match chunk with
        | Mint8unsigned | Mint8signed | Mint16unsigned | Mint16signed | Mint32 => Vint Int.zero
        | Mint64 => Vlong Int64.zero
        | Mfloat32 => Vsingle Float32.zero
        | Mfloat64 => Vfloat Float.zero
        | Many32 | Many64 => Vundef
        end).

Remark read_as_zero_unchanged:
  forall (P: block -> Z -> Prop) m b ofs len m',
  read_as_zero m b ofs len ->
  Mem.unchanged_on P m m' ->

Lemma store_zeros_read_as_zero:
  forall m b p n m',
  store_zeros m b p n = Some m' ->
  read_as_zero m' b p n.

Fixpoint load_store_init_data (m: mem) (b: block) (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | Init_int8 n :: il' =>
      Mem.load Mint8unsigned m b p = Some(Vint(Int.zero_ext 8 n))
      /\ load_store_init_data m b (p + 1) il'
  | Init_int16 n :: il' =>
      Mem.load Mint16unsigned m b p = Some(Vint(Int.zero_ext 16 n))
      /\ load_store_init_data m b (p + 2) il'
  | Init_int32 n :: il' =>
      Mem.load Mint32 m b p = Some(Vint n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_int64 n :: il' =>
      Mem.load Mint64 m b p = Some(Vlong n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_float32 n :: il' =>
      Mem.load Mfloat32 m b p = Some(Vsingle n)
      /\ load_store_init_data m b (p + 4) il'
  | Init_float64 n :: il' =>
      Mem.load Mfloat64 m b p = Some(Vfloat n)
      /\ load_store_init_data m b (p + 8) il'
  | Init_addrof symb ofs :: il' =>
      (exists b', find_symbol ge symb = Some b' /\ Mem.load Mptr m b p = Some(Vptr b' ofs))
      /\ load_store_init_data m b (p + size_chunk Mptr) il'
  | Init_space n :: il' =>
      read_as_zero m b p n
      /\ load_store_init_data m b (p + Z.max n 0) il'
  end.

Lemma store_init_data_list_charact:
  forall b il m p m',
  store_init_data_list m b p il = Some m' ->
  read_as_zero m b p (init_data_list_size il) ->
  load_store_init_data m' b p il.

Remark alloc_global_unchanged:
  forall (P: block -> Z -> Prop) m id g m',
  alloc_global m (id, g) = Some m' ->
  Mem.unchanged_on P m m'.

Remark alloc_globals_unchanged:
  forall (P: block -> Z -> Prop) gl m m',
  alloc_globals m gl = Some m' ->
  Mem.unchanged_on P m m'.

Remark load_store_init_data_invariant:
  forall m m' b,
  (forall chunk ofs, Mem.load chunk m' b ofs = Mem.load chunk m b ofs) ->

Definition globals_initialized (g: t) (m: mem) :=
  forall b gd,
  find_def g b = Some gd ->
  match gd with
  | Gfun f =>
         Mem.perm m b 0 Cur Nonempty
      /\ (forall ofs k p, Mem.perm m b ofs k p -> ofs = 0 /\ p = Nonempty)
  | Gvar v =>
         Mem.range_perm m b 0 (init_data_list_size v.(gvar_init)) Cur (perm_globvar v)
      /\ (forall ofs k p, Mem.perm m b ofs k p ->
            0 <= ofs < init_data_list_size v.(gvar_init) /\ perm_order (perm_globvar v) p)
      /\ (v.(gvar_volatile) = false -> load_store_init_data m b 0 v.(gvar_init))
      /\ (v.(gvar_volatile) = false -> Mem.loadbytes m b 0 (init_data_list_size v.(gvar_init)) = Some (bytes_of_init_data_list v.(gvar_init)))
  end.

Lemma alloc_global_initialized:
  forall g m id gd m',
  genv_next g = Mem.nextblock m ->

Lemma alloc_globals_initialized:
  forall gl ge m m',
  alloc_globals m gl = Some m' ->
  genv_next ge = Mem.nextblock m ->

End INITMEM.

Definition init_mem (p: program F V) :=
  alloc_globals (globalenv p) Mem.empty p.(prog_defs).

Lemma init_mem_genv_next: forall p m,
  init_mem p = Some m ->
  genv_next (globalenv p) = Mem.nextblock m.

Theorem find_symbol_not_fresh:
  forall p id b m,
  init_mem p = Some m ->
  find_symbol (globalenv p) id = Some b -> Mem.valid_block m b.

Theorem find_def_not_fresh:
  forall p b g m,
  init_mem p = Some m ->
  find_def (globalenv p) b = Some g -> Mem.valid_block m b.

Theorem find_funct_ptr_not_fresh:
  forall p b f m,
  init_mem p = Some m ->
  find_funct_ptr (globalenv p) b = Some f -> Mem.valid_block m b.

Theorem find_var_info_not_fresh:
  forall p b gv m,
  init_mem p = Some m ->
  find_var_info (globalenv p) b = Some gv -> Mem.valid_block m b.

Lemma init_mem_characterization_gen:
  forall p m,
  init_mem p = Some m ->
  globals_initialized (globalenv p) (globalenv p) m.

Theorem init_mem_characterization:
  forall p b gv m,
  find_var_info (globalenv p) b = Some gv ->
  init_mem p = Some m ->
  Mem.range_perm m b 0 (init_data_list_size gv.(gvar_init)) Cur (perm_globvar gv)

Theorem init_mem_characterization_2:
  forall p b fd m,
  find_funct_ptr (globalenv p) b = Some fd ->
  init_mem p = Some m ->
  Mem.perm m b 0 Cur Nonempty

Section INITMEM_INJ.

Variable ge: t.
Variable thr: block.
Hypothesis symb_inject: forall id b, find_symbol ge id = Some b -> Plt b thr.

Lemma store_zeros_neutral:
  forall m b p n m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_neutral:
  forall m b p id m',
  Mem.inject_neutral thr m ->

Lemma store_init_data_list_neutral:
  forall b idl m p m',
  Mem.inject_neutral thr m ->

Lemma alloc_global_neutral:
  forall idg m m',
  alloc_global ge m idg = Some m' ->
  Mem.inject_neutral thr m ->

Remark advance_next_le: forall gl x, Ple x (advance_next gl x).

Lemma alloc_globals_neutral:
  forall gl m m',
  alloc_globals ge m gl = Some m' ->
  Mem.inject_neutral thr m ->

End INITMEM_INJ.

Theorem initmem_inject:
  forall p m,
  init_mem p = Some m ->
  Mem.inject (Mem.flat_inj (Mem.nextblock m)) m m.

Definition init_data_alignment (i: init_data) : Z :=
  match i with
  | Init_int8 n => 1
  | Init_int16 n => 2
  | Init_int32 n => 4
  | Init_int64 n => 8
  | Init_float32 n => 4
  | Init_float64 n => 4
  | Init_addrof symb ofs => if Archi.ptr64 then 8 else 4
  | Init_space n => 1
  end.

Fixpoint init_data_list_aligned (p: Z) (il: list init_data) {struct il} : Prop :=
  match il with
  | nil => True
  | i1 :: il => (init_data_alignment i1 | p) /\ init_data_list_aligned (p + init_data_size i1) il
  end.

Section INITMEM_INVERSION.

Variable ge: t.

Lemma store_init_data_aligned:
  forall m b p i m',
  store_init_data ge m b p i = Some m' ->
  (init_data_alignment i | p).

Lemma store_init_data_list_aligned:
  forall b il m p m',
  store_init_data_list ge m b p il = Some m' ->
  init_data_list_aligned p il.

Lemma store_init_data_list_free_idents:
  forall b i o il m p m',
  store_init_data_list ge m b p il = Some m' ->
  In (Init_addrof i o) il ->
  exists b', find_symbol ge i = Some b'.

End INITMEM_INVERSION.

Theorem init_mem_inversion:
  forall p m id v,
  init_mem p = Some m ->
  In (id, Gvar v) p.(prog_defs) ->

Section INITMEM_EXISTS.

Variable ge: t.

Lemma store_zeros_exists:
  forall m b p n,
  Mem.range_perm m b p (p + n) Cur Writable ->

Lemma store_init_data_exists:
  forall m b p i,
  Mem.range_perm m b p (p + init_data_size i) Cur Writable ->

Lemma store_init_data_list_exists:
  forall b il m p,
  Mem.range_perm m b p (p + init_data_list_size il) Cur Writable ->

Lemma alloc_global_exists:
  forall m idg,
  match idg with
  | (id, Gfun f) => True
  | (id, Gvar v) =>
        init_data_list_aligned 0 v.(gvar_init)

End INITMEM_EXISTS.

Theorem init_mem_exists:
  forall p,
  (forall id v, In (id, Gvar v) (prog_defs p) ->
        init_data_list_aligned 0 v.(gvar_init)

End GENV.

Section MATCH_GENVS.

Context {A B V W: Type} (R: globdef A V -> globdef B W -> Prop).

Record match_genvs (ge1: t A V) (ge2: t B W): Prop := {
  mge_next:
    genv_next ge2 = genv_next ge1;
  mge_symb:
    forall id, PTree.get id (genv_symb ge2) = PTree.get id (genv_symb ge1);
  mge_defs:
    forall b, option_rel R (PTree.get b (genv_defs ge1)) (PTree.get b (genv_defs ge2))
}.

Lemma add_global_match:
  forall ge1 ge2 id g1 g2,
  match_genvs ge1 ge2 ->
  R g1 g2 ->
  match_genvs (add_global ge1 (id, g1)) (add_global ge2 (id, g2)).

Lemma add_globals_match:
  forall gl1 gl2,
  list_forall2 (fun idg1 idg2 => fst idg1 = fst idg2 /\ R (snd idg1) (snd idg2)) gl1 gl2 ->
  forall ge1 ge2, match_genvs ge1 ge2 ->
  match_genvs (add_globals ge1 gl1) (add_globals ge2 gl2).

End MATCH_GENVS.

Section MATCH_PROGRAMS.

Context {C F1 V1 F2 V2: Type} {LC: Linker C} {LF: Linker F1} {LV: Linker V1}.
Variable match_fundef: C -> F1 -> F2 -> Prop.
Variable match_varinfo: V1 -> V2 -> Prop.
Variable ctx: C.
Variable p: program F1 V1.
Variable tp: program F2 V2.
Hypothesis progmatch: match_program_gen match_fundef match_varinfo ctx p tp.

Lemma globalenvs_match:
  match_genvs (match_globdef match_fundef match_varinfo ctx) (globalenv p) (globalenv tp).

Theorem find_def_match_2:
  forall b, option_rel (match_globdef match_fundef match_varinfo ctx)
                       (find_def (globalenv p) b) (find_def (globalenv tp) b).
Proof (mge_defs globalenvs_match).

Theorem find_def_match:
  forall b g,
  find_def (globalenv p) b = Some g ->
  exists tg,
  find_def (globalenv tp) b = Some tg /\ match_globdef match_fundef match_varinfo ctx g tg.

Theorem find_funct_ptr_match:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists cunit tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_funct_match:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists cunit tf,
  find_funct (globalenv tp) v = Some tf /\ match_fundef cunit f tf /\ linkorder cunit ctx.

Theorem find_var_info_match:
  forall b v,
  find_var_info (globalenv p) b = Some v ->
  exists tv,
  find_var_info (globalenv tp) b = Some tv /\ match_globvar match_varinfo v tv.

Theorem find_symbol_match:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_match:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Lemma store_init_data_list_match:
  forall idl m b ofs m',
  store_init_data_list (globalenv p) m b ofs idl = Some m' ->
  store_init_data_list (globalenv tp) m b ofs idl = Some m'.

Lemma alloc_globals_match:
  forall gl1 gl2, list_forall2 (match_ident_globdef match_fundef match_varinfo ctx) gl1 gl2 ->
  forall m m',
  alloc_globals (globalenv p) m gl1 = Some m' ->
  alloc_globals (globalenv tp) m gl2 = Some m'.

Theorem init_mem_match:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End MATCH_PROGRAMS.

Section TRANSFORM_PARTIAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> res B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => transf f = OK tf) eq p tp.

Theorem find_funct_ptr_transf_partial:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  exists tf,
  find_funct_ptr (globalenv tp) b = Some tf /\ transf f = OK tf.

Theorem find_funct_transf_partial:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  exists tf,
  find_funct (globalenv tp) v = Some tf /\ transf f = OK tf.

Theorem find_symbol_transf_partial:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf_partial:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf_partial:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_PARTIAL.

Section TRANSFORM_TOTAL.

Context {A B V: Type} {LA: Linker A} {LV: Linker V}.
Context {transf: A -> B} {p: program A V} {tp: program B V}.
Hypothesis progmatch: match_program (fun cu f tf => tf = transf f) eq p tp.

Theorem find_funct_ptr_transf:
  forall b f,
  find_funct_ptr (globalenv p) b = Some f ->
  find_funct_ptr (globalenv tp) b = Some (transf f).

Theorem find_funct_transf:
  forall v f,
  find_funct (globalenv p) v = Some f ->
  find_funct (globalenv tp) v = Some (transf f).

Theorem find_symbol_transf:
  forall (s : ident),
  find_symbol (globalenv tp) s = find_symbol (globalenv p) s.

Theorem senv_transf:
  Senv.equiv (to_senv (globalenv p)) (to_senv (globalenv tp)).

Theorem init_mem_transf:
  forall m, init_mem p = Some m -> init_mem tp = Some m.

End TRANSFORM_TOTAL.

End Genv.

Coercion Genv.to_senv: Genv.t >-> Senv.t. *)

Require Import compcert.common.Memory.
(* compcert.common.Memory:
Require Import Zwf.
Require Import Axioms.
Require Import Coqlib.
Require Intv.
Require Import Maps.
Require Archi.
Require Import AST.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Export Memdata.
Require Export Memtype.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Local Notation "a # b" := (PMap.get b a) (at level 1).

Module Mem <: MEM.

Definition perm_order' (po: option permission) (p: permission) :=
  match po with
  | Some p' => perm_order p' p
  | None => False
 end.

Definition perm_order'' (po1 po2: option permission) :=
  match po1, po2 with
  | Some p1, Some p2 => perm_order p1 p2
  | _, None => True
  | None, Some _ => False
 end.

Record mem' : Type := mkmem {
  mem_contents: PMap.t (ZMap.t memval);  
  mem_access: PMap.t (Z -> perm_kind -> option permission);
                                         
  nextblock: block;
  access_max:
    forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
  nextblock_noaccess:
    forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
  contents_default:
    forall b, fst mem_contents#b = Undef
}.

Definition mem := mem'.

Lemma mkmem_ext:
 forall cont1 cont2 acc1 acc2 next1 next2 a1 a2 b1 b2 c1 c2,
  cont1=cont2 -> acc1=acc2 -> next1=next2 ->
  mkmem cont1 acc1 next1 a1 b1 c1 = mkmem cont2 acc2 next2 a2 b2 c2.

Definition valid_block (m: mem) (b: block) := Plt b (nextblock m).

Theorem valid_not_valid_diff:
  forall m b b', valid_block m b -> ~(valid_block m b') -> b <> b'.

Local Hint Resolve valid_not_valid_diff: mem.

Definition perm (m: mem) (b: block) (ofs: Z) (k: perm_kind) (p: permission) : Prop :=
   perm_order' (m.(mem_access)#b ofs k) p.

Theorem perm_implies:
  forall m b ofs k p1 p2, perm m b ofs k p1 -> perm_order p1 p2 -> perm m b ofs k p2.

Local Hint Resolve perm_implies: mem.

Theorem perm_cur_max:
  forall m b ofs p, perm m b ofs Cur p -> perm m b ofs Max p.

Theorem perm_cur:
  forall m b ofs k p, perm m b ofs Cur p -> perm m b ofs k p.

Theorem perm_max:
  forall m b ofs k p, perm m b ofs k p -> perm m b ofs Max p.

Local Hint Resolve perm_cur perm_max: mem.

Theorem perm_valid_block:
  forall m b ofs k p, perm m b ofs k p -> valid_block m b.

Local Hint Resolve perm_valid_block: mem.

Remark perm_order_dec:
  forall p1 p2, {perm_order p1 p2} + {~perm_order p1 p2}.

Remark perm_order'_dec:
  forall op p, {perm_order' op p} + {~perm_order' op p}.

Theorem perm_dec:
  forall m b ofs k p, {perm m b ofs k p} + {~ perm m b ofs k p}.

Definition range_perm (m: mem) (b: block) (lo hi: Z) (k: perm_kind) (p: permission) : Prop :=
  forall ofs, lo <= ofs < hi -> perm m b ofs k p.

Theorem range_perm_implies:
  forall m b lo hi k p1 p2,
  range_perm m b lo hi k p1 -> perm_order p1 p2 -> range_perm m b lo hi k p2.

Theorem range_perm_cur:
  forall m b lo hi k p,
  range_perm m b lo hi Cur p -> range_perm m b lo hi k p.

Theorem range_perm_max:
  forall m b lo hi k p,
  range_perm m b lo hi k p -> range_perm m b lo hi Max p.

Local Hint Resolve range_perm_implies range_perm_cur range_perm_max: mem.

Lemma range_perm_dec:
  forall m b lo hi k p, {range_perm m b lo hi k p} + {~ range_perm m b lo hi k p}.

Definition valid_access (m: mem) (chunk: memory_chunk) (b: block) (ofs: Z) (p: permission): Prop :=
  range_perm m b ofs (ofs + size_chunk chunk) Cur p
  /\ (align_chunk chunk | ofs).

Theorem valid_access_implies:
  forall m chunk b ofs p1 p2,
  valid_access m chunk b ofs p1 -> perm_order p1 p2 ->
  valid_access m chunk b ofs p2.

Theorem valid_access_freeable_any:
  forall m chunk b ofs p,
  valid_access m chunk b ofs Freeable ->
  valid_access m chunk b ofs p.

Local Hint Resolve valid_access_implies: mem.

Theorem valid_access_valid_block:
  forall m chunk b ofs,
  valid_access m chunk b ofs Nonempty ->
  valid_block m b.

Local Hint Resolve valid_access_valid_block: mem.

Lemma valid_access_perm:
  forall m chunk b ofs k p,
  valid_access m chunk b ofs p ->
  perm m b ofs k p.

Lemma valid_access_compat:
  forall m chunk1 chunk2 b ofs p,
  size_chunk chunk1 = size_chunk chunk2 ->
  align_chunk chunk2 <= align_chunk chunk1 ->
  valid_access m chunk1 b ofs p->
  valid_access m chunk2 b ofs p.

Lemma valid_access_dec:
  forall m chunk b ofs p,
  {valid_access m chunk b ofs p} + {~ valid_access m chunk b ofs p}.

Definition valid_pointer (m: mem) (b: block) (ofs: Z): bool :=
  perm_dec m b ofs Cur Nonempty.

Theorem valid_pointer_nonempty_perm:
  forall m b ofs,
  valid_pointer m b ofs = true <-> perm m b ofs Cur Nonempty.

Theorem valid_pointer_valid_access:
  forall m b ofs,
  valid_pointer m b ofs = true <-> valid_access m Mint8unsigned b ofs Nonempty.

Definition weak_valid_pointer (m: mem) (b: block) (ofs: Z) :=
  valid_pointer m b ofs || valid_pointer m b (ofs - 1).

Lemma weak_valid_pointer_spec:
  forall m b ofs,
  weak_valid_pointer m b ofs = true <->
    valid_pointer m b ofs = true \/ valid_pointer m b (ofs - 1) = true.
Lemma valid_pointer_implies:
  forall m b ofs,
  valid_pointer m b ofs = true -> weak_valid_pointer m b ofs = true.

Program Definition empty: mem :=
  mkmem (PMap.init (ZMap.init Undef))

Program Definition alloc (m: mem) (lo hi: Z) :=
  (mkmem (PMap.set m.(nextblock)

Program Definition unchecked_free (m: mem) (b: block) (lo hi: Z): mem :=
  mkmem m.(mem_contents)

Definition free (m: mem) (b: block) (lo hi: Z): option mem :=
  if range_perm_dec m b lo hi Cur Freeable
  then Some(unchecked_free m b lo hi)
  else None.

Fixpoint free_list (m: mem) (l: list (block * Z * Z)) {struct l}: option mem :=
  match l with
  | nil => Some m
  | (b, lo, hi) :: l' =>
      match free m b lo hi with
      | None => None
      | Some m' => free_list m' l'
      end
  end.

Fixpoint getN (n: nat) (p: Z) (c: ZMap.t memval) {struct n}: list memval :=
  match n with
  | O => nil
  | S n' => ZMap.get p c :: getN n' (p + 1) c
  end.

Definition load (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z): option val :=
  if valid_access_dec m chunk b ofs Readable
  then Some(decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)))
  else None.

Definition loadv (chunk: memory_chunk) (m: mem) (addr: val) : option val :=
  match addr with
  | Vptr b ofs => load chunk m b (Ptrofs.unsigned ofs)
  | _ => None
  end.

Definition loadbytes (m: mem) (b: block) (ofs n: Z): option (list memval) :=
  if range_perm_dec m b ofs (ofs + n) Cur Readable
  then Some (getN (nat_of_Z n) ofs (m.(mem_contents)#b))
  else None.

Fixpoint setN (vl: list memval) (p: Z) (c: ZMap.t memval) {struct vl}: ZMap.t memval :=
  match vl with
  | nil => c
  | v :: vl' => setN vl' (p + 1) (ZMap.set p v c)
  end.

Remark setN_other:
  forall vl c p q,
  (forall r, p <= r < p + Z.of_nat (length vl) -> r <> q) ->

Remark setN_outside:
  forall vl c p q,
  q < p \/ q >= p + Z.of_nat (length vl) ->

Remark getN_setN_same:
  forall vl p c,
  getN (length vl) p (setN vl p c) = vl.

Remark getN_exten:
  forall c1 c2 n p,
  (forall i, p <= i < p + Z.of_nat n -> ZMap.get i c1 = ZMap.get i c2) ->

Remark getN_setN_disjoint:
  forall vl q c n p,
  Intv.disjoint (p, p + Z.of_nat n) (q, q + Z.of_nat (length vl)) ->

Remark getN_setN_outside:
  forall vl q c n p,
  p + Z.of_nat n <= q \/ q + Z.of_nat (length vl) <= p ->

Remark setN_default:
  forall vl q c, fst (setN vl q c) = fst c.

Program Definition store (chunk: memory_chunk) (m: mem) (b: block) (ofs: Z) (v: val): option mem :=
  if valid_access_dec m chunk b ofs Writable then
    Some (mkmem (PMap.set b

Definition storev (chunk: memory_chunk) (m: mem) (addr v: val) : option mem :=
  match addr with
  | Vptr b ofs => store chunk m b (Ptrofs.unsigned ofs) v
  | _ => None
  end.

Program Definition storebytes (m: mem) (b: block) (ofs: Z) (bytes: list memval) : option mem :=
  if range_perm_dec m b ofs (ofs + Z.of_nat (length bytes)) Cur Writable then

Program Definition drop_perm (m: mem) (b: block) (lo hi: Z) (p: permission): option mem :=
  if range_perm_dec m b lo hi Cur Freeable then
    Some (mkmem m.(mem_contents)

Theorem nextblock_empty: nextblock empty = 1%positive.

Theorem perm_empty: forall b ofs k p, ~perm empty b ofs k p.

Theorem valid_access_empty: forall chunk b ofs p, ~valid_access empty chunk b ofs p.

Theorem valid_access_load:
  forall m chunk b ofs,
  valid_access m chunk b ofs Readable ->
  exists v, load chunk m b ofs = Some v.

Theorem load_valid_access:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  valid_access m chunk b ofs Readable.

Lemma load_result:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  v = decode_val chunk (getN (size_chunk_nat chunk) ofs (m.(mem_contents)#b)).

Local Hint Resolve load_valid_access valid_access_load: mem.

Theorem load_type:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  Val.has_type v (type_of_chunk chunk).

Theorem load_cast:
  forall m chunk b ofs v,
  load chunk m b ofs = Some v ->
  match chunk with
  | Mint8signed => v = Val.sign_ext 8 v

Theorem load_int8_signed_unsigned:
  forall m b ofs,
  load Mint8signed m b ofs = option_map (Val.sign_ext 8) (load Mint8unsigned m b ofs).

Theorem load_int16_signed_unsigned:
  forall m b ofs,
  load Mint16signed m b ofs = option_map (Val.sign_ext 16) (load Mint16unsigned m b ofs).

Theorem range_perm_loadbytes:
  forall m b ofs len,
  range_perm m b ofs (ofs + len) Cur Readable ->
  exists bytes, loadbytes m b ofs len = Some bytes.

Theorem loadbytes_range_perm:
  forall m b ofs len bytes,
  loadbytes m b ofs len = Some bytes ->
  range_perm m b ofs (ofs + len) Cur Readable.

Theorem loadbytes_load:
  forall chunk m b ofs bytes,
  loadbytes m b ofs (size_chunk chunk) = Some bytes ->
  (align_chunk chunk | ofs) ->
  load chunk m b ofs = Some(decode_val chunk bytes).

Theorem load_loadbytes:
  forall chunk m b ofs v,
  load chunk m b ofs = Some v ->
  exists bytes, loadbytes m b ofs (size_chunk chunk) = Some bytes
             /\ v = decode_val chunk bytes.

Lemma getN_length:
  forall c n p, length (getN n p c) = n.

Theorem loadbytes_length:
  forall m b ofs n bytes,
  loadbytes m b ofs n = Some bytes ->
  length bytes = nat_of_Z n.

Theorem loadbytes_empty:
  forall m b ofs n,
  n <= 0 -> loadbytes m b ofs n = Some nil.

Lemma getN_concat:
  forall c n1 n2 p,
  getN (n1 + n2)%nat p c = getN n1 p c ++ getN n2 (p + Z.of_nat n1) c.

Theorem loadbytes_concat:
  forall m b ofs n1 n2 bytes1 bytes2,
  loadbytes m b ofs n1 = Some bytes1 ->
  loadbytes m b (ofs + n1) n2 = Some bytes2 ->
  n1 >= 0 -> n2 >= 0 ->
  loadbytes m b ofs (n1 + n2) = Some(bytes1 ++ bytes2).

Theorem loadbytes_split:
  forall m b ofs n1 n2 bytes,
  loadbytes m b ofs (n1 + n2) = Some bytes ->
  n1 >= 0 -> n2 >= 0 ->
  exists bytes1, exists bytes2,
     loadbytes m b ofs n1 = Some bytes1
  /\ loadbytes m b (ofs + n1) n2 = Some bytes2
  /\ bytes = bytes1 ++ bytes2.

Theorem load_rep:
 forall ch m1 m2 b ofs v1 v2,
  (forall z, 0 <= z < size_chunk ch -> ZMap.get (ofs + z) m1.(mem_contents)#b = ZMap.get (ofs + z) m2.(mem_contents)#b) ->

Theorem load_int64_split:
  forall m b ofs v,
  load Mint64 m b ofs = Some v -> Archi.ptr64 = false ->

Lemma addressing_int64_split:
  forall i,
  Archi.ptr64 = false ->

Theorem loadv_int64_split:
  forall m a v,
  loadv Mint64 m a = Some v -> Archi.ptr64 = false ->

Theorem valid_access_store:
  forall m1 chunk b ofs v,
  valid_access m1 chunk b ofs Writable ->
  { m2: mem | store chunk m1 b ofs v = Some m2 }.

Local Hint Resolve valid_access_store: mem.

Section STORE.
Variable chunk: memory_chunk.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable v: val.
Variable m2: mem.
Hypothesis STORE: store chunk m1 b ofs v = Some m2.

Lemma store_access: mem_access m2 = mem_access m1.

Lemma store_mem_contents:
  mem_contents m2 = PMap.set b (setN (encode_val chunk v) ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_store_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_store_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_store_1 perm_store_2: mem.

Theorem nextblock_store:
  nextblock m2 = nextblock m1.

Theorem store_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem store_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.

Theorem store_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem store_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Theorem store_valid_access_3:
  valid_access m1 chunk b ofs Writable.

Local Hint Resolve store_valid_access_1 store_valid_access_2 store_valid_access_3: mem.

Theorem load_store_similar:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  exists v', load chunk' m2 b ofs = Some v' /\ decode_encode_val v chunk chunk' v'.

Theorem load_store_similar_2:
  forall chunk',
  size_chunk chunk' = size_chunk chunk ->
  align_chunk chunk' <= align_chunk chunk ->
  type_of_chunk chunk' = type_of_chunk chunk ->
  load chunk' m2 b ofs = Some (Val.load_result chunk' v).

Theorem load_store_same:
  load chunk m2 b ofs = Some (Val.load_result chunk v).

Theorem load_store_other:
  forall chunk' b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk' <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  load chunk' m2 b' ofs' = load chunk' m1 b' ofs'.

Theorem loadbytes_store_same:
  loadbytes m2 b ofs (size_chunk chunk) = Some(encode_val chunk v).

Theorem loadbytes_store_other:
  forall b' ofs' n,
  b' <> b
  \/ n <= 0
  \/ ofs' + n <= ofs
  \/ ofs + size_chunk chunk <= ofs' ->
  loadbytes m2 b' ofs' n = loadbytes m1 b' ofs' n.

Lemma setN_in:
  forall vl p q c,
  p <= q < p + Z.of_nat (length vl) ->

Lemma getN_in:
  forall c q n p,
  p <= q < p + Z.of_nat n ->

End STORE.

Local Hint Resolve perm_store_1 perm_store_2: mem.
Local Hint Resolve store_valid_block_1 store_valid_block_2: mem.
Local Hint Resolve store_valid_access_1 store_valid_access_2
             store_valid_access_3: mem.

Lemma load_store_overlap:
  forall chunk m1 b ofs v m2 chunk' ofs' v',
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b ofs' = Some v' ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  exists mv1 mvl mv1' mvl',
      shape_encoding chunk v (mv1 :: mvl)
  /\  shape_decoding chunk' (mv1' :: mvl') v'
  /\  (   (ofs' = ofs /\ mv1' = mv1)
       \/ (ofs' > ofs /\ In mv1' mvl)
       \/ (ofs' < ofs /\ In mv1 mvl')).

Definition compat_pointer_chunks (chunk1 chunk2: memory_chunk) : Prop :=
  match chunk1, chunk2 with
  | (Mint32 | Many32), (Mint32 | Many32) => True
  | (Mint64 | Many64), (Mint64 | Many64) => True
  | _, _ => False
  end.

Lemma compat_pointer_chunks_true:
  forall chunk1 chunk2,
  (chunk1 = Mint32 \/ chunk1 = Many32 \/ chunk1 = Mint64 \/ chunk1 = Many64) ->
  (chunk2 = Mint32 \/ chunk2 = Many32 \/ chunk2 = Mint64 \/ chunk2 = Many64) ->
  quantity_chunk chunk1 = quantity_chunk chunk2 ->
  compat_pointer_chunks chunk1 chunk2.

Theorem load_pointer_store:
  forall chunk m1 b ofs v m2 chunk' b' ofs' v_b v_o,
  store chunk m1 b ofs v = Some m2 ->
  load chunk' m2 b' ofs' = Some(Vptr v_b v_o) ->
  (v = Vptr v_b v_o /\ compat_pointer_chunks chunk chunk' /\ b' = b /\ ofs' = ofs)
  \/ (b' <> b \/ ofs' + size_chunk chunk' <= ofs \/ ofs + size_chunk chunk <= ofs').

Theorem load_store_pointer_overlap:
  forall chunk m1 b ofs v_b v_o m2 chunk' ofs' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs' = Some v ->
  ofs' <> ofs ->
  ofs' + size_chunk chunk' > ofs ->
  ofs + size_chunk chunk > ofs' ->
  v = Vundef.

Theorem load_store_pointer_mismatch:
  forall chunk m1 b ofs v_b v_o m2 chunk' v,
  store chunk m1 b ofs (Vptr v_b v_o) = Some m2 ->
  load chunk' m2 b ofs = Some v ->
  ~compat_pointer_chunks chunk chunk' ->
  v = Vundef.

Lemma store_similar_chunks:
  forall chunk1 chunk2 v1 v2 m b ofs,
  encode_val chunk1 v1 = encode_val chunk2 v2 ->
  align_chunk chunk1 = align_chunk chunk2 ->
  store chunk1 m b ofs v1 = store chunk2 m b ofs v2.

Theorem store_signed_unsigned_8:
  forall m b ofs v,
  store Mint8signed m b ofs v = store Mint8unsigned m b ofs v.

Theorem store_signed_unsigned_16:
  forall m b ofs v,
  store Mint16signed m b ofs v = store Mint16unsigned m b ofs v.

Theorem store_int8_zero_ext:
  forall m b ofs n,
  store Mint8unsigned m b ofs (Vint (Int.zero_ext 8 n)) =

Theorem store_int8_sign_ext:
  forall m b ofs n,
  store Mint8signed m b ofs (Vint (Int.sign_ext 8 n)) =

Theorem store_int16_zero_ext:
  forall m b ofs n,
  store Mint16unsigned m b ofs (Vint (Int.zero_ext 16 n)) =

Theorem store_int16_sign_ext:
  forall m b ofs n,
  store Mint16signed m b ofs (Vint (Int.sign_ext 16 n)) =

Theorem range_perm_storebytes:
  forall m1 b ofs bytes,
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable ->

Theorem storebytes_store:
  forall m1 b ofs chunk v m2,
  storebytes m1 b ofs (encode_val chunk v) = Some m2 ->
  (align_chunk chunk | ofs) ->
  store chunk m1 b ofs v = Some m2.

Theorem store_storebytes:
  forall m1 b ofs chunk v m2,
  store chunk m1 b ofs v = Some m2 ->
  storebytes m1 b ofs (encode_val chunk v) = Some m2.

Section STOREBYTES.
Variable m1: mem.
Variable b: block.
Variable ofs: Z.
Variable bytes: list memval.
Variable m2: mem.
Hypothesis STORE: storebytes m1 b ofs bytes = Some m2.

Lemma storebytes_access: mem_access m2 = mem_access m1.

Lemma storebytes_mem_contents:
   mem_contents m2 = PMap.set b (setN bytes ofs m1.(mem_contents)#b) m1.(mem_contents).

Theorem perm_storebytes_1:
  forall b' ofs' k p, perm m1 b' ofs' k p -> perm m2 b' ofs' k p.

Theorem perm_storebytes_2:
  forall b' ofs' k p, perm m2 b' ofs' k p -> perm m1 b' ofs' k p.

Local Hint Resolve perm_storebytes_1 perm_storebytes_2: mem.

Theorem storebytes_valid_access_1:
  forall chunk' b' ofs' p,
  valid_access m1 chunk' b' ofs' p -> valid_access m2 chunk' b' ofs' p.

Theorem storebytes_valid_access_2:
  forall chunk' b' ofs' p,
  valid_access m2 chunk' b' ofs' p -> valid_access m1 chunk' b' ofs' p.

Local Hint Resolve storebytes_valid_access_1 storebytes_valid_access_2: mem.

Theorem nextblock_storebytes:
  nextblock m2 = nextblock m1.

Theorem storebytes_valid_block_1:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem storebytes_valid_block_2:
  forall b', valid_block m2 b' -> valid_block m1 b'.

Local Hint Resolve storebytes_valid_block_1 storebytes_valid_block_2: mem.

Theorem storebytes_range_perm:
  range_perm m1 b ofs (ofs + Z.of_nat (length bytes)) Cur Writable.

Theorem loadbytes_storebytes_same:
  loadbytes m2 b ofs (Z.of_nat (length bytes)) = Some bytes.

Theorem loadbytes_storebytes_disjoint:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b \/ Intv.disjoint (ofs', ofs' + len) (ofs, ofs + Z.of_nat (length bytes)) ->

Theorem loadbytes_storebytes_other:
  forall b' ofs' len,
  len >= 0 ->
  b' <> b
  \/ ofs' + len <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

Theorem load_storebytes_other:
  forall chunk b' ofs',
  b' <> b
  \/ ofs' + size_chunk chunk <= ofs
  \/ ofs + Z.of_nat (length bytes) <= ofs' ->

End STOREBYTES.

Lemma setN_concat:
  forall bytes1 bytes2 ofs c,
  setN (bytes1 ++ bytes2) ofs c = setN bytes2 (ofs + Z.of_nat (length bytes1)) (setN bytes1 ofs c).

Theorem storebytes_concat:
  forall m b ofs bytes1 m1 bytes2 m2,
  storebytes m b ofs bytes1 = Some m1 ->
  storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2 ->

Theorem storebytes_split:
  forall m b ofs bytes1 bytes2 m2,
  storebytes m b ofs (bytes1 ++ bytes2) = Some m2 ->
  exists m1,
     storebytes m b ofs bytes1 = Some m1
  /\ storebytes m1 b (ofs + Z.of_nat(length bytes1)) bytes2 = Some m2.

Theorem store_int64_split:
  forall m b ofs v m',
  store Mint64 m b ofs v = Some m' -> Archi.ptr64 = false ->

Theorem storev_int64_split:
  forall m a v m',
  storev Mint64 m a v = Some m' -> Archi.ptr64 = false ->

Section ALLOC.

Variable m1: mem.
Variables lo hi: Z.
Variable m2: mem.
Variable b: block.
Hypothesis ALLOC: alloc m1 lo hi = (m2, b).

Theorem nextblock_alloc:
  nextblock m2 = Pos.succ (nextblock m1).

Theorem alloc_result:
  b = nextblock m1.

Theorem valid_block_alloc:
  forall b', valid_block m1 b' -> valid_block m2 b'.

Theorem fresh_block_alloc:
  ~(valid_block m1 b).

Theorem valid_new_block:
  valid_block m2 b.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.

Theorem valid_block_alloc_inv:
  forall b', valid_block m2 b' -> b' = b \/ valid_block m1 b'.

Theorem perm_alloc_1:
  forall b' ofs k p, perm m1 b' ofs k p -> perm m2 b' ofs k p.

Theorem perm_alloc_2:
  forall ofs k, lo <= ofs < hi -> perm m2 b ofs k Freeable.

Theorem perm_alloc_inv:
  forall b' ofs k p,
  perm m2 b' ofs k p ->
  if eq_block b' b then lo <= ofs < hi else perm m1 b' ofs k p.

Theorem perm_alloc_3:
  forall ofs k p, perm m2 b ofs k p -> lo <= ofs < hi.

Theorem perm_alloc_4:
  forall b' ofs k p, perm m2 b' ofs k p -> b' <> b -> perm m1 b' ofs k p.

Local Hint Resolve perm_alloc_1 perm_alloc_2 perm_alloc_3 perm_alloc_4: mem.

Theorem valid_access_alloc_other:
  forall chunk b' ofs p,
  valid_access m1 chunk b' ofs p ->
  valid_access m2 chunk b' ofs p.

Theorem valid_access_alloc_same:
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  valid_access m2 chunk b ofs Freeable.

Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem valid_access_alloc_inv:
  forall chunk b' ofs p,
  valid_access m2 chunk b' ofs p ->
  if eq_block b' b
  then lo <= ofs /\ ofs + size_chunk chunk <= hi /\ (align_chunk chunk | ofs)
  else valid_access m1 chunk b' ofs p.

Theorem load_alloc_unchanged:
  forall chunk b' ofs,
  valid_block m1 b' ->
  load chunk m2 b' ofs = load chunk m1 b' ofs.

Theorem load_alloc_other:
  forall chunk b' ofs v,
  load chunk m1 b' ofs = Some v ->
  load chunk m2 b' ofs = Some v.

Theorem load_alloc_same:
  forall chunk ofs v,
  load chunk m2 b ofs = Some v ->
  v = Vundef.

Theorem load_alloc_same':
  forall chunk ofs,
  lo <= ofs -> ofs + size_chunk chunk <= hi -> (align_chunk chunk | ofs) ->
  load chunk m2 b ofs = Some Vundef.

Theorem loadbytes_alloc_unchanged:
  forall b' ofs n,
  valid_block m1 b' ->
  loadbytes m2 b' ofs n = loadbytes m1 b' ofs n.

Theorem loadbytes_alloc_same:
  forall n ofs bytes byte,
  loadbytes m2 b ofs n = Some bytes ->
  In byte bytes -> byte = Undef.

End ALLOC.

Local Hint Resolve valid_block_alloc fresh_block_alloc valid_new_block: mem.
Local Hint Resolve valid_access_alloc_other valid_access_alloc_same: mem.

Theorem range_perm_free:
  forall m1 b lo hi,
  range_perm m1 b lo hi Cur Freeable ->
  { m2: mem | free m1 b lo hi = Some m2 }.

Section FREE.

Variable m1: mem.
Variable bf: block.
Variables lo hi: Z.
Variable m2: mem.
Hypothesis FREE: free m1 bf lo hi = Some m2.

Theorem free_range_perm:
  range_perm m1 bf lo hi Cur Freeable.

Lemma free_result:
  m2 = unchecked_free m1 bf lo hi.

Theorem nextblock_free:
  nextblock m2 = nextblock m1.

Theorem valid_block_free_1:
  forall b, valid_block m1 b -> valid_block m2 b.

Theorem valid_block_free_2:
  forall b, valid_block m2 b -> valid_block m1 b.

Local Hint Resolve valid_block_free_1 valid_block_free_2: mem.

Theorem perm_free_1:
  forall b ofs k p,
  b <> bf \/ ofs < lo \/ hi <= ofs ->
  perm m1 b ofs k p ->
  perm m2 b ofs k p.

Theorem perm_free_2:
  forall ofs k p, lo <= ofs < hi -> ~ perm m2 bf ofs k p.

Theorem perm_free_3:
  forall b ofs k p,
  perm m2 b ofs k p -> perm m1 b ofs k p.

Theorem perm_free_inv:
  forall b ofs k p,
  perm m1 b ofs k p ->
  (b = bf /\ lo <= ofs < hi) \/ perm m2 b ofs k p.

Theorem valid_access_free_1:
  forall chunk b ofs p,
  valid_access m1 chunk b ofs p ->
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  valid_access m2 chunk b ofs p.

Theorem valid_access_free_2:
  forall chunk ofs p,
  lo < hi -> ofs + size_chunk chunk > lo -> ofs < hi ->
  ~(valid_access m2 chunk bf ofs p).

Theorem valid_access_free_inv_1:
  forall chunk b ofs p,
  valid_access m2 chunk b ofs p ->
  valid_access m1 chunk b ofs p.

Theorem valid_access_free_inv_2:
  forall chunk ofs p,
  valid_access m2 chunk bf ofs p ->
  lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs.

Theorem load_free:
  forall chunk b ofs,
  b <> bf \/ lo >= hi \/ ofs + size_chunk chunk <= lo \/ hi <= ofs ->
  load chunk m2 b ofs = load chunk m1 b ofs.

Theorem load_free_2:
  forall chunk b ofs v,
  load chunk m2 b ofs = Some v -> load chunk m1 b ofs = Some v.

Theorem loadbytes_free:
  forall b ofs n,
  b <> bf \/ lo >= hi \/ ofs + n <= lo \/ hi <= ofs ->
  loadbytes m2 b ofs n = loadbytes m1 b ofs n.

Theorem loadbytes_free_2:
  forall b ofs n bytes,
  loadbytes m2 b ofs n = Some bytes -> loadbytes m1 b ofs n = Some bytes.

End FREE.

Local Hint Resolve valid_block_free_1 valid_block_free_2
             perm_free_1 perm_free_2 perm_free_3
             valid_access_free_1 valid_access_free_inv_1: mem.

Theorem range_perm_drop_1:
  forall m b lo hi p m', drop_perm m b lo hi p = Some m' -> range_perm m b lo hi Cur Freeable.

Theorem range_perm_drop_2:
  forall m b lo hi p,
  range_perm m b lo hi Cur Freeable -> {m' | drop_perm m b lo hi p = Some m' }.

Section DROP.

Variable m: mem.
Variable b: block.
Variable lo hi: Z.
Variable p: permission.
Variable m': mem.
Hypothesis DROP: drop_perm m b lo hi p = Some m'.

Theorem nextblock_drop:
  nextblock m' = nextblock m.

Theorem drop_perm_valid_block_1:
  forall b', valid_block m b' -> valid_block m' b'.

Theorem drop_perm_valid_block_2:
  forall b', valid_block m' b' -> valid_block m b'.

Theorem perm_drop_1:
  forall ofs k, lo <= ofs < hi -> perm m' b ofs k p.

Theorem perm_drop_2:
  forall ofs k p', lo <= ofs < hi -> perm m' b ofs k p' -> perm_order p p'.

Theorem perm_drop_3:
  forall b' ofs k p', b' <> b \/ ofs < lo \/ hi <= ofs -> perm m b' ofs k p' -> perm m' b' ofs k p'.

Theorem perm_drop_4:
  forall b' ofs k p', perm m' b' ofs k p' -> perm m b' ofs k p'.

Lemma valid_access_drop_1:
  forall chunk b' ofs p',
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p p' ->
  valid_access m chunk b' ofs p' -> valid_access m' chunk b' ofs p'.

Lemma valid_access_drop_2:
  forall chunk b' ofs p',
  valid_access m' chunk b' ofs p' -> valid_access m chunk b' ofs p'.

Theorem load_drop:
  forall chunk b' ofs,
  b' <> b \/ ofs + size_chunk chunk <= lo \/ hi <= ofs \/ perm_order p Readable ->
  load chunk m' b' ofs = load chunk m b' ofs.

Theorem loadbytes_drop:
  forall b' ofs n,
  b' <> b \/ ofs + n <= lo \/ hi <= ofs \/ perm_order p Readable ->
  loadbytes m' b' ofs n = loadbytes m b' ofs n.

End DROP.

Record mem_inj (f: meminj) (m1 m2: mem) : Prop :=
  mk_mem_inj {
    mi_perm:
      forall b1 b2 delta ofs k p,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs k p ->
      perm m2 b2 (ofs + delta) k p;
    mi_align:
      forall b1 b2 delta chunk ofs p,
      f b1 = Some(b2, delta) ->
      range_perm m1 b1 ofs (ofs + size_chunk chunk) Max p ->
      (align_chunk chunk | delta);
    mi_memval:
      forall b1 ofs b2 delta,
      f b1 = Some(b2, delta) ->
      perm m1 b1 ofs Cur Readable ->
      memval_inject f (ZMap.get ofs m1.(mem_contents)#b1) (ZMap.get (ofs+delta) m2.(mem_contents)#b2)
  }.

Lemma perm_inj:
  forall f m1 m2 b1 ofs k p b2 delta,
  mem_inj f m1 m2 ->
  perm m1 b1 ofs k p ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p.

Lemma range_perm_inj:
  forall f m1 m2 b1 lo hi k p b2 delta,
  mem_inj f m1 m2 ->
  range_perm m1 b1 lo hi k p ->
  f b1 = Some(b2, delta) ->
  range_perm m2 b2 (lo + delta) (hi + delta) k p.

Lemma valid_access_inj:
  forall f m1 m2 b1 b2 delta chunk ofs p,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Lemma getN_inj:
  forall f m1 m2 b1 b2 delta,
  mem_inj f m1 m2 ->
  f b1 = Some(b2, delta) ->
  forall n ofs,
  range_perm m1 b1 ofs (ofs + Z.of_nat n) Cur Readable ->

Lemma load_inj:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  mem_inj f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Lemma loadbytes_inj:
  forall f m1 m2 len b1 ofs b2 delta bytes1,
  mem_inj f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Lemma setN_inj:
  forall (access: Z -> Prop) delta f vl1 vl2,
  list_forall2 (memval_inject f) vl1 vl2 ->
  forall p c1 c2,
  (forall q, access q -> memval_inject f (ZMap.get q c1) (ZMap.get (q + delta) c2)) ->

Definition meminj_no_overlap (f: meminj) (m: mem) : Prop :=
  forall b1 b1' delta1 b2 b2' delta2 ofs1 ofs2,
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m b1 ofs1 Max Nonempty ->
  perm m b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Lemma store_mapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Lemma store_unmapped_inj:
  forall f chunk m1 b1 ofs v1 n1 m2,
  mem_inj f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma store_outside_inj:
  forall f m1 m2 chunk b ofs v m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  mem_inj f m1 m2'.

Lemma storebytes_mapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  meminj_no_overlap f m1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ mem_inj f n1 n2.

Lemma storebytes_unmapped_inj:
  forall f m1 b1 ofs bytes1 n1 m2,
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  mem_inj f n1 m2.

Lemma storebytes_outside_inj:
  forall f m1 m2 b ofs bytes2 m2',
  mem_inj f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Lemma storebytes_empty_inj:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  mem_inj f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  mem_inj f m1' m2'.

Lemma alloc_right_inj:
  forall f m1 m2 lo hi b2 m2',
  mem_inj f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  mem_inj f m1 m2'.

Lemma alloc_left_unmapped_inj:
  forall f m1 m2 lo hi m1' b1,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  f b1 = None ->
  mem_inj f m1' m2.

Definition inj_offset_aligned (delta: Z) (size: Z) : Prop :=
  forall chunk, size_chunk chunk <= size -> (align_chunk chunk | delta).

Lemma alloc_left_mapped_inj:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  mem_inj f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  inj_offset_aligned delta (hi-lo) ->
  (forall ofs k p, lo <= ofs < hi -> perm m2 b2 (ofs + delta) k p) ->
  f b1 = Some(b2, delta) ->
  mem_inj f m1' m2.

Lemma free_left_inj:
  forall f m1 m2 b lo hi m1',
  mem_inj f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  mem_inj f m1' m2.

Lemma free_right_inj:
  forall f m1 m2 b lo hi m2',
  mem_inj f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  mem_inj f m1 m2'.

Lemma drop_unmapped_inj:
  forall f m1 m2 b lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b lo hi p = Some m1' ->
  f b = None ->
  mem_inj f m1' m2.

Lemma drop_mapped_inj:
  forall f m1 m2 b1 b2 delta lo hi p m1',
  mem_inj f m1 m2 ->
  drop_perm m1 b1 lo hi p = Some m1' ->
  meminj_no_overlap f m1 ->
  f b1 = Some(b2, delta) ->
  exists m2',
      drop_perm m2 b2 (lo + delta) (hi + delta) p = Some m2'
   /\ mem_inj f m1' m2'.

Lemma drop_outside_inj: forall f m1 m2 b lo hi p m2',
  mem_inj f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs' k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs' k p ->
    lo <= ofs' + delta < hi -> False) ->
  mem_inj f m1 m2'.

Record extends' (m1 m2: mem) : Prop :=
  mk_extends {
    mext_next: nextblock m1 = nextblock m2;
    mext_inj:  mem_inj inject_id m1 m2;
    mext_perm_inv: forall b ofs k p,
      perm m2 b ofs k p ->
      perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty
  }.

Definition extends := extends'.

Theorem extends_refl:
  forall m, extends m m.

Theorem load_extends:
  forall chunk m1 m2 b ofs v1,
  extends m1 m2 ->
  load chunk m1 b ofs = Some v1 ->
  exists v2, load chunk m2 b ofs = Some v2 /\ Val.lessdef v1 v2.

Theorem loadv_extends:
  forall chunk m1 m2 addr1 addr2 v1,
  extends m1 m2 ->
  loadv chunk m1 addr1 = Some v1 ->
  Val.lessdef addr1 addr2 ->

Theorem loadbytes_extends:
  forall m1 m2 b ofs len bytes1,
  extends m1 m2 ->
  loadbytes m1 b ofs len = Some bytes1 ->
  exists bytes2, loadbytes m2 b ofs len = Some bytes2
              /\ list_forall2 memval_lessdef bytes1 bytes2.

Theorem store_within_extends:
  forall chunk m1 m2 b ofs v1 m1' v2,
  extends m1 m2 ->
  store chunk m1 b ofs v1 = Some m1' ->
  Val.lessdef v1 v2 ->

Theorem store_outside_extends:
  forall chunk m1 m2 b ofs v m2',
  extends m1 m2 ->
  store chunk m2 b ofs v = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + size_chunk chunk -> False) ->
  extends m1 m2'.

Theorem storev_extends:
  forall chunk m1 m2 addr1 v1 m1' addr2 v2,
  extends m1 m2 ->
  storev chunk m1 addr1 v1 = Some m1' ->
  Val.lessdef addr1 addr2 ->

Theorem storebytes_within_extends:
  forall m1 m2 b ofs bytes1 m1' bytes2,
  extends m1 m2 ->
  storebytes m1 b ofs bytes1 = Some m1' ->
  list_forall2 memval_lessdef bytes1 bytes2 ->
  exists m2',
     storebytes m2 b ofs bytes2 = Some m2'
  /\ extends m1' m2'.

Theorem storebytes_outside_extends:
  forall m1 m2 b ofs bytes2 m2',
  extends m1 m2 ->
  storebytes m2 b ofs bytes2 = Some m2' ->
  (forall ofs', perm m1 b ofs' Cur Readable -> ofs <= ofs' < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem alloc_extends:
  forall m1 m2 lo1 hi1 b m1' lo2 hi2,
  extends m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists m2',
     alloc m2 lo2 hi2 = (m2', b)
  /\ extends m1' m2'.

Theorem free_left_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  extends m1' m2.

Theorem free_right_extends:
  forall m1 m2 b lo hi m2',
  extends m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall ofs k p, perm m1 b ofs k p -> lo <= ofs < hi -> False) ->
  extends m1 m2'.

Theorem free_parallel_extends:
  forall m1 m2 b lo hi m1',
  extends m1 m2 ->
  free m1 b lo hi = Some m1' ->
  exists m2',
     free m2 b lo hi = Some m2'
  /\ extends m1' m2'.

Theorem valid_block_extends:
  forall m1 m2 b,
  extends m1 m2 ->
  (valid_block m1 b <-> valid_block m2 b).

Theorem perm_extends:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m1 b ofs k p -> perm m2 b ofs k p.

Theorem perm_extends_inv:
  forall m1 m2 b ofs k p,
  extends m1 m2 -> perm m2 b ofs k p -> perm m1 b ofs k p \/ ~perm m1 b ofs Max Nonempty.

Theorem valid_access_extends:
  forall m1 m2 chunk b ofs p,
  extends m1 m2 -> valid_access m1 chunk b ofs p -> valid_access m2 chunk b ofs p.

Theorem valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 -> valid_pointer m1 b ofs = true -> valid_pointer m2 b ofs = true.

Theorem weak_valid_pointer_extends:
  forall m1 m2 b ofs,
  extends m1 m2 ->
  weak_valid_pointer m1 b ofs = true -> weak_valid_pointer m2 b ofs = true.

Record inject' (f: meminj) (m1 m2: mem) : Prop :=
  mk_inject {
    mi_inj:
      mem_inj f m1 m2;
    mi_freeblocks:
      forall b, ~(valid_block m1 b) -> f b = None;
    mi_mappedblocks:
      forall b b' delta, f b = Some(b', delta) -> valid_block m2 b';
    mi_no_overlap:
      meminj_no_overlap f m1;
    mi_representable:
      forall b b' delta ofs,
      f b = Some(b', delta) ->
      perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/ perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
      delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned;
    mi_perm_inv:
      forall b1 ofs b2 delta k p,
      f b1 = Some(b2, delta) ->
      perm m2 b2 (ofs + delta) k p ->
      perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
  }.
Definition inject := inject'.

Local Hint Resolve mi_mappedblocks: mem.

Theorem valid_block_inject_1:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m1 b1.

Theorem valid_block_inject_2:
  forall f m1 m2 b1 b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_block m2 b2.

Local Hint Resolve valid_block_inject_1 valid_block_inject_2: mem.

Theorem perm_inject:
  forall f m1 m2 b1 b2 delta ofs k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  perm m1 b1 ofs k p -> perm m2 b2 (ofs + delta) k p.

Theorem perm_inject_inv:
  forall f m1 m2 b1 ofs b2 delta k p,
  inject f m1 m2 ->
  f b1 = Some(b2, delta) ->
  perm m2 b2 (ofs + delta) k p ->
  perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty.

Theorem range_perm_inject:
  forall f m1 m2 b1 b2 delta lo hi k p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  range_perm m1 b1 lo hi k p -> range_perm m2 b2 (lo + delta) (hi + delta) k p.

Theorem valid_access_inject:
  forall f m1 m2 chunk b1 ofs b2 delta p,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_access m1 chunk b1 ofs p ->
  valid_access m2 chunk b2 (ofs + delta) p.

Theorem valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  valid_pointer m1 b1 ofs = true ->
  valid_pointer m2 b2 (ofs + delta) = true.

Theorem weak_valid_pointer_inject:
  forall f m1 m2 b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  inject f m1 m2 ->
  weak_valid_pointer m1 b1 ofs = true ->
  weak_valid_pointer m2 b2 (ofs + delta) = true.

Lemma address_inject:
  forall f m1 m2 b1 ofs1 b2 delta p,
  inject f m1 m2 ->
  perm m1 b1 (Ptrofs.unsigned ofs1) Cur p ->

Lemma address_inject':
  forall f m1 m2 chunk b1 ofs1 b2 delta,
  inject f m1 m2 ->
  valid_access m1 chunk b1 (Ptrofs.unsigned ofs1) Nonempty ->

Theorem weak_valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_no_overflow:
  forall f m1 m2 b ofs b' delta,
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem weak_valid_pointer_inject_val:
  forall f m1 m2 b ofs b' ofs',
  inject f m1 m2 ->
  weak_valid_pointer m1 b (Ptrofs.unsigned ofs) = true ->

Theorem inject_no_overlap:
  forall f m1 m2 b1 b2 b1' b2' delta1 delta2 ofs1 ofs2,
  inject f m1 m2 ->
  b1 <> b2 ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  perm m1 b1 ofs1 Max Nonempty ->
  perm m1 b2 ofs2 Max Nonempty ->
  b1' <> b2' \/ ofs1 + delta1 <> ofs2 + delta2.

Theorem different_pointers_inject:
  forall f m m' b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  inject f m m' ->
  b1 <> b2 ->
  valid_pointer m b1 (Ptrofs.unsigned ofs1) = true ->

Theorem disjoint_or_equal_inject:
  forall f m m' b1 b1' delta1 b2 b2' delta2 ofs1 ofs2 sz,
  inject f m m' ->
  f b1 = Some(b1', delta1) ->
  f b2 = Some(b2', delta2) ->
  range_perm m b1 ofs1 (ofs1 + sz) Max Nonempty ->
  range_perm m b2 ofs2 (ofs2 + sz) Max Nonempty ->
  sz > 0 ->
  b1 <> b2 \/ ofs1 = ofs2 \/ ofs1 + sz <= ofs2 \/ ofs2 + sz <= ofs1 ->
  b1' <> b2' \/ ofs1 + delta1 = ofs2 + delta2
             \/ ofs1 + delta1 + sz <= ofs2 + delta2
             \/ ofs2 + delta2 + sz <= ofs1 + delta1.

Theorem aligned_area_inject:
  forall f m m' b ofs al sz b' delta,
  inject f m m' ->
  al = 1 \/ al = 2 \/ al = 4 \/ al = 8 -> sz > 0 ->
  (al | sz) ->
  range_perm m b ofs (ofs + sz) Cur Nonempty ->
  (al | ofs) ->
  f b = Some(b', delta) ->
  (al | ofs + delta).

Theorem load_inject:
  forall f m1 m2 chunk b1 ofs b2 delta v1,
  inject f m1 m2 ->
  load chunk m1 b1 ofs = Some v1 ->
  f b1 = Some (b2, delta) ->
  exists v2, load chunk m2 b2 (ofs + delta) = Some v2 /\ Val.inject f v1 v2.

Theorem loadv_inject:
  forall f m1 m2 chunk a1 a2 v1,
  inject f m1 m2 ->
  loadv chunk m1 a1 = Some v1 ->
  Val.inject f a1 a2 ->

Theorem loadbytes_inject:
  forall f m1 m2 b1 ofs len b2 delta bytes1,
  inject f m1 m2 ->
  loadbytes m1 b1 ofs len = Some bytes1 ->
  f b1 = Some (b2, delta) ->
  exists bytes2, loadbytes m2 b2 (ofs + delta) len = Some bytes2
              /\ list_forall2 (memval_inject f) bytes1 bytes2.

Theorem store_mapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2 b2 delta v2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  Val.inject f v1 v2 ->

Theorem store_unmapped_inject:
  forall f chunk m1 b1 ofs v1 n1 m2,
  inject f m1 m2 ->
  store chunk m1 b1 ofs v1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem store_outside_inject:
  forall f m1 m2 chunk b ofs v m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + size_chunk chunk -> False) ->
  store chunk m2 b ofs v = Some m2' ->
  inject f m1 m2'.

Theorem storev_mapped_inject:
  forall f chunk m1 a1 v1 n1 m2 a2 v2,
  inject f m1 m2 ->
  storev chunk m1 a1 v1 = Some n1 ->
  Val.inject f a1 a2 ->

Theorem storebytes_mapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2 b2 delta bytes2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = Some (b2, delta) ->
  list_forall2 (memval_inject f) bytes1 bytes2 ->
  exists n2,
    storebytes m2 b2 (ofs + delta) bytes2 = Some n2
    /\ inject f n1 n2.

Theorem storebytes_unmapped_inject:
  forall f m1 b1 ofs bytes1 n1 m2,
  inject f m1 m2 ->
  storebytes m1 b1 ofs bytes1 = Some n1 ->
  f b1 = None ->
  inject f n1 m2.

Theorem storebytes_outside_inject:
  forall f m1 m2 b ofs bytes2 m2',
  inject f m1 m2 ->
  (forall b' delta ofs',
    f b' = Some(b, delta) ->
    perm m1 b' ofs' Cur Readable ->
    ofs <= ofs' + delta < ofs + Z.of_nat (length bytes2) -> False) ->

Theorem storebytes_empty_inject:
  forall f m1 b1 ofs1 m1' m2 b2 ofs2 m2',
  inject f m1 m2 ->
  storebytes m1 b1 ofs1 nil = Some m1' ->
  storebytes m2 b2 ofs2 nil = Some m2' ->
  inject f m1' m2'.

Theorem alloc_right_inject:
  forall f m1 m2 lo hi b2 m2',
  inject f m1 m2 ->
  alloc m2 lo hi = (m2', b2) ->
  inject f m1 m2'.

Theorem alloc_left_unmapped_inject:
  forall f m1 m2 lo hi m1' b1,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  exists f',
     inject f' m1' m2
  /\ inject_incr f f'
  /\ f' b1 = None
  /\ (forall b, b <> b1 -> f' b = f b).

Theorem alloc_left_mapped_inject:
  forall f m1 m2 lo hi m1' b1 b2 delta,
  inject f m1 m2 ->
  alloc m1 lo hi = (m1', b1) ->
  valid_block m2 b2 ->
  0 <= delta <= Ptrofs.max_unsigned ->

Theorem alloc_parallel_inject:
  forall f m1 m2 lo1 hi1 m1' b1 lo2 hi2,
  inject f m1 m2 ->
  alloc m1 lo1 hi1 = (m1', b1) ->
  lo2 <= lo1 -> hi1 <= hi2 ->
  exists f', exists m2', exists b2,
  alloc m2 lo2 hi2 = (m2', b2)
  /\ inject f' m1' m2'
  /\ inject_incr f f'
  /\ f' b1 = Some(b2, 0)
  /\ (forall b, b <> b1 -> f' b = f b).

Lemma free_left_inject:
  forall f m1 m2 b lo hi m1',
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  inject f m1' m2.

Lemma free_list_left_inject:
  forall f m2 l m1 m1',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  inject f m1' m2.

Lemma free_right_inject:
  forall f m1 m2 b lo hi m2',
  inject f m1 m2 ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) -> perm m1 b1 ofs k p ->
    lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma perm_free_list:
  forall l m m' b ofs k p,
  free_list m l = Some m' ->
  perm m' b ofs k p ->
  perm m b ofs k p /\
  (forall lo hi, In (b, lo, hi) l -> lo <= ofs < hi -> False).

Theorem free_inject:
  forall f m1 l m1' m2 b lo hi m2',
  inject f m1 m2 ->
  free_list m1 l = Some m1' ->
  free m2 b lo hi = Some m2' ->
  (forall b1 delta ofs k p,
    f b1 = Some(b, delta) ->
    perm m1 b1 ofs k p -> lo <= ofs + delta < hi ->
    exists lo1, exists hi1, In (b1, lo1, hi1) l /\ lo1 <= ofs < hi1) ->
  inject f m1' m2'.

Theorem free_parallel_inject:
  forall f m1 m2 b lo hi m1' b' delta,
  inject f m1 m2 ->
  free m1 b lo hi = Some m1' ->
  f b = Some(b', delta) ->
  exists m2',
     free m2 b' (lo + delta) (hi + delta) = Some m2'
  /\ inject f m1' m2'.

Lemma drop_outside_inject: forall f m1 m2 b lo hi p m2',
  inject f m1 m2 ->
  drop_perm m2 b lo hi p = Some m2' ->
  (forall b' delta ofs k p,
    f b' = Some(b, delta) ->
    perm m1 b' ofs k p -> lo <= ofs + delta < hi -> False) ->
  inject f m1 m2'.

Lemma mem_inj_compose:
  forall f f' m1 m2 m3,
  mem_inj f m1 m2 -> mem_inj f' m2 m3 -> mem_inj (compose_meminj f f') m1 m3.

Theorem inject_compose:
  forall f f' m1 m2 m3,
  inject f m1 m2 -> inject f' m2 m3 ->
  inject (compose_meminj f f') m1 m3.

Lemma val_lessdef_inject_compose:
  forall f v1 v2 v3,
  Val.lessdef v1 v2 -> Val.inject f v2 v3 -> Val.inject f v1 v3.

Lemma val_inject_lessdef_compose:
  forall f v1 v2 v3,
  Val.inject f v1 v2 -> Val.lessdef v2 v3 -> Val.inject f v1 v3.

Lemma extends_inject_compose:
  forall f m1 m2 m3,
  extends m1 m2 -> inject f m2 m3 -> inject f m1 m3.

Lemma inject_extends_compose:
  forall f m1 m2 m3,
  inject f m1 m2 -> extends m2 m3 -> inject f m1 m3.

Lemma extends_extends_compose:
  forall m1 m2 m3,
  extends m1 m2 -> extends m2 m3 -> extends m1 m3.

Definition flat_inj (thr: block) : meminj :=
  fun (b: block) => if plt b thr then Some(b, 0) else None.

Definition inject_neutral (thr: block) (m: mem) :=
  mem_inj (flat_inj thr) m m.

Remark flat_inj_no_overlap:
  forall thr m, meminj_no_overlap (flat_inj thr) m.

Theorem neutral_inject:
  forall m, inject_neutral (nextblock m) m -> inject (flat_inj (nextblock m)) m m.

Theorem empty_inject_neutral:
  forall thr, inject_neutral thr empty.

Theorem alloc_inject_neutral:
  forall thr m lo hi b m',
  alloc m lo hi = (m', b) ->
  inject_neutral thr m ->
  Plt (nextblock m) thr ->
  inject_neutral thr m'.

Theorem store_inject_neutral:
  forall chunk m b ofs v m' thr,
  store chunk m b ofs v = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  Val.inject (flat_inj thr) v v ->

Theorem drop_inject_neutral:
  forall m b lo hi p m' thr,
  drop_perm m b lo hi p = Some m' ->
  inject_neutral thr m ->
  Plt b thr ->
  inject_neutral thr m'.

Section UNCHANGED_ON.

Variable P: block -> Z -> Prop.

Record unchanged_on (m_before m_after: mem) : Prop := mk_unchanged_on {
  unchanged_on_nextblock:
    Ple (nextblock m_before) (nextblock m_after);
  unchanged_on_perm:
    forall b ofs k p,
    P b ofs -> valid_block m_before b ->
    (perm m_before b ofs k p <-> perm m_after b ofs k p);
  unchanged_on_contents:
    forall b ofs,
    P b ofs -> perm m_before b ofs Cur Readable ->
    ZMap.get ofs (PMap.get b m_after.(mem_contents)) =
    ZMap.get ofs (PMap.get b m_before.(mem_contents))
}.

Lemma unchanged_on_refl:
  forall m, unchanged_on m m.

Lemma valid_block_unchanged_on:
  forall m m' b,
  unchanged_on m m' -> valid_block m b -> valid_block m' b.

Lemma perm_unchanged_on:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs ->
  perm m b ofs k p -> perm m' b ofs k p.

Lemma perm_unchanged_on_2:
  forall m m' b ofs k p,
  unchanged_on m m' -> P b ofs -> valid_block m b ->
  perm m' b ofs k p -> perm m b ofs k p.

Lemma unchanged_on_trans:
  forall m1 m2 m3, unchanged_on m1 m2 -> unchanged_on m2 m3 -> unchanged_on m1 m3.

Lemma loadbytes_unchanged_on_1:
  forall m m' b ofs n,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m' b ofs n = loadbytes m b ofs n.

Lemma loadbytes_unchanged_on:
  forall m m' b ofs n bytes,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + n -> P b i) ->
  loadbytes m b ofs n = Some bytes ->
  loadbytes m' b ofs n = Some bytes.

Lemma load_unchanged_on_1:
  forall m m' chunk b ofs,
  unchanged_on m m' ->
  valid_block m b ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m' b ofs = load chunk m b ofs.

Lemma load_unchanged_on:
  forall m m' chunk b ofs v,
  unchanged_on m m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> P b i) ->
  load chunk m b ofs = Some v ->
  load chunk m' b ofs = Some v.

Lemma store_unchanged_on:
  forall chunk m b ofs v m',
  store chunk m b ofs v = Some m' ->
  (forall i, ofs <= i < ofs + size_chunk chunk -> ~ P b i) ->
  unchanged_on m m'.

Lemma storebytes_unchanged_on:
  forall m b ofs bytes m',
  storebytes m b ofs bytes = Some m' ->
  (forall i, ofs <= i < ofs + Z.of_nat (length bytes) -> ~ P b i) ->

Lemma alloc_unchanged_on:
  forall m lo hi m' b,
  alloc m lo hi = (m', b) ->
  unchanged_on m m'.

Lemma free_unchanged_on:
  forall m b lo hi m',
  free m b lo hi = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

Lemma drop_perm_unchanged_on:
  forall m b lo hi p m',
  drop_perm m b lo hi p = Some m' ->
  (forall i, lo <= i < hi -> ~ P b i) ->
  unchanged_on m m'.

End UNCHANGED_ON.

Lemma unchanged_on_implies:
  forall (P Q: block -> Z -> Prop) m m',
  unchanged_on P m m' ->
  (forall b ofs, Q b ofs -> valid_block m b -> P b ofs) ->
  unchanged_on Q m m'.

End Mem.

Notation mem := Mem.mem.

Global Opaque Mem.alloc Mem.free Mem.store Mem.load Mem.storebytes Mem.loadbytes.

Hint Resolve
  Mem.valid_not_valid_diff
  Mem.perm_implies
  Mem.perm_cur
  Mem.perm_max
  Mem.perm_valid_block
  Mem.range_perm_implies
  Mem.range_perm_cur
  Mem.range_perm_max
  Mem.valid_access_implies
  Mem.valid_access_valid_block
  Mem.valid_access_perm
  Mem.valid_access_load
  Mem.load_valid_access
  Mem.loadbytes_range_perm
  Mem.valid_access_store
  Mem.perm_store_1
  Mem.perm_store_2
  Mem.nextblock_store
  Mem.store_valid_block_1
  Mem.store_valid_block_2
  Mem.store_valid_access_1
  Mem.store_valid_access_2
  Mem.store_valid_access_3
  Mem.storebytes_range_perm
  Mem.perm_storebytes_1
  Mem.perm_storebytes_2
  Mem.storebytes_valid_access_1
  Mem.storebytes_valid_access_2
  Mem.nextblock_storebytes
  Mem.storebytes_valid_block_1
  Mem.storebytes_valid_block_2
  Mem.nextblock_alloc
  Mem.alloc_result
  Mem.valid_block_alloc
  Mem.fresh_block_alloc
  Mem.valid_new_block
  Mem.perm_alloc_1
  Mem.perm_alloc_2
  Mem.perm_alloc_3
  Mem.perm_alloc_4
  Mem.perm_alloc_inv
  Mem.valid_access_alloc_other
  Mem.valid_access_alloc_same
  Mem.valid_access_alloc_inv
  Mem.range_perm_free
  Mem.free_range_perm
  Mem.nextblock_free
  Mem.valid_block_free_1
  Mem.valid_block_free_2
  Mem.perm_free_1
  Mem.perm_free_2
  Mem.perm_free_3
  Mem.valid_access_free_1
  Mem.valid_access_free_2
  Mem.valid_access_free_inv_1
  Mem.valid_access_free_inv_2
  Mem.unchanged_on_refl
: mem. *)

Require Import compcert.common.Values.
(* compcert.common.Values:
Require Import Coqlib.
Require Import AST.
Require Import Integers.
Require Import Floats.

Definition block : Type := positive.
Definition eq_block := peq.

Inductive val: Type :=
  | Vundef: val
  | Vint: int -> val
  | Vlong: int64 -> val
  | Vfloat: float -> val
  | Vsingle: float32 -> val
  | Vptr: block -> ptrofs -> val.

Definition Vzero: val := Vint Int.zero.
Definition Vone: val := Vint Int.one.
Definition Vmone: val := Vint Int.mone.

Definition Vtrue: val := Vint Int.one.
Definition Vfalse: val := Vint Int.zero.

Definition Vnullptr :=
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition Vptrofs (n: ptrofs) :=
  if Archi.ptr64 then Vlong (Ptrofs.to_int64 n) else Vint (Ptrofs.to_int n).

Module Val.

Definition eq (x y: val): {x=y} + {x<>y}.
Global Opaque eq.

Definition has_type (v: val) (t: typ) : Prop :=
  match v, t with
  | Vundef, _ => True
  | Vint _, Tint => True
  | Vlong _, Tlong => True
  | Vfloat _, Tfloat => True
  | Vsingle _, Tsingle => True
  | Vptr _ _, Tint => Archi.ptr64 = false
  | Vptr _ _, Tlong => Archi.ptr64 = true
  | (Vint _ | Vsingle _), Tany32 => True
  | Vptr _ _, Tany32 => Archi.ptr64 = false
  | _, Tany64 => True
  | _, _ => False
  end.

Fixpoint has_type_list (vl: list val) (tl: list typ) {struct vl} : Prop :=
  match vl, tl with
  | nil, nil => True
  | v1 :: vs, t1 :: ts => has_type v1 t1 /\ has_type_list vs ts
  | _, _ => False
  end.

Definition has_opttype (v: val) (ot: option typ) : Prop :=
  match ot with
  | None => v = Vundef
  | Some t => has_type v t
  end.

Lemma Vptr_has_type:
  forall b ofs, has_type (Vptr b ofs) Tptr.

Lemma Vnullptr_has_type:
  has_type Vnullptr Tptr.

Lemma has_subtype:
  forall ty1 ty2 v,
  subtype ty1 ty2 = true -> has_type v ty1 -> has_type v ty2.

Lemma has_subtype_list:
  forall tyl1 tyl2 vl,
  subtype_list tyl1 tyl2 = true -> has_type_list vl tyl1 -> has_type_list vl tyl2.

Inductive bool_of_val: val -> bool -> Prop :=
  | bool_of_val_int:
      forall n, bool_of_val (Vint n) (negb (Int.eq n Int.zero)).

Definition neg (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition negf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.neg f)
  | _ => Vundef
  end.

Definition absf (v: val) : val :=
  match v with
  | Vfloat f => Vfloat (Float.abs f)
  | _ => Vundef
  end.

Definition negfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.neg f)
  | _ => Vundef
  end.

Definition absfs (v: val) : val :=
  match v with
  | Vsingle f => Vsingle (Float32.abs f)
  | _ => Vundef
  end.

Definition maketotal (ov: option val) : val :=
  match ov with Some v => v | None => Vundef end.

Definition intoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_int f)
  | _ => None
  end.

Definition intuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vint (Float.to_intu f)
  | _ => None
  end.

Definition floatofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_int n))
  | _ => None
  end.

Definition floatofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vfloat (Float.of_intu n))
  | _ => None
  end.

Definition intofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_int f)
  | _ => None
  end.

Definition intuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vint (Float32.to_intu f)
  | _ => None
  end.

Definition singleofint (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_int n))
  | _ => None
  end.

Definition singleofintu (v: val) : option val :=
  match v with
  | Vint n => Some (Vsingle (Float32.of_intu n))
  | _ => None
  end.

Definition negint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.neg n)
  | _ => Vundef
  end.

Definition notint (v: val) : val :=
  match v with
  | Vint n => Vint (Int.not n)
  | _ => Vundef
  end.

Definition of_bool (b: bool): val := if b then Vtrue else Vfalse.

Definition boolval (v: val) : val :=
  match v with
  | Vint n => of_bool (negb (Int.eq n Int.zero))
  | Vptr b ofs => Vtrue
  | _ => Vundef
  end.

Definition notbool (v: val) : val :=
  match v with
  | Vint n => of_bool (Int.eq n Int.zero)
  | Vptr b ofs => Vfalse
  | _ => Vundef
  end.

Definition zero_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.zero_ext nbits n)
  | _ => Vundef
  end.

Definition sign_ext (nbits: Z) (v: val) : val :=
  match v with
  | Vint n => Vint(Int.sign_ext nbits n)
  | _ => Vundef
  end.

Definition singleoffloat (v: val) : val :=
  match v with
  | Vfloat f => Vsingle (Float.to_single f)
  | _ => Vundef
  end.

Definition floatofsingle (v: val) : val :=
  match v with
  | Vsingle f => Vfloat (Float.of_single f)
  | _ => Vundef
  end.

Definition add (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.add n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int n2))
  | Vint n1, Vptr b2 ofs2 => if Archi.ptr64 then Vundef else Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int n1))
  | _, _ => Vundef
  end.

Definition sub (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub n1 n2)
  | Vptr b1 ofs1, Vint n2 => if Archi.ptr64 then Vundef else Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int n2))
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vint(Ptrofs.to_int (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mul (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mulhs (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mulhu (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divs (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.divs n1 n2))
  | _, _ => None
  end.

Definition mods (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero
      || Int.eq n1 (Int.repr Int.min_signed) && Int.eq n2 Int.mone
      then None
      else Some(Vint(Int.mods n1 n2))
  | _, _ => None
  end.

Definition divu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.divu n1 n2))
  | _, _ => None
  end.

Definition modu (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      if Int.eq n2 Int.zero then None else Some(Vint(Int.modu n1 n2))
  | _, _ => None
  end.

Definition add_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vint n1, Vint n2, Vint c => Vint(Int.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition sub_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.sub_overflow n1 n2 Int.zero)
  | _, _ => Vundef
  end.

Definition negative (v: val) : val :=
  match v with
  | Vint n => Vint (Int.negative n)
  | _ => Vundef
  end.

Definition and (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.and n1 n2)
  | _, _ => Vundef
  end.

Definition or (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.or n1 n2)
  | _, _ => Vundef
  end.

Definition xor (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shl (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shl n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shr_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shr_carry n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrx (v1 v2: val): option val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 31)
     then Some(Vint(Int.shrx n1 n2))
     else None
  | _, _ => None
  end.

Definition shru (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
     if Int.ltu n2 Int.iwordsize
     then Vint(Int.shru n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition rol (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.rol n1 n2)
  | _, _ => Vundef
  end.

Definition rolm (v: val) (amount mask: int): val :=
  match v with
  | Vint n => Vint(Int.rolm n amount mask)
  | _ => Vundef
  end.

Definition ror (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vint(Int.ror n1 n2)
  | _, _ => Vundef
  end.

Definition addf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.add f1 f2)
  | _, _ => Vundef
  end.

Definition subf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divf (v1 v2: val): val :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Vfloat(Float.div f1 f2)
  | _, _ => Vundef
  end.

Definition floatofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vfloat (Float.from_words n1 n2)
  | _, _ => Vundef
  end.

Definition addfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.add f1 f2)
  | _, _ => Vundef
  end.

Definition subfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.sub f1 f2)
  | _, _ => Vundef
  end.

Definition mulfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.mul f1 f2)
  | _, _ => Vundef
  end.

Definition divfs (v1 v2: val): val :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Vsingle(Float32.div f1 f2)
  | _, _ => Vundef
  end.

Definition longofwords (v1 v2: val) : val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong (Int64.ofwords n1 n2)
  | _, _ => Vundef
  end.

Definition loword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.loword n)
  | _ => Vundef
  end.

Definition hiword (v: val) : val :=
  match v with
  | Vlong n  => Vint (Int64.hiword n)
  | _ => Vundef
  end.

Definition negl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.neg n)
  | _ => Vundef
  end.

Definition notl (v: val) : val :=
  match v with
  | Vlong n => Vlong (Int64.not n)
  | _ => Vundef
  end.

Definition longofint (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.signed n))
  | _ => Vundef
  end.

Definition longofintu (v: val) : val :=
  match v with
  | Vint n => Vlong (Int64.repr (Int.unsigned n))
  | _ => Vundef
  end.

Definition longoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_long f)
  | _ => None
  end.

Definition longuoffloat (v: val) : option val :=
  match v with
  | Vfloat f => option_map Vlong (Float.to_longu f)
  | _ => None
  end.

Definition longofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_long f)
  | _ => None
  end.

Definition longuofsingle (v: val) : option val :=
  match v with
  | Vsingle f => option_map Vlong (Float32.to_longu f)
  | _ => None
  end.

Definition floatoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_long n))
  | _ => None
  end.

Definition floatoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vfloat (Float.of_longu n))
  | _ => None
  end.

Definition singleoflong (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_long n))
  | _ => None
  end.

Definition singleoflongu (v: val) : option val :=
  match v with
  | Vlong n => Some (Vsingle (Float32.of_longu n))
  | _ => None
  end.

Definition addl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.add n1 n2)
  | Vptr b1 ofs1, Vlong n2 => if Archi.ptr64 then Vptr b1 (Ptrofs.add ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vlong n1, Vptr b2 ofs2 => if Archi.ptr64 then Vptr b2 (Ptrofs.add ofs2 (Ptrofs.of_int64 n1)) else Vundef
  | _, _ => Vundef
  end.

Definition subl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.sub n1 n2)
  | Vptr b1 ofs1, Vlong n2 =>
      if Archi.ptr64 then Vptr b1 (Ptrofs.sub ofs1 (Ptrofs.of_int64 n2)) else Vundef
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then Vundef else
      if eq_block b1 b2 then Vlong(Ptrofs.to_int64 (Ptrofs.sub ofs1 ofs2)) else Vundef
  | _, _ => Vundef
  end.

Definition mull (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mul n1 n2)
  | _, _ => Vundef
  end.

Definition mull' (v1 v2: val): val :=
  match v1, v2 with
  | Vint n1, Vint n2 => Vlong(Int64.mul' n1 n2)
  | _, _ => Vundef
  end.

Definition mullhs (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhs n1 n2)
  | _, _ => Vundef
  end.

Definition mullhu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.mulhu n1 n2)
  | _, _ => Vundef
  end.

Definition divls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.divs n1 n2))
  | _, _ => None
  end.

Definition modls (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero
      || Int64.eq n1 (Int64.repr Int64.min_signed) && Int64.eq n2 Int64.mone
      then None
      else Some(Vlong(Int64.mods n1 n2))
  | _, _ => None
  end.

Definition divlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.divu n1 n2))
  | _, _ => None
  end.

Definition modlu (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 =>
      if Int64.eq n2 Int64.zero then None else Some(Vlong(Int64.modu n1 n2))
  | _, _ => None
  end.

Definition addl_carry (v1 v2 cin: val): val :=
  match v1, v2, cin with
  | Vlong n1, Vlong n2, Vlong c => Vlong(Int64.add_carry n1 n2 c)
  | _, _, _ => Vundef
  end.

Definition subl_overflow (v1 v2: val) : val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vint (Int.repr (Int64.unsigned (Int64.sub_overflow n1 n2 Int64.zero)))
  | _, _ => Vundef
  end.

Definition negativel (v: val) : val :=
  match v with
  | Vlong n => Vint (Int.repr (Int64.unsigned (Int64.negative n)))
  | _ => Vundef
  end.

Definition andl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.and n1 n2)
  | _, _ => Vundef
  end.

Definition orl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.or n1 n2)
  | _, _ => Vundef
  end.

Definition xorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Vlong(Int64.xor n1 n2)
  | _, _ => Vundef
  end.

Definition shll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shl' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrlu (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shru' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition shrxl (v1 v2: val): option val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 (Int.repr 63)
     then Some(Vlong(Int64.shrx' n1 n2))
     else None
  | _, _ => None
  end.

Definition shrl_carry (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 =>
     if Int.ltu n2 Int64.iwordsize'
     then Vlong(Int64.shr_carry' n1 n2)
     else Vundef
  | _, _ => Vundef
  end.

Definition roll (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.rol n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rorl (v1 v2: val): val :=
  match v1, v2 with
  | Vlong n1, Vint n2 => Vlong(Int64.ror n1 (Int64.repr (Int.unsigned n2)))
  | _, _ => Vundef
  end.

Definition rolml (v: val) (amount: int) (mask: int64): val :=
  match v with
  | Vlong n => Vlong(Int64.rolm n (Int64.repr (Int.unsigned amount)) mask)
  | _ => Vundef
  end.

Section COMPARISONS.

Variable valid_ptr: block -> Z -> bool.
Let weak_valid_ptr (b: block) (ofs: Z) := valid_ptr b ofs || valid_ptr b (ofs - 1).

Definition cmp_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 => Some (Int.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmp_different_blocks (c: comparison): option bool :=
  match c with
  | Ceq => Some false
  | Cne => Some true
  | _   => None
  end.

Definition cmpu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vint n1, Vint n2 =>
      Some (Int.cmpu c n1 n2)
  | Vint n1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if Int.eq n1 Int.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vint n2 =>
      if Archi.ptr64 then None else
      if Int.eq n2 Int.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition cmpf_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vfloat f1, Vfloat f2 => Some (Float.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpfs_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vsingle f1, Vsingle f2 => Some (Float32.cmp c f1 f2)
  | _, _ => None
  end.

Definition cmpl_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmp c n1 n2)
  | _, _ => None
  end.

Definition cmplu_bool (c: comparison) (v1 v2: val): option bool :=
  match v1, v2 with
  | Vlong n1, Vlong n2 => Some (Int64.cmpu c n1 n2)
  | Vlong n1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n1 Int64.zero && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
      then cmp_different_blocks c
      else None
  | Vptr b1 ofs1, Vptr b2 ofs2 =>
      if negb Archi.ptr64 then None else
      if eq_block b1 b2 then
        if weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
           && weak_valid_ptr b2 (Ptrofs.unsigned ofs2)
        then Some (Ptrofs.cmpu c ofs1 ofs2)
        else None
      else
        if valid_ptr b1 (Ptrofs.unsigned ofs1)
           && valid_ptr b2 (Ptrofs.unsigned ofs2)
        then cmp_different_blocks c
        else None
  | Vptr b1 ofs1, Vlong n2 =>
      if negb Archi.ptr64 then None else
      if Int64.eq n2 Int64.zero && weak_valid_ptr b1 (Ptrofs.unsigned ofs1)
      then cmp_different_blocks c
      else None
  | _, _ => None
  end.

Definition of_optbool (ob: option bool): val :=
  match ob with Some true => Vtrue | Some false => Vfalse | None => Vundef end.

Definition cmp (c: comparison) (v1 v2: val): val :=
  of_optbool (cmp_bool c v1 v2).

Definition cmpu (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpu_bool c v1 v2).

Definition cmpf (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpf_bool c v1 v2).

Definition cmpfs (c: comparison) (v1 v2: val): val :=
  of_optbool (cmpfs_bool c v1 v2).

Definition cmpl (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmpl_bool c v1 v2).

Definition cmplu (c: comparison) (v1 v2: val): option val :=
  option_map of_bool (cmplu_bool c v1 v2).

Definition maskzero_bool (v: val) (mask: int): option bool :=
  match v with
  | Vint n => Some (Int.eq (Int.and n mask) Int.zero)
  | _ => None
  end.

End COMPARISONS.

Definition offset_ptr (v: val) (delta: ptrofs) : val :=
  match v with
  | Vptr b ofs => Vptr b (Ptrofs.add ofs delta)
  | _ => Vundef
  end.

Definition load_result (chunk: memory_chunk) (v: val) :=
  match chunk, v with
  | Mint8signed, Vint n => Vint (Int.sign_ext 8 n)
  | Mint8unsigned, Vint n => Vint (Int.zero_ext 8 n)
  | Mint16signed, Vint n => Vint (Int.sign_ext 16 n)
  | Mint16unsigned, Vint n => Vint (Int.zero_ext 16 n)
  | Mint32, Vint n => Vint n
  | Mint32, Vptr b ofs => if Archi.ptr64 then Vundef else Vptr b ofs
  | Mint64, Vlong n => Vlong n
  | Mint64, Vptr b ofs => if Archi.ptr64 then Vptr b ofs else Vundef
  | Mfloat32, Vsingle f => Vsingle f
  | Mfloat64, Vfloat f => Vfloat f
  | Many32, (Vint _ | Vsingle _) => v
  | Many32, Vptr _ _ => if Archi.ptr64 then Vundef else v
  | Many64, _ => v
  | _, _ => Vundef
  end.

Lemma load_result_type:
  forall chunk v, has_type (load_result chunk v) (type_of_chunk chunk).

Lemma load_result_same:
  forall v ty, has_type v ty -> load_result (chunk_of_type ty) v = v.

Theorem cast8unsigned_and:
  forall x, zero_ext 8 x = and x (Vint(Int.repr 255)).

Theorem cast16unsigned_and:
  forall x, zero_ext 16 x = and x (Vint(Int.repr 65535)).

Theorem bool_of_val_of_bool:
  forall b1 b2, bool_of_val (of_bool b1) b2 -> b1 = b2.

Theorem bool_of_val_of_optbool:
  forall ob b, bool_of_val (of_optbool ob) b -> ob = Some b.

Theorem notbool_negb_1:
  forall b, of_bool (negb b) = notbool (of_bool b).

Theorem notbool_negb_2:
  forall b, of_bool b = notbool (of_bool (negb b)).

Theorem notbool_negb_3:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem notbool_idem2:
  forall b, notbool(notbool(of_bool b)) = of_bool b.

Theorem notbool_idem3:
  forall x, notbool(notbool(notbool x)) = notbool x.

Theorem notbool_idem4:
  forall ob, notbool (notbool (of_optbool ob)) = of_optbool ob.

Theorem add_commut: forall x y, add x y = add y x.

Theorem add_assoc: forall x y z, add (add x y) z = add x (add y z).

Theorem add_permut: forall x y z, add x (add y z) = add y (add x z).

Theorem add_permut_4:
  forall x y z t, add (add x y) (add z t) = add (add x z) (add y t).

Theorem neg_zero: neg Vzero = Vzero.

Theorem neg_add_distr: forall x y, neg(add x y) = add (neg x) (neg y).

Theorem sub_zero_r: forall x, sub Vzero x = neg x.

Theorem sub_add_opp: forall x y, sub x (Vint y) = add x (Vint (Int.neg y)).

Theorem sub_opp_add: forall x y, sub x (Vint (Int.neg y)) = add x (Vint y).

Theorem sub_add_l:
  forall v1 v2 i, sub (add v1 (Vint i)) v2 = add (sub v1 v2) (Vint i).

Theorem sub_add_r:
  forall v1 v2 i, sub v1 (add v2 (Vint i)) = add (sub v1 v2) (Vint (Int.neg i)).

Theorem mul_commut: forall x y, mul x y = mul y x.

Theorem mul_assoc: forall x y z, mul (mul x y) z = mul x (mul y z).

Theorem mul_add_distr_l:
  forall x y z, mul (add x y) z = add (mul x z) (mul y z).

Theorem mul_add_distr_r:
  forall x y z, mul x (add y z) = add (mul x y) (mul x z).

Theorem mul_pow2:
  forall x n logn,
  Int.is_power2 n = Some logn ->

Theorem mods_divs:
  forall x y z,
  mods x y = Some z -> exists v, divs x y = Some v /\ z = sub x (mul v y).

Theorem modu_divu:
  forall x y z,
  modu x y = Some z -> exists v, divu x y = Some v /\ z = sub x (mul v y).

Theorem modls_divls:
  forall x y z,
  modls x y = Some z -> exists v, divls x y = Some v /\ z = subl x (mull v y).

Theorem modlu_divlu:
  forall x y z,
  modlu x y = Some z -> exists v, divlu x y = Some v /\ z = subl x (mull v y).

Theorem divs_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn -> Int.ltu logn (Int.repr 31) = true ->

Theorem divs_one:
  forall s , divs (Vint s) (Vint Int.one) = Some (Vint s).

Theorem divu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem divu_one:
  forall s, divu (Vint s) (Vint Int.one) = Some (Vint s).

Theorem modu_pow2:
  forall x n logn y,
  Int.is_power2 n = Some logn ->

Theorem and_commut: forall x y, and x y = and y x.

Theorem and_assoc: forall x y z, and (and x y) z = and x (and y z).

Theorem or_commut: forall x y, or x y = or y x.

Theorem or_assoc: forall x y z, or (or x y) z = or x (or y z).

Theorem xor_commut: forall x y, xor x y = xor y x.

Theorem xor_assoc: forall x y z, xor (xor x y) z = xor x (xor y z).

Theorem not_xor: forall x, notint x = xor x (Vint Int.mone).

Theorem shl_mul: forall x y, mul x (shl Vone y) = shl x y.

Theorem shl_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shll_rolml:
  forall x n,
  Int.ltu n Int64.iwordsize' = true ->

Theorem shru_rolm:
  forall x n,
  Int.ltu n Int.iwordsize = true ->

Theorem shrlu_rolml:
  forall x n,
    Int.ltu n Int64.iwordsize' = true ->

Theorem shrx_carry:
  forall x y z,
  shrx x y = Some z ->
  add (shr x y) (shr_carry x y) = z.

Theorem shrx_shr:
  forall x y z,
  shrx x y = Some z ->
  exists p, exists q,
    x = Vint p /\ y = Vint q /\
    z = shr (if Int.lt p Int.zero then add x (Vint (Int.sub (Int.shl Int.one q) Int.one)) else x) (Vint q).

Theorem shrx_shr_2:
  forall n x z,
  shrx x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem or_rolm:
  forall x n m1 m2,
  or (rolm x n m1) (rolm x n m2) = rolm x n (Int.or m1 m2).

Theorem rolm_rolm:
  forall x n1 m1 n2 m2,
  rolm (rolm x n1 m1) n2 m2 =
    rolm x (Int.modu (Int.add n1 n2) Int.iwordsize)

Theorem rolm_zero:
  forall x m,
  rolm x Int.zero m = and x (Vint m).

Theorem addl_commut: forall x y, addl x y = addl y x.

Theorem addl_assoc: forall x y z, addl (addl x y) z = addl x (addl y z).

Theorem addl_permut: forall x y z, addl x (addl y z) = addl y (addl x z).

Theorem addl_permut_4:
  forall x y z t, addl (addl x y) (addl z t) = addl (addl x z) (addl y t).

Theorem negl_addl_distr: forall x y, negl(addl x y) = addl (negl x) (negl y).

Theorem subl_addl_opp: forall x y, subl x (Vlong y) = addl x (Vlong (Int64.neg y)).

Theorem subl_opp_addl: forall x y, subl x (Vlong (Int64.neg y)) = addl x (Vlong y).

Theorem subl_addl_l:
  forall v1 v2 i, subl (addl v1 (Vlong i)) v2 = addl (subl v1 v2) (Vlong i).

Theorem subl_addl_r:
  forall v1 v2 i, subl v1 (addl v2 (Vlong i)) = addl (subl v1 v2) (Vlong (Int64.neg i)).

Theorem mull_commut: forall x y, mull x y = mull y x.

Theorem mull_assoc: forall x y z, mull (mull x y) z = mull x (mull y z).

Theorem mull_addl_distr_l:
  forall x y z, mull (addl x y) z = addl (mull x z) (mull y z).

Theorem mull_addl_distr_r:
  forall x y z, mull x (addl y z) = addl (mull x y) (mull x z).

Theorem andl_commut: forall x y, andl x y = andl y x.

Theorem andl_assoc: forall x y z, andl (andl x y) z = andl x (andl y z).

Theorem orl_commut: forall x y, orl x y = orl y x.

Theorem orl_assoc: forall x y z, orl (orl x y) z = orl x (orl y z).

Theorem xorl_commut: forall x y, xorl x y = xorl y x.

Theorem xorl_assoc: forall x y z, xorl (xorl x y) z = xorl x (xorl y z).

Theorem notl_xorl: forall x, notl x = xorl x (Vlong Int64.mone).

Theorem divls_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn -> Int.ltu logn (Int.repr 63) = true ->

Theorem divls_one:
  forall n, divls (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem divlu_pow2:
  forall x n logn y,
  Int64.is_power2' n = Some logn ->

Theorem divlu_one:
  forall n, divlu (Vlong n) (Vlong Int64.one) = Some (Vlong n).

Theorem modlu_pow2:
  forall x n logn y,
  Int64.is_power2 n = Some logn ->

Theorem shrxl_carry:
  forall x y z,
  shrxl x y = Some z ->
  addl (shrl x y) (shrl_carry x y) = z.

Theorem shrxl_shrl_2:
  forall n x z,
  shrxl x (Vint n) = Some z ->
  z = (if Int.eq n Int.zero then x else

Theorem negate_cmp_bool:
  forall c x y, cmp_bool (negate_comparison c) x y = option_map negb (cmp_bool c x y).

Theorem negate_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmpu_bool valid_ptr c x y).

Theorem negate_cmpl_bool:
  forall c x y, cmpl_bool (negate_comparison c) x y = option_map negb (cmpl_bool c x y).

Theorem negate_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (negate_comparison c) x y = option_map negb (cmplu_bool valid_ptr c x y).

Lemma not_of_optbool:
  forall ob, of_optbool (option_map negb ob) = notbool (of_optbool ob).

Theorem negate_cmp:
  forall c x y,
  cmp (negate_comparison c) x y = notbool (cmp c x y).

Theorem negate_cmpu:
  forall valid_ptr c x y,
  cmpu valid_ptr (negate_comparison c) x y =
    notbool (cmpu valid_ptr c x y).

Theorem swap_cmp_bool:
  forall c x y,
  cmp_bool (swap_comparison c) x y = cmp_bool c y x.

Theorem swap_cmpu_bool:
  forall valid_ptr c x y,
  cmpu_bool valid_ptr (swap_comparison c) x y =
    cmpu_bool valid_ptr c y x.

Theorem swap_cmpl_bool:
  forall c x y,
  cmpl_bool (swap_comparison c) x y = cmpl_bool c y x.

Theorem swap_cmplu_bool:
  forall valid_ptr c x y,
  cmplu_bool valid_ptr (swap_comparison c) x y = cmplu_bool valid_ptr c y x.

Theorem negate_cmpf_eq:
  forall v1 v2, notbool (cmpf Cne v1 v2) = cmpf Ceq v1 v2.

Theorem negate_cmpf_ne:
  forall v1 v2, notbool (cmpf Ceq v1 v2) = cmpf Cne v1 v2.

Theorem cmpf_le:
  forall v1 v2, cmpf Cle v1 v2 = or (cmpf Clt v1 v2) (cmpf Ceq v1 v2).

Theorem cmpf_ge:
  forall v1 v2, cmpf Cge v1 v2 = or (cmpf Cgt v1 v2) (cmpf Ceq v1 v2).

Theorem cmp_ne_0_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmp_eq_1_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmp_eq_0_optbool:
  forall ob, cmp Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmp_ne_1_optbool:
  forall ob, cmp Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Theorem cmpu_ne_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.zero) = of_optbool ob.

Theorem cmpu_eq_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.one) = of_optbool ob.

Theorem cmpu_eq_0_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Ceq (of_optbool ob) (Vint Int.zero) = of_optbool (option_map negb ob).

Theorem cmpu_ne_1_optbool:
  forall valid_ptr ob,
  cmpu valid_ptr Cne (of_optbool ob) (Vint Int.one) = of_optbool (option_map negb ob).

Lemma zero_ext_and:
  forall n v,
  0 < n < Int.zwordsize ->

Lemma rolm_lt_zero:
  forall v, rolm v Int.one Int.one = cmp Clt v (Vint Int.zero).

Lemma rolm_ge_zero:
  forall v,
  xor (rolm v Int.one Int.one) (Vint Int.one) = cmp Cge v (Vint Int.zero).

Inductive lessdef: val -> val -> Prop :=
  | lessdef_refl: forall v, lessdef v v
  | lessdef_undef: forall v, lessdef Vundef v.

Lemma lessdef_same:
  forall v1 v2, v1 = v2 -> lessdef v1 v2.

Lemma lessdef_trans:
  forall v1 v2 v3, lessdef v1 v2 -> lessdef v2 v3 -> lessdef v1 v3.

Inductive lessdef_list: list val -> list val -> Prop :=
  | lessdef_list_nil:
      lessdef_list nil nil
  | lessdef_list_cons:
      forall v1 v2 vl1 vl2,
      lessdef v1 v2 -> lessdef_list vl1 vl2 ->
      lessdef_list (v1 :: vl1) (v2 :: vl2).

Hint Resolve lessdef_refl lessdef_undef lessdef_list_nil lessdef_list_cons.

Lemma lessdef_list_inv:
  forall vl1 vl2, lessdef_list vl1 vl2 -> vl1 = vl2 \/ In Vundef vl1.

Lemma lessdef_list_trans:
  forall vl1 vl2, lessdef_list vl1 vl2 -> forall vl3, lessdef_list vl2 vl3 -> lessdef_list vl1 vl3.

Lemma load_result_lessdef:
  forall chunk v1 v2,
  lessdef v1 v2 -> lessdef (load_result chunk v1) (load_result chunk v2).

Lemma zero_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (zero_ext n v1) (zero_ext n v2).

Lemma sign_ext_lessdef:
  forall n v1 v2, lessdef v1 v2 -> lessdef (sign_ext n v1) (sign_ext n v2).

Lemma singleoffloat_lessdef:
  forall v1 v2, lessdef v1 v2 -> lessdef (singleoffloat v1) (singleoffloat v2).

Lemma add_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (add v1 v2) (add v1' v2').

Lemma addl_lessdef:
  forall v1 v1' v2 v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (addl v1 v2) (addl v1' v2').

Lemma cmpu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmpu_bool valid_ptr c v1 v2 = Some b ->
  cmpu_bool valid_ptr' c v1' v2' = Some b.

Lemma cmplu_bool_lessdef:
  forall valid_ptr valid_ptr' c v1 v1' v2 v2' b,
  (forall b ofs, valid_ptr b ofs = true -> valid_ptr' b ofs = true) ->
  lessdef v1 v1' -> lessdef v2 v2' ->
  cmplu_bool valid_ptr c v1 v2 = Some b ->
  cmplu_bool valid_ptr' c v1' v2' = Some b.

Lemma of_optbool_lessdef:
  forall ob ob',
  (forall b, ob = Some b -> ob' = Some b) ->
  lessdef (of_optbool ob) (of_optbool ob').

Lemma longofwords_lessdef:
  forall v1 v2 v1' v2',
  lessdef v1 v1' -> lessdef v2 v2' -> lessdef (longofwords v1 v2) (longofwords v1' v2').

Lemma loword_lessdef:
  forall v v', lessdef v v' -> lessdef (loword v) (loword v').

Lemma hiword_lessdef:
  forall v v', lessdef v v' -> lessdef (hiword v) (hiword v').

Lemma offset_ptr_zero:
  forall v, lessdef (offset_ptr v Ptrofs.zero) v.

Lemma offset_ptr_assoc:
  forall v d1 d2, offset_ptr (offset_ptr v d1) d2 = offset_ptr v (Ptrofs.add d1 d2).

Definition meminj : Type := block -> option (block * Z).

Inductive inject (mi: meminj): val -> val -> Prop :=
  | inject_int:
      forall i, inject mi (Vint i) (Vint i)
  | inject_long:
      forall i, inject mi (Vlong i) (Vlong i)
  | inject_float:
      forall f, inject mi (Vfloat f) (Vfloat f)
  | inject_single:
      forall f, inject mi (Vsingle f) (Vsingle f)
  | inject_ptr:
      forall b1 ofs1 b2 ofs2 delta,
      mi b1 = Some (b2, delta) ->
      ofs2 = Ptrofs.add ofs1 (Ptrofs.repr delta) ->
      inject mi (Vptr b1 ofs1) (Vptr b2 ofs2)
  | val_inject_undef: forall v,
      inject mi Vundef v.

Hint Constructors inject.

Inductive inject_list (mi: meminj): list val -> list val-> Prop:=
  | inject_list_nil :
      inject_list mi nil nil
  | inject_list_cons : forall v v' vl vl' ,
      inject mi v v' -> inject_list mi vl vl'->
      inject_list mi (v :: vl) (v' :: vl').

Hint Resolve inject_list_nil inject_list_cons.

Lemma inject_ptrofs:
  forall mi i, inject mi (Vptrofs i) (Vptrofs i).

Hint Resolve inject_ptrofs.

Section VAL_INJ_OPS.

Variable f: meminj.

Lemma load_result_inject:
  forall chunk v1 v2,
  inject f v1 v2 ->
  inject f (Val.load_result chunk v1) (Val.load_result chunk v2).

Remark add_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.add v1 v2) (Val.add v1' v2').

Remark sub_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.sub v1 v2) (Val.sub v1' v2').

Remark addl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.addl v1 v2) (Val.addl v1' v2').

Remark subl_inject:
  forall v1 v1' v2 v2',
  inject f v1 v1' ->
  inject f v2 v2' ->
  inject f (Val.subl v1 v2) (Val.subl v1' v2').

Lemma offset_ptr_inject:
  forall v v' ofs, inject f v v' -> inject f (offset_ptr v ofs) (offset_ptr v' ofs).

Lemma cmp_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmp_bool c v1 v2 = Some b ->

Variable (valid_ptr1 valid_ptr2 : block -> Z -> bool).

Let weak_valid_ptr1 b ofs := valid_ptr1 b ofs || valid_ptr1 b (ofs - 1).
Let weak_valid_ptr2 b ofs := valid_ptr2 b ofs || valid_ptr2 b (ofs - 1).

Hypothesis valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_inj:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  weak_valid_ptr2 b2 (Ptrofs.unsigned (Ptrofs.add ofs (Ptrofs.repr delta))) = true.

Hypothesis weak_valid_ptr_no_overflow:
  forall b1 ofs b2 delta,
  f b1 = Some(b2, delta) ->
  weak_valid_ptr1 b1 (Ptrofs.unsigned ofs) = true ->
  0 <= Ptrofs.unsigned ofs + Ptrofs.unsigned (Ptrofs.repr delta) <= Ptrofs.max_unsigned.

Hypothesis valid_different_ptrs_inj:
  forall b1 ofs1 b2 ofs2 b1' delta1 b2' delta2,
  b1 <> b2 ->
  valid_ptr1 b1 (Ptrofs.unsigned ofs1) = true ->
  valid_ptr1 b2 (Ptrofs.unsigned ofs2) = true ->
  f b1 = Some (b1', delta1) ->
  f b2 = Some (b2', delta2) ->
  b1' <> b2' \/
  Ptrofs.unsigned (Ptrofs.add ofs1 (Ptrofs.repr delta1)) <> Ptrofs.unsigned (Ptrofs.add ofs2 (Ptrofs.repr delta2)).

Lemma cmpu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmpu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma cmplu_bool_inject:
  forall c v1 v2 v1' v2' b,
  inject f v1 v1' ->
  inject f v2 v2' ->
  Val.cmplu_bool valid_ptr1 c v1 v2 = Some b ->

Lemma longofwords_inject:
  forall v1 v2 v1' v2',
  inject f v1 v1' -> inject f v2 v2' -> inject f (Val.longofwords v1 v2) (Val.longofwords v1' v2').

Lemma loword_inject:
  forall v v', inject f v v' -> inject f (Val.loword v) (Val.loword v').

Lemma hiword_inject:
  forall v v', inject f v v' -> inject f (Val.hiword v) (Val.hiword v').

End VAL_INJ_OPS.

End Val.

Notation meminj := Val.meminj.

Definition inject_incr (f1 f2: meminj) : Prop :=
  forall b b' delta, f1 b = Some(b', delta) -> f2 b = Some(b', delta).

Lemma inject_incr_refl :
   forall f , inject_incr f f .

Lemma inject_incr_trans :
  forall f1 f2 f3,
  inject_incr f1 f2 -> inject_incr f2 f3 -> inject_incr f1 f3 .

Lemma val_inject_incr:
  forall f1 f2 v v',
  inject_incr f1 f2 ->
  Val.inject f1 v v' ->

Lemma val_inject_list_incr:
  forall f1 f2 vl vl' ,
  inject_incr f1 f2 -> Val.inject_list f1 vl vl' ->

Hint Resolve inject_incr_refl val_inject_incr val_inject_list_incr.

Lemma val_inject_lessdef:
  forall v1 v2, Val.lessdef v1 v2 <-> Val.inject (fun b => Some(b, 0)) v1 v2.

Lemma val_inject_list_lessdef:
  forall vl1 vl2, Val.lessdef_list vl1 vl2 <-> Val.inject_list (fun b => Some(b, 0)) vl1 vl2.

Definition inject_id : meminj := fun b => Some(b, 0).

Lemma val_inject_id:
  forall v1 v2,
  Val.inject inject_id v1 v2 <-> Val.lessdef v1 v2.

Definition compose_meminj (f f': meminj) : meminj :=
  fun b =>
    match f b with
    | None => None
    | Some(b', delta) =>
        match f' b' with
        | None => None
        | Some(b'', delta') => Some(b'', delta + delta')
        end
    end.

Lemma val_inject_compose:
  forall f f' v1 v2 v3,
  Val.inject f v1 v2 -> Val.inject f' v2 v3 -> *)

Require Import compcert.cfrontend.Clight.
(* compcert.cfrontend.Clight:
Require Import Coqlib.
Require Import Errors.
Require Import Maps.
Require Import Integers.
Require Import Floats.
Require Import Values.
Require Import AST.
Require Import Memory.
Require Import Events.
Require Import Globalenvs.
Require Import Smallstep.
Require Import Ctypes.
Require Import Cop.

Inductive expr : Type :=
  | Econst_int: int -> type -> expr       
  | Econst_float: float -> type -> expr   
  | Econst_single: float32 -> type -> expr 
  | Econst_long: int64 -> type -> expr    
  | Evar: ident -> type -> expr           
  | Etempvar: ident -> type -> expr       
  | Ederef: expr -> type -> expr          
  | Eaddrof: expr -> type -> expr         
  | Eunop: unary_operation -> expr -> type -> expr  
  | Ebinop: binary_operation -> expr -> expr -> type -> expr 
  | Ecast: expr -> type -> expr   
  | Efield: expr -> ident -> type -> expr 
  | Esizeof: type -> type -> expr         
  | Ealignof: type -> type -> expr.       

Definition typeof (e: expr) : type :=
  match e with
  | Econst_int _ ty => ty
  | Econst_float _ ty => ty
  | Econst_single _ ty => ty
  | Econst_long _ ty => ty
  | Evar _ ty => ty
  | Etempvar _ ty => ty
  | Ederef _ ty => ty
  | Eaddrof _ ty => ty
  | Eunop _ _ ty => ty
  | Ebinop _ _ _ ty => ty
  | Ecast _ ty => ty
  | Efield _ _ ty => ty
  | Esizeof _ ty => ty
  | Ealignof _ ty => ty
  end.

Definition label := ident.

Inductive statement : Type :=
  | Sskip : statement                   
  | Sassign : expr -> expr -> statement 
  | Sset : ident -> expr -> statement   
  | Scall: option ident -> expr -> list expr -> statement 
  | Sbuiltin: option ident -> external_function -> typelist -> list expr -> statement 
  | Ssequence : statement -> statement -> statement  
  | Sifthenelse : expr  -> statement -> statement -> statement 
  | Sloop: statement -> statement -> statement 
  | Sbreak : statement                      
  | Scontinue : statement                   
  | Sreturn : option expr -> statement      
  | Sswitch : expr -> labeled_statements -> statement  
  | Slabel : label -> statement -> statement
  | Sgoto : label -> statement

with labeled_statements : Type :=            
  | LSnil: labeled_statements
  | LScons: option Z -> statement -> labeled_statements -> labeled_statements.
                      
Definition Swhile (e: expr) (s: statement) :=
  Sloop (Ssequence (Sifthenelse e Sskip Sbreak) s) Sskip.

Definition Sdowhile (s: statement) (e: expr) :=
  Sloop s (Sifthenelse e Sskip Sbreak).

Definition Sfor (s1: statement) (e2: expr) (s3: statement) (s4: statement) :=
  Ssequence s1 (Sloop (Ssequence (Sifthenelse e2 Sskip Sbreak) s3) s4).

Record function : Type := mkfunction {
  fn_return: type;
  fn_callconv: calling_convention;
  fn_params: list (ident * type);
  fn_vars: list (ident * type);
  fn_temps: list (ident * type);
  fn_body: statement
}.

Definition var_names (vars: list(ident * type)) : list ident :=
  List.map (@fst ident type) vars.

Definition fundef := Ctypes.fundef function.

Definition type_of_function (f: function) : type :=
  Tfunction (type_of_params (fn_params f)) (fn_return f) (fn_callconv f).

Definition type_of_fundef (f: fundef) : type :=
  match f with
  | Internal fd => type_of_function fd
  | External id args res cc => Tfunction args res cc
  end.

Definition program := Ctypes.program function.

Record genv := { genv_genv :> Genv.t fundef type; genv_cenv :> composite_env }.

Definition globalenv (p: program) :=
  {| genv_genv := Genv.globalenv p; genv_cenv := p.(prog_comp_env) |}.

Definition env := PTree.t (block * type). 

Definition empty_env: env := (PTree.empty (block * type)).

Definition temp_env := PTree.t val.

Inductive deref_loc (ty: type) (m: mem) (b: block) (ofs: ptrofs) : val -> Prop :=
  | deref_loc_value: forall chunk v,
      access_mode ty = By_value chunk ->
      Mem.loadv chunk m (Vptr b ofs) = Some v ->
      deref_loc ty m b ofs v
  | deref_loc_reference:
      access_mode ty = By_reference ->
      deref_loc ty m b ofs (Vptr b ofs)
  | deref_loc_copy:
      access_mode ty = By_copy ->
      deref_loc ty m b ofs (Vptr b ofs).

Inductive assign_loc (ce: composite_env) (ty: type) (m: mem) (b: block) (ofs: ptrofs):
                                            val -> mem -> Prop :=
  | assign_loc_value: forall v chunk m',
      access_mode ty = By_value chunk ->
      Mem.storev chunk m (Vptr b ofs) v = Some m' ->
      assign_loc ce ty m b ofs v m'
  | assign_loc_copy: forall b' ofs' bytes m',
      access_mode ty = By_copy ->
      (sizeof ce ty > 0 -> (alignof_blockcopy ce ty | Ptrofs.unsigned ofs')) ->
      (sizeof ce ty > 0 -> (alignof_blockcopy ce ty | Ptrofs.unsigned ofs)) ->
      b' <> b \/ Ptrofs.unsigned ofs' = Ptrofs.unsigned ofs
              \/ Ptrofs.unsigned ofs' + sizeof ce ty <= Ptrofs.unsigned ofs
              \/ Ptrofs.unsigned ofs + sizeof ce ty <= Ptrofs.unsigned ofs' ->
      Mem.loadbytes m b' (Ptrofs.unsigned ofs') (sizeof ce ty) = Some bytes ->
      Mem.storebytes m b (Ptrofs.unsigned ofs) bytes = Some m' ->
      assign_loc ce ty m b ofs (Vptr b' ofs') m'.

Section SEMANTICS.

Variable ge: genv.

Inductive alloc_variables: env -> mem ->
                           list (ident * type) ->
                           env -> mem -> Prop :=
  | alloc_variables_nil:
      forall e m,
      alloc_variables e m nil e m
  | alloc_variables_cons:
      forall e m id ty vars m1 b1 m2 e2,
      Mem.alloc m 0 (sizeof ge ty) = (m1, b1) ->
      alloc_variables (PTree.set id (b1, ty) e) m1 vars e2 m2 ->
      alloc_variables e m ((id, ty) :: vars) e2 m2.

Inductive bind_parameters (e: env):
                           mem -> list (ident * type) -> list val ->
                           mem -> Prop :=
  | bind_parameters_nil:
      forall m,
      bind_parameters e m nil nil m
  | bind_parameters_cons:
      forall m id ty params v1 vl b m1 m2,
      PTree.get id e = Some(b, ty) ->
      assign_loc ge ty m b Ptrofs.zero v1 m1 ->
      bind_parameters e m1 params vl m2 ->
      bind_parameters e m ((id, ty) :: params) (v1 :: vl) m2.

Fixpoint create_undef_temps (temps: list (ident * type)) : temp_env :=
  match temps with
  | nil => PTree.empty val
  | (id, t) :: temps' => PTree.set id Vundef (create_undef_temps temps')
 end.

Fixpoint bind_parameter_temps (formals: list (ident * type)) (args: list val)
                              (le: temp_env) : option temp_env :=
 match formals, args with
 | nil, nil => Some le
 | (id, t) :: xl, v :: vl => bind_parameter_temps xl vl (PTree.set id v le)
 | _, _ => None
 end.

Definition block_of_binding (id_b_ty: ident * (block * type)) :=
  match id_b_ty with (id, (b, ty)) => (b, 0, sizeof ge ty) end.

Definition blocks_of_env (e: env) : list (block * Z * Z) :=
  List.map block_of_binding (PTree.elements e).

Definition set_opttemp (optid: option ident) (v: val) (le: temp_env) :=
  match optid with
  | None => le
  | Some id => PTree.set id v le
  end.

Fixpoint select_switch_default (sl: labeled_statements): labeled_statements :=
  match sl with
  | LSnil => sl
  | LScons None s sl' => sl
  | LScons (Some i) s sl' => select_switch_default sl'
  end.

Fixpoint select_switch_case (n: Z) (sl: labeled_statements): option labeled_statements :=
  match sl with
  | LSnil => None
  | LScons None s sl' => select_switch_case n sl'
  | LScons (Some c) s sl' => if zeq c n then Some sl else select_switch_case n sl'
  end.

Definition select_switch (n: Z) (sl: labeled_statements): labeled_statements :=
  match select_switch_case n sl with
  | Some sl' => sl'
  | None => select_switch_default sl
  end.

Fixpoint seq_of_labeled_statement (sl: labeled_statements) : statement :=
  match sl with
  | LSnil => Sskip
  | LScons _ s sl' => Ssequence s (seq_of_labeled_statement sl')
  end.

Section EXPR.

Variable e: env.
Variable le: temp_env.
Variable m: mem.

Inductive eval_expr: expr -> val -> Prop :=
  | eval_Econst_int:   forall i ty,
      eval_expr (Econst_int i ty) (Vint i)
  | eval_Econst_float:   forall f ty,
      eval_expr (Econst_float f ty) (Vfloat f)
  | eval_Econst_single:   forall f ty,
      eval_expr (Econst_single f ty) (Vsingle f)
  | eval_Econst_long:   forall i ty,
      eval_expr (Econst_long i ty) (Vlong i)
  | eval_Etempvar:  forall id ty v,
      le!id = Some v ->
      eval_expr (Etempvar id ty) v
  | eval_Eaddrof: forall a ty loc ofs,
      eval_lvalue a loc ofs ->
      eval_expr (Eaddrof a ty) (Vptr loc ofs)
  | eval_Eunop:  forall op a ty v1 v,
      eval_expr a v1 ->
      sem_unary_operation op v1 (typeof a) m = Some v ->
      eval_expr (Eunop op a ty) v
  | eval_Ebinop: forall op a1 a2 ty v1 v2 v,
      eval_expr a1 v1 ->
      eval_expr a2 v2 ->
      sem_binary_operation ge op v1 (typeof a1) v2 (typeof a2) m = Some v ->
      eval_expr (Ebinop op a1 a2 ty) v
  | eval_Ecast:   forall a ty v1 v,
      eval_expr a v1 ->
      sem_cast v1 (typeof a) ty m = Some v ->
      eval_expr (Ecast a ty) v
  | eval_Esizeof: forall ty1 ty,
      eval_expr (Esizeof ty1 ty) (Vptrofs (Ptrofs.repr (sizeof ge ty1)))
  | eval_Ealignof: forall ty1 ty,
      eval_expr (Ealignof ty1 ty) (Vptrofs (Ptrofs.repr (alignof ge ty1)))
  | eval_Elvalue: forall a loc ofs v,
      eval_lvalue a loc ofs ->
      deref_loc (typeof a) m loc ofs v ->
      eval_expr a v

with eval_lvalue: expr -> block -> ptrofs -> Prop :=
  | eval_Evar_local:   forall id l ty,
      e!id = Some(l, ty) ->
      eval_lvalue (Evar id ty) l Ptrofs.zero
  | eval_Evar_global: forall id l ty,
      e!id = None ->
      Genv.find_symbol ge id = Some l ->
      eval_lvalue (Evar id ty) l Ptrofs.zero
  | eval_Ederef: forall a ty l ofs,
      eval_expr a (Vptr l ofs) ->
      eval_lvalue (Ederef a ty) l ofs
 | eval_Efield_struct:   forall a i ty l ofs id co att delta,
      eval_expr a (Vptr l ofs) ->
      typeof a = Tstruct id att ->
      ge.(genv_cenv)!id = Some co ->
      field_offset ge i (co_members co) = OK delta ->
      eval_lvalue (Efield a i ty) l (Ptrofs.add ofs (Ptrofs.repr delta))
 | eval_Efield_union:   forall a i ty l ofs id co att,
      eval_expr a (Vptr l ofs) ->
      typeof a = Tunion id att ->
      ge.(genv_cenv)!id = Some co ->
      eval_lvalue (Efield a i ty) l ofs.

Scheme eval_expr_ind2 := Minimality for eval_expr Sort Prop
  with eval_lvalue_ind2 := Minimality for eval_lvalue Sort Prop.
Combined Scheme eval_expr_lvalue_ind from eval_expr_ind2, eval_lvalue_ind2.

Inductive eval_exprlist: list expr -> typelist -> list val -> Prop :=
  | eval_Enil:
      eval_exprlist nil Tnil nil
  | eval_Econs:   forall a bl ty tyl v1 v2 vl,
      eval_expr a v1 ->
      sem_cast v1 (typeof a) ty m = Some v2 ->
      eval_exprlist bl tyl vl ->
      eval_exprlist (a :: bl) (Tcons ty tyl) (v2 :: vl).

End EXPR.

Inductive cont: Type :=
  | Kstop: cont
  | Kseq: statement -> cont -> cont       
  | Kloop1: statement -> statement -> cont -> cont 
  | Kloop2: statement -> statement -> cont -> cont 
  | Kswitch: cont -> cont       
  | Kcall: option ident ->                  
           function ->                      
           env ->                           
           temp_env ->                      
           cont -> cont.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s k => call_cont k
  | Kloop1 s1 s2 k => call_cont k
  | Kloop2 s1 s2 k => call_cont k
  | Kswitch k => call_cont k
  | _ => k
  end.

Definition is_call_cont (k: cont) : Prop :=
  match k with
  | Kstop => True
  | Kcall _ _ _ _ _ => True
  | _ => False
  end.

Inductive state: Type :=
  | State
      (f: function)
      (s: statement)
      (k: cont)
      (e: env)
      (le: temp_env)
      (m: mem) : state
  | Callstate
      (fd: fundef)
      (args: list val)
      (k: cont)
      (m: mem) : state
  | Returnstate
      (res: val)
      (k: cont)
      (m: mem) : state.

Fixpoint find_label (lbl: label) (s: statement) (k: cont)
                    {struct s}: option (statement * cont) :=
  match s with
  | Ssequence s1 s2 =>
      match find_label lbl s1 (Kseq s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 s2 =>
      match find_label lbl s1 (Kloop1 s1 s2 k) with
      | Some sk => Some sk
      | None => find_label lbl s2 (Kloop2 s1 s2 k)
      end
  | Sswitch e sl =>
      find_label_ls lbl sl (Kswitch k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(s', k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {struct sl}: option (statement * cont) :=
  match sl with
  | LSnil => None
  | LScons _ s sl' =>
      match find_label lbl s (Kseq (seq_of_labeled_statement sl') k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Variable function_entry: function -> list val -> mem -> env -> temp_env -> mem -> Prop.

Inductive step: state -> trace -> state -> Prop :=

  | step_assign:   forall f a1 a2 k e le m loc ofs v2 v m',
      eval_lvalue e le m a1 loc ofs ->
      eval_expr e le m a2 v2 ->
      sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
      assign_loc ge (typeof a1) m loc ofs v m' ->
      step (State f (Sassign a1 a2) k e le m)
        E0 (State f Sskip k e le m')

  | step_set:   forall f id a k e le m v,
      eval_expr e le m a v ->
      step (State f (Sset id a) k e le m)
        E0 (State f Sskip k e (PTree.set id v le) m)

  | step_call:   forall f optid a al k e le m tyargs tyres cconv vf vargs fd,
      classify_fun (typeof a) = fun_case_f tyargs tyres cconv ->
      eval_expr e le m a vf ->
      eval_exprlist e le m al tyargs vargs ->
      Genv.find_funct ge vf = Some fd ->
      type_of_fundef fd = Tfunction tyargs tyres cconv ->
      step (State f (Scall optid a al) k e le m)
        E0 (Callstate fd vargs (Kcall optid f e le k) m)

  | step_builtin:   forall f optid ef tyargs al k e le m vargs t vres m',
      eval_exprlist e le m al tyargs vargs ->
      external_call ef ge vargs m t vres m' ->
      step (State f (Sbuiltin optid ef tyargs al) k e le m)
         t (State f Sskip k e (set_opttemp optid vres le) m')

  | step_seq:  forall f s1 s2 k e le m,
      step (State f (Ssequence s1 s2) k e le m)
        E0 (State f s1 (Kseq s2 k) e le m)
  | step_skip_seq: forall f s k e le m,
      step (State f Sskip (Kseq s k) e le m)
        E0 (State f s k e le m)
  | step_continue_seq: forall f s k e le m,
      step (State f Scontinue (Kseq s k) e le m)
        E0 (State f Scontinue k e le m)
  | step_break_seq: forall f s k e le m,
      step (State f Sbreak (Kseq s k) e le m)
        E0 (State f Sbreak k e le m)

  | step_ifthenelse:  forall f a s1 s2 k e le m v1 b,
      eval_expr e le m a v1 ->
      bool_val v1 (typeof a) m = Some b ->
      step (State f (Sifthenelse a s1 s2) k e le m)
        E0 (State f (if b then s1 else s2) k e le m)

  | step_loop: forall f s1 s2 k e le m,
      step (State f (Sloop s1 s2) k e le m)
        E0 (State f s1 (Kloop1 s1 s2 k) e le m)
  | step_skip_or_continue_loop1:  forall f s1 s2 k e le m x,
      x = Sskip \/ x = Scontinue ->
      step (State f x (Kloop1 s1 s2 k) e le m)
        E0 (State f s2 (Kloop2 s1 s2 k) e le m)
  | step_break_loop1:  forall f s1 s2 k e le m,
      step (State f Sbreak (Kloop1 s1 s2 k) e le m)
        E0 (State f Sskip k e le m)
  | step_skip_loop2: forall f s1 s2 k e le m,
      step (State f Sskip (Kloop2 s1 s2 k) e le m)
        E0 (State f (Sloop s1 s2) k e le m)
  | step_break_loop2: forall f s1 s2 k e le m,
      step (State f Sbreak (Kloop2 s1 s2 k) e le m)
        E0 (State f Sskip k e le m)

  | step_return_0: forall f k e le m m',
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn None) k e le m)
        E0 (Returnstate Vundef (call_cont k) m')
  | step_return_1: forall f a k e le m v v' m',
      eval_expr e le m a v ->
      sem_cast v (typeof a) f.(fn_return) m = Some v' ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f (Sreturn (Some a)) k e le m)
        E0 (Returnstate v' (call_cont k) m')
  | step_skip_call: forall f k e le m m',
      is_call_cont k ->
      Mem.free_list m (blocks_of_env e) = Some m' ->
      step (State f Sskip k e le m)
        E0 (Returnstate Vundef k m')

  | step_switch: forall f a sl k e le m v n,
      eval_expr e le m a v ->
      sem_switch_arg v (typeof a) = Some n ->
      step (State f (Sswitch a sl) k e le m)
        E0 (State f (seq_of_labeled_statement (select_switch n sl)) (Kswitch k) e le m)
  | step_skip_break_switch: forall f x k e le m,
      x = Sskip \/ x = Sbreak ->
      step (State f x (Kswitch k) e le m)
        E0 (State f Sskip k e le m)
  | step_continue_switch: forall f k e le m,
      step (State f Scontinue (Kswitch k) e le m)
        E0 (State f Scontinue k e le m)

  | step_label: forall f lbl s k e le m,
      step (State f (Slabel lbl s) k e le m)
        E0 (State f s k e le m)

  | step_goto: forall f lbl k e le m s' k',
      find_label lbl f.(fn_body) (call_cont k) = Some (s', k') ->
      step (State f (Sgoto lbl) k e le m)
        E0 (State f s' k' e le m)

  | step_internal_function: forall f vargs k m e le m1,
      function_entry f vargs m e le m1 ->
      step (Callstate (Internal f) vargs k m)
        E0 (State f f.(fn_body) k e le m1)

  | step_external_function: forall ef targs tres cconv vargs k m vres t m',
      external_call ef ge vargs m t vres m' ->
      step (Callstate (External ef targs tres cconv) vargs k m)
         t (Returnstate vres k m')

  | step_returnstate: forall v optid f e le k m,
      step (Returnstate v (Kcall optid f e le k) m)
        E0 (State f Sskip k e (set_opttemp optid v le) m).

Inductive initial_state (p: program): state -> Prop :=
  | initial_state_intro: forall b f m0,
      let ge := Genv.globalenv p in
      Genv.init_mem p = Some m0 ->
      Genv.find_symbol ge p.(prog_main) = Some b ->
      Genv.find_funct_ptr ge b = Some f ->
      type_of_fundef f = Tfunction Tnil type_int32s cc_default ->
      initial_state p (Callstate f nil Kstop m0).

Inductive final_state: state -> int -> Prop :=
  | final_state_intro: forall r m,
      final_state (Returnstate (Vint r) Kstop m) r.

End SEMANTICS.

Inductive function_entry1 (ge: genv) (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=
  | function_entry1_intro: forall m1,
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_vars)) ->
      alloc_variables ge empty_env m (f.(fn_params) ++ f.(fn_vars)) e m1 ->
      bind_parameters ge e m1 f.(fn_params) vargs m' ->
      le = create_undef_temps f.(fn_temps) ->
      function_entry1 ge f vargs m e le m'.

Definition step1 (ge: genv) := step ge (function_entry1 ge).

Inductive function_entry2 (ge: genv)  (f: function) (vargs: list val) (m: mem) (e: env) (le: temp_env) (m': mem) : Prop :=
  | function_entry2_intro:
      list_norepet (var_names f.(fn_vars)) ->
      list_norepet (var_names f.(fn_params)) ->
      list_disjoint (var_names f.(fn_params)) (var_names f.(fn_temps)) ->
      alloc_variables ge empty_env m f.(fn_vars) e m' ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some le ->
      function_entry2 ge f vargs m e le m'.

Definition step2 (ge: genv) := step ge (function_entry2 ge).

Definition semantics1 (p: program) :=
  let ge := globalenv p in
  Semantics_gen step1 (initial_state p) final_state ge ge.

Definition semantics2 (p: program) :=
  let ge := globalenv p in
  Semantics_gen step2 (initial_state p) final_state ge ge.

Lemma semantics_receptive:
  forall (p: program), receptive (semantics1 p). *)



Require Import VST.veric.tycontext.
(* VST.veric.tycontext:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.

Require Import VST.veric.Clight_lemmas. 
Require Import VST.veric.align_mem.

Require Export VST.veric.lift.

Require Export VST.veric.mpred.

Fixpoint modifiedvars' (c: statement) (S: idset) : idset :=
 match c with
 | Sset id e => insert_idset id S
 | Sifthenelse _ c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Scall (Some id) _ _ => insert_idset id S
 | Sbuiltin (Some id) _ _ _ => insert_idset id S
 | Ssequence c1 c2 =>  modifiedvars' c1 (modifiedvars' c2 S)
 | Sloop c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Sswitch e cs => modifiedvars_ls cs S
 | Slabel _ c => modifiedvars' c S
 | _ => S
 end
 with
 modifiedvars_ls (cs: labeled_statements) (S: idset) : idset :=
 match cs with
 | LSnil => S
 | LScons _ c ls => modifiedvars' c (modifiedvars_ls ls S)
 end.

Definition isOK {A} (P: Errors.res A) := match P with Errors.OK _ => true | _ => false end.

Lemma modifiedvars'_union:
 forall id c S,
  isSome ((modifiedvars' c S) ! id) <->
  (isSome ((modifiedvars' c idset0) ! id ) \/ isSome (S ! id))
with modifiedvars_ls_union:
 forall id c S,
  isSome ((modifiedvars_ls c S) ! id) <->
  (isSome ((modifiedvars_ls c idset0) ! id ) \/ isSome (S ! id)).

Definition modifiedvars (c: statement) (id: ident) :=
   isSome ((modifiedvars' c idset0) ! id).

Definition type_of_global (ge: Clight.genv) (b: block) : option type :=
  match Genv.find_var_info ge b with
  | Some gv => Some gv.(gvar_info)
  | None =>
      match Genv.find_funct_ptr ge b with
      | Some fd => Some(type_of_fundef fd)
      | None => None
      end
  end.

Definition filter_genv (ge: Clight.genv) : genviron :=
    Genv.find_symbol ge.

Definition make_tenv (te : Clight.temp_env) : tenviron := fun id => PTree.get id te.

Definition make_venv (te : Clight.env) : venviron := fun id => PTree.get id te.

Definition construct_rho ge ve te:= mkEnviron ge (make_venv ve) (make_tenv te) .

Definition empty_environ (ge: Clight.genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Inductive Annotation :=
  WeakAnnotation : (environ -> mpred) -> Annotation
| StrongAnnotation : (environ -> mpred) -> Annotation.

Inductive tycontext : Type :=
  mk_tycontext : forall (tyc_temps: PTree.t type)
                        (tyc_vars: PTree.t type)
                        (tyc_ret: type)
                        (tyc_globty: PTree.t type)
                        (tyc_globsp: PTree.t funspec)
                        (tyc_annot: PTree.t Annotation),
                             tycontext.

Definition empty_tycontext : tycontext :=
  mk_tycontext (PTree.empty _) (PTree.empty _) Tvoid
         (PTree.empty _)  (PTree.empty _) (PTree.empty _).

Definition temp_types (Delta: tycontext): PTree.t type :=
  match Delta with mk_tycontext a _ _ _ _ _ => a end.
Definition var_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ a _ _ _ _ => a end.
Definition ret_type (Delta: tycontext) : type :=
  match Delta with mk_tycontext _ _ a _ _ _ => a end.
Definition glob_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ _ _ a _ _ => a end.
Definition glob_specs (Delta: tycontext) : PTree.t funspec :=
  match Delta with mk_tycontext _ _ _ _ a _ => a end.
Definition annotations (Delta: tycontext) : PTree.t Annotation :=
  match Delta with mk_tycontext _ _ _ _ _ a => a end.

Definition make_tycontext_t (params: list (ident*type)) (temps : list(ident*type)) :=
fold_right (fun (param: ident*type) => PTree.set (fst param) (snd param))
 (fold_right (fun (temp : ident *type) tenv => let (id,ty):= temp in PTree.set id ty tenv)
  (PTree.empty type) temps) params.

Definition make_tycontext_v (vars : list (ident * type)) :=
 fold_right (fun (var : ident * type) venv => let (id, ty) := var in PTree.set id ty venv)
   (PTree.empty type) vars.

Definition make_tycontext_g (V: varspecs) (G: funspecs) :=
 (fold_right (fun (var : ident * funspec) => PTree.set (fst var) (type_of_funspec (snd var)))
      (fold_right (fun (v: ident * type) => PTree.set (fst v) (snd v))
         (PTree.empty _) V)
            G).

Definition make_tycontext_a (anns : list (ident * Annotation)) :=
 fold_right (fun (ia : ident * Annotation) aenv => let (id, a) := ia in PTree.set id a aenv)
   (PTree.empty Annotation) anns.

Definition make_tycontext (params: list (ident*type)) (temps: list (ident*type)) (vars: list (ident*type))
                       (return_ty: type)
                       (V: varspecs) (G: funspecs) (A: list (ident*Annotation)):  tycontext :=
 mk_tycontext
   (make_tycontext_t params temps)
   (make_tycontext_v vars)
   return_ty
   (make_tycontext_g V G)
   (make_tycontext_s G)
   (make_tycontext_a A).

Definition func_tycontext' (func: function) (Delta: tycontext) : tycontext :=
 mk_tycontext
   (make_tycontext_t (fn_params func) (fn_temps func))
   (make_tycontext_v (fn_vars func))
   (fn_return func)
   (glob_types Delta)
   (glob_specs Delta)
   (annotations Delta).

Definition func_tycontext (func: function) (V: varspecs) (G: funspecs) (A:list (ident * Annotation)): tycontext :=
  make_tycontext (func.(fn_params)) (func.(fn_temps)) (func.(fn_vars)) (func.(fn_return)) V G A.

Definition nofunc_tycontext (V: varspecs) (G: funspecs) : tycontext :=
   make_tycontext nil nil nil Tvoid V G nil.

Ltac try_false :=
try  solve[exists false; rewrite orb_false_r; eauto].

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Definition sub_option {A} (x y: option A) :=
 match x with Some x' => y = Some x' | None => True end.

Lemma sub_option_eqv: forall {A} (x y: option A),
  x = y <-> sub_option x y /\ sub_option y x.

Lemma sub_option_refl: forall {A} (x: option A), sub_option x x.

Lemma sub_option_trans: forall {A} (x y z: option A), sub_option x y -> sub_option y z -> sub_option x z.

Lemma sub_option_spec: forall {A} (T1 T2: PTree.t A),

Definition Annotation_sub (A1 A2: option Annotation):Prop := 
  match A1, A2 with
    _, None => True
  | Some (StrongAnnotation _), Some (WeakAnnotation _) => True
  | Some (StrongAnnotation X), Some (StrongAnnotation Y) => X=Y 
  | X, Y => X=Y 
  end.

Lemma Annotation_sub_trans a1 a2 a3: Annotation_sub a1 a2 -> 
      Annotation_sub a2 a3 -> Annotation_sub a1 a3.

Lemma Annotation_sub_refl a: Annotation_sub a a. 

Lemma Annotation_sub_antisymm a b: Annotation_sub a b -> Annotation_sub b a -> a=b.

Definition tycontext_sub (Delta Delta' : tycontext) : Prop :=
 (forall id, match (temp_types Delta) ! id,  (temp_types Delta') ! id with
                 | None, _ => True
                 | Some t, None => False
                 | Some t, Some t' => t=t'
                end)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, sub_option ((glob_types Delta) ! id) ((glob_types Delta') ! id))
 /\ (forall id, sub_option ((glob_specs Delta) ! id) ((glob_specs Delta') ! id))
 /\ (forall id, Annotation_sub ((annotations Delta) ! id) ((annotations Delta') ! id)).

Definition tycontext_eqv (Delta Delta' : tycontext) : Prop :=
 (forall id, (temp_types Delta) ! id = (temp_types Delta') ! id)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, (glob_types Delta) ! id = (glob_types Delta') ! id)
 /\ (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id)
 /\ (forall id, (annotations Delta) ! id = (annotations Delta') ! id).

Lemma tycontext_eqv_spec: forall Delta Delta',
  tycontext_eqv Delta Delta' <-> tycontext_sub Delta Delta' /\ tycontext_sub Delta' Delta.

Lemma tycontext_sub_refl:
 forall Delta, tycontext_sub Delta Delta.

Lemma tycontext_sub_trans:
 forall Delta1 Delta2 Delta3,
  tycontext_sub Delta1 Delta2 -> tycontext_sub Delta2 Delta3 ->
  tycontext_sub Delta1 Delta3.

Definition binop_stable cenv op a1 a2 : bool :=
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t _ => complete_type cenv t
                    | Cop.add_case_ip _ t => complete_type cenv t
                    | Cop.add_case_pl t => complete_type cenv t
                    | Cop.add_case_lp t => complete_type cenv t
                    | Cop.add_default => true
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t _ => complete_type cenv t
                    | Cop.sub_case_pl t => complete_type cenv t
                    | Cop.sub_case_pp t => complete_type cenv t
                    | Cop.sub_default => true
            end
  | _ => true
  end.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma binop_stable_stable: forall b e1 e2,
  binop_stable env b e1 e2 = true ->
  binop_stable env' b e1 e2 = true.

Lemma Cop_Sem_add_ptr_int_stable ty si u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_int env ty si u v =

Lemma Cop_Sem_add_ptr_long_stable ty u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_long env ty u v =

Lemma Cop_sem_binary_operation_stable:
  forall b v1 e1 v2 e2 m,
  binop_stable env b e1 e2 = true ->
  Cop.sem_binary_operation env b v1 (typeof e1) v2 (typeof e2) m =

Lemma field_offset_stable: forall i id co ofs,
  composite_env_consistent env ->
  env ! i = Some co ->
  field_offset env id (co_members co) = Errors.OK ofs ->

End STABILITY.

Section TYCON_SUB.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma func_tycontext'_sub: forall f,
  tycontext_sub (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_SUB.

Section TYCON_EQUIV.

Variable Delta Delta': tycontext.
Hypothesis equiv: tycontext_eqv Delta Delta'.

Lemma func_tycontext'_eqv: forall f,
  tycontext_eqv (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_EQUIV.

Lemma tycontext_eqv_symm:
  forall Delta Delta', tycontext_eqv Delta Delta' ->  tycontext_eqv Delta' Delta.

Lemma tycontext_eqv_sub:
  forall Delta Delta', tycontext_eqv Delta Delta' ->
         tycontext_sub Delta Delta'.

Record ret_assert : Type := {
 RA_normal: environ->mpred;
 RA_break: environ->mpred;
 RA_continue: environ->mpred;
 RA_return: option val -> environ->mpred
}.

Lemma modifiedvars_Slabel l c: modifiedvars (Slabel l c) = modifiedvars c.

Lemma modifiedvars_computable: forall c (te1 te2: Map.t val), exists te,

Lemma modifiedvars_Sifthenelse b c1 c2 id: modifiedvars (Sifthenelse b c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Sloop c1 c2 id: modifiedvars (Sloop c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Ssequence c1 c2 id: modifiedvars (Ssequence c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_ls_eq: forall sl, modifiedvars_ls sl = modifiedvars' (seq_of_labeled_statement sl).

Lemma modifiedvars_Sswitch e sl n id: modifiedvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) id -> modifiedvars (Sswitch e sl) id. *)

Require Import VST.veric.semax_prog.
(* VST.veric.semax_prog:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
Require Import VST.veric.res_predicates.
Require Import VST.veric.extend_tc.
Require Import VST.veric.Clight_seplog.
Require Import VST.veric.Clight_assert_lemmas.
Require Import VST.veric.Clight_new.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.expr_lemmas.
Require Import VST.veric.semax.
Require Import VST.veric.semax_lemmas.
Require Import VST.veric.Clight_lemmas.
Require Import VST.veric.initial_world.
Require Import VST.msl.normalize.
Require Import VST.veric.semax_call.
Require Import VST.veric.Clight_initial_world.
Require Import VST.veric.initialize.
Require Import VST.veric.coqlib4.
Require Import Coq.Logic.JMeq.

Require Import Coq.Logic.JMeq.
Require Import VST.veric.ghost_PCM.

Local Open Scope pred.

Fixpoint match_globvars (gvs: list (ident * globvar type)) (V: varspecs) : bool :=
 match V with
 | nil => true
 | (id,t)::V' => match gvs with
                       | nil => false
                       | (j,g)::gvs' => if eqb_ident id j
                                              then andb (eqb_type t (gvar_info g)) (match_globvars gvs' V')
                                              else match_globvars gvs' V
                      end
  end.

Section semax_prog.
Context (Espec: OracleKind).

Definition prog_contains (ge: genv) (fdecs : list (ident * fundef)) : Prop :=
     forall id f, In (id,f) fdecs ->
         exists b, Genv.find_symbol ge id = Some b /\ Genv.find_funct_ptr ge b = Some f.

Definition entry_tempenv (te: temp_env) (f: function) (vl: list val) :=
   length vl = length f.(fn_params) /\
   forall id v, PTree.get id te = Some v ->
                      In (id,v)
                       (combine (map (@fst _ _) f.(fn_params)) vl
                          ++ map (fun tv => (fst tv, Vundef)) f.(fn_temps)).

Definition semax_body_params_ok f : bool :=
   andb
        (compute_list_norepet (map (@fst _ _) (fn_params f) ++ map (@fst _ _) (fn_temps f)))
        (compute_list_norepet (map (@fst _ _) (fn_vars f))).

Definition semax_body
       (V: varspecs) (G: funspecs) {C: compspecs} (f: function) (spec: ident * funspec): Prop :=
  match spec with (_, mk_funspec _ cc A P Q _ _) =>
    forall Espec ts x, 
      semax Espec (func_tycontext f V G nil)
          (fun rho => P ts x rho * stackframe_of f rho)
           (Ssequence f.(fn_body) (Sreturn None))
          (frame_ret_assert (function_body_ret_assert (fn_return f) (Q ts x)) (stackframe_of f))
 end.

Definition semax_func
         (V: varspecs) (G: funspecs) {C: compspecs} (fdecs: list (ident * fundef)) (G1: funspecs) : Prop :=
   match_fdecs fdecs G1 /\
  forall ge, prog_contains ge fdecs ->
          genv_cenv ge = cenv_cs ->
          forall n, believe Espec (nofunc_tycontext V G) ge (nofunc_tycontext V G1) n.

Definition main_pre (prog: program) : list Type -> (ident->val) -> assert :=
(fun nil gv => globvars2pred gv (prog_vars prog)).

Definition main_pre_ext (prog: program) (ora: OK_ty) : list Type -> (ident->val) -> assert :=
(fun nil gv rho => globvars2pred gv (prog_vars prog) rho * has_ext ora).

Definition Tint32s := Tint I32 Signed noattr.

Definition main_post (prog: program) : list Type -> (ident->val) -> assert :=
  (fun nil _ _ => TT).

Definition main_spec' (prog: program) 
    (post: list Type -> (ident->val) -> environ ->pred rmap): funspec :=
  mk_funspec (nil, tint) cc_default
     (ConstType (ident->val)) (main_pre prog) post
       (const_super_non_expansive _ _) (const_super_non_expansive _ _).

Definition main_spec (prog: program): funspec :=
  mk_funspec (nil, tint) cc_default
     (ConstType (ident->val)) (main_pre prog) (main_post prog)
       (const_super_non_expansive _ _) (const_super_non_expansive _ _).

Definition main_spec_ext' (prog: program) (ora: OK_ty)
    (post: list Type -> (ident->val) -> environ ->pred rmap): funspec :=
  mk_funspec (nil, tint) cc_default
     (ConstType (ident->val)) (main_pre_ext prog ora) post
       (const_super_non_expansive _ _) (const_super_non_expansive _ _).

Definition main_spec_ext (prog: program) (ora: OK_ty): funspec :=
  mk_funspec (nil, tint) cc_default
     (ConstType (ident->val)) (main_pre_ext prog ora) (main_post prog)
       (const_super_non_expansive _ _) (const_super_non_expansive _ _).

Definition is_Internal (prog : program) (f : ident) :=
  match Genv.find_symbol (Genv.globalenv prog) f with
    None => false
  | Some b =>
    match Genv.find_funct_ptr (Genv.globalenv prog) b with
    | None => false
    | Some f =>
      match f with
      | External _ _ _ _ => false
      | Internal _ => true
      end
    end
  end.

Definition semax_prog {C: compspecs}
           (prog: program)  (V: varspecs) (G: funspecs) : Prop :=
  compute_list_norepet (prog_defs_names prog) = true  /\
  all_initializers_aligned prog /\
  cenv_cs = prog_comp_env prog /\
  @semax_func V G C (prog_funct prog) G /\
  match_globvars (prog_vars prog) V = true /\
  match find_id prog.(prog_main) G with
  | Some s => exists post, s = main_spec' prog post
  | None => False
  end.

Definition semax_prog_ext {C: compspecs}
           (prog: program) (ora: OK_ty) (V: varspecs) (G: funspecs) : Prop :=
  compute_list_norepet (prog_defs_names prog) = true  /\
  all_initializers_aligned prog /\
  cenv_cs = prog_comp_env prog /\
  @semax_func V G C (prog_funct prog) G /\
  match_globvars (prog_vars prog) V = true /\
  match find_id prog.(prog_main) G with
  | Some s => exists post, s = main_spec_ext' prog ora post
  | None => False
  end.

Lemma semax_func_nil:
   forall
     V G {C: compspecs}, semax_func V G nil nil.

Program Definition HO_pred_eq {T}{agT: ageable T}
    (A: Type) (P: A -> pred T) (A': Type) (P': A' -> pred T) : pred nat :=
 fun v => exists H: A=A',
     match H in (_ = A) return (A -> pred T) -> Prop with
     | refl_equal => fun (u3: A -> pred T) =>
                                    forall x: A, (P x <=> u3 x) v
     end P'.

Lemma laterR_level: forall w w' : rmap, laterR w w' -> (level w > level w')%nat.

Lemma necR_level:  forall w w' : rmap, necR w w' -> (level w >= level w')%nat.

Lemma HO_pred_eq_i1:
  forall A P P' m,
      approx (level m) oo  P = approx (level m) oo P' ->
    (|> HO_pred_eq A P A  P') m.

Lemma semax_func_cons_aux:
  forall (psi: genv) id fsig1 cc1 A1 P1 Q1 NEP1 NEQ1 fsig2 cc2 A2 P2 Q2 (V: varspecs) (G': funspecs) {C: compspecs} b fs,
  Genv.find_symbol psi id = Some b ->

Lemma semax_func_cons:
   forall
         fs id f cc (A: TypeTree) P Q NEP NEQ (V: varspecs) (G G': funspecs) {C: compspecs},
      andb (id_in_list id (map (@fst _ _) G))
      (andb (negb (id_in_list id (map (@fst ident fundef) fs)))
        (semax_body_params_ok f)) = true ->
      Forall
         (fun it : ident * type =>
          complete_type cenv_cs (snd it) =
          true) (fn_vars f) ->
       var_sizes_ok cenv_cs (f.(fn_vars)) ->

Lemma semax_external_FF:
 forall Espec ids ef A n,
  @semax_external Espec ids ef A (fun _ _ _ => FF) (fun _ _ _ => FF) n.

Lemma semax_func_cons_ext:
   forall (V: varspecs) (G: funspecs) {C: compspecs} fs id ef argsig retsig A P Q NEP NEQ
          argsig'
          (G': funspecs) cc (ids: list ident),
      ids = map fst argsig' -> 
      argsig' = zip_with_tl ids argsig ->
      ef_sig ef =
      mksignature
        (typlist_of_typelist (type_of_params argsig'))
        (opttyp_of_type retsig) cc ->
      id_in_list id (map (@fst _ _) fs) = false ->
      length ids = length (typelist2list argsig) ->
      (forall gx ts x (ret : option val),
         (Q ts x (make_ext_rval gx ret)
            && !!has_opttyp ret (opttyp_of_type retsig)
            |-- !!tc_option_val retsig ret)) ->
      (forall n, semax_external Espec ids ef A P Q n) ->
      semax_func V G fs G' ->
      semax_func V G ((id, External ef argsig retsig cc)::fs)
           ((id, mk_funspec (argsig', retsig) cc A P Q NEP NEQ)  :: G').

Definition main_params (ge: genv) start : Prop :=
  exists b, exists func,
    Genv.find_symbol ge start = Some b /\
        Genv.find_funct ge (Vptr b Ptrofs.zero) = Some (Internal func) /\
        func.(fn_params) = nil.

Lemma in_prog_funct'_in {F V}:
  forall i f (g: list (ident * globdef F V)), In (i,f) (prog_funct' g) -> In (i, Gfun f) g.

Lemma in_prog_funct_in_prog_defs:
  forall i f prog, In (i,f) (prog_funct prog) -> In (i, Gfun f) (prog_defs prog).

Lemma in_prog_vars_in_prog_defs:
  forall i v prog, In (i,v) (prog_vars prog) -> In (i, Gvar v) (prog_defs prog).

Lemma find_funct_ptr_exists:
  forall (p: program) id f,
  list_norepet (prog_defs_names p) ->
  In (id, Gfun f) (prog_defs p) ->
  exists b,
     Genv.find_symbol (Genv.globalenv p) id = Some b

Lemma funassert_initial_core:
  forall (prog: program) ve te V G n,
      list_norepet (prog_defs_names prog) ->
      match_fdecs (prog_funct prog) G ->
      app_pred (funassert (nofunc_tycontext V G) (mkEnviron (filter_genv (globalenv prog)) ve te))
                      (initial_core (Genv.globalenv prog) G n).

Lemma prog_contains_prog_funct: forall prog: program,
      list_norepet (prog_defs_names prog) ->
          prog_contains (globalenv prog) (prog_funct prog).

Lemma funassert_initial_core_ext:
  forall (ora : OK_ty) (prog: program) ve te V G n,
      list_norepet (prog_defs_names prog) ->
      match_fdecs (prog_funct prog) G ->
      app_pred (funassert (nofunc_tycontext V G) (mkEnviron (filter_genv (globalenv prog)) ve te))
                      (initial_core_ext ora (Genv.globalenv prog) G n).

Lemma funassert_rho:
  forall G rho rho', ge_of rho = ge_of rho' -> funassert G rho |-- funassert G rho'.

Lemma core_inflate_initial_mem:
  forall (m: mem) (prog: program) (G: funspecs) (n: nat)
     (INIT: Genv.init_mem prog = Some m),

Lemma core_inflate_initial_mem':
  forall (ora : OK_ty) (m: mem) (prog: program) (G: funspecs) (n: nat)
     (INIT: Genv.init_mem prog = Some m),

Definition Delta1 V G {C: compspecs}: tycontext :=
  make_tycontext ((1%positive,(Tfunction Tnil Tvoid cc_default))::nil) nil nil Tvoid V G nil.

Lemma match_globvars_in':
  forall i t vl vs,
  match_globvars vl vs = true ->
  In (i,t) vs ->
  exists g, In (i,g) vl /\ gvar_info g = t.

Lemma match_globvars_in:
  forall i vl vs, match_globvars vl vs = true -> In i  (map (@fst _ _) vs) -> In i (map (@fst _ _) vl).

Lemma match_globvars_norepet:
  forall vl vs,
   list_norepet (map (@fst _ _) vl) ->
   match_globvars vl vs = true ->
   list_norepet (map (@fst _ _) vs).

Lemma make_tycontext_g_denote:
  forall id t l vs G,
    list_norepet (map fst l) ->
    match_globvars (prog_vars' l) vs = true ->
    match_fdecs (prog_funct' l) G ->
   ((make_tycontext_g vs G) ! id = Some t <->
    ((exists f, In (id,f) G /\ t = type_of_funspec f) \/ In (id,t) vs)).

Lemma tc_ge_denote_initial:
  forall vs G (prog: program),
list_norepet (prog_defs_names prog) ->
match_globvars (prog_vars prog) vs = true->
match_fdecs (prog_funct prog) G ->
typecheck_glob_environ (filter_genv (globalenv prog)) (make_tycontext_g vs G).

Lemma semax_prog_typecheck_aux:
  forall vs G {C: compspecs} (prog: program) b,
   list_norepet (prog_defs_names prog) ->
   match_globvars (prog_vars prog) vs = true ->
   match_fdecs (prog_funct prog) G ->
   typecheck_environ
      (Delta1 vs G) (construct_rho (filter_genv (globalenv prog)) empty_env
        (PTree.set 1 (Vptr b Ptrofs.zero) (PTree.empty val))) .

Lemma in_map_sig {A B} (E:forall b b' : B, {b=b'}+{b<>b'}) y (f : A -> B) l : In y (map f l) -> {x : A | f x = y /\ In x l }.

Lemma find_symbol_funct_ptr_ex_sig V ge id f :
  (exists b : block,
      Genv.find_symbol ge id = Some b /\

Lemma initial_jm_funassert V (prog : Clight.program) m G n H H1 H2 :

Lemma initial_jm_ext_funassert (ora : OK_ty) V (prog : Clight.program) m G n H H1 H2 :

Lemma semax_prog_rule' {CS: compspecs} :
  forall V G prog m h,
     @semax_prog CS prog V G ->
     Genv.init_mem prog = Some m ->

Lemma semax_prog_rule {CS: compspecs} :
  OK_ty = unit -> 
  forall V G prog m h,
     @semax_prog CS prog V G ->
     Genv.init_mem prog = Some m ->

Definition Delta_types V G {C: compspecs} (tys : list type) : tycontext :=
  make_tycontext
    (params_of_types
       1 ((Tfunction (type_of_params (params_of_types 2 tys)) Tvoid cc_default) :: tys))
    nil nil Tvoid V G nil.

Lemma semax_prog_typecheck_aux_types:
  forall vs G {C: compspecs} (prog: program) b (typed_args : list (val * type)),
   list_norepet (prog_defs_names prog) ->
   match_globvars (prog_vars prog) vs = true ->
   match_fdecs (prog_funct prog) G ->
   Forall (fun x => tc_val (snd x) (fst x)) typed_args ->
   typecheck_environ
     (Delta_types vs G (map snd typed_args))
     (construct_rho
        (filter_genv (globalenv prog)) empty_env
        (PTree.set 1 (Vptr b Ptrofs.zero)

Lemma find_id_maketycontext_s G id : (make_tycontext_s G) ! id = find_id id G.

Lemma semax_prog_entry_point {CS: compspecs} V G prog b id_fun id_arg arg A 
   (P Q: forall ts : list Type, (dependent_type_functor_rec ts (AssertTT A)) mpred)
   NEP NEQ h:
  @semax_prog CS prog V G ->
  Genv.find_symbol (globalenv prog) id_fun = Some b ->

End semax_prog. *)



Require Import VST.concurrency.juicy.semax_initial.
(* VST.concurrency.juicy.semax_initial:
Require Import Coq.Strings.String.

Require Import compcert.lib.Integers.
Require Import compcert.common.AST.
Require Import compcert.cfrontend.Clight.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.common.Memdata.
Require Import compcert.common.Values.

Require Import VST.msl.Coqlib2.
Require Import VST.msl.eq_dec.
Require Import VST.msl.seplog.
Require Import VST.msl.age_to.
Require Import VST.veric.initial_world.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.semax_prog.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_new.
Require Import VST.veric.Clightnew_coop.
Require Import VST.veric.semax.
Require Import VST.veric.semax_ext.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.initial_world.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.semax_ext.
Require Import VST.veric.res_predicates.
Require Import VST.veric.mem_lessdef.
Require Import VST.veric.seplog.
Require Import VST.veric.juicy_safety.
Require Import VST.floyd.coqlib3.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.juicy.semax_conc_pred.
Require Import VST.concurrency.juicy.semax_conc.
Require Import VST.concurrency.juicy.juicy_machine.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.juicy.JuicyMachineModule.
Require Import VST.concurrency.juicy.sync_preds_defs.
Require Import VST.concurrency.juicy.semax_invariant.
Require Import VST.concurrency.juicy.sync_preds.

Set Bullet Behavior "Strict Subproofs".

Section Initial_State.
  Variables
    (CS : compspecs) (V : varspecs) (G : funspecs)
    (ext_link : string -> ident) (prog : Clight.program)
    (all_safe : semax_prog.semax_prog (Concurrent_Espec unit CS ext_link) prog V G)
    (init_mem_not_none : Genv.init_mem prog <> None).

  Definition Jspec := @OK_spec (Concurrent_Espec unit CS ext_link).

  Definition init_m : { m | Genv.init_mem prog = Some m } :=
    match Genv.init_mem prog as y return (y <> None -> {m : mem | y = Some m}) with
    | Some m => fun _ => exist _ m eq_refl
    | None => fun H => (fun Heq => False_rect _ (H Heq)) eq_refl
    end init_mem_not_none.

  Definition initial_state (n : nat) (sch : schedule) : cm_state :=
    (proj1_sig init_m,
     (nil, sch,
      let spr := semax_prog_rule'
                   (Concurrent_Espec unit CS ext_link) V G prog
                   (proj1_sig init_m) 0 all_safe (proj2_sig init_m) in
      let q : corestate := projT1 (projT2 spr) in
      let jm : juicy_mem := proj1_sig (snd (projT2 (projT2 spr)) n tt) in
      @OrdinalPool.mk LocksAndResources (ClightSemanticsForMachines.Clight_newSem (globalenv prog))
        (pos.mkPos (le_n 1))
        
        (fun _ => Krun q)
        (fun _ => m_phi jm)
        (addressFiniteMap.AMap.empty _)
     )
    ).

  Lemma personal_mem_of_same_jm (tp : jstate (globalenv prog)) jm i (cnti : ThreadPool.containsThread tp i) mc :

  Theorem initial_invariant n sch : state_invariant Jspec G n (initial_state n sch).

End Initial_State. *)

Require Import VST.concurrency.juicy.semax_conc.
(* VST.concurrency.juicy.semax_conc:
Require Import VST.msl.msl_standard.
Require Import VST.msl.seplog.
Require Import VST.veric.base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.juicy_mem_ops.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.semax.
Require Import VST.veric.semax_call.
Require Import VST.veric.semax_ext.
Require Import VST.veric.juicy_safety.
Require Import VST.veric.Clight_new.
Require Import VST.veric.res_predicates.
Require Import VST.veric.SeparationLogic.
Require Import VST.sepcomp.extspec.
Require Import VST.floyd.reptype_lemmas.
Require Import VST.floyd.field_at.
Require Import VST.floyd.nested_field_lemmas.
Require Import VST.floyd.client_lemmas.
Require Import VST.floyd.jmeq_lemmas.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.juicy.semax_conc_pred.
Import Clightdefs.
Import String.

Set Bullet Behavior "Strict Subproofs".

Definition _f := 1%positive.      
Definition _args := 2%positive.   
Definition _lock := 1%positive.   
Definition _cond := 2%positive.   

Definition voidstar_funtype := Tfunction (Tcons (tptr tvoid) Tnil) (tptr tvoid) cc_default.

Definition tlock := (Tarray (Tpointer Tvoid noattr) 2 noattr).

Goal forall (cenv: composite_env), @sizeof cenv tlock = LKSIZE.

Definition selflock_fun Q sh p : (unit -> mpred) -> (unit -> mpred) :=
  fun R _ => (Q * |>lock_inv sh p (R tt))%logic.

Definition selflock' Q sh p : unit -> mpred := HORec (selflock_fun Q sh p).
Definition selflock Q sh p : mpred := selflock' Q sh p tt.

Lemma nonexpansive_entail (F: pred rmap -> pred rmap) : nonexpansive F -> forall P Q, (P <=> Q |-- F P <=> F Q)%logic.

Lemma HOnonexpansive_nonexpansive: forall F: mpred -> mpred, nonexpansive F <-> HOnonexpansive (fun P (_ : unit) => F (P tt)).

Lemma selflock'_eq Q sh p : selflock' Q sh p =
  selflock_fun Q sh p (selflock' Q sh p).

Lemma selflock_eq Q sh p : selflock Q sh p = (Q * |>lock_inv sh p (selflock Q sh p))%logic.

Definition res_invariants_fun Q sh1 p1 sh2 p2 : (bool -> mpred) -> (bool -> mpred) :=
  fun R b =>
    if b then
      (Q * lock_inv sh2 p2 (|> R false))%logic
    else
      (Q * lock_inv sh1 p1 (|> R true) * lock_inv sh2 p2 (|> R false))%logic.

Definition res_invariants Q sh1 p1 sh2 p2 : bool -> mpred := HORec (res_invariants_fun Q sh1 p1 sh2 p2).
Definition res_invariant Q sh1 p1 sh2 p2 : mpred := res_invariants Q sh1 p1 sh2 p2 true.
Definition join_res_invariant Q sh1 p1 sh2 p2 : mpred := res_invariants Q sh1 p1 sh2 p2 false.

Lemma res_invariants_eq Q sh1 p1 sh2 p2 : res_invariants Q sh1 p1 sh2 p2 =
  res_invariants_fun Q sh1 p1 sh2 p2 (res_invariants Q sh1 p1 sh2 p2).

Lemma res_invariant_eq Q sh1 p1 sh2 p2 :
  res_invariant Q sh1 p1 sh2 p2 =
  (Q *
  lock_inv sh2 p2 (|> join_res_invariant Q sh1 p1 sh2 p2))%logic.

Lemma join_res_invariant_eq Q sh1 p1 sh2 p2 :
  join_res_invariant Q sh1 p1 sh2 p2 =
  (Q *
  lock_inv sh1 p1 (|> res_invariant Q sh1 p1 sh2 p2) *
  lock_inv sh2 p2 (|> join_res_invariant Q sh1 p1 sh2 p2))%logic.

Definition tcond := tint.

Definition cond_var {cs} sh v := @data_at_ cs sh tcond v.

Lemma approx_eq_i':
  forall (P Q : pred rmap) n,
  (|> (P <=> Q))%pred n -> approx n P = approx n Q.

Lemma fash_equiv_approx: forall n (R: pred rmap),
  (|> (R <=> approx n R))%pred n.

Lemma nonexpansive_super_non_expansive: forall (F: mpred -> mpred),
  nonexpansive F ->
  forall R n,
  approx n (F R) = approx n (F (approx n R)).

Lemma nonexpansive2_super_non_expansive: forall (F: mpred -> mpred -> mpred),
  (forall P, nonexpansive (fun Q => F P Q)) ->
  (forall Q, nonexpansive (fun P => F P Q)) ->
  forall P Q n,
  approx n (F P Q) = approx n (F (approx n P) (approx n Q)).

Definition acquire_arg_type: rmaps.TypeTree := rmaps.ProdType (rmaps.ConstType (val * share)) rmaps.Mpred.

Definition acquire_pre: val * share * mpred -> environ -> mpred :=
  fun args =>
  match args with
  | (v, sh, R) =>
     PROP (readable_share sh)
     LOCAL (temp _lock v)
     SEP (lock_inv sh v R)
  end.

Notation acquire_post :=
  (fun args =>
  match args with
  | (v, sh, R) =>
     PROP ()
     LOCAL ()
     SEP (lock_inv sh v R; R)
  end).

Lemma NP_acquire_pre: @super_non_expansive acquire_arg_type (fun _ => acquire_pre).

Lemma NP_acquire_post: @super_non_expansive acquire_arg_type (fun _ => acquire_post).

Definition acquire_spec: funspec := mk_funspec
  ((_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  acquire_arg_type
  (fun _ => acquire_pre)
  (fun _ => acquire_post)
  NP_acquire_pre
  NP_acquire_post
.

Definition release_arg_type: rmaps.TypeTree := rmaps.ProdType (rmaps.ConstType (val * share)) rmaps.Mpred.

Definition release_pre: val * share * mpred -> environ -> mpred :=
  fun args =>
  match args with
  | (v, sh, R) =>
     PROP (readable_share sh)
     LOCAL (temp _lock v)
     SEP (weak_exclusive_mpred R && emp; lock_inv sh v R; R)
  end.

Notation release_post :=
  (fun args =>
  match args with
  | (v, sh, R) =>
     PROP ()
     LOCAL ()
     SEP (lock_inv sh v R)
  end).

Lemma NP_release_pre: @super_non_expansive release_arg_type (fun _ => release_pre).

Lemma NP_release_post: @super_non_expansive release_arg_type (fun _ => release_post).

Definition release_spec: funspec := mk_funspec
  ((_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  release_arg_type
  (fun _ => release_pre)
  (fun _ => release_post)
  NP_release_pre
  NP_release_post
.

Program Definition makelock_spec cs: funspec := mk_funspec
  ((_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  (rmaps.ProdType (rmaps.ConstType (val * share)) rmaps.Mpred)

Program Definition freelock_spec cs: funspec := mk_funspec
  ((_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  (rmaps.ProdType (rmaps.ConstType (val * share)) rmaps.Mpred)

Lemma selflock_rec : forall sh v R, rec_inv sh v R (selflock R sh v).

Program Definition freelock2_spec cs: funspec := mk_funspec
  ((_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  (rmaps.ProdType (rmaps.ProdType (rmaps.ConstType (val * share * share)) rmaps.Mpred) rmaps.Mpred)

Program Definition release2_spec: funspec := mk_funspec
  ((_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  (rmaps.ProdType (rmaps.ProdType (rmaps.ConstType (val * share)) rmaps.Mpred) rmaps.Mpred)

Definition makecond_spec cs :=
   WITH v : val, sh : share
   PRE [ _cond OF tptr tcond ]
     PROP (writable_share sh)
     LOCAL (temp _cond v)
     SEP (@data_at_ cs sh tcond v)
   POST [ tvoid ]
     PROP ()
     LOCAL ()
     SEP (cond_var sh v).

Definition freecond_spec cs :=
   WITH v : val, sh : share
   PRE [ _cond OF tptr tcond ]
     PROP (writable_share sh)
     LOCAL (temp _cond v)
     SEP (@cond_var cs sh v)
   POST [ tvoid ]
     PROP ()
     LOCAL ()
     SEP (@data_at_ cs sh tcond v).

Program Definition wait_spec cs: funspec := mk_funspec
  ((_cond OF tptr tcond)%formals :: (_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  (rmaps.ProdType (rmaps.ConstType (val * val * share * share)) rmaps.Mpred)

Program Definition wait2_spec cs: funspec := mk_funspec
  ((_cond OF tptr tcond)%formals :: (_lock OF tptr Tvoid)%formals :: nil, tvoid)
  cc_default
  (rmaps.ProdType (rmaps.ConstType (val * val * share * share)) rmaps.Mpred)

Definition signal_spec cs :=
   WITH c : val, shc : share
   PRE [ _cond OF tptr tcond ]
     PROP (readable_share shc)
     LOCAL (temp _cond c)
     SEP (@cond_var cs shc c)
   POST [ tvoid ]
     PROP ()
     LOCAL ()
     SEP (@cond_var cs shc c).

Local Open Scope logic.

Definition spawn_arg_type := rmaps.ProdType (rmaps.ProdType (rmaps.ProdType (rmaps.ConstType (val * val))
  (rmaps.ArrowType (rmaps.DependentType 0) (rmaps.ConstType globals))) (rmaps.DependentType 0))
  (rmaps.ArrowType (rmaps.DependentType 0) (rmaps.ArrowType (rmaps.ConstType val) rmaps.Mpred)).

Definition spawn_pre :=
  (fun (ts: list Type) (x: val * val * (nth 0 ts unit -> globals) * nth 0 ts unit *
                           (nth 0 ts unit -> val -> mpred)) =>
   match x with
   | (f, b, gv, w, pre) =>
     PROP (tc_val (tptr Tvoid) b)
     (LOCALx (temp _f f :: temp _args b :: gvars (gv w) :: nil)
     (SEP (
       EX _y : ident,
         (func_ptr'
           (WITH y : val, x : nth 0 ts unit
             PRE [ _y OF tptr tvoid ]
               PROP ()
               (LOCALx (temp _y y :: gvars (gv x) :: nil)
               (SEP   (pre x y)))
             POST [tptr tvoid]
               PROP  ()
               LOCAL ()
               SEP   ())
           f);
         valid_pointer b && pre w b)))
   end).

Definition spawn_post :=
  (fun (ts: list Type) (x: val * val * (nth 0 ts unit -> globals) * nth 0 ts unit *
                           (nth 0 ts unit -> val -> mpred)) =>
   match x with
   | (f, b, w, pre) =>
     PROP ()
     LOCAL ()
     SEP ()
   end).

Lemma approx_idem : forall n P, compcert_rmaps.R.approx n (compcert_rmaps.R.approx n P) =

Lemma spawn_pre_nonexpansive: @super_non_expansive spawn_arg_type spawn_pre.

Lemma spawn_post_nonexpansive: @super_non_expansive spawn_arg_type spawn_post.

Definition spawn_spec := mk_funspec
  ((_f OF tptr voidstar_funtype)%formals :: (_args OF tptr tvoid)%formals :: nil, tvoid)
  cc_default
  spawn_arg_type
  spawn_pre
  spawn_post
  spawn_pre_nonexpansive
  spawn_post_nonexpansive.

Definition void_spec T : external_specification juicy_mem external_function T :=
    Build_external_specification
      juicy_mem external_function T
      (fun ef => False)
      (fun ef Hef ge tys vl m z => False)
      (fun ef Hef ge ty vl m z => False)
      (fun rv m z => False).

Definition ok_void_spec (T : Type) : OracleKind.

Definition concurrent_simple_specs (cs : compspecs) (ext_link : string -> ident) :=
  (ext_link "acquire"%string, acquire_spec) ::
  (ext_link "release"%string, release_spec) ::
  nil.

Definition concurrent_simple_ext_spec Z (cs : compspecs) (ext_link : string -> ident) :=
  add_funspecs_rec
    ext_link
    (ok_void_spec Z).(@OK_ty)
    (ok_void_spec Z).(@OK_spec)
    (concurrent_simple_specs cs ext_link).

Definition Concurrent_Simple_Espec Z cs ext_link :=
  Build_OracleKind
    Z
    (concurrent_simple_ext_spec Z cs ext_link).

Lemma strong_nat_ind (P : nat -> Prop) (IH : forall n, (forall i, lt i n -> P i) -> P n) n : P n.

Set Printing Implicit.

Definition concurrent_specs (cs : compspecs) (ext_link : string -> ident) :=
  (ext_link "acquire"%string, acquire_spec) ::
  (ext_link "release"%string, release_spec) ::
  (ext_link "makelock"%string, makelock_spec cs) ::
  (ext_link "freelock"%string, freelock_spec cs) ::
  (ext_link "spawn"%string, spawn_spec) ::
  nil.

Definition concurrent_ext_spec Z (cs : compspecs) (ext_link : string -> ident) :=
  add_funspecs_rec
    ext_link
    (ok_void_spec Z).(@OK_ty)
    (ok_void_spec Z).(@OK_spec)
    (concurrent_specs cs ext_link).

Definition Concurrent_Espec Z cs ext_link :=
  Build_OracleKind
    Z
    (concurrent_ext_spec Z cs ext_link). *)

Require Import VST.concurrency.juicy.semax_to_juicy_machine.
(* VST.concurrency.juicy.semax_to_juicy_machine:
Require Import Coq.Strings.String.

Require Import compcert.lib.Integers.
Require Import compcert.common.AST.
Require Import compcert.cfrontend.Clight.
Require Import compcert.common.Globalenvs.
Require Import compcert.common.Memory.
Require Import compcert.common.Memdata.
Require Import compcert.common.Values.

Require Import VST.msl.Coqlib2.
Require Import VST.msl.eq_dec.
Require Import VST.msl.seplog.
Require Import VST.veric.aging_lemmas.
Require Import VST.veric.initial_world.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.semax_prog.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_new.
Require Import VST.veric.Clightnew_coop.
Require Import VST.veric.semax.
Require Import VST.veric.semax_ext.
Require Import VST.veric.semax_lemmas.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.initial_world.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.res_predicates.
Require Import VST.floyd.coqlib3.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.juicy.semax_conc_pred.
Require Import VST.concurrency.juicy.semax_conc.
Require Import VST.concurrency.juicy.juicy_machine.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.addressFiniteMap.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.juicy.JuicyMachineModule.
Require Import VST.concurrency.juicy.sync_preds_defs.
Require Import VST.concurrency.juicy.sync_preds.
Require Import VST.concurrency.juicy.join_lemmas.

Require Import VST.concurrency.juicy.semax_invariant.
Require Import VST.concurrency.juicy.semax_initial.
Require Import VST.concurrency.juicy.semax_progress.
Require Import VST.concurrency.juicy.semax_preservation_jspec.
Require Import VST.concurrency.juicy.semax_safety_makelock.
Require Import VST.concurrency.juicy.semax_safety_spawn.
Require Import VST.concurrency.juicy.semax_safety_release.
Require Import VST.concurrency.juicy.semax_safety_freelock.
Require Import VST.concurrency.juicy.semax_preservation.
Require Import VST.concurrency.juicy.semax_simlemmas.

Set Bullet Behavior "Strict Subproofs".

Section juicy.

Existing Instance JuicyMachineShell.
Existing Instance HybridMachineSig.HybridCoarseMachine.DilMem.
Existing Instance HybridMachineSig.HybridCoarseMachine.scheduler.

Context (ge : genv).

Inductive jmsafe : nat -> cm_state -> Prop :=
| jmsafe_0 m tr sch tp : jmsafe 0 (m, (tr, sch, tp))
| jmsafe_halted n m tr tp : jmsafe n (m, (tr, nil, tp))
| jmsafe_core n m m' tr tr' sch (tp tp' : jstate ge):
    JuicyMachine.machine_step(Sem := JSem) sch tr tp m sch tr' tp' m' ->
    tp_bupd (fun tp' => jmsafe n (m', (tr', sch, tp'))) tp' ->
    jmsafe (S n) (m, (tr, sch, tp))
| jmsafe_sch n m m' i tr tr' sch (tp tp' : jstate ge):
    JuicyMachine.machine_step(Sem := JSem) (i :: sch) tr tp m sch tr' tp' m' ->
    (forall sch', tp_bupd (fun tp' => jmsafe n (m', (tr', sch', tp'))) tp') ->
    jmsafe (S n) (m, (tr, i :: sch, tp)).

Lemma step_sch_irr i tr tr' sch sch' (tp : jstate ge) m tp' m' :
  JuicyMachine.machine_step(Sem := JSem) (i :: sch) tr tp m sch tr' tp' m' ->

Lemma schstep_norun i sch tr tr' tp m tp' m' :
  JuicyMachine.machine_step(Sem := JSem) (i :: sch) tr tp m sch tr' tp' m' ->

End juicy.

Record CSL_proof := {
  CSL_prog : Clight.program;
  CSL_CS: compspecs;
  CSL_V : varspecs; 
  CSL_G : funspecs;
  CSL_ext_link : string -> ident;
  CSL_ext_link_inj : forall s1 s2, CSL_ext_link s1 = CSL_ext_link s2 -> s1 = s2;
  CSL_all_safe : semax_prog.semax_prog (Concurrent_Espec unit CSL_CS CSL_ext_link)
                             CSL_prog CSL_V CSL_G;
  CSL_init_mem_not_none : Genv.init_mem CSL_prog <> None;
}.

Section Safety.
  Variable CPROOF: CSL_proof.
  Definition CS :=   CPROOF.(CSL_CS).
  Definition V :=   CPROOF.(CSL_V).
  Definition G :=   CPROOF.(CSL_G).
  Definition ext_link :=   CPROOF.(CSL_ext_link).
  Definition ext_link_inj :=   CPROOF.(CSL_ext_link_inj).
  Definition prog :=   CPROOF.(CSL_prog).
  Definition all_safe :=   CPROOF.(CSL_all_safe).
  Definition init_mem_not_none :=   CPROOF.(CSL_init_mem_not_none).

  Definition Jspec' := (@OK_spec (Concurrent_Espec unit CS ext_link)).

  Definition inv Gamma n state :=
    exists m, (n <= m)%nat /\ state_invariant(ge := globalenv prog) Jspec' Gamma m state.

  Lemma inv_sch_irr Gamma n m i tr sch sch' tp :
    inv Gamma n (m, (tr, i :: sch, tp)) ->
    inv Gamma n (m, (tr, i :: sch', tp)).

  Lemma no_Krun_inv Gamma n m tr sch sch' tp :
    (1 < pos.n (num_threads tp) -> no_Krun tp)%nat ->

  Lemma blocked_at_external_dec state ef : {blocked_at_external state ef} + {~blocked_at_external(ge := globalenv prog) state ef}.

  Lemma safety_bupd : forall state n Gamma, (exists state', state_step state state' /\
    (state_invariant Jspec' Gamma n state' \/ state_invariant Jspec' Gamma (S n) state')) ->
    exists state',
      state_step(ge := globalenv prog) state state' /\
      (state_bupd (state_invariant Jspec' Gamma n) state' \/
       state_bupd (state_invariant Jspec' Gamma (S n)) state').

  Theorem safety_induction Gamma n state :
    state_invariant Jspec' Gamma (S n) state ->
    exists state',
      state_step(ge := globalenv prog) state state' /\
      (state_bupd (state_invariant Jspec' Gamma n) state' \/
       state_bupd (state_invariant Jspec' Gamma (S n)) state').

  Lemma tp_bupd_mono : forall (P Q : jstate (globalenv prog) -> Prop) tp,
    (forall phi tp' phi', tp_update tp phi tp' phi' ->
       P tp' -> Q tp') ->
    tp_bupd P tp -> tp_bupd Q tp.

  Lemma inv_step Gamma n state :
    inv Gamma (S n) state ->
    exists state',
      state_step state state' /\
      state_bupd (inv Gamma n) state'.

  Lemma num_tp_update : forall tp tp' phi phi', tp_update(ge := globalenv prog) tp phi tp' phi' ->
    num_threads tp' = num_threads tp.

  Lemma no_Krun_stable_update tp tp' phi phi' : no_Krun tp -> tp_update tp phi tp' phi' ->
    no_Krun(ge := globalenv prog) tp'.

  Lemma invariant_safe Gamma n state :
    inv Gamma n state -> jmsafe (globalenv prog) n state.

  Definition init_mem : { m | Genv.init_mem prog = Some m } := init_m prog init_mem_not_none.

  Definition spr :=
    semax_prog_rule'
      (Concurrent_Espec unit CS ext_link) V G prog
      (proj1_sig init_mem) 0 all_safe (proj2_sig init_mem).

  Definition initial_corestate : corestate := projT1 (projT2 spr).

  Definition initial_jm (n : nat) : juicy_mem := proj1_sig (snd (projT2 (projT2 spr)) n tt).

  Definition initial_machine_state (n : nat) :=
    @OrdinalPool.mk LocksAndResources (@JSem (globalenv prog))
      (pos.mkPos (le_n 1))
      (fun _ => Krun initial_corestate)
      (fun _ => m_phi (initial_jm n))
      (addressFiniteMap.AMap.empty _).

  Definition NoExternal_Espec : external_specification mem external_function unit :=
    Build_external_specification
      _ _ _
      
      (fun _ => False)
      (fun _ _ _ _ _ _ _ => False)
      (fun _ _ _ _ _ _ _ => False)
            (fun _ _ _ => Logic.True).

  Definition NoExternal_Hrel : nat -> mem -> mem -> Prop := fun _ _ _ => False.

  Theorem jmsafe_initial_state sch n :
    jmsafe (globalenv prog) n ((proj1_sig init_mem), (nil, sch, initial_machine_state n)).

  Lemma initial_corestate_initial :
    exists b, Genv.find_symbol (globalenv prog) (prog_main prog) = Some b /\

  Lemma jmsafe_csafe n m tr sch s : jmsafe (globalenv prog) n (m, (tr, sch, s)) -> jm_csafe (sch, tr, s) m n.

  Theorem safety_initial_state (sch : schedule) (n : nat) :
    jm_csafe (sch, nil, initial_machine_state n) (proj1_sig init_mem) n.

End Safety. *)

Require Import VST.concurrency.common.permissions.
(* VST.concurrency.common.permissions:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool
        ssrnat ssrfun eqtype seq fintype finfun.

Set Implicit Arguments.
Require Import VST.msl.Coqlib2.
Require Import VST.sepcomp.mem_lemmas.
Require Import VST.sepcomp.event_semantics.
Require Import VST.concurrency.common.threads_lemmas.
Require Import VST.concurrency.common.permjoin_def.
Require Import compcert.common.Memory.
Require Import compcert.common.Values. 
Require Import compcert.lib.Integers.
Require Export compcert.lib.Maps.
Require Import Coq.ZArith.ZArith.
From VST.veric Require Import shares juicy_mem juicy_mem_lemmas.
Require Import VST.msl.msl_standard.
Require Import FunInd.
Import cjoins.

Require Import ProofIrrelevance.

Lemma po_refl: forall p, Mem.perm_order'' p p.

Lemma perm_order_antisym :
  forall p p'
    (Hlt: Mem.perm_order'' p p')

Definition access_map := Maps.PMap.t (Z -> option permission).
Definition delta_map := Maps.PTree.t (Z -> option (option permission)).

Section permMapDefs.

  Definition empty_map : access_map :=
    (fun z => None, Maps.PTree.empty (Z -> option permission)).

  Lemma empty_map_spec: forall b ofs,
      Maps.PMap.get b empty_map ofs = None.

  Definition permission_at (m : mem) (b : block) (ofs : Z) (k : perm_kind) :=
    Maps.PMap.get b (Mem.mem_access m) ofs k.

  Definition perm_coh (p1 p2 : option permission) :=
    match p1 with
    | Some Freeable | Some Writable | Some Readable =>
                                      match p2 with
                                      | None => True
                                      | _ => False
                                      end
    | Some Nonempty | None =>
                      match p2 with
                      | Some Freeable => False
                      | _ => True
                      end
    end.

  Lemma perm_coh_lower:
    forall p1 p2 p3 p4
      (Hpu: perm_coh p1 p2)
      (Hperm2: Mem.perm_order'' p2 p4)

  Lemma perm_coh_not_freeable:
    forall p p',
      perm_coh p p' ->
      p' <> Some Freeable.

  Lemma perm_coh_empty_1:
    forall p,
      perm_coh p None.

  Lemma perm_coh_empty_2:
    forall p : option permission,
      Mem.perm_order'' (Some Writable) p ->

  Lemma perm_of_glb_not_Freeable: forall sh,
      ~ perm_of_sh (Share.glb Share.Rsh sh) = Some Freeable.

  Lemma perm_coh_self: forall res,
      perm_coh (perm_of_res res)
               (perm_of_res_lock res).

  Lemma perm_coh_joins:
    forall a b, joins a b ->
           perm_coh (perm_of_res a) (perm_of_res_lock b).

  Lemma po_join_sub_lock:
  forall r1 r2 ,
    join_sub r2 r1 ->
    Mem.perm_order'' (perm_of_res_lock r1) (perm_of_res_lock r2).

  Definition permMapCoherence (pmap1 pmap2 : access_map) :=
    forall b ofs, perm_coh (pmap1 !! b ofs) (pmap2 !! b ofs).

  Lemma permCoh_empty: forall r,
      (forall b ofs, Mem.perm_order'' (Some Writable) (r !! b ofs)) ->

  Lemma permCoh_empty': forall x,
      permMapCoherence x empty_map.

  Lemma perm_of_res_lock_not_Freeable:
    forall r,
      Mem.perm_order'' (Some Writable) (perm_of_res_lock r).

  Definition perm_union (p1 p2 : option permission) : option (option permission) :=
    match p1,p2 with
      | None, _ => Some p2
      | _, None => Some p1
      | Some p1', Some p2' =>
        match p1', p2' with
          | Freeable, _ => None
          | _, Freeable => None
          | Nonempty, _ => Some p2
          | _, Nonempty => Some p1
          | Writable, _ => None
          | _, Writable => None
          | Readable, Readable => Some (Some Readable)
        end
    end.

  Lemma perm_union_comm :
    forall p1 p2,
      perm_union p1 p2 = perm_union p2 p1.

  Lemma perm_union_result : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                              pu = p1 \/ pu = p2.

  Lemma perm_union_ord : forall p1 p2 pu (Hunion: perm_union p1 p2 = Some pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Lemma perm_union_lower:
    forall p1 p2 p3
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p2 p3),

  Lemma perm_union_lower_2:
    forall p1 p2 p3 p4
      (Hpu: exists pu, perm_union p1 p2 = Some pu)
      (Hperm: Mem.perm_order'' p1 p3)

  Inductive not_racy : option permission -> Prop :=
  | empty : not_racy None.

  Inductive racy : option permission -> Prop :=
  | freeable : racy (Some Freeable).

  Lemma not_racy_union :
    forall p1 p2 (Hnot_racy: not_racy p1),
    exists pu, perm_union p1 p2 = Some pu.

  Lemma no_race_racy : forall p1 p2 (Hracy: racy p1)
                              (Hnorace: exists pu, perm_union p1 p2 = Some pu),
                         not_racy p2.

  Lemma perm_order_clash:
    forall p p'
      (Hreadable: Mem.perm_order' p Readable)

  Lemma perm_order_incompatible:
    forall p p'
      (Hreadable: Mem.perm_order'' p (Some Readable))

  Definition perm_max (p1 p2 : option permission) : option permission :=
    match p1,p2 with
      | Some Freeable, _ => p1
      | _, Some Freeable => p2
      | Some Writable, _ => p1
      | _, Some Writable => p2
      | Some Readable, _ => p1
      | _, Some Readable => p2
      | Some Nonempty, _ => p1
      | _, Some Nonempty => p2
      | None, None => None
    end.

  Lemma perm_max_comm :
    forall p1 p2,
      perm_max p1 p2 = perm_max p2 p1.

  Lemma perm_max_result : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                            pu = p1 \/ pu = p2.

  Lemma perm_max_ord : forall p1 p2 pu (Hmax: perm_max p1 p2 = pu),
                           Mem.perm_order'' pu p1 /\ Mem.perm_order'' pu p2.

  Definition getMaxPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Max) (Mem.mem_access m).

  Definition getCurPerm (m : mem) : access_map :=
    Maps.PMap.map (fun f => fun ofs => f ofs Cur) (Mem.mem_access m).

  Definition getPermMap (m : mem) : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    Mem.mem_access m.

  Lemma getCur_Max : forall m b ofs,
                       Mem.perm_order'' (Maps.PMap.get b (getMaxPerm m) ofs)

  Lemma getMaxPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getMaxPerm m) ofs = permission_at m b ofs Max.

  Lemma getCurPerm_correct :
    forall m b ofs,
      Maps.PMap.get b (getCurPerm m) ofs = permission_at m b ofs Cur.

  Definition permDisjoint p1 p2:=
    exists pu : option permission,
      perm_union p1 p2 = Some pu.

   Lemma permDisjoint_None: forall p,
      permDisjoint None p.

  Lemma permDisjoint_comm: forall p1 p2,
      permDisjoint p1 p2 -> permDisjoint p2 p1.

  Lemma permDisjointLT: forall a b c,
      permDisjoint a c ->
      Mem.perm_order'' a b ->

  Ltac if_simpl:=
    repeat match goal with
           | [ H: ?X = true |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = false |- context[if ?X then _ else _] ] => rewrite H; simpl 
           | [ H: ?X = left _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: ?X = right _ |- context[match ?X with left _ => _ | right _ => _ end] ]=>
             rewrite H; simpl 
           | [ H: (@is_left _ _ ?X) = true |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           | [ H: (@is_left _ _ ?X) = false |-
               context [match ?X with left _ => _ | right _ => _ end ]] => destruct X; inversion H
           end.

  Ltac permDisj_solve:= eexists; simpl; reflexivity.
  
  Lemma join_sh_permDisjoint:
        forall sh1 sh2,
          joins sh1 sh2 ->
          permDisjoint (perm_of_sh sh1) (perm_of_sh sh2).
  
  Lemma writable0_not_join_readable:
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ readable_share sh2.

  Lemma writable0_not_join_writable0 :
    forall sh1 sh2,
      joins sh1 sh2 ->
      writable0_share sh1 ->
      ~ writable0_share sh2.
 
  Lemma joins_permDisjoint: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res r1) (perm_of_res r2).
  
  Ltac glb_contradictions:=
    repeat match goal with
           | [ H: writable0_share_dec _ = _ |- _ ] => clear H
           end;
    match goal with
    | [ H:  Share.glb Share.Rsh ?sh = Share.top  |- _ ] =>
      exfalso; eapply glb_Rsh_not_top; eassumption
    | [ H: writable0_share (Share.glb Share.Rsh ?sh) |- _ ] =>
      eapply writable0_right in H
    end; join_sh_contradiction.
  
  Lemma joins_permDisjoint_lock: forall r1 r2,
      joins r1 r2 ->
      permDisjoint (perm_of_res_lock r1) (perm_of_res_lock r2).
  
  Definition permMapsDisjoint (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs, exists pu,
      perm_union ((Maps.PMap.get b pmap1) ofs)
                 ((Maps.PMap.get b pmap2) ofs) = Some pu.

  Definition permMapsDisjoint2 (pmap pmap': access_map * access_map) :=
    permMapsDisjoint pmap.1 pmap'.1 /\
    permMapsDisjoint pmap.2 pmap'.2.

  Lemma permDisjoint_permMapsDisjoint: forall r1 r2,
      (forall b ofs, permDisjoint (r1 !! b ofs) (r2 !! b ofs))->
      permMapsDisjoint r1 r2.

  Lemma permMapsDisjoint_permDisjoint: forall r1 r2 b ofs,
      permMapsDisjoint r1 r2 ->
      permDisjoint (r1 !! b ofs) (r2 !! b ofs).

  Lemma empty_disjoint':
    forall pmap,
      permMapsDisjoint empty_map pmap.
  Lemma empty_disjoint:
    permMapsDisjoint empty_map
                     empty_map.

  Lemma permMapsDisjoint_comm :
    forall pmap1 pmap2
      (Hdis: permMapsDisjoint pmap1 pmap2),
      permMapsDisjoint pmap2 pmap1.

  Lemma permMapsDisjoint2_comm:
    forall pmaps pmaps',
      permMapsDisjoint2 pmaps pmaps' <-> permMapsDisjoint2 pmaps' pmaps.

  Lemma disjoint_norace:
    forall (mi mj : mem) (b : block) (ofs : Z)
      (Hdisjoint: permMapsDisjoint (getCurPerm mi) (getCurPerm mj))
      (Hpermj: Mem.perm mj b ofs Cur Readable)

  Definition isCanonical (pmap : access_map) := pmap.1 = fun _ => None.
  Import Maps.
  Definition TreeMaxIndex {A} (t:Maps.PTree.t A): positive:=
    compcert.lib.Coqlib.list_fold_left (fun a => [eta Pos.max a.1]) 1%positive (Maps.PTree.elements t) .
  Lemma fold_max_monoton: forall  {A} (ls: seq.seq (positive * A)), forall i,
  Lemma fold_max_monoton': forall  {A} (ls: seq.seq (positive * A)), forall i j,
  Lemma TreeMaxIndex_help: forall {A} (ls: seq.seq (positive * A)), forall i v,

  Lemma max_works: forall A (t:PTree.t A) m, (m > TreeMaxIndex t)%positive ->

  Lemma Cur_isCanonical: forall m, isCanonical (getCurPerm m).

  Lemma Max_isCanonical: forall m, isCanonical (getMaxPerm m).

  Definition permMapLt (pmap1 pmap2 : access_map) : Prop :=
    forall b ofs,
      Mem.perm_order'' (Maps.PMap.get b pmap2 ofs)
                       (Maps.PMap.get b pmap1 ofs).

  Lemma empty_LT: forall pmap,
             permMapLt empty_map pmap.

  Lemma canonical_lt :
    forall p' m
      (Hlt: permMapLt p' (getMaxPerm m)),
      isCanonical p'.

   Lemma invalid_block_empty:
    forall pmap m
      (Hlt: permMapLt pmap (getMaxPerm m)),
    forall b, ~ Mem.valid_block m b ->

  Definition setPerm (p : option permission) (b : block)
             (ofs : Z) (pmap : access_map) : access_map :=
    Maps.PMap.set b (fun ofs' => if compcert.lib.Coqlib.zeq ofs ofs' then
                                p
                              else
                                Maps.PMap.get b pmap ofs')
                  pmap.

   Fixpoint setPermBlock (p : option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm p b (ofs + (Z_of_nat len))%Z (setPermBlock p b ofs pmap len)
    end.

  Lemma setPermBlock_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock p b ofs pmap sz)) ofs' =

  Lemma setPermBlock_or:
    forall p b ofs sz pmap b' ofs',
      (setPermBlock p b ofs pmap sz) !! b' ofs' = p \/
      (setPermBlock p b ofs pmap sz) !! b' ofs' = pmap !! b' ofs'.

  Fixpoint setPermBlock_var (fp : nat -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp length) b (ofs + (Z_of_nat len))%Z
              (setPermBlock_var fp b ofs pmap len)
    end.

  Lemma setPermBlock_var_other_2:
    forall p b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock_var p b ofs pmap sz)) ofs' =

   Lemma setPermBlock_var_other_1:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_var_same:
    forall p b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlock_setPermBlock_var:
    forall b ofs sz pmap p,
      setPermBlock p b ofs pmap sz =
      setPermBlock_var (fun _ => p) b ofs pmap sz.

  Lemma permMapCoherence_increase:
    forall pmap pmap' b ofs sz_nat sz
      (Hsz: sz = Z.of_nat (sz_nat))

  Fixpoint setPermBlockFunc (fp : Z -> option permission) (b : block)
           (ofs : Z) (pmap : access_map) (length: nat): access_map :=
    match length with
      0 => pmap
    | S len =>
      setPerm (fp (ofs + (Z_of_nat len))%Z) b (ofs + (Z_of_nat len))%Z (setPermBlockFunc fp b ofs pmap len)
    end.

  Lemma setPermBlockFunc_same:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs <= ofs' < ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_1:
    forall fp b ofs ofs' pmap sz
      (Hofs: (ofs' < ofs)%Z \/ (ofs' >= ofs + (Z.of_nat sz))%Z),

  Lemma setPermBlockFunc_other_2:
    forall fp b b' ofs ofs' pmap sz,
      b <> b' ->
      (Maps.PMap.get b' (setPermBlock fp b ofs pmap sz)) ofs' =

  Lemma setPermBlock_coherent:
    forall pmap pmap' b ofs sz
      (Hcoh: permMapCoherence pmap pmap')
      (Hnonempty: forall ofs', Intv.In ofs' (ofs, ofs + Z.of_nat sz)%Z ->

  Definition computeMap (pmap : access_map) (delta : delta_map) : access_map :=
    (pmap.1,
     @Maps.PTree.combine (Z -> option permission) (Z -> option (option permission))
                         (Z -> option permission)
                         (fun p1 pd => match pd, p1 with
                                    | Some pd', Some p1' =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => p1' z
                                                  end)
                                    | Some pd', None =>
                                      Some (fun z => match pd' z with
                                                    Some pd'' => pd''
                                                  | _ => pmap.1 z
                                                  end)
                                    | None, _ => p1
                                    end)
                         pmap.2 delta).

  Lemma computeMap_1 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df (p : option permission),
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_2 :
    forall (pmap : access_map) (dmap : delta_map) b ofs df,
      Maps.PTree.get b dmap = Some df ->

  Lemma computeMap_3 :
    forall (pmap : access_map) (dmap : delta_map) b ofs,
      Maps.PTree.get b dmap = None ->

  Import Maps BlockList.

  Definition maxF (f : Z -> perm_kind -> option permission) :=
    fun ofs k => match k with
              | Max => Some Freeable
              | Cur => f ofs k
              end.

  Definition allF (f : Z -> perm_kind -> option permission) :=
    fun (_ : Z) (_ : perm_kind) => Some Freeable.

  Fixpoint PList (f : (Z -> perm_kind -> option permission) ->
                      Z -> perm_kind -> option permission)
           l m : list (positive * (Z -> perm_kind -> option permission)) :=
    match l with
      | nil => nil
      | x :: l =>
        (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m)
  end.

  Lemma PList_app :
    forall l m x f,
      (PList f l m) ++ ((Pos.of_nat x,

  Lemma PList_cons :
    forall f l m x,
      (Pos.of_nat x, f (PMap.get (Pos.of_nat x) m)) :: (PList f l m) =

  Lemma PList_correct :
    forall f l m k v
           (HInl: List.In k l)

  Lemma PList_mkBlock_complete :
    forall f k v m n
           (Hk: k > 0)
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m)),

  Lemma PList_mkBlock_det :
    forall n f k v v' m
           (HIn1: List.In (Pos.of_nat k, v) (PList f (mkBlockList n) m))

  Fixpoint canonicalPTree (l : list (positive * (Z -> perm_kind -> option permission))) :=
    match l with
      | nil => PTree.empty _
      | x :: l =>
        PTree.set (fst x) (snd x) (canonicalPTree l)
    end.

  Lemma canonicalPTree_elements :
    forall l x
           (Hin: List.In x (PTree.elements (canonicalPTree l))),

  Lemma canonicalPTree_get_complete :
    forall l m k f fn
           (HGet: (canonicalPTree (PList fn l m)) ! k = Some f),
      List.In (k, f) (PList fn l m).

  Lemma canonicalPTree_get_sound :
    forall n m k fn
           (Hk: k > 0)
           (Hn: n > 1)
           (HGet: (canonicalPTree (PList fn (mkBlockList n) m)) ! (Pos.of_nat k) = None),

  Definition canonicalPMap fn n m : Maps.PMap.t (Z -> perm_kind -> option permission) :=
    let l := mkBlockList n in
    (fun _ _ => None, canonicalPTree (PList fn l m)).

  Lemma canonicalPMap_sound :
    forall k n m fn
           (Hk : k > 0)
           (Hkn : k < n),
      fn (m !! (Pos.of_nat k)) = (canonicalPMap fn n m) !! (Pos.of_nat k).

  Lemma canonicalPMap_default :
    forall n k m fn
           (Hkn : k >= n),
      (canonicalPMap fn n m) !! (Pos.of_nat k) = fun _ _ => None.

  Definition setMaxPerm (m : mem) : mem.

  Lemma setMaxPerm_Max :
    forall m b ofs,
      (Mem.valid_block m b ->

   Lemma setMaxPerm_MaxV :
    forall m b ofs,
      Mem.valid_block m b ->

  Lemma setMaxPerm_MaxI :
    forall m b ofs,
      ~ Mem.valid_block m b ->

  Lemma setMaxPerm_Cur :
    forall m b ofs,
      permission_at (setMaxPerm m) b ofs Cur = permission_at m b ofs Cur.

  Definition makeCurMax_map (mem_access:PMap.t (Z -> perm_kind -> option permission)):
    PMap.t (Z -> perm_kind -> option permission):=
    PMap.map (fun f => fun z k => f z Max) mem_access.

  Definition makeCurMax (m:mem): mem.

  Lemma makeCurMax_correct :
    forall m b ofs k,
      permission_at m b ofs Max = permission_at (makeCurMax m) b ofs k.

  Lemma makeCurMax_valid :
    forall m b,
      Mem.valid_block m b <-> Mem.valid_block (makeCurMax m) b.

  Definition restrPermMap p' m (Hlt: permMapLt p' (getMaxPerm m)) : mem.

Lemma restrPermMap_irr:
      forall p1 p2 m1 m2
        (P1: permMapLt p1 (getMaxPerm m1))
        (P2: permMapLt p2 (getMaxPerm m2)),
        p1 = p2 -> m1 = m2 ->
        restrPermMap P1 = restrPermMap P2.
    Lemma restrPermMap_ext:
      forall p1 p2 m
        (P1: permMapLt p1 (getMaxPerm m))
        (P2: permMapLt p2 (getMaxPerm m)),
        (forall b, (p1 !! b) = (p2 !! b)) ->
        restrPermMap P1 = restrPermMap P2.

  Lemma restrPermMap_nextblock :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      Mem.nextblock (restrPermMap Hlt) = Mem.nextblock m.

  Lemma restrPermMap_valid :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      Mem.valid_block (restrPermMap Hlt) b <-> Mem.valid_block m b.

  Lemma restrPermMap_contents :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      contents_at (restrPermMap Hlt) = contents_at m.

  Lemma restrPermMap_max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)),
      max_access_at (restrPermMap Hlt) = max_access_at m.

  Lemma getMax_restr :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b,
      (getMaxPerm (restrPermMap Hlt)) !!  b = (getMaxPerm m) !! b.

  Lemma restrPermMap_irr' : forall p' p'' m
                             (Hlt : permMapLt p' (getMaxPerm m))
                             (Hlt': permMapLt p'' (getMaxPerm m))
                             (Heq_new: p' = p''),
                             restrPermMap Hlt = restrPermMap Hlt'.

  Lemma restrPermMap_disjoint_inv:
    forall (mi mj m : mem) (pi pj : access_map)
      (Hltj: permMapLt pj (getMaxPerm m))
      (Hlti: permMapLt pi (getMaxPerm m))
      (Hdisjoint: permMapsDisjoint pi pj)
      (Hrestrj: restrPermMap Hltj = mj)
      (Hrestri: restrPermMap Hlti = mi),
      permMapsDisjoint (getCurPerm mi) (getCurPerm mj).

  Lemma restrPermMap_correct :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m))
      b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs /\

  Corollary restrPermMap_Cur :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Cur =
      Maps.PMap.get b p' ofs.

  Corollary restrPermMap_Max :
    forall p' m (Hlt: permMapLt p' (getMaxPerm m)) b ofs,
      permission_at (restrPermMap Hlt) b ofs Max =
      Maps.PMap.get b (getMaxPerm m) ofs.

  Lemma restrPermMap_can : forall (p : access_map) (m m': mem)
                             (Hlt: permMapLt p (getMaxPerm m))
                             (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getCurPerm m').

  Lemma restrPermMap_can_max : forall (p : access_map) (m m': mem)
                                 (Hlt: permMapLt p (getMaxPerm m))
                                 (Hrestrict: restrPermMap Hlt = m'),
      isCanonical (getMaxPerm m').

  Definition erasePerm (m : mem) : mem.

  Lemma erasePerm_Perm :
    forall m b ofs k ,
      (Mem.valid_block m b ->

   Lemma erasePerm_V :
    forall m b ofs k,
      Mem.valid_block m b ->

  Lemma erasePerm_I :
    forall m b ofs k,
      ~ Mem.valid_block m b ->

   Definition decay m_before m_after := forall b ofs,
      (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k,
           (Maps.PMap.get b (Mem.mem_access m_before) ofs k = Some Freeable /\
            Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) \/
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Definition strong_decay m_before m_after := forall b ofs,
       (~Mem.valid_block m_before b ->
       Mem.valid_block m_after b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = Some Freeable)
       \/ (forall k, Maps.PMap.get b (Mem.mem_access m_after) ofs k = None)) /\
      (Mem.valid_block m_before b ->
       (forall k, Maps.PMap.get b (Mem.mem_access m_before) ofs k =
             Maps.PMap.get b (Mem.mem_access m_after) ofs k)).

   Lemma strong_decay_implies_decay:
     forall m m',
       strong_decay m m' ->
       decay m m'.

  Lemma decay_refl:
    forall m,
      decay m m.

  Lemma decay_trans :
    forall m m' m'',
      (forall b, Mem.valid_block m b -> Mem.valid_block m' b) ->

  Definition permMapJoin (pmap1 pmap2 pmap3: access_map) :=
    forall b ofs,
      permjoin ((pmap1 !! b) ofs) ((pmap2 !! b) ofs) ((pmap3 !! b) ofs).

  Lemma permMapJoin_order:
    forall p1 p2 p3
      (Hjoin: permMapJoin p1 p2 p3),
    forall b ofs,
      Mem.perm_order'' (p3 !! b ofs) (p1 !! b ofs) /\

  Lemma permMapLt_invalid_block:
    forall pmap m b ofs
      (Hlt: permMapLt pmap (getMaxPerm m))
      (Hinvalid: ~ Mem.valid_block m b),

  Lemma perm_order_valid_block:
    forall pmap m b ofs p
      (Hperm: Mem.perm_order'' (pmap !! b ofs) (Some p))

  Definition perm_order''_dec : forall (op op' : option permission),
      {Mem.perm_order'' op op'} + {~ Mem.perm_order'' op op'}.

  Definition perm_eq_dec: forall (op op' : option permission),
      {op = op'} + {~ op = op'}.

End permMapDefs.

Require Import VST.concurrency.common.core_semantics.
Require Import compcert.lib.Coqlib.

Lemma storebytes_decay:
  forall m loc p vl m', Mem.storebytes m loc p vl = Some m' -> decay m m'.

Lemma alloc_decay:
  forall m lo hi m1 b1, Mem.alloc m lo hi = (m1,b1) -> decay m m1.

Lemma free_decay: forall m b lo hi m', Mem.free m b lo hi = Some m' -> decay m m'.

Lemma msem_decay: 
  forall C (Sem: MemSem C) c m c' m',
   corestep (csem Sem)  c m c' m' ->
  decay m m'. *)



Require Import VST.concurrency.juicy.erasure_signature.
(* VST.concurrency.juicy.erasure_signature:
Require Import compcert.common.Memory.

Require Import VST.concurrency.common.threadPool.
Require Import VST.concurrency.common.scheduler.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.semantics.
Require Import VST.concurrency.juicy.juicy_machine. Import Concur.
Require Import VST.concurrency.common.HybridMachine.

Definition init_inj_ok (j: Values.Val.meminj) m:=
  forall b b' ofs, j b = Some (b', ofs) ->
              b = b' /\
              Mem.valid_block m b.

Module Type ErasureSig.

  Import HybridMachineSig.

  Declare Instance Sem (ge : Clight.genv) : Semantics.

  Declare Instance JR : Resources.
  Declare Instance JTP (ge : Clight.genv) : ThreadPool.ThreadPool(Sem := Sem ge).
  Declare Instance JMS (ge : Clight.genv) : MachineSig(ThreadPool := JTP ge).
  Declare Instance DilMem : DiluteMem.
  Declare Instance scheduler : Scheduler.
  Declare Instance JuicyMachine (ge : Clight.genv) : HybridMachine(machineSig:=JMS ge).
  Notation JMachineSem ge := (MachineSemantics(HybridMachine := JuicyMachine ge)).
  Notation jres := (@res JR).
  Notation jstate ge := (@ThreadPool.t _ _ (JTP ge)).
  Notation jmachine_state ge := (@MachState _ _ (JTP ge)).
  Declare Instance DR : Resources.
  Declare Instance DTP (ge : Clight.genv) : ThreadPool.ThreadPool(Sem := Sem ge).
  Declare Instance DMS (ge : Clight.genv) : MachineSig(ThreadPool := DTP ge).
  Declare Instance DryMachine (ge : Clight.genv) : HybridMachine(machineSig := DMS ge).
  Notation DMachineSem ge := (MachineSemantics(HybridMachine := DryMachine ge)).
  Notation dres := (@res DR).
  Notation dstate ge := (@ThreadPool.t _ _ (DTP ge)).
  Notation dmachine_state ge := (@MachState _ _ (DTP ge)).

  Parameter match_st : forall (ge : Clight.genv), jstate ge -> dstate ge -> Prop.

  Axiom MTCH_cnt: forall {ge js tid ds},
      match_st ge js ds ->
      ThreadPool.containsThread js tid -> ThreadPool.containsThread ds tid.
  Axiom MTCH_cnt': forall {ge js tid ds},
      match_st ge js ds ->
      ThreadPool.containsThread ds tid -> ThreadPool.containsThread js tid.

  Axiom  MTCH_getThreadC: forall ge js ds tid c,
      forall (cnt: ThreadPool.containsThread js tid)
        (cnt': ThreadPool.containsThread ds tid)
        (M: match_st ge js ds),
        ThreadPool.getThreadC cnt =  c ->
        ThreadPool.getThreadC cnt'  =  c.

  Axiom MTCH_compat: forall ge js ds m,
      match_st ge js ds ->
      mem_compatible js m ->
      mem_compatible ds m.

  Axiom MTCH_updt:
    forall ge js ds tid c
      (H0:match_st ge js ds)
      (cnt: ThreadPool.containsThread js tid)
      (cnt': ThreadPool.containsThread ds tid),
      match_st ge (ThreadPool.updThreadC cnt c)
               (ThreadPool.updThreadC cnt' c).

  Axiom core_diagram:
    forall ge (m : mem)  (U0 U U': _) rmap pmap
      (ds : dstate ge) dtr (js js': jstate ge) jtr jtr'
      (m' : mem),
      corestep (JMachineSem ge U0 rmap) (U, jtr, js) m (U', jtr', js') m' ->
      match_st ge js ds ->
      invariant ds ->
      exists (ds' : dstate ge),
        invariant ds' /\
        match_st ge js' ds' /\
        exists dtr', corestep (DMachineSem ge U0 pmap) (U, dtr, ds) m (U', app dtr dtr', ds') m'.

  Axiom halted_diagram:
    forall ge U (ds : dmachine_state ge) (js : jmachine_state ge)  rmap pmap,
      fst (fst js) = fst (fst ds) ->
      halted (JMachineSem ge U rmap) js = halted (DMachineSem ge U pmap) ds.

End ErasureSig.

Module ErasureFnctr (PC:ErasureSig).
  Import HybridMachineSig PC.

  Section ErasureFnctr.

    Context (ge : Clight.genv).
    Notation jres := (@res JR).
    Notation jstate := (@ThreadPool.t _ _ (JTP ge)).
    Notation jmachine_state := (@MachState _ _ (JTP ge)).
    Notation dres := (@res DR).
    Notation dstate := (@ThreadPool.t _ _ (DTP ge)).
    Notation dmachine_state := (@MachState _ _ (DTP ge)).
    Instance DMS : MachineSig(ThreadPool := DTP ge) := DMS ge.
    Instance Sem : Semantics := Sem ge.
    Notation match_st := (match_st ge).

    Inductive init_inv:  Values.Val.meminj ->
                         semG -> list Values.val -> mem ->
                         semG -> list Values.val -> mem -> Prop:=
    |InitEq: forall j g1 args1 m1 g2 args2 m2,
        g1 = g2 ->
        args1 = args2 ->
        m1 = m2 ->
        init_inj_ok j m1 ->
        init_inv j g1 args1 m1 g2 args2 m2.

    Inductive halt_inv:  Values.Val.meminj ->
                         semG -> Values.val -> mem ->
                         semG -> Values.val -> mem -> Prop:=
    |HaltEq: forall j g1 args1 m1 g2 args2 m2,
        g1 = g2 ->
        args1 = args2 ->
        m1 = m2 ->
        halt_inv j g1 args1 m1 g2 args2 m2.

    Definition ge_inv: semG -> semG -> Prop:= @eq semG.
    Definition core_data:= unit.
    Definition core_ord: unit-> unit -> Prop := fun _ _ => False.

    Inductive match_state :
      core_data ->  Values.Val.meminj -> jmachine_state ->  mem -> dmachine_state -> mem -> Prop:=
      MATCH: forall d j js ds U m,
        invariant ds -> 
        match_st js ds ->
        match_state d j  (U, nil, js) m (U, nil, ds) m.

    Lemma core_ord_wf:  well_founded core_ord.

  End ErasureFnctr.

End ErasureFnctr. *)

Require Import VST.concurrency.juicy.erasure_proof.
(* VST.concurrency.juicy.erasure_proof:
Require Import ProofIrrelevance.

Require Import compcert.common.Memory.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.

Require Import VST.concurrency.common.threadPool. Import addressFiniteMap.
Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.common.bounded_maps.
Require Import VST.concurrency.juicy.juicy_machine.
Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.dry_machine_lemmas.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permissions.
Require Import VST.concurrency.juicy.sync_preds.

Require Import VST.concurrency.juicy.JuicyMachineModule.
Require Import VST.concurrency.common.ClightMachine.

Require Import VST.concurrency.juicy.erasure_signature.

From mathcomp.ssreflect Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Require Import VST.concurrency.common.ssromega. 
From mathcomp.ssreflect Require Import ssreflect seq.

Set Bullet Behavior "Strict Subproofs".

Module Parching <: ErasureSig.
  Import THE_JUICY_MACHINE.
  Import Clight_newMachine.
  Import DMS.
  Import ThreadPoolWF.

  Section Parching.

  Context (ge : Clight.genv).

  Instance Sem : Semantics := ClightSemanticsForMachines.Clight_newSem ge.

  Instance JR : Resources := LocksAndResources.
  Instance JTP : ThreadPool.ThreadPool := OrdinalPool.OrdinalThreadPool.
  Instance JMS : MachineSig := Concur.JuicyMachineShell.
  Instance DilMem : DiluteMem := HybridMachineSig.HybridCoarseMachine.DilMem.
  Instance scheduler : Scheduler := HybridCoarseMachine.scheduler.
  Instance JuicyMachine : HybridMachine := HybridCoarseMachine.HybridCoarseMachine.
  Definition jstate := jstate ge.

  Instance DR : Resources := DryHybridMachine.dryResources.
  Instance DTP : ThreadPool.ThreadPool := OrdinalPool.OrdinalThreadPool.
  Instance DMS : MachineSig := DryHybridMachine.DryHybridMachineSig.
  Instance DryMachine : HybridMachine := HybridCoarseMachine.HybridCoarseMachine.
  Definition dstate := ThreadPool.t
                         (ThreadPool := OrdinalPool.OrdinalThreadPool)
                         .
                         
  Definition dmachine_state:= MachState(ThreadPool := OrdinalPool.OrdinalThreadPool).

  Import event_semantics threadPool.ThreadPool.

  Inductive match_st' : jstate ->  dstate -> Prop:=
    MATCH_ST: forall (js:jstate) (ds:dstate)
                (mtch_cnt: forall {tid},  containsThread js tid -> containsThread ds tid )
                (mtch_cnt': forall {tid}, containsThread ds tid -> containsThread js tid )
                (mtch_gtc: forall {tid} (Htid:containsThread js tid)(Htid':containsThread ds tid),
                    getThreadC Htid = getThreadC Htid' )
                (mtch_perm1: forall b ofs {tid} (Htid:containsThread js tid)(Htid':containsThread ds tid),
                    juicy_mem.perm_of_res (resource_at (getThreadR Htid) (b, ofs)) =
                    ((getThreadR Htid').1 !! b) ofs )
                (mtch_perm2: forall b ofs {tid} (Htid:containsThread js tid)(Htid':containsThread ds tid),
                    juicy_mem.perm_of_res_lock (resource_at (getThreadR Htid) (b, ofs)) =
                    ((getThreadR Htid').2 !! b) ofs )
                (mtch_locks: forall a,
                    ssrbool.isSome (lockRes js a) = ssrbool.isSome (lockRes ds a))
                (mtch_locksEmpty: forall lock dres,
                    lockRes js lock = Some (None) ->
                    lockRes ds lock = Some dres ->
                   dres = (empty_map, empty_map))
                (mtch_locksRes: forall lock jres dres,
                    lockRes js lock = Some (Some jres) ->
                    lockRes ds lock = Some dres ->
                     forall b ofs,
                       juicy_mem.perm_of_res (resource_at jres (b, ofs)) = (dres.1 !! b) ofs )
                (mtch_locksRes: forall lock jres dres,
                    lockRes js lock = Some (Some jres) ->
                    lockRes ds lock = Some dres ->
                     forall b ofs,
                    juicy_mem.perm_of_res_lock (resource_at jres (b, ofs)) = (dres.2 !! b) ofs )
                ,
      match_st' js ds.
  Definition match_st:= match_st'.

  Lemma MTCH_cnt: forall {js tid ds},
           match_st js ds ->
           containsThread js tid -> containsThread ds tid.
  
  Lemma MTCH_cnt': forall {js tid ds},
           match_st js ds ->
           containsThread ds tid -> containsThread js tid.

  Lemma MTCH_perm: forall {js ds i},
      forall (cnt: containsThread js i)
      (MTCH: match_st js ds),
      forall b ofs,
        juicy_mem.perm_of_res ((getThreadR cnt) @ (b, ofs)) = ((getThreadR (MTCH_cnt MTCH cnt)).1 !! b) ofs.

  Lemma MTCH_perm2: forall {js ds i},
      forall (cnt: containsThread js i)
      (MTCH: match_st js ds),
      forall b ofs,
        juicy_mem.perm_of_res_lock  ((getThreadR cnt) @ (b, ofs)) = ((getThreadR (MTCH_cnt MTCH cnt)).2 !! b) ofs.

  Lemma MTCH_perm': forall {js ds i},
      forall (cnt: containsThread ds i)
      (MTCH: match_st js ds),
      forall b ofs,
        ((getThreadR cnt).1 !! b) ofs =

  Lemma MTCH_perm2': forall {js ds i},
      forall (cnt: containsThread ds i)
      (MTCH: match_st js ds),
      forall b ofs,
        ((getThreadR cnt).2 !! b) ofs =

  Lemma cnt_irr: forall tid (ds : dstate) (cnt1 cnt2: containsThread ds tid),
      getThreadC cnt1 = getThreadC cnt2.

  Lemma MTCH_locks: forall ds js laddr rmap,
      match_st js ds ->
      lockRes ds laddr = Some rmap ->
      exists x, lockRes js laddr = Some x.

  Lemma MTCH_getThreadC: forall js ds tid c,
      forall (cnt: containsThread js tid)
        (cnt': containsThread ds tid)
        (M: match_st js ds),
        getThreadC cnt =  c ->
        getThreadC cnt'  =  c.

  Lemma MTCH_lockSet: forall js ds,
      match_st js ds ->
      forall b ofs, (lockSet js) !! b ofs = (lockSet ds) !! b ofs.

  Lemma MTCH_compat: forall js ds m,
      match_st js ds ->
      mem_compatible js m ->
      mem_compatible ds m.

  Lemma MTCH_updt:
    forall js ds tid c
      (H0:match_st js ds)
      (cnt: containsThread js tid)
      (cnt': containsThread ds tid),
      match_st (updThreadC cnt c)
               (updThreadC cnt' c).

  Lemma MTCH_updt':
    forall js ds tid c m
      (H0:match_st js ds)
      (cnt: containsThread js tid)
      (cnt': containsThread ds tid)
      (Hcmpt : mem_compatible js m)
      (Hcmpt' : HybridMachineSig.mem_compatible ds m),

    Lemma MTCH_restrict_personal:
      forall ds js m i
        (MTCH: match_st js ds)
        (Hi: containsThread js i)
        (Hi': containsThread ds i)
        Hcmpt
        (Hcmpt': DryHybridMachine.mem_compatible ds m),

    Lemma MTCH_updLockS:
             forall js ds loc jres dres1 dres2,
               match_st js ds ->
             (forall b ofs, perm_of_res (jres @ (b, ofs)) = dres1 !! b ofs) ->
             (forall b ofs, perm_of_res_lock (jres @ (b, ofs)) = dres2 !! b ofs) ->
                      match_st
                        (updLockSet js loc (Some jres))
                        (updLockSet ds loc (dres1,dres2)).

    Lemma MTCH_updLockN:
      forall js ds loc,
        match_st js ds ->
        match_st
          (updLockSet js loc None)
          (updLockSet ds loc (empty_map,empty_map)).

    Lemma MTCH_remLockN:
      forall js ds loc,
        match_st js ds ->
        match_st
          (remLockSet js loc)
          (remLockSet ds loc).

    Lemma MTCH_update:
      forall js ds Kc phi p1 p2 i
        (Hi : containsThread js i)
        (Hi': containsThread ds i),
        match_st js ds ->
        ( forall b ofs,
            perm_of_res (phi @ (b, ofs)) = p1 !! b ofs) ->
        ( forall b ofs,
            perm_of_res_lock (phi @ (b, ofs)) = p2 !! b ofs) ->
        match_st (updThread Hi  Kc phi)
                 (updThread Hi' Kc (p1,p2)).

    Lemma match_st_age_tp_to tp n ds :
      match_st tp ds -> match_st (Concur.age_tp_to n tp) ds.

    Definition match_rmap_perm (rmap : rmap) (pmap: access_map * access_map): Prop:=
      (forall b ofs, perm_of_res (rmap @ (b, ofs)) = pmap.1 !! b ofs) /\
               pmap.2 = empty_map.

     Definition no_locks_perm (rmap : rmap): Prop:=
      forall b ofs, perm_of_res_lock (rmap @ (b, ofs)) = None.

    Lemma MTCH_initial:
      forall  c rmap pmap,
        match_rmap_perm rmap pmap ->
        no_locks_perm rmap ->
        match_st (Concur.initial_machine rmap c) (DryHybridMachine.initial_machine  pmap.1 c).

    Lemma contains_iff_num:
      forall (js : jstate) (ds : dstate)
        (Hcnt: forall i, containsThread js i <-> containsThread ds i),
        OrdinalPool.num_threads js = OrdinalPool.num_threads ds.

    Lemma MTCH_latestThread: forall js ds,
        match_st js ds ->
        latestThread js = latestThread ds.

Lemma perm_of_writable0: 
   forall sh, shares.writable0_share sh -> sh <> Share.top -> perm_of_sh sh = Some Writable.

    Lemma MTCH_addThread: forall js ds parg arg phi res lres,
        match_st js ds ->
        (forall b0 ofs0, perm_of_res (phi@(b0, ofs0)) = res !! b0 ofs0) ->
        (forall b0 ofs0, perm_of_res_lock (phi@(b0, ofs0)) = lres !! b0 ofs0) ->
        match_st
          (addThread js parg arg phi)
          (addThread ds parg arg (res,lres)).

    Lemma MTCH_age: forall js ds age,
        match_st js ds ->
        match_st (Concur.age_tp_to age js) ds.

    Lemma MTCH_tp_update: forall js ds phi js' phi',
        match_st js ds -> tp_update js phi js' phi' ->
        match_st js' ds.

  Lemma perm_of_readable' : forall sh, shares.readable_share sh ->

  Lemma perm_of_writable' : forall sh, shares.writable0_share sh ->

  Lemma lock_range_perm : forall m js ds (MATCH : match_st js ds) i (Hi : containsThread js i)
    (Hcmpt : mem_compatible js m) b ofs 
    sh R (HJcanwrite : Concur.lock_at_least sh R (getThreadR Hi) b (Ptrofs.intval ofs)),
  
  Inductive deltaMap_cases (dmap:delta_map) b ofs:=
  | DMAPS df p:  dmap ! b = Some df -> df ofs = Some p -> deltaMap_cases dmap b ofs
  | DNONE1 df:  dmap ! b = Some df -> df ofs = None -> deltaMap_cases dmap b ofs
  | DNONE2:  dmap ! b = None -> deltaMap_cases dmap b ofs.

  Lemma deltaMap_dec: forall dmap b ofs, deltaMap_cases dmap b ofs.
 
  Lemma permMapsDisjoint2_empty: forall rmap,
      permMapsDisjoint2 (empty_map, empty_map) rmap.
  
  Lemma po_None1: forall p, Mem.perm_order'' None p -> p = None.

  Lemma addThrd_inv: forall (ds : dstate) vf arg new_perm,
      invariant ds  ->
      (forall i cnti,
          permMapsDisjoint2 new_perm (@getThreadR _ _ _ i ds cnti)) ->
      (forall l rm,  lockRes ds l = Some rm ->
                permMapsDisjoint2 new_perm rm) ->
      permMapCoherence new_perm.1 new_perm.2 ->

  Lemma sync_step_diagram:
    forall (m m':Memory.mem) (U:seq nat) js js' ds i ev
          (MATCH: match_st js ds)
          (dinv: invariant ds)
            (Hi: containsThread js i)
            (Hcmpt: mem_compatible js m)
            (HschedN: schedPeek U = Some i)
      (Htstep:  syncStep true Hi Hcmpt js' m' ev),
      exists ds' : dstate, exists ev',
        invariant ds' /\ match_st js' ds' /\
        syncStep true (MTCH_cnt MATCH Hi) (MTCH_compat _ _ _ MATCH Hcmpt) ds' m' ev'.
  Proof.
    intros.
    inversion Htstep; try subst.
    
    { 
        
    assert (Htid':= MTCH_cnt MATCH Hi).
    pose (inflated_delta1:=
            fun loc => match (d_phi @ loc ) with
                      NO s _ => if Share.EqDec_share s Share.bot then None else Some ( perm_of_res (phi' @ loc))
                    | _ => Some (perm_of_res (phi' @ loc))
                    end).
    pose (inflated_delta2:=
            fun loc =>  match (d_phi @ loc ) with
                       NO s _ => if Share.EqDec_share s Share.bot then None else
                                Some ( perm_of_res_lock (phi' @ loc))
                    | _ => Some (perm_of_res_lock (phi' @ loc))
                    end).
         pose (virtue1:= PTree.map
                                      (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                                         (inflated_delta1 (block, ofs))) (snd (getMaxPerm m)) ).

         pose (virtue2:= PTree.map
                                      (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                                         (inflated_delta2 (block, ofs))) (snd (getMaxPerm m)) ).
         assert (virtue_some1: forall l p, inflated_delta1 l = Some p ->
                             p = perm_of_res (phi' @ l)).
            {
              intros l p; unfold inflated_delta1.
              destruct (d_phi @ l); try solve[intros HH; inversion HH; reflexivity].
              destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot));
                [congruence| intros HH; inversion HH; reflexivity]. }
            assert (virtue_some2: forall l p, inflated_delta2 l = Some p ->
                                        p = perm_of_res_lock (phi' @ l)).
            {
               intros l p; unfold inflated_delta2.
              destruct (d_phi @ l); try solve[intros HH; inversion HH; reflexivity].
              destruct ( proj_sumbool (Share.EqDec_share sh0 Share.bot));
                [congruence| intros HH; inversion HH; reflexivity]. }

            assert (virtue_correct1: forall b ofs,
                       (computeMap (getThreadR Htid').1 virtue1)  !! b ofs
                       = perm_of_res (phi' @ (b, ofs))
                   ).
            { intros.
              destruct (deltaMap_dec virtue1 b0 ofs0).
              -  rewrite (computeMap_1 _ _ _ _ e e0).
                 move: e.
                 rewrite /virtue1 /inflated_delta1 PTree.gmap.
                 destruct (((getMaxPerm m).2) ! b0);
                   intros HH; inversion HH as [H0].
                 move :e0; rewrite -H0.
                 destruct (d_phi @ (b0, ofs0)); intros HH';
                 try solve[inversion HH'; reflexivity].
                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)); inversion HH'.
                 reflexivity.
              -  rewrite (computeMap_2 _ _ _ _ e).
                 move: e.
                 rewrite /virtue1 /inflated_delta1 PTree.gmap.
                 destruct (((getMaxPerm m).2) ! b0);
                   intros HH; inversion HH as [H0].
                 move :e0; rewrite -H0.
                 destruct (d_phi @ (b0, ofs0)) eqn:dphibo; intros HH';
                 try solve[inversion HH'].
                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)) eqn:isBot; inversion HH'.
                 move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).
                 rewrite dphibo.
                 replace (NO sh0 n) with (NO Share.bot shares.bot_unreadable).
                 move => /join_comm
                 /(@join_unit1_e _ _ _ (NO Share.bot _) _ _ (NO_identity shares.bot_unreadable)) <-.
                 symmetry. inversion MATCH; auto.
                 destruct (Share.EqDec_share sh0 Share.bot); inversion isBot.
                 subst sh0; f_equal. apply proof_irr.
                 assumption.
              - rewrite (computeMap_3 _ _ _ _ e).
                move: e.
                rewrite /virtue1 /inflated_delta1 PTree.gmap.
                destruct (((getMaxPerm m).2) ! b0) eqn:isNO;
                  intros HH; try solve[inversion HH].
                clear HH.
                move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).
                cut (d_phi @ (b0,ofs0) = NO Share.bot shares.bot_unreadable).
                { move => -> .
                  move => /join_comm
                          /(@join_unit1_e _ _ _ (NO Share.bot _) _ _ (NO_identity shares.bot_unreadable)) <-.
                  symmetry. inversion MATCH; auto.
                }
                destruct Hcmpt as [x Hcmpt']; inversion Hcmpt'.
                move: juice_join => /Concur.compatible_lockRes_sub.
                move => /(_ _ _ His_unlocked) /(resource_at_join_sub _ _ (b0, ofs0)) .
                cut (x @ (b0, ofs0) = NO Share.bot shares.bot_unreadable).
                { move=> -> . elim=> X Join. inversion Join; subst.
                  apply permjoin.join_to_bot_l in RJ; subst sh1.
                  f_equal. apply proof_irr. }
                { inversion all_cohere.
                  specialize (max_coh (b0, ofs0)). move: isNO max_coh.
                  rewrite /max_access_at /access_at /getMaxPerm /PMap.get PTree.gmap1 /=.
                  destruct (((Mem.mem_access m).2) ! b0)=> HH; try solve[ inversion HH].
                  rewrite Concur.Mem_canonical_useful /=.
                  destruct (x @ (b0, ofs0))=> /=.
                  - destruct (eq_dec sh0 Share.bot); subst => //.
                    intros; f_equal. apply proof_irr.
                  - destruct (perm_of_sh sh0) eqn:POSsh0;
                      try (intros ?; exfalso; assumption).
                    apply perm_of_empty_inv in POSsh0; subst.
                    exfalso; apply shares.bot_unreadable; assumption.
                  - tauto.
                }
            }

             assert (virtue_correct2: forall b ofs,
                       (computeMap (getThreadR Htid').2 virtue2)  !! b ofs
                       = perm_of_res_lock (phi' @ (b, ofs))
                   ).
            { intros.
              destruct (deltaMap_dec virtue2 b0 ofs0).
              -  rewrite (computeMap_1 _ _ _ _ e e0).
                 move: e.
                 rewrite /virtue2 /inflated_delta2 PTree.gmap.
                 destruct (((getMaxPerm m).2) ! b0);
                   intros HH; inversion HH as [H0].
                 move :e0; rewrite -H0.
                 destruct (d_phi @ (b0, ofs0)); intros HH';
                 try solve[inversion HH'; reflexivity].
                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)); inversion HH'.
                 reflexivity.
              -  rewrite (computeMap_2 _ _ _ _ e).
                 move: e.
                 rewrite /virtue2 /inflated_delta2 PTree.gmap.
                 destruct (((getMaxPerm m).2) ! b0);
                   intros HH; inversion HH as [H0].
                 move :e0; rewrite -H0.
                 destruct (d_phi @ (b0, ofs0)) eqn:dphibo; intros HH';
                 try solve[inversion HH'].
                 destruct (proj_sumbool (Share.EqDec_share sh0 Share.bot)) eqn:isBot; inversion HH'.
                 move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).
                 rewrite dphibo;
                 replace (NO sh0 n) with (NO Share.bot shares.bot_unreadable).
                 move => /join_comm
                         /(@join_unit1_e _ _ _ (NO Share.bot _) _ _ (NO_identity shares.bot_unreadable)) <-.
                 symmetry. inversion MATCH; auto.
                 destruct (Share.EqDec_share sh0 Share.bot); inversion isBot; auto.
                 subst sh0; f_equal; apply proof_irr.
                 assumption.
              - rewrite (computeMap_3 _ _ _ _ e).
                move: e.
                rewrite /virtue2 /inflated_delta2 PTree.gmap.
                destruct (((getMaxPerm m).2) ! b0) eqn:isNO;
                  intros HH; try solve[inversion HH].
                clear HH.
                move: Hadd_lock_res => /(resource_at_join _ _ _ (b0, ofs0)).
                cut (d_phi @ (b0,ofs0) = NO Share.bot shares.bot_unreadable).
                { move => -> .
                  move => /join_comm /(@join_unit1_e _ _ _ (NO Share.bot _) _ _
                                                    (NO_identity shares.bot_unreadable)) <-.
                  symmetry. inversion MATCH; auto.
                }
                destruct Hcmpt as [x Hcmpt']; inversion Hcmpt'.
                move: juice_join => /Concur.compatible_lockRes_sub.
                move => /(_ _ _ His_unlocked) /(resource_at_join_sub _ _ (b0, ofs0)) .
                cut (x @ (b0, ofs0) = NO Share.bot shares.bot_unreadable).
                { move=> -> . elim=> X Join. inversion Join; subst.
                  apply permjoin.join_to_bot_l in RJ.
                  subst. f_equal; apply proof_irr. }
                { inversion all_cohere.
                  specialize (max_coh (b0, ofs0)). move: isNO max_coh.
                  rewrite /max_access_at /access_at /getMaxPerm /PMap.get PTree.gmap1 /=.
                  destruct (((Mem.mem_access m).2) ! b0)=> HH; try solve[ inversion HH].
                  rewrite Concur.Mem_canonical_useful /=.
                  destruct (x @ (b0, ofs0))=> /=.
                  - destruct (eq_dec sh0 Share.bot) eqn:?; subst => //.
                    intros; f_equal; apply proof_irr.
                  - destruct (perm_of_sh sh0) eqn:POSsh0;
                      try (intros ?; exfalso; assumption).
                    apply perm_of_empty_inv in POSsh0; subst.
                    exfalso; apply shares.bot_unreadable; assumption.
                  - tauto.
                }
            }

         pose (ds':= updThread Htid' (Kresume c Vundef)
                  (computeMap
                     (getThreadR Htid').1 virtue1,
              computeMap
                     (getThreadR Htid').2 virtue2)).
         pose (ds'':= updLockSet ds'
                      (b, Ptrofs.intval ofs) (empty_map,empty_map)).
                      SearchAbout Events.delta_content.
         exists ds'', (Events.acquire (b, Ptrofs.intval ofs) (Some (build_delta_content virtue1 m')) ).
         split; [|split].
    - { 

        unfold ds''.
        rewrite updLock_updThread_comm.
        pose (ds0:= (updLockSet ds (b, (Ptrofs.intval ofs)) (empty_map,empty_map))).

        cut (invariant ds0).
        { 
          intros dinv0.
          apply updThread_inv.

          - assumption.
          - intros.
            assert (forall l, joins (phi' @ l) (getThreadR (MTCH_cnt' MATCH cnt) @ l)).
            {assert (Hcmpt':=Hcmpt).
              assert (Hcmpt'':=Hcmpt).
              eapply
                Concur.compatible_threadRes_join
                with (cnti:=Hi)(cntj:=(MTCH_cnt' MATCH cnt))
                in Hcmpt'; auto.
              eapply
                Concur.compatible_threadRes_lockRes_join
              with (cnti:=(MTCH_cnt' MATCH cnt))
                     (l:=(b, Ptrofs.intval ofs))
                     (phi:=d_phi)
                in Hcmpt''; auto.
              intro l; apply resource_at_joins with (loc := l) in Hcmpt';
                apply resource_at_joins with (loc := l) in Hcmpt'';
                apply resource_at_join with (loc := l) in Hadd_lock_res.
              eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;
              eapply joins_comm; auto.
            }

            split;
            eapply permDisjoint_permMapsDisjoint; intros b0 ofs0; simpl.
            + rewrite virtue_correct1 (MTCH_perm' _ MATCH b0 ofs0).
              apply joins_permDisjoint; auto.
            + rewrite virtue_correct2 (MTCH_perm2' _ MATCH b0 ofs0).
              apply joins_permDisjoint_lock; auto.
          - intros; intros b0 ofs0.
            destruct (eq_dec i j).
            + subst j.
              rewrite virtue_correct2 (MTCH_perm' _ MATCH b0 ofs0).
              contradiction.
            + rewrite virtue_correct2 (MTCH_perm' _ MATCH b0 ofs0).
              assert (forall l, joins (phi' @ l) (getThreadR (MTCH_cnt' MATCH cnt) @ l)).
              {assert (Hcmpt':=Hcmpt).
               assert (Hcmpt'':=Hcmpt).
               eapply
                Concur.compatible_threadRes_join
                with (cnti:=Hi)(cntj:=(MTCH_cnt' MATCH cnt))
                in Hcmpt'; auto.
               eapply
                 Concur.compatible_threadRes_lockRes_join
                 with (cnti:=(MTCH_cnt' MATCH cnt))
                     (l:=(b, Ptrofs.intval ofs))
                     (phi:=d_phi)
                 in Hcmpt''; auto.
               intro l; apply resource_at_joins with (loc := l) in Hcmpt';
                 apply resource_at_joins with (loc := l) in Hcmpt'';
                 apply resource_at_join with (loc := l) in Hadd_lock_res.
               eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;
               eapply joins_comm; auto.
             }

              apply perm_coh_joins.
              apply joins_comm; auto.

          - intros; intros b0 ofs0.
            destruct (eq_dec i j).
            + subst j.
              contradiction.
            + rewrite virtue_correct1 (MTCH_perm2' _ MATCH b0 ofs0).
              assert (forall l, joins (phi' @ l) (getThreadR (MTCH_cnt' MATCH cnt) @ l)).
              {assert (Hcmpt':=Hcmpt).
               assert (Hcmpt'':=Hcmpt).
               eapply
                Concur.compatible_threadRes_join
                with (cnti:=Hi)(cntj:=(MTCH_cnt' MATCH cnt))
                in Hcmpt'; auto.
               eapply
                 Concur.compatible_threadRes_lockRes_join
                 with (cnti:=(MTCH_cnt' MATCH cnt))
                     (l:=(b, Ptrofs.intval ofs))
                     (phi:=d_phi)
                 in Hcmpt''; auto.
               intro l; apply resource_at_joins with (loc := l) in Hcmpt';
                 apply resource_at_joins with (loc := l) in Hcmpt'';
                 apply resource_at_join with (loc := l) in Hadd_lock_res.
               eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;
               eapply joins_comm; auto.
              }
              apply perm_coh_joins; auto.
          - intros l pmap0.
            destruct (AMap.E.eq_dec l (b, Ptrofs.intval ofs)).
            + subst l; rewrite gssLockRes; simpl; intros HH; inversion HH; simpl.
              split; apply empty_disjoint'.
            + rewrite gsoLockRes; auto; simpl; intros HH.
              assert (exists pmap1, lockRes js l = Some pmap1).
              { inversion MATCH.
                specialize (mtch_locks l).
                setoid_rewrite HH in mtch_locks.
                destruct (lockRes js l).
                - exists l0; reflexivity.
                - inversion mtch_locks.
              }
              destruct H as [pmap1 HH'].
              destruct pmap1.
              * assert (forall l, joins (r @ l) (phi' @ l)).
               { assert (Hcmpt':=Hcmpt).
                 assert (Hcmpt'':=Hcmpt).
                 eapply
                   Concur.compatible_threadRes_lockRes_join
                 with (cnti:=Hi)
                        (l0:=l)
                        (phi:=r)
                   in Hcmpt'; auto.
                 eapply
                   Concur.compatible_lockRes_join
                 with (l2:=(b, Ptrofs.intval ofs))
                        (l1:=l)
                        (phi2:=d_phi)
                        (phi1:=r)
                   in Hcmpt''; auto.
                 intro l0; apply resource_at_joins with (loc := l0) in Hcmpt';
                   apply resource_at_joins with (loc := l0) in Hcmpt'';
                   apply resource_at_join with (loc := l0) in Hadd_lock_res.
                 eapply joins_comm.
                 eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;
                 eapply joins_comm; auto. }
               split;
                 eapply permDisjoint_permMapsDisjoint; intros b0 ofs0.
               -- rewrite virtue_correct1.
                inversion MATCH.
                erewrite <- mtch_locksRes; eauto.
                apply joins_permDisjoint; auto.
               -- rewrite virtue_correct2.
                  inversion MATCH.
                  erewrite <- mtch_locksRes0; eauto.
                  apply joins_permDisjoint_lock; auto.
              * inversion MATCH.
                specialize (mtch_locksEmpty l pmap0 HH' HH);
                  subst pmap0;
                  simpl; split; apply permDisjoint_permMapsDisjoint; intros b0 ofs0;
                rewrite empty_map_spec;
                apply permDisjoint_None.
          - intros l pmap0.
            destruct (AMap.E.eq_dec l (b, Ptrofs.intval ofs)).
            + subst l; rewrite gssLockRes; simpl; intros HH; inversion HH; simpl.
              
              split; [apply permCoh_empty | apply permCoh_empty'].
              { move=> b0 ofs0;
                  rewrite virtue_correct2.
                apply perm_of_res_lock_not_Freeable. }

            + rewrite gsoLockRes; auto; simpl; intros HH.
              assert (HH':=HH).
              eapply MTCH_locks in HH'; eauto.
              destruct HH' as [x HH'].
              destruct x.
              * assert (forall l, joins (r @ l) (phi' @ l)).
               { assert (Hcmpt':=Hcmpt).
                 assert (Hcmpt'':=Hcmpt).
                 eapply
                   Concur.compatible_threadRes_lockRes_join
                 with (cnti:=Hi)
                        (l0:=l)
                        (phi:=r)
                   in Hcmpt'; auto.
                 eapply
                   Concur.compatible_lockRes_join
                 with (l2:=(b, Ptrofs.intval ofs))
                        (l1:=l)
                        (phi2:=d_phi)
                        (phi1:=r)
                   in Hcmpt''; auto.
                 intro l0; apply resource_at_joins with (loc := l0) in Hcmpt';
                   apply resource_at_joins with (loc := l0) in Hcmpt'';
                   apply resource_at_join with (loc := l0) in Hadd_lock_res.
                 eapply joins_comm.
                 eapply (juicy_mem_lemmas.components_join_joins _ _ _ _ Hadd_lock_res); eauto;
                 eapply joins_comm; auto. }
                split; intros b0 ofs0.
                -- rewrite virtue_correct2.
                   inversion MATCH.
                   erewrite <- mtch_locksRes; eauto.
                   apply perm_coh_joins; auto.
                -- rewrite virtue_correct1.
                   inversion MATCH.
                   erewrite <- mtch_locksRes0; eauto.
                   apply perm_coh_joins; apply joins_comm; auto.
              * inversion MATCH.
                specialize (mtch_locksEmpty l _ HH' HH).
                subst pmap0; split; intros b0 ofs0;
                simpl; rewrite empty_map_spec.

                apply perm_coh_empty_2.
                rewrite virtue_correct2.
                apply perm_of_res_lock_not_Freeable.
                apply perm_coh_empty_1.
          - simpl. intros b0 ofs0.
            rewrite virtue_correct1 virtue_correct2.
            eapply perm_coh_self.
        }

            { apply updLock_inv.
              - assumption.
              - intros.
                apply permMapsDisjoint2_empty.

              - intros.
                apply permMapsDisjoint2_comm.
                apply permMapsDisjoint2_empty.
              - intros.
                split; [apply permCoh_empty | apply permCoh_empty'].
                { move=> b0 ofs0.
                  apply (invariant_not_freeable) with (b1:=b0)(ofs1:= ofs0) in dinv.
                  destruct dinv as [AA BB].
                  eapply BB in H0.
                  destruct ((rmap'0.2) # b0 ofs0); try constructor.
                  destruct p; try constructor.
                  exfalso; apply H0; reflexivity. }
              - simpl.
                apply permCoh_empty'.
              - intros.
                split; [apply permCoh_empty | apply permCoh_empty'].
                { move=> b0 ofs0.
                  rewrite (MTCH_perm2' _ MATCH).
                  apply perm_of_res_lock_not_Freeable. }
              - simpl; intros.
                cut (lockRes js (b, ofs0) = None).
                { intros HH. inversion MATCH.
                  specialize (mtch_locks (b, ofs0)).
                  rewrite HH in mtch_locks.
                  clear - mtch_locks.
                  destruct (lockRes ds (b, ofs0)) eqn:AA; auto.
                  - inv mtch_locks.
                }
                {
                  move HJcanwrite at bottom.
                  destruct Hcmpt as [all_juice Hcmpt].
                  inversion Hcmpt.
                  unfold Concur.juicyLocks_in_lockSet in jloc_in_set.
                  eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join.
                  destruct juice_join as [x H0].
                  assert (H0':= fun loc => resource_at_join _ _ _ loc H0).
                  apply resource_at_join with (loc:=(b, Ptrofs.intval ofs)) in H0.
                  rewrite <- (fst_snd0 (b, Ptrofs.intval ofs)) in H0.
                  destruct (HJcanwrite 0) as [sh' [rsh' [HJc1 HJc2]]]. pose proof LKSIZE_pos; omega.
                  rewrite HJc2 in H0.
                  simpl in H0; inversion H0.
                  - subst.
                    symmetry in H6.
                    assert (H1 := jloc_in_set (b, Ptrofs.intval ofs)).
                    spec H1. { intros. destruct (HJcanwrite _ H2) as [sh'' [rsh'' [HJc3 HJc4]]].
                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.
                            clear - H0'. inv H0'; eauto.
                    }
                    assert (VALID:= Concur.compat_lr_valid Hcompatible).
                    specialize (VALID b (Ptrofs.intval ofs)).
                    simpl in *.
                    unfold OrdinalPool.lockRes in *.
                    simpl in *.
                    destruct (AMap.find (elt:=option rmap)
                                        (b, Ptrofs.intval ofs) (OrdinalPool.lockGuts js)) eqn:AA;
                      rewrite AA in H1, VALID; try solve[inversion H1].
                    apply VALID. auto.
                  -
                    symmetry in H6.
                    assert (H1 := jloc_in_set (b, Ptrofs.intval ofs)).
                    spec H1. { intros. destruct (HJcanwrite _ H7) as [sh'' [rsh'' [HJc3 HJc4]]].
                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.
                            clear - H0'. inv H0'; eauto.
                    }
                    assert (VALID:= Concur.compat_lr_valid Hcompatible).
                    specialize (VALID b (Ptrofs.intval ofs)).
                    simpl in *.
                    unfold OrdinalPool.lockRes in *.
                    simpl in *.
                    destruct (AMap.find (elt:=option rmap)
                                        (b, Ptrofs.intval ofs) (OrdinalPool.lockGuts js)) eqn:AA;
                      rewrite AA in H1, VALID; try solve[inversion H1].
                    apply VALID. auto.
                }
              - simpl. intros ofs0 ineq. move HJcanwrite at bottom.
                cut ( lockRes js (b, ofs0) = None).
                { intros HH. inversion MATCH.
                  specialize (mtch_locks (b, ofs0)). rewrite HH in mtch_locks.
                  destruct (lockRes ds (b, ofs0)) eqn:AA; inversion mtch_locks; auto. }
                {
                  destruct (lockRes js (b, ofs0)) eqn:MAP; try reflexivity. exfalso.
                  move HJcanwrite at bottom.
                  destruct Hcmpt as [all_juice Hcmpt].
                  inversion Hcmpt.
                  unfold Concur.juicyLocks_in_lockSet in jloc_in_set.
                  eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join.
                  destruct juice_join as [x H0].
                  assert (H0':= fun loc => resource_at_join _ _ _ loc H0).
                  apply resource_at_join with (loc:=(b, Ptrofs.intval ofs)) in H0.
                  rewrite <- (fst_snd0 (b, Ptrofs.intval ofs)) in H0.
                  destruct (HJcanwrite 0) as [sh' [rsh' [HJc1 HJc2]]]. pose proof LKSIZE_pos; omega.
                  rewrite HJc2 in H0.
                  simpl in H0; inversion H0.
                  -
                    symmetry in H5.
                    assert (H8 := jloc_in_set (b, Ptrofs.intval ofs)).
                    spec H8. { intros. destruct (HJcanwrite _ H4) as [sh'' [rsh'' [HJc3 HJc4]]].
                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.
                            clear - H0'. inv H0'; eauto.
                    } 
                    assert (VALID:= Concur.compat_lr_valid Hcompatible).
                    specialize (VALID b ofs0).
                    rewrite MAP in VALID.
                    apply VALID in ineq.
                    move ineq at bottom.
                    setoid_rewrite ineq in H8.
                    inversion H8.
                  -
                    symmetry in H5.
                    assert (H8 := jloc_in_set (b, Ptrofs.intval ofs)).
                    spec H8. { intros. destruct (HJcanwrite _ H4) as [sh'' [rsh'' [HJc3 HJc4]]].
                            specialize (H0' (b, Ptrofs.intval ofs + i0)). rewrite HJc4 in H0'.
                            clear - H0'. inv H0'; eauto.
                   }
                    assert (VALID:= Concur.compat_lr_valid Hcompatible).
                    specialize (VALID b ofs0).
                    rewrite MAP in VALID.
                    apply VALID in ineq.
                    move ineq at bottom.
                    setoid_rewrite ineq in H8.
                    inversion H8.
                }
            }
      }
    - unfold ds''.
      apply match_st_age_tp_to.
      apply MTCH_updLockN.
      unfold ds'.
      apply MTCH_update; auto.

    - assert (H: exists l, lockRes ds (b, Ptrofs.intval ofs) = Some l).
      { inversion MATCH; subst.
        specialize (mtch_locks (b, (Ptrofs.intval ofs) )).
        rewrite His_unlocked in mtch_locks.
        destruct (lockRes ds (b, Ptrofs.intval ofs));
          try solve[inversion mtch_locks]. exists l; reflexivity. }
      destruct H as [l dlockRes].
      assert (Hlt'':  permMapLt (setPermBlock (Some Writable) b (Ptrofs.intval ofs)
                                              (getThreadR
                                                 (MTCH_cnt MATCH Hi)).2 LKSIZE_nat)
                                (getMaxPerm m)).
      { intros b0 ofs0.
        move: (Hlt' b0 ofs0).
        
        destruct (peq b b0);
          [subst b0;
            destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].
        - do 2 (rewrite setPermBlock_same; auto).
        - apply Intv.range_notin in n; [|simpl; pose proof LKSIZE_pos; omega].
          do 2 (rewrite setPermBlock_other_1; auto).

          destruct Hcmpt as [jall Hcmpt];
            inversion Hcmpt; inversion all_cohere.
          rewrite -Concur.juic2Perm_locks_correct.
          rewrite -(MTCH_perm2 _ MATCH); auto.
          apply Concur.mem_access_coh_sub with (phi1:=jall).
          assumption.
          eapply Concur.compatible_threadRes_sub; eauto.
        - do 2 (rewrite setPermBlock_other_2; auto).
          destruct Hcmpt as [jall Hcmpt];
            inversion Hcmpt; inversion all_cohere.
          rewrite -Concur.juic2Perm_locks_correct.
          rewrite -(MTCH_perm2 _ MATCH); auto.
          apply Concur.mem_access_coh_sub with (phi1:=jall).
          assumption.
          eapply Concur.compatible_threadRes_sub; eauto.
      }

      change virtue1 with (virtue1, virtue2).1.
      econstructor 1.

      15: reflexivity.
      15: now unfold ds'', ds'; repeat f_equal; apply proof_irr.
      8: eassumption.
      10: eassumption.
      + 
        split.
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].

          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta1 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh0 Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption.
          }
          { move: (Concur.compat_lockLT
                        Hcmpt _ His_unlocked p b0).

            rewrite /PMap.get HH' is_none => /po_None1 //.
            }
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta2 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh0 Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          { move: (Concur.compat_lockLT
                        Hcmpt _ His_unlocked p b0).
            rewrite /PMap.get HH' is_none => /po_None1 //.
            }

      + assumption.
      + eapply MTCH_getThreadC; eassumption.
      + reflexivity.
      + eassumption.
      + unfold Concur.juicyRestrict_locks.
        apply restrPermMap_ext;
          intros b0.
        inversion MATCH; subst.
        extensionality ofs0.
        rewrite <- Concur.juic2Perm_locks_correct.
        symmetry. apply mtch_perm2.
        apply Concur.mem_compat_thread_max_cohere.
        assumption.
      + eapply lock_range_perm;  eauto.
      + reflexivity.
      + instantiate (1:= Hlt'').
        apply restrPermMap_ext.
        intros b0.
        extensionality ofs0.
        destruct (ident_eq b b0); [
            destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z) |].
        * unfold Intv.In in i0.
          subst. repeat (rewrite setPermBlock_same; auto).
        * subst. apply Intv.range_notin in n; auto.
          repeat (rewrite setPermBlock_other_1; auto).
          rewrite -Concur.juic2Perm_locks_correct.
          inversion MATCH. symmetry. eapply mtch_perm2.
          eapply Concur.mem_compat_thread_max_cohere; auto.
          simpl; pose proof LKSIZE_pos; xomega.
        * repeat (rewrite setPermBlock_other_2; auto).
          rewrite -Concur.juic2Perm_locks_correct.
          inversion MATCH. symmetry. eapply mtch_perm2.
          eapply Concur.mem_compat_thread_max_cohere; auto.
      + exact dlockRes.
      + intros b0 ofs0. inversion MATCH; subst.
        specialize (mtch_locksRes _ _ _ His_unlocked dlockRes).
        rewrite <- mtch_locksRes.
        rewrite <- mtch_perm1 with (Htid:=Hi).
        replace (MTCH_cnt MATCH Hi) with Htid' by eapply proof_irr.
        rewrite virtue_correct1.
        eapply permjoin.join_permjoin.
        eapply resource_at_join.
        apply join_comm.
        assumption.
      + intros b0 ofs0. inversion MATCH; subst.
        specialize (mtch_locksRes0 _ _ _ His_unlocked dlockRes).
        rewrite <- mtch_locksRes0.
        rewrite <- mtch_perm2 with (Htid:=Hi).
        replace (MTCH_cnt MATCH Hi) with Htid' by eapply proof_irr.
        rewrite virtue_correct2.

             apply permjoin.join_permjoin_lock.
             eapply resource_at_join.
             apply join_comm.
             assumption.
    }

    {

    assert (Htid':= MTCH_cnt MATCH Hi).
    pose (inflated_delta1:=
            fun loc => match (d_phi @ loc ) with
                      NO s _ => if Share.EqDec_share s Share.bot then None else Some ( perm_of_res (phi' @ loc))
                    | _ => Some (perm_of_res (phi' @ loc))
                    end).
    pose (inflated_delta2:=
            fun loc => match (d_phi @ loc ) with
                      NO s _ => if Share.EqDec_share s Share.bot then None
                             else Some ( perm_of_res_lock (phi' @ loc))
                    | _ => Some (perm_of_res_lock (phi' @ loc))
                    end).
    pose (virtue1:= PTree.map
                     (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                        (inflated_delta1 (block, ofs))) (snd (getMaxPerm m)) ).
    pose (virtue2:= PTree.map
                      (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                         (inflated_delta2 (block, ofs))) (snd (getMaxPerm m)) ).
    pose (ds':= updThread Htid' (Kresume c Vundef)
                                          (computeMap
                                             (getThreadR Htid').1 virtue1,
                                           computeMap
                                             (getThreadR Htid').2 virtue2)).
    pose (ds'':= updLockSet ds' (b, Ptrofs.intval ofs)
                                            (Concur.juice2Perm d_phi m, Concur.juice2Perm_locks d_phi m )).

    assert (virtue_spec1: forall b0 ofs0, perm_of_res (phi' @ (b0, ofs0)) =
                                    (computeMap (getThreadR Htid').1 virtue1) !! b0 ofs0).
    {
      intros b0 ofs0.
      destruct (virtue1 ! b0) eqn:VIRT.
      destruct (o ofs0) eqn:O.
      - erewrite computeMap_1; try eassumption.
        unfold virtue1 in VIRT. rewrite PTree.gmap in VIRT.
        destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.
        unfold inflated_delta1 in H0. rewrite <- H0 in O.
        clear VIRT H0.
        replace o0 with (perm_of_res (phi' @ (b0, ofs0))).
        + reflexivity.
        + destruct (d_phi @ (b0, ofs0)) eqn:AA;
            rewrite AA in O;
            try destruct (Share.EqDec_share sh0 Share.bot);
          inversion O; reflexivity.
           - erewrite computeMap_2; try eassumption.
             unfold virtue1 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.
             unfold inflated_delta1 in H0. rewrite <- H0 in O.
             apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.
             move Hrem_lock_res at bottom.
             replace (d_phi @ (b0, ofs0)) with (NO Share.bot shares.bot_unreadable)
               in Hrem_lock_res.
             + inversion MATCH; rewrite <- mtch_perm1 with (Htid:= Hi).
               f_equal.
               eapply join_unit1_e; eauto.
               eapply NO_identity.
             + destruct (d_phi @ (b0, ofs0)) eqn:HH; rewrite HH in O; try solve[inversion O].
               destruct ((Share.EqDec_share sh0 Share.bot)); try solve[ inversion O].
               subst; f_equal; apply proof_irr.
           - erewrite computeMap_3; try eassumption.
             unfold virtue1 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m)) ! b0) eqn:notInMem; inversion VIRT.
             clear VIRT.
             assert (THE_CURE: (getMaxPerm m) !! b0 = fun _ => None).
             { unfold PMap.get. rewrite notInMem.
               apply Max_isCanonical.
             }
             assert (the_cure:= equal_f THE_CURE ofs0).
             rewrite getMaxPerm_correct in the_cure.
             replace ((getThreadR Htid').1 !! b0 ofs0) with
             (perm_of_res ((getThreadR Hi)@ (b0, ofs0))).
             + assert (Hcohere':= Hcompatible).
               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.
               inversion Hcohere'.
               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.
               unfold Concur.access_cohere' in acc_coh.
               specialize (acc_coh (b0,ofs0)).
               unfold max_access_at, access_at in acc_coh.
               unfold permission_at in the_cure.
               rewrite the_cure in acc_coh.

               apply po_None1 in acc_coh.
               move Hrem_lock_res at bottom.
               apply join_comm in Hrem_lock_res.
               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.
               apply join_join_sub in Hrem_lock_res.
               assert (HH:= juicy_mem_lemmas.po_join_sub _ _ Hrem_lock_res).
               rewrite acc_coh in HH. rewrite acc_coh.
               apply po_None1 in HH. assumption.
             + inversion MATCH; rewrite mtch_perm1; reflexivity.
    }

    assert (virtue_spec2: forall b0 ofs0, perm_of_res_lock (phi' @ (b0, ofs0)) =
                                    (computeMap (getThreadR Htid').2 virtue2) !! b0 ofs0).
    {
      intros b0 ofs0.
      destruct (virtue2 ! b0) eqn:VIRT.
      destruct (o ofs0) eqn:O.
      - erewrite computeMap_1; try eassumption.
        unfold virtue2 in VIRT. rewrite PTree.gmap in VIRT.
        destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.
        unfold inflated_delta2 in H0. rewrite <- H0 in O.
        clear VIRT H0.
        replace o0 with (perm_of_res_lock (phi' @ (b0, ofs0))).
        + reflexivity.
        + destruct (d_phi @ (b0, ofs0)) eqn:AA; rewrite AA in O;
            try destruct (Share.EqDec_share sh0 Share.bot);
          inversion O; reflexivity.
           - erewrite computeMap_2; try eassumption.
             unfold virtue2 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m)) ! b0); inversion VIRT.
             unfold inflated_delta2 in H0. rewrite <- H0 in O.
             apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.
             move Hrem_lock_res at bottom.
             replace (d_phi @ (b0, ofs0)) with (NO Share.bot shares.bot_unreadable) in Hrem_lock_res.
             + inversion MATCH; rewrite <- mtch_perm2 with (Htid:= Hi).
               f_equal.
               eapply join_unit1_e; eauto.
               eapply NO_identity.
             + destruct (d_phi @ (b0, ofs0)) eqn:HH; rewrite HH in O; try solve[inversion O].
               destruct ((Share.EqDec_share sh0 Share.bot)); try solve[ inversion O].
               subst; f_equal; apply proof_irr. 
           - erewrite computeMap_3; try eassumption.
             unfold virtue2 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m)) ! b0) eqn:notInMem; inversion VIRT.
             clear VIRT.
             assert (THE_CURE: (getMaxPerm m) !! b0 = fun _ => None).
             { unfold PMap.get. rewrite notInMem.
               apply Max_isCanonical.
             }
             assert (the_cure:= equal_f THE_CURE ofs0).
             rewrite getMaxPerm_correct in the_cure.
             replace ((getThreadR Htid').2 !! b0 ofs0) with
             (perm_of_res_lock ((getThreadR Hi)@ (b0, ofs0))).
             + assert (Hcohere':= Hcompatible).
               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.
               inversion Hcohere'.
               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.
               unfold max_access_cohere in max_coh.
               specialize (max_coh (b0,ofs0)).
               unfold max_access_at, access_at in max_coh.
               unfold permission_at in the_cure.
               rewrite the_cure in max_coh.

               pose (HERE:= perm_of_res_op2 (getThreadR Hi @ (b0, ofs0))).
               eapply juicy_mem_lemmas.perm_order''_trans in HERE; eauto.
               apply po_None1 in HERE.
               move Hrem_lock_res at bottom.
               apply join_comm in Hrem_lock_res.
               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_lock_res.
               apply join_join_sub in Hrem_lock_res.
               assert (HH:= po_join_sub_lock Hrem_lock_res).
               rewrite HERE in HH. rewrite HERE.
               apply po_None1 in HH. assumption.
             + inversion MATCH; rewrite mtch_perm2; reflexivity.
}
SearchAbout Events.delta_content.
SearchAbout access_map delta_map.
    eexists ds'', _.
    split; [|split].
    - unfold ds''.
      cut (invariant ds').
      { intros dinv'.
        apply updLock_inv.
        - assumption.
        - move=> laddr ramp0 laddr_neq .
          unfold ds'; rewrite gsoThreadLPool => get_lres.
          
          move: (get_lres) => /(MTCH_locks) /= /(_ _ MATCH) [] l.
          destruct l.
          + 
            inversion MATCH => jget_lres.
            split.
            * apply permDisjoint_permMapsDisjoint;
              intros b0 ofs0.
              move : (mtch_locksRes _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.
              rewrite -Concur.juic2Perm_correct.
              apply joins_permDisjoint.
              apply resource_at_joins.
              eapply join_sub_joins_trans.
              -- exists phi'; eassumption.
              -- eapply Concur.compatible_threadRes_lockRes_join; eauto.
              -- apply Concur.max_acc_coh_acc_coh.
                 destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
            * apply permDisjoint_permMapsDisjoint;
              intros b0 ofs0.
              move : (mtch_locksRes0 _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.
              rewrite -Concur.juic2Perm_locks_correct.
              apply joins_permDisjoint_lock.
              apply resource_at_joins.
              eapply join_sub_joins_trans.
              -- exists phi'; eassumption.
              -- eapply Concur.compatible_threadRes_lockRes_join; eauto.
              -- destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
          + 
            inversion MATCH.
            move => /(mtch_locksEmpty) // /(_ _ get_lres) ->.
            apply permMapsDisjoint2_comm;
            apply permMapsDisjoint2_empty.

        - rewrite /ds'=> i0.
          destruct (eq_dec i i0).
          + subst=> cnti.
            rewrite gssThreadRes; split=> /=;
              apply permDisjoint_permMapsDisjoint => b0 ofs0.
            * rewrite - virtue_spec1.
              rewrite - Concur.juic2Perm_correct.
              apply joins_permDisjoint.
              apply resource_at_joins.
              apply joins_comm.
              eexists; eassumption.

              apply Concur.max_acc_coh_acc_coh.
              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
            * rewrite - virtue_spec2.
              rewrite - Concur.juic2Perm_locks_correct.
              apply joins_permDisjoint_lock.
              apply resource_at_joins.
              apply joins_comm.
              eexists; eassumption.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
          + move => cnti. rewrite gsoThreadRes => //.
            split=> /=;
              apply permDisjoint_permMapsDisjoint => b0 ofs0.
            * rewrite (MTCH_perm' _ MATCH).
              rewrite - Concur.juic2Perm_correct.
              apply joins_permDisjoint.
              apply resource_at_joins.
              apply joins_comm.
              eapply join_sub_joins_trans.
              exists phi'; eassumption.
              eapply Concur.compatible_threadRes_join;
                eassumption.

              apply Concur.max_acc_coh_acc_coh.
              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
            * rewrite (MTCH_perm2' _ MATCH).
              rewrite - Concur.juic2Perm_locks_correct.
              apply joins_permDisjoint_lock.
              apply resource_at_joins.
              apply joins_comm.
              eapply join_sub_joins_trans.
              exists phi'; eassumption.
              eapply Concur.compatible_threadRes_join;
                eassumption.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
        - move=> laddr ramp0 laddr_neq .
          unfold ds'; rewrite gsoThreadLPool => get_lres.
          
          move: (get_lres) => /(MTCH_locks) /= /(_ _ MATCH) [] l.
          destruct l.
          + 
            inversion MATCH => jget_lres.
            split.
            * intros b0 ofs0.
              move : (mtch_locksRes0 _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.
              rewrite - Concur.juic2Perm_correct.
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply join_sub_joins_trans.
              exists phi'; eassumption.
              eapply Concur.compatible_threadRes_lockRes_join ; eassumption.

              apply Concur.max_acc_coh_acc_coh.
              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
            * intros b0 ofs0.
              move : (mtch_locksRes _ _ _ jget_lres get_lres b0 ofs0) =>  <- /=.
              rewrite - Concur.juic2Perm_locks_correct.
               apply perm_coh_joins.
               apply resource_at_joins.
               apply joins_comm.
              eapply join_sub_joins_trans.
              exists phi'; eassumption.
              eapply Concur.compatible_threadRes_lockRes_join ; eassumption.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.

          + 
            inversion MATCH.
            move => /(mtch_locksEmpty) // /(_ _ get_lres) -> /=.
            split; first [apply permCoh_empty'| apply permCoh_empty].
            { move => b0 ofs0.
              rewrite -Concur.juic2Perm_locks_correct.
              apply perm_of_res_lock_not_Freeable.

              destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.

            }

        - move=> b0 ofs0 /=.
          assert ( max_access_cohere m d_phi).
          {
             destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption. }

          rewrite - Concur.juic2Perm_locks_correct.
          rewrite - Concur.juic2Perm_correct.
          apply perm_coh_self.

          + apply Concur.max_acc_coh_acc_coh; assumption.
          + assumption.
        - rewrite /ds'=> i0.
          destruct (eq_dec i i0).
          + subst=> cnti. rewrite gssThreadRes; split=> /= b0 ofs0.
            * rewrite - virtue_spec2.
              rewrite - Concur.juic2Perm_correct.
              apply perm_coh_joins.
              apply resource_at_joins.
              eexists; eassumption.

              apply Concur.max_acc_coh_acc_coh.
               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.

            * rewrite - virtue_spec1.
              rewrite - Concur.juic2Perm_locks_correct.
              apply perm_coh_joins.
              apply joins_comm.
              apply resource_at_joins.
              eexists; eassumption.

               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
          + move => cnti. rewrite gsoThreadRes => //.
            split=> /= b0 ofs0.
            * rewrite (MTCH_perm2' _ MATCH).
              rewrite - Concur.juic2Perm_correct.
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply join_sub_joins_trans.
              eexists phi'; eassumption.
              eapply Concur.compatible_threadRes_join; eassumption.

               apply Concur.max_acc_coh_acc_coh.
               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.
            * rewrite (MTCH_perm' _ MATCH).
              rewrite - Concur.juic2Perm_locks_correct.
              apply perm_coh_joins.
              apply resource_at_joins.
              apply joins_comm.
              eapply join_sub_joins_trans.
              eexists phi'; eassumption.
              eapply Concur.compatible_threadRes_join; eassumption.

               destruct Hcmpt as [jall Hcmpt]; inversion Hcmpt.
                 apply Concur.mem_access_coh_sub with (phi1:= jall).
                  inversion  all_cohere; assumption.
                 apply join_sub_trans with (b1:=(getThreadR Hi)).
                 exists phi'; assumption.
                 apply Concur.compatible_threadRes_sub; assumption.

        - intros ofs0 ineq.
          rewrite gsoThreadLPool.
          cut (lockRes js (b, ofs0) = None).
          { intros HH. inversion MATCH. specialize (mtch_locks (b, ofs0)).
            rewrite HH in mtch_locks.
            destruct (lockRes ds (b, ofs0)) eqn:AA; inversion mtch_locks; auto.
          }
          { destruct Hcompatible as [allj Hcompatible].
            inversion Hcompatible.
            assert (VALID:= Concur.compat_lr_valid Hcmpt).
            specialize (VALID b (Ptrofs.intval ofs)).
            eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join. 
            rewrite His_locked in VALID. apply VALID; auto.
           }
        - intros ofs0 ineq.
          rewrite gsoThreadLPool.
          cut (lockRes js (b, ofs0) = None).
          { intros HH. inversion MATCH. specialize (mtch_locks (b, ofs0)).
            rewrite HH in mtch_locks.
            destruct (lockRes ds (b, ofs0)) eqn:AA; inversion mtch_locks; auto.
          }
          { destruct (lockRes js (b, ofs0)) eqn:AA; try reflexivity. exfalso.
             destruct Hcompatible as [allj Hcompatible].
            inversion Hcompatible.
            assert (VALID:= Concur.compat_lr_valid Hcmpt).
            specialize (VALID b ofs0).
            rewrite AA in VALID.
            apply VALID in ineq.
            eapply Concur.compatible_threadRes_sub with (cnt:= Hi) in juice_join.
            specialize (jloc_in_set (b,Ptrofs.intval ofs)).
            spec jloc_in_set. { intros. simpl. 
                  apply resource_at_join_sub with (l:=(b,Ptrofs.intval ofs+i0)) in juice_join.
                  destruct (HJcanwrite _ H) as [sh' [rsh' [? ?]]]. rewrite H1 in juice_join.
                 destruct juice_join as [x HH].
                 inversion HH; eauto.
            }
           setoid_rewrite ineq in jloc_in_set. inv jloc_in_set.
          }

      }

      {  
        
        apply invariant_decr.
        - assumption.
        - move=> /= b0 ofs0.
          rewrite -virtue_spec1 (MTCH_perm' _ MATCH).
          apply juicy_mem_lemmas.po_join_sub;
            apply resource_at_join_sub.
          exists (d_phi); apply join_comm.
          replace (MTCH_cnt' MATCH Htid') with Hi by (apply proof_irrelevance); assumption.
        - move=> /= b0 ofs0.
          rewrite -virtue_spec2 (MTCH_perm2' _ MATCH).

          apply po_join_sub_lock.
           apply resource_at_join_sub.
          exists (d_phi); apply join_comm.
          replace (MTCH_cnt' MATCH Htid') with Hi by (apply proof_irrelevance); assumption.
      }

    - 
      unfold ds''.
      apply match_st_age_tp_to.
      cut (max_access_cohere m d_phi).
      intros maxcoh.
      apply MTCH_updLockS.

      2:{
      inversion MATCH; subst.
      intros; apply Concur.juic2Perm_correct.
      inversion Hcompatible; inversion H; inversion all_cohere.
      apply Concur.max_acc_coh_acc_coh.
      assumption.
       }

      unfold ds'.
      apply MTCH_update; eauto.
      move=> b0 ofs0.
      apply Concur.juic2Perm_locks_correct.
      assumption.

      { inversion Hcompatible; inversion H; inversion all_cohere.
        eapply Concur.mem_access_coh_sub.
         - eassumption.
         - eapply join_sub_trans.
           + unfold join_sub. exists phi'. eassumption.
           + eapply Concur.compatible_threadRes_sub.
             assumption.
      }

    - assert (H: exists l, lockRes ds (b, Ptrofs.intval ofs) = Some l).
      { inversion MATCH; subst.
        specialize (mtch_locks (b, (Ptrofs.intval ofs) )).
        rewrite His_locked in mtch_locks.
        destruct (lockRes ds (b, Ptrofs.intval ofs)); try solve[inversion mtch_locks]. exists l; reflexivity. }
           destruct H as [l dlockRes].
      econstructor 2.
      17: reflexivity.
      16: instantiate (2:= (virtue1, virtue2));
          instantiate (1 := (Concur.juice2Perm d_phi m, Concur.juice2Perm_locks d_phi m));
        unfold ds'; repeat f_equal; try reflexivity; try apply proof_irrelevance.
      9: eassumption.
      11: eassumption.
      9: reflexivity.
      + 
        split.
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta1 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh0 Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          {
            apply join_join_sub in Hrem_lock_res.
            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_lock_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p, b0)).
            destruct m; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }
          
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta2 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh0 Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          {
            apply join_join_sub in Hrem_lock_res.
            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_lock_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p, b0)).
            destruct m; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }

      + 
        repeat split.
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { intros HHH; rewrite HHH in f1b0.
            inversion f1b0.  }
          {
            apply join_join_sub in Hrem_lock_res.
            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_lock_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p, b0)).
            destruct m; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }
          
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res_lock (d_phi @ (p, b0)) = None).
          { intros HHH; rewrite HHH in f1b0.
            inversion f1b0.  }
          {
            apply join_join_sub in Hrem_lock_res.
            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_lock_res.
            apply po_join_sub_lock in Hrem_lock_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_lock_res;
              [|eapply perm_of_res_op2].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p, b0)).
            destruct m; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }
      + assumption.
      + eapply MTCH_getThreadC; eassumption.
      + reflexivity.
      + eassumption.
      + apply restrPermMap_ext.
        intros b0.
        inversion MATCH; subst.
        extensionality ofs0.
        rewrite -Concur.juic2Perm_locks_correct.
        symmetry; apply mtch_perm2.
        inversion Hcompatible; inversion H; inversion all_cohere.
        eapply Concur.mem_access_coh_sub.
        * eassumption.
        *  eapply Concur.compatible_threadRes_sub.
           assumption.
      + eapply lock_range_perm; eauto.
      + apply restrPermMap_ext.
        intros b0.
        extensionality ofs0.
        destruct (peq b b0); [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].
        * unfold Intv.In in i0; simpl in i0.
          repeat rewrite setPermBlock_same; auto.
        * apply Intv.range_notin in n; auto.
          repeat rewrite setPermBlock_other_1; auto.
          rewrite -Concur.juic2Perm_locks_correct.
          symmetry; eapply MTCH_perm2.
          destruct Hcmpt as [jall Hcmpt];
            inversion Hcmpt. inversion all_cohere.
          eapply Concur.mem_access_coh_sub; eauto.
          apply Concur.compatible_threadRes_sub; assumption.
          pose proof LKSIZE_pos; simpl; xomega.
        * repeat rewrite setPermBlock_other_2; auto.
          rewrite -Concur.juic2Perm_locks_correct.
          symmetry; eapply MTCH_perm2.
          destruct Hcmpt as [jall Hcmpt];
            inversion Hcmpt. inversion all_cohere.
          eapply Concur.mem_access_coh_sub; eauto.
          apply Concur.compatible_threadRes_sub; assumption.

      + exact dlockRes.
      + inversion MATCH.
        specialize (mtch_locksEmpty _ _ His_locked dlockRes).
        inversion mtch_locksEmpty; simpl.
        move=> b0 ofs0.
        rewrite empty_map_spec; tauto.
      + simpl; intros b0 ofs0.
        replace (MTCH_cnt MATCH Hi) with Htid'.
        rewrite -virtue_spec1.
        rewrite -Concur.juic2Perm_correct.
        rewrite (MTCH_perm' _ MATCH b0 ofs0).
        apply permjoin.join_permjoin.
        move Hrem_lock_res at bottom.
        eapply resource_at_join; apply join_comm.
        replace (MTCH_cnt' MATCH Htid') with Hi.
        assumption.
        apply proof_irrelevance.
        2:
        apply proof_irrelevance.
        apply Concur.max_acc_coh_acc_coh.
        inversion Hcompatible; inversion H; inversion all_cohere.
        eapply Concur.mem_access_coh_sub.
        * eassumption.
        *  eapply join_sub_trans.
           -- unfold join_sub. exists phi'. eassumption.
           -- eapply Concur.compatible_threadRes_sub.
              assumption.
      + simpl; intros b0 ofs0.
        replace (MTCH_cnt MATCH Hi) with Htid'.
        rewrite -virtue_spec2.
        rewrite -Concur.juic2Perm_locks_correct.
        rewrite (MTCH_perm2' _ MATCH b0 ofs0).
        apply permjoin.join_permjoin_lock.
        apply resource_at_join.
        apply join_comm.
        replace (MTCH_cnt' MATCH Htid') with Hi by apply proof_irrelevance.
        assumption.
        2:
        apply proof_irrelevance.
        inversion Hcompatible; inversion H; inversion all_cohere.
        eapply Concur.mem_access_coh_sub.
        * eassumption.
        *  eapply join_sub_trans.
           -- unfold join_sub. exists phi'. eassumption.
           -- eapply Concur.compatible_threadRes_sub.
              assumption.
      + replace (MTCH_cnt MATCH Hi) with Htid' by apply proof_irrelevance.
        reflexivity.
    }

    {

      pose (inflated_delta11:=
              fun loc => match (d_phi @ loc ) with
                        NO s _ => if Share.EqDec_share s Share.bot then None else  Some ( perm_of_res (phi' @ loc))
                      | _ => Some ( perm_of_res (phi' @ loc))
                      end).
      pose (virtue11:= PTree.map
                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                          (inflated_delta11 (block, ofs))) (snd (getMaxPerm m')) ).
      assert (virtue_spec11: forall b0 ofs0,
                 (computeMap (getThreadR (MTCH_cnt MATCH Hi)).1 virtue11) !! b0 ofs0 =
                 perm_of_res (phi' @ (b0, ofs0))).
      { intros b0 ofs0.
        destruct (virtue11 ! b0) eqn:VIRT.
        destruct (o ofs0) eqn:O.
        - erewrite computeMap_1; try eassumption.
          unfold virtue11 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta11 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          reflexivity.
        - erewrite computeMap_2; try eassumption.
          unfold virtue11 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta11 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          subst.
          apply resource_at_join with (loc:= (b0,ofs0)) in Hrem_fun_res.
          rewrite AA in Hrem_fun_res.
          eapply (join_unit1_e) in Hrem_fun_res.
          rewrite Hrem_fun_res.
          inversion MATCH.
          symmetry.
          apply mtch_perm1.
          apply NO_identity.
        - erewrite computeMap_3; try eassumption.
             unfold virtue11 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.
             clear VIRT.
             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).
             { unfold PMap.get. rewrite notInMem.
               apply Max_isCanonical.
             }
             assert (the_cure:= equal_f THE_CURE ofs0).
             rewrite getMaxPerm_correct in the_cure.
             replace ((getThreadR (MTCH_cnt MATCH Hi)).1 !! b0 ofs0) with
             (perm_of_res ((getThreadR Hi)@ (b0, ofs0))).
             + assert (Hcohere':= Hcompatible).
               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.
               inversion Hcohere'.
               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.
               unfold Concur.access_cohere' in acc_coh.
               specialize (acc_coh (b0,ofs0)).
               unfold max_access_at, access_at in acc_coh.
               unfold permission_at in the_cure.
               rewrite the_cure in acc_coh.
               apply po_None1 in acc_coh.
               move Hrem_fun_res at bottom.
               apply join_comm in Hrem_fun_res.
               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.
               apply join_join_sub in Hrem_fun_res.
               assert (HH:= juicy_mem_lemmas.po_join_sub _ _ Hrem_fun_res).
               rewrite acc_coh in HH. rewrite acc_coh.
               apply po_None1 in HH. symmetry; assumption.
             + inversion MATCH.  apply mtch_perm1.
      }

      pose (inflated_delta12:=
              fun loc => match (d_phi @ loc ) with
                        NO s _ => if Share.EqDec_share s Share.bot then None
                               else  Some ( perm_of_res_lock (phi' @ loc))
                      | _ => Some ( perm_of_res_lock (phi' @ loc))
                      end).
      pose (virtue12:= PTree.map
                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                          (inflated_delta12 (block, ofs))) (snd (getMaxPerm m')) ).
      assert (virtue_spec12: forall b0 ofs0,
                 (computeMap (getThreadR (MTCH_cnt MATCH Hi)).2 virtue12) !! b0 ofs0 =
                 perm_of_res_lock (phi' @ (b0, ofs0))).
      { intros b0 ofs0.
        destruct (virtue12 ! b0) eqn:VIRT.
        destruct (o ofs0) eqn:O.
        - erewrite computeMap_1; try eassumption.
          unfold virtue12 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta12 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          reflexivity.
        - erewrite computeMap_2; try eassumption.
          unfold virtue12 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta12 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          subst.
          apply resource_at_join with (loc:= (b0,ofs0)) in Hrem_fun_res.
          rewrite AA in Hrem_fun_res.
          apply join_unit1_e in Hrem_fun_res; try apply NO_identity; rewrite Hrem_fun_res.
          inversion MATCH.
          symmetry.
          apply mtch_perm2.
        - erewrite computeMap_3; try eassumption.
             unfold virtue12 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.
             clear VIRT.
             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).
             { unfold PMap.get. rewrite notInMem.
               apply Max_isCanonical.
             }
             assert (the_cure:= equal_f THE_CURE ofs0).
             rewrite getMaxPerm_correct in the_cure.
             replace ((getThreadR (MTCH_cnt MATCH Hi)).2 !! b0 ofs0) with
             (perm_of_res_lock ((getThreadR Hi)@ (b0, ofs0))).
             + assert (Hcohere':= Hcompatible).
               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.
               inversion Hcohere'.
                              specialize (max_coh (b0,ofs0)).
               unfold max_access_at, access_at in max_coh.
               unfold permission_at in the_cure.
               rewrite the_cure in max_coh.
               apply po_None1 in max_coh.
               move Hrem_fun_res at bottom.
               apply join_comm in Hrem_fun_res.
               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.
               apply join_join_sub in Hrem_fun_res.
               assert (HH:= po_join_sub_lock Hrem_fun_res).

               move:
                 (perm_of_res_op2 (getThreadR Hi @ (b0, ofs0))).

               rewrite max_coh => /po_None1 is_none.
               rewrite is_none in HH; rewrite is_none.
               apply po_None1 in HH. symmetry; assumption.
             + inversion MATCH.  apply mtch_perm2.
      }

      pose (inflated_delta21:=
              fun loc => match (d_phi @ loc ) with
                        NO s _ => if Share.EqDec_share s Share.bot then None
                               else  Some ( perm_of_res (d_phi @ loc))
                      | _ => Some ( perm_of_res (d_phi @ loc))
                      end).
      pose (virtue21:= PTree.map
                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                          (inflated_delta21 (block, ofs))) (snd (getMaxPerm m')) ).
      assert (virtue_spec21: forall b0 ofs0,
                 (computeMap empty_map virtue21) !! b0 ofs0 = (perm_of_res (d_phi @(b0, ofs0)))).
      { intros b0 ofs0.
        destruct (virtue21 ! b0) eqn:VIRT.
        destruct (o ofs0) eqn:O.
        - erewrite computeMap_1; try eassumption.
          unfold virtue21 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta21 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          reflexivity.
        - erewrite computeMap_2; try eassumption.
          unfold virtue21 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta21 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          subst; simpl.
          destruct (eq_dec Share.bot Share.bot).
          + rewrite empty_map_spec; auto.
          + exfalso; apply n; auto. contradiction.
        - erewrite computeMap_3; try eassumption.
             unfold virtue21 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.
             clear VIRT.
             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).
             { unfold PMap.get. rewrite notInMem.
               apply Max_isCanonical.
             }
             assert (the_cure:= equal_f THE_CURE ofs0).
             rewrite getMaxPerm_correct in the_cure.
             replace ((getThreadR (MTCH_cnt MATCH Hi)).1 !! b0 ofs0) with
             (perm_of_res ((getThreadR Hi)@ (b0, ofs0))).
             + assert (Hcohere':= Hcompatible).
               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.
               inversion Hcohere'.
               apply Concur.max_acc_coh_acc_coh in max_coh as acc_coh.
               unfold Concur.access_cohere' in acc_coh.
               specialize (acc_coh (b0,ofs0)).
               unfold max_access_at, access_at in acc_coh.
               unfold permission_at in the_cure.
               rewrite the_cure in acc_coh.
               apply po_None1 in acc_coh.
               move Hrem_fun_res at bottom.
               
               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.
               apply join_join_sub in Hrem_fun_res.
               assert (HH:= juicy_mem_lemmas.po_join_sub _ _ Hrem_fun_res).
               rewrite acc_coh in HH.
               apply po_None1 in HH.
               rewrite empty_map_spec.
               symmetry; assumption.
             + inversion MATCH.  apply mtch_perm1.
      }

      pose (inflated_delta22:=

              fun loc => match (d_phi @ loc ) with
                        NO s _ => if Share.EqDec_share s Share.bot then None
                               else  Some ( perm_of_res_lock (d_phi @ loc))
                      | _ => Some (perm_of_res_lock (d_phi @ loc))
                      end).

      pose (virtue22:= PTree.map
                       (fun (block : positive) (_ : Z -> option permission) (ofs : Z) =>
                          (inflated_delta22 (block, ofs))) (snd (getMaxPerm m')) ).
      assert (virtue_spec22: forall b0 ofs0,
                 (computeMap empty_map virtue22) !! b0 ofs0 =
                 (perm_of_res_lock (d_phi @(b0, ofs0)))).
      {intros b0 ofs0.
        destruct (virtue22 ! b0) eqn:VIRT.
        destruct (o ofs0) eqn:O.
        - erewrite computeMap_1; try eassumption.
          unfold virtue22 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta22 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          reflexivity.
        - erewrite computeMap_2; try eassumption.
          unfold virtue22 in VIRT. rewrite PTree.gmap in VIRT.
          destruct ((snd (getMaxPerm m')) ! b0); inversion VIRT.
          rewrite <- H0 in O.
          unfold inflated_delta22 in O.
          destruct (d_phi @ (b0, ofs0)) eqn:AA;
          try (inversion O; reflexivity).
          destruct (Share.EqDec_share sh Share.bot); inversion O.
          subst. simpl;
            rewrite empty_map_spec; auto.
        - erewrite computeMap_3; try eassumption.
             unfold virtue22 in VIRT. rewrite PTree.gmap in VIRT.
             destruct ((snd (getMaxPerm m')) ! b0) eqn:notInMem; inversion VIRT.
             clear VIRT.
             assert (THE_CURE: (getMaxPerm m') !! b0 = fun _ => None).
             { unfold PMap.get. rewrite notInMem.
               apply Max_isCanonical.
             }
             assert (the_cure:= equal_f THE_CURE ofs0).
             rewrite getMaxPerm_correct in the_cure.
             replace ((getThreadR (MTCH_cnt MATCH Hi)).2 !! b0 ofs0) with
             (perm_of_res_lock ((getThreadR Hi)@ (b0, ofs0))).
          + assert (Hcohere':= Hcompatible).
               apply Concur.compatible_threadRes_cohere with (cnt:=Hi) in Hcohere'.
               inversion Hcohere'.
                              specialize (max_coh (b0,ofs0)).
                unfold max_access_at, access_at in max_coh.
               unfold permission_at in the_cure.

               rewrite the_cure in max_coh.
               apply po_None1 in max_coh.
               move Hrem_fun_res at bottom.
               
               apply resource_at_join with (loc:=(b0,ofs0)) in Hrem_fun_res.
               apply join_join_sub in Hrem_fun_res.
               assert (HH:= po_join_sub_lock Hrem_fun_res).

               move:
                 (perm_of_res_op2 (getThreadR Hi @ (b0, ofs0))).

               rewrite max_coh => /po_None1 is_none.
               rewrite empty_map_spec.
               rewrite is_none in HH.
               apply po_None1 in HH. symmetry; assumption.
             + inversion MATCH.  apply mtch_perm2.

      }

      pose (ds_upd:= updThread
                       (MTCH_cnt MATCH Hi)
                       (Kresume c Vundef)
                       (computeMap (getThreadR (MTCH_cnt MATCH Hi)).1 virtue11,
                        computeMap (getThreadR (MTCH_cnt MATCH Hi)).2 virtue12)).

      pose (ds':= addThread
                    ds_upd
                    (Vptr b ofs)
                    arg
                    (computeMap empty_map virtue21,
                     computeMap empty_map virtue22)).
      exists ds'.
      eexists.
      split ;[|split].
      { 
        cut (invariant ds_upd).
        { 
          intro HH; apply addThrd_inv.
          - assumption.
          - move=> j cntj .
            split;
              apply permDisjoint_permMapsDisjoint => b0 ofs0.
            + rewrite virtue_spec21.
              destruct (eq_dec i j).
              * subst. rewrite gssThreadRes.
                rewrite virtue_spec11.
                apply joins_permDisjoint.
                apply resource_at_joins.
                eexists; eassumption.
              * rewrite gsoThreadRes; auto.
                rewrite (MTCH_perm' _ MATCH).
                apply joins_permDisjoint.
                apply resource_at_joins.
                eapply join_sub_joins_trans; eauto.
                exists phi'; eauto.
                simpl.
                eapply Concur.compatible_threadRes_join; eauto.
            + rewrite virtue_spec22.
              destruct (eq_dec i j).
              * subst. rewrite gssThreadRes.
                rewrite virtue_spec12.
                apply joins_permDisjoint_lock.
                apply resource_at_joins.
                eexists; eassumption.
              * rewrite gsoThreadRes; auto.
                rewrite (MTCH_perm2' _ MATCH).
                apply joins_permDisjoint_lock.
                apply resource_at_joins.
                eapply join_sub_joins_trans; eauto.
                exists phi'; eauto.
                simpl.
                eapply Concur.compatible_threadRes_join; eauto.
          - move => l rm.
            rewrite gsoThreadLPool => isLock2.
            split; apply permDisjoint_permMapsDisjoint=> b0 ofs0 /=.
            + rewrite virtue_spec21.

              assert (exists pmap1, lockRes js l = Some pmap1).
              { inversion MATCH.
                specialize (mtch_locks l).
                rewrite isLock2 in mtch_locks.
                destruct (lockRes js l).
                - exists l0; reflexivity.
                - inversion mtch_locks.
              }
              destruct H as [rm' H].
              destruct rm'.
              * inversion MATCH.
                rewrite -(mtch_locksRes _ _ _ H isLock2).
                apply joins_permDisjoint.
                apply resource_at_joins.
                eapply join_sub_joins_trans.
                exists phi'; eassumption.
                eapply Concur.compatible_threadRes_lockRes_join;
                  eauto.
              * inversion MATCH.
                specialize (mtch_locksEmpty _ _ H isLock2).
                inversion mtch_locksEmpty.
                rewrite empty_map_spec.
                eapply permDisjoint_comm.
                eapply permDisjoint_None.
            + rewrite virtue_spec22.

              assert (exists pmap1, lockRes js l = Some pmap1).
              { inversion MATCH.
                specialize (mtch_locks l).
                rewrite isLock2 in mtch_locks.
                destruct (lockRes js l).
                - exists l0; reflexivity.
                - inversion mtch_locks.
              }
              destruct H as [rm' H].
              destruct rm'.
              * inversion MATCH.
                rewrite -(mtch_locksRes0 _ _ _ H isLock2).
                apply joins_permDisjoint_lock.
                apply resource_at_joins.
                eapply join_sub_joins_trans.
                exists phi'; eassumption.
                eapply Concur.compatible_threadRes_lockRes_join;
                  eauto.
              * inversion MATCH.
                specialize (mtch_locksEmpty _ _ H isLock2).
                inversion mtch_locksEmpty.
                rewrite empty_map_spec.
                eapply permDisjoint_comm.
                eapply permDisjoint_None.
          - move=> b0 ofs0;
              simpl.
            rewrite virtue_spec21 virtue_spec22.
            apply perm_coh_self.
          - move=> j cntj b0 ofs0.
            rewrite virtue_spec21.
            destruct (eq_dec i j).
            * subst. rewrite gssThreadRes.
              rewrite virtue_spec12.
              apply perm_coh_joins.
              apply resource_at_joins.
              eexists; eauto.
            * rewrite gsoThreadRes; auto.
              rewrite (MTCH_perm2' _ MATCH).
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply join_sub_joins_trans.
              -- eexists; eauto.
              --  eapply Concur.compatible_threadRes_join; eauto.
          - move=> j cntj b0 ofs0.
            rewrite virtue_spec22.
            destruct (eq_dec i j).
            * subst. rewrite gssThreadRes.
              rewrite virtue_spec11.
              apply perm_coh_joins.
              apply resource_at_joins.
              eexists; eauto.
            * rewrite gsoThreadRes; auto.
              rewrite (MTCH_perm' _ MATCH).
              apply perm_coh_joins.
              apply resource_at_joins.
              apply joins_comm.
              eapply join_sub_joins_trans.
              -- eexists; eauto.
              --  eapply Concur.compatible_threadRes_join; eauto.
          - move => l rm .
            rewrite gsoThreadLPool => isLock b0 ofs0.
            rewrite virtue_spec21.
             assert (exists pmap1, lockRes js l = Some pmap1).
              { inversion MATCH.
                specialize (mtch_locks l).
                rewrite isLock in mtch_locks.
                destruct (lockRes js l).
                - exists l0; reflexivity.
                - inversion mtch_locks.
              }
              destruct H as [rm' H].
              destruct rm'.
              + inversion MATCH.
                rewrite -(mtch_locksRes0 _ _ _ H isLock).
                apply perm_coh_joins.
                apply resource_at_joins.
                eapply join_sub_joins_trans.
                exists phi'; eassumption.
                eapply Concur.compatible_threadRes_lockRes_join;
                  eauto.
              + inversion MATCH.
                specialize (mtch_locksEmpty _ _ H isLock).
                inversion mtch_locksEmpty.
                rewrite empty_map_spec.
                eapply perm_coh_empty_1.
          - move => l rm .
            rewrite gsoThreadLPool => isLock b0 ofs0.
            rewrite virtue_spec22.
             assert (exists pmap1, lockRes js l = Some pmap1).
              { inversion MATCH.
                specialize (mtch_locks l).
                rewrite isLock in mtch_locks.
                destruct (lockRes js l).
                - exists l0; reflexivity.
                - inversion mtch_locks.
              }
              destruct H as [rm' H].
              destruct rm'.
              + inversion MATCH.
                rewrite -(mtch_locksRes _ _ _ H isLock).
                apply perm_coh_joins.
                apply resource_at_joins.
                apply joins_comm.
                eapply join_sub_joins_trans.

                exists phi'; eassumption.
                eapply Concur.compatible_threadRes_lockRes_join;
                  eauto.
              + inversion MATCH.
                specialize (mtch_locksEmpty _ _ H isLock).
                inversion mtch_locksEmpty.
                rewrite empty_map_spec.
                eapply perm_coh_empty_2.
                apply juicy_mem_lemmas.perm_of_res_lock_not_Freeable.
        }

        { 
          
          apply invariant_decr.
          - assumption.
          - simpl=> b0 ofs0.
            rewrite virtue_spec11.
            rewrite -MTCH_perm.
            apply juicy_mem_lemmas.po_join_sub.
            move Hrem_fun_res at bottom.
            replace
              (m_phi
                      (Concur.personal_mem
                         (Concur.thread_mem_compatible Hcompatible Hi)))
            with
            (getThreadR Hi) in Hrem_fun_res by reflexivity.
            eapply resource_at_join_sub.
            exists d_phi. apply join_comm; assumption.
          - simpl=> b0 ofs0.
            rewrite virtue_spec12.
            rewrite -MTCH_perm2.
            
            apply po_join_sub_lock.
            apply resource_at_join_sub.
            exists d_phi.
            apply join_comm.
            assumption.
        }
      }

      { 
        apply match_st_age_tp_to.
        apply MTCH_addThread.
        - apply MTCH_update.
          + assumption.
          + intros. symmetry; apply virtue_spec11.
          + intros. symmetry; apply virtue_spec12.
        - intros. symmetry; apply virtue_spec21.
        - intros. symmetry; apply virtue_spec22.
      }
      {
        eapply DryHybridMachine.step_create with
        (virtue1:=(virtue11,virtue12))
          (virtue2:=(virtue21,virtue22)).
        - 
          split.
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p0 f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta11 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p0, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p0, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          {
            apply join_join_sub in Hrem_fun_res.
            apply resource_at_join_sub with (l:=(p0,b0)) in Hrem_fun_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p0, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p0, b0)).
            destruct m'; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p0) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }
          
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta12 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          {
            apply join_join_sub in Hrem_fun_res.
            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_fun_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p, b0)).
            destruct m'; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }

        - 
           split.
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p0 f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta21 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p0, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p0, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          {
            apply join_join_sub in Hrem_fun_res.
            apply resource_at_join_sub with (l:=(p0,b0)) in Hrem_fun_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p0, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p0, b0)).
            destruct m'; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p0) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }
          
        * eapply sub_map_and_shape;
          [eapply same_shape_map|].
          move=> p f1 HH.
          assert (HH':= HH).
          eapply map_leq_apply in HH';
            try apply treemap_sub_map.
          rewrite PTree.gmap in HH.
          destruct HH'  as [f2 HH'].
          rewrite HH' in HH; simpl in HH; inversion HH.
          exists f2; split; auto.
          move => b0 f1b0.
          unfold inflated_delta22 in f1b0.
          destruct (f2 b0) eqn:is_none; auto.
          cut (perm_of_res (d_phi @ (p, b0)) = None).
          { rewrite /perm_of_res.
            destruct (d_phi @ (p, b0)) eqn:DELT;
              try solve[intros delt; inversion delt].
            destruct (eq_dec sh Share.bot) eqn:DELT';
              try solve[intros delt; inversion delt].
            unfold eq_dec in DELT'.
            rewrite DELT' in f1b0; inversion f1b0.
            destruct k; intros NADA; inversion NADA.
            apply perm_of_empty_inv in NADA.
            subst; exfalso. apply shares.bot_unreadable; assumption. }
          {
            apply join_join_sub in Hrem_fun_res.
            apply resource_at_join_sub with (l:=(p,b0)) in Hrem_fun_res.
            apply juicy_mem_lemmas.po_join_sub in Hrem_fun_res.
            eapply juicy_mem_lemmas.perm_order''_trans in Hrem_fun_res;
              [|eapply perm_of_res_op1].

            cut ((perm_of_res'
                    (getThreadR Hi @ (p, b0))) = None).
            intros to_rewrite;
              eapply po_None1; rewrite -to_rewrite; eauto.

            move: (Concur.mem_compat_thread_max_cohere
                        Hcmpt Hi (p, b0)).
            destruct m'; simpl in *.
            rewrite  /max_access_at
                    /access_at
                    /PMap.get /=.

            move : HH'.

            rewrite /getMaxPerm PTree.gmap1; simpl.
            destruct ((mem_access.2) ! p) eqn:AA;
              try solve [simpl; intros FALSE; inversion FALSE].
            simpl; intros TT; inversion TT.
            rewrite -H1 in is_none.
            rewrite is_none => /po_None1.
            auto.
            }

        - assumption.
        - inversion MATCH. erewrite <- mtch_gtc; eassumption.
        - reflexivity.
        - eassumption.
        - eassumption.
        - move => b0 ofs0.
          rewrite virtue_spec11.
          rewrite virtue_spec21.
          inversion MATCH. erewrite <- MTCH_perm.
          eapply permjoin.join_permjoin.
          apply resource_at_join.
          move Hrem_fun_res at bottom.
            replace
              (m_phi
                      (Concur.personal_mem
                         (Concur.thread_mem_compatible Hcompatible Hi)))
            with
            (getThreadR Hi) in Hrem_fun_res by reflexivity.
            assumption.
        -move => b0 ofs0.
          rewrite virtue_spec12.
          rewrite virtue_spec22.
          inversion MATCH. erewrite <- MTCH_perm2.
          eapply permjoin.join_permjoin_lock. 
          apply resource_at_join.
          move Hrem_fun_res at bottom.
            replace
              (m_phi
                      (Concur.personal_mem
                         (Concur.thread_mem_compatible Hcompatible Hi)))
            with
            (getThreadR Hi) in Hrem_fun_res by reflexivity.
            assumption.
        - reflexivity.

        - reflexivity.
      }
    }

    {
      assert (Htid':= MTCH_cnt MATCH Hi).
           pose (pmap_tid  := getThreadR Htid').
      pose (pdata:= fun i:nat => pmap_tid.1 !! b (Z.of_nat i)).
      pose (pmap_tid' :=
              (setPermBlock
                (Some Nonempty)
                b
                (Ptrofs.intval ofs)
                pmap_tid.1
                LKSIZE_nat,
               (setPermBlock
                  (Some Writable)
                  b
                  (Ptrofs.intval ofs)
                  pmap_tid.2
                  LKSIZE_nat

           ))).
   assert (pmap_spec1: forall b0 ofs0, perm_of_res (phi' @ (b0, ofs0)) =
                                    pmap_tid'.1 !! b0 ofs0).
   { move => b0 ofs0.
     rewrite /pmap_tid'.
     destruct (peq b b0);
       [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].
     - rewrite setPermBlock_same; auto.

       assert (HH':adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).
       { split; auto. }

       move: Hrmap => /=.
       rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.
       intros [X Hg]; destruct (X _ HH') as (val & sh & Rsh & sh_before & Wsh & sh_after); clear X.
       rewrite sh_after.
       reflexivity.
     - rewrite setPermBlock_other_1.

       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).
        { intros [ H1 [H2 H2']]; apply n; split; auto.  }
        move: Hrmap.
       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].
       move=> /(_ _ HH') => <- _ /=.
       rewrite (MTCH_perm' _ MATCH); simpl; repeat f_equal;
       apply proof_irrelevance.

       apply Intv.range_notin in n; auto.
       pose proof LKSIZE_pos; simpl. xomega.
     - rewrite setPermBlock_other_2.

       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b0,ofs0)).
        { intros [ H1 [H2 H2']]; apply n. auto.  }
        move: Hrmap.
       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].
       move=> /(_ _ HH') => <- _ /=.
       rewrite (MTCH_perm' _ MATCH); simpl; repeat f_equal;
       apply proof_irrelevance.

       auto.

       }

   assert (pmap_spec2: forall b0 ofs0, perm_of_res_lock (phi' @ (b0, ofs0)) =
                                    pmap_tid'.2 !! b0 ofs0).
    { move => b0 ofs0.
     rewrite /pmap_tid'.
     destruct (peq b b0);
       [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].
     - rewrite setPermBlock_same.

       assert (HH':adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).
       { split; auto. }

       move: Hrmap => /=.
       rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.
       intros [X Hg]; destruct (X _ HH') as (val & sh & Rsh & sh_before & Wsh & sh_after); clear X.
       rewrite sh_after.
       apply perm_of_writable0;
         try apply shares.writable0_share_glb_Rsh; eauto;
           apply shares.glb_Rsh_not_top.
       auto.

     - rewrite setPermBlock_other_1.

       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).
        { intros [ H1 [H2 H2']]; apply n; split; auto.  }
        move: Hrmap.
       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].
       move=> /(_ _ HH') => <- _ /=.
       rewrite (MTCH_perm2' _ MATCH); simpl; repeat f_equal;
       apply proof_irrelevance.

       apply Intv.range_notin in n; auto.
       pose proof LKSIZE_pos; simpl. xomega.
     - rewrite setPermBlock_other_2.

       assert (HH': ~ adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b0,ofs0)).
        { intros [ H1 [H2 H2']]; apply n. auto.  }
        move: Hrmap.
       rewrite /rmap_locking.rmap_makelock => [] [] H1 [].
       move=> /(_ _ HH') => <- _ /=.
       rewrite (MTCH_perm2' _ MATCH); simpl; repeat f_equal;
       apply proof_irrelevance.

       auto.

       }

      pose (ds':= updThread Htid' (Kresume c Vundef) (pmap_tid')).
      pose (ds'':= updLockSet ds' (b, Ptrofs.intval ofs) (empty_map,empty_map)).
      exists ds'',  (Events.mklock (b, Ptrofs.intval ofs)).
      split ; [|split].
      - 
        cut (invariant ds').
        { intros dinv'.
          apply updLock_inv.
          - assumption.
          - intros i0 cnt0 ofs0 ineq.
            apply permMapsDisjoint2_empty.
          - intros i0 cnti.
            apply permMapsDisjoint2_comm;
            apply permMapsDisjoint2_empty.
          - intros laddr rmap'0 H H0; split;
            first [ apply permCoh_empty | apply permCoh_empty'].
            { move=> b0 ofs0.
              apply (invariant_not_freeable) with (b1:=b0)(ofs1:= ofs0) in dinv.
              destruct dinv as [AA BB].
              eapply BB in H0.
              destruct ((rmap'0.2) # b0 ofs0); try constructor.
              destruct p; try constructor.
              exfalso; apply H0; reflexivity. }
          - intros i0 cnti; apply permCoh_empty'.
          - intros i0 cnti; split;
            first [ apply permCoh_empty | apply permCoh_empty'].
            { move=> b0 ofs0.
              destruct (eq_dec i0 i).
              - subst i0.
                rewrite gssThreadRes.
                rewrite <- pmap_spec2.
                apply perm_of_res_lock_not_Freeable.
              - rewrite gsoThreadRes; auto.

                rewrite (MTCH_perm2' _ MATCH).

              apply perm_of_res_lock_not_Freeable. }
          - intros ofs0  ineq.
            rewrite gsoThreadLPool.

          destruct (lockRes ds (b, ofs0)) eqn:AA;  auto.

          inversion MATCH. specialize (mtch_locks (b,ofs0)).
          rewrite AA in mtch_locks.
          destruct (lockRes js (b, ofs0)) eqn:BB; inversion mtch_locks.
          destruct Hcompatible as [allj Hcompatible].
          inversion Hcompatible.
          specialize (lset_in_juice (b, ofs0)). setoid_rewrite BB in lset_in_juice.
          spec lset_in_juice; auto.
          destruct lset_in_juice as [sh' MAP]; auto.
          assert (HH:= Concur.compatible_threadRes_sub Hi juice_join).
          apply resource_at_join_sub with (l:= (b,ofs0)) in HH.
          assert (MAP0 := MAP 0). spec MAP0; [pose proof LKSIZE_pos; omega|]. 
            simpl in MAP0. destruct MAP0 as [shx [pshx [P [MAPx MAP0]]]]. rewrite Z.add_0_r in MAP0.
          rewrite MAP0 in HH.

          assert (ineq': Ptrofs.intval ofs <= ofs0 < Ptrofs.intval ofs + LKSIZE).
          { clear - ineq.
            destruct ineq; auto. simpl in *.
            xomega.
          }
          assert (HH':adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b,ofs0)).
          { split; auto. }
          move: Hrmap => /=.
          rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.
          intros [X Hg]; destruct (X _ HH') as (val & sh & Rsh & sh_before & Wsh & sh_after); clear X.

          rewrite sh_before in HH.
          destruct HH as [x HH]. inversion HH.

        - intros ofs0 ineq.
          rewrite gsoThreadLPool.
          destruct (lockRes ds (b, ofs0)) eqn:AA; auto.
          inversion MATCH. specialize (mtch_locks (b,ofs0)).
          rewrite AA in mtch_locks.
          destruct (lockRes js (b, ofs0)) eqn:BB; inversion mtch_locks.
          destruct Hcompatible as [allj Hcompatible].
          inversion Hcompatible.
          specialize (lset_in_juice (b, ofs0)). setoid_rewrite BB in lset_in_juice.
          destruct lset_in_juice as [sh' MAP]; auto.
          assert (HH:= Concur.compatible_threadRes_sub Hi juice_join).
          assert (ineq': 0 <= Ptrofs.intval ofs - ofs0 < LKSIZE).
          { clear - ineq. simpl in ineq; destruct ineq. xomega. }
          apply resource_at_join_sub with (l:= (b,Ptrofs.intval ofs)) in HH.
          specialize (MAP _ ineq'). destruct MAP as [shx [pshx [P [MAPx MAP]]]]. simpl in MAP.
          replace (ofs0 + (Ptrofs.intval ofs - ofs0)) with (Ptrofs.intval ofs) in MAP by omega.
          move: Hrmap => /=.
          rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2 H3.
          assert (adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, Ptrofs.unsigned ofs)).
          { split; auto.
            split; omega. }
          destruct H3 as [H3 Hg].
          move: (H3 _ H4)=> [] v [] sh [] Rsh [] HH1 [] Wsh HH2.
          rewrite HH1 in HH.
          destruct HH as [x HH]. simpl in HH2. rewrite Z.sub_diag in HH2.
          clear - MAP HH. rewrite MAP in HH. inv HH.
        }

        { 
          
          assert (H:forall j cntj, i<> j ->
                              joins phi' (@getThreadR _ _ _ j js (MTCH_cnt' MATCH cntj))).
          { 
            intros j cntj neq.
            assert (Hcmpt':=Hcmpt).
            apply Concur.compatible_threadRes_join  with
            (cnti:= Hi)(cntj0:= (MTCH_cnt' MATCH cntj)) in Hcmpt'; auto.
              destruct Hcmpt' as [x thread_join].
              simpl in Hrmap.
              apply (rmap_locking.rmap_makelock_join
                       _ _ _ _
                       _ _ _
                       LKSIZE_pos
                       Hrmap) in thread_join.
              destruct thread_join as [X [_ THEY_JOIN]].
              exists X; assumption. }

          assert (H':forall (l : address)
                      pmap,
                     lockRes js l = Some (Some pmap) ->
                     joins phi' pmap).
          { 
            intros l pmap is_lock.
            assert (Hcmpt':=Hcmpt).
            apply Concur.compatible_threadRes_lockRes_join  with
            (cnti:= Hi)(l0:=l)(phi:=pmap) in Hcmpt'; auto.
              destruct Hcmpt' as [x thread_lock_join].
              simpl in Hrmap.
              apply (rmap_locking.rmap_makelock_join
                       _ _ _ _
                       _ _ _
                       LKSIZE_pos
                       Hrmap) in thread_lock_join.
              destruct thread_lock_join as [X [_ THEY_JOIN]].
              exists X; assumption.

          }

          apply updThread_inv.
          - eassumption.
          - intros j cnt H1.
            split; apply permDisjoint_permMapsDisjoint=> b0 ofs0.
            + rewrite <- pmap_spec1.
              rewrite (MTCH_perm' _ MATCH).
              apply joins_permDisjoint.
              apply resource_at_joins; apply H; assumption.
            + rewrite <- pmap_spec2.
              rewrite (MTCH_perm2' _ MATCH).
              apply joins_permDisjoint_lock.
              apply resource_at_joins; apply H; assumption.
          - intros j cnt neq b0 ofs0.
            rewrite (MTCH_perm' _ MATCH).
            destruct (peq b b0);
              [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].
            + rewrite setPermBlock_same; auto.

              move: Hrmap.
              rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.
              assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).
              { split; auto. }
              intros [X Hg]; destruct (X _ H3) as (val & sh & Rsh & H4 & Y & H5); clear X.
              
              assert (H0: joins (getThreadR (MTCH_cnt' MATCH cnt))
                            (getThreadR Hi)).
              { eapply Concur.compatible_threadRes_join;
                eauto. }
              apply resource_at_joins with (loc:=(b, ofs0))   in H0.
              rewrite Hpersonal_juice in H0.
              rewrite H4 in H0.
              destruct H0 as [x H0]; inversion H0; subst.
              -- rewrite - H7; simpl;
                 destruct (eq_dec sh1 Share.bot); constructor.
              -- rewrite -H7; simpl.
                 apply join_comm in RJ.
                 exfalso. eapply shares.join_writable0_readable; eauto.
            + apply Intv.range_notin in n; simpl in n; try (pose proof LKSIZE_pos; simpl; omega).
              rewrite setPermBlock_other_1; auto.
              rewrite /pmap_tid.
              rewrite (MTCH_perm2' _ MATCH).
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply Concur.compatible_threadRes_join; eauto.
            + rewrite setPermBlock_other_2; auto.
              rewrite /pmap_tid.
              rewrite (MTCH_perm2' _ MATCH).
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply Concur.compatible_threadRes_join; eauto.

          - intros j cnt neq b0 ofs0.
            rewrite (MTCH_perm2' _ MATCH).
            destruct (peq b b0);
              [subst b0; destruct (Intv.In_dec ofs0 (Ptrofs.intval ofs, Ptrofs.intval ofs + lksize.LKSIZE)%Z ) | ].
            + rewrite setPermBlock_same; auto.

              move: Hrmap.
              rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.
              assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, ofs0)).
              { split; auto. }
              intros [X Hg]; destruct (X _ H3) as (val & sh & Rsh & H4 & Wsh & H5); clear X.
              assert (H0: joins (getThreadR (MTCH_cnt' MATCH cnt))
                            (getThreadR Hi)).
              { eapply Concur.compatible_threadRes_join;
                eauto. }
              apply resource_at_joins with (loc:=(b, ofs0))   in H0.
              rewrite Hpersonal_juice in H0.
              rewrite H4 in H0.
              destruct H0 as [x H0]; inversion H0; subst.
              -- rewrite - H7; simpl;
                 destruct (eq_dec sh1 Share.bot); constructor.
              -- rewrite -H7; simpl.
                 apply join_comm in RJ.
                 exfalso. eapply shares.join_writable0_readable; eauto.
            + apply Intv.range_notin in n; simpl in n; try (pose proof LKSIZE_pos; simpl; omega).
              rewrite setPermBlock_other_1; auto.
              rewrite /pmap_tid.
              rewrite (MTCH_perm' _ MATCH).
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply Concur.compatible_threadRes_join; eauto.
            + rewrite setPermBlock_other_2; auto.
              rewrite /pmap_tid.
              rewrite (MTCH_perm' _ MATCH).
              apply perm_coh_joins.
              apply resource_at_joins.
              eapply Concur.compatible_threadRes_join; eauto.
          - move=> l pmap is_lock.
            assert (is_lock': exists p, lockRes js l = Some p).
            { destruct (lockRes js l) eqn:is_lock'.
              + exists l0; reflexivity.
              + inversion MATCH. specialize (mtch_locks l).
                rewrite is_lock is_lock' in mtch_locks.
                inversion mtch_locks. }
            destruct is_lock' as [p is_lock'];
              destruct p.
            + assert (is_lock'':=is_lock').
              apply H' in is_lock''.
              split; apply permDisjoint_permMapsDisjoint=> b0 ofs0.
              * rewrite - pmap_spec1.
                inversion MATCH.
                erewrite <- mtch_locksRes; eauto.
                apply joins_permDisjoint.
                apply resource_at_joins.
                apply joins_comm.
                eapply H'; eauto.
              * rewrite - pmap_spec2.
                inversion MATCH.
                erewrite <- mtch_locksRes0; eauto.
                apply joins_permDisjoint_lock.
                apply resource_at_joins.
                apply joins_comm.
                eapply H'; eauto.
            + inversion MATCH.
              eapply mtch_locksEmpty in is_lock';
                eauto; rewrite is_lock'.
              split; first [apply empty_disjoint' | apply empty_disjoint].
          - move=> l pmap is_lock.
            assert (is_lock': exists p, lockRes js l = Some p).
            { destruct (lockRes js l) eqn:is_lock'.
              + exists l0; reflexivity.
              + inversion MATCH. specialize (mtch_locks l).
                rewrite is_lock is_lock' in mtch_locks.
                inversion mtch_locks. }
            destruct is_lock' as [p is_lock'];
              destruct p.
             + assert (is_lock'':=is_lock').
              apply H' in is_lock''.
              split; move=> b0 ofs0.
              * rewrite - pmap_spec2.
                inversion MATCH.
                erewrite <- mtch_locksRes; eauto.
                apply perm_coh_joins.
                apply resource_at_joins.
                apply joins_comm.
                eapply H'; eauto.
              * rewrite - pmap_spec1.
                inversion MATCH.
                erewrite <- mtch_locksRes0; eauto.
                apply perm_coh_joins.
                apply resource_at_joins.
                eapply H'; eauto.
            + inversion MATCH.
              eapply mtch_locksEmpty in is_lock';
                eauto; rewrite is_lock'.
              split;
                first [ apply permCoh_empty' | apply permCoh_empty].

              { move=> b0 ofs0.
                rewrite -pmap_spec2.
                apply perm_of_res_lock_not_Freeable. }
          - intros b0 ofs0.
            rewrite - pmap_spec2 - pmap_spec1.
            apply perm_coh_self.
        }

      -     unfold ds''.
                                apply MTCH_age.
                                apply MTCH_updLockN.
                                 unfold ds'.
                                apply MTCH_update.
                                assumption.

                                intros b0 ofs0.
                                apply pmap_spec1.

                                intros b0 ofs0.
                                apply pmap_spec2.
      - econstructor 4. 
        11: reflexivity.
        11: reflexivity.
        + assumption.
        + eapply MTCH_getThreadC; eassumption.
        + reflexivity.
        + eassumption.
        + reflexivity.
        + destruct Hrmap as (_ & _ & Hl & _).
          intros ??.
          specialize (Hl (b, ofs0)) as (? & sh & ? & Hl & ? & _); [split; auto|].
          simpl in Hl.
          unfold Mem.perm; setoid_rewrite restrPermMap_Cur.
          replace (MTCH_cnt _ _) with Htid' by apply proof_irr.
          inv MATCH.
          erewrite <- mtch_perm1; setoid_rewrite Hl; simpl.
          apply perm_of_writable'; auto.
        + rewrite <- Hstore. f_equal.
          erewrite <- (MTCH_restrict_personal ).
          * reflexivity.
          * auto.
                + replace (MTCH_cnt MATCH Hi) with Htid' by
              apply proof_irrelevance; reflexivity.
        + replace (MTCH_cnt MATCH Hi) with Htid' by
              apply proof_irrelevance; reflexivity.
        + destruct (lockRes ds (b, Ptrofs.intval ofs)) eqn:AA; auto.
          inversion MATCH.
          specialize (mtch_locks (b, Ptrofs.intval ofs)).
          rewrite AA in mtch_locks.

          move: Hrmap.
          rewrite /rmap_locking.rmap_makelock => [] [] H1 [] H2.
          assert (H3: adr_range (b, Ptrofs.unsigned ofs) LKSIZE (b, Ptrofs.unsigned ofs)).
          { split; auto.
            pose proof LKSIZE_pos.
            split; omega. }
          intros [X Hg]; destruct (X _ H3) as (val & sh & Rsh & H4 & Y & H5); clear X.
          assert (Hcmpt':=Hcmpt).
          destruct Hcmpt as [jall Hcmpt].
          inversion Hcmpt.
          apply Concur.compatible_threadRes_sub with (cnt:=Hi) in juice_join.
          apply resource_at_join_sub with (l:=(b, Ptrofs.unsigned ofs)) in juice_join.
          destruct juice_join as [X HH].
          simpl in H4.
          rewrite H4 in HH.
          hnf in lset_in_juice.
          specialize (lset_in_juice (b, Ptrofs.intval ofs)).
          spec lset_in_juice; auto. destruct lset_in_juice as [sh' ?].
          destruct (H6 0). pose proof LKSIZE_pos; omega. simpl in H7.
          destruct H7 as [psh [P [H7' H7]]].
          rewrite Z.add_0_r in H7; rewrite H7 in HH; inv HH.
    }

        { assert (Htid':= MTCH_cnt MATCH Hi).
                    Definition WorF (sh: share): permission:=
            if eq_dec sh Share.top then Freeable else Writable.
          pose (delta_b:=
                  fun ofs0 => if (Intv.In_dec ofs0 ( Ptrofs.intval ofs,  Ptrofs.intval ofs + LKSIZE)%Z) then
                             Some (perm_of_res (phi' @ (b, ofs0)))
                           else None).
          Definition empty_delta_map: delta_map:= PTree.empty (Z -> option (option permission)).

  Lemma step_decay_invariant:
    forall (tp : dstate)  (m : Mem.mem) i

  Lemma mtch_install_perm:
    forall js ds m m' tid (MATCH : match_st js ds)
      (Hcmpt : mem_compatible js m) (Htid : containsThread js tid)
      (Hperm : install_perm Hcmpt Htid m'),
      DryHybridMachine.install_perm _ _ _ (MTCH_compat _ _ _ MATCH Hcmpt) (MTCH_cnt MATCH Htid) m'.

  Lemma core_diagram':
    forall (m : Mem.mem)  (U0 U U': schedule)

  Lemma core_diagram:
    forall (m : Mem.mem)  (U0 U U': schedule) rmap pmap

  Lemma halted_diagram:
    forall U ds js rmap pmap,
      fst (fst js) = fst (fst ds) ->
      halted (JMachineSem(ge := ge) U rmap) js = halted (ClightMachineSem(ge := ge) U pmap) ds.

  End Parching.

End Parching. *)

Require Import VST.concurrency.juicy.erasure_safety.
(* VST.concurrency.juicy.erasure_safety:
Require Import ProofIrrelevance.

Require Import compcert.common.Memory.

Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.

Require Import VST.concurrency.common.HybridMachineSig.
Require Import VST.concurrency.juicy.juicy_machine. Import Concur.
Require Import VST.concurrency.common.HybridMachine.
Require Import VST.concurrency.common.lksize.
Require Import VST.concurrency.common.permissions.

Require Import VST.concurrency.juicy.erasure_signature.
Require Import VST.concurrency.juicy.erasure_proof.
Require Import VST.concurrency.juicy.Clight_safety.
Import addressFiniteMap.

From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Require Import VST.concurrency.common.ssromega. 
From mathcomp.ssreflect Require Import ssreflect seq.

Set Bullet Behavior "Strict Subproofs".

Module ErasureSafety.

  Module ErasureProof := erasure_proof.Parching.
  Module Erasure := ErasureFnctr ErasureProof.
  Import ErasureProof.
  Import Erasure.

  Section ErasureSafety.

  Context (initU: HybridMachineSig.schedule).
  Context (init_rmap : @res JR).
  Context (init_pmap : @res DR).
  Context (init_rmap_perm:  match_rmap_perm init_rmap init_pmap).

  Definition step_diagram:= ErasureProof.core_diagram.

  Import JuicyMachineModule.THE_JUICY_MACHINE.
  Import ClightMachine.Clight_newMachine.DMS.

  Existing Instance DMS.

  Lemma erasure_safety': forall n ge sch js jtr ds dtr m,
      ErasureProof.match_st ge js ds ->

  Theorem erasure_safety: forall ge cd j js ds m n,
      Erasure.match_state ge cd j js m ds m ->

  End ErasureSafety.

End ErasureSafety.

Require Import VST.concurrency.juicy.semax_to_juicy_machine.

Lemma no_locks_no_locks_perm : forall r, Parching.no_locks_perm r <-> initial_world.no_locks r.

Lemma juice2Perm_match : forall m r, access_cohere' m r ->
  Parching.match_rmap_perm r (juice2Perm r m, empty_map).

Section DrySafety.

  Variable (CPROOF : CSL_proof).

  Instance Sem : Semantics := ClightSemanticsForMachines.Clight_newSem (Clight.globalenv CPROOF.(CSL_prog)).
  Definition ge := Clight.globalenv CPROOF.(CSL_prog).
  Instance DTP : threadPool.ThreadPool.ThreadPool := Parching.DTP ge.
  Instance DMS : HybridMachineSig.MachineSig := Parching.DMS ge.
  Definition init_mem := proj1_sig (init_mem CPROOF).
  Definition init_rmap n := m_phi (initial_jm CPROOF n).

  Lemma init_match n : Parching.match_rmap_perm (init_rmap n) (getCurPerm init_mem, empty_map).

  Lemma init_no_locks n : Parching.no_locks_perm (init_rmap n).

  Theorem dry_safety_initial_state (sch : HybridMachineSig.schedule) (n : nat) :

  Context {SW : spawn_wrapper CPROOF}.

  Notation ClightSem:= ClightSemanticsForMachines.ClightSem.
  Theorem Clight_initial_safe (sch : HybridMachineSig.schedule) (n : nat) :

End DrySafety. *)



Require Import VST.concurrency.compiler.safety.
(* VST.concurrency.compiler.safety:
From mathcomp.ssreflect Require Import ssreflect seq ssrbool ssrnat.

Require Import Coq.ZArith.ZArith.

Require Import compcert.common.Memory.

Require Import VST.msl.eq_dec.

Require Import VST.concurrency.common.konig.

Require Import VST.msl.Axioms.

Section cardinality.

End cardinality.

Section filtered_konig.
  Variable X: Type.
  Variable Filter: X -> Prop.
  Variable R: X->X->Prop.
  Hypothesis em: forall P, P \/ ~ P.
  Hypothesis  preservation :  forall P P', Filter P -> R P P' -> Filter P'.

  Record TT :Type:= mkTT {thing: X; prf: Filter thing}.
  Inductive RR: TT->TT->Prop:=
  | stepstep: forall P x' (stp: R (thing P) x'), RR P (mkTT x' (preservation _ _ (prf P) stp)).

  Lemma filtered_to_unfiltered_safe:
    forall P,
      konig.safe _ RR P ->
  Lemma unfiltered_to_filtered_safeN:
    forall n P,
      konig.safeN X R n (thing P) ->

  Inductive cardinality {X} (P:X->Prop): nat -> Prop:=
  |Cardinality n (f:nat-> X): (forall i j, i<n -> j<n -> i<>j -> f(i)<>f(j)) ->
                           (forall i, i<n -> P (f i)) ->
                           (forall x, P x -> exists i, i < n /\ f i = x) ->
                           cardinality P n.
  Inductive cardinality' {X} (P:X->Prop): nat -> Prop:=
  |Cardinality' n (f:nat-> X): (forall i j, i<n -> j<n -> i<>j  -> f(i)<>f(j)) ->
                            (forall i, i<n -> P (f i)) ->
                            cardinality' P n.

  Lemma repetition_dec: forall (f:nat -> X) x n,  (exists i, i<n /\ f(i) = x) \/ (forall i, i<n -> f i <> x).
  Lemma finite_cardinality:
    forall (P:X->Prop) (EM: forall x, P x \/ ~ P x), finite P -> exists n, cardinality P n.

  Lemma filtered_konigsafe:
    forall (x : X),
      (forall P : Prop, P \/ ~ P) ->
      (forall x0 : X, Filter x0 -> finite (R x0)) ->
      Filter x ->
      (forall n : nat, safeN X R n x) -> konig.safe X R x.

End filtered_konig.

Section Safety.
  Context (ST:Type)(SCH:Type).
  Context (STEP:ST->SCH->ST->SCH-> Prop).
  Context (valid: ST-> SCH -> Prop).
  Hypothesis em: forall P, P \/ ~ P.
  
  Lemma schedule_dec:
    forall (U U':SCH), (U=U') \/ (U<>U').
  
  Inductive ksafe (st:ST) U: nat -> Prop :=
  |sft0: ksafe st U 0
  |sft_step: forall n st' U', STEP st U st' U' -> (forall U'', valid st' U'' -> ksafe st' U'' n) -> ksafe st U (S n).

  CoInductive safe st U: Prop:=
  | csft_step: forall st' U', STEP st U st' U' -> (forall U'', valid st' U'' -> safe st' U'') -> safe st U.

  Definition SST:= ST -> Prop.
  
  Definition is_in (st:ST)(P:SST):= P st.
  
  Infix "\In":= (is_in) (at level 20, right associativity).

  Inductive SStep {X Y: Type} (R: X -> X -> Y -> Prop)(valid:X->Y->Prop) (P P':X -> Prop) : Prop:=
  | blahblah: (forall x y, P x -> valid x y -> exists x', R x x' y /\ P' x') ->
              (forall x', P' x' -> exists x y, R x x' y /\ P x /\ valid x y) ->
              SStep R valid P P'.
  Definition SST_step : SST -> SST -> Prop := SStep (fun st st' U => exists U', STEP st U st' U') valid.
  Hypothesis  preservation : forall P0 P' : SST, finite P0 -> SST_step P0 P' -> finite P'.

  Definition SsafeN:= konig.safeN SST SST_step.
  Definition Ssafe:= konig.safe (SST) SST_step.
  
  Inductive P_init {st_init:ST}: SST:=
  |ItIsMe: P_init st_init.

  Lemma finite_P_init: forall {st}, finite (@P_init st).

  Lemma SsafeN_ksafe': forall n P,
      SsafeN n P -> forall st U, st \In P -> valid st U -> ksafe st U n.

  Corollary SsafeN_ksafe: forall n st,
      SsafeN n (@P_init st) -> forall U, valid st U -> ksafe st U n.

  Lemma ksafe_SsafeN': forall n P,
      (forall st U, st \In P -> valid st U -> ksafe st U n) ->
      SsafeN n P.

  Lemma ksafe_SsafeN: forall st_init,
      (forall U, valid st_init U) ->
      forall n, (forall U, ksafe st_init U n) ->
           SsafeN n (@P_init st_init).

  Lemma Ssafe_safe': forall P,
      Ssafe P -> forall st U, st \In P -> valid st U -> safe st U.

  Lemma Ssafe_safe: forall st_init,
      (forall U, valid st_init U) ->
      Ssafe (@P_init st_init) -> forall U, safe st_init U.

  Lemma SsafeN_Ssafe:
    (forall P: Prop, P \/ ~ P) ->
    forall P,
      (forall P, finite (SST_step P)) ->
      (forall n, SsafeN n P) ->
      Ssafe P.

  Lemma finite_Ssafe_safe':
    (forall P : Prop, P \/ ~ P) ->
    (forall P : ST -> Prop, finite P -> finite (SST_step P)) ->
    forall P, (finite P) ->
         ( forall n : nat, safeN (ST -> Prop) SST_step n P) ->
         Ssafe P.

  Lemma finite_Ssafe_safe:
    (forall P : Prop, P \/ ~ P) ->
    (forall P : ST -> Prop, finite P -> finite (SST_step P)) ->
    forall st, ( forall n : nat, safeN (ST -> Prop) SST_step n (@P_init st)) ->
          Ssafe (@P_init st).

  Definition possible_image {X Y} (STEP:X-> Y-> X  -> Prop) (valid: X -> Y -> Prop)  st st' U:= valid st U /\  STEP st U st' .
  Definition finite_on_x {X Y} (A:X->Y->Prop):=
    exists n (f: nat -> X), forall x y, A x y -> exists i, (i < n) /\ f i = x.
  
  Lemma finite_rel_generalize' {X Y} (V: X -> Y -> Prop) (R: X -> X -> Y -> Prop):
    (forall x, finite_on_x (possible_image (fun x x' y => R x y x') V x)) ->
    forall (P:X -> Prop), finite P ->
                 finite (fun x' => exists x y, P x /\ V x y /\ R x x' y).
  Lemma power_set_finite {X}:
    (forall P : Prop, P \/ ~ P) ->
    forall P: X-> Prop, finite P ->
               finite (fun A => subset A P).

  Lemma subset_finite {X}: forall (P P': X-> Prop), finite P -> subset P' P -> finite P'.

  Lemma finite_rel_generalize {X Y} (V: X -> Y -> Prop) (R: X -> X -> Y -> Prop):
    forall (propositional_extentionality: True),
      (forall P : Prop, P \/ ~ P) ->
      (forall x, finite_on_x (possible_image (fun x x' y => R x y x') V x)) ->
      forall (P:X -> Prop), finite P ->
                   finite (SStep R V P).

  Lemma ksafe_safe':
    (forall P: Prop, P \/ ~ P) ->
    forall (propositional_extentionality: True),
    forall (branches_finitely_on_the_state: forall x : ST,
          @finite_on_x _ _ (possible_image (fun x y x' => exists y', STEP x y x' y') valid x)),
    forall st,
      (forall n U, valid st U -> ksafe st U n) ->
      (forall U, valid st U -> safe st U).

  Lemma ksafe_safe:
    (forall P: Prop, P \/ ~ P) ->
    forall (propositional_extentionality: True),
    forall (branches_finitely_on_the_state: forall x : ST,
          @finite_on_x _ _ (possible_image (fun x y x' => exists y', STEP x y x' y') valid x)),
    forall st,
      (forall U : SCH, valid st U) ->
      (forall n U, ksafe st U n) ->
      (forall U, safe st U).
   Lemma safe_ksafe':
    forall st,
      (forall U, valid st U -> safe st U) ->
      (forall U, valid st U -> forall n, ksafe st U n).

  Lemma safe_ksafe:
    forall st,
      (forall U : SCH, valid st U) ->
      (forall U, safe st U) ->
      (forall n U, ksafe st U n).

End Safety. *)

Require Import VST.concurrency.compiler.coinductive_safety.
(* VST.concurrency.compiler.coinductive_safety:
Require Import Setoid Program.
Require Import VST.concurrency.paco.src.paco.

Section safety_equivalence.

  Context
  ( X Y:Type)
  ( halted: X -> Y -> Prop)
  ( int_step: X -> Y -> Y -> Prop)
  ( ext_step: X -> Y -> X -> Y -> Prop)
  ( valid: X -> Y -> Prop).

  Axiom determinism:
    forall x y y',
      valid x y  -> int_step x y y' ->
      forall x',
        valid x' y -> int_step x' y y'.

  Axiom valid_step:
    forall x y y',
      valid x y  -> int_step x y y' ->
      valid x y'.

  Section explicit_safety.

    CoInductive exp_safety (x:X) (y:Y): Prop:=
    | halted_safety : halted x y -> exp_safety x y
    | internal_safety y': int_step x y y'  ->
                          (forall x',  valid x' y' -> exp_safety x' y') ->
                          exp_safety x y
    | external_safety x' y': ext_step x y x' y' ->
                             (forall x',  valid x' y' -> exp_safety x' y') ->
                             exp_safety x y.

    Inductive exp_safety_gen {_exp_safety} (x:X) (y:Y): Prop:=
    | paco_halted_safety : halted x y -> exp_safety_gen x y
    | paco_internal_safety y': int_step x y y'  ->
                               (forall x',  valid x' y' -> _exp_safety x' y') ->
                               exp_safety_gen x y
    | paco_external_safety x' y': ext_step x y x' y' ->
                                  (forall x',  valid x' y' -> _exp_safety x' y') ->
                                  exp_safety_gen x y.
    Definition paco_exp_safety := paco2 (@exp_safety_gen).

    Lemma exp_safety_paco_correct:
      forall x y, exp_safety x y <-> paco_exp_safety bot2 x y.

  End explicit_safety.

  Section explicit_safetyN.
    Inductive stepN x y y': nat -> Prop :=
    | trivial_step: y = y' -> stepN x y y' 0
    | _stepN n _y: int_step x y _y -> stepN x _y y' n -> stepN x y y' (S n).

    Inductive exp_safetyN_gen {_exp_safety} (x:X) (y:Y): Prop:=
    | paco_halted_safetyN : halted x y -> exp_safetyN_gen x y
    | paco_internal_safetyN y' n: stepN x y y' (S n)  ->
                                  (forall x',  valid x' y' -> _exp_safety x' y') ->
                                  exp_safetyN_gen x y
    | paco_external_safetyN x' y': ext_step x y x' y' ->
                                   (forall x',  valid x' y' -> _exp_safety x' y') ->
                                   exp_safetyN_gen x y.
    Definition paco_exp_safetyN := paco2 (@exp_safetyN_gen).

    Lemma determinismN:
      forall n,
      forall x y y',
        valid x y  -> stepN x y y' n ->
        forall x',
          valid x' y -> stepN x' y y' n.

    Lemma valid_stepN:
      forall n,
      forall x y y',
        valid x y  -> stepN x y y' n ->
        valid x y'.

    Lemma safetyN_equivalence:
      forall x y,
        valid x y ->
        paco_exp_safety bot2 x y <-> paco_exp_safetyN bot2 x y.

  End explicit_safetyN.

  Section explicit_safetyN_stutter.

  Context {core_data: Type}
          {core_ord : core_data -> core_data -> Prop}
          (core_ord_wf: well_founded core_ord).

  CoInductive exp_safetyN_stutter (cd:core_data) (x:X) (y:Y): Prop:=
  | halted_safetyN_stut : halted x y -> exp_safetyN_stutter cd x y
  | internal_safetyN_stut cd' y' n: stepN x y y' (S n)  ->
                            (forall x',  valid x' y' -> exp_safetyN_stutter cd' x' y') ->
                            exp_safetyN_stutter cd x y
  | external_safetyN_stut cd' x' y': ext_step x y x' y' ->
                            (forall x',  valid x' y' -> exp_safetyN_stutter cd' x' y') ->
                            exp_safetyN_stutter cd x y
  | stutter cd': core_ord cd' cd ->
                 exp_safetyN_stutter cd' x y ->
                 exp_safetyN_stutter cd x y.

  Inductive exp_safetyN_stutter_gen {_exp_safety} (cd:core_data) (x:X) (y:Y): Prop:=
  | paco_halted_safetyN_stut : halted x y -> exp_safetyN_stutter_gen cd x y
  | paco_internal_safetyN_stut cd' y' n: stepN x y y' (S n)  ->
                            (forall x',  valid x' y' -> _exp_safety cd' x' y') ->
                            exp_safetyN_stutter_gen cd x y
  | paco_external_safetyN_stut cd' x' y': ext_step x y x' y' ->
                            (forall x',  valid x' y' -> _exp_safety cd' x' y') ->
                            exp_safetyN_stutter_gen cd x y
  | paco_stutter cd': core_ord cd' cd ->
                 _exp_safety cd' x y ->
                 exp_safetyN_stutter_gen cd x y.
  Definition paco_exp_safetyN_stutter := paco3 (@exp_safetyN_stutter_gen).

  Lemma exp_safetyN_stutter_paco_correct:
    forall cd x y, exp_safetyN_stutter cd x y <-> paco_exp_safetyN_stutter bot3 cd x y.

  Lemma speach_therapy:
    forall cd x y,
      paco_exp_safetyN bot2 x y <->
      paco_exp_safetyN_stutter bot3 cd x y.
  End explicit_safetyN_stutter.

  Section The_Equivalence.

  Context (core_data: Type)
          (core_ord : core_data -> core_data -> Prop)
          (core_ord_wf: well_founded core_ord)
          (default: core_data).

  Theorem safety_stutter_stepN_equiv:
    forall x y,
      valid x y ->
      exp_safety x y <-> exists cd, @exp_safetyN_stutter _ core_ord cd x y.

  End The_Equivalence.

End safety_equivalence. *)



Require Import Omega.

Require Import VST.concurrency.common.ssromega.
(* VST.concurrency.common.ssromega:
From mathcomp.ssreflect Require Import ssreflect ssrbool ssrnat eqtype seq.
Require Import Coq.ZArith.ZArith.
Require Import PreOmega.
Set Implicit Arguments.

Ltac arith_hypo_ssrnat2coqnat :=
  match goal with
    | H : context [andb _ _] |- _ => let H0 := fresh in case/andP: H => H H0
    | H : context [orb _ _] |- _ => case/orP: H => H
    | H : context [?L <= ?R] |- _ => move/leP: H => H
    | H : context [?L < ?R] |- _ => move/ltP : H => H
    | H : context [?L == ?R] |- _ => move/eqP : H => H
    | H : context [addn ?L ?R] |- _ => rewrite -plusE in H
    | H : context [muln ?L ?R] |- _ => rewrite -multE in H
    | H : context [subn ?L ?R] |- _ => rewrite -minusE in H
  end.

Ltac arith_goal_ssrnat2coqnat :=
  rewrite ?NatTrec.trecE -?plusE -?minusE -?multE -?leqNgt -?ltnNge;
  repeat match goal with
           | |- is_true (andb _ _) => apply/andP; split
           | |- is_true (orb _ _) => try apply/orP
           | |- is_true (_ <= _) => try apply/leP
           | |- is_true (_ < _) => try apply/ltP
         end.

Ltac ssromega :=
  repeat arith_hypo_ssrnat2coqnat;
  arith_goal_ssrnat2coqnat; simpl;
  omega. *)

Set Bullet Behavior "Strict Subproofs".



Require Import Coq.Logic.Classical_Prop.



Section SafetyEquivalence.



  Import HybridMachineSig.HybridMachineSig.

  Import HybridCoarseMachine.

  Import threadPool.

  Context (resources:semantics.Resources)

          (Sem:semantics.Semantics)

          (TP: threadPool.ThreadPool.ThreadPool).

  Definition CoreSem:= semantics.csem (event_semantics.msem (@semantics.semSem Sem)).

  Context (Machine: MachineSig).

  Existing Instance Machine.

  Existing Instance DilMem.

  Existing Instance scheduler.



Ltac fold_ids:=

  repeat match goal with

         | [ U: schedule |-  _ ] =>

           match goal with

           | [  |- context[yield U] ] => fail 1

           | [  |- context[U] ] => replace U with (yield U) by auto 

           end 

         | [ m: mem |-  _ ] =>

           match goal with

           | [  |- context[diluteMem m] ] => fail 1

           | [  |- context[m] ] => replace m with (diluteMem m) by auto 

           end 

         end.

  

  Definition correct_schedule (tp:  ThreadPool.t) U : Prop:=

    match schedPeek U with

    | Some i => unique_Krun tp i

    | None => True

    end.

  

  Definition bounded_mem (m: mem) := bounded_maps.bounded_map (snd (getMaxPerm m)) .



  Definition kstate:Type:= (event_trace * ThreadPool.t * mem).

  Definition cstate2kstate (st:MachState) (m:mem): kstate:=

    (snd (fst st), snd st, m).

  Definition kstate2cstate (st:kstate) U: MachState:=

    (U, fst (fst st), snd (fst st)).

  Ltac simpl_state:=

    unfold kstate2cstate, cstate2kstate in *; simpl in *.



  Inductive sem_with_halt: MachState -> mem -> MachState -> mem -> Prop:=

  | halted_step st m:

      is_true (ssrbool.isSome (halted_machine st)) -> sem_with_halt st m st m

  | step_step st m st' m' :

      MachStep st m st' m' ->

      sem_with_halt st m st' m'.

  Definition kstep (st: kstate) U st' U': Prop:=

    sem_with_halt (kstate2cstate st U) (snd st) (kstate2cstate st' U') (snd st').



  Definition valid (kst:kstate) U := correct_schedule (snd (fst kst)) U.

  

  Definition valid_bound st U :=

    valid st U /\ bounded_mem (snd st).

  Definition ksafe_kstep (st : MachState) (m : mem) : nat -> Prop :=

    ksafe _ _ (kstep) valid (cstate2kstate st m) (fst (fst st)).

  Definition safe_kstep (st : MachState) (m : mem) : Prop :=

    safe _ _ (kstep) valid (cstate2kstate st m) (fst (fst st)).



Section Csafe_KSafe.



  Inductive CoreOrAngel: MachState -> MachState -> Prop:=

  | IsCore st tr tp':

      CoreOrAngel st (fst (fst st), seq.cat (snd (fst st)) tr, tp')

  | IsAngel st tr tp':

      CoreOrAngel st (schedSkip (fst (fst st)), seq.cat (snd (fst st)) tr, tp').

 Lemma step_CoreOrAngel: forall st m st' m',

      MachStep st m st' m' ->

      CoreOrAngel st st'.

  Proof.

    intros. inversion H;

    destruct st' as ((?&?)&?);

    simpl in *; subst;

    match goal with

    | [  |- context[seq.cat _ _] ] => econstructor

    

    | _ => replace (snd (fst st)) with (seq.cat (snd (fst st)) nil) by apply seq.cats0;

            econstructor

    end.

  Qed.



    Lemma csafe_monotone:

    forall n U tr tp m,

    csafe (U, tr, tp) m (S n) ->

    csafe (U, tr, tp) m (n) .

  Proof.

    induction n; [econstructor|].

    intros.

    inversion H; simpl in *; subst.

    - econstructor 2; auto.

    - econstructor 3; eauto.

    - econstructor 4; eauto.

  Qed.



  Inductive has_unique_running tp:Prop :=

  | HasUniqueRun i (cnti : ThreadPool.containsThread tp i) q:

      ThreadPool.getThreadC cnti = Krun q ->

      has_unique_running tp.

  

  Lemma schedPeek_Skip:

    forall U tid

      ( HschedN : schedPeek U = Some tid)

      ( HschedS : schedSkip U = U),

      False.

  Proof.

    intros. apply schedSkip_id in HschedS; subst.

    inversion HschedN.

  Qed.

  

  Lemma unique_Krun_update:

    forall st tid,

      unique_Krun st tid ->

      forall (cnt: ThreadPool.containsThread st tid) c_new m_new cnt,

        unique_Krun (ThreadPool.updThread(tid:=tid)(tp:=st) cnt (Krun c_new) m_new) tid.

  Proof.

    intros.

    unfold unique_Krun in *.

    intros.

    destruct (Nat.eq_dec j tid).

    - subst.

      destruct (Nat.eq_dec tid tid); subst;

        now auto.

    - pose proof cnti as cnti'.

      eapply ThreadPool.cntUpdate' in cnti'.

      eapply (H _ cnti' q).

      erewrite <- ThreadPool.gsoThreadCode with (cntj' := cnti) by eauto.

      assumption.



  Qed.

      

  Lemma unique_Krun_updateC:

    forall st tid,

      unique_Krun st tid ->

      forall (cnt: ThreadPool.containsThread st tid) c_new  cnt,

        unique_Krun (ThreadPool.updThreadC(tp:=st)(tid:=tid) cnt (Krun c_new)) tid.

  Proof.

    intros.

    unfold unique_Krun in *.

    intros.

    destruct (Nat.eq_dec j tid).

    - subst.

      destruct (Nat.eq_dec tid tid); subst;

        now auto.

    - pose proof cnti as cnti'.

      eapply ThreadPool.cntUpdateC' in cnti'.

      eapply (H _ cnti' q).

      erewrite ThreadPool.gsoThreadCC with (cntj' := cnti) by eauto.

      assumption.

      
  Qed.



  Lemma MachStep_preserve_unique:

    forall U tr st tr' st' m m',

      valid (tr, st, m) U -> 

      MachStep (U,tr,st) m (U,tr',st') m' ->

      has_unique_running st'.

  Proof.

    intros.

    inversion H0; simpl in *; subst;

      try solve[exfalso; eapply schedPeek_Skip; eauto].

    -  inversion Htstep; subst.

      eapply (HasUniqueRun _ _ ltac:(eapply ThreadPool.cntUpdate)).

      eapply ThreadPool.gssThreadCode.

    -  inversion Htstep; subst.

      

      eapply (HasUniqueRun _ _ ltac:(eapply ThreadPool.cntUpdateC)).

      eapply ThreadPool.gssThreadCC.

    - 

      pose proof Htstep as Htstep'.

      eapply threadStep_at_Krun in Htstep'.

      destruct Htstep' as [q Hget].

      eapply threadStep_equal_run with (j := tid) in Htstep.

      destruct Htstep as [Hget_eq _].

      specialize (Hget_eq ltac:(do 2 eexists; eauto)).

      destruct Hget_eq as [? [? ?]].

      econstructor;

        now eauto.

      Unshelve. all:auto.

  Qed.



    Lemma CoreStep_preserve_valid:

    forall U tr st tr' st' m m',

      valid (tr, st, m) U ->

      MachStep (U,tr,st) m (U,tr',st') m' ->

      valid (tr', st', m') U.

  Proof.

    intros.

    unfold valid, correct_schedule in *.

    inversion H0; simpl in *; subst;

      try solve[exfalso; eapply schedPeek_Skip; eauto];

      try (erewrite HschedN in *).

    - 

      inversion Htstep; subst.

      intros j cntj' q Hget'.

      destruct (Nat.eq_dec tid j); [now auto|].

      assert (cntj : ThreadPool.containsThread st j)

        by (eapply ThreadPool.cntUpdate'; eauto).

      erewrite @ThreadPool.gsoThreadCode with (cntj := cntj) in Hget' by eauto.

      specialize (H _ _ _ Hget').

      destruct (Nat.eq_dec tid j);

        now eauto.

    -  inversion Htstep; subst.

      intros j cntj' q' Hget'.

      destruct (Nat.eq_dec tid j); [auto|].

      assert (cntj : ThreadPool.containsThread st j)

        by (eapply ThreadPool.cntUpdateC'; eauto).

      erewrite <- @ThreadPool.gsoThreadCC with (cntj := cntj) in Hget' by eauto.

      specialize (H _ _ _ Hget').

      destruct (Nat.eq_dec tid j);

        now eauto.

    - 

      pose proof Htstep as Htstep'.

      intros j cntj' q' Hget'.

      eapply @threadStep_equal_run with (j := j) in Htstep.

      destruct Htstep as [_ Hget_eq].

      specialize (Hget_eq ltac:(do 2 eexists; eauto)).

      destruct Hget_eq as [cntj [q Hgetj]].

      specialize (H _ _ _ Hgetj).

      assumption.

  Qed.



  Lemma AngelStep_preserve_valid:

    forall U U' tr st tr' st' m m',

      valid (tr, st, m) U ->

      MachStep (U,tr,st) m (schedSkip U,tr',st') m' ->

      valid (tr', st', m') U'.

  Proof.

    intros.

    inversion H0; subst; simpl in *;

      try (exfalso; eapply schedPeek_Skip; now eauto);

      subst.

    - 

      inversion Htstep; subst.

      unfold valid, correct_schedule in *.

      destruct (schedPeek U') eqn:HU'; auto.

      rewrite HschedN in H.

      simpl in *.

      intros j cntj' q' Hget'.

      destruct (Nat.eq_dec tid j); subst.

      + rewrite ThreadPool.gssThreadCC in Hget'.

        discriminate.

      + assert (cntj: ThreadPool.containsThread st j)

          by (eapply ThreadPool.cntUpdateC'; eauto).

        erewrite <- @ThreadPool.gsoThreadCC with (cntj := cntj) in Hget' by eauto.

        specialize (H _ _ _ Hget').

        destruct (Nat.eq_dec tid j); subst;

          simpl in *; exfalso;

            now auto.

    - 

      unfold valid, correct_schedule in *.

      rewrite HschedN in H.

      simpl in *.

      destruct (schedPeek U') eqn:?; auto.

      intros j cntj' q' Hget'.

      destruct (syncstep_equal_run _ _ _ _ _ _ _ _ _ Htstep j) as [? Hrun'].

      destruct (Hrun' ltac:(do 2 eexists; eauto)) as [cntj [q Hget]].

      specialize (H _ _ _ Hget).

      destruct (Nat.eq_dec tid j); subst;

        [|exfalso; simpl in *; now auto].

      eapply @syncstep_not_running with (cntj:= cntj) (q:=q) in Htstep.

      exfalso;

        now auto.

    - unfold valid, correct_schedule in *.

      rewrite HschedN in H.

      simpl in *.

      destruct (schedPeek U'); auto.

      intros j cntj' q' Hget'.

      specialize (H _ _ _ Hget').

      destruct (Nat.eq_dec tid j); subst;

        simpl in *; exfalso; now auto.

  Qed.

  

  Lemma ksafe_csafe_equiv':

    forall st_ m tr,

      (forall n U, valid (tr, st_, m) U -> ksafe_kstep (U, tr, st_) m n) ->

      (forall n U, valid (tr, st_, m) U -> csafe (U, tr, st_) m n).

  Proof.

    intros st m tr HH n U.

    specialize (HH n).

    revert st m tr HH U.

    induction n; intros.

    - econstructor.

    - assert (H':=H).

      eapply HH in H.

      inversion H; subst; simpl in *.

      inversion H1; subst.

      +  econstructor 2; auto.

      +  simpl_state.

        destruct st' as ((?&?)&?); simpl in *; subst.

        

        assert (step_cases:= (step_CoreOrAngel _ _ _ _ H0)); inversion step_cases; subst.

        * eapply CoreSafe; simpl.

          -- eassumption.

          -- eapply IHn.

             unfold ksafe_kstep, cstate2kstate.

             assumption.

             eapply CoreStep_preserve_valid in H0;

               eauto.

        *   simpl_state.

         eapply AngelSafe; simpl.

           -- eassumption.

           -- intros.

              eapply IHn.

              unfold ksafe_kstep, cstate2kstate.

              assumption.

              eapply AngelStep_preserve_valid;

                now eauto.

  Qed.



  Lemma ksafe_csafe_equiv:

    forall tp m tr,

      (forall U, valid (tr, tp, m) U) ->

      (forall n U, ksafe_kstep (U, tr, tp) m n) ->

      (forall n U, csafe (U, tr, tp) m n).



  Proof. intros ? ? ? H ? ? ?. apply ksafe_csafe_equiv'; try apply H.

         auto.

  Qed.



  Lemma valid_unique_running:

    forall tp tr m U U' tid tid',

      schedPeek U = Some tid ->

      schedPeek U' = Some tid' ->

      valid (tr, tp, m) U ->

      valid (tr, tp, m) U' ->

      has_unique_running tp ->

      tid = tid'.

  Proof.

    unfold valid, correct_schedule; simpl.

    intros.

    destruct (schedPeek U); inversion H;

      destruct (schedPeek U'); inversion H0; subst.

    unfold unique_Krun in *.

    inversion H3.

    specialize (H1 _ _ _ H4).

    specialize (H2 _ _ _ H4).

    destruct (Nat.eq_dec tid i), (Nat.eq_dec tid' i);

      subst; auto;

        simpl in *;

        try (exfalso; now auto).

  Qed.



  Lemma csafe_first_tid:

    forall n U U' tr tp m,

      csafe (U, tr, tp) m n ->

      schedPeek U = schedPeek U' -> 

      csafe (U', tr, tp) m n.

  Proof.

    induction n; subst.

    - constructor 1.

    - intros. inversion H; subst.

      + econstructor 2; eauto.

        unfold halted_machine in *; simpl in *.

        destruct (schedPeek U); try solve [inversion H1].

        rewrite <- H0; eauto.

      + econstructor 3; eauto; simpl in *.

        inversion Hstep; simpl in *; subst;

          try match goal with

              | [ H: schedPeek ?U = Some _, H0: schedSkip U = U |- _ ] =>

                apply schedPeek_Skip in H; eauto; inversion H

              end.

        * rewrite <- H6. fold_ids.

          econstructor 1; simpl; eauto.

          rewrite <- H0; eauto.

        * rewrite <- H6. fold_ids. 

          econstructor 2; simpl; eauto.

          rewrite <- H0; eauto.

        * unfold MachStep; simpl. fold_ids.

          econstructor 3; simpl; eauto.

          rewrite <- H0; eauto.

      + econstructor 4; eauto; simpl in *.

        inversion Hstep; simpl in *; subst;

          try match goal with

              | [ H: schedPeek ?U = Some _, H0: ?U = schedSkip ?U |- _ ] =>

                eapply schedPeek_Skip in H; eauto; inversion H

              end.

        * rewrite <- H6; econstructor 4; subst; simpl in *; subst; eauto.

          rewrite <- H0; eauto. 

        * econstructor 5; subst; simpl in *; subst; eauto.

          rewrite <- H0; eauto. 

        * rewrite <- H6; econstructor 6; subst; simpl in *; subst; eauto.

          rewrite <- H0; eauto. 

  
  Qed.

  

  Lemma csafe_unique_running:

    forall U tr tp m n tid,

      schedPeek U = Some tid ->

      has_unique_running tp ->

      valid (tr, tp, m) U ->

      csafe (U, tr, tp) m n ->

      forall U', valid (tr, tp, m) U' ->

            csafe (U', tr, tp) m n.

  Proof.

    intros.

    destruct (schedPeek U') eqn:UU.

    2: econstructor; unfold halted_machine; simpl; try rewrite UU; auto.

    eapply csafe_first_tid; eauto.

    rewrite H, UU; f_equal.

    eapply valid_unique_running; eauto.

  Qed.

  

  Lemma csafe_ksafe_equiv:

    forall st_ m tr,

      (forall n U, valid (tr, st_, m) U -> csafe (U, tr, st_) m n) ->

      (forall n U, valid (tr, st_, m) U -> ksafe_kstep (U, tr, st_) m n).

  Proof.

    intros st m tr HH n U.

    specialize (HH n).

    revert st m tr HH U.

    induction n; intros.

    - econstructor.

    - assert (H':=H).

      eapply HH in H.

      inversion H; subst; simpl in *.

      + 

        econstructor.

        * constructor. simpl_state; auto.

        * eapply IHn; simpl; eauto.

          intros ? H1.

          apply HH in H1.

          eapply csafe_monotone; eauto.

      + 

        econstructor.

        * constructor 2; simpl_state.

          instantiate(1:=( seq.cat tr tr0, tp', m')); simpl.

          eauto.

        * eapply IHn.

          simpl.

          assert (Hsched: exists tid, schedPeek U = Some tid)

            by (inversion Hstep; subst;

                eexists; eauto).

          destruct Hsched.

          eapply csafe_unique_running;

            now eauto using MachStep_preserve_unique, CoreStep_preserve_valid.

      +  

        econstructor.

        * constructor 2; simpl_state.

          instantiate(1:=( seq.cat tr tr0, tp', m')); simpl.

          eauto.

        * eapply IHn.

          eauto.

  Qed.



  Lemma csafe_ksafe_equiv_trick:

    forall st_ m tr,

      (forall U, valid (tr, st_, m) U) ->

      (forall n U, csafe (U, tr, st_) m n) ->

      (forall n U, ksafe_kstep (U, tr, st_) m n).

  Proof.

    intros ? ? ? ? VALID H ?;

    apply csafe_ksafe_equiv; try apply VALID; auto.

  Qed.    



End Csafe_KSafe.



Section Safety_Explicity_Safety.



  Definition explicit_safety (U:schedule)  (tr:event_trace) (st:machine_state) (m:mem): Prop:=

    exp_safety _ _ (fun U stm => is_true (ssrbool.isSome (halted_machine (U, fst(fst stm), snd(fst stm)))))

                   (fun U stm stm' => internal_step U (snd(fst stm)) (snd stm) (snd(fst stm')) (snd stm'))

                   (fun U stm U' stm' => external_step U (fst(fst stm)) (snd(fst stm)) (snd stm) U' (fst(fst stm')) (snd(fst stm')) (snd stm'))

                   (fun U stm => @valid (fst(fst stm),snd(fst stm), snd stm) U) U (tr,st,m).



  Definition explicit_safety_bounded (U:schedule)  (tr:event_trace)(st:machine_state) (m:mem): Prop:=

    exp_safety _ _ (fun U stm => is_true (ssrbool.isSome (halted_machine (U, fst(fst stm), snd(fst stm)))))

                   (fun U stm stm' => internal_step U (snd(fst stm)) (snd stm) (snd(fst stm')) (snd stm'))

                   (fun U stm U' stm' => external_step U (fst(fst stm))  (snd(fst stm)) (snd stm) U' (fst(fst stm')) (snd(fst stm')) (snd stm'))

                   (fun U stm => @valid_bound (fst(fst stm),snd(fst stm), snd stm) U) U (tr,st,m).



  Section TracesIrrelevant.

    

        Lemma kstep_trace_irr: forall U U' tr1 tr1' tr2 tp tp' m m',

            kstep (tr1, tp, m) U (tr1', tp', m') U' -> exists tr2', kstep (tr2, tp, m) U (tr2', tp', m') U'.

        Proof.

          intros. inversion H; simpl in *; subst.

          - exists tr2. 

            constructor; eauto.

          - unfold kstate2cstate in *; simpl in *.

            inversion H0; simpl in *; subst;

              try solve[exists tr2; econstructor 2; econstructor; eauto].

            + exists tr2; econstructor 2. simpl_state; eauto. fold_ids.

              econstructor; eauto.

            + exists (seq.cat tr2

                        (List.map

                           (fun mev : event_semantics.mem_event =>

                              HybridMachineSig.Events.internal tid mev) ev)).

              simpl. econstructor. unfold kstate2cstate; simpl.

              unfold MachStep in *; simpl in *.

              fold_ids.

              auto.

              econstructor; eauto.

            + exists (seq.cat tr2 (HybridMachineSig.Events.external tid ev :: nil)).

              simpl. econstructor. unfold kstate2cstate; simpl.

              unfold MachStep in *; simpl in *.

              econstructor; eauto.

        Qed.

              

        Lemma safe_kstep_trace_irr: forall U tr tr' tp m,

            safe_kstep (U,tr,tp) m -> safe_kstep (U,tr',tp) m.

        Proof.

          unfold safe_kstep; simpl.

          unfold cstate2kstate, kstate2cstate in *; simpl in *.

          cofix foo.

          intros. inversion H.

          destruct st' as ((?&?)&?).

          destruct (kstep_trace_irr _ _ _ _ tr' _ _ _ _ H0) as (tr2' &STEP).

          econstructor; eauto.



        Qed.



            Lemma external_step_trace_irr: forall U U' tr1 tr1' tr2 tp tp' m m',

            external_step U tr1 tp m U' tr1' tp' m' -> exists tr2', external_step U tr2 tp m U' tr2' tp' m'.

        Proof.

          intros. inversion H; simpl in *; subst.

          - exists tr2. fold_ids.

            econstructor; eauto.

          - exists tr2. econstructor 2; eauto.

          - exists tr2. econstructor 3; eauto.

          - exists (seq.cat tr2

           (HybridMachineSig.Events.external tid ev :: nil)).

            econstructor 4; eauto.

          - exists tr2. econstructor 5; eauto.

          

        Qed.

        

        Lemma explicit_safety_trace_irr: forall U tr tr' tp m,

           explicit_safety U tr tp m -> explicit_safety U tr' tp m.

        Proof.

          cofix COFIX.

          intros. inversion H; simpl in *.

          - econstructor; eauto.

          - econstructor 2; eauto.

          - destruct (external_step_trace_irr _ _ _ _ tr' _ _ _ _ H0) as (?&STEP). 

            

            destruct y' as ((y1&y2)&y3); simpl in *.

            econstructor 3; simpl.

            + instantiate(1:= (x, y2, y3)).

              eauto.

            + simpl in *.

              intros. eapply COFIX.

              eapply H1 in H2.

              eapply H2.

        Qed.        

  End TracesIrrelevant.



  Lemma explicit_safety_schedule_irr:

    forall U U' tr tp m,

      schedPeek U = schedPeek U' ->

      explicit_safety U tr tp m -> explicit_safety U' tr tp m.

  Proof.

    cofix COFIX.

    intros. inversion H0; simpl in *.

    - econstructor.

      simpl in *.

      unfold halted_machine in *. simpl in *.

      rewrite <- H.

      assumption.

    - econstructor 2; eauto.

      simpl.

      inversion H1; subst.

      rewrite H in HschedN.

      rewrite <- H7.

      econstructor; eauto.

    - inversion H1;

        try match goal with

            | [H: schedSkip _ = _ |- _] =>

              econstructor 3 with (x' := schedSkip U')

            | [ |- _] =>

              econstructor 3 with (x' := U')

            end; subst;

        try match goal with

            | [H: diluteMem _ = _ |- _] =>

              rewrite <- H; clear H

            end; eauto;

          [econstructor 1 |

           econstructor 2 |

           econstructor 3 |

           |

           econstructor 5 
];

          try (rewrite <- H); eauto.

      rewrite <- H9.

      econstructor 4; try (rewrite <- H); eauto.

  Qed.

  

  Inductive InternalOrExternal: MachState -> mem -> MachState -> mem -> Prop:=

  | IsInternal st st' m m':

      internal_step (fst (fst st)) (snd st) m (snd st') m'  ->

      InternalOrExternal st m st' m'

  | IsExternal st st' m m':

      external_step (fst (fst st)) (snd (fst st)) (snd st) m (fst (fst st')) (snd (fst st')) (snd st') m'  ->

      InternalOrExternal st m st' m'.

      

  Lemma step_InternalOrExternal: forall st m st' m',

      MachStep st m st' m' ->

      InternalOrExternal st m st' m'.

  Proof.

    intros. inversion H;

    destruct st' as ((?&?)&?);

    simpl in *; subst.

    - constructor 2. fold_ids. econstructor; eauto.

    - constructor 2. econstructor 2; eauto.

    - constructor 1. 

      destruct st as ((?&?)&?); simpl in *.

      eapply thread_step' in Htstep; eauto.

    - constructor 2; econstructor 3; eauto.

    - constructor 2; econstructor 4; eauto.

    - constructor 2; econstructor 5; eauto.

   

  Qed.

  

  Lemma safety_equivalence21: forall st m tr,

      (forall U, valid (tr, st, m) U ->

             safe_kstep (U, tr, st) m) ->

      forall U, valid (tr, st, m) U ->

            explicit_safety U tr st m.

  Proof.

    cofix COFIX.

    intros st m tr sns_all U sns.

    eapply sns_all in sns.

    inversion sns.

    unfold cstate2kstate in H; simpl in H.

    inversion H; subst.

    -  unfold kstate2cstate in *; simpl in *; subst.

      eapply halted_safety; simpl; assumption.

    -  destruct st' as [[tr' tp] m'].

      unfold cstate2kstate, kstate2cstate in *; simpl in *; subst.

      assert (step_cases:= (step_InternalOrExternal _ _ _ _ H1)); inversion step_cases; subst.

      +  eapply (internal_safety).

        instantiate (1:=(tr,tp,m')); simpl in *; eauto.

        unfold cstate2kstate, kstate2cstate in *; simpl in *; subst.

        

        intros.

        eapply COFIX; eauto.

        intros.



        unfold safe_kstep, cstate2kstate, kstate2cstate in *; simpl in *; subst.

        eapply safe_kstep_trace_irr.

        

        eapply H0.

        simpl; eauto.

      +   eapply (external_safety).

        instantiate (1:=(tr',tp,m')); simpl in *; eauto.

        unfold cstate2kstate, kstate2cstate in *; simpl in *; subst.

        

        intros.

        eapply COFIX; eauto.

  Qed.



  Lemma safety_equivalence22: forall st m tr,

      (forall U, valid (tr, st, m) U ->

           explicit_safety U tr st m) ->

           (forall U, valid (tr, st, m) U ->

                 safe_kstep (U, tr, st) m).

  Proof.

    cofix COFIX.

    intros st m tr es_all U es.

    eapply es_all in es.

    inversion es.

    - econstructor; eauto.

      + econstructor. simpl; eauto.

      + unfold cstate2kstate; simpl; intros U'' VAL.

        apply COFIX; eauto.

    - eapply step_equivalence2 in H. destruct H as (?&H); simpl in *.

      econstructor.

      + econstructor 2.

        unfold kstate2cstate, cstate2kstate in *; simpl in *.

        instantiate(1:=((seq.cat tr x) , snd(fst y'), snd y')); simpl in *.

        instantiate(1:=U).

        destruct y' as ((?&?)&?).

        eapply H. 

      + intros. destruct y' as ((?&?)&?).

        simpl in *; apply COFIX; intros; eauto.

        eapply H0 in H2. simpl in *.

        eapply explicit_safety_trace_irr.

        eapply H2.

    - eapply step_equivalence3 in H. destruct H as (?&?&STEP); simpl in *.

      destruct y' as ((y1&y2)&y3); simpl in *.

      econstructor.

      + econstructor 2.

        unfold kstate2cstate, cstate2kstate in *; simpl in *.

        instantiate(1:=(y1 , y2, y3)); simpl in *.

        instantiate(1:=x').

        eapply STEP.

      + intros. simpl in *; apply COFIX; intros; eauto.

        eapply H0 in H2. simpl in *.

        eapply explicit_safety_trace_irr.

        eapply H2.

  Qed.

  Lemma safety_equivalence2: forall st m tr,

      (forall U, valid (tr, st, m) U ->

             safe_kstep (U, tr, st) m) <->

      (forall U, valid (tr, st, m) U ->

            explicit_safety U tr st m).

  Proof.

    intros st m tr; split;

           [eapply safety_equivalence21 | apply safety_equivalence22].

  Qed.  

  

End  Safety_Explicity_Safety.



Section Csafe_Safety.



Context (finit_branch_kstep:(forall x : kstate,

        finite_on_x

          (possible_image

             (fun (x0 : kstate) (y : schedule) (x' : kstate) =>

                exists y' : schedule, kstep x0 y x' y') valid x))).



Lemma finite_state_preservation:

  forall P0 P' : SST kstate,

    konig.finite P0 -> SST_step kstate schedule kstep valid P0 P' -> konig.finite P'.

Proof.

  

Admitted.

    

Lemma csafe_safety_trick:

  forall tr tp m,

       (forall U : schedule, valid (tr, tp,m) U) ->

       (forall (n : nat) U, csafe (U, tr, tp) m n) ->

       forall U : schedule, safe kstate schedule kstep valid (tr,tp,m) U.

Proof.

  intros ??????.

  eapply ksafe_safe; eauto.

  - eapply finite_state_preservation.

  - exact classic.

  - eapply csafe_ksafe_equiv_trick; eauto.

Qed.



Lemma csafe_safety:

  forall tr tp m,

       (forall (n : nat) U, valid (tr, tp,m) U -> csafe (U, tr, tp) m n) ->

       forall U : schedule, valid (tr, tp,m) U -> safe kstate schedule kstep valid (tr,tp,m) U.

Proof.

  intros ??????.

  eapply ksafe_safe'; eauto.

  - eapply finite_state_preservation.

  - exact classic.

  - eapply csafe_ksafe_equiv; eauto.

Qed.



Lemma safety_csafe_trick:

  forall tr tp m,

    (forall U : schedule, valid (tr, tp,m) U) ->

    (forall U : schedule, safe kstate schedule kstep valid (tr,tp,m) U) ->

    (forall (n : nat) U, csafe (U, tr, tp) m n).

Proof.

  unfold kstate2cstate; simpl.

  intros ???????.

  eapply ksafe_csafe_equiv; eauto.

  unfold ksafe_kstep.

  simpl_state.

  eapply safe_ksafe; eauto.

Qed.



Lemma safety_csafe:

  forall tr tp m,

    (forall U : schedule, valid (tr, tp,m) U -> safe kstate schedule kstep valid (tr,tp,m) U) ->

    (forall (n : nat) U, valid (tr, tp,m) U -> csafe (U, tr, tp) m n).

Proof.

  unfold kstate2cstate; simpl.

  intros ???????.

  eapply ksafe_csafe_equiv'; eauto.

  unfold ksafe_kstep.

  simpl_state.

  intros.

  eapply safe_ksafe'; eauto.

Qed.



Lemma csafe_explicit_safety:

  forall tr tp m,

       (forall (n : nat) U, valid (tr, tp,m) U -> csafe (U, tr, tp) m n) ->

       forall U, valid (tr, tp,m) U -> explicit_safety U tr tp m.

Proof.

  intros ??????.

  eapply safety_equivalence2; eauto.

  intros.

  eapply csafe_safety; eauto; simpl.

Qed.



Lemma explicit_safety_csafe:

  forall tr tp m,

    (forall U : schedule, valid (tr, tp,m) U -> explicit_safety U tr tp m) ->

    (forall (n : nat) U, valid (tr, tp,m) U -> csafe (U, tr, tp) m n).

Proof.

  intros.

  eapply safety_csafe; eauto.

  intros.

  eapply safety_equivalence22; eauto.

Qed.



Lemma csafe_explicit_safety':

  forall tr tp m,

       (forall U : schedule, valid (tr, tp,m) U) ->

       (forall (n : nat) U, csafe (U, tr, tp) m n) ->

       forall U : schedule, explicit_safety U tr tp m.

Proof.

  intros ??????.

  eapply safety_equivalence2; eauto.

  intros.

  eapply csafe_safety; eauto.

Qed.



Lemma explicit_safety_csafe':

  forall tr tp m,

    (forall U : schedule, valid (tr, tp,m) U) ->

    (forall U : schedule, explicit_safety U tr tp m) ->

    (forall (n : nat) U, csafe (U, tr, tp) m n).

Proof.

  intros.

  eapply safety_csafe_trick; eauto.

  intros.

  eapply safety_equivalence22; eauto.

Qed.



End Csafe_Safety.



End SafetyEquivalence.



