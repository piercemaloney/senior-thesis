Require Import VST.veric.juicy_base.
(* VST.veric.juicy_base:
Require Export VST.veric.base.
Require Export VST.msl.msl_standard.
Require Export VST.veric.rmaps.

Require Export VST.veric.rmaps_lemmas.

Require Export VST.veric.compcert_rmaps.

Export Mem.
Open Scope Z. *)

Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
(* VST.veric.juicy_mem:
Require Import VST.veric.base.
Require Import VST.veric.Memory.
Require Import VST.veric.juicy_base.
Require Import VST.veric.shares.
Import cjoins.

Definition dec_share_nonidentity (sh: Share.t) : {~identity sh}+{identity sh} :=
   (Sumbool.sumbool_not _ _ (dec_share_identity sh)).

Definition perm_of_sh (sh: Share.t): option permission :=
  if writable0_share_dec sh
  then if eq_dec sh Share.top
            then Some Freeable
            else Some Writable
    else if readable_share_dec sh
         then Some Readable
         else if eq_dec sh Share.bot
                   then None
              else Some Nonempty.
Functional Scheme perm_of_sh_ind := Induction for perm_of_sh Sort Prop.

Definition contents_at (m: mem) (loc: address) : memval :=
  ZMap.get (snd loc) (PMap.get (fst loc) (mem_contents m)).

Definition contents_cohere (m: mem) (phi: rmap) :=
  forall rsh sh v loc pp, phi @ loc = YES rsh sh (VAL v) pp -> contents_at m loc = v /\ pp=NoneP.

Definition valshare (r: resource) : share :=
    match r with
      | YES sh rsh _ _ => Share.glb Share.Rsh sh
      | _ => Share.bot
    end.

Definition res_retain' (r: resource) : Share.t :=
 match r with
  | NO sh _ => sh
  | YES sh _ _ _ => Share.glb Share.Lsh sh
  | PURE _ _ => Share.top
 end.

Definition perm_of_res (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh rsh (VAL _) _ => perm_of_sh sh
 | YES sh rsh _ _ => Some Nonempty
 end.

Definition perm_of_res_lock_explicit
             (r : compcert_rmaps.RML.R.resource):=
    match r with
    | compcert_rmaps.RML.R.NO _ _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ => None
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ =>
      if writable0_share_dec (Share.glb Share.Rsh sh)
      then if eq_dec (Share.glb Share.Rsh sh) Share.top then Some Freeable else Some Writable
      else if readable_share_dec (Share.glb Share.Rsh sh) then Some Readable else
             if eq_dec  (Share.glb Share.Rsh sh) Share.bot then None else Some Nonempty
    | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => None
    | compcert_rmaps.RML.R.PURE _ _ => None
    end.
      
  Functional Scheme perm_of_res_lock_expl_ind := Induction for perm_of_res_lock_explicit Sort Prop.

Definition perm_of_res' (r: resource) :=
  
 match r with
 | NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
 | PURE _ _ => Some Nonempty
 | YES sh _ _ _ => perm_of_sh sh
 end.

Definition perm_of_res_lock (r: resource) := 
  
 match r with
 | YES sh rsh (LK _ _) _ => perm_of_sh (Share.glb Share.Rsh sh)
 | _ => None 
 end.

Definition perm_of_res_explicit
               (r : compcert_rmaps.RML.R.resource):=
        match r with
        | compcert_rmaps.RML.R.NO sh _ => if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.VAL _) _ =>
             if writable0_share_dec sh
             then if eq_dec sh Share.top then Some Freeable else Some Writable
             else
               if readable_share_dec sh
               then Some Readable
               else if eq_dec sh Share.bot then None else Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.LK _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.YES sh _ (compcert_rmaps.FUN _ _) _ => Some Nonempty
           | compcert_rmaps.RML.R.PURE _ _ => Some Nonempty
        end.
      
Functional Scheme perm_of_res_expl_ind := Induction for perm_of_res_explicit Sort Prop.

Lemma Rsh_not_top: Share.Rsh <> Share.top.

Lemma nonidentity_Rsh: ~identity Share.Rsh.

Lemma perm_of_sh_fullshare: perm_of_sh fullshare = Some Freeable.

Lemma nonreadable_extern_retainer: ~readable_share extern_retainer.

Lemma Lsh_nonreadable: ~readable_share Share.Lsh.

Lemma perm_of_res_op1:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res r).

Lemma perm_of_res_op2:
  forall r,
    perm_order'' (perm_of_res' r) (perm_of_res_lock r).

Definition access_cohere (m: mem)  (phi: rmap) :=
  forall loc,  access_at m loc Cur = perm_of_res (phi @ loc).

Definition max_access_at m loc := access_at m loc Max.

Definition max_access_cohere (m: mem) (phi: rmap)  :=
  forall loc,
    perm_order'' (max_access_at m loc) (perm_of_res' (phi @ loc)).

Definition alloc_cohere (m: mem) (phi: rmap) :=
 forall loc,  (fst loc >= nextblock m)%positive -> phi @ loc = NO Share.bot bot_unreadable.

Inductive juicy_mem: Type :=
  mkJuicyMem: forall (m: mem) (phi: rmap)
    (JMcontents: contents_cohere m phi)
    (JMaccess: access_cohere m phi)
    (JMmax_access: max_access_cohere m phi)
    (JMalloc: alloc_cohere m phi),
       juicy_mem.

Section selectors.
Variable (j: juicy_mem).
Definition m_dry := match j with mkJuicyMem m _ _ _ _ _ => m end.
Definition m_phi := match j with mkJuicyMem _ phi _ _ _ _ => phi end.
Lemma juicy_mem_contents: contents_cohere m_dry m_phi.
Lemma juicy_mem_access: access_cohere m_dry m_phi.
Lemma juicy_mem_max_access: max_access_cohere m_dry m_phi.
Lemma juicy_mem_alloc_cohere: alloc_cohere m_dry m_phi.
End selectors.

Definition juicy_mem_resource: forall jm m', resource_at m' = resource_at (m_phi jm) ->
  {jm' | m_phi jm' = m' /\ m_dry jm' = m_dry jm}.

Lemma perm_of_empty_inv {s} : perm_of_sh s = None -> s = Share.bot.

Lemma writable_join_sub: forall loc phi1 phi2,
  join_sub phi1 phi2 -> writable loc phi1 -> writable loc phi2.

Lemma writable_inv: forall phi loc, writable loc phi ->
  exists sh, exists rsh, exists k, exists pp, 
       phi @ loc = YES sh rsh k pp /\ 
       writable0_share sh /\
       isVAL k.

Lemma nreadable_inv: forall phi loc, ~readable loc phi 
  -> (exists sh, exists nsh, phi @ loc = NO sh nsh)
   \/ (exists sh, exists rsh, exists k, exists pp, phi @ loc = YES sh rsh k pp /\ ~isVAL k)
   \/ (exists k, exists pp, phi @ loc = PURE k pp).

Lemma age1_joinx {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall phi1 phi2 phi3 phi1' phi2' phi3',
             age phi1 phi1' -> age phi2 phi2' -> age phi3 phi3' ->
             join phi1 phi2 phi3 -> join phi1' phi2' phi3'.

Lemma constructive_age1_join  {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} : forall x y z x' : A,
       join x y z ->
       age x x' ->
       { yz' : A*A | join x' (fst yz') (snd yz') /\ age y (fst yz') /\ age z (snd yz')}.

Lemma age1_constructive_joins_eq : forall {A}  {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A}  {phi1 phi2},
  constructive_joins phi1 phi2
  -> forall {phi1'}, age1 phi1 = Some phi1'
  -> forall {phi2'}, age1 phi2 = Some phi2'
  -> constructive_joins phi1' phi2'.

Program Definition age1_juicy_mem (j: juicy_mem): option juicy_mem :=
      match age1 (m_phi j) with
        | Some phi' => Some (mkJuicyMem (m_dry j) phi' _ _ _ _)
        | None => None
      end.

Lemma age1_juicy_mem_unpack: forall j j',
  age1_juicy_mem j = Some j' ->
  age (m_phi j)  (m_phi j')
  /\ m_dry j = m_dry j'.

Lemma age1_juicy_mem_unpack': forall j j',
  age (m_phi j)  (m_phi j')  /\ m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma age1_juicy_mem_unpack'': forall j j',
  age (m_phi j)  (m_phi j')  -> m_dry j = m_dry j' ->
  age1_juicy_mem j = Some j'.

Lemma rmap_join_eq_level: forall phi1 phi2: rmap, joins phi1 phi2 -> level phi1 = level phi2.

Lemma rmap_join_sub_eq_level: forall phi1 phi2: rmap,
          join_sub phi1 phi2 -> level phi1 = level phi2.

Lemma age1_juicy_mem_None1:
  forall j, age1_juicy_mem j = None -> age1 (m_phi j) = None.

Lemma age1_juicy_mem_None2:
  forall j, age1 (m_phi j) = None -> age1_juicy_mem j = None.

Lemma age1_juicy_mem_Some:
  forall j j', age1_juicy_mem j = Some j' -> age1 (m_phi j) = Some (m_phi j').

Lemma unage_juicy_mem: forall j' : juicy_mem,
   exists j : juicy_mem, age1_juicy_mem j = Some j'.

Lemma level1_juicy_mem: forall j: juicy_mem,
  age1_juicy_mem j = None <-> level (m_phi j) = 0%nat.

Lemma level2_juicy_mem: forall j1 j2: juicy_mem,
   age1_juicy_mem j1 = Some j2 -> level (m_phi j1) = S (level (m_phi j2)).

Lemma juicy_mem_ageable_facts: ageable_facts juicy_mem (fun j => level (m_phi j)) age1_juicy_mem.

Instance juicy_mem_ageable: ageable juicy_mem :=
  mkAgeable _ (fun j => level (m_phi j)) age1_juicy_mem juicy_mem_ageable_facts.

Lemma level_juice_level_phi: forall (j: juicy_mem), level j = level (m_phi j).

Lemma juicy_mem_ext: forall j1 j2,
       m_dry j1 = m_dry j2  ->
       m_phi j1 = m_phi j2 ->
       j1=j2.

Lemma unage_writable: forall (phi phi': rmap) loc,
  age phi phi' -> writable loc phi' -> writable loc phi.

Lemma unage_readable: forall (phi phi': rmap) loc,
  age phi phi' -> readable loc phi' -> readable loc phi.

Lemma readable_inv: forall phi loc, readable loc phi ->
  exists rsh, exists sh, exists v, exists pp, phi @ loc = YES rsh sh (VAL v) pp.

Definition fmap_option {A B} (v: option A) (m: B) (f: A -> B): B :=
  match v with
    | None => m
    | Some v' => f v'
  end.

Lemma resource_at_make_rmap: forall f g lev H Hg, resource_at (proj1_sig (make_rmap f g lev H Hg)) = f.

Lemma resource_at_remake_rmap: forall f g lev H Hg, resource_at (proj1_sig (remake_rmap f g lev H Hg)) = f.

Lemma ghost_of_make_rmap: forall f g lev H Hg, ghost_of (proj1_sig (make_rmap f g lev H Hg)) = g.

Lemma ghost_of_remake_rmap: forall f g lev H Hg, ghost_of (proj1_sig (remake_rmap f g lev H Hg)) = g.

Lemma level_make_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (make_rmap f g lev H Hg)) = lev.

Lemma level_remake_rmap: forall f g lev H Hg, @level rmap _ (proj1_sig (remake_rmap f g lev H Hg)) = lev.

Section inflate.
Variables (m: mem) (phi: rmap).

Definition inflate_initial_mem' (w: rmap) (loc: address) :=
   match access_at m loc Cur with
           | Some Freeable => YES Share.top readable_share_top (VAL (contents_at m loc)) NoneP
           | Some Writable => YES Ews (writable_readable writable_Ews) (VAL (contents_at m loc)) NoneP
           | Some Readable => YES Ers readable_Ers (VAL (contents_at m loc)) NoneP
           | Some Nonempty => 
                         match w @ loc with PURE _ _ => w @ loc | _ => NO _ nonreadable_extern_retainer end
           | None =>  NO Share.bot bot_unreadable
         end.

Lemma inflate_initial_mem'_fmap:
 forall w, resource_fmap (approx (level w)) (approx (level w)) oo inflate_initial_mem' w =
                inflate_initial_mem' w.

Definition inflate_initial_mem (w: rmap): rmap :=
    proj1_sig (make_rmap (inflate_initial_mem' w) (ghost_of w) _
            (inflate_initial_mem'_fmap w) (ghost_of_approx w)).

Lemma inflate_initial_mem_level: forall w, level (inflate_initial_mem w) = level w.

Definition all_VALs (phi: rmap) :=
  forall l, match phi @ l with
              | YES _ _ k _ => isVAL k
              | _ => True
            end.

Lemma inflate_initial_mem_all_VALs: forall lev, all_VALs (inflate_initial_mem lev).

Definition inflate_alloc: rmap.

Lemma approx_map_idem: forall n (lp: preds),
  preds_fmap (approx n) (approx n) (preds_fmap (approx n) (approx n) lp) =
  preds_fmap (approx n) (approx n) lp.

Definition inflate_store: rmap. refine (

End inflate.

Lemma adr_inv0: forall (b b': block) (ofs ofs': Z) (sz: Z),
  ~ adr_range (b, ofs) sz (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + sz.

Lemma adr_inv: forall (b b': block) (ofs ofs': Z) ch,
  ~ adr_range (b, ofs) (size_chunk ch) (b', ofs') ->
  b <> b' \/ ~ ofs <= ofs' < ofs + size_chunk ch.

Lemma range_inv0: forall ofs ofs' sz,
  ~ ofs <= ofs' < ofs + sz ->
  ofs' < ofs \/ ofs' >= ofs + sz.

Lemma range_inv: forall ofs ofs' ch,
  ~ ofs <= ofs' < ofs + size_chunk ch ->
  ofs' < ofs \/ ofs' >= ofs + size_chunk ch.

Lemma perm_of_sh_Freeable_top: forall sh, perm_of_sh sh = Some Freeable -> 
     sh = Share.top.

Lemma nextblock_access_empty: forall m b ofs k, (b >= nextblock m)%positive
  -> access_at m (b, ofs) k = None.

Section initial_mem.
Variables (m: mem) (w: rmap).

Definition initial_rmap_ok := 
   forall loc, ((fst loc >= nextblock m)%positive -> core w @ loc = NO Share.bot bot_unreadable) /\
                   (match w @ loc with 
                    | PURE _ _ => (fst loc < nextblock m)%positive /\ 
                                           access_at m loc Cur = Some Nonempty /\  
                                            max_access_at m loc = Some Nonempty 
                    | _ => True end).
Hypothesis IOK: initial_rmap_ok.
End initial_mem.

Definition empty_retainer (loc: address) := Share.bot.

Lemma perm_of_freeable: perm_of_sh Share.top = Some Freeable.

Lemma perm_of_writable: 
   forall sh, writable_share sh -> sh <> Share.top -> perm_of_sh sh = Some Writable.

Lemma perm_of_readable:
  forall sh (rsh: readable_share sh), ~writable0_share sh -> perm_of_sh sh = Some Readable.

Lemma perm_of_nonempty:
  forall sh, sh <> Share.bot -> ~readable_share sh -> perm_of_sh sh = Some Nonempty.

Lemma perm_of_empty:
    perm_of_sh Share.bot = None.

Lemma perm_of_Ews: perm_of_sh Ews = Some Writable.

Lemma perm_of_Ers: perm_of_sh Ers = Some Readable.

Lemma extern_retainer_neq_bot: extern_retainer <> Share.bot.

Lemma perm_order''_trans: forall a b c, Mem.perm_order'' a b ->  Mem.perm_order'' b c ->

Definition initial_mem (m: mem) lev (IOK: initial_rmap_ok m lev) : juicy_mem.

Definition juicy_mem_level (j: juicy_mem) (lev: nat) :=
  level (m_phi j) = lev.

Lemma initial_mem_level: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_level j (level lev).

Lemma initial_mem_all_VALs: forall lev m j IOK, j = initial_mem m lev IOK
  -> all_VALs (m_phi j).

Lemma perm_mem_access: forall m b ofs p,
  perm m b ofs Cur p ->
  exists p', (perm_order p' p /\ access_at m (b, ofs) Cur = Some p').

Section store.
Variables (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m').

Lemma store_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (size_chunk ch) loc'
  -> (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP -> contents_at m' loc' = mv.

Definition store_juicy_mem: juicy_mem.

End store.

Section storebytes.
Variables (jm: juicy_mem) (m': mem) (b: block) (ofs: Z) (bytes: list memval)
  (STOREBYTES: storebytes (m_dry jm) b ofs bytes = Some m').

Lemma storebytes_phi_elsewhere_eq: forall rsh sh mv loc',
  ~ adr_range (b, ofs) (Zlength bytes) loc' ->
  (m_phi jm) @ loc' = YES rsh sh (VAL mv) NoneP ->
  contents_at m' loc' = mv.

Definition storebytes_juicy_mem: juicy_mem.

End storebytes.

Lemma free_smaller_None : forall m b b' ofs lo hi m',
  access_at m (b, ofs) Cur = None
  -> free m b' lo hi = Some m'
  -> access_at m' (b, ofs) Cur = None.

Lemma free_nadr_range_eq : forall m b b' ofs' lo hi m',
  ~ adr_range (b, lo) (hi - lo) (b', ofs')
  -> free m b lo hi = Some m'
  -> access_at m (b', ofs') = access_at m' (b', ofs')
  /\  contents_at m (b', ofs') = contents_at m' (b', ofs').

Section free.
Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable).

Definition inflate_free: rmap. refine (

Definition free_juicy_mem: juicy_mem.

End free.

Lemma free_not_freeable_eq : forall m b lo hi m' b' ofs',
  free m b lo hi = Some m'
  -> access_at m (b', ofs') Cur <> Some Freeable
  -> access_at m (b', ofs') Cur = access_at m' (b', ofs') Cur.

Definition after_alloc' 
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else phi @ loc.

Lemma adr_range_eq_block : forall b ofs n b' ofs',
  adr_range (b,ofs) n (b',ofs') ->
  b=b'.

Lemma after_alloc'_ok : forall lo hi b phi H,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (after_alloc' lo hi b phi H)
  = after_alloc' lo hi b phi H.

Definition after_alloc
  (lo hi: Z) (b: block) (phi: rmap)(H: forall ofs, phi @ (b,ofs) = NO Share.bot bot_unreadable) : rmap :=
  proj1_sig (make_rmap (after_alloc' lo hi b phi H) (ghost_of phi)
    (level phi)
    (after_alloc'_ok lo hi b phi H) (ghost_of_approx phi)).

Definition mod_after_alloc' (phi: rmap) (lo hi: Z) (b: block)
  : address -> resource := fun loc =>
    if adr_range_dec (b,lo) (hi-lo) loc 
      then YES Share.top readable_share_top (VAL Undef) NoneP
      else core phi @ loc.

Lemma mod_after_alloc'_ok : forall phi lo hi b,
  resource_fmap (approx (level phi)) (approx (level phi)) oo (mod_after_alloc'  phi lo hi b)
  = mod_after_alloc' phi lo hi b.

Definition mod_after_alloc (phi: rmap) (lo hi: Z) (b: block) :=
  proj1_sig (make_rmap (mod_after_alloc' phi lo hi b) (ghost_of phi)
    _
    (mod_after_alloc'_ok phi lo hi b) (ghost_of_approx phi)).

Transparent alloc.

Lemma adr_range_inv: forall loc loc' n,
  ~ adr_range loc n loc' ->
  fst loc <> fst loc' \/ (fst loc=fst loc' /\ ~snd loc <= snd loc' < snd loc + n).

Lemma dry_noperm_juicy_nonreadable : forall m loc,
  access_at (m_dry m) loc Cur = None ->   ~readable loc (m_phi m).

Lemma fullempty_after_alloc : forall m1 m2 lo n b ofs,
  alloc m1 lo n = (m2, b) ->
  access_at m2 (b, ofs) Cur = None \/ access_at m2 (b, ofs) Cur = Some Freeable.

Lemma alloc_dry_unchanged_on : forall m1 m2 loc lo hi b0,
  alloc m1 lo hi = (m2, b0) ->
  ~adr_range (b0,lo) (hi-lo) loc ->
  access_at m1 loc = access_at m2 loc /\
  (access_at m1 loc Cur <> None -> contents_at m1 loc= contents_at m2 loc).

Lemma adr_range_zle_fact : forall b lo hi loc,
  adr_range (b,lo) (hi-lo) loc ->
  zle lo (snd loc) && zlt (snd loc) hi = true.

Lemma alloc_dry_updated_on : forall m1 m2 lo hi b loc,
  alloc m1 lo hi = (m2, b) ->
  adr_range (b, lo) (hi - lo) loc ->
  access_at m2 loc Cur=Some Freeable /\
  contents_at m2 loc=Undef.

Definition resource_decay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
 forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = 
                       YES sh (writable0_readable wsh) (VAL v) NoneP /\ 
       phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)
  \/ ((fst l >= nextb)%positive /\ exists v, phi2 @ l = YES Share.top readable_share_top (VAL v) NoneP)
  \/ (exists v, exists pp, phi1 @ l = YES Share.top readable_share_top (VAL v) pp 
                        /\ phi2 @ l = NO Share.bot bot_unreadable)).

Definition resource_nodecay (nextb: block) (phi1 phi2: rmap) :=
  (level phi1 >= level phi2)%nat /\
  forall l: address,
  ((fst l >= nextb)%positive -> phi1 @ l = NO Share.bot bot_unreadable) /\
  (resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = (phi2 @ l) \/
  (exists sh, exists (wsh: writable0_share sh), exists v, exists v',
       resource_fmap (approx (level phi2)) (approx (level phi2)) (phi1 @ l) = YES sh (writable0_readable wsh) (VAL v) NoneP
      /\ phi2 @ l = YES sh (writable0_readable wsh) (VAL v') NoneP)).

Lemma resource_nodecay_decay:
   forall b phi1 phi2, resource_nodecay b phi1 phi2 -> resource_decay b phi1 phi2.

Lemma resource_decay_refl: forall b phi, 
  (forall l, (fst l >= b)%positive -> phi @ l = NO Share.bot bot_unreadable) ->

Lemma resource_decay_trans: forall b b' m1 m2 m3,
  (b <= b')%positive ->
  resource_decay b m1 m2 -> resource_decay b' m2 m3 -> resource_decay b m1 m3.

Lemma level_store_juicy_mem:
 forall jm m ch b i v H, level (store_juicy_mem jm m ch b i v H) = level jm.

Lemma level_storebytes_juicy_mem:
 forall jm m b i bytes H, level (storebytes_juicy_mem jm m b i bytes H) = level jm.

Lemma inflate_store_resource_nodecay:
  forall (jm: juicy_mem) (m': mem)
          (ch: memory_chunk) (b: block) (ofs: Z) (v: val)
          (STORE: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable))
          phi',
  inflate_store m' (m_phi jm) = phi' -> resource_nodecay (nextblock (m_dry jm)) (m_phi jm) phi'.

Lemma inflate_free_resource_decay:
 forall (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs : Z,
             lo <= ofs < hi -> perm_of_res (m_phi jm @ (b, ofs)) = Some Freeable),
   resource_decay (nextblock (m_dry jm)) (m_phi jm) (inflate_free jm b lo hi).

Lemma juicy_store_nodecay:
  forall jm m' ch b ofs v
       (H: store ch (m_dry jm) b ofs v = Some m')
          (PERM: forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi jm @ (b,z))) (Some Writable)),
       resource_nodecay (nextblock (m_dry jm)) (m_phi jm) (m_phi (store_juicy_mem jm _ _ _ _ _ H)).

Lemma can_age1_juicy_mem: forall j r,
  age (m_phi j) r -> exists j', age1 j = Some j'.

Lemma can_age_jm:
  forall jm, age1 (m_phi jm) <> None -> exists jm', age jm jm'.

Lemma age_jm_dry: forall {jm jm'}, age jm jm' -> m_dry jm = m_dry jm'.

Lemma age_jm_phi: forall {jm jm'}, age jm jm' -> age (m_phi jm) (m_phi jm').

Lemma age1_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma age1_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi = Some phi' ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma age1_PURE_2 {phi phi' l k P} :
  age1 phi = Some phi' ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma perm_of_res_age x y loc :
  age x y -> perm_of_res (x @ loc) = perm_of_res (y @ loc).

Lemma contents_cohere_age m : hereditary age (contents_cohere m).

Lemma access_cohere_age m : hereditary age (access_cohere m).

Lemma max_access_cohere_age m : hereditary age (max_access_cohere m).

Lemma alloc_cohere_age m : hereditary age (alloc_cohere m).

Definition unage {A} {_:ageable A} x y := age y x.

Lemma unage_YES'_1 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi @ l = YES rsh sh k P ->
  (exists P, phi' @ l = YES rsh sh k P).

Lemma unage_YES'_2 {phi phi' l rsh sh k P} :
  age1 phi' = Some phi ->
  phi' @ l = YES rsh sh k P ->
  (exists P, phi @ l = YES rsh sh k P).

Lemma unage_PURE_2 {phi phi' l k P} :
  age1 phi' = Some phi ->
  phi' @ l = PURE k P ->
  (exists P, phi @ l = PURE k P).

Lemma contents_cohere_unage m : hereditary unage (contents_cohere m).

Lemma access_cohere_unage m : hereditary unage (access_cohere m).

Lemma max_access_cohere_unage m : hereditary unage (max_access_cohere m).

Lemma alloc_cohere_unage m : hereditary unage (alloc_cohere m).

Lemma juicy_mem_unage jm' : { jm | age jm jm' }. *)
(* VST.veric.juicy_mem_lemmas:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.res_predicates.
Require Import VST.veric.shares.

Definition juicy_mem_core (j: juicy_mem) : rmap := core (m_phi j).

Definition no_VALs (phi: rmap) := forall loc,
  match phi @ loc with
    | YES _ _ (VAL _) _ => False | _ => True
  end.

Lemma components_join_joins {A} {JA: Join A}{PA: Perm_alg A}{TA: Trip_alg A}: forall a b c d,
   join a b c -> joins a d -> joins b d -> joins c d.

Lemma contents_cohere_join_sub: forall m phi phi',
  contents_cohere m phi -> join_sub phi' phi -> contents_cohere m phi'.

Lemma perm_of_sh_join_sub: forall (sh1 sh2: Share.t) p,

Lemma perm_order'_trans: forall p1 p2 p3,
  perm_order' (Some p1) p2 -> perm_order' (Some p2) p3 -> perm_order' (Some p1) p3.

Lemma rmap_unage_YES: forall phi phi' sh rsh k pp loc, 
  age phi phi' 
  -> phi' @ loc = YES sh rsh k pp 
  -> exists pp', phi @ loc = YES sh rsh k pp'.

Lemma preds_fmap_NoneP_approx: forall pp lev1 lev2,
  preds_fmap (approx lev1) (approx lev1) pp = NoneP ->
  preds_fmap (approx lev2) (approx lev2) pp = NoneP.
Proof.
intros.
destruct pp.
unfold NoneP, approx, compose in *.
simpl in *. unfold compose in *.
inv H. simpl in *.
apply EqdepFacts.eq_sigT_eq_dep in H2.

Lemma oracle_unage:
  forall (jm': juicy_mem) (w: rmap), age w (m_phi jm') ->
       exists jm, age jm jm' /\ m_phi jm = w.

Lemma writable_perm:
  forall b i jm, writable (b,i) (m_phi jm) -> Mem.perm (m_dry jm) b i Cur Writable.

Lemma valid_access_None: forall m ch b b' ofs ofs' p,
  Mem.valid_access m ch b ofs p

Lemma core_load_getN: forall ch v b ofs bl phi m,
  contents_cohere m phi
  -> (core_load' ch (b, ofs) v bl)%pred phi
  -> bl = Mem.getN (size_chunk_nat ch) ofs (PMap.get b (Mem.mem_contents m)).

Lemma core_load_valid: forall ch v b ofs m phi,
  (core_load ch (b, ofs) v)%pred phi
  -> access_cohere m phi
  -> Mem.valid_access m ch b ofs Readable.

Lemma core_load_load': forall ch b ofs v m,
  core_load ch (b, ofs) v (m_phi m) -> Mem.load ch (m_dry m) b ofs = Some v.

Lemma Zminus_lem: forall z1 z2, z1 <= z2 -> nat_of_Z (z2 - z1) = O -> z1=z2.

Lemma nat_of_Z_lem1: forall n z, S n = nat_of_Z z -> n = nat_of_Z (z - 1).

Lemma nat_of_Z_lem2: forall n z1 z2, S n = nat_of_Z (z1 - z2) -> n = nat_of_Z (z1 - z2 - 1).

Lemma nth_getN: forall m b ofs ofs' z,
  ofs <= ofs' < ofs + z
  -> z >= 0
  -> contents_at m (b, ofs')
  = nth (nat_of_Z (ofs' - ofs)) (Mem.getN (nat_of_Z z) ofs (PMap.get b (Mem.mem_contents m))) Undef.

Lemma load_core_load: forall ch b ofs v m,
  Mem.load ch (m_dry m) b ofs = Some v ->

Lemma core_load_load: forall ch b ofs v m,
  (forall z, ofs <= z < ofs + size_chunk ch ->
                      perm_order'' (perm_of_res (m_phi m @ (b,z))) (Some Readable)) ->
  (core_load ch (b, ofs) v (m_phi m) <-> Mem.load ch (m_dry m) b ofs = Some v).

Lemma mapsto_valid_access: forall ch v sh b ofs jm,
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> Mem.valid_access (m_dry jm) ch b ofs Readable.

Lemma mapsto_valid_access_wr: forall ch v sh (wsh: writable0_share sh) b ofs jm,
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> Mem.valid_access (m_dry jm) ch b ofs Writable.

Program Definition mapsto_can_store_definition ch v sh (wsh: writable0_share sh) b ofs jm (v':val)
  (MAPSTO: (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)):
  Memory.mem. 

Lemma mapsto_can_store_property: forall (ch:memory_chunk) v sh (wsh: writable0_share sh) b ofs jm v'
  (MAPSTO: (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)),
  Mem.store ch (m_dry jm) b ofs v' = 

Lemma mapsto_can_store: forall ch v sh (wsh: writable0_share sh) b ofs jm v',
  (address_mapsto ch v sh (b, ofs) * TT)%pred (m_phi jm)
  -> exists m', Mem.store ch (m_dry jm) b ofs v' = Some m'.

Lemma store_outside':
   forall ch m b z v m',
          Mem.store ch m b z v = Some m' ->

Lemma adr_range_zle_zlt : forall  b lo hi ofs,
  adr_range (b,lo) (hi-lo) (b,ofs)
  -> zle lo ofs && zlt ofs hi = true.

Lemma join_top: forall sh2 sh, join Share.top sh2 sh -> sh = Share.top.

Lemma juicy_free_aux_lemma:
 forall phi b lo hi F,
 app_pred (VALspec_range (hi-lo) Share.top (b,lo) * F) phi ->

Lemma juicy_free_lemma:
  forall {j b lo hi m' m1 F}
    (H: Mem.free (m_dry j) b lo hi = Some m')

Section free.

Variables (jm :juicy_mem) (m': mem)
          (b: block) (lo hi: Z)
          (FREE: free (m_dry jm) b lo hi = Some m')
          (PERM: forall ofs, lo <= ofs < hi ->
                      perm_of_res (m_phi jm @ (b,ofs)) = Some Freeable)
          (phi1 phi2 : rmap) (Hphi1: VALspec_range (hi-lo) Share.top (b,lo) phi1)
          (Hjoin : join phi1 phi2 (m_phi jm)).

Lemma phi2_eq : m_phi (free_juicy_mem _ _ _ _ _ FREE) = phi2.

End free.

Lemma juicy_free_lemma':
  forall {j b lo hi m' m1 m2 F}
    (H: Mem.free (m_dry j) b lo hi = Some m')

Lemma initial_mem_core: forall lev m j IOK,
  j = initial_mem m lev IOK -> juicy_mem_core j = core lev.

Lemma writable_writable_after_alloc' : forall m1 m2 lo hi b lev loc IOK1 IOK2,
  alloc m1 lo hi = (m2, b) ->
  writable loc (m_phi (initial_mem m1 lev IOK1)) ->
  writable loc (m_phi (initial_mem m2 lev IOK2)).

Lemma readable_eq_after_alloc' : forall m1 m2 lo hi b lev loc IOK1 IOK2,
  alloc m1 lo hi = (m2, b) ->
  readable loc (m_phi (initial_mem m1 lev IOK1)) ->
  m_phi (initial_mem m1 lev IOK1) @ loc=m_phi (initial_mem m2 lev IOK2) @ loc.

Lemma necR_m_dry:
  forall jm jm', necR jm jm' -> m_dry jm = m_dry jm'.

Lemma perm_order''_trans p1 p2 p3 :
  perm_order'' p1 p2 ->
  perm_order'' p2 p3 ->
  perm_order'' p1 p3.

Lemma po_join_sub_sh sh1 sh2 :
  join_sub sh2 sh1 ->
  Mem.perm_order'' (perm_of_sh sh1) (perm_of_sh sh2).

Lemma po_join_sub r1 r2 :
  join_sub r2 r1 ->
  Mem.perm_order'' (perm_of_res r1) (perm_of_res r2).

Lemma perm_of_res_lock_not_Freeable:
  forall r,
    perm_order'' (Some Writable) (perm_of_res_lock r).

Definition readable_perm (p: option permission) :
  {perm_order'' p (Some Readable)}+{~perm_order'' p (Some Readable)}.

Definition rebuild_juicy_mem_fmap (jm: juicy_mem) (m': mem) : (AV.address -> resource) :=
 fun loc =>
   match m_phi jm @ loc with
    PURE k pp => PURE k pp
   | NO sh rsh => if readable_perm (access_at m' loc Cur)
                            then YES Tsh (writable_readable writable_share_top)
                                        (VAL (contents_at m' loc)) NoneP
                            else NO sh rsh 
   | YES sh rsh (VAL _) _ => 
                 if readable_perm (access_at m' loc Cur)
                 then YES sh rsh (VAL (contents_at m' loc)) NoneP
                 else NO _ bot_unreadable
   | YES sh rsh _ _ => m_phi jm @ loc
end.

Definition rebuild_juicy_mem_rmap (jm: juicy_mem) (m': mem) :
  {phi : rmap |
  level phi = level jm /\
  resource_at phi = rebuild_juicy_mem_fmap jm m' /\
  ghost_of phi = ghost_of (m_phi jm)}. *)
(* VST.veric.juicy_mem_ops:
Require Import VST.veric.juicy_base.
Import cjoins.
Require Import VST.veric.juicy_mem.
Require Import VST.veric.juicy_mem_lemmas.
Require Import VST.veric.shares.

Module Type JUICY_MEM_OPS.
Parameter juicy_mem_store
  : juicy_mem -> memory_chunk -> block -> Z -> val -> option juicy_mem.

Parameter juicy_mem_storebytes
  : juicy_mem -> block -> Z -> list memval -> option juicy_mem.

Parameter juicy_mem_alloc
  : juicy_mem -> Z -> Z -> juicy_mem * block.

Axiom juicy_mem_store_succeeds: forall j j' ch b ofs v,
  juicy_mem_store j ch b ofs v = Some j'
  -> exists m', store ch (m_dry j) b ofs v = Some m' /\ m' = m_dry j'.
Axiom juicy_mem_alloc_succeeds: forall j j' b lo hi,
  juicy_mem_alloc j lo hi = (j', b) -> (m_dry j', b) = alloc (m_dry j) lo hi.

End JUICY_MEM_OPS.

Obligation Tactic := Tactics.program_simpl.

Module JuicyMemOps <: JUICY_MEM_OPS.
Program Definition juicy_mem_store j ch b ofs v: option juicy_mem :=
  if valid_access_dec (m_dry j) ch b ofs Writable
    then Some (store_juicy_mem j _ ch b ofs v _)
    else None.

Lemma juicy_mem_store_succeeds: forall j j' ch b ofs v,
  juicy_mem_store j ch b ofs v = Some j'
  -> exists m', store ch (m_dry j) b ofs v = Some m' /\ m' = m_dry j'.

Program Definition juicy_mem_storebytes j b ofs bytes: option juicy_mem :=
  if range_perm_dec (m_dry j) b ofs (ofs + Z_of_nat (length bytes)) Cur Writable
    then Some (storebytes_juicy_mem j _ b ofs bytes _)
    else None.

Lemma juicy_mem_storebytes_succeeds: forall j j' b ofs bytes,
  juicy_mem_storebytes j b ofs bytes = Some j' ->
  exists m', storebytes (m_dry j) b ofs bytes = Some m' /\ m' = m_dry j'.

Lemma pshare_sh_bot: forall p, pshare_sh p = Share.bot -> False.

Lemma juicy_mem_alloc_aux1:
  forall jm lo hi m' b, alloc (m_dry jm) lo hi = (m',b) ->
        forall ofs, m_phi jm @ (b,ofs) = NO Share.bot bot_unreadable.

Lemma after_alloc_contents_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
  contents_cohere m'
    (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_access_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 access_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_max_access_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 max_access_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Lemma after_alloc_alloc_cohere:
 forall jm lo hi m' b (H : alloc (m_dry jm) lo hi = (m', b)),
 alloc_cohere m'
  (after_alloc lo hi b (m_phi jm) (juicy_mem_alloc_aux1 jm lo hi m' b H)).

Definition juicy_mem_alloc (jm: juicy_mem) (lo hi: Z) : juicy_mem * block :=
         (mkJuicyMem (fst (alloc (m_dry jm) lo hi))
                     (after_alloc lo hi (snd (alloc (m_dry jm) lo hi)) (m_phi jm)
                            (juicy_mem_alloc_aux1 _ _ _ _ _ (eq_refl _)))
                     (after_alloc_contents_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_access_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_max_access_cohere _ _ _ _ _ (eq_refl _))
                     (after_alloc_alloc_cohere _ _ _ _ _ (eq_refl _)),
           snd (alloc (m_dry jm) lo hi)).

Lemma juicy_mem_alloc_at:
  forall jm lo hi jm' b,
     juicy_mem_alloc jm lo hi = (jm',b) ->
     forall loc, m_phi jm' @ loc =
       if adr_range_dec (b, lo) (hi - lo) loc
       then YES Share.top readable_share_top (VAL Undef) NoneP

Lemma juicy_mem_alloc_level:
 forall jm lo hi jm' b,
   juicy_mem_alloc jm lo hi = (jm', b) -> level jm = level jm'.

Lemma juicy_mem_alloc_succeeds: forall j j' b lo hi,
  juicy_mem_alloc j lo hi = (j', b) -> (m_dry j', b) = alloc (m_dry j) lo hi.

End JuicyMemOps.

Module Abs := JuicyMemOps.
Require Import VST.veric.local.

Inductive AbsPrimcom : relation juicy_mem -> Prop :=
| AbsPrimcom_store : forall ch b ofs v,
  AbsPrimcom (fun j j' => Abs.juicy_mem_store j ch b ofs v = Some j')
| AbsPrimcom_alloc : forall lo hi,
  AbsPrimcom (fun j j' => fst (Abs.juicy_mem_alloc j lo hi) = j')
.
Inductive AbsPrimexpr : pfunc juicy_mem val -> Prop :=.

Instance abstract : GenericSemantics juicy_mem AbsPrimcom AbsPrimexpr := {}.

Inductive ConcPrimcom : relation mem -> Prop :=
| ConcPrimcom_store : forall ch b ofs v,
  ConcPrimcom (fun m m' => store ch m b ofs v = Some m')
| ConcPrimcom_alloc : forall lo hi,
  ConcPrimcom (fun m m' => fst (alloc m lo hi) = m')
| ConcPrimcom_free : forall b ofs n,
  ConcPrimcom (fun m m' => free m b ofs n = Some m').

Inductive ConcPrimexpr : pfunc mem val -> Prop :=.

Instance concrete : GenericSemantics mem ConcPrimcom ConcPrimexpr := {}.

Inductive VU : relation juicy_mem -> relation mem -> Prop :=
| VU_store : forall ch b ofs v,
  VU (fun j j' => Abs.juicy_mem_store j ch b ofs v = Some j')
     (fun m m' => store ch m b ofs v = Some m')
| VU_alloc : forall lo hi,
  VU (fun j j' => fst (Abs.juicy_mem_alloc j lo hi) = j')
     (fun m m' => fst (alloc m lo hi) = m')
.

Inductive GF : pfunc juicy_mem val -> pfunc mem val -> Prop :=.

Lemma PrimexprErasure : forall g f, GF g f -> False. Proof. inversion 1. Qed.

Lemma PrimcomErasure : forall v u j j' m m',
  VU v u -> m_dry j = m -> v j j' -> u m m' -> m_dry j' = m'.

Lemma PrimcomSafety : forall v u j j' m,
  VU v u -> m_dry j = m -> v j j' -> exists m', u m m'. *)

Require Import VST.veric.res_predicates.
(* VST.veric.res_predicates:
Require Import VST.msl.log_normalize.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.  
Require Import VST.veric.shares. 
Require Import VST.veric.address_conflict.

Import RML. Import R.
Local Open Scope pred.

Program Definition kind_at (k: kind) (l: address) : pred rmap :=
   fun m => exists rsh, exists sh, exists pp, m @ l = YES rsh sh k pp.

Definition spec : Type :=  forall (sh: Share.t) (l: AV.address), pred rmap.

Program Definition yesat_raw (pp: preds) (k: kind) 
                           (sh: share) (rsh: readable_share sh) (l: address) : pred rmap :=
   fun phi => phi @ l = YES sh rsh k (preds_fmap (approx (level phi)) (approx (level phi)) pp).

Obligation Tactic := idtac.

Program Definition yesat (pp: preds) (k: kind) : spec :=
 fun (sh: share) (l: AV.address) (m: rmap) =>

Program Definition pureat (pp: preds) (k: kind) (l: AV.address): pred rmap :=

Ltac do_map_arg :=
match goal with |- ?a = ?b =>
  match a with context [map ?x _] =>
    match b with context [map ?y _] => replace y with x; auto end end end.

Lemma yesat_raw_eq_aux:
  forall pp k rsh sh l,
    hereditary age
    (fun phi : rmap =>
     resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
     resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp)).

Lemma yesat_raw_eq: yesat_raw =
  fun pp k rsh sh l =>
  ((exist (hereditary age)
   (fun phi =>
   resource_fmap (approx (level phi)) (approx (level phi)) (phi @ l) =
   resource_fmap (approx (level phi)) (approx (level phi)) (YES rsh sh k pp))
   (yesat_raw_eq_aux pp k rsh sh l)) : pred rmap).

Lemma yesat_eq_aux: 
  forall pp k sh l, 
    hereditary age
    (fun m : rmap =>
      exists rsh, 
     resource_fmap (approx (level m)) (approx (level m)) (m @ l) =
     resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp)).

Lemma yesat_eq: yesat = fun pp k sh l =>
 exist (hereditary age)
  (fun m => 
  exists rsh, 
   resource_fmap (approx (level m)) (approx (level m)) (m @ l) = 
   resource_fmap (approx (level m)) (approx (level m)) (YES sh rsh k pp))
   (yesat_eq_aux pp k sh l).

Lemma map_compose_approx_succ_e:
  forall A n pp pp',
       map (compose (A:=A) (approx (S n))) pp =
    map (compose (A:=A) (approx (S n))) pp' ->
  map (compose (A:=A) (approx n)) pp = map (compose (A:=A) (approx n)) pp'.

Program Definition noat (l: AV.address) : pred rmap :=

Definition resource_share (r: resource) : option share :=
 match r with
 | YES sh _ _ _ => Some sh
 | NO sh _ => Some sh
 | PURE _ _ => None
 end.

Definition nonlock (r: resource) : Prop :=
 match r with
 | YES _ _ k _ => isVAL k \/ isFUN k
 | NO _ _ => True
 | PURE _ _ => False
 end.

Lemma age1_nonlock: forall phi phi' l,
  age1 phi = Some phi' -> (nonlock (phi @ l) <-> nonlock (phi' @ l)).

Lemma age1_resource_share: forall phi phi' l,
  age1 phi = Some phi' -> (resource_share (phi @ l) = resource_share (phi' @ l)).

Lemma resource_share_join_exists: forall r1 r2 r sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  exists sh, join sh1 sh2 sh /\ resource_share r = Some sh.

Lemma resource_share_join: forall r1 r2 r sh1 sh2 sh,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  join r1 r2 r ->
  join sh1 sh2 sh ->
  resource_share r = Some sh.

Lemma resource_share_joins: forall r1 r2 sh1 sh2,
  resource_share r1 = Some sh1 ->
  resource_share r2 = Some sh2 ->
  joins r1 r2 ->
  joins sh1 sh2.

Lemma nonlock_join: forall r1 r2 r,
  nonlock r1 ->
  nonlock r2 ->
  join r1 r2 r ->
  nonlock r.

Program Definition nonlockat (l: AV.address): pred rmap :=

Program Definition shareat (l: AV.address) (sh: share): pred rmap :=

Program Definition jam {A} {JA: Join A}{PA: Perm_alg A}{agA: ageable A}{AgeA: Age_alg A} {B: Type} {S': B -> Prop} (S: forall l, {S' l}+{~ S' l}) (P Q: B -> pred A) : B -> pred A :=
  fun (l: B) m => if S l then P l m else Q l m.

Lemma jam_true: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = P loc.

Lemma jam_false: forall A JA PA agA AgeA B (S': B -> Prop) S P Q loc, ~ S' loc -> @jam A JA PA agA AgeA B S' S P Q loc = Q loc.

Lemma boxy_jam:  forall (m: modality) A (S': A -> Prop) S P Q,
      (forall (x: A), boxy m (P x)) ->
      (forall x, boxy m (Q x)) ->
      forall x, boxy m (@jam rmap _ _ _ _ A S' S P Q x).

Definition extensible_jam: forall A (S': A -> Prop) S (P Q: A -> pred rmap),
      (forall (x: A), boxy extendM (P x)) ->
      (forall x, boxy extendM (Q x)) ->
      forall x, boxy extendM  (@jam _ _ _ _ _ _ S' S P Q x).

Definition jam_vacuous:
  forall A JA PA agA AgeA B S S' P Q, (forall x:B, ~ S x) -> @jam A JA PA agA AgeA B S S' P Q = Q.

Lemma make_sub_rmap: forall w (P: address -> Prop) (P_DEC: forall l, {P l} + {~ P l}),
  (forall l sh k, P l -> res_option (w @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  {w' | level w' = level w /\ resource_at w' =
       (fun l => if P_DEC l then w @ l else core (w @ l)) /\ ghost_of w' = ghost_of w}.

Definition is_resource_pred (p: address -> pred rmap) (q: resource -> address -> nat -> Prop) :=
  forall l w, (p l) w = q (w @ l) l (level w).

Definition resource_stable (p: address -> pred rmap) :=
  forall l w w', w @ l = w' @ l -> level w = level w' -> (p l) w = (p l) w'.

Lemma is_resource_pred_resource_stable: forall {p},
  (exists q, is_resource_pred p q) -> resource_stable p.

Program Definition noghost : pred rmap := fun m => identity (ghost_of m).

Lemma allp_jam_split2: forall (P Q R: address -> Prop) (p q r: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l})
  (R_DEC: forall l, {R l} + {~ R l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (exists resp, is_resource_pred r resp) ->
  Ensemble_join Q R P ->
  (forall l, Q l -> p l = q l) ->
  (forall l, R l -> p l = r l) ->
  (forall l m sh k, P l -> (p l) m -> res_option (m @ l) = Some (sh, k) -> isVAL k \/ isFUN k) ->
  allp (jam P_DEC p noat) && noghost =
  (allp (jam Q_DEC q noat) && noghost) * (allp (jam R_DEC r noat) && noghost).

Lemma allp_jam_overlap: forall (P Q: address -> Prop) (p q: address -> pred rmap)
  (P_DEC: forall l, {P l} + {~ P l})
  (Q_DEC: forall l, {Q l} + {~ Q l}),
  (exists resp, is_resource_pred p resp) ->
  (exists resp, is_resource_pred q resp) ->
  (forall l w1 w2, p l w1 -> q l w2 -> joins w1 w2 -> False) ->
  (exists l, P l /\ Q l) ->
  allp (jam P_DEC p noat) * allp (jam Q_DEC q noat) |-- FF.

Lemma yesat_join_diff:
  forall pp pp' k k' sh sh' l w, k <> k' -> 
                  yesat pp k sh l w -> yesat pp' k' sh' l w -> False.

Lemma yesat_raw_join:
  forall pp k (sh1 sh2 sh3: Share.t) rsh1 rsh2 rsh3 l phi1 phi2 phi3,

Lemma nonunit_join: forall A {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Disj_alg A} (x y z: A),
  nonunit x -> join x y z -> nonunit z.

Lemma yesat_join:
  forall pp k sh1 sh2 sh3 l m1 m2 m3,
   join sh1 sh2 sh3 ->   
   yesat pp k sh1 l m1 ->
   yesat pp k sh2 l m2 ->
   join m1 m2 m3 ->
   yesat pp k sh3 l m3.

Definition spec_parametric (Q: address -> spec) : Prop :=
   forall l l', exists pp, exists ok,
             forall sh m,
           Q l sh l' m = 
            (exists p, exists k, ok k /\ m @ l' = 
                 YES sh p k (preds_fmap (approx (level m)) (approx (level m)) pp)).

Lemma YES_ext:
  forall sh sh' rsh rsh' k p, sh=sh' -> YES sh rsh k p = YES sh' rsh' k p.

Definition VALspec : spec :=
       fun (sh: Share.t) (l: address) =>
          allp (jam (eq_dec l)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat) && noghost.

Definition VALspec_range (n: Z) : spec :=
     fun (sh: Share.t) (l: address) =>
          andp (allp (jam (adr_range_dec l n)
                                  (fun l' => EX v: memval, 
                                                yesat NoneP (VAL v) sh l')
                                  noat)) noghost.

Definition nonlock_permission_bytes (sh: share) (a: address) (n: Z) : pred rmap :=
  andp (allp (jam (adr_range_dec a n) (fun i => shareat i sh && nonlockat i) noat)) noghost.

Definition nthbyte (n: Z) (l: list memval) : memval :=
     nth (nat_of_Z n) l Undef.

Definition address_mapsto_old (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address)  => 
             allp (jam (adr_range_dec l (size_chunk ch)) 
                              (fun l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l')
                           noat).

Definition address_mapsto (ch: memory_chunk) (v: val) : spec :=
        fun (sh: Share.t) (l: AV.address) =>
           EX bl: list memval, 
               !! (length bl = size_chunk_nat ch  /\ decode_val ch bl = v /\ (align_chunk ch | snd l))  &&
                (allp (jam (adr_range_dec l (size_chunk ch))
                                    (fun loc => yesat NoneP (VAL (nth (nat_of_Z (snd loc - snd l)) bl Undef)) sh loc)
                                    noat)) && noghost.

Lemma address_mapsto_align: forall ch v sh l,
  address_mapsto ch v sh l = address_mapsto ch v sh l && !! (align_chunk ch | snd l).

Lemma address_mapsto_fun:
  forall ch sh sh' l v v',
          (address_mapsto ch v sh l * TT) && (address_mapsto ch v' sh' l * TT) |-- !!(v=v').

Definition LKspec lock_size (R: pred rmap) : spec :=
   fun (sh: Share.t) (l: AV.address)  =>
    allp (jam (adr_range_dec l lock_size)
               (fun l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l')
               noat) && noghost.

Definition TTat (l: address) : pred rmap := TT.

Lemma address_mapsto_old_parametric: forall ch v, 
   spec_parametric (fun l sh l' => yesat NoneP (VAL (nthbyte (snd l' - snd l) (encode_val ch v))) sh l').

Lemma VALspec_parametric: 
  spec_parametric (fun l sh l' => EX v: memval,  yesat NoneP (VAL v) sh l').

Lemma LKspec_parametric lock_size: forall R: pred rmap,
  spec_parametric (fun l sh l' => yesat (SomeP Mpred (fun _ => R)) (LK lock_size (snd l' - snd l)) sh l').

Definition val2address (v: val) : option AV.address := 
  match v with Vptr b ofs => Some (b, Ptrofs.signed ofs) | _ => None end.

Lemma VALspec_readable:
  forall l sh w,  (VALspec sh l * TT) %pred w -> readable l w.

Lemma address_mapsto_VALspec:
  forall ch v sh l i, 0 <= i < size_chunk ch ->
        address_mapsto ch v sh l |-- VALspec sh (adr_add l i) * TT.

Lemma address_mapsto_exists:
  forall ch v sh (rsh: readable_share sh) loc w0
      (RESERVE: forall l', adr_range loc (size_chunk ch) l' -> w0 @ l' = NO Share.bot bot_unreadable)

Lemma VALspec1: VALspec_range 1 = VALspec.

Lemma VALspec_range_exp_address_mapsto:
  forall ch sh l,
    (align_chunk ch | snd l) ->
    VALspec_range (size_chunk ch) sh l |-- EX v: val, address_mapsto ch v sh l.

Lemma address_mapsto_VALspec_range:
  forall ch v sh l,
        address_mapsto ch v sh l |-- VALspec_range (size_chunk ch) sh l.

Lemma approx_eq_i:
  forall (P Q: pred rmap) (w: rmap),
      (|> ! (P <=> Q)) w -> approx (level w) P = approx (level w) Q.

Lemma level_later {A} `{H : ageable A}: forall {w: A} {n': nat},
         laterR (level w) n' ->
       exists w', laterR w w' /\ n' = level w'.

Lemma VALspec_range_bytes_readable:
  forall n sh loc m, VALspec_range n sh loc m -> bytes_readable loc n m.

Lemma VALspec_range_bytes_writable:
  forall n sh loc m, writable_share sh -> VALspec_range n sh loc m -> bytes_writable loc n m.

Lemma yesat_join_sub:
  forall pp k l sh m m',
          join_sub m m' ->
          yesat pp k sh l m ->
         exists sh', yesat pp k sh' l m'.

Lemma VALspec_range_precise: forall n sh l,  precise (VALspec_range n sh l).

Lemma nonlock_permission_bytes_precise: forall sh p n,
  precise (nonlock_permission_bytes sh p n).

Lemma address_mapsto_precise: forall ch v sh l, precise (address_mapsto ch v sh l).

Lemma LKspec_precise lock_size: forall R sh l, precise (LKspec lock_size R sh l).

Program Definition core_load (ch: memory_chunk) (l: address) (v: val): pred rmap :=
  EX bl: list memval,
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Program Definition core_load' (ch: memory_chunk) (l: address) (v: val) (bl: list memval)
  : pred rmap :=
  !!(length bl = size_chunk_nat ch /\ decode_val ch bl = v /\ (align_chunk ch | snd l)) &&
    allp (jam (adr_range_dec l (size_chunk ch))
      (fun l' phi => exists sh, exists rsh, phi @ l' 
        = YES sh rsh (VAL (nth (nat_of_Z (snd l' - snd l)) bl Undef)) NoneP)
      (fun _ _ => True)).

Lemma VALspec_range_0: forall sh loc, VALspec_range 0 sh loc = emp.
Hint Resolve VALspec_range_0: normalize.

Lemma nonlock_permission_bytes_0: forall sh a, nonlock_permission_bytes sh a 0 = emp.

Lemma nonlock_permission_bytes_not_nonunit: forall sh p n,
  ~ nonunit sh ->
  nonlock_permission_bytes sh p n |-- emp.

Lemma is_resource_pred_YES_VAL sh:
  is_resource_pred
    (fun l' => EX  v: memval, yesat NoneP (VAL v) sh l')
    (fun r _ n => (exists b0 rsh, r = YES sh rsh (VAL b0)
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_YES_VAL' sh v:
  is_resource_pred
    (fun l' => yesat NoneP (VAL (v l')) sh l')
    (fun r l n => (exists rsh, r = YES sh rsh (VAL (v l))
        (SomeP (ConstType unit) (fun _ => tt)))).

Lemma is_resource_pred_nonlock_shareat sh:
  is_resource_pred
    (fun i : address => shareat i sh && nonlockat i)
    (fun r _ _ => resource_share r = Some sh /\ nonlock r).

Lemma VALspec_range_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma nonlock_permission_bytes_split2:
  forall (n m r: Z) (sh: Share.t) (b: block) (ofs: Z),

Lemma VALspec_range_VALspec:
  forall (n : Z) (v : val) (sh : Share.t) (l : address) (i : Z),

Lemma VALspec_range_overlap': forall sh p1 p2 n1 n2,
  adr_range p1 n1 p2 ->
  n2 > 0 ->
  VALspec_range n1 sh p1 * VALspec_range n2 sh p2 |-- FF.

Lemma address_mapsto_overlap':
  forall sh ch1 v1 ch2 v2 a1 a2,
     adr_range a1 (size_chunk ch1) a2 ->
     address_mapsto ch1 v1 sh a1 * address_mapsto ch2 v2 sh a2 |-- FF.

Lemma VALspec_range_overlap: forall sh l1 n1 l2 n2,
  range_overlap l1 n1 l2 n2 ->
  VALspec_range n1 sh l1 * VALspec_range n2 sh l2 |-- FF.

Lemma address_mapsto_overlap: forall sh l1 ch1 v1 l2 ch2 v2,
  range_overlap l1 (size_chunk ch1) l2 (size_chunk ch2) ->
  address_mapsto ch1 v1 sh l1 * address_mapsto ch2 v2 sh l2 |-- FF.

Lemma share_joins_self: forall sh: share, joins sh sh -> nonunit sh -> False.

Lemma nonlock_permission_bytes_overlap:
  forall sh n1 n2 p1 p2,
  nonunit sh ->
  range_overlap p1 n1 p2 n2 ->
  nonlock_permission_bytes sh p1 n1 * nonlock_permission_bytes sh p2 n2 |-- FF.

Lemma address_mapsto_value_cohere':
  forall ch v1 v2 sh1 sh2 a r
 (Hmaps1 : address_mapsto ch v1 sh1 a r)
 (Hmaps2 : address_mapsto ch v2 sh2 a r), v1=v2.

Lemma address_mapsto_value_cohere:
  forall ch v1 v2 sh1 sh2 a,
 address_mapsto ch v1 sh1 a * address_mapsto ch v2 sh2 a |-- !! (v1=v2).

Definition almost_empty rm: Prop:=
  forall loc sh psh k P, rm @ loc = YES sh psh k P -> forall val, ~ k = VAL val.

Definition no_locks phi :=
  forall addr sh sh' z z' P,
phi @ addr <> YES sh sh' (LK z z') P. *)

Require Import VST.veric.extend_tc.
(* VST.veric.extend_tc:
Require Import VST.msl.log_normalize.
Require Import VST.msl.alg_seplog.
Require Export VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.binop_lemmas2.

Local Open Scope pred.

Definition tc_expr {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred:=
  fun rho => denote_tc_assert (typecheck_expr Delta e) rho.

Definition tc_exprlist {CS: compspecs} (Delta: tycontext) (t : list type) (e: list expr) : environ -> mpred :=
      fun rho => denote_tc_assert (typecheck_exprlist Delta t e) rho.

Definition tc_lvalue {CS: compspecs} (Delta: tycontext) (e: expr) : environ -> mpred :=
     fun rho => denote_tc_assert (typecheck_lvalue Delta e) rho.

Definition tc_temp_id {CS: compspecs} (id : positive) (ty : type)
  (Delta : tycontext) (e : expr) : environ -> mpred  :=
     fun rho => denote_tc_assert (typecheck_temp_id id ty Delta e) rho.

Definition tc_expropt {CS: compspecs} Delta (e: option expr) (t: type) : environ -> mpred :=
   match e with None => `!!(t=Tvoid)
                     | Some e' => tc_expr Delta (Ecast e' t)
   end.

Definition tc_temp_id_load id tfrom Delta v : environ -> mpred  :=
fun rho => !! (exists tto, (temp_types Delta) ! id = Some tto
                      /\ tc_val tto (eval_cast tfrom tto (v rho))).

Lemma extend_prop: forall P, boxy extendM (prop P).

Hint Resolve extend_prop.

Lemma extend_tc_temp_id_load :  forall id tfrom Delta v rho, boxy extendM (tc_temp_id_load id tfrom Delta v rho).

Lemma extend_tc_andp:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_andp A B) rho).

Lemma extend_tc_bool:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert (tc_bool A B) rho).

Lemma extend_tc_int_or_ptr_type:
 forall {CS: compspecs} A rho,
   boxy extendM (denote_tc_assert (tc_int_or_ptr_type A) rho).

Lemma extend_tc_Zge:
 forall {CS: compspecs} v i rho,
   boxy extendM (denote_tc_assert (tc_Zge v i) rho).

Lemma extend_tc_Zle:
 forall {CS: compspecs} v i rho,
   boxy extendM (denote_tc_assert (tc_Zle v i) rho).

Lemma extend_tc_iszero:
 forall {CS: compspecs} v rho,
   boxy extendM (denote_tc_assert (tc_iszero v) rho).

Lemma extend_valid_pointer':
  forall a b, boxy extendM (valid_pointer' a b).

Lemma extend_andp: forall P Q, 
  boxy extendM P -> boxy extendM Q -> boxy extendM (andp P Q).

Lemma extend_orp: forall P Q, 
  boxy extendM P -> boxy extendM Q -> boxy extendM (orp P Q).

Lemma extend_tc_test_eq:
  forall {CS: compspecs} e1 e2 rho,
 boxy extendM (denote_tc_assert (tc_test_eq e1 e2) rho).

Lemma extend_tc_test_order:
  forall {CS: compspecs} e1 e2 rho,
 boxy extendM (denote_tc_assert (tc_test_order e1 e2) rho).

Lemma extend_isCastResultType:
 forall {CS: compspecs} t t' v rho,
   boxy extendM (denote_tc_assert (isCastResultType t t' v) rho).

Lemma extend_tc_temp_id: forall {CS: compspecs} id ty Delta e rho, boxy extendM (tc_temp_id id ty Delta e rho).

Lemma extend_tc_samebase:
  forall {CS: compspecs} e1 e2 rho,
boxy extendM (denote_tc_assert (tc_samebase e1 e2) rho).

Lemma extend_tc_nonzero:
 forall {CS: compspecs} v rho,
   boxy extendM (denote_tc_assert (tc_nonzero v) rho).

Lemma extend_tc_nodivover:
 forall {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nodivover e1 e2) rho).

Lemma extend_tc_nosignedover:
 forall op {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nosignedover op e1 e2) rho).

Lemma extend_tc_nobinover:
 forall op {CS: compspecs} e1 e2 rho,
   boxy extendM (denote_tc_assert (tc_nobinover op e1 e2) rho).

Lemma boxy_orp {A} `{H : ageable A}:
     forall (M: modality) , reflexive _ (app_mode M) ->
      forall P Q, boxy M P -> boxy M Q -> boxy M (P || Q).

Lemma extend_tc_orp:
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_orp A B) rho).

Lemma extend_tc_ilt:
 forall {CS: compspecs} e i rho,
   boxy extendM (denote_tc_assert (tc_ilt e i) rho).

Lemma extend_tc_llt:
 forall {CS: compspecs} e i rho,
   boxy extendM (denote_tc_assert (tc_llt e i) rho).

Lemma extend_tc_andp':
 forall {CS: compspecs} A B rho,
   boxy extendM (denote_tc_assert A rho) ->
   boxy extendM (denote_tc_assert B rho) ->
   boxy extendM (denote_tc_assert (tc_andp' A B) rho).

Ltac extend_tc_prover := 
  match goal with
  | |- _ => solve [immediate]
  | |- _ => apply extend_prop
  | |- _ => first
              [ simple apply extend_tc_bool
              | simple apply extend_tc_int_or_ptr_type
              | simple apply extend_tc_andp
              | simple apply extend_tc_andp'
              | simple apply extend_tc_Zge
              | simple apply extend_tc_Zle
              | simple apply extend_tc_iszero
              | simple apply extend_tc_nonzero
              | simple apply extend_tc_nodivover
              | simple apply extend_tc_nobinover
              | simple apply extend_tc_samebase
              | simple apply extend_tc_ilt
              | simple apply extend_tc_llt
              | simple apply extend_isCastResultType
              | simple apply extend_tc_test_eq
              | simple apply extend_tc_test_order]
  | |- boxy _ (denote_tc_assert (if ?A then _ else _) _) => destruct A
  | |- boxy _ (denote_tc_assert match tc_bool ?A _ with _ => _ end _) =>
             destruct A
  | |- boxy _ (denote_tc_assert match ?A with Some _ => _ | None => _ end _) =>
          destruct A
  end.

Lemma extend_tc_binop: forall {CS: compspecs} Delta e1 e2 b t rho, 
  boxy extendM (denote_tc_assert (typecheck_expr Delta e1) rho) ->
  boxy extendM (denote_tc_assert (typecheck_expr Delta e2) rho) ->
  boxy extendM (denote_tc_assert (isBinOpResultType b e1 e2 t) rho).

Lemma extend_tc_expr: forall {CS: compspecs} Delta e rho, boxy extendM (tc_expr Delta e rho)
 with extend_tc_lvalue: forall {CS: compspecs} Delta e rho, boxy extendM (tc_lvalue Delta e rho).

Lemma extend_tc_exprlist: forall {CS: compspecs} Delta t e rho, boxy extendM (tc_exprlist Delta t e rho).

Lemma extend_tc_expropt: forall {CS: compspecs} Delta e t rho, boxy extendM (tc_expropt Delta e t rho).

Hint Resolve extend_tc_expr extend_tc_temp_id extend_tc_temp_id_load extend_tc_exprlist extend_tc_expropt extend_tc_lvalue.
Hint Resolve (@extendM_refl rmap _ _ _ _ _). *)

Require Import VST.veric.Clight_seplog.
(* VST.veric.Clight_seplog:
Require Import VST.msl.log_normalize.
Require Import VST.msl.alg_seplog.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.res_predicates.

Require Import VST.veric.mpred.
Require Import VST.veric.address_conflict.
Require Export VST.veric.shares.

Require Export VST.veric.seplog.

Require Export VST.veric.mapsto_memory_block.

Local Open Scope pred.

Require Import compcert.cfrontend.Clight. 
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.binop_lemmas2.
Require Export VST.veric.Clight_mapsto_memory_block.

Local Open Scope pred.

Definition expr_true {CS: compspecs} e := lift1 (typed_true (typeof e)) (eval_expr e).

Definition expr_false {CS: compspecs} e := lift1 (typed_false (typeof e)) (eval_expr e).

Definition eval_lvar (id: ident) (ty: type) (rho: environ) :=
 match Map.get (ve_of rho) id with
| Some (b, ty') => if eqb_type ty ty' then Vptr b Ptrofs.zero else Vundef
| None => Vundef
end.

Definition var_block (sh: Share.t) {cs: compspecs} (idt: ident * type) (rho: environ): mpred :=
  !! (sizeof (snd idt) <= Ptrofs.max_unsigned) &&
  (memory_block sh (sizeof (snd idt))) (eval_lvar (fst idt) (snd idt) rho).

Definition stackframe_of {cs: compspecs} (f: Clight.function) : assert :=
  fold_right (fun P Q rho => P rho * Q rho) (fun rho => emp) (map (fun idt => var_block Share.top idt) (Clight.fn_vars f)).

Lemma stackframe_of_eq : forall {cs: compspecs}, stackframe_of =
        fun f rho => fold_right sepcon emp (map (fun idt => var_block Share.top idt rho) (Clight.fn_vars f)).

Lemma  subst_derives:
 forall a v P Q, (forall rho, P rho |-- Q rho) -> forall rho, subst a v P rho |-- subst a v Q rho.

Definition tc_formals (formals: list (ident * type)) : environ -> Prop :=
     fun rho => tc_vals (map (@snd _ _) formals) (map (fun xt => (eval_id (fst xt) rho)) formals).

Program Definition close_precondition (params vars: list (ident * type)) (P: environ -> pred rmap) (rho: environ) : pred rmap :=
 fun phi =>
   exists ve', exists te',
   (forall i, In i (map (@fst _ _) params) -> Map.get te' i = Map.get (te_of rho) i) /\

Lemma close_precondition_i:
  forall params vars P rho,
  P rho |-- close_precondition params vars P rho.

Definition precondition_closed (f: function) {A: TypeTree}
  (P: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred) : Prop :=
 forall ts x,
  closed_wrt_vars (not_a_param (fn_params f)) (P ts x) /\
  closed_wrt_lvars (is_a_local (fn_vars f)) (P ts x).

Lemma close_precondition_e:
   forall f (A: TypeTree) (P:  forall ts, dependent_type_functor_rec ts (AssertTT A) mpred),
    precondition_closed f P ->
  forall ts x rho,
   close_precondition (fn_params f) (fn_vars f) (P ts x) rho |-- P ts x rho.

Definition bind_args (formals vars: list (ident * type)) (P: environ -> pred rmap) : assert :=
          fun rho => !! tc_formals formals rho && close_precondition formals vars P rho.

Definition ret_temp : ident := 1%positive.

Definition get_result1 (ret: ident) (rho: environ) : environ :=
   make_args (ret_temp::nil) (eval_id ret rho :: nil) rho.

Definition get_result (ret: option ident) : environ -> environ :=
 match ret with
 | None => make_args nil nil
 | Some x => get_result1 x
 end.

Definition bind_ret (vl: option val) (t: type) (Q: assert) : assert :=
     match vl, t with
     | None, Tvoid => fun rho => Q (make_args nil nil rho)
     | Some v, _ => fun rho => !! (tc_val t v) &&
                               Q (make_args (ret_temp::nil) (v::nil) rho)
     | _, _ => fun rho => FF
     end.

Definition funassert (Delta: tycontext): assert := funspecs_assert (glob_specs Delta).

Definition proj_ret_assert (Q: ret_assert) (ek: exitkind) (vl: option val) : assert :=
 match ek with
 | EK_normal => RA_normal Q
 | EK_break => RA_break Q
 | EK_continue => RA_continue Q
 | EK_return => RA_return Q vl
 end.

Definition overridePost  (Q: assert)  (R: ret_assert) :=
 match R with 
  {| RA_normal := _; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Q; RA_break := b; RA_continue := c; RA_return := r |}
 end.

Definition existential_ret_assert {A: Type} (R: A -> ret_assert) :=
  {| RA_normal := fun rho => EX x:A, (R x).(RA_normal) rho;
     RA_break := fun rho => EX x:A, (R x).(RA_break) rho;
     RA_continue := fun rho => EX x:A, (R x).(RA_continue) rho;
     RA_return := fun vl rho => EX x:A, (R x).(RA_return) vl rho
   |}.

Definition normal_ret_assert (Q: assert) : ret_assert :=
  {| RA_normal := Q; RA_break := seplog.FF; RA_continue := seplog.FF; RA_return := fun _ => seplog.FF |}.

Definition frame_ret_assert (R: ret_assert) (F: assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := fun rho => n rho * F rho; 
     RA_break := fun rho => b rho * F rho; 
     RA_continue := fun rho => c rho * F rho;
     RA_return := fun vl rho => r vl rho * F rho |}
 end.

Definition conj_ret_assert (R: ret_assert) (F: assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := fun rho => n rho && F rho; 
     RA_break := fun rho => b rho && F rho; 
     RA_continue := fun rho => c rho && F rho;
     RA_return := fun vl rho => r vl rho && F rho |}
 end.

Definition switch_ret_assert (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := seplog.FF; 
     RA_break := n; 
     RA_continue := c;
     RA_return := r |}
 end.

Require Import VST.msl.normalize.

Lemma normal_ret_assert_derives:
 forall P Q rho,
  P rho |-- Q rho ->
  forall ek vl, proj_ret_assert (normal_ret_assert P) ek vl rho 
            |-- proj_ret_assert (normal_ret_assert Q) ek vl rho.
Hint Resolve normal_ret_assert_derives.

Lemma normal_ret_assert_FF:
  forall ek vl rho, proj_ret_assert (normal_ret_assert (fun rho => FF)) ek vl rho = FF.

Lemma frame_normal:
  forall P F,
   frame_ret_assert (normal_ret_assert P) F = normal_ret_assert (fun rho => P rho * F rho).

Lemma proj_frame:
  forall P F ek vl,
    proj_ret_assert (frame_ret_assert P F) ek vl = fun rho => F rho * proj_ret_assert P ek vl rho.

Lemma proj_conj:
  forall P F ek vl,
    proj_ret_assert (conj_ret_assert P F) ek vl = fun rho => F rho && proj_ret_assert P ek vl rho.

Definition loop1_ret_assert (Inv: assert) (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Inv;
     RA_break := n; 
     RA_continue := Inv;
     RA_return := r |}
 end.

Definition loop2_ret_assert (Inv: assert) (R: ret_assert) : ret_assert :=
 match R with 
  {| RA_normal := n; RA_break := b; RA_continue := c; RA_return := r |} =>
  {| RA_normal := Inv;
     RA_break := n;
     RA_continue := seplog.FF;
     RA_return := r |}
 end.

Lemma frame_for1:
  forall Q R F,
   frame_ret_assert (loop1_ret_assert Q R) F =
   loop1_ret_assert (fun rho => Q rho * F rho) (frame_ret_assert R F).

Lemma frame_loop1:
  forall Q R F,
   frame_ret_assert (loop2_ret_assert Q R) F =
   loop2_ret_assert (fun rho => Q rho * F rho) (frame_ret_assert R F).

Lemma overridePost_normal:
  forall P Q, overridePost P (normal_ret_assert Q) = normal_ret_assert P.

Hint Rewrite normal_ret_assert_FF frame_normal frame_for1 frame_loop1
                 overridePost_normal: normalize.

Definition function_body_ret_assert (ret: type) (Q: assert) : ret_assert :=
 {| RA_normal := seplog.FF;
    RA_break := seplog.FF; 
    RA_continue := seplog.FF;
    RA_return := fun vl => bind_ret vl ret Q |}.

Lemma same_glob_funassert:
  forall Delta1 Delta2,
     (forall id, (glob_specs Delta1) ! id = (glob_specs Delta2) ! id) ->
              funassert Delta1 = funassert Delta2. *)

Require Import VST.veric.Clight_assert_lemmas.
(* VST.veric.Clight_assert_lemmas:
Require Export VST.veric.base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_seplog.
Require Export VST.veric.assert_lemmas.

Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.extend_tc.

Local Open Scope pred.

Lemma corable_funassert:
  forall G rho, corable (funassert G rho).

Hint Resolve corable_funassert.

Definition allp_fun_id (Delta : tycontext) (rho : environ): pred rmap :=
(ALL id : ident ,
 (ALL fs : funspec ,
  !! ((glob_specs Delta) ! id = Some fs) -->
  (EX b : block, !! (Map.get (ge_of rho) id = Some b) && func_at fs (b, 0)))).

Lemma corable_allp_fun_id: forall Delta rho,
  corable (allp_fun_id Delta rho).
  
Lemma allp_fun_id_sub: forall Delta Delta' rho,
  tycontext_sub Delta Delta' ->
  allp_fun_id Delta' rho |-- allp_fun_id Delta rho.

Lemma funassert_allp_fun_id_sub: forall Delta Delta' rho,
  tycontext_sub Delta Delta' ->
  funassert Delta' rho |-- allp_fun_id Delta rho.

Lemma prop_derives {A}{H: ageable A}:
 forall (P Q: Prop), (P -> Q) -> prop P |-- prop Q.

Section STABILITY.
Variable CS: compspecs.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma tc_bool_e_sub: forall b b' err rho phi,
  (b = true -> b' = true) ->
  denote_tc_assert (tc_bool b err) rho phi ->
  denote_tc_assert (tc_bool b' err) rho phi.

Lemma tc_bool_e_i:
  forall b c rho phi,
   b = true ->
  app_pred (denote_tc_assert (tc_bool b c) rho) phi.

Lemma tc_expr_lvalue_sub: forall rho,
  typecheck_environ Delta rho ->
  forall e,
    tc_expr Delta e rho |-- tc_expr Delta' e rho /\
    tc_lvalue Delta e rho |-- tc_lvalue Delta' e rho.

Lemma tc_expr_sub:
    forall e rho, typecheck_environ Delta rho -> tc_expr Delta e rho |-- tc_expr Delta' e rho.

Lemma tc_lvalue_sub:
    forall e rho, typecheck_environ Delta rho -> tc_lvalue Delta e rho |-- tc_lvalue Delta' e rho.

Lemma tc_temp_id_sub:
    forall id t e rho,
   tc_temp_id id t Delta e rho |-- tc_temp_id id t Delta' e rho.

Lemma tc_temp_id_load_sub:
   forall id t v rho,
   tc_temp_id_load id t Delta v rho |--    tc_temp_id_load id t Delta' v rho.

Lemma tc_exprlist_sub:
  forall e t rho, typecheck_environ Delta rho -> tc_exprlist Delta e t rho |-- tc_exprlist Delta' e t rho.

Definition typeof_temp (Delta: tycontext) (id: ident) : option type :=
 match (temp_types Delta) ! id with
 | Some t => Some t
 | None => None
 end.

Lemma typeof_temp_sub:
   forall i t,
    typeof_temp Delta i = Some t ->
    typeof_temp Delta' i = Some t.

End STABILITY. *)

Require Import VST.veric.Clight_new.
(* VST.veric.Clight_new:
Require Import VST.sepcomp.semantics.
Require Import VST.veric.Clight_base.
Require Import VST.veric.Clight_lemmas.
Require compcert.common.Globalenvs.

Inductive cont': Type :=
  | Kseq: statement -> cont'       
  | Kloop1: statement -> statement -> cont'
  | Kloop2: statement -> statement  -> cont'
  | Kswitch: cont'       
  | Kcall: forall (l: option ident),                  
           function ->                      
           env ->                           
           temp_env ->                      
           cont'.

Definition cont := list cont'.

Fixpoint call_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k => call_cont k
  | Kloop1 _ _ :: k => call_cont k
  | Kloop2 _ _ :: k => call_cont k
  | Kswitch :: k => call_cont k
  | _ => k
  end.

Fixpoint current_function (k: cont) : option function :=
 match k with
  | Kseq s :: k => current_function k
  | Kloop1 _ _ :: k => current_function k
  | Kloop2 _ _:: k =>current_function k
  | Kswitch :: k => current_function k
  | Kcall _ f _ _ :: _ => Some f
  | _ => None
  end.

Fixpoint continue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => continue_cont k'
  | Kloop1 s1 s2 :: k' => Kseq s2 :: Kloop2 s1 s2 :: k'
  | Kswitch :: k' => continue_cont k'
  | _ => nil 
  end.

Lemma call_cont_nonnil: forall k f, current_function k = Some f -> call_cont k <> nil.

Fixpoint precontinue_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => precontinue_cont k'
  | Kloop1 _ _ :: _ => k
  | Kswitch :: k' => precontinue_cont k'
  | _ => nil 
  end.

Fixpoint break_cont (k: cont) : cont :=
  match k with
  | Kseq s :: k' => break_cont k'
  | Kloop1 _ _ :: k' => k'
  | Kloop2 _ _ :: k' => k'
  | Kswitch :: k' => k'
  | _ =>  nil 
  end.

Inductive corestate :=
 | State: forall (ve: env) (te: temp_env) (k: cont), corestate
 | ExtCall: forall (ef: external_function) (args: list val)
                   (lid: option ident) (ve: env) (te: temp_env) (k: cont),
                corestate.

Fixpoint strip_skip (k: cont) : cont :=
 match k with Kseq Sskip :: k' => strip_skip k' | _ => k end.

Definition cl_at_external (c: corestate) : option (external_function * list val) :=
  match c with
  | State _ _ k => None
  | ExtCall ef args lid ve te k => Some (ef, args)
 end.

Definition cl_after_external (vret: option val) (c: corestate) : option corestate :=
  match vret, c with
  | Some v, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id v te) k)
  | None, ExtCall ef args (Some id) ve te k => Some (State ve (PTree.set id Vundef te) k)
  | Some v, ExtCall ef args None ve te k => Some (State ve te k)
  | None, ExtCall ef args None ve te k => Some (State ve te k)
  | _, _ => None
  end.

Fixpoint find_label (lbl: label) (s: statement) (k: cont)
                    {struct s}: option cont :=
  match s with
  | Ssequence s1 s2 =>
      match find_label lbl s1 (Kseq s2 :: k) with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sifthenelse a s1 s2 =>
      match find_label lbl s1 k with
      | Some sk => Some sk
      | None => find_label lbl s2 k
      end
  | Sloop s1 a3 =>
      match find_label lbl s1 (Kseq Scontinue :: Kloop1 s1 a3 :: k) with
      | Some sk => Some sk
      | None => find_label lbl a3 (Kloop2 s1 a3 :: k)
      end
  | Sswitch e sl =>
      find_label_ls lbl sl (Kswitch :: k)
  | Slabel lbl' s' =>
      if ident_eq lbl lbl' then Some(Kseq s' :: k) else find_label lbl s' k
  | _ => None
  end

with find_label_ls (lbl: label) (sl: labeled_statements) (k: cont)
                    {struct sl}: option cont :=
  match sl with
  | LSnil => None
  | LScons _ s sl' =>
      match find_label lbl s (Kseq (seq_of_labeled_statement sl') :: k) with
      | Some sk => Some sk
      | None => find_label_ls lbl sl' k
      end
  end.

Inductive cl_step (ge: Clight.genv): forall (q: corestate) (m: mem) (q': corestate) (m': mem), Prop :=

  | step_assign: forall ve te k m a1 a2 loc ofs v2 v m',
     type_is_volatile (typeof a1) = false ->
      Clight.eval_lvalue ge ve te m a1 loc ofs ->
      Clight.eval_expr ge ve te m a2 v2 ->
      Cop.sem_cast v2 (typeof a2) (typeof a1) m = Some v ->
      Clight.assign_loc ge (typeof a1) m loc ofs v m' ->
      cl_step ge (State ve te (Kseq (Sassign a1 a2):: k)) m (State ve te k) m'

  | step_set:   forall ve te k m id a v,
      Clight.eval_expr ge ve te m a v ->
      cl_step ge (State ve te (Kseq (Sset id a) :: k)) m (State ve (PTree.set id v te) k) m

  | step_call_internal:   forall ve te k m optid a al tyargs tyres cc vf vargs f m1 ve' le',
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (Internal f) ->
      type_of_function f = Tfunction tyargs tyres cc ->
      list_norepet (var_names f.(fn_params) ++ var_names f.(fn_temps)) ->
      forall (NRV: list_norepet (var_names f.(fn_vars))),
      Clight.alloc_variables ge empty_env m (f.(fn_vars)) ve' m1 ->
      bind_parameter_temps f.(fn_params) vargs (create_undef_temps f.(fn_temps)) = Some
le' ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m
                   (State ve' le' (Kseq f.(fn_body) :: Kseq (Sreturn None) :: Kcall optid f ve te :: k)) m1

  | step_call_external:   forall ve te k m optid a al tyargs tyres cc vf vargs ef,
      Cop.classify_fun (typeof a) = Cop.fun_case_f tyargs tyres cc ->
      Clight.eval_expr ge ve te m a vf ->
      Clight.eval_exprlist ge ve te m al tyargs vargs ->
      Genv.find_funct ge vf = Some (External ef tyargs tyres cc) ->
      cl_step ge (State ve te (Kseq (Scall optid a al) :: k)) m (ExtCall ef vargs optid ve te k) m

  | step_seq: forall ve te k m s1 s2 st' m',
          cl_step ge (State ve te (Kseq s1 :: Kseq s2 :: k)) m st' m' ->
          cl_step ge (State ve te (Kseq (Ssequence s1 s2) :: k)) m st' m'

  | step_skip: forall ve te k m st' m',
          cl_step ge (State ve te k) m st' m' ->
          cl_step ge (State ve te (Kseq Sskip :: k)) m st' m'

  | step_continue: forall ve te k m st' m',
           cl_step ge (State ve te (continue_cont k)) m st' m' ->
           cl_step ge (State ve te (Kseq Scontinue :: k)) m st' m'

  | step_break: forall ve te k m st' m',
                   cl_step ge (State ve te (break_cont k)) m st' m' ->
                   cl_step ge (State ve te (Kseq Sbreak :: k)) m st' m'

  | step_ifthenelse:  forall ve te k m a s1 s2 v1 b,
      Clight.eval_expr ge ve te m a v1 ->
      Cop.bool_val v1 (typeof a) m = Some b ->
      cl_step ge (State ve te (Kseq (Sifthenelse a s1 s2) :: k)) m (State ve te  (Kseq (if b then s1 else s2) :: k)) m

  | step_for: forall ve te k m s1 s2,
      cl_step ge (State ve te (Kseq (Sloop s1 s2) :: k)) m
              (State ve te (Kseq s1 :: Kseq Scontinue :: Kloop1 s1 s2 :: k)) m

  | step_loop2: forall ve te k m a3 s,
      cl_step ge (State ve te (Kloop2 s a3 :: k)) m
             (State ve te (Kseq s :: Kseq Scontinue :: Kloop1 s a3 :: k)) m

  | step_return: forall f ve te optexp optid k m v' m' ve' te' te'' k',
      call_cont k = Kcall optid f ve' te' :: k' ->
      Mem.free_list m (Clight.blocks_of_env ge ve) = Some m' ->
      match optexp with None => v' = Vundef
                                  | Some a => exists v, Clight.eval_expr ge ve te m a v
                                     /\ Cop.sem_cast v (typeof a) f.(fn_return) m = Some v'
                            end ->
      match optid with None => True /\ te''=te'
                                | Some id => True /\ te'' = PTree.set id v' te'
      end ->
      cl_step ge (State ve te (Kseq (Sreturn optexp) :: k)) m (State ve' te'' k') m'

  | step_switch: forall ve te k m a sl v n,
      Clight.eval_expr ge ve te m a v ->
      Cop.sem_switch_arg v (typeof a) = Some n ->
      cl_step ge (State ve te (Kseq (Sswitch a sl) :: k)) m
              (State ve te (Kseq (seq_of_labeled_statement (select_switch n sl)) :: Kswitch :: k)) m

  | step_label: forall ve te k m lbl s st' m',
       cl_step ge (State ve te (Kseq s :: k)) m st' m' ->
       cl_step ge (State ve te (Kseq (Slabel lbl s) :: k)) m st' m'

  | step_goto: forall f ve te k m lbl k'
                     
      (CUR: current_function k = Some f),
      find_label lbl f.(fn_body) (Kseq (Sreturn None) :: (call_cont k)) = Some k' ->
      cl_step ge (State ve te (Kseq (Sgoto lbl) :: k)) m (State ve te k') m.

Definition vret2v (vret: list val) : val :=
  match vret with v::nil => v | _ => Vundef end.

Definition cl_halted (c: corestate) : option val := None.

Definition empty_function : function := mkfunction Tvoid cc_default nil nil nil Sskip.

Fixpoint temp_bindings (i: positive) (vl: list val) :=
 match vl with
 | nil => PTree.empty val
 | v::vl' => PTree.set i v (temp_bindings (i+1)%positive vl')
 end.

Definition Tint32s := Tint I32 Signed noattr.
Definition true_expr : Clight.expr := Clight.Econst_int Int.one Tint32s.

Fixpoint typed_params (i: positive) (n: nat) : list (ident * type) :=
  match n with
  | O => nil
  | S n' => (i, Tint32s) :: typed_params (i+1)%positive n'
  end.

Fixpoint params_of_types (i: positive) (l : list type) : list (ident * type) :=
  match l with
  | nil => nil
  | t :: l => (i, t) :: params_of_types (i+1)%positive l
  end.

Fixpoint typelist2list (tl: typelist) : list type :=
  match tl with
  | Tcons t r => t::typelist2list r
  | Tnil => nil
  end.

Definition params_of_fundef (f: fundef) : list type :=
  match f with
  | Internal {| fn_params := fn_params |} => map snd fn_params
  | External _ t _ _ => typelist2list t
  end.

Inductive val_casted_list: list val -> typelist -> Prop :=
  | vcl_nil:
      val_casted_list nil Tnil
  | vcl_cons: forall v1 vl ty1 tyl,
      val_casted v1 ty1 -> val_casted_list vl tyl ->
      val_casted_list (v1 :: vl) (Tcons  ty1 tyl).

Definition cl_initial_core (ge: genv) (v: val) (args: list val) (q: corestate) : Prop :=
  match v with
    Vptr b i =>
    if Ptrofs.eq_dec i Ptrofs.zero then
      match Genv.find_funct_ptr ge b with
        Some f =>
        match type_of_fundef f with Tfunction targs _ c =>
        c = cc_default /\
        val_casted_list args targs /\
        Val.has_type_list args (Ctypes.typlist_of_typelist targs) /\
        q = State empty_env (temp_bindings 1%positive (v::args))
                    (Kseq (Scall None
                                 (Etempvar 1%positive (type_of_fundef f))
                                 (map (fun x => Etempvar (fst x) (snd x))
                                      (params_of_types 2%positive
                                                       (params_of_fundef f)))) ::
                          Kseq (Sloop Sskip Sskip) :: nil)
        | _ => False end
      | _ => False end
    else False
  | _ => False
end.

Lemma cl_corestep_not_at_external:
  forall ge m q m' q', cl_step ge q m q' m' -> cl_at_external q = None.

Lemma cl_corestep_not_halted :
  forall ge m q m' q', cl_step ge q m q' m' -> cl_halted q = None.

Lemma cl_after_at_external_excl :
  forall retv q q', cl_after_external retv q = Some q' -> cl_at_external q' = None.

Definition arg_well_formed args m0:=
  Val.inject_list (Mem.flat_inj (Mem.nextblock m0)) args args.

Program Definition cl_core_sem  (ge: genv):
  @CoreSemantics corestate mem :=
  @Build_CoreSemantics _ _
    
    (fun _ m c m' v args => cl_initial_core ge v args c /\ arg_well_formed args m /\ m' = m)
    (fun c _ => cl_at_external c)
    (fun ret c _ => cl_after_external ret c)
    (fun c _ =>  False )
    (cl_step ge)
    _
    (cl_corestep_not_at_external ge).

Lemma cl_corestep_fun: forall ge m q m1 q1 m2 q2,
    cl_step ge q m q1 m1 ->
    cl_step ge q m q2 m2 ->
    (q1,m1)=(q2,m2). *)

Require Import VST.sepcomp.extspec.
(* VST.sepcomp.extspec:
Require Import Coq.Lists.ListSet.
Require Import compcert.common.AST.
Require Import compcert.common.Values.
Require Import compcert.common.Memory.
Require Import compcert.common.Globalenvs.
Require Import compcert.lib.Maps.

Definition PTree_injective {A} (t: PTree.t A) : Prop :=
  forall id1 id2 b, t ! id1 = Some b -> t ! id2 = Some b -> id1 = id2.

Definition injective_PTree A := sig (@PTree_injective A).

Structure external_specification (M E Z : Type) :=
  { ext_spec_type : E -> Type
  ; ext_spec_pre: forall e: E,
    ext_spec_type e -> injective_PTree block -> list typ -> list val -> Z -> M -> Prop
  ; ext_spec_post: forall e: E,
    ext_spec_type e -> injective_PTree block -> option typ -> option val -> Z -> M ->  Prop
  ; ext_spec_exit: option val -> Z -> M ->  Prop }.

Arguments ext_spec_type {M E Z} _ _.
Arguments ext_spec_pre {M E Z} _ _ _ _ _ _ _ _.
Arguments ext_spec_post {M E Z} _ _ _ _ _ _ _ _.
Arguments ext_spec_exit {M E Z} _ _ _ _.

Definition ext_spec := external_specification mem external_function.

Lemma extfunct_eqdec (ef1 ef2 : external_function) : {ef1=ef2} + {~ef1=ef2}.

Set Implicit Arguments.

Definition ef_ext_spec (M Z : Type) :=
  external_specification M AST.external_function Z.

Definition spec_of
  (M Z : Type) (ef : AST.external_function) (spec : ef_ext_spec M Z) :=
  (ext_spec_pre spec ef, ext_spec_post spec ef).

Definition oval_inject j (v tv : option val) :=
  match v, tv with
    | None, None => True
    | Some v', Some tv' => Val.inject j v' tv'
    | _, _ => False
  end.

Module ExtSpecProperties.

Definition det (M E Z : Type) (spec : external_specification M E Z) :=
  forall ef (x x' : ext_spec_type spec ef) ge tys z vals m
         oty' ov' z' m' oty'' ov'' z'' m'',
  ext_spec_pre spec ef x ge tys vals z m ->
  ext_spec_post spec ef x ge oty' ov' z' m' ->
  ext_spec_pre spec ef x' ge tys vals z m ->
  ext_spec_post spec ef x' ge oty'' ov'' z'' m'' ->
  oty'=oty'' /\ ov'=ov'' /\ z'=z'' /\ m'=m''.

Record closed (Z : Type) (spec : ext_spec Z) :=
  { P_closed :
      forall ef (x : ext_spec_type spec ef) ge j tys vals z m tvals tm,
      ext_spec_pre spec ef x ge tys vals z m ->
      Val.inject_list j vals tvals ->
      Mem.inject j m tm ->
      ext_spec_pre spec ef x ge tys tvals z tm
  ; Q_closed :
      forall ef (x : ext_spec_type spec ef) ge j oty ov z m otv tm,
      ext_spec_post spec ef x ge oty ov z m ->
      oval_inject j ov otv ->
      Mem.inject j m tm ->
      ext_spec_post spec ef x ge oty otv z tm
  ; exit_closed :
      forall j ov z m otv tm,
      ext_spec_exit spec ov z m ->
      oval_inject j ov otv ->
      Mem.inject j m tm ->
      ext_spec_exit spec otv z tm }.

End ExtSpecProperties. *)

Require Import VST.sepcomp.step_lemmas.
(* VST.sepcomp.step_lemmas:
Require Import compcert.lib.Coqlib.
Require Import compcert.lib.Maps.

Require Import compcert.common.AST.
Require Import compcert.common.Values.

Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.semantics_lemmas.

Definition has_opttyp (v : option val) (t : option typ) :=
  match v, t with
    None, None => True
  | Some v, Some t => Val.has_type v t
  | _, _ => False
  end.

Section safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context {Hrel: nat -> M -> M -> Prop}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).

  Variable ge : G.

  Inductive safeN_ : nat -> Z -> C -> M -> Prop :=
  | safeN_0: forall z c m, safeN_ O z c m
  | safeN_step:
      forall n z c m c' m',
      corestep Hcore c m c' m' ->
      safeN_ n z c' m' ->
      safeN_ (S n) z c m
  | safeN_external:
      forall n z c m e args x,
      at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           after_external Hcore ret c m' = Some c' /\
           safeN_ n' z' c' m') ->
      safeN_ (S n) z c m
  | safeN_halted:
      forall n z c m i,
      halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      safeN_ n z c m.

  Definition corestep_fun  :=
       forall m q m1 q1 m2 q2 ,
       corestep Hcore q m q1 m1 ->
       corestep Hcore q m q2 m2 ->
       (q1, m1) = (q2, m2).

  Lemma safe_corestep_forward:
     corestep_fun ->
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ (S n) z c m -> safeN_ n z c' m'.

  Lemma safe_corestep_backward:
    forall c m c' m' n z,
    corestep Hcore c m c' m' -> safeN_ n z c' m' -> safeN_ (S n) z c m.

  Lemma safe_downward1 :
    forall n c m z,
      safeN_ (S n) z c m -> safeN_ n z c m.

  Lemma safe_downward :
    forall n n' c m z,
      le n' n ->
      safeN_ n z c m -> safeN_ n' z c m.

  Lemma safe_corestepN_forward:
    corestep_fun ->
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n + S n0) z c m ->
      safeN_ n z c' m'.

  Lemma safe_step'_back2 :
    forall
      {ora st m st' m' n},
      corestep Hcore st m st' m' ->
      safeN_ (n-1) ora st' m' ->
      safeN_ n ora st m.

  Lemma safe_corestepN_backward:
    forall z c m c' m' n n0,
      corestepN Hcore n0 c m c' m' ->
      safeN_ (n - n0) z c' m' ->
      safeN_ n z c m.

  Lemma convergent_controls_safe :
    forall m q1 q2,
      (at_external Hcore q1 m = at_external Hcore q2 m) ->
      (forall ret m q', after_external Hcore ret q1 m = Some q' ->
                      after_external Hcore ret q2 m = Some q') ->
      (halted Hcore q1 = halted Hcore q2) ->
      (forall q' m', corestep Hcore q1 m q' m' ->
                     corestep Hcore q2 m q' m') ->
      (forall n z, safeN_ n z q1 m -> safeN_ n z q2 m).

  Lemma wlog_safeN_gt0 : forall
    n z q m,
    (lt 0 n -> safeN_ n z q m) ->
    safeN_ n z q m.

End safety.

Section dry_safety.
  Context {G C M Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C M).
  Variable (Hspec:external_specification M external_function Z).
  Definition dry_safeN := @safeN_ G C M Z genv_symb (fun n' m m' => True) Hcore Hspec.
End dry_safety. *)

Require Import VST.veric.tycontext.
(* VST.veric.tycontext:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.

Require Import VST.veric.Clight_lemmas. 
Require Import VST.veric.align_mem.

Require Export VST.veric.lift.

Require Export VST.veric.mpred.

Fixpoint modifiedvars' (c: statement) (S: idset) : idset :=
 match c with
 | Sset id e => insert_idset id S
 | Sifthenelse _ c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Scall (Some id) _ _ => insert_idset id S
 | Sbuiltin (Some id) _ _ _ => insert_idset id S
 | Ssequence c1 c2 =>  modifiedvars' c1 (modifiedvars' c2 S)
 | Sloop c1 c2 => modifiedvars' c1 (modifiedvars' c2 S)
 | Sswitch e cs => modifiedvars_ls cs S
 | Slabel _ c => modifiedvars' c S
 | _ => S
 end
 with
 modifiedvars_ls (cs: labeled_statements) (S: idset) : idset :=
 match cs with
 | LSnil => S
 | LScons _ c ls => modifiedvars' c (modifiedvars_ls ls S)
 end.

Definition isOK {A} (P: Errors.res A) := match P with Errors.OK _ => true | _ => false end.

Lemma modifiedvars'_union:
 forall id c S,
  isSome ((modifiedvars' c S) ! id) <->
  (isSome ((modifiedvars' c idset0) ! id ) \/ isSome (S ! id))
with modifiedvars_ls_union:
 forall id c S,
  isSome ((modifiedvars_ls c S) ! id) <->
  (isSome ((modifiedvars_ls c idset0) ! id ) \/ isSome (S ! id)).

Definition modifiedvars (c: statement) (id: ident) :=
   isSome ((modifiedvars' c idset0) ! id).

Definition type_of_global (ge: Clight.genv) (b: block) : option type :=
  match Genv.find_var_info ge b with
  | Some gv => Some gv.(gvar_info)
  | None =>
      match Genv.find_funct_ptr ge b with
      | Some fd => Some(type_of_fundef fd)
      | None => None
      end
  end.

Definition filter_genv (ge: Clight.genv) : genviron :=
    Genv.find_symbol ge.

Definition make_tenv (te : Clight.temp_env) : tenviron := fun id => PTree.get id te.

Definition make_venv (te : Clight.env) : venviron := fun id => PTree.get id te.

Definition construct_rho ge ve te:= mkEnviron ge (make_venv ve) (make_tenv te) .

Definition empty_environ (ge: Clight.genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Inductive Annotation :=
  WeakAnnotation : (environ -> mpred) -> Annotation
| StrongAnnotation : (environ -> mpred) -> Annotation.

Inductive tycontext : Type :=
  mk_tycontext : forall (tyc_temps: PTree.t type)
                        (tyc_vars: PTree.t type)
                        (tyc_ret: type)
                        (tyc_globty: PTree.t type)
                        (tyc_globsp: PTree.t funspec)
                        (tyc_annot: PTree.t Annotation),
                             tycontext.

Definition empty_tycontext : tycontext :=
  mk_tycontext (PTree.empty _) (PTree.empty _) Tvoid
         (PTree.empty _)  (PTree.empty _) (PTree.empty _).

Definition temp_types (Delta: tycontext): PTree.t type :=
  match Delta with mk_tycontext a _ _ _ _ _ => a end.
Definition var_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ a _ _ _ _ => a end.
Definition ret_type (Delta: tycontext) : type :=
  match Delta with mk_tycontext _ _ a _ _ _ => a end.
Definition glob_types (Delta: tycontext) : PTree.t type :=
  match Delta with mk_tycontext _ _ _ a _ _ => a end.
Definition glob_specs (Delta: tycontext) : PTree.t funspec :=
  match Delta with mk_tycontext _ _ _ _ a _ => a end.
Definition annotations (Delta: tycontext) : PTree.t Annotation :=
  match Delta with mk_tycontext _ _ _ _ _ a => a end.

Definition make_tycontext_t (params: list (ident*type)) (temps : list(ident*type)) :=
fold_right (fun (param: ident*type) => PTree.set (fst param) (snd param))
 (fold_right (fun (temp : ident *type) tenv => let (id,ty):= temp in PTree.set id ty tenv)
  (PTree.empty type) temps) params.

Definition make_tycontext_v (vars : list (ident * type)) :=
 fold_right (fun (var : ident * type) venv => let (id, ty) := var in PTree.set id ty venv)
   (PTree.empty type) vars.

Definition make_tycontext_g (V: varspecs) (G: funspecs) :=
 (fold_right (fun (var : ident * funspec) => PTree.set (fst var) (type_of_funspec (snd var)))
      (fold_right (fun (v: ident * type) => PTree.set (fst v) (snd v))
         (PTree.empty _) V)
            G).

Definition make_tycontext_a (anns : list (ident * Annotation)) :=
 fold_right (fun (ia : ident * Annotation) aenv => let (id, a) := ia in PTree.set id a aenv)
   (PTree.empty Annotation) anns.

Definition make_tycontext (params: list (ident*type)) (temps: list (ident*type)) (vars: list (ident*type))
                       (return_ty: type)
                       (V: varspecs) (G: funspecs) (A: list (ident*Annotation)):  tycontext :=
 mk_tycontext
   (make_tycontext_t params temps)
   (make_tycontext_v vars)
   return_ty
   (make_tycontext_g V G)
   (make_tycontext_s G)
   (make_tycontext_a A).

Definition func_tycontext' (func: function) (Delta: tycontext) : tycontext :=
 mk_tycontext
   (make_tycontext_t (fn_params func) (fn_temps func))
   (make_tycontext_v (fn_vars func))
   (fn_return func)
   (glob_types Delta)
   (glob_specs Delta)
   (annotations Delta).

Definition func_tycontext (func: function) (V: varspecs) (G: funspecs) (A:list (ident * Annotation)): tycontext :=
  make_tycontext (func.(fn_params)) (func.(fn_temps)) (func.(fn_vars)) (func.(fn_return)) V G A.

Definition nofunc_tycontext (V: varspecs) (G: funspecs) : tycontext :=
   make_tycontext nil nil nil Tvoid V G nil.

Ltac try_false :=
try  solve[exists false; rewrite orb_false_r; eauto].

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Definition sub_option {A} (x y: option A) :=
 match x with Some x' => y = Some x' | None => True end.

Lemma sub_option_eqv: forall {A} (x y: option A),
  x = y <-> sub_option x y /\ sub_option y x.

Lemma sub_option_refl: forall {A} (x: option A), sub_option x x.

Lemma sub_option_trans: forall {A} (x y z: option A), sub_option x y -> sub_option y z -> sub_option x z.

Lemma sub_option_spec: forall {A} (T1 T2: PTree.t A),

Definition Annotation_sub (A1 A2: option Annotation):Prop := 
  match A1, A2 with
    _, None => True
  | Some (StrongAnnotation _), Some (WeakAnnotation _) => True
  | Some (StrongAnnotation X), Some (StrongAnnotation Y) => X=Y 
  | X, Y => X=Y 
  end.

Lemma Annotation_sub_trans a1 a2 a3: Annotation_sub a1 a2 -> 
      Annotation_sub a2 a3 -> Annotation_sub a1 a3.

Lemma Annotation_sub_refl a: Annotation_sub a a. 

Lemma Annotation_sub_antisymm a b: Annotation_sub a b -> Annotation_sub b a -> a=b.

Definition tycontext_sub (Delta Delta' : tycontext) : Prop :=
 (forall id, match (temp_types Delta) ! id,  (temp_types Delta') ! id with
                 | None, _ => True
                 | Some t, None => False
                 | Some t, Some t' => t=t'
                end)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, sub_option ((glob_types Delta) ! id) ((glob_types Delta') ! id))
 /\ (forall id, sub_option ((glob_specs Delta) ! id) ((glob_specs Delta') ! id))
 /\ (forall id, Annotation_sub ((annotations Delta) ! id) ((annotations Delta') ! id)).

Definition tycontext_eqv (Delta Delta' : tycontext) : Prop :=
 (forall id, (temp_types Delta) ! id = (temp_types Delta') ! id)
 /\ (forall id, (var_types Delta) ! id = (var_types Delta') ! id)
 /\ ret_type Delta = ret_type Delta'
 /\ (forall id, (glob_types Delta) ! id = (glob_types Delta') ! id)
 /\ (forall id, (glob_specs Delta) ! id = (glob_specs Delta') ! id)
 /\ (forall id, (annotations Delta) ! id = (annotations Delta') ! id).

Lemma tycontext_eqv_spec: forall Delta Delta',
  tycontext_eqv Delta Delta' <-> tycontext_sub Delta Delta' /\ tycontext_sub Delta' Delta.

Lemma tycontext_sub_refl:
 forall Delta, tycontext_sub Delta Delta.

Lemma tycontext_sub_trans:
 forall Delta1 Delta2 Delta3,
  tycontext_sub Delta1 Delta2 -> tycontext_sub Delta2 Delta3 ->
  tycontext_sub Delta1 Delta3.

Definition binop_stable cenv op a1 a2 : bool :=
match op with
  | Cop.Oadd => match Cop.classify_add (typeof a1) (typeof a2) with
                    | Cop.add_case_pi t _ => complete_type cenv t
                    | Cop.add_case_ip _ t => complete_type cenv t
                    | Cop.add_case_pl t => complete_type cenv t
                    | Cop.add_case_lp t => complete_type cenv t
                    | Cop.add_default => true
            end
  | Cop.Osub => match Cop.classify_sub (typeof a1) (typeof a2) with
                    | Cop.sub_case_pi t _ => complete_type cenv t
                    | Cop.sub_case_pl t => complete_type cenv t
                    | Cop.sub_case_pp t => complete_type cenv t
                    | Cop.sub_default => true
            end
  | _ => true
  end.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma binop_stable_stable: forall b e1 e2,
  binop_stable env b e1 e2 = true ->
  binop_stable env' b e1 e2 = true.

Lemma Cop_Sem_add_ptr_int_stable ty si u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_int env ty si u v =

Lemma Cop_Sem_add_ptr_long_stable ty u v (H:complete_type env ty = true):
  Cop.sem_add_ptr_long env ty u v =

Lemma Cop_sem_binary_operation_stable:
  forall b v1 e1 v2 e2 m,
  binop_stable env b e1 e2 = true ->
  Cop.sem_binary_operation env b v1 (typeof e1) v2 (typeof e2) m =

Lemma field_offset_stable: forall i id co ofs,
  composite_env_consistent env ->
  env ! i = Some co ->
  field_offset env id (co_members co) = Errors.OK ofs ->

End STABILITY.

Section TYCON_SUB.
Variables Delta Delta': tycontext.
Hypothesis extends: tycontext_sub Delta Delta'.

Lemma func_tycontext'_sub: forall f,
  tycontext_sub (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_SUB.

Section TYCON_EQUIV.

Variable Delta Delta': tycontext.
Hypothesis equiv: tycontext_eqv Delta Delta'.

Lemma func_tycontext'_eqv: forall f,
  tycontext_eqv (func_tycontext' f Delta) (func_tycontext' f Delta').

End TYCON_EQUIV.

Lemma tycontext_eqv_symm:
  forall Delta Delta', tycontext_eqv Delta Delta' ->  tycontext_eqv Delta' Delta.

Lemma tycontext_eqv_sub:
  forall Delta Delta', tycontext_eqv Delta Delta' ->
         tycontext_sub Delta Delta'.

Record ret_assert : Type := {
 RA_normal: environ->mpred;
 RA_break: environ->mpred;
 RA_continue: environ->mpred;
 RA_return: option val -> environ->mpred
}.

Lemma modifiedvars_Slabel l c: modifiedvars (Slabel l c) = modifiedvars c.

Lemma modifiedvars_computable: forall c (te1 te2: Map.t val), exists te,

Lemma modifiedvars_Sifthenelse b c1 c2 id: modifiedvars (Sifthenelse b c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Sloop c1 c2 id: modifiedvars (Sloop c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_Ssequence c1 c2 id: modifiedvars (Ssequence c1 c2) id <-> modifiedvars c1 id \/ modifiedvars c2 id.

Lemma modifiedvars_ls_eq: forall sl, modifiedvars_ls sl = modifiedvars' (seq_of_labeled_statement sl).

Lemma modifiedvars_Sswitch e sl n id: modifiedvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) id -> modifiedvars (Sswitch e sl) id. *)

Require Import VST.veric.expr2.
(* VST.veric.expr2:
Require Import VST.msl.msl_standard.
Require Import VST.veric.Clight_base.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.tycontext.
Require Import VST.veric.Clight_lemmas.
Require Export VST.veric.expr.

Require Import VST.veric.mpred.

Lemma neutral_cast_lemma: forall t1 t2 v,
  is_neutral_cast t1 t2 = true ->
  tc_val t1 v -> eval_cast t1 t2 v = v.

Lemma neutral_cast_subsumption: forall t1 t2 v,
  is_neutral_cast t1 t2 = true ->
  tc_val t1 v -> tc_val t2 v.

Lemma neutral_cast_subsumption': forall t1 t2 v,
  is_neutral_cast (implicit_deref t1) t2 = true ->
  tc_val t1 v -> tc_val t2 v.

Definition denote_tc_iszero v : mpred :=
         match v with
         | Vint i => prop (is_true (Int.eq i Int.zero))
         | Vlong i => prop (is_true (Int64.eq i Int64.zero))
         | _ => FF
         end.

Definition denote_tc_nonzero v : mpred :=
         match v with
         | Vint i => prop (i <> Int.zero)
         | Vlong i =>prop (i <> Int64.zero)
         | _ => FF end.

Definition denote_tc_igt i v : mpred :=
     match v with
     | Vint i1 => prop (Int.unsigned i1 < Int.unsigned i)
     | _ => FF
     end.

Definition denote_tc_lgt l v : mpred :=
     match v with
     | Vlong l1 => prop (Int64.unsigned l1 < Int64.unsigned l)
     | _ => FF
     end.

Definition Zoffloat (f:float): option Z := 
  match f with
    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>
       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)
    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))
    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))
    | Fappli_IEEE.B754_zero _ => Some 0
    | _ => None
  end.  

Definition Zofsingle (f: float32): option Z := 
  match f with
    | Fappli_IEEE.B754_finite s m (Zpos e) _ =>
       Some (Fcore_Zaux.cond_Zopp s (Zpos m) * Zpower_pos 2 e)
    | Fappli_IEEE.B754_finite s m 0 _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m))
    | Fappli_IEEE.B754_finite s m (Zneg e) _ => Some (Fcore_Zaux.cond_Zopp s (Zpos m / Zpower_pos 2 e))
    | Fappli_IEEE.B754_zero _ => Some 0
    | _ => None
  end.  

Definition denote_tc_Zge z v : mpred :=
          match v with
                     | Vfloat f => match Zoffloat f with
                                    | Some n => prop (z >= n)
                                    | None => FF
                                   end
                     | Vsingle f => match Zofsingle f with
                                    | Some n => prop (z >= n)
                                    | None => FF
                                   end
                     | _ => FF
                  end.

Definition denote_tc_Zle z v : mpred :=
          match v with
                     | Vfloat f => match Zoffloat f with
                                    | Some n => prop (z <= n)
                                    | None => FF
                                   end
                     | Vsingle f => match Zofsingle f with
                                    | Some n => prop (z <= n)
                                    | None => FF
                                   end
                     | _ => FF
                  end.

Definition sameblock v1 v2 : bool :=
         match v1, v2 with
          | Vptr b1 _, Vptr b2 _ => peq b1 b2
          | _, _ => false
         end.

Definition denote_tc_samebase v1 v2 : mpred :=
       prop (is_true (sameblock v1 v2)).

Definition denote_tc_nodivover v1 v2 : mpred :=
match v1, v2 with
          | Vint n1, Vint n2 => prop (~(n1 = Int.repr Int.min_signed /\ n2 = Int.mone))
          | Vlong n1, Vlong n2 => prop (~(n1 = Int64.repr Int64.min_signed /\ n2 = Int64.mone))
          | Vint n1, Vlong n2 => TT
          | Vlong n1, Vint n2 => prop (~ (n1 = Int64.repr Int64.min_signed  /\ n2 = Int.mone))
          | _ , _ => FF
        end.

Definition denote_tc_nosignedover (op: Z->Z->Z) v1 v2 : mpred :=
 match v1,v2 with
 | Vint n1, Vint n2 => 
   prop (Int.min_signed <= op (Int.signed n1) (Int.signed n2) <= Int.max_signed)
 | Vlong n1, Vlong n2 =>
   prop (Int64.min_signed <= op (Int64.signed n1) (Int64.signed n2) <= Int64.max_signed)
 | Vint n1, Vlong n2 =>
   prop (Int64.min_signed <= op (Int.signed n1) (Int64.signed n2) <= Int64.max_signed)
 | Vlong n1, Vint n2 =>
   prop (Int64.min_signed <= op (Int64.signed n1) (Int.signed n2) <= Int64.max_signed)
 | _, _ => FF
 end.

Definition denote_tc_initialized id ty rho : mpred :=
    prop (exists v, Map.get (te_of rho) id = Some v
               /\ tc_val ty v).

Definition denote_tc_isptr v : mpred :=
  prop (isptr v).

Definition denote_tc_isint v : mpred :=
  prop (is_int I32 Signed v).

Definition denote_tc_islong v : mpred :=
  prop (is_long v).

Definition test_eq_ptrs v1 v2 : mpred :=
  if sameblock v1 v2
  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))
  else (andp (valid_pointer v1) (valid_pointer v2)).

Definition test_order_ptrs v1 v2 : mpred :=
  if sameblock v1 v2
  then (andp (weak_valid_pointer v1) (weak_valid_pointer v2))
  else FF.

Definition denote_tc_test_eq v1 v2 : mpred :=
 match v1, v2 with
 | Vint i, Vint j => 
     if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))
 | Vlong i, Vlong j => 
     if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF
 | Vint i, Vptr _ _ =>
      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v2)
 | Vlong i, Vptr _ _ =>
      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v2) else FF
 | Vptr _ _, Vint i =>
      if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (weak_valid_pointer v1)
 | Vptr _ _, Vlong i =>
      if Archi.ptr64 then andp (prop (i = Int64.zero)) (weak_valid_pointer v1) else FF
 | Vptr _ _, Vptr _ _ =>
      test_eq_ptrs v1 v2
 | _, _ => FF
 end.

Definition denote_tc_test_order v1 v2 : mpred :=
 match v1, v2 with
 | Vint i, Vint j => if Archi.ptr64 then FF else andp (prop (i = Int.zero)) (prop (j = Int.zero))
 | Vlong i, Vlong j => if Archi.ptr64 then andp (prop (i = Int64.zero)) (prop (j = Int64.zero)) else FF
 | Vptr _ _, Vptr _ _ =>
      test_order_ptrs v1 v2
 | _, _ => FF
 end.

Definition typecheck_error (e: tc_error) : Prop := False.

Fixpoint denote_tc_assert {CS: compspecs}(a: tc_assert) : environ -> mpred :=
  match a with
  | tc_FF msg => `(prop (typecheck_error msg))
  | tc_TT => `TT
  | tc_andp' b c => `andp (denote_tc_assert b) (denote_tc_assert c)
  | tc_orp' b c => `orp (denote_tc_assert b) (denote_tc_assert c)
  | tc_nonzero' e => `denote_tc_nonzero (eval_expr e)
  | tc_isptr e => `denote_tc_isptr (eval_expr e)
  | tc_isint e => `denote_tc_isint (eval_expr e)
  | tc_islong e => `denote_tc_islong (eval_expr e)
  | tc_test_eq' e1 e2 => `denote_tc_test_eq (eval_expr e1) (eval_expr e2)
  | tc_test_order' e1 e2 => `denote_tc_test_order (eval_expr e1) (eval_expr e2)
  | tc_ilt' e i => `(denote_tc_igt i) (eval_expr e)
  | tc_llt' e l => `(denote_tc_lgt l) (eval_expr e)
  | tc_Zle e z => `(denote_tc_Zge z) (eval_expr e)
  | tc_Zge e z => `(denote_tc_Zle z) (eval_expr e)
  | tc_samebase e1 e2 => `denote_tc_samebase (eval_expr e1) (eval_expr e2)
  | tc_nodivover' v1 v2 => `denote_tc_nodivover (eval_expr v1) (eval_expr v2)
  | tc_initialized id ty => denote_tc_initialized id ty
  | tc_iszero' e => `denote_tc_iszero (eval_expr e)
  | tc_nosignedover op e1 e2 => `(denote_tc_nosignedover op) (eval_expr e1) (eval_expr e2)
 end.

Lemma and_False: forall x, (x /\ False) = False.

Lemma and_True: forall x, (x /\ True) = x.

Lemma True_and: forall x, (True /\ x) = x.

Lemma False_and: forall x, (False /\ x) = False.

Lemma tc_andp_sound : forall {CS: compspecs} a1 a2 rho m,
    denote_tc_assert  (tc_andp a1 a2) rho m <->
    denote_tc_assert  (tc_andp' a1 a2) rho m.

Lemma denote_tc_assert_andp:
  forall {CS: compspecs} a b rho, denote_tc_assert (tc_andp a b) rho =
             andp (denote_tc_assert a rho) (denote_tc_assert b rho).

Lemma neutral_isCastResultType:
  forall {CS: compspecs} t t' v rho,
   is_neutral_cast t' t = true ->
   forall m, denote_tc_assert (isCastResultType t' t v) rho m.

Lemma is_true_e: forall b, is_true b -> b=true.

Lemma tc_bool_e: forall {CS: compspecs} b a rho m,
  app_pred (denote_tc_assert (tc_bool b a) rho) m ->
  b = true. *)

Require Import VST.veric.expr_lemmas.
(* VST.veric.expr_lemmas:
Require Import VST.veric.Clight_base.
Require Import VST.msl.msl_standard.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.Clight_lemmas.
Require Import VST.veric.mpred.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Export VST.veric.environ_lemmas.
Require Import VST.veric.binop_lemmas2.
Require Import VST.veric.binop_lemmas3.
Require Import VST.veric.binop_lemmas.
Require Import VST.veric.binop_lemmas4.
Require Import VST.veric.expr_lemmas2.
Require Export VST.veric.expr_lemmas3.
Require Export VST.veric.expr_lemmas4.
Require Import VST.veric.juicy_mem.
Import Cop.
Import Cop2.
Import Clight_Cop2.

Lemma tc_bool_val:
  forall v t,
       tc_val t v ->
       bool_type t = true ->
      exists b, strict_bool_val v t = Some b.

Lemma bool_val_strict: forall t v b, tc_val t v -> bool_type t = true -> bool_val t v = Some b ->
  strict_bool_val v t = Some b.

Lemma bool_val_Cop: forall t v m b b', bool_val t v = Some b -> Cop.bool_val v t m = Some b' ->

Lemma map_ptree_rel : forall id v te, Map.set id v (make_tenv te) = make_tenv (PTree.set id v te).

Lemma cast_exists : forall {CS: compspecs} Delta e2 t rho phi
(TC: typecheck_environ Delta rho),
denote_tc_assert (typecheck_expr Delta e2) rho phi ->
denote_tc_assert (isCastResultType (typeof e2) t e2)
  rho phi ->
sem_cast (typeof e2) t (eval_expr e2 rho)  =
Some (force_val (sem_cast (typeof e2) t (eval_expr e2 rho))).

Definition func_tycontext_t_denote :=
forall p t id ty ,  list_norepet (map fst p ++ map fst t ) ->
((make_tycontext_t p t) ! id = Some ty <-> (In (id,ty) p \/ In (id,ty) t)).

Definition func_tycontext_v_denote :=
forall v id ty, list_norepet (map fst v) ->
((make_tycontext_v v) ! id = Some ty <-> In (id,ty) v).

Lemma func_tycontext_v_sound : func_tycontext_v_denote.

Lemma set_inside : forall i0 t1 t p id,
list_disjoint (map fst p) (i0 :: map fst t) ->
(fold_right
          (fun param : ident * type =>
           PTree.set (fst param) (snd param, true))

Lemma func_tycontext_t_sound : func_tycontext_t_denote.

Definition cast_no_val_change (from: type)(to:type) : bool :=
match from, to with
| Tint _ _ _, Tint I32 _ _ => true
| Tpointer _ _, Tpointer _ _ => 
    eqb_type from to || 
    negb (eqb_type from int_or_ptr_type) && 
    negb (eqb_type to int_or_ptr_type)
| Tfloat F64 _ , Tfloat F64 _ => true
| Tfloat F32 _ , Tfloat F32 _ => true
| _, _ => false
end.

Lemma cast_no_change : forall v from to m,
tc_val from v ->
is_true (cast_no_val_change from to) ->
Cop.sem_cast v from to m = Some v.

Lemma tc_exprlist_length : forall {CS: compspecs} Delta tl el rho phi,
denote_tc_assert (typecheck_exprlist Delta tl el) rho phi ->
length tl = length el.

Lemma neutral_cast_tc_val : forall {CS: compspecs} e t rho phi Delta,
true = is_neutral_cast (implicit_deref (typeof e)) t ->
denote_tc_assert (isCastResultType (implicit_deref (typeof e)) t  e) rho phi ->
denote_tc_assert (typecheck_expr Delta e) rho phi ->
typecheck_environ Delta rho ->
tc_val t (eval_expr e rho).

Opaque Int.repr.

Definition typecheck_tid_ptr_compare
Delta id :=
match (temp_types Delta) ! id with
| Some t => is_int_type t
| None => false
end.

Lemma typecheck_tid_ptr_compare_sub:
   forall Delta Delta',
    tycontext_sub Delta Delta' ->
    forall id, typecheck_tid_ptr_compare Delta id = true ->
                typecheck_tid_ptr_compare Delta' id = true.

Lemma int64_eq_e:
 forall i j, Int64.eq i j = true -> i=j.

Lemma tc_val_sem_cast:
  forall {CS: compspecs} t2 e2 rho phi Delta,
      typecheck_environ Delta rho ->
      denote_tc_assert (typecheck_expr Delta e2) rho phi ->
      denote_tc_assert (isCastResultType (typeof e2) t2  e2) rho phi ->
      tc_val t2 (force_val (sem_cast (typeof e2) t2 (eval_expr e2 rho))). *)

Require Import VST.veric.juicy_extspec.
(* VST.veric.juicy_extspec:
Require Import VST.veric.juicy_base.
Require Import VST.sepcomp.semantics.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.shares.
Require Import VST.veric.juicy_safety.
Require Import VST.veric.juicy_mem. 

Require Import VST.veric.ghost_PCM. 
Require Import VST.veric.own. 

Require Import VST.veric.age_to_resource_at.

Local Open Scope nat_scope.
Local Open Scope pred.

Record juicy_ext_spec (Z: Type) := {
  JE_spec:> external_specification juicy_mem external_function Z;
  JE_pre_hered: forall e t ge_s typs args z, hereditary age (ext_spec_pre JE_spec e t ge_s typs args z);
  JE_post_hered: forall e t ge_s tret rv z, hereditary age (ext_spec_post JE_spec e t ge_s tret rv z);
  JE_exit_hered: forall rv z, hereditary age (ext_spec_exit JE_spec rv z)
}.

Class OracleKind := {
  OK_ty : Type;
  OK_spec: juicy_ext_spec OK_ty
}.

Definition void_spec T : external_specification juicy_mem external_function T :=
    Build_external_specification
      juicy_mem external_function T
      (fun ef => False)
      (fun ef Hef ge tys vl m z => False)
      (fun ef Hef ge ty vl m z => False)
      (fun rv m z => False).

Definition ok_void_spec (T : Type) : OracleKind.

Definition j_initial_core {C} (csem: @CoreSemantics C mem)
     (n: nat) (m: juicy_mem) (q: C) (m': juicy_mem) (v: val) (args: list val) 
     : Prop :=
  m' = m /\
  semantics.initial_core csem n (m_dry m) q (m_dry m') v args.

Definition j_at_external {C} (csem: @CoreSemantics C mem)
   (q: C) (jm: juicy_mem) : option (external_function * list val) :=
   semantics.at_external csem q (m_dry jm).

Definition j_after_external {C} (csem: @CoreSemantics C mem)
    (ret: option val) (q: C) (jm: juicy_mem) :=
   semantics.after_external csem ret q (m_dry jm).

Definition jstep {C} (csem: @CoreSemantics C mem)
  (q: C) (jm: juicy_mem) (q': C) (jm': juicy_mem) : Prop :=
 corestep csem q (m_dry jm) q' (m_dry jm') /\ 
 resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm') /\
 level jm = S (level jm') /\
 ghost_of (m_phi jm') = ghost_approx jm' (ghost_of (m_phi jm)).

Definition j_halted {C} (csem: @CoreSemantics C mem)
       (c: C) (i: int): Prop :=
     halted csem c i.

Lemma jstep_not_at_external {C} (csem: @CoreSemantics C mem):
  forall m q m' q', jstep csem q m q' m' -> at_external csem q (m_dry m) = None.

Lemma jstep_not_halted  {C} (csem: @CoreSemantics C mem):
  forall m q m' q' i, jstep csem q m q' m' -> ~j_halted csem q i.

Definition juicy_core_sem
  {C} (csem: @CoreSemantics C mem) :
   @CoreSemantics C juicy_mem :=
  @Build_CoreSemantics _ juicy_mem
    (j_initial_core csem)
    (j_at_external csem)
    (j_after_external csem)
    (j_halted csem)
    (jstep csem)
    (jstep_not_halted csem)
    (jstep_not_at_external csem)
.

Section upd_exit.
  Context {Z : Type}.
  Variable spec : juicy_ext_spec Z.

  Definition upd_exit' (Q_exit : option val -> Z -> juicy_mem -> Prop) :=
  {| ext_spec_type := ext_spec_type spec
   ; ext_spec_pre := ext_spec_pre spec
   ; ext_spec_post := ext_spec_post spec
   ; ext_spec_exit := Q_exit |}.

  Definition upd_exit'' (ef : external_function) (x : ext_spec_type spec ef) ge :=
    upd_exit' (ext_spec_post spec ef x ge (sig_res (ef_sig ef))).

  Program Definition upd_exit {ef : external_function} (x : ext_spec_type spec ef) ge :=
    Build_juicy_ext_spec _ (upd_exit'' _ x ge) _ _ _.
End upd_exit.

Obligation Tactic := Tactics.program_simpl.

Program Definition juicy_mem_op (P : pred rmap) : pred juicy_mem :=
  fun jm => P (m_phi jm).

Lemma age_resource_decay:
   forall b jm1 jm2 jm1' jm2',
        resource_decay b jm1 jm2 ->
        age jm1 jm1' -> age jm2 jm2' ->
        level jm1 = S (level jm2) ->
        resource_decay b jm1' jm2'.

Lemma necR_PURE' phi0 phi k p adr :
  necR phi0 phi ->
  phi @ adr = PURE k p ->
  
  exists pp, phi0 @ adr = PURE k pp.

Definition jm_update m m' := m_dry m' = m_dry m /\ level m' = level m /\
  resource_at (m_phi m') = resource_at (m_phi m).

Lemma jm_update_age: forall m1 m2 m1', jm_update m1 m2 -> age m1 m1' ->
  exists m2', jm_update m1' m2' /\ age m2 m2'.

Definition has_ext {Z} (ora : Z) : pred rmap := @own (ext_PCM _) 0 (Some (Tsh, Some ora), None) NoneP.

Definition jm_bupd {Z} (ora : Z) P m := forall C : ghost,
  
  join_sub (Some (ext_ref ora, NoneP) :: nil) C ->
  joins (ghost_of (m_phi m)) (ghost_approx m C) ->
  exists m' : juicy_mem, joins (ghost_of (m_phi m')) ((ghost_approx m) C) /\
    jm_update m m' /\ P m'.

Lemma jm_bupd_intro: forall {Z} (ora : Z) (P : juicy_mem -> Prop) m, P m -> jm_bupd ora P m.

Section juicy_safety.
  Context {G C Z:Type}.
  Context {genv_symb: G -> injective_PTree block}.
  Context (Hcore:@CoreSemantics C mem).
  Variable (Hspec : juicy_ext_spec Z).
  Variable ge : G.

  Definition Hrel n' m m' :=
    n' = level m' /\
    (level m' < level m)%nat /\
    pures_eq (m_phi m) (m_phi m').

  Inductive jsafeN_:
    nat -> Z -> C -> juicy_mem -> Prop :=
  | jsafeN_0: forall z c m, jsafeN_ O z c m
  | jsafeN_step:
      forall n z c m c' m',
      jstep Hcore c m c' m' ->
      jm_bupd z (jsafeN_ n z c') m' ->
      jsafeN_ (S n) z c m
  | jsafeN_external:
      forall n z c m e args x,
      j_at_external Hcore c m = Some (e,args) ->
      ext_spec_pre Hspec e x (genv_symb ge) (sig_args (ef_sig e)) args z m ->
      (forall ret m' z' n'
         (Hargsty : Val.has_type_list args (sig_args (ef_sig e)))
         (Hretty : has_opttyp ret (sig_res (ef_sig e))),
         (n' <= n)%nat ->
         Hrel n' m m' ->
         ext_spec_post Hspec e x (genv_symb ge) (sig_res (ef_sig e)) ret z' m' ->
         exists c',
           semantics.after_external Hcore ret c (m_dry m') = Some c' /\
           jm_bupd z' (jsafeN_ n' z' c') m') ->
      jsafeN_ (S n) z c m
  | jsafeN_halted:
      forall n z c m i,
      semantics.halted Hcore c i ->
      ext_spec_exit Hspec (Some (Vint i)) z m ->
      jsafeN_ n z c m.

  Lemma jsafe_corestep_backward:
    forall c m c' m' n z,
    jstep Hcore c m c' m' ->
    jsafeN_ n z c' m' -> jsafeN_ (S n) z c m.

  Lemma jsafe_downward1 :
    forall n c m z,
      jsafeN_ (S n) z c m -> jsafeN_ n z c m.

  Lemma jsafe_downward :
    forall n n' c m z,
      le n' n ->
      jsafeN_ n z c m -> jsafeN_ n' z c m.

  Lemma jsafe_step'_back2 :
    forall
      {ora st m st' m' n},
      jstep Hcore st m st' m' ->
      jsafeN_ (n-1) ora st' m' ->
      jsafeN_ n ora st m.

  Lemma jsafe_corestepN_backward:
    forall z c m c' m' n n0,
      semantics_lemmas.corestepN (juicy_core_sem Hcore) n0 c m c' m' ->

  Lemma convergent_controls_jsafe :
    forall m q1 q2,
      (j_at_external Hcore q1 m = j_at_external Hcore q2 m) ->
      (forall ret m q', semantics.after_external Hcore ret q1 m = Some q' ->

  Lemma wlog_jsafeN_gt0 : forall
    n z q m,
    (lt 0 n -> jsafeN_ n z q m) ->
    jsafeN_ n z q m.

Lemma make_join_ext : forall (ora : Z) a c n,
  join_sub (Some (ext_ref ora, NoneP) :: nil) c ->
  joins (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) c) ->
  join_sub (Some (ext_ref ora, NoneP) :: nil) (make_join a c).

Lemma age_safe:
  forall jm jm0, age jm0 jm ->
  forall ora c,
   jsafeN_ (level jm0) ora c jm0 ->
   jsafeN_ (level jm) ora c jm.

End juicy_safety.

Lemma juicy_core_sem_preserves_corestep_fun
  {C} (csem: @CoreSemantics C mem) :
  corestep_fun csem ->
  corestep_fun (juicy_core_sem csem). *)

Require Import VST.veric.semax.
(* VST.veric.semax:
Require Import VST.veric.juicy_base.
Require Import VST.veric.juicy_mem VST.veric.juicy_mem_lemmas VST.veric.juicy_mem_ops.
Require Import VST.veric.res_predicates.
Require Import VST.veric.extend_tc.
Require Import VST.veric.Clight_seplog.
Require Import VST.veric.Clight_assert_lemmas.
Require Import VST.veric.Clight_new.
Require Import VST.veric.Clight_lemmas.
Require Import VST.sepcomp.extspec.
Require Import VST.sepcomp.step_lemmas.
Require Import VST.veric.juicy_safety.
Require Import VST.veric.juicy_extspec.
Require Import VST.veric.tycontext.
Require Import VST.veric.expr2.
Require Import VST.veric.expr_lemmas.
Require Import VST.veric.own.

Local Open Scope nat_scope.
Local Open Scope pred.

Definition closed_wrt_modvars c (F: assert) : Prop :=
    closed_wrt_vars (modifiedvars c) F.

Definition genv_symb_injective {F V} (ge: Genv.t F V) : extspec.injective_PTree block.

Definition jsafeN {Z} (Hspec : juicy_ext_spec Z) (ge: genv) :=
  @jsafeN_ genv _ _ genv_symb_injective 
               (cl_core_sem ge) Hspec ge.

Lemma ext_join_approx : forall {Z} (z : Z) n g,
  joins g (Some (ghost_PCM.ext_ref z, NoneP) :: nil) ->

Lemma ext_join_unapprox : forall {Z} (z : Z) n g,
  joins (ghost_fmap (approx n) (approx n) g) (Some (ghost_PCM.ext_ref z, NoneP) :: nil) ->

Program Definition ext_compat {Z} (ora : Z) : mpred :=
  fun w => joins (ghost_of w) (Some (ghost_PCM.ext_ref ora, NoneP) :: nil).

Program Definition assert_safe
     (Espec : OracleKind)
     (ge: genv) ve te (ctl: cont) : assert :=
  fun rho => bupd (fun w => forall ora (jm:juicy_mem),
       ext_compat ora w ->
       rho = construct_rho (filter_genv ge) ve te ->
       m_phi jm = w ->
             jsafeN (@OK_spec Espec) ge (level w) ora (State ve te ctl) jm).

Definition list2opt {T: Type} (vl: list T) : option T :=
 match vl with nil => None | x::_ => Some x end.

Definition match_venv (ve: venviron) (vars: list (ident * type)) :=
 forall id, match ve id with Some (b,t) => In (id,t) vars | _ => True end.

Definition guard_environ (Delta: tycontext) (f: option function) (rho: environ) : Prop :=
   typecheck_environ Delta rho /\
  match f with
  | Some f' => match_venv (ve_of rho) (fn_vars f')
                /\ ret_type Delta = fn_return f'
  | None => True
  end.

Lemma guard_environ_e1:
   forall Delta f rho, guard_environ Delta f rho ->
     typecheck_environ Delta rho.

Definition _guard (Espec : OracleKind)
    (gx: genv) (Delta: tycontext) (P : assert) (f: option function) (ctl: cont) : pred nat :=
     ALL tx : Clight.temp_env, ALL vx : env,
          let rho := construct_rho (filter_genv gx) vx tx in
          !! guard_environ Delta f rho
                  && P rho && funassert Delta rho
             >=> assert_safe Espec gx vx tx ctl rho.

Definition guard (Espec : OracleKind)
    (gx: genv) (Delta: tycontext) (P : assert)  (ctl: cont) : pred nat :=
  _guard Espec gx Delta P (current_function ctl) ctl.

Definition zap_fn_return (f: function) : function :=
 mkfunction Tvoid f.(fn_callconv) f.(fn_params) f.(fn_vars) f.(fn_temps) f.(fn_body).

Definition exit_cont (ek: exitkind) (vl: option val) (k: cont) : cont :=
  match ek with
  | EK_normal => k
  | EK_break => break_cont k
  | EK_continue => continue_cont k
  | EK_return =>
         match vl, call_cont k with
         | Some v, Kcall (Some x) f ve te :: k' =>
                    Kseq (Sreturn None) :: Kcall None (zap_fn_return f) ve (PTree.set x v te) :: k'
         | _,_ => Kseq (Sreturn None) :: call_cont k
         end
   end.

Definition rguard (Espec : OracleKind)
    (gx: genv) (Delta: tycontext)  (R : ret_assert) (ctl: cont) : pred nat :=
  ALL ek: exitkind, ALL vl: option val,
    _guard Espec gx Delta (proj_ret_assert R ek vl) (current_function ctl) (exit_cont ek vl ctl).

Record semaxArg :Type := SemaxArg {
 sa_Delta: tycontext;
 sa_P: assert;
 sa_c: statement;
 sa_R: ret_assert
}.

Definition ext_spec_pre' (Espec: OracleKind) (ef: external_function)
   (x': ext_spec_type OK_spec ef) (ge_s: injective_PTree block)
   (ts: list typ) (args: list val) (z: OK_ty) : pred juicy_mem :=
  exist (hereditary age)
     (ext_spec_pre OK_spec ef x' ge_s ts args z)
     (JE_pre_hered _ _ _ _ _ _ _ _).

Program Definition ext_spec_post' (Espec: OracleKind)
   (ef: external_function) (x': ext_spec_type OK_spec ef) (ge_s: injective_PTree block)
   (tret: option typ) (ret: option val) (z: OK_ty) : pred juicy_mem :=
  exist (hereditary age)
   (ext_spec_post OK_spec ef x' ge_s tret ret z)
     (JE_post_hered _ _ _ _ _ _ _ _).

Definition juicy_mem_pred (P : pred rmap) (jm: juicy_mem): pred nat :=
     # diamond fashionM (exactly (m_phi jm) && P).

Fixpoint make_ext_args (gx: genviron) (ids: list ident) (vl: list val)  :=
  match ids, vl with
  | id::ids', v::vl' => env_set (make_ext_args gx ids' vl') id v
  | _, v::vl' => env_set (make_ext_args gx ids vl') 1%positive v
  | _, _ => mkEnviron gx (Map.empty _) (Map.empty _)
 end.

Definition make_ext_rval  (gx: genviron) (v: option val):=
  match v with
  | Some v' =>  mkEnviron gx (Map.empty _)
                              (Map.set 1%positive v' (Map.empty _))
  | None => mkEnviron gx (Map.empty _) (Map.empty _)
  end.

Definition semax_external
  (Hspec: OracleKind) (ids: list ident) ef
  (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)):
        pred nat :=
 ALL gx: genv, ALL Ts: list Type,
 ALL x: (dependent_type_functor_rec Ts A (pred rmap)),
   |>  ALL F: pred rmap, ALL ts: list typ,
   ALL args: list val,
   !!Val.has_type_list args (sig_args (ef_sig ef)) &&
   juicy_mem_op (P Ts x (make_ext_args (filter_genv gx) ids args) * F) >=>
   EX x': ext_spec_type OK_spec ef,
    (ALL z:_, juicy_mem_op (ext_compat z) -->
     ext_spec_pre' Hspec ef x' (genv_symb_injective gx) ts args z) &&
     ! ALL tret: option typ, ALL ret: option val, ALL z': OK_ty,
      ext_spec_post' Hspec ef x' (genv_symb_injective gx) tret ret z' >=>
          juicy_mem_op (Q Ts x (make_ext_rval (filter_genv gx) ret) * F).

Definition tc_option_val (sig: type) (ret: option val) :=
  match sig, ret with
    | Tvoid, None => True
    | Tvoid, Some _ => False
    | ty, Some v => tc_val ty v
    | _, _ => False
  end.

Fixpoint zip_with_tl {A : Type} (l1 : list A) (l2 : typelist) : list (A*type) :=
  match l1, l2 with
    | a::l1', Tcons b l2' => (a,b)::zip_with_tl l1' l2'
    | _, _ => nil
  end.

Definition believe_external (Hspec: OracleKind) (gx: genv) (v: val) (fsig: funsig) cc
  (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)):
  pred nat :=
  match Genv.find_funct gx v with
  | Some (External ef sigargs sigret cc') =>
      let ids := fst (split (fst fsig)) in
        !! (fsig = (zip_with_tl ids sigargs, sigret) /\ cc'=cc
           /\ ef_sig ef = mksignature
                           (typlist_of_typelist (type_of_params (fst fsig)))
                           (opttyp_of_type (snd fsig)) cc
           /\ length (typelist2list sigargs)=length ids)
        && semax_external Hspec ids ef A P Q
        && ! (ALL ts: list Type,
              ALL x: dependent_type_functor_rec ts A (pred rmap),
              ALL ret:option val,
                Q ts x (make_ext_rval (filter_genv gx) ret)
                  && !!has_opttyp ret (opttyp_of_type (snd fsig))
                  >=> !! tc_option_val sigret ret)
  | _ => FF
  end.

Definition fn_funsig (f: function) : funsig := (fn_params f, fn_return f).

Definition var_sizes_ok (cenv: composite_env) (vars: list (ident*type)) :=
   Forall (fun var : ident * type => @sizeof cenv (snd var) <= Ptrofs.max_unsigned)%Z vars.

Definition var_block' (sh: Share.t) (cenv: composite_env) (idt: ident * type) (rho: environ): mpred :=
  !! (sizeof (snd idt) <= Ptrofs.max_unsigned)%Z &&
  (memory_block sh (sizeof (snd idt))) (eval_lvar (fst idt) (snd idt) rho).

Definition stackframe_of' (cenv: composite_env) (f: Clight.function) : assert :=
  fold_right (fun P Q rho => P rho * Q rho) (fun rho => emp)
     (map (fun idt => var_block' Share.top cenv idt) (Clight.fn_vars f)).

Definition believe_internal_
  (semax:semaxArg -> pred nat)
  (gx: genv) (Delta: tycontext) v (fsig: funsig) cc (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)) : pred nat :=
  (EX b: block, EX f: function,
   prop (v = Vptr b Ptrofs.zero /\ Genv.find_funct_ptr gx b = Some (Internal f)
                 /\ Forall (fun it => complete_type (genv_cenv gx) (snd it) = true) (fn_vars f)
                 /\ list_norepet (map (@fst _ _) f.(fn_params) ++ map (@fst _ _) f.(fn_temps))
                 /\ list_norepet (map (@fst _ _) f.(fn_vars)) /\ var_sizes_ok (genv_cenv gx) (f.(fn_vars))
                 /\ fsig = fn_funsig f /\ f.(fn_callconv) = cc)
  && ALL ts: list Type,
     ALL x : dependent_type_functor_rec ts A (pred rmap),
           |> semax (SemaxArg  (func_tycontext' f Delta)
                                (fun rho => (bind_args f.(fn_params) f.(fn_vars) (P ts x) rho * stackframe_of' (genv_cenv gx) f rho)
                                             && funassert (func_tycontext' f Delta) rho)
                              (Ssequence f.(fn_body) (Sreturn None))
           (frame_ret_assert (function_body_ret_assert (fn_return f) (Q ts x)) (stackframe_of' (genv_cenv gx) f)))).

Definition empty_environ (ge: genv) := mkEnviron (filter_genv ge) (Map.empty _) (Map.empty _).

Definition claims (ge: genv) (Delta: tycontext) v fsig cc A P Q : Prop :=
  exists id HP HQ, (glob_specs Delta)!id = Some (mk_funspec fsig cc A P Q HP HQ) /\
    exists b, Genv.find_symbol ge id = Some b /\ v = Vptr b Ptrofs.zero.

Definition believepred (Espec: OracleKind) (semax: semaxArg -> pred nat)
              (Delta: tycontext) (gx: genv)  (Delta': tycontext) : pred nat :=
  ALL v:val, ALL fsig: funsig, ALL cc: calling_convention,
  ALL A: TypeTree,
  ALL P: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred,
  ALL Q: forall ts, dependent_type_functor_rec ts (AssertTT A) mpred,
       !! claims gx Delta' v fsig cc A P Q  -->
      (believe_external Espec gx v fsig cc A P Q
        || believe_internal_ semax gx Delta v fsig cc A P Q).

Definition semax_  {CS: compspecs}  (Espec: OracleKind)
       (semax: semaxArg -> pred nat) (a: semaxArg) : pred nat :=
 match a with SemaxArg Delta P c R =>
  ALL gx: genv, ALL Delta': tycontext,
       !! (tycontext_sub Delta Delta' /\ genv_cenv gx = cenv_cs)-->
      (believepred Espec semax Delta' gx Delta') -->
     ALL k: cont, ALL F: assert,
       (!! (closed_wrt_modvars c F) &&
              rguard Espec gx Delta' (frame_ret_assert R F) k) -->
        guard Espec gx Delta' (fun rho => F rho * P rho) (Kseq c :: k)
  end.

Definition semax'  {CS: compspecs} (Espec: OracleKind) Delta P c R : pred nat :=
     HORec (semax_  Espec) (SemaxArg Delta P c R).

Definition believe_internal {CS: compspecs} (Espec:  OracleKind)
  (gx: genv) (Delta: tycontext) v (fsig: funsig) cc (A: TypeTree)
  (P Q: forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)) : pred nat :=
  (EX b: block, EX f: function,
   prop (v = Vptr b Ptrofs.zero /\ Genv.find_funct_ptr gx b = Some (Internal f)
                 /\ Forall (fun it => complete_type (genv_cenv gx) (snd it) = true) (fn_vars f)
                 /\ list_norepet (map (@fst _ _) f.(fn_params) ++ map (@fst _ _) f.(fn_temps))
                 /\ list_norepet (map (@fst _ _) f.(fn_vars)) /\ var_sizes_ok (genv_cenv gx) (f.(fn_vars))
                 /\ fsig = fn_funsig f /\ f.(fn_callconv) = cc)
  && ALL ts: list Type,
     ALL x : dependent_type_functor_rec ts A (pred rmap),
        |> semax' Espec (func_tycontext' f Delta)
                                (fun rho => (bind_args f.(fn_params) f.(fn_vars) (P ts x) rho * stackframe_of' (genv_cenv gx)  f rho)
                                             && funassert (func_tycontext' f Delta) rho)
                               (Ssequence f.(fn_body) (Sreturn None))
           (frame_ret_assert (function_body_ret_assert (fn_return f) (Q ts x)) (stackframe_of' (genv_cenv gx) f))).

Definition believe {CS: compspecs} (Espec:OracleKind)
              (Delta: tycontext) (gx: genv) (Delta': tycontext): pred nat :=
  ALL v:val, ALL fsig: funsig, ALL cc: calling_convention,
  ALL A: TypeTree,
  ALL P: (forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)),
  ALL Q: (forall ts, dependent_type_functor_rec ts (AssertTT A) (pred rmap)),
       !! claims gx Delta' v fsig cc A P Q  -->
      (believe_external Espec gx v fsig cc A P Q
        || believe_internal Espec gx Delta v fsig cc A P Q).

Lemma semax_fold_unfold : forall {CS: compspecs} (Espec : OracleKind),
  semax' Espec = fun Delta P c R =>
  ALL gx: genv, ALL Delta': tycontext,
       !! (tycontext_sub Delta Delta' /\ genv_cenv gx = cenv_cs) -->
       believe Espec Delta' gx Delta' -->
     ALL k: cont, ALL F: assert,
        (!! (closed_wrt_modvars c F) && rguard Espec gx Delta' (frame_ret_assert R F) k) -->
        guard Espec gx Delta' (fun rho => F rho * P rho) (Kseq c :: k).

Definition weakest_pre {CS: compspecs} (Espec: OracleKind) (Delta: tycontext) c Q: assert :=
  fun rho: environ =>
  ALL gx: genv, ALL Delta': tycontext,
       !! (tycontext_sub Delta Delta' /\ genv_cenv gx = cenv_cs) -->
       unfash (believe Espec Delta' gx Delta') -->
     ALL k: cont, ALL F: assert,
        unfash (!! (closed_wrt_modvars c F) && rguard Espec gx Delta' (frame_ret_assert Q F) k) -->
        
        ALL tx : Clight.temp_env, ALL vx : env,
          (!! (rho = construct_rho (filter_genv gx) vx tx)) -->
          ((!! guard_environ Delta' (current_function (Kseq c :: k)) rho && funassert Delta' rho) -->
             (F rho -* assert_safe Espec gx vx tx (Kseq c :: k) rho)).

Opaque semax'.

Definition semax {CS: compspecs} (Espec: OracleKind) (Delta: tycontext) P c Q :=
  forall n, semax' Espec Delta P c Q n.

Lemma any_level_pred_nat: forall P: pred nat, (forall n, P n) <-> TT |-- P.

Lemma semax_weakest_pre_aux: forall {A: Type} (P: pred nat) (Q R: A -> pred rmap),
  P = fash (ALL x: A, Q x --> R x) ->
  (TT |-- P <-> forall x, Q x |-- R x).

Lemma unfash_allp:  forall {A} {agA: ageable A} {B} (f: B -> pred nat),
  @unfash _ agA (allp f) = allp (fun x:B => unfash (f x)).

Lemma fash_TT: forall {A} {agA: ageable A}, @unfash A agA TT = TT.

Lemma allp_andp: 
  forall {A} {NA: ageable A} {B: Type} (b0: B) (P: B -> pred A) (Q: pred A),
   (allp P && Q = allp (fun x => P x && Q))%pred.

Lemma unfash_prop_imp:
  forall {A} {agA: ageable A} (P: Prop) (Q: pred nat),
  (@unfash _ agA (prop P --> Q) = prop P --> @unfash _ agA Q)%pred.

Import age_to.

Lemma unfash_imp:
  forall {A} {NA: ageable A} (P Q: pred nat),
  (@unfash A _ (P --> Q) = (@unfash A _ P) --> @unfash A _ Q)%pred.

Lemma unfash_andp:  forall {A} {agA: ageable A} (P Q: pred nat),
  (@unfash A agA (andp P Q) = andp (@unfash A agA P) (@unfash A agA Q)).

Lemma andp_imp_e':
  forall (A : Type) (agA : ageable A) (P Q : pred A),
   P && (P --> Q) |-- P && Q.

Lemma unfash_fash:
  forall (A : Type) (agA : ageable A) (P : pred A),
   unfash (fash P) |-- P.

Lemma imp_imp:
  forall (A : Type) (agA : ageable A) (P Q R: pred A),
    P --> (Q --> R) = P && Q --> R.

Lemma imp_allp:
  forall B (A : Type) (agA : ageable A) (P: pred A) (Q: B -> pred A),
    P --> allp Q  = ALL x: B, P --> Q x.

Lemma fash_prop: forall P: Prop,
  fash (!! P: pred rmap) = !! P.

Lemma fash_unfash:
  forall (P : pred nat),
   fash (unfash P: pred rmap) = P.

Lemma prop_true_imp:
  forall (P: Prop) (Q: pred rmap),
    P -> !! P --> Q = Q.

Lemma corable_unfash:
  forall (A : Type) (JA : Join A) (PA : Perm_alg A) (SA : Sep_alg A) (agA : ageable A) 
    (AgeA : Age_alg A) (P : pred nat), corable (! P). *)

Require Import VST.veric.Clight_lemmas.
(* VST.veric.Clight_lemmas:
Require Import VST.veric.Clight_base.
Require Import compcert.cfrontend.Clight.

Definition var_name (V: Type) (bdec: ident * globvar V) : ident :=
   fst bdec.

Definition no_dups (F V: Type) (fdecs: list (ident * F)) (bdecs: list (ident * globvar V)) : Prop :=
  list_norepet (map (@fst ident F) fdecs ++ map (@var_name V) bdecs).
Arguments no_dups [F V] _ _.

Lemma no_dups_inv:
  forall  (A V: Type) id f fdecs bdecs,
    no_dups ((id,f)::fdecs) bdecs ->
    no_dups fdecs bdecs /\
     ~ In id (map (@fst ident A) fdecs) /\
     ~ In id (map (@var_name V) bdecs).
Arguments no_dups_inv [A V] _ _ _ _ _.

Lemma of_bool_Int_eq_e:
  forall i j, Val.of_bool (Int.eq i j) = Vtrue -> i = j.

Lemma eq_block_lem:
    forall (A: Set) a (b: A) c, (if eq_block a a then b else c) = b.

Lemma signed_zero: Int.signed Int.zero = 0.

Lemma equiv_e1 : forall A B: Prop, A=B -> A -> B.
Arguments equiv_e1 [A B] _ _.

Lemma deref_loc_fun: forall {ty m b z v v'},
   Clight.deref_loc ty m b z v -> Clight.deref_loc ty m b z v' -> v=v'.

Lemma eval_expr_lvalue_fun:
  forall ge e le m,
    (forall a v v', Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v') /\

Lemma eval_expr_fun:   forall {ge e le m a v v'},
    Clight.eval_expr ge e le m a v -> Clight.eval_expr ge e le m a v' -> v=v'.

Lemma eval_exprlist_fun:   forall {ge e le m a ty v v'},
    Clight.eval_exprlist ge e le m a ty v -> Clight.eval_exprlist ge e le m a ty v' -> v=v'.

Lemma eval_lvalue_fun:   forall {ge e le m a b b' z z'},
    Clight.eval_lvalue ge e le m a b z -> Clight.eval_lvalue ge e le m a b' z' -> (b,z)=(b',z').

Lemma inv_find_symbol_fun:
  forall {ge id id' b},
    Senv.find_symbol ge id = Some b ->

Lemma assign_loc_fun:
  forall {cenv ty m b ofs v m1 m2},
   assign_loc cenv ty m b ofs v m1 ->
   assign_loc cenv ty m b ofs v m2 ->
   m1=m2.

Lemma alloc_variables_fun:
  forall {ge e m vl e1 m1 e2 m2},
     Clight.alloc_variables ge e m vl e1 m1 ->

Lemma bind_parameters_fun:
  forall {ge e m p v m1 m2},
    Clight.bind_parameters ge e m p v m1 ->

Lemma eventval_list_match_fun:
  forall {se a a' t v},
    Events.eventval_list_match se a t v ->

Ltac fun_tac :=
  match goal with
  | H: ?A = Some _, H': ?A = Some _ |- _ => inversion2 H H'
  | H: Clight.eval_expr ?ge ?e ?le ?m ?A _,
    H': Clight.eval_expr ?ge ?e ?le ?m ?A _ |- _ =>
        apply (eval_expr_fun H) in H'; subst
  | H: Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _,
    H': Clight.eval_exprlist ?ge ?e ?le ?m ?A ?ty _ |- _ =>
        apply (eval_exprlist_fun H) in H'; subst
  | H: Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _,
    H': Clight.eval_lvalue ?ge ?e ?le ?m ?A _ _ |- _ =>
        apply (eval_lvalue_fun H) in H'; inv H'
  | H: Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _,
    H': Clight.assign_loc ?ge ?ty ?m ?b ?ofs ?v _ |- _ =>
        apply (assign_loc_fun H) in H'; inv H'
  | H: Clight.deref_loc ?ty ?m ?b ?ofs _,
    H': Clight.deref_loc ?ty ?m ?b ?ofs _ |- _ =>
        apply (deref_loc_fun H) in H'; inv H'
  | H: Clight.alloc_variables ?ge ?e ?m ?vl _ _,
    H': Clight.alloc_variables ?ge ?e ?m ?vl _ _ |- _ =>
        apply (alloc_variables_fun H) in H'; inv H'
  | H: Clight.bind_parameters ?ge ?e ?m ?p ?vl _,
    H': Clight.bind_parameters ?ge ?e ?m ?p ?vl _ |- _ =>
        apply (bind_parameters_fun H) in H'; inv H'
  | H: Senv.find_symbol ?ge _ = Some ?b,
    H': Senv.find_symbol ?ge _ = Some ?b |- _ =>
       apply (inv_find_symbol_fun H) in H'; inv H'
  | H: Events.eventval_list_match ?ge _ ?t ?v,
    H': Events.eventval_list_match ?ge _ ?t ?v |- _ =>
       apply (eventval_list_match_fun H) in H'; inv H'
 end. *)

Require Import VST.veric.own.
(* VST.veric.own:
Require Import VST.msl.log_normalize.
Require Import VST.msl.ghost.
Require Import VST.msl.ghost_seplog.
Require Export VST.veric.base.
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.veric.res_predicates.

Import RML. Import R.
Local Open Scope pred.

Notation ghost_approx m := (ghost_fmap (approx (level m)) (approx (level m))).

Program Definition ghost_is g: pred rmap :=
  fun m => ghost_of m = ghost_approx m g.

Definition Own g: pred rmap := allp noat && ghost_is g.

Lemma Own_op: forall a b c, join a b c -> Own c = Own a * Own b.

Fixpoint make_join (a c : ghost) : ghost :=
  match a, c with
  | nil, _ => c
  | _, nil => nil
  | None :: a', x :: c' => x :: make_join a' c'
  | _ :: a', None :: c' => None :: make_join a' c'
  | Some (ga, pa) :: a', Some (gc, _) :: c' => Some (gc, pa) :: make_join a' c'
  end.

Lemma make_join_nil : forall a, make_join a nil = nil.

Lemma make_join_nil_cons : forall o a c, make_join (o :: a) (None :: c) = None :: make_join a c.

Lemma ghost_joins_approx: forall n a c,
  joins (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) c) ->
  let c' := make_join a c in
  joins (ghost_fmap (approx (S n)) (approx (S n)) a) (ghost_fmap (approx (S n)) (approx (S n)) c') /\
    forall b, joins b (ghost_fmap (approx (S n)) (approx (S n)) c') ->
      joins (ghost_fmap (approx n) (approx n) b) (ghost_fmap (approx n) (approx n) c).

Program Definition bupd (P: pred rmap): pred rmap :=
  fun m => forall c, joins (ghost_of m) (ghost_approx m c) ->
    exists b, joins b (ghost_approx m c) /\
    exists m', level m' = level m /\ resource_at m' = resource_at m /\ ghost_of m' = b /\ P m'.

Lemma bupd_intro: forall P, P |-- bupd P.

Lemma bupd_mono: forall P Q, P |-- Q -> bupd P |-- bupd Q.

Lemma bupd_frame_r: forall P Q, bupd P * Q |-- bupd (P * Q).

Lemma bupd_frame_l: forall P Q, P * bupd Q |-- bupd (P * Q).

Lemma bupd_trans: forall P, bupd (bupd P) |-- bupd P.

Lemma bupd_prop : forall P, bupd (!! P) = !! P.

Lemma subp_bupd: forall (G : pred nat) (P P' : pred rmap), G |-- P >=> P' ->
    G |-- (bupd P >=> bupd P')%pred.

Lemma eqp_bupd: forall (G : pred nat) (P P' : pred rmap), G |-- P <=> P' ->
    G |-- (bupd P <=> bupd P').

Definition ghost_fp_update_ND a B :=
  forall n c, joins (ghost_fmap (approx n) (approx n) a) c ->
    exists b, B b /\ joins (ghost_fmap (approx n) (approx n) b) c.

Lemma Own_update_ND: forall a B, ghost_fp_update_ND a B ->
  Own a |-- bupd (EX b : _, !!(B b) && Own b).

Definition ghost_fp_update (a b : ghost) :=
  forall n c, joins (ghost_fmap (approx n) (approx n) a) c ->
               joins (ghost_fmap (approx n) (approx n) b) c.

Lemma ghost_fp_update_approx: forall a b n, ghost_fp_update a b ->
  ghost_fp_update (ghost_fmap (approx n) (approx n) a) (ghost_fmap (approx n) (approx n) b).

Lemma Own_update: forall a b, ghost_fp_update a b ->
  Own a |-- bupd (Own b).

Lemma Own_unit: emp |-- EX a : _, !!(identity a) && Own a.

Lemma Own_dealloc: forall a, Own a |-- bupd emp.

Definition singleton {A} k (x : A) : list (option A) := repeat None k ++ Some x :: nil.

Definition gname := nat.

Definition own {RA: Ghost} (n: gname) (a: G) (pp: preds) :=
  EX v : _, Own (singleton n (existT _ RA (exist _ a v), pp)).

Definition list_set {A} (m : list (option A)) k v : list (option A) :=
  firstn k m ++ repeat None (k - length m) ++ Some v :: skipn (S k) m.

Lemma singleton_join_gen: forall k a c (m: ghost)
  (Hjoin: join (Some a) (nth k m None) (Some c)),
  join (singleton k a) m (list_set m k c).

Lemma map_repeat : forall {A B} (f : A -> B) x n, map f (repeat x n) = repeat (f x) n.

Lemma ghost_fmap_singleton: forall f g k v, ghost_fmap f g (singleton k v) =
  singleton k (match v with (a, b) => (a, preds_fmap f g b) end).

Lemma ghost_fmap_singleton_inv : forall f g a k v,
  ghost_fmap f g a = singleton k v ->
  exists v', a = singleton k v' /\ v = let (a, b) := v' in (a, preds_fmap f g b).

Lemma ghost_alloc: forall {RA: Ghost} a pp, ghost.valid a ->

Lemma singleton_join: forall a b c k,
  join (singleton k a) (singleton k b) (singleton k c) <-> join a b c.

Lemma singleton_join_inv: forall k a b c,
  join (singleton k a) (singleton k b) c -> exists c', join a b c' /\ c = singleton k c'.

Lemma ghost_valid_2: forall {RA: Ghost} g a1 a2 pp,
  own g a1 pp * own g a2 pp |-- !!ghost.valid_2 a1 a2.

Lemma ghost_op: forall {RA: Ghost} g (a1 a2 a3: G) pp, join a1 a2 a3 ->
  own g a3 pp = own g a1 pp * own g a2 pp.

Lemma ghost_valid: forall {RA: Ghost} g a pp,
  own g a pp |-- !!ghost.valid a.

Lemma singleton_join_inv_gen: forall k a (b c: ghost),
  join (singleton k a) b c ->
  join (Some a) (nth k b None) (nth k c None) /\
    exists c', nth k c None = Some c' /\ c = list_set b k c'.

Lemma ghost_update_ND: forall {RA: Ghost} g (a: G) B pp,
  fp_update_ND a B -> own g a pp |-- bupd (EX b : _, !!(B b) && own g b pp).

Lemma ghost_update: forall {RA: Ghost} g (a b: G) pp,
  fp_update a b -> own g a pp |-- bupd (own g b pp).

Lemma ghost_dealloc: forall {RA: Ghost} g a pp,
  own g a pp |-- bupd emp.

Lemma list_set_same : forall {A} n l (a : A), nth n l None = Some a ->
  list_set l n a = l.

Definition cored: pred rmap := ALL P : pred rmap, ALL Q : pred rmap,
  P && Q --> P * Q.

Program Definition is_w w: pred rmap := fun w' => necR w w'.

Lemma cored_unit: forall w, cored w = join w w w.

Lemma cored_dup: forall P, P && cored |-- (P && cored) * (P && cored).

Lemma cored_core: forall w, cored (core w).

Lemma cored_duplicable: cored = cored * cored.

Lemma cored_emp: cored |-- bupd emp.

Lemma join_singleton_inv: forall k a b RA c v pp,
  join a b (singleton k (existT _ RA (exist _ (core c) v), pp)) ->
  a = singleton k (existT _ RA (exist _ (core c) v), pp) \/ b = singleton k (existT _ RA (exist _ (core c) v), pp).

Lemma own_cored: forall {RA: Ghost} g a pp, join a a a -> own g a pp |-- cored.

Require Import VST.veric.tycontext.
Require Import VST.veric.Clight_seplog.
 
Lemma own_super_non_expansive: forall {RA: Ghost} n g a pp,
  approx n (own g a pp) = approx n (own g a (preds_fmap (approx n) (approx n) pp)). *)



Local Open Scope pred.



Hint Resolve @now_later @andp_derives @sepcon_derives.



Lemma no_dups_swap:

  forall F V a b c, @no_dups F V (a++b) c -> @no_dups F V (b++a) c.

Proof.

unfold no_dups; intros.

rewrite map_app in *.

forget (map (@fst _ _) b) as bb.

forget (map (@fst _ _) a) as aa.

forget (map (var_name V) c) as cc.

clear - H.

destruct (list_norepet_append_inv _ _ _ H) as [? [? ?]].

apply list_norepet_append; auto.

apply list_norepet_append_commut; auto.

clear - H2.

unfold Coqlib.list_disjoint in *.

intros; apply H2; auto.

clear - H.

rewrite in_app in *.

intuition.

Qed.



Lemma join_sub_share_top: forall sh, join_sub Share.top sh -> sh = Share.top.

Proof.

intros.

generalize (top_correct' sh); intro.

apply join_sub_antisym; auto.

Qed.



Lemma opt2list2opt: forall {A:Type} (l: option A), list2opt (opt2list l) = l.

destruct l; auto.

Qed.



Lemma nat_of_Z_minus_le : forall z a b,

  b <= a ->

  (nat_of_Z (z - a) <= nat_of_Z (z - b))%nat.

Proof.

  intros.

  apply inj_le_rev.

  do 2 rewrite nat_of_Z_max.

  rewrite Coqlib.Zmax_spec.

  destruct (zlt 0 (z-a)).

  rewrite Coqlib.Zmax_spec.

  destruct (zlt 0 (z-b)).

  omega.

  omega.

  rewrite Coqlib.Zmax_spec.

  destruct (zlt 0 (z-b)); omega.

Qed.



Section SemaxContext.



Lemma universal_imp_unfold {A} {agA: ageable A}:

   forall B (P Q: B -> pred A) w,

     (ALL psi : B, P psi --> Q psi) w = (forall psi : B, (P psi --> Q psi) w).

Proof.

intros.

apply prop_ext; split; intros.

eapply H; eauto.

intro b; apply H.

Qed.



Lemma guard_environ_put_te':

 forall ge te ve Delta id v k,

 guard_environ Delta k (mkEnviron ge ve te)  ->

    (forall t,

        (temp_types Delta) ! id = Some t -> tc_val' t v) ->

 guard_environ Delta k (mkEnviron ge ve (Map.set id v te)).

Proof.

 intros.

 destruct H; split.

 apply typecheck_environ_put_te; auto.

 destruct k; auto.

Qed.



Lemma prop_imp_derives {A}{agA: ageable A}:

  forall (P: Prop) (Q Q': pred A),  (P -> Q |-- Q') -> !!P --> Q |-- !!P --> Q'.

Proof.

 intros.

 repeat intro.

 apply H; auto.

Qed.



Lemma prop_imp {A}{agA: ageable A}:

  forall (P: Prop) (Q Q': pred A),  (P -> Q = Q') -> !!P --> Q = !!P --> Q'.

Proof.

  intros.

  apply pred_ext; apply prop_imp_derives.

  + intros; rewrite H by auto; auto.

  + intros; rewrite H by auto; auto.

Qed.



Lemma age_laterR {A} `{ageable A}: forall {x y}, age x y -> laterR x y.

Proof.

intros. constructor 1; auto.

Qed.

Hint Resolve @age_laterR.



Lemma typecheck_environ_sub:

  forall Delta Delta', tycontext_sub Delta Delta' ->

   forall rho,

   typecheck_environ Delta' rho -> typecheck_environ Delta rho.

Proof.

intros ? ? [? [? [? [? Hs]]]] ?  [? [? ?]].

split; [ | split].

* clear - H H3.

 hnf; intros.

 specialize (H id); rewrite H0 in H.

 destruct ((temp_types Delta') ! id) eqn:?H; try contradiction.

 destruct H; subst.

 specialize (H3 id ty H1).

 destruct H3 as [v [? ?]].

 exists v; split; auto.

* clear - H0 H4.

  red in H4|-*.

 intros id ty. specialize (H4 id ty). rewrite <- H4.

 rewrite H0. clear; intuition.

* clear - H2 H5.

 hnf; intros. eapply H5.

 specialize (H2 id). hnf in H2. rewrite H in H2. eauto.

Qed.



Lemma funassert_resource: forall Delta rho a a' (Hl: level a = level a')

  (Hr: resource_at a = resource_at a'),

  funassert Delta rho a -> funassert Delta rho a'.

Proof.

  intros.

  destruct H as [H1 H2]; split; repeat intro.

  - destruct (H1 _ _ _ (rt_refl _ _ _) H0) as (b1 & ? & ?).

    exists b1; split; auto.

    destruct b0; simpl in *.

    rewrite Hr in H4.

    pose proof (necR_level _ _ H).

    eapply necR_PURE in H; eauto.

    rewrite H; simpl; f_equal; f_equal.

    extensionality i a0 a1 a2.

    match goal with |-context[compcert_rmaps.R.approx ?a (approx ?b ?c)] =>

      change (compcert_rmaps.R.approx a (approx b c)) with ((approx a oo approx b) c) end.

    rewrite fmap_app, approx_oo_approx', approx'_oo_approx by omega; auto.

  - specialize (H2 b b0).

    destruct b0; simpl in *.

    apply (H2 _ (rt_refl _ _ _)).

    rewrite Hr, Hl.

    destruct H0 as [p Hp].

    pose proof (necR_level _ _ H).

    rewrite <- resource_at_approx.

    eapply necR_PURE' in H as [? ->]; simpl; eauto.

Qed.



Lemma cl_corestep_fun': forall ge, corestep_fun (cl_core_sem ge).

Proof.  repeat intro. eapply cl_corestep_fun; simpl in *; eauto. Qed.

Hint Resolve cl_corestep_fun'.



Lemma derives_skip:

  forall {CS: compspecs} {Espec: OracleKind} p Delta (R: ret_assert),

      (forall rho, p rho |-- proj_ret_assert R EK_normal None rho) ->

        semax Espec Delta p Clight.Sskip R.

Proof.

intros ? ? ? ?; intros.

intros n.

rewrite semax_fold_unfold.

intros psi Delta'.

apply prop_imp_i; intros [? HGG].

clear H0 Delta. rename Delta' into Delta.

intros ?w _ _. clear n.

intros k F.

intros ?w _ ?.

clear w. rename w0 into n.

intros te ve w ?.

destruct H0 as [H0' H0].

specialize (H0 EK_normal None te ve w H1).

simpl exit_cont in H0.

simpl in H0'. clear n H1. remember ((construct_rho (filter_genv psi) ve te)) as rho.

revert w H0.

apply imp_derives; auto.

apply andp_derives; auto.

apply andp_derives; auto.

repeat intro. 

simpl.

specialize (H rho). destruct R; simpl in H. simpl tycontext.RA_normal.

rewrite sepcon_comm.

eapply sepcon_derives; try apply H0; auto.



repeat intro.

destruct (H0 _ H1) as (b & ? & m' & ? & ? & ? & HP).

exists b; split; auto; exists m'; repeat split; auto.

repeat intro.

specialize (HP ora jm H6 H7 H8).

destruct (@level rmap _ m').

constructor.

apply convergent_controls_jsafe with (State ve te k); auto.

simpl.



intros.

destruct H9 as [? [? ?]].

split3; auto.



econstructor; eauto.

Qed.



Lemma jsafe_corestep_forward:

  forall {Espec: OracleKind} ge c m c' m' n z,

    jstep (cl_core_sem ge) c m c' m' -> jsafeN (@OK_spec Espec) ge (S n) z c m ->

    jm_bupd z (jsafeN (@OK_spec Espec) ge n z c') m'.

Proof.

  intros.

  inv H0.

  assert ((c',m') = (c'0,m'0)).

  { eapply juicy_core_sem_preserves_corestep_fun with (csem := cl_core_sem ge); eauto. }

  inv H0; auto.

  setoid_rewrite (semantics.corestep_not_at_external (juicy_core_sem _)) in H2; eauto; congruence.

  contradiction.

Qed.



Lemma semax_unfold {CS: compspecs} {Espec: OracleKind}:

  semax Espec = fun Delta P c R =>

    forall (psi: Clight.genv) Delta' (w: nat)

          (TS: tycontext_sub Delta Delta')

          (HGG: genv_cenv psi = cenv_cs)

           (Prog_OK: believe Espec Delta' psi Delta' w) (k: cont) (F: assert),

        closed_wrt_modvars c F ->

       rguard Espec psi Delta' (frame_ret_assert R F) k w ->

       guard Espec psi Delta' (fun rho => F rho * P rho) (Kseq c :: k) w.

Proof.

unfold semax; rewrite semax_fold_unfold.

extensionality Delta P c R.

apply prop_ext; split; intros.

eapply (H w); eauto.

split; auto. split; auto.

intros psi Delta'.

apply prop_imp_i; intros [? HGG].

intros w' ? ? k F w'' ? [? ?].

eapply H; eauto.

eapply pred_nec_hereditary; eauto.

Qed.



Fixpoint list_drop (A: Type) (n: nat) (l: list A) {struct n} : list A :=

  match n with O => l | S i => match l with nil => nil | _ :: l' => list_drop A i l' end end.

Arguments list_drop [A] _ _.



Definition straightline (c: Clight.statement) :=

 forall ge ve te k m ve' te' k' m',

        cl_step ge (State ve te (Kseq c :: k)) m (State ve' te' k') m' ->  k=k'.



Lemma straightline_assign: forall e0 e, straightline (Clight.Sassign e0 e).

Proof.

unfold straightline; intros.

inv H; auto.

Qed.



Lemma extract_exists_pre_later {CS: compspecs} {Espec: OracleKind}:

  forall  (A : Type) (Q: assert) (P : A -> assert) c Delta (R: ret_assert),

  (forall x, semax Espec Delta (fun rho => Q rho && |> P x rho) c R) ->

   semax Espec Delta (fun rho => Q rho && |> exp (fun x => P x rho)) c R.

Proof.

rewrite semax_unfold in *.

intros.

intros.

intros te ve ?w ? ?w ? ?.

destruct H4.

destruct H4.

destruct H6 as [w2 [w3 [? [? [HQ ?]]]]].

destruct (age1 w2) as [w2' | ] eqn:?.

*

destruct (@age1_join _ _ _ _ _ _ _ _ H6 Heqo)

  as [w3' [w1' [? [? ?]]]].

hnf in H8.

specialize (H8 _ (age_laterR H10)).

destruct H8 as [x H8].

specialize (H x psi Delta' w TS HGG Prog_OK k F H0 H1).

unfold guard, _guard in H.

specialize (H te ve).

cbv beta in H.

specialize (H w0 H2 w1 H3).

apply H.

split; auto. split; auto.

exists w2, w3. split3; auto.

split; auto.

intros w3x ?.

eapply pred_nec_hereditary; [ | apply H8].

clear - H10 H12.

eapply age_later_nec; eauto.

*

assert (level w1 = O). {

  clear - H6 Heqo.

  apply join_level in H6. destruct H6.

  rewrite <- H. apply age1_level0.  auto.

}

hnf.

intros.

eexists; split.

apply H10.

exists w1.

split3; auto. split; auto.

simpl.

intros.

rewrite H9.

constructor.

Qed.



Lemma extract_exists_pre {CS: compspecs} {Espec: OracleKind}:

  forall  (A : Type) (P : A -> assert) c Delta (R: ret_assert),

  (forall x, semax Espec Delta (P x) c R) ->

   semax Espec Delta (fun rho => exp (fun x => P x rho)) c R.

Proof.

rewrite semax_unfold in *.

intros.

intros.

intros te ve ?w ? ?w ? ?.

rewrite exp_sepcon2 in H4.

destruct H4 as [[TC [x H5]] ?].



specialize (H x).

specialize (H psi Delta' w TS HGG Prog_OK k F H0).

spec H. {

 clear - H1.

 unfold rguard in *.

 intros ek vl tx vx. specialize (H1 ek vl tx vx).

 red in H1.

 eapply subp_trans'; [| apply H1 ].

 apply derives_subp.

 apply andp_derives; auto.

}

eapply H; eauto.

split; auto.

split; auto.

Qed.



Definition G0: funspecs := nil.



Definition empty_genv prog_pub cenv: Clight.genv :=

   Build_genv (Genv.globalenv (AST.mkprogram (F:=Clight.fundef)(V:=type) nil prog_pub (1%positive))) cenv.



Lemma empty_program_ok {CS: compspecs} {Espec: OracleKind}: forall Delta ge w,

    glob_specs Delta = PTree.empty _ ->

    believe Espec Delta ge Delta w.

Proof.

intros Delta ge w ?.

intro b.

intros fsig cc A P Q.

intros ?n ? ?.

destruct H1 as [id [? [b0 [? ?]]]].

rewrite H in H1. rewrite PTree.gempty in H1.

inv H1.

Qed.



Definition all_assertions_computable  :=

  forall (Espec: OracleKind) psi tx vx (Q: assert), 

     exists k,  assert_safe Espec psi tx vx k = Q.



Lemma ewand_TT_emp {A} {JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}{CA: Canc_alg A}:

    ewand TT emp = emp.

Proof.

intros.

apply pred_ext; intros w ?.

destruct H as [w1 [w3 [? [? ?]]]].

hnf; eapply split_identity.

eapply join_comm; eauto.

auto.

exists w; exists w; split; auto.

change (identity w) in H.

apply identity_unit'; auto.

Qed.



Lemma subp_derives' {A}{agA: ageable A}:

  forall P Q: pred A, (forall n, (P >=> Q) n) -> P |-- Q.

Proof.

intros.

intros n ?. eapply H; eauto.

Qed.



Lemma guard_environ_sub:

  forall {Delta Delta' f rho},

   tycontext_sub Delta Delta' ->

   guard_environ Delta' f rho ->

   guard_environ Delta f rho.

Proof.

intros.

destruct H0; split; auto.

eapply typecheck_environ_sub; eauto.

destruct f; auto.

destruct H1; split; auto.

destruct H as [? [? [? ?]]]. rewrite H4; auto.

Qed.



Lemma guard_environ_eqv:

  forall Delta Delta' f rho,

  tycontext_eqv Delta Delta' ->

  guard_environ Delta f rho -> guard_environ Delta' f rho.

Proof.

  intros.

  rewrite tycontext_eqv_spec in H.

  eapply guard_environ_sub; eauto.

  tauto.

Qed.



Lemma proj_frame_ret_assert:

 forall (R: ret_assert) (F: assert) ek vl,

  proj_ret_assert (frame_ret_assert R F) ek vl = 

  seplog.sepcon (proj_ret_assert R ek vl) F.

Proof.

intros; extensionality rho; destruct R, ek; simpl;

rewrite ?sepcon_andp_prop1; auto.

Qed.



Lemma semax_extensionality0 {CS: compspecs} {Espec: OracleKind}:

       TT |--

      ALL Delta:tycontext, ALL Delta':tycontext,

      ALL P:assert, ALL P':assert,

      ALL c: statement, ALL R:ret_assert, ALL R':ret_assert,

       ((!! tycontext_sub Delta Delta'

       &&  (ALL ek: exitkind, ALL  vl : option val, ALL rho: environ,  

               (proj_ret_assert R ek vl rho >=> proj_ret_assert R' ek vl rho))

      && (ALL rho:environ, P' rho >=> P rho)  && semax' Espec Delta P c R) >=> semax' Espec Delta' P' c R').

Proof.

apply loeb.

intros w ? Delta Delta' P P' c R R'.

intros w1 ? w2 ? [[[? ?] ?] ?].

do 3 red in H2.

rewrite semax_fold_unfold; rewrite semax_fold_unfold in H5.

intros gx Delta''.

apply prop_imp_i; intros [TS HGG].

intros w3 ? ?.

specialize (H5 gx Delta'' _ (necR_refl _)

  (conj (tycontext_sub_trans _ _ _ H2 TS) HGG)

                  _ H6 H7).



intros k F w4 Hw4 [? ?].

specialize (H5 k F w4 Hw4).

assert ((rguard Espec gx Delta'' (frame_ret_assert R F) k) w4).

do 9 intro.

apply (H9 b b0 b1 b2 y H10 a' H11).

destruct H12; split; auto; clear H13.

pose proof I.

destruct H12; split; auto.



rewrite proj_frame_ret_assert in H14|-*.

clear H12 H13.

revert a' H11 H14.

apply sepcon_subp' with (level w2).

apply H3.

auto.

apply necR_level in H6.

apply necR_level in Hw4.

eapply le_trans; try eassumption.

eapply le_trans; try eassumption.



specialize (H5 (conj H8 H10)). clear H8 H9 H10.

do 7 intro.

apply (H5 b b0 y H8 _ H9).

destruct H10; split; auto.

destruct H10; split; auto.

clear H10 H11.

revert a' H9 H12.

apply sepcon_subp' with (level w2); auto.

apply necR_level in H6.

apply necR_level in Hw4.

eapply le_trans; try eassumption.

eapply le_trans; try eassumption.

Qed.



Lemma semax_extensionality1 {CS: compspecs} {Espec: OracleKind}:

  forall Delta Delta' (P P': assert) c (R R': ret_assert) ,

       tycontext_sub Delta Delta' ->

       ((ALL ek: exitkind, ALL  vl : option val, ALL rho: environ,  

          (proj_ret_assert R ek vl rho >=> proj_ret_assert R' ek vl rho))

      && (ALL rho:environ, P' rho >=> P rho)  && (semax' Espec Delta P c R) |-- semax' Espec Delta' P' c R').

Proof.

intros.

intros n ?.

apply (semax_extensionality0 n I Delta Delta' P P' c R R' _ (le_refl _) _ (necR_refl _)).

destruct H0;

split; auto.

destruct H0;

split; auto.

split; auto.

Qed.



Lemma semax_frame {CS: compspecs} {Espec: OracleKind}:  forall Delta P s R F,

   closed_wrt_modvars s F ->

  semax Espec Delta P s R ->

    semax Espec Delta (fun rho => P rho * F rho) s (frame_ret_assert R F).

Proof.

intros until F. intros CL H.

rewrite semax_unfold.

rewrite semax_unfold in H.

intros.

pose (F0F := fun rho => F0 rho * F rho).

specialize (H psi Delta' w TS HGG Prog_OK k F0F).

spec H. {

 unfold F0F.

 clear - H0 CL.

 hnf in *; intros; simpl in *.

 rewrite <- CL. rewrite <- H0. auto.

 intuition.

 intuition.

}

replace (fun rho : environ => F0 rho * (P rho * F rho))

  with  (fun rho : environ => F0F rho * P rho).

*

apply H.

unfold F0F; clear - H1.

intros ek vl tx vx; specialize (H1 ek vl tx vx).

red in H1.

remember ((construct_rho (filter_genv psi) vx tx)) as rho.

red.

hnf; intros. specialize (H1 _ H).

hnf; intros. apply H1; auto.

destruct H2; split; auto. destruct H2; split; auto.

rewrite proj_frame_ret_assert in H4|-*.

rewrite proj_frame_ret_assert.

rewrite seplog.sepcon_assoc.

eapply sepcon_derives; try apply H4; auto. simpl.

rewrite sepcon_comm; auto.

*

unfold F0F.

extensionality rho.

rewrite sepcon_assoc.

f_equal. apply sepcon_comm.

Qed.



Lemma assert_safe_last:

  forall {Espec: OracleKind} ge ve te st rho w,

   (forall w', age w w' -> assert_safe Espec ge ve te st rho w) ->

    assert_safe Espec ge ve te st rho w.

Proof.

intros.

case_eq (age1 w). auto.

clear H.

intro; apply bupd_intro; repeat intro.

rewrite (af_level1 age_facts) in H.

rewrite H.

constructor.

Qed.



Lemma pred_sub_later' {A} `{H: ageable A}:

  forall (P Q: pred A),

           (|> P >=> |> Q)  |--  (|> (P >=> Q)).

Proof.

intros.

rewrite later_fash; auto.

rewrite later_imp.

auto.

Qed.



Lemma later_strengthen_safe1:

  forall {Espec: OracleKind} (P: pred rmap) ge ve te k rho,

              ((|> P) >=> assert_safe Espec ge ve te k rho) |--   |>  (P >=> assert_safe Espec ge ve te k rho).

Proof.

intros.

intros w ?.

apply (@pred_sub_later' _ _ P  (assert_safe Espec ge ve te k rho)); auto.

eapply subp_trans'; try apply H.

apply derives_subp; clear.

apply now_later.

Qed.



End SemaxContext.



Hint Resolve @age_laterR.



Fixpoint filter_seq (k: cont) : cont :=

 match k with

  | Kseq s :: k1 => filter_seq k1

  | _ => k

  end.



Lemma cons_app: forall A (x: A) (y: list A), x::y = (x::nil)++y.

Proof. auto. Qed.



Lemma cons_app': forall A (x:A) y z,

      x::y++z = (x::y)++z.

Proof. auto. Qed.



Lemma cat_prefix_empty:

   forall {A} prefix (ctl: list A), ctl =  prefix ++ ctl -> prefix = nil.

Proof.

do 3 intro.

destruct prefix; auto; intro; elimtype False.

assert (length ctl = length ((a::prefix) ++ ctl)).

f_equal; auto.

simpl in H0.

rewrite app_length in H0.

omega.

Qed.



Definition true_expr : Clight.expr := Clight.Econst_int Int.one (Tint I32 Signed noattr).



Lemma dec_skip: forall s, {s=Sskip}+{s<>Sskip}.

Proof.

 destruct s; try (left; congruence); right; congruence.

Qed.



Lemma strip_step:  

  forall ge ve te k m st' m',

     cl_step ge (State ve te (strip_skip k)) m st' m' =

    cl_step ge (State ve te k) m st' m'.

Proof.

intros.

 apply prop_ext.

 induction k; intros; split; simpl; intros; try destruct IHk; auto.

 destruct a; try destruct s; auto.

  constructor; auto.

 destruct a; try destruct s; auto.

 inv H. auto.

Qed.



 Lemma strip_skip_app:

  forall k k', strip_skip k = nil -> strip_skip (k++k') = strip_skip k'.

Proof. induction k; intros; auto. destruct a; inv H. destruct s; inv H1; auto.

  simpl. apply IHk. auto.

Qed.



Lemma strip_strip: forall k, strip_skip (strip_skip k) = strip_skip k.

Proof.

induction k; simpl.

auto.

destruct a; simpl; auto.

destruct (dec_skip s).

subst; auto.

destruct s; auto.

Qed.



Lemma strip_skip_app_cons:

 forall {k c l}, strip_skip k = c::l -> forall k', strip_skip  (k++k') = c::l++k'.

Proof. intros. revert k H;  induction k; intros. inv H.

  destruct a; try solve [simpl in *; auto];

  try solve [simpl in *; rewrite cons_app'; rewrite H; auto].

 destruct (dec_skip s). subst. simpl in *; auto.

 destruct s; inv H; simpl; auto.

Qed.



Lemma filter_seq_current_function:

  forall ctl1 ctl2, filter_seq ctl1 = filter_seq ctl2 ->

       current_function ctl1 = current_function ctl2.

Proof.

  intros ? ? H0. revert ctl2 H0; induction ctl1; simpl; intros.

  revert H0; induction ctl2; simpl; intros; try destruct a; try congruence; auto.

  destruct a; auto; revert H0; induction ctl2; simpl; intros; try destruct a; try congruence; auto.

Qed.



Lemma filter_seq_call_cont:

  forall ctl1 ctl2, filter_seq ctl1 = filter_seq ctl2 -> call_cont ctl1 = call_cont ctl2.

Proof.

  intros ? ? H0. revert ctl2 H0; induction ctl1; simpl; intros.

  revert H0; induction ctl2; simpl; intros; try destruct a; try congruence; auto.

  destruct a; auto; revert H0; induction ctl2; simpl; intros; try destruct a; try congruence; auto.

Qed.



Lemma call_cont_app_nil:

  forall l k, call_cont l = nil -> call_cont (l++k) = call_cont k.

Proof.

 intros l k; revert k; induction l; simpl; intros;

   try destruct a; simpl in *; try congruence; auto.

Qed.

Lemma call_cont_app_cons:

  forall l c l', call_cont l = c::l' -> forall k, call_cont (l++k) = c::l' ++ k.

Proof.

  intros; revert c l' k H; induction l; simpl; intros;

   try destruct a; simpl in *; try congruence; auto.

Qed.



Lemma and_FF : forall {A} `{ageable A} (P:pred A),

  P && FF = FF.

Proof.

  intros. rewrite andp_comm. apply FF_and.

Qed.



Lemma sepcon_FF : forall {A}{JA: Join A}{PA: Perm_alg A}{AG: ageable A}{XA: Age_alg A} (P:pred A),

  (P * FF = FF)%pred.

Proof.

  intros. rewrite sepcon_comm. apply FF_sepcon.

Qed.



Section extensions.



Lemma age1_resource_decay:

  forall jm jm', age jm jm' -> resource_decay (nextblock (m_dry jm)) (m_phi jm) (m_phi jm').

Proof.

 intros. split.

 apply age_level in H.

 change (level (m_phi jm)) with (level jm).

 change (level (m_phi jm')) with (level jm').

 omega.

 intro l. split. apply juicy_mem_alloc_cohere. left.

 symmetry; apply age1_resource_at with (m_phi jm); eauto.

  destruct (age1_juicy_mem_unpack _ _ H); auto.

 symmetry; apply resource_at_approx.

Qed.



Lemma safe_loop_skip:

  forall {Espec: OracleKind}

    ge ora ve te k m,

    jsafeN (@OK_spec Espec) ge (level m) ora

           (State ve te (Kseq (Sloop Clight.Sskip Clight.Sskip) :: k)) m.

Proof.

  intros.

  remember (level m)%nat as N.

  destruct N; [constructor|].

  case_eq (age1 m); [intros m' ? |  intro; apply age1_level0 in H; omegaContradiction].

  apply jsafeN_step with

    (c' := State ve te (Kseq Sskip :: Kseq Scontinue :: Kloop1 Sskip Sskip :: k))

    (m'0 := m').

  split3.

  replace (m_dry m') with (m_dry m) by (destruct (age1_juicy_mem_unpack _ _ H); auto).

  repeat econstructor.

  apply age1_resource_decay; auto. split; [apply age_level; auto|].

  apply age_jm_phi in H.

  erewrite (age1_ghost_of _ _ H) by (symmetry; apply ghost_of_approx).

  unfold level at 1; simpl.

  repeat intro; auto.

  assert (N = level m')%nat.

  apply age_level in H; omega.

  clear HeqN m H. rename m' into m.

  intros; eexists; repeat split; eauto.

  clear H H1; revert m H0; induction N; intros; simpl; [constructor|].

  case_eq (age1 m); [intros m' ? |  intro; apply age1_level0 in H; omegaContradiction].

  apply jsafeN_step

    with (c' := State ve te (Kseq Sskip :: Kseq Scontinue :: Kloop1 Sskip Sskip :: k))

         (m'0 := m').

  split3.

  replace (m_dry m') with (m_dry m) by (destruct (age1_juicy_mem_unpack _ _ H); auto).

  repeat constructor.

 apply age1_resource_decay; auto. split; [apply age_level; auto|].

  apply age_jm_phi in H.

  erewrite (age1_ghost_of _ _ H) by (symmetry; apply ghost_of_approx).

  unfold level at 1; simpl.

  repeat intro; auto.

  intros; eexists; repeat split; eauto.

  eapply IHN; eauto.

  apply age_level in H. omega.

Qed.



Lemma safe_seq_skip {Espec: OracleKind} ge n ora ve te k m :

  jsafeN OK_spec ge n ora (State ve te k) m ->

  jsafeN OK_spec ge n ora (State ve te (Kseq Sskip :: k)) m.

Proof.

inversion 1; subst. constructor.

econstructor; eauto. simpl. destruct H0 as (?&?&?). split3; eauto.

eapply step_skip; eauto.

simpl in *; congruence.

contradiction.

Qed.



Lemma safe_seq_skip' {Espec: OracleKind} ge n ora ve te k m :

  jsafeN OK_spec ge n ora (State ve te (Kseq Sskip :: k)) m ->

  jsafeN OK_spec ge n ora (State ve te k) m.

Proof.

inversion 1; subst. constructor.

econstructor; eauto. simpl. destruct H0 as (?&?&?). split3; eauto.

inv H0; auto.

simpl in *; congruence.

contradiction.

Qed.



Lemma safe_step_forward {Espec: OracleKind}:

  forall psi n ora st m,

   cl_at_external st = None ->

   jsafeN (@OK_spec Espec) psi (S n) ora st m ->

 exists st', exists m',

   jstep (cl_core_sem psi) st m st' m' /\ jm_bupd ora (jsafeN (@OK_spec Espec) psi n ora  st') m'.

Proof.

 intros.

 inv H0.

 eexists; eexists; split; eauto.

 simpl in H2; rewrite H2 in H; congruence.

 contradiction.

Qed.



Lemma safeN_strip {Espec: OracleKind}:

  forall ge n ora ve te k m,

     jsafeN (@OK_spec Espec) ge n ora (State ve te (strip_skip k)) m =

     jsafeN (@OK_spec Espec) ge n ora (State ve te k) m.

Proof.

 intros.

 destruct n. apply prop_ext; simpl; intuition.

 constructor. constructor.

 apply prop_ext; split; intros H.

 { induction k. simpl in H. auto. destruct a; auto.

   destruct (dec_skip s); subst.

   simpl in H|-*. apply IHk in H. apply safe_seq_skip; auto.

   destruct s; simpl in *; congruence. }

 { induction k. simpl. auto. destruct a; auto.

   destruct (dec_skip s); subst.

   simpl in *. apply IHk. apply safe_seq_skip'; auto.

   destruct s; simpl in *; congruence. }

Qed.



Local Open Scope nat_scope.



Definition control_as_safe {Espec: OracleKind} ge n ctl1 ctl2 :=

 forall (ora : OK_ty) (ve : env) (te : temp_env) (m : juicy_mem) (n' : nat),

     n' <= n ->

     jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl1) m ->

     jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl2) m.



Fixpoint prebreak_cont (k: cont) : cont :=

  match k with

  | Kloop1 s e3 :: k' => k

  | Kseq s :: k' => prebreak_cont k'

  | Kloop2 s e3 :: k' => k

  | Kswitch :: k' => k

  | _ =>  nil 

  end.



Lemma prebreak_cont_is: forall k,

  match (prebreak_cont k) with

  | Kloop1 _ _ :: _ => True

  | Kloop2 _ _ :: _ => True

  | Kswitch :: _ => True

  | nil => True

  | _ => False

  end.

Proof.

induction k; simpl; auto.

destruct (prebreak_cont k); try contradiction; destruct a; auto.

Qed.



Lemma find_label_prefix:

  forall lbl s ctl k, find_label lbl s ctl = Some k -> exists j, k = j++ctl

with

  find_label_ls_prefix:

  forall lbl s ctl k, find_label_ls lbl s ctl = Some k -> exists j, k = j++ctl.

Proof.

 intros.

  clear find_label_prefix.

  revert ctl k H; induction s; simpl; intros; try congruence.

  revert H; case_eq (find_label lbl s1 (Kseq s2 :: ctl)); intros; [inv H0 | auto ].

  destruct (IHs1 _ _ H) as [j ?]. exists (j++ (Kseq s2::nil)); rewrite app_ass; auto.

  revert H; case_eq (find_label lbl s1 ctl); intros; [inv H0 | auto ]; auto.

  revert H; case_eq (find_label lbl s1 (Kseq Scontinue :: Kloop1 s1 s2 :: ctl)); intros; [inv H0 | auto ].

  destruct (IHs1 _ _ H) as [j ?]. exists (j++ (Kseq Scontinue :: Kloop1 s1 s2::nil)); rewrite app_ass; auto.

  destruct (IHs2 _ _ H0) as [j ?]. exists (j++ (Kloop2 s1 s2::nil)); rewrite app_ass; auto.

  destruct (find_label_ls_prefix _ _ _ _ H) as [j ?]. exists (j++(Kswitch :: nil)); rewrite app_ass; auto.

  if_tac in H. subst l. inv H.

  exists (Kseq s :: nil); auto.

  apply IHs; auto.



 induction s; simpl; intros. inv H.

 revert H; case_eq (find_label lbl s (Kseq (seq_of_labeled_statement s0) :: ctl)); intros.

 inv H0.

 destruct (find_label_prefix _ _ _ _ H) as [j ?]; exists (j++Kseq (seq_of_labeled_statement s0) ::nil); rewrite app_ass; auto.

 auto.

Qed.



Lemma find_label_None:

  forall lbl s ctl, find_label lbl s ctl = None -> forall ctl', find_label lbl s ctl' = None

with

  find_label_ls_None:

  forall lbl s ctl, find_label_ls lbl s ctl = None ->  forall ctl', find_label_ls lbl s ctl' = None.

Proof.

clear find_label_None; induction s; simpl; intros; try congruence;

 try match type of H with match ?A with Some _ => _| None => _ end = _

                => revert H; case_eq A; intros; [inv H0 | ]

       end;

 try (rewrite (IHs1 _ H); eauto).

 eauto.

 destruct (ident_eq lbl l). inv H. eapply IHs; eauto.



clear find_label_ls_None; induction s; simpl; intros; try congruence;

 try match type of H with match ?A with Some _ => _| None => _ end = _

                => revert H; case_eq A; intros; [inv H0 | ]

       end;

 try (rewrite (IHs1 _ H); eauto).

 eauto.

 rewrite (find_label_None _ _ _ H). eauto.

Qed.



Lemma find_label_prefix2':

 forall lbl s k1 pre, find_label lbl s k1 = Some (pre++k1) ->

               forall k2, find_label lbl s k2 = Some (pre++k2)

with find_label_ls_prefix2':

 forall lbl s k1 pre, find_label_ls lbl s k1 = Some (pre++k1) ->

               forall k2, find_label_ls lbl s k2 = Some (pre++k2) .

Proof.

intros. clear find_label_prefix2'.

revert pre k1 H k2; induction s; simpl; intros; try congruence;

 try match type of H with match ?A with Some _ => _| None => _ end = _

                => revert H; case_eq A; intros; [inv H0 | ]

       end;

 try

 (destruct (find_label_prefix _ _ _ _ H) as [j Hj];

 rewrite cons_app in Hj; rewrite <- app_ass in Hj; apply app_inv_tail in Hj; subst pre;

  erewrite app_ass in H; simpl in H;

  rewrite (IHs1 _ _ H); rewrite app_ass; reflexivity);

 try solve [erewrite (find_label_None); eauto].

 rewrite (IHs1 _ _ H); auto.

 change (Kseq Scontinue :: Kloop1 s1 s2 :: k1) with ((Kseq Scontinue :: Kloop1 s1 s2 :: nil) ++ k1)

   in H.

 change (Kseq Scontinue :: Kloop1 s1 s2 :: k2) with ((Kseq Scontinue :: Kloop1 s1 s2 :: nil) ++ k2).

destruct (find_label_prefix _ _ _ _ H) as [j Hj];

 rewrite cons_app in Hj; rewrite <- app_ass in Hj; apply app_inv_tail in Hj; subst pre.

  erewrite app_ass in H; simpl in H;

  rewrite (IHs1 _ _ H); rewrite app_ass; reflexivity.

 change (Kseq Scontinue :: Kloop1 s1 s2 :: k1) with ((Kseq Scontinue :: Kloop1 s1 s2 :: nil) ++ k1)

   in H.

 change (Kseq Scontinue :: Kloop1 s1 s2 :: k2) with ((Kseq Scontinue :: Kloop1 s1 s2 :: nil) ++ k2).

 erewrite (find_label_None); eauto.

 destruct (find_label_prefix _ _ _ _ H0) as [j Hj];

  rewrite cons_app in Hj; rewrite <- app_ass in Hj; apply app_inv_tail in Hj; subst pre.

  erewrite app_ass in H0; simpl in H0;

  rewrite (IHs2 _ _ H0); rewrite app_ass; reflexivity.

destruct (find_label_ls_prefix _ _ _ _ H) as [j Hj];

 rewrite cons_app in Hj; rewrite <- app_ass in Hj; apply app_inv_tail in Hj; subst pre.

  erewrite app_ass in H; simpl in H.

  rewrite (find_label_ls_prefix2' _ _ _ _ H); rewrite app_ass; reflexivity.

  if_tac. inv H. rewrite cons_app in H2. apply app_inv_tail in H2; subst. reflexivity.

  eauto.



intros. clear find_label_ls_prefix2'.

revert pre k1 H k2; induction s; simpl; intros; try congruence;

 try match type of H with match ?A with Some _ => _| None => _ end = _

                => revert H; case_eq A; intros; [inv H0 | ]

       end;

 eauto.

 (destruct (find_label_prefix _ _ _ _ H) as [j Hj];

 rewrite cons_app in Hj; rewrite <- app_ass in Hj; apply app_inv_tail in Hj; subst pre;

  erewrite app_ass in H; simpl in H).

  rewrite (find_label_prefix2' _ _ _ _ H); rewrite app_ass; reflexivity;

 try solve [erewrite (find_label_ls_None); eauto].

  erewrite (find_label_None); eauto.

Qed.



Lemma find_label_prefix2:

  forall lbl s pre j ctl1 ctl2,

   find_label lbl s (pre++ctl1) = Some (j++ctl1) ->

   find_label lbl s (pre++ctl2) = Some (j++ctl2).

Proof.

intros.

 destruct (find_label_prefix _ _ _ _ H).

 rewrite <- app_ass in H0.

 apply  app_inv_tail in H0. subst j.

 rewrite app_ass in *.

 forget (pre++ctl1) as k1. forget (pre++ctl2) as k2.

 clear - H. rename x into pre.

 eapply find_label_prefix2'; eauto.

Qed.



Lemma control_as_safe_bupd {Espec: OracleKind}: forall ge n ctl1 ctl2, control_as_safe ge n ctl1 ctl2 ->

 forall (ora : OK_ty) (ve : env) (te : temp_env) (m : juicy_mem) (n' : nat),

     n' <= n ->

     jm_bupd ora (jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl1)) m ->

     jm_bupd ora (jsafeN (@OK_spec Espec) ge n' ora (State ve te ctl2)) m.

Proof.

  repeat intro.

  destruct (H1 _ H2) as (? & ? & ? & ?); eauto.

Qed.



Lemma corestep_preservation_lemma {Espec: OracleKind}:

   forall ge ctl1 ctl2 ora ve te m n c l c' m',

       filter_seq ctl1 = filter_seq ctl2 ->

      (forall k : list cont', control_as_safe ge n (k ++ ctl1) (k ++ ctl2)) ->

      control_as_safe ge (S n) ctl1 ctl2 ->

      jstep (cl_core_sem ge) (State ve te (c :: l ++ ctl1)) m c' m' ->

      jm_bupd ora (jsafeN (@OK_spec Espec) ge n ora c') m' ->

   exists c2 : corestate,

     exists m2 : juicy_mem,

       jstep (cl_core_sem ge) (State ve te (c :: l ++ ctl2)) m c2 m2 /\

       jm_bupd ora (jsafeN (@OK_spec Espec) ge n ora c2) m2.

Proof. intros until m'. intros H0 H4 CS0 H H1.

  remember (State ve te (c :: l ++ ctl1)) as q. rename c' into q'.

  destruct H as [H [Hb [Hc Hg]]].

  remember (m_dry m) as dm; remember (m_dry m') as dm'.

  revert c l m Heqdm m' Heqdm' Hb Hc Hg H1 Heqq; induction H; intros; try inv Heqq.

  

  do 2 eexists; split; [split3; [econstructor; eauto | auto | auto ] | eapply control_as_safe_bupd; auto ].

  

  do 2 eexists; split; [split3; [ | eassumption | auto ] | ].

  rewrite <- Heqdm'; econstructor; eauto.

  eapply control_as_safe_bupd; auto.

  

  do 2 eexists; split; [split3; [econstructor; eauto | auto | auto ] |  ].

  do 3 rewrite cons_app'. eapply control_as_safe_bupd; auto.

  

{ do 2 eexists; split; [split3; [ | eassumption | auto ] | ].

  rewrite <- Heqdm';  eapply step_call_external; eauto.

  intros ? HC J; specialize (H5 _ HC J) as (m'' & J' & Hupd & H5).

  exists m''; split; auto; split; auto.

  destruct n; [constructor|].

  inv H5.

  { destruct H7 as (?&?&?). inv H5. }

  { eapply jsafeN_external; eauto.

    intros ret m'0 z'' n'' Hargsty Hretty Hle H10 H11; specialize (H9 ret m'0 z'' n'' Hargsty Hretty Hle H10 H11).

    destruct H9 as [c' [? ?]]. simpl in H5. unfold cl_after_external in *.

    destruct ret as [ret|]. destruct optid.

    exists (State ve (PTree.set i ret te) (l ++ ctl2)); split; auto.

    inv H5. eapply control_as_safe_bupd; auto.

    destruct H10 as (?&?&?). inv H5.

    exists (State ve te (l ++ ctl2)); split; auto. eapply control_as_safe_bupd; auto.

    destruct optid; auto.

    exists (State ve (PTree.set i Vundef te) (l ++ ctl2)); split; auto.  inv H5. eapply control_as_safe_bupd; auto.

    exists (State ve te (l ++ ctl2)); split; auto. eapply control_as_safe_bupd; auto.

    inv H5. auto. }

   contradiction. }

  

  { destruct (IHcl_step (Kseq s1) (Kseq s2 :: l)

            _ (eq_refl _) _ (eq_refl _) Hb Hc Hg H1 (eq_refl _))

      as [c2 [m2 [? ?]]]; clear IHcl_step.

    destruct H2 as [H2 [H2b H2c]].

    exists c2, m2; split; auto. split3; auto. constructor. apply H2. }

  

  { destruct l.

    simpl in H.

   assert (jsafeN (@OK_spec Espec) ge (S n) ora (State ve te ctl1) m0).

   { econstructor; eauto; split3; eauto. }

   apply CS0 in H2; auto.

    eapply safe_step_forward in H2; auto.

   destruct H2 as [st2 [m2 [? ?]]]; exists st2; exists m2; split; auto.

   simpl.

     destruct H2 as [H2 [H2b H2c]].

    split3; auto.

    simpl; rewrite <- strip_step. simpl. rewrite strip_step; auto.

    destruct (IHcl_step c l _ (eq_refl _) _ (eq_refl _) Hb Hc Hg H1 (eq_refl _))

      as [c2 [m2 [? ?]]]; clear IHcl_step.

    exists c2; exists m2; split; auto.

    destruct H2 as [H2 [H2b H2c]].

   simpl.

   split3; auto.

   simpl; rewrite <- strip_step.

   change (strip_skip (Kseq Sskip :: c :: l ++ ctl2)) with (strip_skip (c::l++ctl2)).

   rewrite strip_step; auto. }

  

  case_eq (continue_cont l); intros.

  assert (continue_cont (l++ctl1) = continue_cont (l++ctl2)).

  clear - H0 H2.

  induction l; simpl in *.

 revert ctl2 H0; induction ctl1; simpl; intros.

 revert H0; induction ctl2; simpl; intros; auto.

 destruct a; simpl in *; auto. inv H0. inv H0.

 destruct a; auto.

 revert H0; induction ctl2; simpl; intros. inv H0.

 destruct a; try congruence. rewrite <- (IHctl2 H0).

 f_equal.

 revert H0; induction ctl2; simpl; intros; try destruct a; try congruence.

 auto.

 revert H0; induction ctl2; simpl; intros; try destruct a; try congruence.

 auto.

 revert H0; induction ctl2; simpl; intros; try destruct a; try congruence.

 auto.

 destruct a; try congruence. auto. auto.

  rewrite H3 in H.

  exists st', m'0; split; auto.

  split3; auto.

  constructor. auto.

  assert (forall k, continue_cont (l++k) = c::l0++k).

  clear - H2. revert H2; induction l; intros; try destruct a; simpl in *; auto; try discriminate.

  repeat rewrite cons_app'. f_equal; auto.

  rewrite H3 in H, IHcl_step.

  destruct (IHcl_step _ _ _ (eq_refl _) _ (eq_refl _) Hb Hc Hg H1 (eq_refl _)) as [c2 [m2 [? ?]]]; clear IHcl_step.

  exists c2,m2; split; auto.

   destruct H5 as [H5 [H5b H5c]].

 split3; auto.

 constructor. rewrite H3; auto.

  

{

  case_eq (prebreak_cont l); intros.

  {

  assert (break_cont (l++ctl1) = break_cont (l++ctl2)).

  clear - H0 H2.

  revert H2; induction l; simpl; intros; try destruct a; try congruence.

  revert ctl2 H0; induction ctl1; simpl; intros.

 revert H0; induction ctl2; simpl; intros; try destruct a; try congruence. auto.

 destruct a. auto.

 revert H0; induction ctl2; try destruct a; simpl; intros; try congruence; auto.

 revert H0; induction ctl2; try destruct a; simpl; intros; try congruence; auto.

 revert H0; induction ctl2; try destruct a; simpl; intros; try congruence; auto.

 revert H0; induction ctl2; try destruct a; simpl; intros; try congruence; auto.

 destruct s; auto.

  rewrite H3 in H.

  exists st', m'0; split; auto.

  split3; auto.

  constructor. auto.

  }

  {

  assert (PB:= prebreak_cont_is l); rewrite H2 in PB.

  destruct c; try contradiction.

  {

  assert (forall k, break_cont (l++k) = l0++k).

  clear - H2.

  revert H2; induction l; intros; try destruct a; simpl in *; auto; congruence.

  rewrite H3 in H.

  destruct l0; simpl in *.

  hnf in CS0.

  specialize (CS0 ora ve te m0 (S n)).

  assert (semantics.corestep (juicy_core_sem (cl_core_sem ge)) (State ve te ctl1) m0 st' m'0).

  split3; auto.

  pose proof (@jsafeN_step genv _ _ genv_symb_injective (cl_core_sem ge) OK_spec ge _ _ _ _ _ _ H5 H1).

  apply CS0 in H6; auto.

  destruct (safe_step_forward ge n ora (State ve te ctl2) m0) as [c2 [m2 [? ?]]]; auto.

  exists c2; exists m2; split; auto.

  destruct H7;  constructor; auto. constructor; auto. rewrite H3. auto.

  destruct (IHcl_step c l0 m0 (eq_refl _) m'0 (eq_refl _)) as [c2 [m2 [? ?]]]; auto.

  rewrite H3; auto.

  exists c2,m2; split; auto.

  destruct H5; split; auto. constructor; auto. rewrite H3; auto.

  }

  {

  assert (forall k, break_cont (l++k) = l0++k).

  clear - H2.

  revert H2; induction l; intros; try destruct a; simpl in *; auto; congruence.

  rewrite H3 in H.

  destruct l0; simpl in *.

  hnf in CS0.

  specialize (CS0 ora ve te m0 (S n)).

  assert (semantics.corestep (juicy_core_sem (cl_core_sem ge)) (State ve te ctl1) m0 st' m'0).

  split3; auto.

  pose proof (@jsafeN_step genv _ _ genv_symb_injective  (cl_core_sem ge) OK_spec ge _ _ _ _ _ _ H5 H1).

  apply CS0 in H6; auto.

  destruct (safe_step_forward ge n ora (State ve te ctl2) m0) as [c2 [m2 [? ?]]]; auto.

  exists c2; exists m2; split; auto.

  destruct H7;  constructor; auto. constructor; auto. rewrite H3. auto.

  destruct (IHcl_step c l0 m0 (eq_refl _) m'0 (eq_refl _)) as [c2 [m2 [? ?]]]; auto.

  rewrite H3; auto.

  exists c2,m2; split; auto.

  destruct H5; split; auto. constructor; auto. rewrite H3; auto.

  }

  {

  assert (forall k, break_cont (l++k) = l0++k).

  clear - H2.

  revert H2; induction l; intros; try destruct a; simpl in *; auto; congruence.

  rewrite H3 in H.

  destruct l0; simpl in *.

  hnf in CS0.

  specialize (CS0 ora ve te m0 (S n)).

  assert (semantics.corestep (juicy_core_sem (cl_core_sem ge)) (State ve te ctl1) m0 st' m'0).

  split3; auto.

  pose proof (@jsafeN_step genv _ _ genv_symb_injective  (cl_core_sem ge) OK_spec ge _ _ _ _ _ _ H5 H1).

  apply CS0 in H6; auto.

  destruct (safe_step_forward ge n ora (State ve te ctl2) m0) as [c2 [m2 [? ?]]]; auto.

  exists c2; exists m2; split; auto.

  destruct H7;  constructor; auto. constructor; auto. rewrite H3. auto.

  destruct (IHcl_step c l0 m0 (eq_refl _) m'0 (eq_refl _)) as [c2 [m2 [? ?]]]; auto.

  rewrite H3; auto.

  exists c2,m2; split; auto.

  destruct H5; split; auto. constructor; auto. rewrite H3; auto.

  }

  }

}

  

  exists (State ve te (Kseq (if b then s1 else s2) :: l ++ ctl2)), m'.

  split. split3; auto. rewrite <- Heqdm'. econstructor; eauto.

  rewrite cons_app. rewrite <- app_ass.

  eapply control_as_safe_bupd; auto.

  

  change (Kseq s1 :: Kseq Scontinue :: Kloop1 s1 s2 :: l ++ ctl1) with

               ((Kseq s1 :: Kseq Scontinue :: Kloop1 s1 s2 :: l) ++ ctl1) in H1.

  eapply control_as_safe_bupd in H1; eauto.

  do 2 eexists; split; eauto.

   split3; eauto. rewrite <- Heqdm'.

  econstructor; eauto.

  

  change (Kseq s :: Kseq Scontinue :: Kloop1 s a3 :: l ++ ctl1) with

              ((Kseq s :: Kseq Scontinue :: Kloop1 s a3 :: l) ++ ctl1) in H1.

  eapply control_as_safe_bupd in H1; eauto.

  do 2 eexists; split; eauto.   split3; eauto. rewrite <- Heqdm'.  econstructor; eauto.

 

  case_eq (call_cont l); intros.

  rewrite call_cont_app_nil in * by auto.

  exists (State ve' te'' k'), m'0; split; auto.

  split3; auto.

  econstructor; try eassumption. rewrite call_cont_app_nil; auto.

  rewrite <- (filter_seq_call_cont _ _ H0); auto.

  rewrite (call_cont_app_cons _ _ _ H6) in H. inv H.

  do 2 eexists; split.

  split3; eauto.

  econstructor; try eassumption.

 rewrite (call_cont_app_cons _ _ _ H6). reflexivity.

  eapply control_as_safe_bupd; auto.

 

  do 2 eexists; split; [split3; [| eauto | eauto] | ].

  rewrite <- Heqdm'. econstructor; eauto.

  do 2 rewrite cons_app'. eapply control_as_safe_bupd; auto.

 

  destruct (IHcl_step _ _  _ (eq_refl _) _ (eq_refl _) Hb Hc Hg H1 (eq_refl _)) as [c2 [m2 [? ?]]]; clear IHcl_step.

  exists c2, m2; split; auto.

   destruct H2 as [H2 [H2b H2c]].

  split3; auto.

  constructor; auto.

 

  case_eq (call_cont l); intros.

  do 2 eexists; split; [ | apply H1].

  split3; auto.

  rewrite <- Heqdm'; econstructor. 2: rewrite call_cont_app_nil; auto.

  instantiate (1:=f).

  generalize (filter_seq_current_function ctl1 ctl2 H0); intro.

  clear - H3 H2 CUR.

  revert l H3 H2 CUR; induction l; simpl; try destruct a; intros; auto; try congruence.

  rewrite call_cont_app_nil in H by auto.

  rewrite <- (filter_seq_call_cont ctl1 ctl2 H0); eauto.

  rewrite (call_cont_app_cons _ _ _ H2) in H.

  assert (exists j, k' = j ++ ctl1).

  clear - H2 H.

  assert (exists id, exists f, exists ve, exists te, c =  Kcall id f ve te).

  clear - H2; induction l; [inv H2 | ].

  destruct a; simpl in H2; auto. inv H2; do 4 eexists; reflexivity.

  destruct H0 as [id [ff [ve [te ?]]]]. clear H2; subst c.

  change (find_label lbl (fn_body f)

      ((Kseq (Sreturn None) :: Kcall id ff ve te :: l0) ++ ctl1) = Some k') in H.

  forget (Kseq (Sreturn None) :: Kcall id ff ve te :: l0) as pre.

  assert (exists j, k' = j++ (pre++ctl1));

   [ | destruct H0 as [j H0]; exists (j++pre); rewrite app_ass; auto ].

  forget (pre++ctl1) as ctl. forget (fn_body f) as s;  clear - H.

 eapply find_label_prefix; eauto.

  destruct H3 as [j ?].

  subst k'.

  exists (State ve te (j++ctl2)), m'; split; [ | eapply control_as_safe_bupd; eauto].

  split3; auto.

  rewrite <- Heqdm'; econstructor.

  instantiate (1:=f).

  clear - CUR H2.

  revert f c l0 CUR H2; induction l; simpl; intros. inv H2.

  destruct a; simpl in *; eauto.

  rewrite (call_cont_app_cons _ _ _ H2).

  clear - H2 H.

  change (Kseq (Sreturn None) :: c :: l0 ++ ctl1) with ((Kseq (Sreturn None) :: c :: l0) ++ ctl1) in H.

  change (Kseq (Sreturn None) :: c :: l0 ++ ctl2) with ((Kseq (Sreturn None) :: c :: l0) ++ ctl2).

  forget (Kseq (Sreturn None) :: c :: l0)  as pre.

clear - H.

 eapply find_label_prefix2; eauto.

Qed.



Lemma control_as_safe_le {Espec: OracleKind}:

  forall n' n ge ctl1 ctl2, n' <= n -> control_as_safe ge n ctl1 ctl2 -> control_as_safe ge n' ctl1 ctl2.

Proof.

 intros. intro; intros. eapply H0; auto; omega.

Qed.



Lemma control_suffix_safe {Espec: OracleKind}:

    forall

      ge n ctl1 ctl2 k,

      filter_seq ctl1 = filter_seq ctl2 ->

      control_as_safe ge n ctl1 ctl2 ->

      control_as_safe ge n (k ++ ctl1) (k ++ ctl2).

  Proof.

    intro ge. induction n using (well_founded_induction lt_wf).

    intros. hnf; intros.

    destruct n'; [ constructor | ].

    assert (forall k, control_as_safe ge n' (k ++ ctl1) (k ++ ctl2)).

    intro; apply H; auto. apply control_as_safe_le with n; eauto. omega.

   case_eq (strip_skip k); intros.

    rewrite <- safeN_strip in H3|-*.  rewrite strip_skip_app in H3|-* by auto.

   rewrite safeN_strip in H3|-*.

    auto.

   assert (ZZ: forall k, strip_skip (c::l++k) = c::l++k)

    by (clear - H5; intros; rewrite <- (strip_skip_app_cons H5); rewrite strip_strip; auto).

  rewrite <- safeN_strip in H3|-*.

  rewrite (strip_skip_app_cons H5) in H3|-* by auto.

  inv H3.

  apply corestep_preservation_lemma

    with (c0 := c) (l0 := l) (ve0 := ve) (te0 := te) (m0 := m)

         (ctl3:=ctl1) (ctl4:=ctl2) (n0 := n') in H8; auto.

   destruct H8 as [? [? [? ?]]].

   econstructor; eauto.

   eapply control_as_safe_le; eauto.

  simpl in H7. congruence.

  simpl in H6. unfold cl_halted in H6. contradiction.

Qed.



Lemma guard_safe_adj {Espec: OracleKind}:

 forall

   psi Delta P k1 k2,

   current_function k1 = current_function k2 ->

  (forall ora m ve te n,

     jsafeN (@OK_spec Espec) psi n ora (State ve te k1) m ->

     jsafeN (@OK_spec Espec) psi n ora (State ve te k2) m) ->

  guard Espec psi Delta P k1 |-- guard Espec psi Delta P k2.

Proof.

intros.

unfold guard.

apply allp_derives. intros tx.

apply allp_derives. intros vx.

rewrite H; apply subp_derives; auto.

apply bupd_mono.

intros w ? ? ? ? ? ?.

apply H0.

eapply H1; eauto.

Qed.



Lemma assert_safe_adj:

  forall {Espec: OracleKind} ge ve te k k' rho,

      (forall n, control_as_safe ge n k k') ->

     assert_safe Espec ge ve te k rho |-- assert_safe Espec ge ve te k' rho.

Proof.

 intros. apply bupd_mono. intros w ? ? ? ? ? ?. specialize (H0 ora jm H1 H2 H3).

 eapply H; try apply H0. apply le_refl.

Qed.



Lemma assert_safe_adj':

  forall {Espec: OracleKind} ge ve te k k' rho P w,

      (forall n, control_as_safe ge n k k') ->

     app_pred (P >=> assert_safe Espec ge ve te k rho) w ->

     app_pred (P >=> assert_safe Espec ge ve te k' rho) w.

Proof.

 intros.

 eapply subp_trans'; [ | apply derives_subp; eapply assert_safe_adj; try eassumption; eauto].

 auto.

Qed.



Lemma rguard_adj:

  forall {Espec: OracleKind} ge Delta R k k',

      current_function k = current_function k' ->

      (forall ek vl n, control_as_safe ge n (exit_cont ek vl k) (exit_cont ek vl k')) ->

      rguard Espec ge Delta R k |-- rguard Espec ge Delta R k'.

Proof.

 intros.

 intros n H1;  hnf in H1|-*.

 intros ek vl te ve; specialize (H1 ek vl te ve).

 rewrite <- H.

 eapply assert_safe_adj'; eauto.

Qed.



Lemma assert_safe_last': forall {Espec: OracleKind} ge ve te ctl rho w,

            (age1 w <> None -> assert_safe Espec ge ve te ctl rho w) ->

             assert_safe Espec ge ve te ctl rho w.

Proof.

 intros. apply assert_safe_last; intros. apply H. rewrite H0. congruence.

Qed.



Lemma pjoinable_emp_None {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

  forall w: option (psepalg.lifted JA), identity w ->  w=None.

Proof.

intros.

destruct w; auto.

elimtype False.

specialize (H None (Some l)).

spec H.

constructor.

inversion H.

Qed.



Lemma pjoinable_None_emp {A}{JA: Join A}{PA: Perm_alg A}{SA: Sep_alg A}:

           identity (None: option (psepalg.lifted JA)).

Proof.

intros; intro; intros.

inv H; auto.

Qed.



Lemma unage_mapsto:

  forall sh t v1 v2 w, age1 w <> None -> (|> mapsto sh t v1 v2) w -> mapsto sh t v1 v2 w.

Proof.

  intros.

  case_eq (age1 w); intros; try contradiction.

  clear H.

  specialize (H0 _ (age_laterR H1)).

  unfold mapsto in *.

  revert H0; case_eq (access_mode t); intros; auto.

  destruct (type_is_volatile t); try contradiction.

  destruct v1; try contradiction.

  rename H into Hmode.

  if_tac; rename H into H_READ.

  + destruct H0 as [H0|H0]; [left | right].

    destruct H0 as [H0' H0]; split; auto.

    destruct H0 as [bl [[] ?]]; exists bl; split; [split|]; auto.

    clear - H0 H1.

     intro loc'; specialize (H0 loc').

     hnf in *.

     if_tac.

     destruct H0 as [p ?]; exists p.

     hnf in *.

     rewrite preds_fmap_NoneP in *.

     apply (age1_YES w r); auto.

     unfold noat in *; simpl in *.

    apply <- (age1_resource_at_identity _ _ loc' H1); auto.

    eapply age1_ghost_of_identity; eauto.

    destruct H0 as [? [v2' [bl [[] ?]]]].

    hnf in H. subst v2. split; hnf; auto. exists v2', bl; split; [split|]; auto.

    clear - H2 H1; rename H2 into H0.

     intro loc'; specialize (H0 loc').

     hnf in *.

     if_tac.

     destruct H0 as [p ?]; exists p.

     hnf in *.

     rewrite preds_fmap_NoneP in *.

     apply (age1_YES w r); auto.

     unfold noat in *; simpl in *.

    apply <- (age1_resource_at_identity _ _ loc' H1); auto.

    eapply age1_ghost_of_identity; eauto.

  + split; [exact (proj1 H0) |].

    destruct H0 as [_ [? Hg]].

    split; [|eapply age1_ghost_of_identity; eauto].

    intro loc'; specialize (H loc').

    hnf in *.

    if_tac.

    - unfold shareat in *; simpl in *.

      pose proof H1.

      apply age1_resource_share with (l := loc') in H1.

      apply age1_nonlock with (l := loc') in H2.

      rewrite H1; tauto.

    - unfold noat in *; simpl in *.

      apply <- (age1_resource_at_identity _ _ loc' H1); auto.

Qed.



Lemma semax_extensionality_Delta {CS: compspecs} {Espec: OracleKind}:

  forall Delta Delta' P c R,

       tycontext_sub Delta Delta' ->

     semax Espec Delta P c R -> semax Espec Delta' P c R.

Proof.

intros.

unfold semax in *.

intros.

specialize (H0 n).

apply (semax_extensionality1 Delta Delta' P P c R R); auto.

split; auto.

split; auto.

intros ? ? ?; auto.

Qed.



End extensions.



Definition Cnot (e: Clight.expr) : Clight.expr :=

   Clight.Eunop Cop.Onotbool e type_bool.



Section statement_rect.

  Variable P : statement -> Type.

  Variable Q : labeled_statements -> Type.

  Variable f : P Sskip.

  Variable f0 : forall e e0 : expr, P (Sassign e e0).

  Variable f1 : forall (i : ident) (e : expr), P (Sset i e).

  Variable f2 : forall (o : option ident) (e : expr) (l : list expr), P (Scall o e l).

  Variable f3 : forall (o : option ident) (e : external_function) (t : typelist) (l : list expr), P (Sbuiltin o e t l).

  Variable f4 : forall s : statement, P s -> forall s0 : statement, P s0 -> P (Ssequence s s0).

  Variable f5 : forall (e : expr) (s : statement), P s -> forall s0 : statement, P s0 -> P (Sifthenelse e s s0).

  Variable f6 : forall s : statement, P s -> forall s0 : statement, P s0 -> P (Sloop s s0).

  Variable f7 : P Sbreak.

  Variable f8 : P Scontinue.

  Variable f9 : forall o : option expr, P (Sreturn o).

  Variable f10 : forall (e : expr) (l : labeled_statements), Q l -> P (Sswitch e l).

  Variable f11 : forall (l : label) (s : statement), P s -> P (Slabel l s).

  Variable f12 : forall l : label, P (Sgoto l).

  Variable f13 : Q LSnil.

  Variable f14 : forall (o : option Z) (s : statement) (l : labeled_statements), P s -> Q l -> Q (LScons o s l).



  Fixpoint statement_rect (s : statement) : P s :=

  match s as s0 return (P s0) with

  | Sskip => f

  | Sassign e e0 => f0 e e0

  | Sset i e => f1 i e

  | Scall o e l => f2 o e l

  | Sbuiltin o e t l => f3 o e t l

  | Ssequence s0 s1 => f4 s0 (statement_rect s0) s1 (statement_rect s1)

  | Sifthenelse e s0 s1 => f5 e s0 (statement_rect s0) s1 (statement_rect s1)

  | Sloop s0 s1 => f6 s0 (statement_rect s0) s1 (statement_rect s1)

  | Sbreak => f7

  | Scontinue => f8

  | Sreturn o => f9 o

  | Sswitch e l => f10 e l (labeled_statements_rect l)

  | Slabel l s0 => f11 l s0 (statement_rect s0)

  | Sgoto l => f12 l

  end

  with labeled_statements_rect (l : labeled_statements) : Q l :=

  match l as l0 return (Q l0) with

  | LSnil => f13

  | LScons o s l0 => f14 o s l0 (statement_rect s) (labeled_statements_rect l0)

  end.

End statement_rect.



Require Import VST.msl.eq_dec.
(* VST.msl.eq_dec:
Require Import VST.msl.base.

Class EqDec (A : Type) : Type :=
  eq_dec : forall a a' : A, {a = a'} + {a <> a'}.

Instance EqDec_nat : EqDec nat := eq_nat_dec.

Definition upd {A} `{EqDec A} (B : Type) (f : A -> B) (a : A) (b : B) : A -> B :=
  fun a' => if eq_dec a a' then b else f a'.
Arguments upd [A H B] _ _ _ _.

Lemma upd_eq {A} `{EqDec A} : forall B (f : A -> B) a b,
  upd f a b a = b.
Arguments upd_eq [A H B] _ _ _.

Lemma upd_eq' {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a = a' ->
  upd f a b a' = b.
Arguments upd_eq' [A H B] _ _ _ _ _.

Lemma upd_neq {A} `{EqDec A} : forall B (f : A -> B) a b a',
  a <> a' ->
  upd f a b a' = f a'. *)



Section eq_dec.

  Local Ltac t := hnf; decide equality; auto.



  Let eq_dec_type := type_eq.

  Let eq_dec_float := Float.eq_dec.

  Let eq_dec_float32 := Float32.eq_dec.

  Let eq_dec_int := Int.eq_dec.

  Let eq_dec_int64 := Int64.eq_dec.

  Let eq_dec_ident := ident_eq.

  Let eq_dec_signature := signature_eq.

  Let eq_dec_attr : EqDec attr. repeat t. Qed.

  Let eq_dec_signedness : EqDec signedness. t. Qed.

  Let eq_dec_intsize : EqDec intsize. t. Qed.

  Let eq_dec_floatsize : EqDec floatsize. t. Qed.

  Let eq_dec_Z : EqDec Z. repeat t. Qed.

  Let eq_dec_calling_convention : EqDec calling_convention. repeat t. Qed.

  Lemma eq_dec_external_function : EqDec external_function. repeat t. Qed.

  Let eq_dec_option_ident := option_eq (ident_eq).

  Let eq_dec_option_Z : EqDec (option Z). repeat t. Qed.

  Let eq_dec_typelist : EqDec typelist. repeat t. Qed.



  Lemma eq_dec_expr : EqDec expr.

  Proof. repeat t. Qed.



  Let eq_dec_expr := eq_dec_expr.

  Let eq_dec_option_expr : EqDec (option expr). repeat t. Qed.

  Let eq_dec_list_expr : EqDec (list expr). repeat t. Qed.



  Local Ltac eq_dec a a' :=

    let H := fresh in

    assert (H : {a = a'} + {a <> a'}) by (auto; repeat (decide equality ; auto));

    destruct H; [subst; auto | try (right; congruence)].



  Lemma eq_dec_statement : forall s s' : statement, { s = s' } + { s <> s' }.

  Proof.

    apply

      (statement_rect

         (fun s => forall s', { s = s' } + { s <> s' })

         (fun l => forall l', { l = l' } + { l <> l' }));

      try (intros until s'; destruct s'); intros;

      try (destruct l');

      try solve [right; congruence | left; reflexivity];

      repeat

        match goal with

        | |- context [ ?x ?a          = ?x ?b          ] => eq_dec a b

        | |- context [ ?x ?y ?a       = ?x ?y ?b       ] => eq_dec a b

        | |- context [ ?x ?a _        = ?x ?b _        ] => eq_dec a b

        | |- context [ ?x ?y ?z ?a    = ?x ?y ?z ?b    ] => eq_dec a b

        | |- context [ ?x ?y ?a _     = ?x ?y ?b _     ] => eq_dec a b

        | |- context [ ?x ?a _  _     = ?x ?b _  _     ] => eq_dec a b

        | |- context [ ?x ?y ?z ?t ?a = ?x ?y ?z ?t ?b ] => eq_dec a b

        | |- context [ ?x ?y ?z ?a _  = ?x ?y ?z ?b _  ] => eq_dec a b

        | |- context [ ?x ?y ?a _  _  = ?x ?y ?b _  _  ] => eq_dec a b

        | |- context [ ?x ?a _  _  _  = ?x ?b _  _  _  ] => eq_dec a b

        end.

  Qed.



  Lemma eq_dec_labeled_statements : forall l l' : labeled_statements, { l = l' } + { l <> l' }.

  Proof.

    decide equality.

    apply eq_dec_statement.

  Qed.



End eq_dec.



Instance EqDec_statement: EqDec statement := eq_dec_statement.

Instance EqDec_external_function: EqDec external_function := eq_dec_external_function.



Lemma closed_Slabel l c F: closed_wrt_modvars (Slabel l c) F = closed_wrt_modvars c F.

Proof. unfold closed_wrt_modvars. rewrite modifiedvars_Slabel. trivial. Qed.



Lemma closed_Sifthenelse b c1 c2 F: closed_wrt_modvars (Sifthenelse b c1 c2) F <-> closed_wrt_modvars c1 F /\ closed_wrt_modvars c2 F.

Proof.

  unfold closed_wrt_modvars.

  pose proof modifiedvars_Sifthenelse b c1 c2.

  pose proof modifiedvars_computable c1 as TC.

  forget (modifiedvars (Sifthenelse b c1 c2)) as S.

  forget (modifiedvars c1) as S1.

  forget (modifiedvars c2) as S2.

  clear b c1 c2.

  unfold closed_wrt_vars.

  split; [intros; split; intros | intros [? ?]; intros].

  + apply H0.

    intros.

    specialize (H1 i).

    specialize (H i).

    clear - H H1.

    tauto.

  + apply H0.

    intros.

    specialize (H1 i).

    specialize (H i).

    clear - H H1.

    tauto.

  + specialize (TC (te_of rho) te').

    destruct TC as [te'' [? ?]].

    transitivity (F (mkEnviron (ge_of rho) (ve_of rho) te'')).

    - apply H1.

      clear H0 H1.

      intros.

      specialize (H3 i).

      specialize (H i).

      specialize (H2 i).

      specialize (H4 i).

      destruct H2; [| rewrite <- H0 in *]; tauto.

    - change (mkEnviron (ge_of rho) (ve_of rho) te') with (mkEnviron (ge_of (mkEnviron (ge_of rho) (ve_of rho) te'')) (ve_of (mkEnviron (ge_of rho) (ve_of rho) te'')) te').

      change te'' with (te_of (mkEnviron (ge_of rho) (ve_of rho) te'')) in H3, H4, H2.

      forget (mkEnviron (ge_of rho) (ve_of rho) te'') as rho'.

      apply H0.

      clear H0 H1 H2 H3 H te''.

      intros.

      specialize (H4 i).

      destruct H4; [auto | right; congruence].

Qed.



Lemma closed_Sloop c1 c2 F: closed_wrt_modvars (Sloop c1 c2) F <-> closed_wrt_modvars c1 F /\ closed_wrt_modvars c2 F.

Proof.

  unfold closed_wrt_modvars.

  pose proof modifiedvars_Sloop c1 c2.

  pose proof modifiedvars_computable c1 as TC.

  forget (modifiedvars (Sloop c1 c2)) as S.

  forget (modifiedvars c1) as S1.

  forget (modifiedvars c2) as S2.

  clear c1 c2.

  unfold closed_wrt_vars.

  split; [intros; split; intros | intros [? ?]; intros].

  + apply H0.

    intros.

    specialize (H1 i).

    specialize (H i).

    clear - H H1.

    tauto.

  + apply H0.

    intros.

    specialize (H1 i).

    specialize (H i).

    clear - H H1.

    tauto.

  + specialize (TC (te_of rho) te').

    destruct TC as [te'' [? ?]].

    transitivity (F (mkEnviron (ge_of rho) (ve_of rho) te'')).

    - apply H1.

      clear H0 H1.

      intros.

      specialize (H3 i).

      specialize (H i).

      specialize (H2 i).

      specialize (H4 i).

      destruct H2; [| rewrite <- H0 in *]; tauto.

    - change (mkEnviron (ge_of rho) (ve_of rho) te') with (mkEnviron (ge_of (mkEnviron (ge_of rho) (ve_of rho) te'')) (ve_of (mkEnviron (ge_of rho) (ve_of rho) te'')) te').

      change te'' with (te_of (mkEnviron (ge_of rho) (ve_of rho) te'')) in H3, H4, H2.

      forget (mkEnviron (ge_of rho) (ve_of rho) te'') as rho'.

      apply H0.

      clear H0 H1 H2 H3 H te''.

      intros.

      specialize (H4 i).

      destruct H4; [auto | right; congruence].

Qed.



Lemma closed_Ssequence c1 c2 F: closed_wrt_modvars (Ssequence c1 c2) F <-> closed_wrt_modvars c1 F /\ closed_wrt_modvars c2 F.

Proof.

  unfold closed_wrt_modvars.

  pose proof modifiedvars_Ssequence c1 c2.

  pose proof modifiedvars_computable c1 as TC.

  forget (modifiedvars (Ssequence c1 c2)) as S.

  forget (modifiedvars c1) as S1.

  forget (modifiedvars c2) as S2.

  clear c1 c2.

  unfold closed_wrt_vars.

  split; [intros; split; intros | intros [? ?]; intros].

  + apply H0.

    intros.

    specialize (H1 i).

    specialize (H i).

    clear - H H1.

    tauto.

  + apply H0.

    intros.

    specialize (H1 i).

    specialize (H i).

    clear - H H1.

    tauto.

  + specialize (TC (te_of rho) te').

    destruct TC as [te'' [? ?]].

    transitivity (F (mkEnviron (ge_of rho) (ve_of rho) te'')).

    - apply H1.

      clear H0 H1.

      intros.

      specialize (H3 i).

      specialize (H i).

      specialize (H2 i).

      specialize (H4 i).

      destruct H2; [| rewrite <- H0 in *]; tauto.

    - change (mkEnviron (ge_of rho) (ve_of rho) te') with (mkEnviron (ge_of (mkEnviron (ge_of rho) (ve_of rho) te'')) (ve_of (mkEnviron (ge_of rho) (ve_of rho) te'')) te').

      change te'' with (te_of (mkEnviron (ge_of rho) (ve_of rho) te'')) in H3, H4, H2.

      forget (mkEnviron (ge_of rho) (ve_of rho) te'') as rho'.

      apply H0.

      clear H0 H1 H2 H3 H te''.

      intros.

      specialize (H4 i).

      destruct H4; [auto | right; congruence].

Qed.



Lemma closed_Sswitch e sl F:

  closed_wrt_modvars (Sswitch e sl) F ->

  (forall n, closed_wrt_modvars (seq_of_labeled_statement (select_switch (Int.unsigned n) sl)) F).

Proof.

  intros.

  unfold closed_wrt_modvars, closed_wrt_vars in *.

  intros.

  apply H.

  intros.

  specialize (H0 i); destruct H0; auto.

  left.

  eapply modifiedvars_Sswitch; eauto.

Qed.



Lemma semax_eq:

 forall {CS: compspecs} {Espec: OracleKind} Delta P c R,

  semax Espec Delta P c R = 

  (TT |-- (ALL psi : genv,

         ALL Delta' : tycontext,

         !! (tycontext_sub Delta Delta' /\ genv_cenv psi = cenv_cs) -->

         believe Espec Delta' psi Delta' -->

         ALL k : cont ,

         ALL F : assert ,

         !! closed_wrt_modvars c F &&

         rguard Espec psi Delta' (frame_ret_assert R F) k -->

         guard Espec psi Delta' (fun rho : environ => F rho * P rho) (Kseq c :: k))).

Proof.

intros.

extensionality w.

rewrite semax_fold_unfold.

apply prop_ext; intuition.

Qed.



Lemma safe_kseq_Slabel {Espec: OracleKind} psi n ora ve te l c k m :

  @jsafeN (@OK_ty Espec) (@OK_spec Espec) psi n ora

      (State ve te (@cons cont' (Kseq c) k)) m ->

@jsafeN (@OK_ty Espec) (@OK_spec Espec) psi n ora

  (State ve te (@cons cont' (Kseq (Slabel l c)) k)) m.

Proof.

inversion 1; subst.

+ constructor.

+ econstructor; eauto. simpl. destruct H0 as (?&?&?). split3; eauto. 

  simpl in H0. simpl. eapply step_label; trivial.

+ simpl in *; congruence.

+ simpl in *. unfold cl_halted in H0. contradiction.

Qed.



Lemma semax_Slabel {cs:compspecs} {Espec: OracleKind}

       (Gamma:tycontext) (P:environ -> mpred) (c:statement) (Q:ret_assert) l:

@semax cs Espec Gamma P c Q -> @semax cs Espec Gamma P (Slabel l c) Q.

Proof. intros. 

rewrite semax_eq. rewrite semax_eq in H.

eapply derives_trans. eassumption. clear H.

apply allp_derives; intros psi.

apply allp_derives; intros Delta.

apply prop_imp_derives; intros TC.

apply imp_derives; [ apply derives_refl | ].

apply allp_derives; intros k.

apply allp_derives; intros F.

apply imp_derives; [ apply derives_refl | ].

apply guard_safe_adj; [ trivial | intros].

apply safe_kseq_Slabel; trivial.

Qed.



Lemma denote_tc_resource: forall {cs: compspecs} rho a a' t, resource_at a = resource_at a' ->

  denote_tc_assert t rho a -> denote_tc_assert t rho a'.

Proof.

  induction t; auto; intros; simpl in *.

  - destruct H0; auto.

  - destruct H0; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho); auto; simpl in *; if_tac; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho); auto; simpl in *; if_tac; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho), (eval_expr e0 rho); auto; simpl in *.

    + simple_if_tac; auto.

      destruct H0; split; auto.

      destruct H1; [left | right]; simpl in *; rewrite <- H; auto.

    + simple_if_tac; auto.

      destruct H0; split; auto.

      destruct H1; [left | right]; simpl in *; rewrite <- H; auto.

    + unfold test_eq_ptrs in *.

      destruct (sameblock _ _), H0; split; simpl in *; rewrite <- H; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho), (eval_expr e0 rho); auto; simpl in *.

    unfold test_order_ptrs in *.

    destruct (sameblock _ _), H0; split; simpl in *; rewrite <- H; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho); auto; simpl in *; if_tac; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho); auto; simpl in *; if_tac; auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho); auto; simpl in *.

    + destruct (Zoffloat f); auto.

    + destruct (Zofsingle f); auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho); auto; simpl in *.

    + destruct (Zoffloat f); auto.

    + destruct (Zofsingle f); auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho), (eval_expr e0 rho); auto.

  - unfold liftx in *; simpl in *.

    unfold lift in *; simpl in *.

    destruct (eval_expr e rho), (eval_expr e0 rho); auto.

Qed.



Lemma bupd_denote_tc: forall {cs: compspecs} P t rho a,

  denote_tc_assert t rho a -> bupd P a -> bupd (denote_tc_assert t rho && P) a.

Proof.

  repeat intro.

  destruct (H0 _ H1) as (b & ? & m & ? & ? & ? & ?); subst.

  eexists; split; eauto; exists m; repeat split; eauto.

  eapply denote_tc_resource; [|eauto]; auto.

Qed.



Lemma assert_safe_jsafe: forall {Espec: OracleKind} ge ve te ctl ora jm,

  assert_safe Espec ge ve te ctl (construct_rho (filter_genv ge) ve te) (m_phi jm) ->

  jm_bupd ora (jsafeN OK_spec ge (level jm) ora (State ve te ctl)) jm.

Proof.

  repeat intro.

  destruct (H _ H1) as (? & ? & ? & Hl & Hr & ? & Hsafe); subst.

  destruct (juicy_mem_resource _ _ Hr) as (jm' & ? & ?); subst.

  exists jm'; repeat split; auto.

  rewrite level_juice_level_phi, <- Hl.

  apply Hsafe; auto.

  simpl.

  eapply joins_comm, join_sub_joins_trans, joins_comm, H2.

  destruct H0.

  change (Some (ghost_PCM.ext_ref ora, NoneP) :: nil) with

    (ghost_approx (m_phi jm) (Some (ghost_PCM.ext_ref ora, NoneP) :: nil)).

  eexists; apply ghost_fmap_join; eauto.

Qed.

