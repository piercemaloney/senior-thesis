

Set Implicit Arguments.



Require Import FCF.Crypto.
(* FCF.Crypto:
Require Export FCF.DistRules.
Require Export FCF.Comp.
Require Export Arith.
Require Export FCF.Fold.
Require Export FCF.Rat.
Require Export FCF.DistSem.
Require Export FCF.StdNat.
Require Export FCF.DistTacs.

Open Scope comp_scope.
Open Scope rat_scope. *)

Require Import FCF.RndNat.
(* FCF.RndNat:
Set Implicit Arguments.

Require Import FCF.Crypto.
Require Import Permutation.
Require Import FCF.NotationV1.
  
Definition RndNat_unchecked(n : nat) :=
  v <-$ {0,1} ^ (lognat n);
  let n := (bvToNat v) in
    ret n.

Definition ltNatBool := fun x1 x2 => if (lt_dec x1 x2) then true else false.

Definition RndNat(n : nat) :=
    (Repeat (RndNat_unchecked n) (fun x => (ltNatBool x n))).

Notation "[ 0 '..' n )" := (RndNat n)
  (right associativity, at level 77) : comp_scope.

Lemma well_formed_RndNat : forall n,
  n > O ->
  well_formed_comp (RndNat n).

Lemma RndNat_support_lt : forall n x,
  In x (getSupport (RndNat n)) ->
  x < n.

Hint Resolve well_formed_RndNat : wftac.

Lemma RndNat_unchecked_lt_support : forall n v,
  v < n ->
  In v (getSupport (RndNat_unchecked n)).

Local Open Scope rat_scope.

Lemma RndNat_uniform : forall v1 v2 n,
  v1 < n ->
  v2 < n -> 
  evalDist (RndNat n) v1 == evalDist (RndNat n) v2.

Lemma in_getSupport_RndNat : forall x k,
  x < k ->
  In x (getSupport (RndNat k)).

Lemma RndNat_support_length : 
  forall n, 
    length (getSupport (RndNat n)) = n.

Theorem RndNat_prob : 
  forall n i (nzn : nz n),
    i < n ->
    evalDist (RndNat n) i == 1 / n.

Theorem RndNat_seq : 
  forall (n : posnat)(A : Set)(c : nat -> Comp A) a,
    evalDist (x <-$ RndNat n; c x) a ==
    (1 / n) * sumList (allNatsLt n) (fun z => evalDist (c z) a).

Lemma rndNat_sumList : 
  forall (A : Set)(f : nat -> Comp A) n (nzn : nz n) x,
    evalDist (i <-$ RndNat n; f i) x == 
    sumList (forNats n) (fun i => (1 / n) * (evalDist (f i) x)). *)

Require Import FCF.NotationV1.
(* FCF.NotationV1:
Set Implicit Arguments.

Require Import FCF.Comp.

Local Open Scope comp_scope.

Notation "'ret' v" := (Ret (EqDec_dec _) v)
  (at level 75).

Notation "{ 0 , 1 } ^ n" := (Rnd n)
  (right associativity, at level 77) : comp_scope.

Notation "{ 0 , 1 }" := (Bind (Rnd 1) (fun m => ret (Vector.hd m)))
  (right associativity, at level 75) : comp_scope.

Notation "x <-$ c1 ; c2" := (@Bind _ _ c1%comp (fun x => c2)) 
  (right associativity, at level 81, c1 at next level) : comp_scope.

Notation "[ x1 , x2 ] <-$2 c1 ; c2" := 
  (Bind c1%comp (fun z => let '(x1, x2) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Notation "[ x1 , x2 , x3 ] <-$3 c1 ; c2" := 
  (Bind c1%comp (fun z => let '(x1, x2, x3) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Definition setLet(A : Set)(B : Type)(a : A)(f : A -> B) := f a.

Notation "x <- e1 ; e2" := (setLet e1 (fun x => e2)) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 ] <-2 e1 ; c2" := (let '(x1, x2) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 , x3 ] <-3 e1 ; c2" := (let '(x1, x2, x3) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 , x3 , x4 ] <-4 e1 ; c2" := (let '(x1, x2, x3, x4) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "[ x1 , x2 , x3 , x4 , x5 ] <-5 e1 ; c2" := (let '(x1, x2, x3, x4, x5) := e1 in c2) (right associativity, at level 81, e1 at next level) : comp_scope.

Notation "x <--$ c1 ; c2" := (OC_Bind c1%comp (fun x => c2)) 
  (right associativity, at level 81, c1 at next level) : comp_scope.

Notation "[ x1 , x2 ] <--$2 c1 ; c2" := 
  (OC_Bind c1%comp (fun z => let '(x1, x2) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Notation "[ x1 , x2 , x3 ] <--$3 c1 ; c2" := 
  (OC_Bind c1%comp (fun z => let '(x1, x2, x3) := z in c2)) (right associativity, at level 81, c1 at next level, only parsing) : comp_scope.

Notation "$ c" := (OC_Ret _ _ c) (at level 79) : comp_scope.

Notation "x <-? c1 ; c2" := (maybeBind c1 (fun x => (c2)))
                              (right associativity, at level 81, c1 at next level) : comp_scope.

Definition maybeBindComp(A B : Set)(eqdb : EqDec B)(c : Comp (option A))(f : A -> Comp B) : Comp (option B) :=
  opt_a <-$ c;
  match opt_a with
    | None => ret None
    | Some a => b <-$ (f a); ret (Some b)
  end.

Notation "x <-$? c1 ; c2" := 
   (maybeBindComp _ (c1)%comp (fun x => (c2)%comp))
                              (right associativity, at level 81, c1 at next level) : comp_scope.

Infix "xor" := (BVxor _) (at level 30). *)



Definition Bernoulli(r : Rat) : Comp bool :=

  match r with

    | RatIntro n d =>

      v <-$ RndNat d; ret (if (lt_dec v n) then true else false)

  end.



Theorem Bernoulli_correct : 

  forall (r : Rat),

    r <= 1 ->

    Pr[Bernoulli r] == r.



  unfold Bernoulli.

  intuition.

  destruct r.



  rewrite RndNat_seq.

  

  rewrite (sumList_filter_partition (fun z => if (lt_dec z n) then true else false)).

  eapply eqRat_trans.

  eapply ratMult_eqRat_compat.

  eapply eqRat_refl.

  eapply ratAdd_eqRat_compat.



  eapply sumList_all.

  intros.

  destruct ( lt_dec a n).

  simpl.

  destruct ( EqDec_dec bool_EqDec true true).

  eapply eqRat_refl.

  intuition.

  apply filter_In in H0.

  intuition.

  exfalso.

  destruct (lt_dec a n); intuition.



  eapply sumList_0.

  intros.

  apply filter_In in H0.

  intuition.

  destruct (lt_dec a n); simpl in *.

  discriminate.

  destruct (EqDec_dec bool_EqDec false true); intuition.



  rewrite allNatsLt_filter_lt.

  rewrite <- ratAdd_0_r.

  rewrite ratMult_1_r.

  rewrite allNatsLt_length.

  rewrite <- ratMult_num_den.

  eapply eqRat_terms.

  omega.

  unfold posnatMult, posnatToNat, natToPosnat.

  destruct p.

  omega.



  eapply rat_le_1_if; trivial.



Qed.



Theorem Bernoulli_wf : 

  forall r, 

    well_formed_comp (Bernoulli r).



  intuition.

  unfold Bernoulli.

  destruct r.

  wftac.



Qed.



Theorem Bernoulli_correct_complement : 

  forall (r : Rat),

    r <= 1 ->

    evalDist (Bernoulli r) false == 

    ratSubtract 1 r.



  intuition.

  eapply eqRat_trans.

  eapply evalDist_complement.

  eapply Bernoulli_wf.

  eapply ratSubtract_eqRat_compat; intuition.

  eapply Bernoulli_correct.

  trivial.

Qed.

