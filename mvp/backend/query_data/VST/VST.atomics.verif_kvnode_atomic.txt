Require Import VST.veric.rmaps.
Require Import VST.progs.ghosts.
Require Import atomics.general_atomics.
(* atomics.general_atomics:
Require Import VST.veric.rmaps.
Require Import VST.veric.compcert_rmaps.
Require Import VST.progs.ghosts.
Require Import VST.progs.conclib.
Require Import VST.progs.invariants.
Require Import VST.progs.fupd.
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Export Ensembles.

Set Bullet Behavior "Strict Subproofs".

Section atomics.

Context {CS : compspecs} {inv_names : invG}.

Section atomicity.

Lemma approx_mono: forall n P Q, (P >=> Q) (Nat.pred n) -> approx n P |-- approx n Q.

Lemma subp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P' >=> P -> G |-- Q >=> Q' ->
    G |-- ((P -* Q) >=> (P' -* Q'))%pred.

Lemma eqp_wand: forall (G : Triv) (P P' Q Q' : mpred), G |-- P <=> P' -> G |-- Q <=> Q' ->
    G |-- ((P -* Q) <=> (P' -* Q')).

Lemma subp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P >=> P' ->
    G |-- ((|={E1,E2}=> P) >=> |={E1,E2}=> P').

Lemma eqp_fupd: forall (G : Triv) E1 E2 (P P' : mpred), G |-- P <=> P' ->
    G |-- ((|={E1,E2}=> P) <=> |={E1,E2}=> P').

Lemma eqp_imp: forall (G : Triv) (P P' Q Q' : mpred),
       G |-- P <=> P' -> G |-- Q <=> Q' -> G |-- (P --> Q) <=> P' --> Q'.

Lemma fview_shift_nonexpansive: forall E1 E2 P Q n,
  approx n (P -* |={E1,E2}=> Q) = approx n (approx n P -* |={E1,E2}=> (approx n Q)).

Lemma emp_dup: forall P, P && emp = (P && emp) * (P && emp).

Definition atomic_shift {A B} (a : A -> mpred) Ei Eo (b : A -> B -> mpred) (Q : B -> mpred) :=
  EX P : mpred, |> P * ((|> P -* |={Eo,Ei}=> (EX x : A, a x *
    ((a x -* |={Ei,Eo}=> |> P) &&
     ALL y : B, b x y -* |={Ei,Eo}=> Q y))) && cored).

End atomicity.

End atomics.

Definition atomic_spec_type W T := ProdType (ProdType W (ArrowType (ConstType T) Mpred)) (ConstType invG).

Definition super_non_expansive_a {A W} (a : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> predicates_hered.pred rmap) :=
  forall n ts w x, approx n (a ts w x) =
  approx n (a ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x).

Definition super_non_expansive_b {A B W} (b : forall ts : list Type, functors.MixVariantFunctor._functor
  (dependent_type_functor_rec ts W) (predicates_hered.pred rmap) -> A -> B -> predicates_hered.pred rmap) :=
  forall n ts w x y, approx n (b ts w x y) =
  approx n (b ts (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) x y).

Definition super_non_expansive_la {W} la := forall n ts w rho,
  Forall (fun l => approx n (!! locald_denote (l ts w) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w)) rho)) la.

Definition super_non_expansive_lb {B W} lb := forall n ts w (v : B) rho,
  Forall (fun l => approx n (!! locald_denote (l ts w v) rho) = approx n (!! locald_denote (l ts
    (functors.MixVariantFunctor.fmap (dependent_type_functor_rec ts W) (approx n) (approx n) w) v) rho)) lb.

Program Definition atomic_spec {A T} W args tz la P a (t : T) lb b Ei Eo
  (Hla : super_non_expansive_la la) (HP : super_non_expansive' P) (Ha : super_non_expansive_a(A := A) a)
  (Hlb : super_non_expansive_lb lb) (Hb : super_non_expansive_b b) :=
  mk_funspec (pair args tz) cc_default (atomic_spec_type W T)
  (fun (ts: list Type) '(w, Q, inv_names) =>
    PROP ()
    (LOCALx (map (fun l => l ts w) la)
    (SEP (atomic_shift(inv_names := inv_names) (a ts w) Ei Eo (b ts w) Q; P ts w))))
  (fun (ts: list Type) '(w, Q, inv_names) => EX v : T,
    PROP () (LOCALx (map (fun l => l ts w v) lb)
    (SEP (Q v)))) _ _.

Ltac start_atomic_function :=
  match goal with |- semax_body ?V ?G ?F ?spec =>
    let s := fresh "spec" in
    pose (s:=spec); hnf in s;
    match goal with
    | s :=  (DECLARE _ WITH u : unit
               PRE  [] main_pre _ nil u
               POST [ tint ] main_post _ nil u) |- _ => idtac
    | s := ?spec' |- _ => check_canonical_funspec spec'
   end;
   change (semax_body V G F s); subst s
 end; unfold atomic_spec;
 let DependedTypeList := fresh "DependedTypeList" in
 match goal with |- semax_body _ _ _ (pair _ (mk_funspec _ _ _ ?Pre _ _ _)) =>
   match Pre with 
   | (fun x => match x with (a,b) => _ end) => intros Espec DependedTypeList [a b] 
   | (fun i => _) => intros Espec DependedTypeList (x, Q)
   end;
   simpl fn_body; simpl fn_params; simpl fn_return
 end;
 simpl functors.MixVariantFunctor._functor in *;
 simpl rmaps.dependent_type_functor_rec;
 repeat match goal with |- @semax _ _ _ (match ?p with (a,b) => _ end * _) _ _ =>
             destruct p as [a b]
           end;
 simplify_func_tycontext;
 repeat match goal with 
 | |- context [Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s) Sskip] =>
       fold (Swhile e s)
 | |- context [Ssequence ?s1 (Sloop (Ssequence (Sifthenelse ?e Sskip Sbreak) ?s2) ?s3) ] =>
      match s3 with
      | Sset ?i _ => match s1 with Sset ?i' _ => unify i i' | Sskip => idtac end
      end;
      fold (Sfor s1 e s2 s3)
 end;
 try expand_main_pre;
 process_stackframe_of;
 repeat change_mapsto_gvar_to_data_at;  
 repeat rewrite <- data_at__offset_zero;
 try apply start_function_aux1;
 repeat (apply semax_extract_PROP; 
              match goal with
              | |- _ ?sh -> _ =>
                 match type of sh with
                 | share => intros ?SH 
                 | Share.t => intros ?SH 
                 | _ => intro
                 end
               | |- _ => intro
               end);
 first [ eapply eliminate_extra_return'; [ reflexivity | reflexivity | ]
        | eapply eliminate_extra_return; [ reflexivity | reflexivity | ]
        | idtac];
 abbreviate_semax; simpl. *)
Require Import VST.progs.conclib.
Require Import atomics.maps.
(* atomics.maps:
Require Import VST.progs.conclib.
Require Import VST.progs.ghosts.
Require Import RelationClasses.

Section ListMaps.

Context {A B : Type} {A_eq : EqDec A} {d : Inhabitant B}.

Definition map_Znth i (L : A -> option (list B)) k := option_map (fun v => Znth i v) (L k).

Lemma map_Znth_single : forall i (k : A) (v : list B),
  map_Znth i (singleton k v) = singleton k (Znth i v).

Lemma map_Znth_add : forall (m1 m2 : A -> option (list B)) i,
  map_Znth i (map_add m1 m2) = map_add (map_Znth i m1) (map_Znth i m2).

Lemma map_Znth_eq : forall (L : A -> option (list B)) k vs (Hlength : forall vs', L k = Some vs' -> Zlength vs' = Zlength vs)
  (Hnz : vs <> []) (Hall : forall i, 0 <= i < Zlength vs -> map_Znth i L k = Some (Znth i vs)),
  L k = Some vs.

Lemma map_Znth_upd : forall (m : A -> option (list B)) k v i,
  map_Znth i (map_upd m k v) = map_upd (map_Znth i m) k (Znth i v).

Lemma map_incl_Znth : forall (m1 m2 : A -> option (list B)) i, map_incl m1 m2 ->
  map_incl (map_Znth i m1) (map_Znth i m2).

End ListMaps.

Section Logs.

Context {B : Type}.

Definition log_latest s (v1 : Z) (v2 : B) := s v1 = Some v2 /\ forall v', v1 < v' -> s v' = None.

Lemma log_latest_singleton : forall v1 v2, log_latest (singleton v1 v2) v1 v2.

Lemma log_incl_latest : forall k1 k2 v1 v2 log1 log2 (Hincl : map_incl log1 log2)
  (Hv1 : log1 k1 = Some v1) (Hlatest : log_latest log2 k2 v2), k1 <= k2.

Lemma log_latest_upd : forall log v1 v2 v1' v2', log_latest log v1 v2 -> v1 < v1' ->
  map_incl log (map_upd log v1' v2') /\ log_latest (map_upd log v1' v2') v1' v2'.

Lemma log_latest_inj : forall log v1 v2 v1' v2' (H1 : log_latest log v1 v2) (H1' : log_latest log v1' v2'),
  v1 = v1' /\ v2 = v2'.

Lemma log_latest_add : forall m1 m2 k1 k2 (v1 v2 : B)
  (Hlatest1 : log_latest m1 k1 v1) (Hlatest2 : log_latest m2 k2 v2),
  log_latest (map_add m1 m2) (Z.max k1 k2) (if zlt k1 k2 then v2 else v1).

Lemma log_latest_upd_list : forall l (m : Z -> option B) k v k' v' (Hm : log_latest m k v)
  (Hlast : last l (k, v) = (k', v')) (Hlt : k <= k') (Hordered : Forall (fun '(k, v) => k <= k') l),
  log_latest (map_upd_list m l) k' v'.

End Logs.

Lemma map_Znth_log_latest : forall {B} {d : Inhabitant B} m k (v : list B) i, log_latest m k v ->
  log_latest (map_Znth i m) k (Znth i v). *)
Require Import VST.floyd.library.
Require Import VST.floyd.sublist.
Require Import atomics.kvnode_atomic.
(* atomics.kvnode_atomic:
Require Import Clightdefs.
Local Open Scope Z_scope.
Definition ___builtin_annot : ident := 6%positive.
Definition ___builtin_annot_intval : ident := 7%positive.
Definition ___builtin_bswap : ident := 30%positive.
Definition ___builtin_bswap16 : ident := 32%positive.
Definition ___builtin_bswap32 : ident := 31%positive.
Definition ___builtin_clz : ident := 33%positive.
Definition ___builtin_clzl : ident := 34%positive.
Definition ___builtin_clzll : ident := 35%positive.
Definition ___builtin_ctz : ident := 36%positive.
Definition ___builtin_ctzl : ident := 37%positive.
Definition ___builtin_ctzll : ident := 38%positive.
Definition ___builtin_debug : ident := 51%positive.
Definition ___builtin_fabs : ident := 4%positive.
Definition ___builtin_fmadd : ident := 42%positive.
Definition ___builtin_fmax : ident := 40%positive.
Definition ___builtin_fmin : ident := 41%positive.
Definition ___builtin_fmsub : ident := 43%positive.
Definition ___builtin_fnmadd : ident := 44%positive.
Definition ___builtin_fnmsub : ident := 45%positive.
Definition ___builtin_fsqrt : ident := 39%positive.
Definition ___builtin_membar : ident := 8%positive.
Definition ___builtin_memcpy_aligned : ident := 5%positive.
Definition ___builtin_nop : ident := 50%positive.
Definition ___builtin_read16_reversed : ident := 46%positive.
Definition ___builtin_read32_reversed : ident := 47%positive.
Definition ___builtin_va_arg : ident := 10%positive.
Definition ___builtin_va_copy : ident := 11%positive.
Definition ___builtin_va_end : ident := 12%positive.
Definition ___builtin_va_start : ident := 9%positive.
Definition ___builtin_write16_reversed : ident := 48%positive.
Definition ___builtin_write32_reversed : ident := 49%positive.
Definition ___compcert_va_composite : ident := 16%positive.
Definition ___compcert_va_float64 : ident := 15%positive.
Definition ___compcert_va_int32 : ident := 13%positive.
Definition ___compcert_va_int64 : ident := 14%positive.
Definition ___i64_dtos : ident := 17%positive.
Definition ___i64_dtou : ident := 18%positive.
Definition ___i64_sar : ident := 29%positive.
Definition ___i64_sdiv : ident := 23%positive.
Definition ___i64_shl : ident := 27%positive.
Definition ___i64_shr : ident := 28%positive.
Definition ___i64_smod : ident := 25%positive.
Definition ___i64_stod : ident := 19%positive.
Definition ___i64_stof : ident := 21%positive.
Definition ___i64_udiv : ident := 24%positive.
Definition ___i64_umod : ident := 26%positive.
Definition ___i64_utod : ident := 20%positive.
Definition ___i64_utof : ident := 22%positive.
Definition _d : ident := 63%positive.
Definition _data : ident := 2%positive.
Definition _i : ident := 58%positive.
Definition _in : ident := 62%positive.
Definition _l : ident := 59%positive.
Definition _load_SC : ident := 52%positive.
Definition _main : ident := 65%positive.
Definition _n : ident := 54%positive.
Definition _node : ident := 3%positive.
Definition _out : ident := 55%positive.
Definition _read : ident := 61%positive.
Definition _snap : ident := 57%positive.
Definition _store_SC : ident := 53%positive.
Definition _v : ident := 60%positive.
Definition _ver : ident := 56%positive.
Definition _version : ident := 1%positive.
Definition _write : ident := 64%positive.
Definition _t'1 : ident := 66%positive.
Definition _t'2 : ident := 67%positive.
Definition _t'3 : ident := 68%positive.

Definition f_read := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: (_out, (tptr tint)) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_ver, (tptr tint)) :: (_snap, tint) :: (_i, tint) ::
               (_l, (tptr tint)) :: (_v, tint) :: (_t'3, tint) ::
               (_t'2, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Sloop
  (Ssequence
    Sskip
    (Ssequence
      (Sset _ver
        (Efield
          (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
            (Tstruct _node noattr)) _version (tptr tint)))
      (Ssequence
        (Ssequence
          (Scall (Some _t'1)
            (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                             cc_default))
            ((Etempvar _ver (tptr tint)) :: nil))
          (Sset _snap (Etempvar _t'1 tint)))
        (Ssequence
          (Sifthenelse (Ebinop Oand (Etempvar _snap tint)
                         (Ebinop Oeq (Econst_int (Int.repr 1) tint)
                           (Econst_int (Int.repr 1) tint) tint) tint)
            Scontinue
            Sskip)
          (Ssequence
            (Ssequence
              (Sset _i (Econst_int (Int.repr 0) tint))
              (Sloop
                (Ssequence
                  (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                                 (Econst_int (Int.repr 8) tint) tint)
                    Sskip
                    Sbreak)
                  (Ssequence
                    (Sset _l
                      (Ederef
                        (Ebinop Oadd
                          (Efield
                            (Ederef
                              (Etempvar _n (tptr (Tstruct _node noattr)))
                              (Tstruct _node noattr)) _data
                            (tarray (tptr tint) 8)) (Etempvar _i tint)
                          (tptr (tptr tint))) (tptr tint)))
                    (Ssequence
                      (Scall (Some _t'2)
                        (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil)
                                         tint cc_default))
                        ((Etempvar _l (tptr tint)) :: nil))
                      (Sassign
                        (Ederef
                          (Ebinop Oadd (Etempvar _out (tptr tint))
                            (Etempvar _i tint) (tptr tint)) tint)
                        (Etempvar _t'2 tint)))))
                (Sset _i
                  (Ebinop Oadd (Etempvar _i tint)
                    (Econst_int (Int.repr 1) tint) tint))))
            (Ssequence
              (Ssequence
                (Scall (Some _t'3)
                  (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint
                                   cc_default))
                  ((Etempvar _ver (tptr tint)) :: nil))
                (Sset _v (Etempvar _t'3 tint)))
              (Sifthenelse (Ebinop Oeq (Etempvar _v tint)
                             (Etempvar _snap tint) tint)
                (Sreturn None)
                Sskip)))))))
  Sskip)
|}.

Definition f_write := {|
  fn_return := tvoid;
  fn_callconv := cc_default;
  fn_params := ((_n, (tptr (Tstruct _node noattr))) :: (_in, (tptr tint)) ::
                nil);
  fn_vars := nil;
  fn_temps := ((_ver, (tptr tint)) :: (_v, tint) :: (_i, tint) ::
               (_l, (tptr tint)) :: (_d, tint) :: (_t'1, tint) :: nil);
  fn_body :=
(Ssequence
  (Sset _ver
    (Efield
      (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
        (Tstruct _node noattr)) _version (tptr tint)))
  (Ssequence
    (Ssequence
      (Scall (Some _t'1)
        (Evar _load_SC (Tfunction (Tcons (tptr tint) Tnil) tint cc_default))
        ((Etempvar _ver (tptr tint)) :: nil))
      (Sset _v (Etempvar _t'1 tint)))
    (Ssequence
      (Scall None
        (Evar _store_SC (Tfunction (Tcons (tptr tint) (Tcons tint Tnil))
                          tvoid cc_default))
        ((Etempvar _ver (tptr tint)) ::
         (Ebinop Oadd (Etempvar _v tint) (Econst_int (Int.repr 1) tint) tint) ::
         nil))
      (Ssequence
        (Ssequence
          (Sset _i (Econst_int (Int.repr 0) tint))
          (Sloop
            (Ssequence
              (Sifthenelse (Ebinop Olt (Etempvar _i tint)
                             (Econst_int (Int.repr 8) tint) tint)
                Sskip
                Sbreak)
              (Ssequence
                (Sset _l
                  (Ederef
                    (Ebinop Oadd
                      (Efield
                        (Ederef (Etempvar _n (tptr (Tstruct _node noattr)))
                          (Tstruct _node noattr)) _data
                        (tarray (tptr tint) 8)) (Etempvar _i tint)
                      (tptr (tptr tint))) (tptr tint)))
                (Ssequence
                  (Sset _d
                    (Ederef
                      (Ebinop Oadd (Etempvar _in (tptr tint))
                        (Etempvar _i tint) (tptr tint)) tint))
                  (Scall None
                    (Evar _store_SC (Tfunction
                                      (Tcons (tptr tint) (Tcons tint Tnil))
                                      tvoid cc_default))
                    ((Etempvar _l (tptr tint)) :: (Etempvar _d tint) :: nil)))))
            (Sset _i
              (Ebinop Oadd (Etempvar _i tint) (Econst_int (Int.repr 1) tint)
                tint))))
        (Scall None
          (Evar _store_SC (Tfunction (Tcons (tptr tint) (Tcons tint Tnil))
                            tvoid cc_default))
          ((Etempvar _ver (tptr tint)) ::
           (Ebinop Oadd (Etempvar _v tint) (Econst_int (Int.repr 2) tint)
             tint) :: nil))))))
|}.

Definition composites : list composite_definition :=
(Composite _node Struct
   ((_version, (tptr tint)) :: (_data, (tarray (tptr tint) 8)) :: nil)
   noattr :: nil).

Definition prog : Clight.program := {|
prog_defs :=
((___builtin_fabs,
   Gfun(External (EF_builtin "__builtin_fabs"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_memcpy_aligned,
   Gfun(External (EF_builtin "__builtin_memcpy_aligned"
                   (mksignature
                     (AST.Tint :: AST.Tint :: AST.Tint :: AST.Tint :: nil)
                     None cc_default))
     (Tcons (tptr tvoid)
       (Tcons (tptr tvoid) (Tcons tuint (Tcons tuint Tnil)))) tvoid
     cc_default)) ::
 (___builtin_annot,
   Gfun(External (EF_builtin "__builtin_annot"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons (tptr tschar) Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (___builtin_annot_intval,
   Gfun(External (EF_builtin "__builtin_annot_intval"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tschar) (Tcons tint Tnil))
     tint cc_default)) ::
 (___builtin_membar,
   Gfun(External (EF_builtin "__builtin_membar"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_va_start,
   Gfun(External (EF_builtin "__builtin_va_start"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___builtin_va_arg,
   Gfun(External (EF_builtin "__builtin_va_arg"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_va_copy,
   Gfun(External (EF_builtin "__builtin_va_copy"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default))
     (Tcons (tptr tvoid) (Tcons (tptr tvoid) Tnil)) tvoid cc_default)) ::
 (___builtin_va_end,
   Gfun(External (EF_builtin "__builtin_va_end"
                   (mksignature (AST.Tint :: nil) None cc_default))
     (Tcons (tptr tvoid) Tnil) tvoid cc_default)) ::
 (___compcert_va_int32,
   Gfun(External (EF_external "__compcert_va_int32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tvoid) Tnil) tuint cc_default)) ::
 (___compcert_va_int64,
   Gfun(External (EF_external "__compcert_va_int64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tulong
     cc_default)) ::
 (___compcert_va_float64,
   Gfun(External (EF_external "__compcert_va_float64"
                   (mksignature (AST.Tint :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons (tptr tvoid) Tnil) tdouble
     cc_default)) ::
 (___compcert_va_composite,
   Gfun(External (EF_external "__compcert_va_composite"
                   (mksignature (AST.Tint :: AST.Tint :: nil) (Some AST.Tint)
                     cc_default)) (Tcons (tptr tvoid) (Tcons tuint Tnil))
     (tptr tvoid) cc_default)) ::
 (___i64_dtos,
   Gfun(External (EF_runtime "__i64_dtos"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tlong cc_default)) ::
 (___i64_dtou,
   Gfun(External (EF_runtime "__i64_dtou"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tlong)
                     cc_default)) (Tcons tdouble Tnil) tulong cc_default)) ::
 (___i64_stod,
   Gfun(External (EF_runtime "__i64_stod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tlong Tnil) tdouble cc_default)) ::
 (___i64_utod,
   Gfun(External (EF_runtime "__i64_utod"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tulong Tnil) tdouble cc_default)) ::
 (___i64_stof,
   Gfun(External (EF_runtime "__i64_stof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tlong Tnil) tfloat cc_default)) ::
 (___i64_utof,
   Gfun(External (EF_runtime "__i64_utof"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tsingle)
                     cc_default)) (Tcons tulong Tnil) tfloat cc_default)) ::
 (___i64_sdiv,
   Gfun(External (EF_runtime "__i64_sdiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_udiv,
   Gfun(External (EF_runtime "__i64_udiv"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_smod,
   Gfun(External (EF_runtime "__i64_smod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tlong Tnil)) tlong cc_default)) ::
 (___i64_umod,
   Gfun(External (EF_runtime "__i64_umod"
                   (mksignature (AST.Tlong :: AST.Tlong :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tulong Tnil)) tulong cc_default)) ::
 (___i64_shl,
   Gfun(External (EF_runtime "__i64_shl"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___i64_shr,
   Gfun(External (EF_runtime "__i64_shr"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tulong (Tcons tint Tnil)) tulong cc_default)) ::
 (___i64_sar,
   Gfun(External (EF_runtime "__i64_sar"
                   (mksignature (AST.Tlong :: AST.Tint :: nil)
                     (Some AST.Tlong) cc_default))
     (Tcons tlong (Tcons tint Tnil)) tlong cc_default)) ::
 (___builtin_bswap,
   Gfun(External (EF_builtin "__builtin_bswap"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap32,
   Gfun(External (EF_builtin "__builtin_bswap32"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tuint cc_default)) ::
 (___builtin_bswap16,
   Gfun(External (EF_builtin "__builtin_bswap16"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tushort Tnil) tushort cc_default)) ::
 (___builtin_clz,
   Gfun(External (EF_builtin "__builtin_clz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzl,
   Gfun(External (EF_builtin "__builtin_clzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_clzll,
   Gfun(External (EF_builtin "__builtin_clzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_ctz,
   Gfun(External (EF_builtin "__builtin_ctz"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzl,
   Gfun(External (EF_builtin "__builtin_ctzl"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons tuint Tnil) tint cc_default)) ::
 (___builtin_ctzll,
   Gfun(External (EF_builtin "__builtin_ctzll"
                   (mksignature (AST.Tlong :: nil) (Some AST.Tint)
                     cc_default)) (Tcons tulong Tnil) tint cc_default)) ::
 (___builtin_fsqrt,
   Gfun(External (EF_builtin "__builtin_fsqrt"
                   (mksignature (AST.Tfloat :: nil) (Some AST.Tfloat)
                     cc_default)) (Tcons tdouble Tnil) tdouble cc_default)) ::
 (___builtin_fmax,
   Gfun(External (EF_builtin "__builtin_fmax"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmin,
   Gfun(External (EF_builtin "__builtin_fmin"
                   (mksignature (AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble Tnil)) tdouble cc_default)) ::
 (___builtin_fmadd,
   Gfun(External (EF_builtin "__builtin_fmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fmsub,
   Gfun(External (EF_builtin "__builtin_fmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmadd,
   Gfun(External (EF_builtin "__builtin_fnmadd"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_fnmsub,
   Gfun(External (EF_builtin "__builtin_fnmsub"
                   (mksignature
                     (AST.Tfloat :: AST.Tfloat :: AST.Tfloat :: nil)
                     (Some AST.Tfloat) cc_default))
     (Tcons tdouble (Tcons tdouble (Tcons tdouble Tnil))) tdouble
     cc_default)) ::
 (___builtin_read16_reversed,
   Gfun(External (EF_builtin "__builtin_read16_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tushort) Tnil) tushort cc_default)) ::
 (___builtin_read32_reversed,
   Gfun(External (EF_builtin "__builtin_read32_reversed"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tuint) Tnil) tuint cc_default)) ::
 (___builtin_write16_reversed,
   Gfun(External (EF_builtin "__builtin_write16_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tushort) (Tcons tushort Tnil))
     tvoid cc_default)) ::
 (___builtin_write32_reversed,
   Gfun(External (EF_builtin "__builtin_write32_reversed"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tuint) (Tcons tuint Tnil))
     tvoid cc_default)) ::
 (___builtin_nop,
   Gfun(External (EF_builtin "__builtin_nop"
                   (mksignature nil None cc_default)) Tnil tvoid cc_default)) ::
 (___builtin_debug,
   Gfun(External (EF_external "__builtin_debug"
                   (mksignature (AST.Tint :: nil) None
                     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|}))
     (Tcons tint Tnil) tvoid
     {|cc_vararg:=true; cc_unproto:=false; cc_structret:=false|})) ::
 (_load_SC,
   Gfun(External (EF_external "load_SC"
                   (mksignature (AST.Tint :: nil) (Some AST.Tint) cc_default))
     (Tcons (tptr tint) Tnil) tint cc_default)) ::
 (_store_SC,
   Gfun(External (EF_external "store_SC"
                   (mksignature (AST.Tint :: AST.Tint :: nil) None
                     cc_default)) (Tcons (tptr tint) (Tcons tint Tnil)) tvoid
     cc_default)) :: (_read, Gfun(Internal f_read)) ::
 (_write, Gfun(Internal f_write)) :: nil);
prog_public :=
(_write :: _read :: _store_SC :: _load_SC :: ___builtin_debug ::
 ___builtin_nop :: ___builtin_write32_reversed ::
 ___builtin_write16_reversed :: ___builtin_read32_reversed ::
 ___builtin_read16_reversed :: ___builtin_fnmsub :: ___builtin_fnmadd ::
 ___builtin_fmsub :: ___builtin_fmadd :: ___builtin_fmin ::
 ___builtin_fmax :: ___builtin_fsqrt :: ___builtin_ctzll ::
 ___builtin_ctzl :: ___builtin_ctz :: ___builtin_clzll :: ___builtin_clzl ::
 ___builtin_clz :: ___builtin_bswap16 :: ___builtin_bswap32 ::
 ___builtin_bswap :: ___i64_sar :: ___i64_shr :: ___i64_shl :: ___i64_umod ::
 ___i64_smod :: ___i64_udiv :: ___i64_sdiv :: ___i64_utof :: ___i64_stof ::
 ___i64_utod :: ___i64_stod :: ___i64_dtou :: ___i64_dtos ::
 ___compcert_va_composite :: ___compcert_va_float64 ::
 ___compcert_va_int64 :: ___compcert_va_int32 :: ___builtin_va_end ::
 ___builtin_va_copy :: ___builtin_va_arg :: ___builtin_va_start ::
 ___builtin_membar :: ___builtin_annot_intval :: ___builtin_annot ::
 ___builtin_memcpy_aligned :: ___builtin_fabs :: nil);
prog_main := _main;
prog_types := composites;
prog_comp_env := make_composite_env composites;
prog_comp_env_eq := refl_equal _
|}. *)

Set Bullet Behavior "Strict Subproofs".

Instance CompSpecs : compspecs. make_compspecs prog. Defined.
Definition Vprog : varspecs. mk_varspecs prog. Defined.

Definition load_SC_spec := DECLARE _load_SC load_SC_spec.
Definition store_SC_spec := DECLARE _store_SC store_SC_spec.

Definition tnode := Tstruct _node noattr.

Opaque upto.

Existing Instances fmap_PCM fmap_order.

Definition node_entry sh v vs locs lg i := EX v' : Z, EX log : Z -> option Z, EX d : Z,
  !!(repable_signed d /\ (if Z.even v then v' = v /\ d = Znth i vs 0 else v' >= v - 1) /\ log_latest log v' d) &&
  ghost (sh, log) (Znth i lg Vundef) * data_at sh tint (vint d) (Znth i locs Vundef).

Existing Instances max_PCM max_order.

Definition node_state sh v vs version locs g lg := !!(repable_signed v /\
    Forall repable_signed vs /\ Zlength vs = Zlength locs /\ Zlength lg = Zlength locs) &&
  ghost (sh, v) g * data_at sh tint (vint v) version *
  fold_right sepcon emp (map (node_entry sh v vs locs lg) (upto (length locs))).

Definition node_inv v vs version locs g lg := EX v' : Z, !!(Z.even v = true /\ (v' = v \/ v' = v + 1)) &&
  node_state gsh2 v' vs version locs g lg.

Program Definition read_spec := DECLARE _read atomic_spec
  (ConstType (val * val * share * val * list val * val * list val * Z * list Z)) (0, [])
  [(_n, tptr tnode); (_out, tptr tint)] tvoid
  [fun _ '(n, out, sh, version, locs, g, lg, v0, vs0) => temp _n n;
   fun _ '(n, out, sh, version, locs, g, lg, v0, vs0) => temp _out out]
  (fun _ '(n, out, sh, version, locs, g, lg, v0, vs0) => !!(readable_share sh /\ isptr version /\
     Forall isptr locs /\ Zlength locs = 8) &&
   data_at sh tnode (version, locs) n * data_at_ Tsh (tarray tint 8) out)
  (fun _ '(n, out, sh, version, locs, g, lg, v0, vs0) '(v, vs) => node_inv v vs version locs g lg)
  tt []
  (fun _ '(n, out, sh, version, locs, g, lg, v0, vs0) '(v, vs) _ =>
   data_at sh tnode (version, locs) n * data_at Tsh (tarray tint 8) (map (fun x => vint x) vs) out)
  (fun _ '(n, out, sh, version, locs, g, lg, v0, vs0) '(v, vs) _ => node_inv v vs version locs g lg)
  _ _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.

Program Definition write_spec := DECLARE _write atomic_spec
  (ConstType (val * val * share * val * list val * list Z * val * list val * Z * list Z)) (0, [])
  [(_n, tptr tnode); (_in, tptr tint)] tvoid
  [fun _ '(n, input, sh, version, locs, vals, g, lg, v0, vs0) => temp _n n;
   fun _ '(n, input, sh, version, locs, vals, g, lg, v0, vs0) => temp _in input]
  (fun _ '(n, input, sh, version, locs, vals, g, lg, v0, vs0) => !!(readable_share sh /\ isptr version /\
     Forall isptr locs /\ Zlength locs = 8 /\ Forall repable_signed vals /\ Z.even v0 = true) &&
   data_at sh tnode (version, locs) n * data_at Tsh (tarray tint 8) (map (fun x => vint x) vals) input *
   node_state gsh1 v0 vs0 version locs g lg)
  (fun _ '(n, input, sh, version, locs, vals, g, lg, v0, vs0) '(v, vs) => node_inv v vs version locs g lg)
  tt []
  (fun _ '(n, input, sh, version, locs, vals, g, lg, v0, vs0) '(v, vs) _ =>
   data_at sh tnode (version, locs) n * data_at Tsh (tarray tint 8) (map (fun x => vint x) vals) input *
   node_state gsh1 (v0 + 2) vals version locs g lg)
  (fun _ '(n, input, sh, version, locs, vals, g, lg, v0, vs0) '(v, vs) _ =>
   node_inv (v0 + 2) vals version locs g lg)
  _ _ _ _ _ _.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.
Next Obligation.
Proof.
  intros ?? w; decompose [prod] w; auto.
Qed.

Definition Gprog : funspecs := ltac:(with_library prog [load_SC_spec; store_SC_spec; read_spec; write_spec]).

Lemma land_1 : forall i, Z.land i 1 = i mod 2.
Proof.
  intros; apply Z.land_ones with (n := 1); omega.
Qed.

Lemma singleton_snap : forall (x : Z -> option Z) p v1 v2, x v1 = Some v2 ->
  view_shift (ghost_snap x p) (ghost_snap (singleton v1 v2) p).
Proof.
  intros.
  apply ghost_snap_forget.
  unfold singleton; intros ??; if_tac; intro X; inv X; auto.
Qed.

Lemma body_read : semax_body Vprog Gprog f_read read_spec.
Proof.
  start_atomic_function.
  destruct x as ((((((((n, out), sh), version), locs), g), lg), v0), vs0); Intros.
  destruct H as (HP & HQ).
  eapply semax_loop; [|forward; unfold loop2_ret_assert; apply ENTAIL_refl].
  repeat forward.
  forward_call (version, P, II, lI,
    fun sh v' => !!(sh = gsh2) && EX v : Z, EX vs : _, !!(Z.even v = true /\ Forall repable_signed vs /\
      Zlength vs = Zlength locs /\ Zlength lg = Zlength locs /\ (v' = v \/ v' = v + 1)) && ghost (gsh2, v') g *
      fold_right sepcon emp (map (node_entry gsh2 v' vs locs lg) (upto (length locs))) * R (v, vs),
      fun v : Z => P * ghost_snap v g).
  { split.
    + intros.
      etransitivity; [apply HP|].
      apply derives_view_shift.
      Intro x; destruct x as (v, vs).
      unfold node_inv, node_state; Intro v'.
      Exists gsh2 v' v vs; entailer!.
    + intros.
      rewrite <- sepcon_assoc; etransitivity; [|apply view_shift_sepcon1, HP].
      view_shift_intro v2; view_shift_intro vs; view_shift_intros.
      rewrite sepcon_comm, !sepcon_assoc.
      etransitivity; [apply view_shift_sepcon1, make_snap|].
      apply derives_view_shift.
      Exists (v2, vs); unfold node_inv, node_state; Exists v; entailer!. }
  Intros v1.
  match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
    forward_if (PROP (Z.testbit v1 0 = false) (LOCALx Q (SEPx R))) end.
  { eapply semax_pre; [|apply semax_continue].
    unfold POSTCONDITION, abbreviate, overridePost.
    destruct (eq_dec EK_continue EK_normal); [discriminate|].
    unfold loop1_ret_assert.
    entailer!.
    admit.  }
  { forward.
    entailer!.
    unfold Int.one in *; rewrite and_repr, land_1, Zmod_odd in *.
    destruct (Z.odd v1); auto; discriminate. }
  Intros.
  forward_for_simple_bound 8 (EX i : Z, EX vals : list Z, PROP (Zlength vals = i)
    LOCAL (temp _snap (vint v1); temp _ver version; temp _n n; temp _out out)
    SEP (fold_right sepcon emp (map (fun p => invariant (II p)) lI);
         P; ghost_snap v1 g; @data_at CompSpecs sh tnode (version, locs) n;
         data_at Tsh (tarray tint 8) (map (fun x => vint x) vals ++ repeat Vundef (Z.to_nat (8 - i))) out;
         EX vers : list (Z * Z), !!(Zlength vers = i /\
           Forall (fun '(v, v') => v1 <= v /\ if Z.even v then v' = v else True) vers) &&
           fold_right sepcon emp (map (fun i => ghost_snap (fst (Znth i vers (0, 0))) g *
             ghost_snap (singleton (snd (Znth i vers (0, 0))) (Znth i vals 0)) (Znth i lg Vundef))
             (sublist 0 i (upto 8))))).
  { Exists (@nil Z) (@nil (Z * Z)); rewrite !sepcon_map; entailer!. }
  - Intros vers; rewrite !sepcon_map; Intros.
    forward.
    { entailer!.
      apply Forall_Znth; [omega|].
      eapply Forall_impl; [|eauto]; auto. }
    forward_call (Znth i locs Vundef, P * ghost_snap v1 g,
      II, lI,
      fun sh v => !!(sh = gsh2) && EX ver : Z, EX vs : _, EX ver' : Z, EX v'' : _, EX log : _,
        !!(repable_signed ver' /\ Z.even ver = true /\ Forall repable_signed vs /\ Zlength vs = Zlength locs /\
           Zlength lg = Zlength locs /\ (ver' = ver \/ ver' = ver + 1) /\
           (if Z.even ver' then v'' = ver' /\ v = Znth i vs 0 else v'' >= ver' - 1) /\ log_latest log v'' v) &&
           ghost (gsh2, ver') g * data_at gsh2 tint (vint ver') version * ghost (gsh2, log) (Znth i lg Vundef) *
           fold_right sepcon emp (upd_Znth i (map (node_entry gsh2 ver' vs locs lg) (upto (length locs))) emp) *
        R (ver, vs) * ghost_snap v1 g,
      fun v : Z => P * EX vi : Z, EX v'' : Z, !!(v1 <= vi /\ if Z.even vi then v'' = vi else True) &&
        ghost_snap v1 g * ghost_snap vi g * ghost_snap (singleton v'' v) (Znth i lg Vundef)).

     { split.
      + intros.
        rewrite <- !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
        apply derives_view_shift.
        Intro s; destruct s as (v, vs).
        unfold node_inv, node_state; Intros ver'.
        rewrite extract_nth_sepcon with (i := i)
          by (rewrite Zlength_map, Zlength_upto, <- Zlength_correct; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, <- Zlength_correct; auto; omega).
        unfold node_entry; Intros v'' log d.
        Exists gsh2 d v vs ver' v'' log; entailer!.
      + intros.
        rewrite <- sepcon_assoc; etransitivity; [|apply view_shift_sepcon1, HP].
        view_shift_intro ver; view_shift_intro vs; view_shift_intro ver'; view_shift_intro v'';
          view_shift_intro log; view_shift_intros.
        rewrite sepcon_comm, !sepcon_assoc.
        etransitivity; [apply view_shift_sepcon1, make_snap|].
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ (Znth i lg Vundef))), !sepcon_assoc.
        etransitivity; [apply view_shift_sepcon1, make_snap|].
        rewrite sepcon_assoc; etransitivity; [apply view_shift_sepcon1|].
        { match goal with H : log_latest _ _ _ |- _ => destruct H end.
          apply singleton_snap; eauto. }
        apply derives_view_shift.
        assert_PROP (v1 <= ver').
        { rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ g)), (sepcon_comm _ (ghost_snap v1 g)).
          rewrite <- !sepcon_assoc, snap_master_join by auto; entailer!. }
        Exists (ver, vs) ver' v''; unfold node_inv, node_state; Exists ver'; entailer!.
        { if_tac; tauto. }
        rewrite extract_nth_sepcon with (i := Zlength x)(l := map _ _)
          by (rewrite Zlength_map, Zlength_upto, <- Zlength_correct; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, <- Zlength_correct; omega).
        unfold node_entry; Exists v'' log v; unfold share; entailer!. }
      Intros vali vi v''.
      forward.
      Exists (x ++ [vali]) (vers ++ [(vi, v'')]); rewrite !Zlength_app, !Zlength_cons, !Zlength_nil.
      rewrite upd_init, map_app, <- app_assoc, !sepcon_map by (rewrite ?Zlength_map; omega); entailer!.
      { rewrite Forall_app; repeat constructor; auto. }
      rewrite sublist_split with (mid := Zlength x)(hi := Zlength x + 1) by (rewrite ?Zlength_upto; simpl; omega).
      erewrite sublist_len_1, Znth_upto by (rewrite ?Zlength_upto; simpl; omega).
      rewrite !map_app, !sepcon_app; simpl.
      rewrite !app_Znth2 by omega.
      replace (Zlength vers) with (Zlength x); rewrite Zminus_diag, !Znth_0_cons; simpl; cancel.
      rewrite <- !sepcon_map; apply sepcon_list_derives; rewrite !Zlength_map; auto.
      intros ? Hi; erewrite !Znth_map by auto.
      rewrite Zlength_sublist in Hi by (rewrite ?Zlength_upto; simpl; omega).
      rewrite !Znth_sublist, !Znth_upto by (simpl; omega).
      rewrite !app_Znth1 by omega; auto.
  - Intros vals vers.
    rewrite app_nil_r, sublist_same by auto; simpl.
    rewrite Z.bit0_odd, Zodd_even_bool in *; destruct (Z.even v1) eqn: Heven; try discriminate.
    forward_call (version, P * ghost_snap v1 g * fold_right sepcon emp (map (fun i =>
      ghost_snap (fst (Znth i vers (0, 0))) g *
      ghost_snap (singleton (snd (Znth i vers (0, 0))) (Znth i vals 0)) (Znth i lg Vundef)) (upto 8)), II, lI,
      fun sh v' => !!(sh = gsh2) && EX v : Z, EX vs : _, !!(Z.even v = true /\ Forall repable_signed vs /\
        Zlength vs = Zlength locs /\ Zlength lg = Zlength locs /\ (v' = v \/ v' = v + 1)) &&
        ghost (gsh2, v') g * fold_right sepcon emp (map (node_entry gsh2 v' vs locs lg) (upto (length locs))) *
        R (v, vs) * ghost_snap v1 g * fold_right sepcon emp (map (fun i => ghost_snap (fst (Znth i vers (0, 0))) g *
          ghost_snap (singleton (snd (Znth i vers (0, 0))) (Znth i vals 0)) (Znth i lg Vundef)) (upto 8)),
      fun v : Z => (if eq_dec v v1 then Q (v, vals) tt else P) *
        (!!(if eq_dec v v1 then Forall (fun '(vi, v') => vi = v1 /\ v' = v1) vers else True) &&
        ghost_snap v g * fold_right sepcon emp (map (fun i => ghost_snap (fst (Znth i vers (0, 0))) g *
          ghost_snap (singleton (snd (Znth i vers (0, 0))) (Znth i vals 0)) (Znth i lg Vundef)) (upto 8)))).
    { split.
      + intros.
        rewrite <- !sepcon_assoc, sepcon_assoc; etransitivity; [apply view_shift_sepcon; [apply HP | reflexivity]|].
        apply derives_view_shift.
        Intro x; destruct x as (v, vs).
        unfold node_inv, node_state; Intro v'.
        Exists gsh2 v' v vs; entailer!.
      + intros.
        destruct (eq_dec v v1).
        * view_shift_intro ver; view_shift_intro vs; view_shift_intros; subst.
          match goal with H : _ \/ _ |- _ => destruct H; subst;
            [|match goal with H : Z.even (ver + 1) = true |- _ => rewrite Z.even_add in H;
              replace (Z.even ver) with true in H; discriminate end] end.
          apply view_shift_assert with (PP := Forall (fun '(vi, v') => vi = ver /\ v' = ver) vers).
          { rewrite Forall_forall_Znth with (d := (0, 0)), prop_forall; apply allp_right; intro i.
            rewrite prop_forall; apply allp_right; intro.
            match goal with H : Forall _ vers |- _ => apply Forall_Znth with (i0 := i)(d := (0, 0)) in H; auto end.
            rewrite extract_nth_sepcon with (i := i)(l := map _ (upto 8))
              by (rewrite Zlength_map, Zlength_upto; simpl; omega).
            erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto; simpl; omega).
            rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ g)), (sepcon_comm _ (ghost_snap (fst _) g)).
            rewrite <- !sepcon_assoc, snap_master_join by auto.
            Intros; apply prop_right; destruct (Znth i vers (0, 0)); simpl in *.
            assert (z = ver) by omega; subst.
            destruct (Z.even ver); try discriminate; tauto. }
          intro Hvers.
          etransitivity; [|etransitivity; [apply view_shift_sepcon with (Q' :=
            ghost_snap ver g * fold_right sepcon emp (map (fun i => ghost_snap (fst (Znth i vers (0, 0))) g *
              ghost_snap (singleton (snd (Znth i vers (0, 0))) (Znth i vals 0)) (Znth i lg Vundef)) (upto 8)));
            [apply (HQ (ver, vals) tt) | reflexivity] | apply derives_view_shift; entailer!]].
          apply derives_view_shift.
          assert_PROP (vs = vals).
          { assert_PROP (forall i, 0 <= i < Zlength vs -> Znth i vs 0 = Znth i vals 0);
              [|eapply prop_right, list_Znth_eq'; auto; omega].
            rewrite prop_forall; apply allp_right; intro i.
            rewrite prop_forall; apply allp_right; intro.
            apply Forall_Znth with (i0 := i)(d := (0, 0)) in Hvers; [|omega].
            rewrite extract_nth_sepcon with (i := i)
              by (rewrite Zlength_map, Zlength_upto, <- Zlength_correct; omega).
            rewrite extract_nth_sepcon with (i := i)(l := map _ _)
              by (rewrite Zlength_map, Zlength_upto; simpl; omega).
            erewrite !Znth_map, !Znth_upto by (rewrite ?Zlength_upto, <- ?Zlength_correct; simpl; omega).
            unfold node_entry; Intros v' log d.
            destruct (Z.even ver); try discriminate.
            destruct (Znth i vers (0, 0)); repeat match goal with H : _ = _ /\ _ = _ |- _ => destruct H end.
            subst; rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ (Znth i lg Vundef))),
              (sepcon_comm _ (ghost_snap _ (Znth i lg Vundef))).
            rewrite <- !sepcon_assoc, snap_master_join by auto; simpl; Intros; apply prop_right.
            unfold singleton in *.
            match goal with H : log_latest _ _ _ |- _ => destruct H end.
            match goal with H : map_incl _ _ |- _ => specialize (H ver); simpl in H; rewrite eq_dec_refl in H;
              specialize (H _ eq_refl); rewrite H in *; congruence end. }
          subst; unfold node_inv, node_state; Exists ver; entailer!.
        * rewrite <- !sepcon_assoc, sepcon_assoc; etransitivity; [|apply view_shift_sepcon; [apply HP | reflexivity]].
          view_shift_intro ver; view_shift_intro vs; view_shift_intros.
          rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost _ _)), (sepcon_comm _ (ghost_snap _ _)).
          rewrite <- !sepcon_assoc, snap_master_join by auto.
          view_shift_intros; rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1, make_snap|].
          apply derives_view_shift; Exists (ver, vs); unfold node_inv, node_state; Exists v; entailer!. }
    Intros v2.
    match goal with |-semax _ (PROP () (LOCALx ?Q (SEPx ?R))) _ _ =>
      forward_if (PROP (v2 <> v1) (LOCALx Q (SEPx R))) end.
    + subst; rewrite eq_dec_refl in *.
      forward.
      Exists tt (v1, vals); entailer!.
      admit. 
    + forward.
      entailer!.
    + intros; unfold overridePost.
      destruct (eq_dec ek EK_normal); [subst | apply ENTAIL_refl].
      unfold POSTCONDITION, abbreviate, loop1_ret_assert.
      Intros; if_tac; [contradiction | entailer!].
      admit. 
Admitted.

Lemma dirty_entry : forall sh v vs locs lg i, Z.even v = true ->
  node_entry sh v vs locs lg i |-- node_entry sh (v + 1) vs locs lg i.
Proof.
  intros; unfold node_entry.
  Intros v' log d.
  rewrite H in *; match goal with H : _ /\ _ |- _ => destruct H end.
  Exists v log d; entailer!.
  rewrite Z.even_add, H; simpl; omega.
Qed.

Lemma clean_entry : forall v vs locs lg i vs', Z.even v = false ->
  node_entry gsh1 (v + 1) vs' locs lg i * node_entry gsh2 v vs locs lg i |--
  node_entry gsh1 (v + 1) vs' locs lg i * node_entry gsh2 (v + 1) vs' locs lg i.
Proof.
  intros; unfold node_entry.
  Intros v1 log1 d1 v2 log2 d2.
  Exists (v + 1) log1 d1 (v + 1) log1 d1.
  rewrite sepcon_assoc, (sepcon_comm (data_at _ _ _ _)), <- !sepcon_assoc.
  erewrite master_share_join' by eauto.
  assert_PROP (d1 = d2).
  { rewrite sepcon_assoc, sepcon_comm; apply sepcon_derives_prop.
    unfold data_at, field_at, at_offset; rewrite !data_at_rec_eq; simpl; Intros.
    eapply derives_trans; [apply mapsto_value_eq; auto; discriminate|].
    apply prop_left; unfold unfold_reptype; simpl; intro; apply prop_right.
    apply repr_inj_signed; auto; congruence. }
  erewrite <- master_share_join by eauto; entailer!.
  exploit (log_latest_inj log2 v1 d2 v2); eauto; intros (? & ?); subst.
  rewrite Z.even_add, H in *; simpl in *.
  match goal with H : _ /\ _ |- _ => destruct H; subst; repeat (split; auto) end.
Qed.

Corollary clean_entries : forall v vs locs lg vs', Z.even v = false ->
  fold_right sepcon emp (map (node_entry gsh1 (v + 1) vs' locs lg) (upto 8)) *
  fold_right sepcon emp (map (node_entry gsh2 v vs locs lg) (upto 8)) |--
  fold_right sepcon emp (map (node_entry gsh1 (v + 1) vs' locs lg) (upto 8)) *
  fold_right sepcon emp (map (node_entry gsh2 (v + 1) vs' locs lg) (upto 8)).
Proof.
  intros.
  rewrite <- !sepcon_map; apply sepcon_list_derives; rewrite !Zlength_map; auto; intros.
  erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
  apply clean_entry; auto.
Qed.

Lemma body_write : semax_body Vprog Gprog f_write write_spec.
Proof.
  start_atomic_function.
  destruct x as (((((((((n, input), sh), version), locs), vals), g), lg), v0), vs0); Intros.
  destruct H as (HP & HQ).
  forward.
  unfold node_state; Intros.
  forward_call (version, P * ghost (gsh1, v0) g, II, lI,
    fun sh v' => !!(sh = gsh2) && EX v : Z, EX vs : _, !!(repable_signed v' /\ Z.even v = true /\
      Forall repable_signed vs /\ Zlength vs = Zlength locs /\ Zlength lg = Zlength locs /\
      (v' = v \/ v' = v + 1)) && ghost (gsh2, v') g * fold_right sepcon emp
        (map (node_entry gsh2 v' vs locs lg) (upto (length locs))) * R (v, vs) * ghost (gsh1, v0) g,
    fun v : Z => P * (!!(v = v0) && ghost (gsh1, v0) g)).
  { split.
    + intros.
      rewrite <- sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
      apply derives_view_shift.
      Intro x; destruct x as (v, vs).
      unfold node_inv, node_state; Intros v'.
      Exists gsh2 v' v vs; entailer!.
    + intros.
      rewrite <- sepcon_assoc; etransitivity; [|apply view_shift_sepcon1, HP].
      apply derives_view_shift; Intros v1 vs.
      assert_PROP (v0 = v).
      { rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, _) _)), (sepcon_comm _ (ghost (gsh1, _) _)).
        erewrite <- !sepcon_assoc, master_share_join' by eauto; entailer!. }
      Exists (v1, vs); unfold node_inv, node_state; Exists v; entailer!. }
  Intros x; subst.
  assert (repable_signed (v0 + 1)) by admit. 
  forward_call (version, v0 + 1, P * ghost (gsh1, v0) g * data_at gsh1 tint (vint v0) version, II, lI,
    fun sh => !!(sh = Tsh) && EX v : Z, EX vs : _, EX v' : Z, !!(repable_signed v' /\ Z.even v = true /\
      Forall repable_signed vs /\ Zlength vs = Zlength locs /\ Zlength lg = Zlength locs /\
      (v' = v \/ v' = v + 1)) && ghost (gsh2, v') g *
      fold_right sepcon emp (map (node_entry gsh2 v' vs locs lg) (upto (length locs))) * R (v, vs) *
      ghost (gsh1, v0) g, P * ghost (gsh1, v0 + 1) g * data_at gsh1 tint (vint (v0 + 1)) version).
  { split; [auto | split].
    + intros.
      rewrite <- !sepcon_assoc, sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
      apply derives_view_shift.
      Intros x; destruct x as (v, vs).
      unfold node_inv, node_state; Intro v'.
      Exists Tsh v vs v'; entailer!.
      eapply derives_trans; [apply data_at_value_cohere; auto|].
      erewrite sepcon_comm, data_at_share_join; eauto; cancel.
    + intros.
      rewrite <- !sepcon_assoc, sepcon_assoc; etransitivity; [|apply view_shift_sepcon1, HP].
      view_shift_intro v; view_shift_intro vs; view_shift_intro v'; view_shift_intros.
      rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, _) _)), (sepcon_comm _ (ghost (gsh1, _) _)).
      erewrite <- !sepcon_assoc, master_share_join' by eauto; view_shift_intros; subst v'.
      rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1|].
      { apply master_update with (v' := v0 + 1); omega. }
      apply derives_view_shift.
      erewrite <- master_share_join by eauto.
      subst; erewrite <- data_at_share_join by eauto.
      Exists (v, vs); unfold node_inv, node_state.
      Exists (v0 + 1); entailer!.
      { match goal with H : _ \/ _ |- _ => destruct H; subst; auto end.
        rewrite Z.even_add in *; simpl in *.
        match goal with H : Z.even v = true |- _ => rewrite H in *; discriminate end. }
      apply sepcon_list_derives; rewrite !Zlength_map; auto; intros.
      erewrite !Znth_map, !Znth_upto by (auto; rewrite Zlength_upto in *; omega).
      apply dirty_entry; auto. }
  assert_PROP (Zlength (map (fun x => vint x) vals) = 8) by entailer!.
  rewrite <- seq_assoc.
  forward_for_simple_bound 8 (EX i : Z, PROP ( )
    LOCAL (temp _v (vint v0); temp _ver version; temp _n n; temp _in input)
    SEP (fold_right sepcon emp (map (fun p => invariant (II p)) lI); P;
    ghost (gsh1, v0 + 1) g; data_at gsh1 tint (vint (v0 + 1)) version;
    @data_at CompSpecs sh tnode (version, locs) n;
    data_at Tsh (tarray tint 8) (map (fun x : Z => vint x) vals) input;
    fold_right sepcon emp (map (node_entry gsh1 (v0 + 2) vals locs lg) (sublist 0 i (upto 8)));
    fold_right sepcon emp (map (node_entry gsh1 v0 vs0 locs lg) (sublist i 8 (upto 8))))).
  { rewrite <- ZtoNat_Zlength; replace (Zlength locs) with 8; entailer!. }
  - 
    forward.
    { entailer!.
      apply Forall_Znth; [omega|].
      eapply Forall_impl; [|eauto]; auto. }
    forward.
    erewrite sublist_next with (i0 := i), Znth_upto by (rewrite ?Zlength_upto; simpl; omega); simpl.
    rewrite Zlength_map in *.
    forward_call (Znth i locs Vundef, Znth i vals 0, P * ghost (gsh1, v0 + 1) g *
      node_entry gsh1 v0 vs0 locs lg i, II, lI,
      fun sh => !!(sh = Tsh) && EX ver : Z, EX vs : _, EX ver' : Z, EX v'' : _, EX log : _, EX d : Z,
        !!(repable_signed ver' /\ Z.even ver = true /\ Forall repable_signed vs /\ Zlength vs = Zlength locs /\
           Zlength lg = Zlength locs /\ (ver' = ver \/ ver' = ver + 1) /\
           (if Z.even ver' then v'' = ver' /\ d = Znth i vs 0 else v'' >= ver' - 1) /\ log_latest log v'' d) &&
        ghost (gsh2, ver') g * data_at gsh2 tint (vint ver') version * ghost (gsh2, log) (Znth i lg Vundef) *
        fold_right sepcon emp (upd_Znth i (map (node_entry gsh2 ver' vs locs lg) (upto (length locs))) emp) *
        R (ver, vs) * ghost (gsh1, v0 + 1) g *
        EX log' : _, !!(log_latest log' v0 (Znth i vs0 0)) && ghost (gsh1, log') (Znth i lg Vundef),
      P * ghost (gsh1, v0 + 1) g * node_entry gsh1 (v0 + 2) vals locs lg i).
    { split; [apply Forall_Znth; auto; omega | split].
      + rewrite <- !sepcon_assoc, sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
        apply derives_view_shift.
        Intro x; destruct x as (v, vs).
        unfold node_inv, node_state; Intro v'.
        rewrite extract_nth_sepcon with (i := i)
          by (rewrite Zlength_map, Zlength_upto, <- Zlength_correct; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, <- Zlength_correct; auto; omega).
        unfold node_entry; Intros v'' log d v2 log2 d2.
        Exists Tsh v vs v' v'' log d log2; entailer!.
        { replace (Z.even v0) with true in *; match goal with H : _ /\ _ |- _ => destruct H; subst; auto end. }
        eapply derives_trans; [apply data_at_value_cohere; auto|].
        erewrite sepcon_comm, data_at_share_join by eauto; cancel.
      + intros.
        rewrite <- !sepcon_assoc, sepcon_assoc; etransitivity; [|apply view_shift_sepcon1, HP].
        view_shift_intro ver; view_shift_intro vs; view_shift_intro ver'; view_shift_intro v'';
          view_shift_intro log; view_shift_intro d; view_shift_intro log'; view_shift_intros.
        apply view_shift_assert with (PP := v0 + 1 = ver').
        { rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, _) g)), (sepcon_comm _ (ghost (gsh1, _) g)).
          erewrite <- !sepcon_assoc, master_share_join' by eauto; entailer!. }
        intro; subst.
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, _) (Znth _ _ _))).
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh1, _) (Znth _ _ _))).
        erewrite <- !sepcon_assoc, master_share_join' by eauto; view_shift_intros; subst.
        exploit (log_latest_inj log v'' d v0); eauto; intros (? & ?); subst.
        destruct (log_latest_upd log v0 (Znth i vs0 0) (v0 + 2) (Znth i vals 0)); auto; try omega.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1|].
        { apply master_update with (v' := map_upd log (v0 + 2) (Znth i vals 0)); auto. }
        erewrite <- master_share_join by eauto; apply derives_view_shift.
        Exists (ver, vs); unfold node_inv, node_state.
        Exists (v0 + 1); rewrite extract_nth_sepcon with (i := i)(l := map _ _)
          by (rewrite Zlength_map, Zlength_upto, <- Zlength_correct; omega).
        erewrite Znth_map, Znth_upto by (rewrite ?Zlength_upto, <- Zlength_correct; auto; omega).
        erewrite <- data_at_share_join by eauto.
        unfold node_entry; Exists (v0 + 2) (map_upd log (v0 + 2) (Znth i vals 0)) (Znth i vals 0) (v0 + 2)
          (map_upd log (v0 + 2) (Znth i vals 0)) (Znth i vals 0); entailer!.
        rewrite !Z.even_add; simpl.
        replace (Z.even v0) with true; simpl.
        split; split; auto; try omega; apply Forall_Znth; auto; omega. }
    erewrite sublist_split with (mid := i)(hi := i + 1), sublist_len_1, Znth_upto, map_app, sepcon_app
      by (auto; rewrite ?Zlength_upto; simpl; omega); entailer!.
  - rewrite !sublist_nil, !sublist_same by auto; simpl.
    assert (repable_signed (v0 + 2)) by admit. 
    forward_call (version, v0 + 2, P * ghost (gsh1, v0 + 1) g * data_at gsh1 tint (vint (v0 + 1)) version *
      fold_right sepcon emp (map (node_entry gsh1 (v0 + 2) vals locs lg) (upto 8)), II, lI,
      fun sh => !!(sh = Tsh) && EX v : Z, EX vs : _, EX v' : Z, !!(repable_signed v' /\ Z.even v = true /\
        Forall repable_signed vs /\ Zlength vs = Zlength locs /\ Zlength lg = Zlength locs /\
        (v' = v \/ v' = v + 1)) && ghost (gsh2, v') g *
        fold_right sepcon emp (map (node_entry gsh2 v' vs locs lg) (upto (length locs))) * R (v, vs) *
        ghost (gsh1, v0 + 1) g * fold_right sepcon emp (map (node_entry gsh1 (v0 + 2) vals locs lg) (upto 8)),
      EX v : Z, EX vs : list Z, Q (v, vs) tt * ghost (gsh1, v0 + 2) g * data_at gsh1 tint (vint (v0 + 2)) version *
        fold_right sepcon emp (map (node_entry gsh1 (v0 + 2) vals locs lg) (upto 8))).
    { split; [auto | split].
      + intros.
        rewrite <- !sepcon_assoc, 2sepcon_assoc; etransitivity; [apply view_shift_sepcon1, HP|].
        apply derives_view_shift.
        Intros x; destruct x as (v, vs).
        unfold node_inv, node_state; Intro v'.
        Exists Tsh v vs v'; entailer!.
        eapply derives_trans; [apply data_at_value_cohere; auto|].
        erewrite sepcon_comm, data_at_share_join by eauto; cancel.
      + intros.
        view_shift_intro v; view_shift_intro vs; view_shift_intro v'; view_shift_intros.
        etransitivity; [|etransitivity; [apply view_shift_sepcon with (Q' :=
          ghost (gsh1, v0 + 2) g * data_at gsh1 tint (vint (v0 + 2)) version *
            fold_right sepcon emp (map (node_entry gsh1 (v0 + 2) vals locs lg) (upto 8)));
          [apply (HQ (v, vs) tt) | reflexivity] | apply derives_view_shift; Exists v vs; entailer!]].
        rewrite <- !sepcon_assoc, (sepcon_comm _ (ghost (gsh2, _) _)), (sepcon_comm _ (ghost (gsh1, _) _)).
        erewrite <- !sepcon_assoc, master_share_join' by eauto; view_shift_intros; subst.
        match goal with H : _ \/ _ |- _ => destruct H; [subst; rewrite Z.even_add in *;
          replace (Z.even v0) with true in *; discriminate|] end.
        assert (v = v0) by omega; subst.
        rewrite !sepcon_assoc; etransitivity; [apply view_shift_sepcon1|].
        { apply master_update with (v' := v0 + 2); omega. }
        erewrite <- master_share_join by eauto; apply derives_view_shift; unfold node_inv, node_state.
        Exists (v0 + 2); rewrite Zlength_map in *.
        replace (length locs) with (Z.to_nat 8) by (symmetry; rewrite <- Zlength_length; auto; computable).
        pose proof (clean_entries (v0 + 1) vs locs lg vals) as Hclean.
        rewrite <- Z.add_assoc in Hclean; simpl in *.
        sep_apply Hclean.
        { rewrite Z.even_add; replace (Z.even v0) with true; auto. }
        erewrite <- data_at_share_join by eauto; entailer!.
        rewrite Z.even_add; replace (Z.even v0) with true; auto. }
    Intros s; destruct s as (v, vs).
    forward.
    Exists tt (v, vs); entailer!.
Admitted.
