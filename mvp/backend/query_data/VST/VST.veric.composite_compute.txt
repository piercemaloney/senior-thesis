Require Import Coq.Sorting.Permutation.

Require Import Coq.Sorting.Sorting.

Require Import Coq.Structures.Orders.

Require Import VST.veric.base.
(* VST.veric.base:
Require Export Coq.Arith.EqNat.
Require Export Coq.Relations.Relations.

Require Export compcert.lib.Axioms.
Require Export compcert.lib.Coqlib.
Require Export compcert.lib.Integers.
Require Export compcert.lib.Floats.
Require Export compcert.lib.Maps.
Require Export compcert.common.AST.
Require Export compcert.common.Values.
Require Export compcert.common.Memdata.
Require Export compcert.common.Memtype.
Require Export compcert.common.Memory.
Require Export compcert.common.Globalenvs.

Require Export VST.msl.Coqlib2. 
Require Export VST.veric.coqlib4.

Fixpoint id_in_list (id: ident) (ids: list ident) : bool :=
 match ids with i::ids' => orb (Pos.eqb id i) (id_in_list id ids') | _ => false end.

Fixpoint compute_list_norepet (ids: list ident) : bool :=
 match ids with
 | id :: ids' => if id_in_list id ids' then false else compute_list_norepet ids'
 | nil => true
 end.

Lemma id_in_list_true: forall i ids, id_in_list i ids = true -> In i ids.

Lemma id_in_list_false: forall i ids, id_in_list i ids = false -> ~In i ids.

Lemma compute_list_norepet_e: forall ids,
     compute_list_norepet ids = true -> list_norepet ids.

Lemma list_norepet_rev:
  forall A (l: list A), list_norepet (rev l) = list_norepet l.

Lemma block_eq_dec: forall b1 b2: block, {b1 = b2} + {b1 <> b2}.

Lemma rev_if_be_singleton:
  forall x, rev_if_be (x::nil) = (x::nil).

Lemma rev_if_be_1: forall i, rev_if_be (i::nil) = (i::nil).

Lemma decode_byte_val:
  forall m, decode_val Mint8unsigned (Byte m :: nil) =
              Vint (Int.zero_ext 8 (Int.repr (Byte.unsigned m))).

Lemma Vint_inj: forall x y, Vint x = Vint y -> x=y.

Definition nullval : val := 
  if Archi.ptr64 then Vlong Int64.zero else Vint Int.zero.

Definition val_to_bool (v: val) : option bool :=
  match v with
    | Vint n => Some (negb (Int.eq n Int.zero))
    | Vptr _ _ => Some true
    | _ => None
  end.

Definition bool_of_valf (v: val): option bool :=
match v with
  | Vint i => Some (negb (Int.eq i Int.zero))
  | Vlong i => Some (negb (Int64.eq i Int64.zero))
  | Vfloat _ => None
  | Vsingle _ => None
  | Vptr _ _ => Some true
  | Vundef => None
end. *)



Require Import compcert.cfrontend.Ctypes. 
(* compcert.cfrontend.Ctypes:
Require Import Axioms Coqlib Maps Errors.
Require Import AST Linking.
Require Archi.

Inductive signedness : Type :=
  | Signed: signedness
  | Unsigned: signedness.

Inductive intsize : Type :=
  | I8: intsize
  | I16: intsize
  | I32: intsize
  | IBool: intsize.

Inductive floatsize : Type :=
  | F32: floatsize
  | F64: floatsize.

Record attr : Type := mk_attr {
  attr_volatile: bool;
  attr_alignas: option N         
}.

Definition noattr := {| attr_volatile := false; attr_alignas := None |}.

Inductive type : Type :=
  | Tvoid: type                                    
  | Tint: intsize -> signedness -> attr -> type    
  | Tlong: signedness -> attr -> type              
  | Tfloat: floatsize -> attr -> type              
  | Tpointer: type -> attr -> type                 
  | Tarray: type -> Z -> attr -> type              
  | Tfunction: typelist -> type -> calling_convention -> type    
  | Tstruct: ident -> attr -> type                 
  | Tunion: ident -> attr -> type                  
with typelist : Type :=
  | Tnil: typelist
  | Tcons: type -> typelist -> typelist.

Lemma intsize_eq: forall (s1 s2: intsize), {s1=s2} + {s1<>s2}.

Lemma type_eq: forall (ty1 ty2: type), {ty1=ty2} + {ty1<>ty2}
with typelist_eq: forall (tyl1 tyl2: typelist), {tyl1=tyl2} + {tyl1<>tyl2}.

Opaque type_eq typelist_eq.

Definition attr_of_type (ty: type) :=
  match ty with
  | Tvoid => noattr
  | Tint sz si a => a
  | Tlong si a => a
  | Tfloat sz a => a
  | Tpointer elt a => a
  | Tarray elt sz a => a
  | Tfunction args res cc => noattr
  | Tstruct id a => a
  | Tunion id a => a
  end.

Definition change_attributes (f: attr -> attr) (ty: type) : type :=
  match ty with
  | Tvoid => ty
  | Tint sz si a => Tint sz si (f a)
  | Tlong si a => Tlong si (f a)
  | Tfloat sz a => Tfloat sz (f a)
  | Tpointer elt a => Tpointer elt (f a)
  | Tarray elt sz a => Tarray elt sz (f a)
  | Tfunction args res cc => ty
  | Tstruct id a => Tstruct id (f a)
  | Tunion id a => Tunion id (f a)
  end.

Definition remove_attributes (ty: type) : type :=
  change_attributes (fun _ => noattr) ty.

Definition attr_union (a1 a2: attr) : attr :=
  {| attr_volatile := a1.(attr_volatile) || a2.(attr_volatile);
     attr_alignas :=
       match a1.(attr_alignas), a2.(attr_alignas) with
       | None, al => al
       | al, None => al
       | Some n1, Some n2 => Some (N.max n1 n2)
       end
  |}.

Definition merge_attributes (ty: type) (a: attr) : type :=
  change_attributes (attr_union a) ty.

Inductive struct_or_union : Type := Struct | Union.

Definition members : Type := list (ident * type).

Inductive composite_definition : Type :=
  Composite (id: ident) (su: struct_or_union) (m: members) (a: attr).

Definition name_composite_def (c: composite_definition) : ident :=
  match c with Composite id su m a => id end.

Definition composite_def_eq (x y: composite_definition): {x=y} + {x<>y}.

Global Opaque composite_def_eq. 

Record composite : Type := {
  co_su: struct_or_union;
  co_members: members;
  co_attr: attr;
  co_sizeof: Z;
  co_alignof: Z;
  co_rank: nat;
  co_sizeof_pos: co_sizeof >= 0;
  co_alignof_two_p: exists n, co_alignof = two_power_nat n;
  co_sizeof_alignof: (co_alignof | co_sizeof)
}.

Definition composite_env : Type := PTree.t composite.

Definition type_int32s := Tint I32 Signed noattr.
Definition type_bool := Tint IBool Signed noattr.

Definition typeconv (ty: type) : type :=
  match ty with
  | Tint (I8 | I16 | IBool) _ _ => Tint I32 Signed noattr
  | Tarray t sz a       => Tpointer t noattr
  | Tfunction _ _ _     => Tpointer ty noattr
  | _                   => remove_attributes ty
  end.

Definition default_argument_conversion (ty: type) : type :=
  match ty with
  | Tint (I8 | I16 | IBool) _ _ => Tint I32 Signed noattr
  | Tfloat _ _          => Tfloat F64 noattr
  | Tarray t sz a       => Tpointer t noattr
  | Tfunction _ _ _     => Tpointer ty noattr
  | _                   => remove_attributes ty
  end.

Fixpoint complete_type (env: composite_env) (t: type) : bool :=
  match t with
  | Tvoid => false
  | Tint _ _ _ => true
  | Tlong _ _ => true
  | Tfloat _ _ => true
  | Tpointer _ _ => true
  | Tarray t' _ _ => complete_type env t'
  | Tfunction _ _ _ => false
  | Tstruct id _ | Tunion id _ =>
      match env!id with Some co => true | None => false end
  end.

Definition complete_or_function_type (env: composite_env) (t: type) : bool :=
  match t with
  | Tfunction _ _ _ => true
  | _ => complete_type env t
  end.

Definition align_attr (a: attr) (al: Z) : Z :=
  match attr_alignas a with
  | Some l => two_p (Z.of_N l)
  | None => al
  end.

Fixpoint alignof (env: composite_env) (t: type) : Z :=
  align_attr (attr_of_type t)
   (match t with
      | Tvoid => 1
      | Tint I8 _ _ => 1
      | Tint I16 _ _ => 2
      | Tint I32 _ _ => 4
      | Tint IBool _ _ => 1
      | Tlong _ _ => Archi.align_int64
      | Tfloat F32 _ => 4
      | Tfloat F64 _ => Archi.align_float64
      | Tpointer _ _ => if Archi.ptr64 then 8 else 4
      | Tarray t' _ _ => alignof env t'
      | Tfunction _ _ _ => 1
      | Tstruct id _ | Tunion id _ =>
          match env!id with Some co => co_alignof co | None => 1 end
    end).

Remark align_attr_two_p:
  forall al a,
  (exists n, al = two_power_nat n) ->
  (exists n, align_attr a al = two_power_nat n).

Lemma alignof_two_p:
  forall env t, exists n, alignof env t = two_power_nat n.

Lemma alignof_pos:
  forall env t, alignof env t > 0.

Fixpoint sizeof (env: composite_env) (t: type) : Z :=
  match t with
  | Tvoid => 1
  | Tint I8 _ _ => 1
  | Tint I16 _ _ => 2
  | Tint I32 _ _ => 4
  | Tint IBool _ _ => 1
  | Tlong _ _ => 8
  | Tfloat F32 _ => 4
  | Tfloat F64 _ => 8
  | Tpointer _ _ => if Archi.ptr64 then 8 else 4
  | Tarray t' n _ => sizeof env t' * Z.max 0 n
  | Tfunction _ _ _ => 1
  | Tstruct id _ | Tunion id _ =>
      match env!id with Some co => co_sizeof co | None => 0 end
  end.

Lemma sizeof_pos:
  forall env t, sizeof env t >= 0.

Fixpoint naturally_aligned (t: type) : Prop :=
  attr_alignas (attr_of_type t) = None /\
  match t with
  | Tarray t' _ _ => naturally_aligned t'
  | _ => True
  end.

Lemma sizeof_alignof_compat:
  forall env t, naturally_aligned t -> (alignof env t | sizeof env t).

Fixpoint alignof_composite (env: composite_env) (m: members) : Z :=
  match m with
  | nil => 1
  | (id, t) :: m' => Z.max (alignof env t) (alignof_composite env m')
  end.

Fixpoint sizeof_struct (env: composite_env) (cur: Z) (m: members) : Z :=
  match m with
  | nil => cur
  | (id, t) :: m' => sizeof_struct env (align cur (alignof env t) + sizeof env t) m'
  end.

Fixpoint sizeof_union (env: composite_env) (m: members) : Z :=
  match m with
  | nil => 0
  | (id, t) :: m' => Z.max (sizeof env t) (sizeof_union env m')
  end.

Lemma alignof_composite_two_p:
  forall env m, exists n, alignof_composite env m = two_power_nat n.

Lemma alignof_composite_pos:
  forall env m a, align_attr a (alignof_composite env m) > 0.

Lemma sizeof_struct_incr:
  forall env m cur, cur <= sizeof_struct env cur m.

Lemma sizeof_union_pos:
  forall env m, 0 <= sizeof_union env m.

Fixpoint field_offset_rec (env: composite_env) (id: ident) (fld: members) (pos: Z)
                          {struct fld} : res Z :=
  match fld with
  | nil => Error (MSG "Unknown field " :: CTX id :: nil)
  | (id', t) :: fld' =>
      if ident_eq id id'
      then OK (align pos (alignof env t))
      else field_offset_rec env id fld' (align pos (alignof env t) + sizeof env t)
  end.

Definition field_offset (env: composite_env) (id: ident) (fld: members) : res Z :=
  field_offset_rec env id fld 0.

Fixpoint field_type (id: ident) (fld: members) {struct fld} : res type :=
  match fld with
  | nil => Error (MSG "Unknown field " :: CTX id :: nil)
  | (id', t) :: fld' => if ident_eq id id' then OK t else field_type id fld'
  end.

Remark field_offset_rec_in_range:
  forall env id ofs ty fld pos,
  field_offset_rec env id fld pos = OK ofs -> field_type id fld = OK ty ->
  pos <= ofs /\ ofs + sizeof env ty <= sizeof_struct env pos fld.

Lemma field_offset_in_range:
  forall env fld id ofs ty,
  field_offset env id fld = OK ofs -> field_type id fld = OK ty ->
  0 <= ofs /\ ofs + sizeof env ty <= sizeof_struct env 0 fld.

Lemma field_offset_no_overlap:
  forall env id1 ofs1 ty1 id2 ofs2 ty2 fld,
  field_offset env id1 fld = OK ofs1 -> field_type id1 fld = OK ty1 ->
  field_offset env id2 fld = OK ofs2 -> field_type id2 fld = OK ty2 ->
  id1 <> id2 ->
  ofs1 + sizeof env ty1 <= ofs2 \/ ofs2 + sizeof env ty2 <= ofs1.

Lemma field_offset_prefix:
  forall env id ofs fld2 fld1,
  field_offset env id fld1 = OK ofs ->
  field_offset env id (fld1 ++ fld2) = OK ofs.

Lemma field_offset_aligned:
  forall env id fld ofs ty,
  field_offset env id fld = OK ofs -> field_type id fld = OK ty ->
  (alignof env ty | ofs).

Inductive mode: Type :=
  | By_value: memory_chunk -> mode
  | By_reference: mode
  | By_copy: mode
  | By_nothing: mode.

Definition access_mode (ty: type) : mode :=
  match ty with
  | Tint I8 Signed _ => By_value Mint8signed
  | Tint I8 Unsigned _ => By_value Mint8unsigned
  | Tint I16 Signed _ => By_value Mint16signed
  | Tint I16 Unsigned _ => By_value Mint16unsigned
  | Tint I32 _ _ => By_value Mint32
  | Tint IBool _ _ => By_value Mint8unsigned
  | Tlong _ _ => By_value Mint64
  | Tfloat F32 _ => By_value Mfloat32
  | Tfloat F64 _ => By_value Mfloat64
  | Tvoid => By_nothing
  | Tpointer _ _ => By_value Mptr
  | Tarray _ _ _ => By_reference
  | Tfunction _ _ _ => By_reference
  | Tstruct _ _ => By_copy
  | Tunion _ _ => By_copy
end.

Definition type_is_volatile (ty: type) : bool :=
  match access_mode ty with
  | By_value _ => attr_volatile (attr_of_type ty)
  | _          => false
  end.

Fixpoint alignof_blockcopy (env: composite_env) (t: type) : Z :=
  match t with
  | Tvoid => 1
  | Tint I8 _ _ => 1
  | Tint I16 _ _ => 2
  | Tint I32 _ _ => 4
  | Tint IBool _ _ => 1
  | Tlong _ _ => 8
  | Tfloat F32 _ => 4
  | Tfloat F64 _ => 8
  | Tpointer _ _ => if Archi.ptr64 then 8 else 4
  | Tarray t' _ _ => alignof_blockcopy env t'
  | Tfunction _ _ _ => 1
  | Tstruct id _ | Tunion id _ =>
      match env!id with
      | Some co => Z.min 8 (co_alignof co)
      | None => 1
      end
  end.

Lemma alignof_blockcopy_1248:
  forall env ty, let a := alignof_blockcopy env ty in a = 1 \/ a = 2 \/ a = 4 \/ a = 8.

Lemma alignof_blockcopy_pos:
  forall env ty, alignof_blockcopy env ty > 0.

Lemma sizeof_alignof_blockcopy_compat:
  forall env ty, (alignof_blockcopy env ty | sizeof env ty).

Fixpoint rank_type (ce: composite_env) (t: type) : nat :=
  match t with
  | Tarray t' _ _ => S (rank_type ce t')
  | Tstruct id _ | Tunion id _ =>
      match ce!id with
      | None => O
      | Some co => S (co_rank co)
      end
  | _ => O
  end.

Fixpoint rank_members (ce: composite_env) (m: members) : nat :=
  match m with
  | nil => 0%nat
  | (id, t) :: m => Init.Nat.max (rank_type ce t) (rank_members ce m)
  end.

Fixpoint type_of_params (params: list (ident * type)) : typelist :=
  match params with
  | nil => Tnil
  | (id, ty) :: rem => Tcons ty (type_of_params rem)
  end.

Definition typ_of_type (t: type) : AST.typ :=
  match t with
  | Tvoid => AST.Tint
  | Tint _ _ _ => AST.Tint
  | Tlong _ _ => AST.Tlong
  | Tfloat F32 _ => AST.Tsingle
  | Tfloat F64 _ => AST.Tfloat
  | Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _ | Tstruct _ _ | Tunion _ _ => AST.Tptr
  end.

Definition opttyp_of_type (t: type) : option AST.typ :=
  if type_eq t Tvoid then None else Some (typ_of_type t).

Fixpoint typlist_of_typelist (tl: typelist) : list AST.typ :=
  match tl with
  | Tnil => nil
  | Tcons hd tl => typ_of_type hd :: typlist_of_typelist tl
  end.

Definition signature_of_type (args: typelist) (res: type) (cc: calling_convention): signature :=
  mksignature (typlist_of_typelist args) (opttyp_of_type res) cc.

Definition sizeof_composite (env: composite_env) (su: struct_or_union) (m: members) : Z :=
  match su with
  | Struct => sizeof_struct env 0 m
  | Union  => sizeof_union env m
  end.

Lemma sizeof_composite_pos:
  forall env su m, 0 <= sizeof_composite env su m.

Fixpoint complete_members (env: composite_env) (m: members) : bool :=
  match m with
  | nil => true
  | (id, t) :: m' => complete_type env t && complete_members env m'
  end.

Lemma complete_member:
  forall env id t m,
  In (id, t) m -> complete_members env m = true -> complete_type env t = true.

Program Definition composite_of_def
     (env: composite_env) (id: ident) (su: struct_or_union) (m: members) (a: attr)
     : res composite :=
  match env!id, complete_members env m return _ with
  | Some _, _ =>
      Error (MSG "Multiple definitions of struct or union " :: CTX id :: nil)
  | None, false =>
      Error (MSG "Incomplete struct or union " :: CTX id :: nil)
  | None, true =>
      let al := align_attr a (alignof_composite env m) in
      OK {| co_su := su;
            co_members := m;
            co_attr := a;
            co_sizeof := align (sizeof_composite env su m) al;
            co_alignof := al;
            co_rank := rank_members env m;
            co_sizeof_pos := _;
            co_alignof_two_p := _;
            co_sizeof_alignof := _ |}
  end.

Local Open Scope error_monad_scope.

Fixpoint add_composite_definitions (env: composite_env) (defs: list composite_definition) : res composite_env :=
  match defs with
  | nil => OK env
  | Composite id su m a :: defs =>
      do co <- composite_of_def env id su m a;
      add_composite_definitions (PTree.set id co env) defs
  end.

Definition build_composite_env (defs: list composite_definition) :=
  add_composite_definitions (PTree.empty _) defs.

Section STABILITY.

Variables env env': composite_env.
Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.

Lemma alignof_stable:
  forall t, complete_type env t = true -> alignof env' t = alignof env t.

Lemma sizeof_stable:
  forall t, complete_type env t = true -> sizeof env' t = sizeof env t.

Lemma complete_type_stable:
  forall t, complete_type env t = true -> complete_type env' t = true.

Lemma rank_type_stable:
  forall t, complete_type env t = true -> rank_type env' t = rank_type env t.

Lemma alignof_composite_stable:
  forall m, complete_members env m = true -> alignof_composite env' m = alignof_composite env m.

Lemma sizeof_struct_stable:
  forall m pos, complete_members env m = true -> sizeof_struct env' pos m = sizeof_struct env pos m.

Lemma sizeof_union_stable:
  forall m, complete_members env m = true -> sizeof_union env' m = sizeof_union env m.

Lemma sizeof_composite_stable:
  forall su m, complete_members env m = true -> sizeof_composite env' su m = sizeof_composite env su m.

Lemma complete_members_stable:
  forall m, complete_members env m = true -> complete_members env' m = true.

Lemma rank_members_stable:
  forall m, complete_members env m = true -> rank_members env' m = rank_members env m.

End STABILITY.

Lemma add_composite_definitions_incr:
  forall id co defs env1 env2,
  add_composite_definitions env1 defs = OK env2 ->
  env1!id = Some co -> env2!id = Some co.

Record composite_consistent (env: composite_env) (co: composite) : Prop := {
  co_consistent_complete:
     complete_members env (co_members co) = true;
  co_consistent_alignof:
     co_alignof co = align_attr (co_attr co) (alignof_composite env (co_members co));
  co_consistent_sizeof:
     co_sizeof co = align (sizeof_composite env (co_su co) (co_members co)) (co_alignof co);
  co_consistent_rank:
     co_rank co = rank_members env (co_members co)
}.

Definition composite_env_consistent (env: composite_env) : Prop :=
  forall id co, env!id = Some co -> composite_consistent env co.

Lemma composite_consistent_stable:
  forall (env env': composite_env)
         (EXTENDS: forall id co, env!id = Some co -> env'!id = Some co)
         co,
  composite_consistent env co -> composite_consistent env' co.

Lemma composite_of_def_consistent:
  forall env id su m a co,
  composite_of_def env id su m a = OK co ->
  composite_consistent env co.

Theorem build_composite_env_consistent:
  forall defs env, build_composite_env defs = OK env -> composite_env_consistent env.

Theorem build_composite_env_charact:
  forall id su m a defs env,
  build_composite_env defs = OK env ->
  In (Composite id su m a) defs ->
  exists co, env!id = Some co /\ co_members co = m /\ co_attr co = a /\ co_su co = su.

Theorem build_composite_env_domain:
  forall env defs id co,
  build_composite_env defs = OK env ->
  env!id = Some co ->
  In (Composite id (co_su co) (co_members co) (co_attr co)) defs.

Remark rank_type_members:
  forall ce id t m, In (id, t) m -> (rank_type ce t <= rank_members ce m)%nat.

Lemma rank_struct_member:
  forall ce id a co id1 t1,
  composite_env_consistent ce ->
  ce!id = Some co ->
  In (id1, t1) (co_members co) ->
  (rank_type ce t1 < rank_type ce (Tstruct id a))%nat.

Lemma rank_union_member:
  forall ce id a co id1 t1,
  composite_env_consistent ce ->
  ce!id = Some co ->
  In (id1, t1) (co_members co) ->
  (rank_type ce t1 < rank_type ce (Tunion id a))%nat.

Set Implicit Arguments.

Section PROGRAMS.

Variable F: Type.

Inductive fundef : Type :=
  | Internal: F -> fundef
  | External: external_function -> typelist -> type -> calling_convention -> fundef.

Record program : Type := {
  prog_defs: list (ident * globdef fundef type);
  prog_public: list ident;
  prog_main: ident;
  prog_types: list composite_definition;
  prog_comp_env: composite_env;
  prog_comp_env_eq: build_composite_env prog_types = OK prog_comp_env
}.

Definition program_of_program (p: program) : AST.program fundef type :=
  {| AST.prog_defs := p.(prog_defs);
     AST.prog_public := p.(prog_public);
     AST.prog_main := p.(prog_main) |}.

Coercion program_of_program: program >-> AST.program.

Program Definition make_program (types: list composite_definition)
                                (defs: list (ident * globdef fundef type))
                                (public: list ident)
                                (main: ident) : res program :=
  match build_composite_env types with
  | Error e => Error e
  | OK ce =>
      OK {| prog_defs := defs;
            prog_public := public;
            prog_main := main;
            prog_types := types;
            prog_comp_env := ce;
            prog_comp_env_eq := _ |}
  end.

Global Opaque Linker_types.

Definition check_compat_composite (l: list composite_definition) (cd: composite_definition) : bool :=
  List.forallb
    (fun cd' =>
      if ident_eq (name_composite_def cd') (name_composite_def cd) then composite_def_eq cd cd' else true)
    l.

Definition filter_redefs (l1 l2: list composite_definition) :=
  let names1 := map name_composite_def l1 in
  List.filter (fun cd => negb (In_dec ident_eq (name_composite_def cd) names1)) l2.

Definition link_composite_defs (l1 l2: list composite_definition): option (list composite_definition) :=
  if List.forallb (check_compat_composite l2) l1
  then Some (l1 ++ filter_redefs l1 l2)
  else None.

Lemma link_composite_def_inv:
  forall l1 l2 l,
  link_composite_defs l1 l2 = Some l ->
     (forall cd1 cd2, In cd1 l1 -> In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1)
  /\ l = l1 ++ filter_redefs l1 l2
  /\ (forall x, In x l <-> In x l1 \/ In x l2).

Lemma add_composite_definitions_append:
  forall l1 l2 env env'',
  add_composite_definitions env (l1 ++ l2) = OK env'' <->
  exists env', add_composite_definitions env l1 = OK env' /\ add_composite_definitions env' l2 = OK env''.

Lemma composite_eq:
  forall su1 m1 a1 sz1 al1 r1 pos1 al2p1 szal1
         su2 m2 a2 sz2 al2 r2 pos2 al2p2 szal2,
  su1 = su2 -> m1 = m2 -> a1 = a2 -> sz1 = sz2 -> al1 = al2 -> r1 = r2 ->
  Build_composite su1 m1 a1 sz1 al1 r1 pos1 al2p1 szal1 = Build_composite su2 m2 a2 sz2 al2 r2 pos2 al2p2 szal2.

Lemma composite_of_def_eq:
  forall env id co,
  composite_consistent env co ->
  env!id = None ->
  composite_of_def env id (co_su co) (co_members co) (co_attr co) = OK co.

Lemma composite_consistent_unique:
  forall env co1 co2,
  composite_consistent env co1 ->
  composite_consistent env co2 ->
  co_su co1 = co_su co2 ->
  co_members co1 = co_members co2 ->
  co_attr co1 = co_attr co2 ->
  co1 = co2.

Lemma composite_of_def_stable:
  forall (env env': composite_env)
         (EXTENDS: forall id co, env!id = Some co -> env'!id = Some co)
         id su m a co,
  env'!id = None ->
  composite_of_def env id su m a = OK co ->
  composite_of_def env' id su m a = OK co.

Lemma link_add_composite_definitions:
  forall l0 env0,
  build_composite_env l0 = OK env0 ->
  forall l env1 env1' env2,
  add_composite_definitions env1 l = OK env1' ->
  (forall id co, env1!id = Some co -> env2!id = Some co) ->
  (forall id co, env0!id = Some co -> env2!id = Some co) ->
  (forall id, env2!id = if In_dec ident_eq id (map name_composite_def l0) then env0!id else env1!id) ->
  ((forall cd1 cd2, In cd1 l0 -> In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1)) ->
  { env2' |
      add_composite_definitions env2 (filter_redefs l0 l) = OK env2'
  /\ (forall id co, env1'!id = Some co -> env2'!id = Some co)
  /\ (forall id co, env0!id = Some co -> env2'!id = Some co) }.

Theorem link_build_composite_env:
  forall l1 l2 l env1 env2,
  build_composite_env l1 = OK env1 ->
  build_composite_env l2 = OK env2 ->
  link l1 l2 = Some l ->
  { env |
     build_composite_env l = OK env
  /\ (forall id co, env1!id = Some co -> env!id = Some co)
  /\ (forall id co, env2!id = Some co -> env!id = Some co) }.

Definition link_fundef {F: Type} (fd1 fd2: fundef F) :=
  match fd1, fd2 with
  | Internal _, Internal _ => None
  | External ef1 targs1 tres1 cc1, External ef2 targs2 tres2 cc2 =>
      if external_function_eq ef1 ef2
      && typelist_eq targs1 targs2
      && type_eq tres1 tres2
      && calling_convention_eq cc1 cc2
      then Some (External ef1 targs1 tres1 cc1)
      else None
  | Internal f, External ef targs tres cc =>
      match ef with EF_external id sg => Some (Internal f) | _ => None end
  | External ef targs tres cc, Internal f =>
      match ef with EF_external id sg => Some (Internal f) | _ => None end
  end.

Remark link_fundef_either:
  forall (F: Type) (f1 f2 f: fundef F), link f1 f2 = Some f -> f = f1 \/ f = f2.

Global Opaque Linker_fundef.

Definition lift_option {A: Type} (opt: option A) : { x | opt = Some x } + { opt = None }.

Definition link_program {F:Type} (p1 p2: program F): option (program F) :=
  match link (program_of_program p1) (program_of_program p2) with
  | None => None
  | Some p =>
      match lift_option (link p1.(prog_types) p2.(prog_types)) with
      | inright _ => None
      | inleft (exist typs EQ) =>
          match link_build_composite_env
                   p1.(prog_types) p2.(prog_types) typs
                   p1.(prog_comp_env) p2.(prog_comp_env)
                   p1.(prog_comp_env_eq) p2.(prog_comp_env_eq) EQ with
          | exist env (conj P Q) =>
              Some {| prog_defs := p.(AST.prog_defs);
                      prog_public := p.(AST.prog_public);
                      prog_main := p.(AST.prog_main);
                      prog_types := typs;
                      prog_comp_env := env;
                      prog_comp_env_eq := P |}
          end
      end
  end.

Definition linkorder_program {F: Type} (p1 p2: program F) : Prop :=
     linkorder (program_of_program p1) (program_of_program p2)
  /\ (forall id co, p1.(prog_comp_env)!id = Some co -> p2.(prog_comp_env)!id = Some co).

Global Opaque Linker_program.

Section LINK_MATCH_PROGRAM.

Context {F G: Type}.
Variable match_fundef: fundef F -> fundef G -> Prop.

Hypothesis link_match_fundef:
  forall f1 tf1 f2 tf2 f,
  link f1 f2 = Some f ->
  match_fundef f1 tf1 -> match_fundef f2 tf2 ->
  exists tf, link tf1 tf2 = Some tf /\ match_fundef f tf.

Let match_program (p: program F) (tp: program G) : Prop :=
    Linking.match_program (fun ctx f tf => match_fundef f tf) eq p tp
 /\ prog_types tp = prog_types p.

Theorem link_match_program:
  forall p1 p2 tp1 tp2 p,
  link p1 p2 = Some p -> match_program p1 tp1 -> match_program p2 tp2 ->
  exists tp, link tp1 tp2 = Some tp /\ match_program p tp.

End LINK_MATCH_PROGRAM. *)



Axiom list_norepet_NoDup: forall {A: Type} (l: list A), list_norepet l <-> NoDup l.



Lemma PTree_In_fst_elements {A: Type}: forall (T: PTree.t A) i,

  In i (map fst (PTree.elements T)) <-> exists a, PTree.get i T = Some a.

Proof.

  intros.

  split; intros.

  + apply list_in_map_inv in H.

    destruct H as [[i0 a] [? ?]].

    simpl in H; subst i0.

    apply PTree.elements_complete in H0.

    eauto.

  + destruct H as [a ?].

    apply PTree.elements_correct in H.

    apply (in_map fst) in H.

    auto.

Qed.



Lemma PTree_gs {A: Type}: forall (T: PTree.t A) i j x,

  (exists a, PTree.get i T= Some a) ->

  exists a, PTree.get i (PTree.set j x T) = Some a.

Proof.

  intros.

  destruct H.

  destruct (Pos.eq_dec i j).

  + subst.

    rewrite PTree.gss; eauto.

  + rewrite PTree.gso; eauto.

Qed.



Lemma PTree_gs_equiv {A: Type}: forall (T: PTree.t A) i j x,

  (exists a, PTree.get i T= Some a) \/ i = j <->

  exists a, PTree.get i (PTree.set j x T) = Some a.

Proof.

  intros.

  split; intros.

  + destruct H; [apply PTree_gs; auto |].

    subst; rewrite PTree.gss; eauto.

  + destruct (Pos.eq_dec i j); auto.

    rewrite PTree.gso in H by auto.

    auto.

Qed.



Lemma PTree_set_In_fst_elements {A: Type}: forall (T: PTree.t A) i i' a',

  In i (map fst (PTree.elements T)) ->

  In i (map fst (PTree.elements (PTree.set i' a' T))).

Proof.

  intros.

  rewrite PTree_In_fst_elements in H |- *.

  apply PTree_gs; auto.

Qed.

  

Fixpoint relative_defined_type {A: Type} (l: list (ident * A)) (t: type): Prop :=

  match t with

  | Tarray t' _ _ => relative_defined_type l t'

  | Tstruct id _ => In id (map fst l)

  | Tunion id _ => In id (map fst l)

  | _ => True

  end.



Lemma relative_defined_type_mono: forall {A B: Type} (l1: list (ident * A)) (l2: list (ident * B)) (t: type),

  (forall i, In i (map fst l1) -> In i (map fst l2)) ->

  relative_defined_type l1 t ->

  relative_defined_type l2 t.

Proof.

  intros.

  induction t; auto.

  + simpl in *.

    firstorder.

  + simpl in *.

    firstorder.

Qed.



Lemma relative_defined_type_equiv: forall {A B: Type} (l1: list (ident * A)) (l2: list (ident * B)) (t: type),

  (forall i, In i (map fst l1) <-> In i (map fst l2)) ->

  (relative_defined_type l1 t <-> relative_defined_type l2 t).

Proof.

  intros.

  split; apply relative_defined_type_mono;

  firstorder.

Qed.



Inductive ordered_composite: list (positive * composite) -> Prop :=

| ordered_composite_nil: ordered_composite nil

| ordered_composite_cons: forall i co l,

    Forall (relative_defined_type l) (map snd (co_members co)) ->

    ordered_composite l ->

    ordered_composite ((i, co) :: l).



Module composite_reorder.



Module CompositeRankOrder <: TotalLeBool.

  Definition t := (positive * composite)%type.

  Definition leb (x y: t) := Nat.leb (co_rank (snd y)) (co_rank (snd x)).



  Theorem leb_total : forall a1 a2, leb a1 a2 = true \/ leb a2 a1 = true.

  Proof.

    intros.

    unfold leb.

    rewrite !Nat.leb_le.

    omega.

  Qed.



  Theorem leb_trans: Transitive (fun x y => is_true (leb x y)).

  Proof.

    hnf; intros; unfold leb, is_true in *.

    rewrite !Nat.leb_le in *.

    omega.

  Qed.



End CompositeRankOrder.



Module CompositeRankSort := Sort CompositeRankOrder.



Section composite_reorder.



Context (cenv: composite_env)

        (cenv_consistent: composite_env_consistent cenv).



Definition rebuild_composite_elements := CompositeRankSort.sort (PTree.elements cenv).



Inductive ordered_and_complete: list (positive * composite) -> Prop :=

| ordered_and_complete_nil: ordered_and_complete nil

| ordered_and_complete_cons: forall i co l,

    (forall i' co',

        cenv ! i' = Some co' ->

        (co_rank co' < co_rank co)%nat ->

        In (i', co') l) ->

    ordered_and_complete l ->

    ordered_and_complete ((i, co) :: l).



Theorem RCT_Permutation: Permutation rebuild_composite_elements (PTree.elements cenv).

Proof.

  symmetry.

  apply CompositeRankSort.Permuted_sort.

Qed.



Lemma RCT_ordered_and_complete: ordered_and_complete rebuild_composite_elements.

Proof.

  pose proof RCT_Permutation.

  assert (forall i co, cenv ! i = Some co -> In (i, co) rebuild_composite_elements).

  {

    intros.

    eapply Permutation_in.

    + symmetry; apply RCT_Permutation.

    + apply PTree.elements_correct; auto.

  } 

  clear H.

  pose proof CompositeRankSort.StronglySorted_sort (PTree.elements cenv) CompositeRankOrder.leb_trans.

  pose proof app_nil_l rebuild_composite_elements.

  unfold rebuild_composite_elements in *.

  set (l := (CompositeRankSort.sort (PTree.elements cenv))) in H1 at 1 |- *.

  revert H1; generalize (@nil (positive * composite)).

  clearbody l.

  induction l; intros.

  + constructor.

  + specialize (IHl (l0 ++ a :: nil)).

    rewrite <- app_assoc in IHl.

    specialize (IHl H1).

    destruct a as [i co]; constructor; auto.

    intros.

    apply H0 in H2.

    rewrite <- H1 in H2, H.

    clear - H2 H3 H.

    induction l0.

    - destruct H2; auto.

      exfalso; inv H0.

      omega.

    - inv H.

      destruct H2.

      * exfalso.

        subst.

        rewrite Forall_forall in H5.

        specialize (H5 (i, co)).

        rewrite in_app in H5.

        specialize (H5 (or_intror (or_introl eq_refl))).

        unfold is_true in H5.

        rewrite Nat.leb_le in H5; simpl in H5.

        omega.

      * apply IHl0; auto.

Qed.



Theorem RCT_ordered: ordered_composite rebuild_composite_elements.

Proof.

  pose proof RCT_ordered_and_complete.

  assert (forall i co, In (i, co) rebuild_composite_elements -> complete_members cenv (co_members co) = true /\ co_rank co = rank_members cenv (co_members co)).

  {

    intros.

    eapply Permutation_in in H0; [| exact RCT_Permutation].

    apply PTree.elements_complete in H0; auto.

    split.

    + apply co_consistent_complete.

      eapply cenv_consistent; eauto.

    + apply co_consistent_rank.

      eapply cenv_consistent; eauto.

  }

  induction H.

  + constructor.

  + specialize (IHordered_and_complete (fun i co HH => H0 i co (or_intror HH))).

    constructor; auto.

    clear IHordered_and_complete H1.

    specialize (H0 _ _ (or_introl eq_refl)).

    assert (rank_members cenv (co_members co) <= co_rank co)%nat by omega.

    destruct H0 as [? _].

    induction (co_members co) as [| [i0 t0] ?].

    - constructor.

    - simpl in H0; rewrite andb_true_iff in H0; destruct H0.

      simpl in H1; pose proof Max.max_lub_r _ _ _ H1.

      apply Max.max_lub_l in H1.

      constructor; auto; clear IHm H2 H3.

      simpl.

      induction t0; try solve [simpl; auto].

      * 

        spec IHt0; auto.

        spec IHt0; [simpl in H1; omega |].

        auto.

      * 

        simpl in H0, H1 |- *.

        destruct (cenv ! i1) eqn:?H; [| inv H0].

        specialize (H _ _ H2).

        spec H; [omega |].

        apply (in_map fst) in H; auto.

      * 

        simpl in H0, H1 |- *.

        destruct (cenv ! i1) eqn:?H; [| inv H0].

        specialize (H _ _ H2).

        spec H; [omega |].

        apply (in_map fst) in H; auto.

Qed.



End composite_reorder.



End composite_reorder.



Module type_func.

Section type_func.



Context {A: Type}

        (f_default: type -> A)

        (f_array: A -> type -> Z -> attr -> A)

        (f_struct: A -> ident -> attr -> A)

        (f_union: A -> ident -> attr -> A)

        (f_member: struct_or_union -> list (ident * type * A) -> A).



Fixpoint F (env: PTree.t A) (t: type): A :=

  match t with

  | Tarray t n a => f_array (F env t) t n a

  | Tstruct id a =>

      match env ! id with

      | Some v => f_struct v id a

      | None => f_default t

      end

  | Tunion id a =>

      match env ! id with

      | Some v => f_union v id a

      | None => f_default t

      end

  | _ => f_default t

  end.



Definition Complete (cenv: composite_env) (env: PTree.t A): Prop :=

  forall i,

    (exists co, PTree.get i cenv = Some co) <->

    (exists a, PTree.get i env = Some a).



Definition Consistent (cenv: composite_env) (env: PTree.t A): Prop :=

  forall i co a,

    PTree.get i cenv = Some co ->

    PTree.get i env = Some a ->

    a = f_member (co_su co) (map

                              (fun it0: positive * type =>

                                 let (i0, t0) := it0 in

                                 (i0, t0, F env t0))

                              (co_members co)).



Definition env_rec (i: positive) (co: composite) (env: PTree.t A): PTree.t A :=

  PTree.set i

    (f_member (co_su co) (map

                              (fun it0: positive * type =>

                                 let (i0, t0) := it0 in (i0, t0, F env t0))

                              (co_members co)))

    env.



Definition Env (l: list (positive * composite)): PTree.t A :=

  fold_right

    (fun (ic: positive * composite) =>

       let (i, co) := ic in env_rec i co)

    (PTree.empty A)

    l.



Lemma F_PTree_set: forall t env i a,

  ~ In i (map fst (PTree.elements env)) ->

  relative_defined_type (PTree.elements env) t ->

  F env t = F (PTree.set i a env) t.

Proof.

  intros.

  induction t; auto.

  + simpl.

    apply IHt in H0.

    rewrite H0; auto.

  + simpl in H0 |- *.

    rewrite PTree.gso; auto.

    intro; subst; tauto.

  + simpl in H0 |- *.

    rewrite PTree.gso; auto.

    intro; subst; tauto.

Qed.



Lemma relative_defined_type_PTree_set: forall t (env: PTree.t A) i a,

  relative_defined_type (PTree.elements env) t ->

  relative_defined_type (PTree.elements (PTree.set i a env)) t.

Proof.

  intros.

  revert H; apply relative_defined_type_mono.

  intros; apply PTree_set_In_fst_elements; auto.

Qed.



Section Consistency_Induction_Step.



Context (cenv: composite_env)

        (env: PTree.t A)

        (l: list (positive * composite))

        (i0: positive)

        (co0: composite).



Hypothesis NOT_IN_LIST: ~ In i0 (map fst l).



Hypothesis RDT_list: Forall (relative_defined_type l) (map snd (co_members co0)).



Hypothesis CENV0: PTree.get i0 cenv = Some co0.



Hypothesis IH_In_equiv: forall i, In i (map fst l) <-> In i (map fst (PTree.elements env)).



Hypothesis IH_RDT:

  forall i co a,

    PTree.get i cenv = Some co ->

    PTree.get i env = Some a ->

    Forall (relative_defined_type (PTree.elements env)) (map snd (co_members co)).



Hypothesis IH_main:

  Consistent cenv env.



Lemma NOT_IN: ~ In i0 (map fst (PTree.elements env)).

Proof.

  intros.

  rewrite <- IH_In_equiv; auto.

Qed.



Lemma RDT_PTree: Forall (relative_defined_type (PTree.elements env)) (map snd (co_members co0)).

Proof.

  intros.

  revert RDT_list; apply Forall_impl.

  intros t.

  apply relative_defined_type_mono.

  firstorder.

Qed.



Lemma establish_In_equiv:

  forall i, In i (map fst ((i0, co0) :: l)) <-> In i (map fst (PTree.elements (env_rec i0 co0 env))).

Proof.

  intros.

  specialize (IH_In_equiv i).

  rewrite PTree_In_fst_elements in IH_In_equiv |- *.

  unfold env_rec.

  rewrite <- PTree_gs_equiv.

  simpl In.

  assert (i0 = i <-> i = i0) by (split; intros; congruence).

  tauto.

Qed.



Lemma establish_RDT:

  forall i co a,

    PTree.get i cenv = Some co ->

    PTree.get i (env_rec i0 co0 env) = Some a ->

    Forall (relative_defined_type (PTree.elements (env_rec i0 co0 env))) (map snd (co_members co)).

Proof.

  pose proof RDT_PTree as RDT_PTree.

  intros i co a CENV ENV.

  unfold env_rec in ENV.

  destruct (Pos.eq_dec i i0).

  + subst i0; rewrite CENV in CENV0; inversion CENV0; subst co0; clear CENV0.

    rewrite PTree.gss in ENV.

    inversion ENV; clear a ENV H0.

    revert RDT_PTree.

    apply Forall_impl; intros t.

    apply relative_defined_type_PTree_set.

  + rewrite PTree.gso in ENV by auto.

    specialize (IH_RDT _ _ _ CENV ENV).

    revert IH_RDT.

    apply Forall_impl; intros t.

    apply relative_defined_type_PTree_set.

Qed.



Lemma establish_main:

  Consistent cenv (env_rec i0 co0 env).

Proof.

  pose proof NOT_IN as NOT_IN.

  pose proof RDT_PTree as RDT_PTree.

  intros i co a CENV ENV.

  unfold env_rec in ENV.

  destruct (Pos.eq_dec i i0).

  + subst i0; rewrite CENV in CENV0; inversion CENV0; subst co0; clear CENV0.

    rewrite PTree.gss in ENV.

    inversion ENV; clear a ENV H0.

    f_equal.

    auto.

    apply map_ext_in.

    intros (i1, t1) ?.

    f_equal.

    apply F_PTree_set; auto.

    rewrite Forall_forall in RDT_PTree; apply RDT_PTree.

    apply (in_map snd) in H; auto.

  + rewrite PTree.gso in ENV by auto.

    specialize (IH_main _ _ _ CENV ENV).

    subst a.

    f_equal.

    apply map_ext_in.

    intros (i1, t1) ?.

    f_equal.

    apply F_PTree_set; auto.

    specialize (IH_RDT _ _ _ CENV ENV).

    rewrite Forall_forall in IH_RDT; apply IH_RDT.

    apply (in_map snd) in H; auto.

Qed.



End Consistency_Induction_Step.



Lemma Consistency: forall cenv l,

  Permutation l (PTree.elements cenv) ->

  ordered_composite l ->

  Consistent cenv (Env l).

Proof.

  intros.

  assert (forall i co, In (i, co) l -> PTree.get i cenv = Some co).

  {

    intros.

    apply PTree.elements_complete.

    eapply Permutation_in; eauto.

  }

  assert (NoDup (map fst l)).

  {

    eapply Permutation_NoDup; [symmetry; apply Permutation_map; eassumption |].

    rewrite <- list_norepet_NoDup.

    apply PTree.elements_keys_norepet.

  }

  clear H.

  assert (

    (forall i, In i (map fst l) <-> In i (map fst (PTree.elements (Env l)))) /\

    (forall i co a,

      PTree.get i cenv = Some co ->

      PTree.get i (Env l) = Some a ->

      Forall (relative_defined_type (PTree.elements (Env l))) (map snd (co_members co))) /\

    Consistent cenv (Env l)); [| tauto].

  induction l as [| [i0 co0] l].

  + split; [| split]; hnf; intros.

    - simpl; tauto.

    - unfold Env in H3; simpl in H3.

      rewrite PTree.gempty in H3; inv H3.

    - unfold Env in H3; simpl in H3.

      rewrite PTree.gempty in H3; inv H3.

  + inv H0.

    rename H4 into RDT_list; specialize (IHl H6); clear H6.

    assert (CENV0: PTree.get i0 cenv = Some co0).

    { apply H1; left; auto. }

    spec IHl; [| clear H1].

    { intros; apply H1; right; auto. } 

    inv H2.

    rename H1 into NOT_IN_LIST; specialize (IHl H3); clear H3.

    destruct IHl as [IH_In_equiv [IH_RDT IH_main]].

    split; [| split].

    - apply establish_In_equiv; auto.

    - eapply establish_RDT; eauto.

    - eapply establish_main; eauto.

Qed.



Lemma Completeness: forall cenv l,

  Permutation l (PTree.elements cenv) ->

  Complete cenv (Env l).

Proof.

  intros.

  intro.

  rewrite <- !PTree_In_fst_elements.

  pose proof PTree.elements_keys_norepet cenv.

  rewrite list_norepet_NoDup in H0.

  rewrite <- H in H0 |- *; clear H.

  induction l.

  + simpl; tauto.

  + destruct a as [i0 co0].

    inv H0.

    specialize (IHl H3).

    simpl.

    unfold env_rec.

    rewrite PTree_In_fst_elements, <- PTree_gs_equiv, <- PTree_In_fst_elements.

    assert (i = i0 <-> i0 = i) by (split; intros; congruence).

    tauto.

Qed.



End type_func.



End type_func.



Corollary composite_reorder_consistent {A: Type}:

  forall cenv f_default f_array f_struct f_union f_members,

    composite_env_consistent cenv ->

    type_func.Consistent f_default f_array f_struct f_union f_members cenv (@type_func.Env A f_default f_array f_struct f_union f_members (composite_reorder.rebuild_composite_elements cenv)).

Proof.

  intros.

  apply type_func.Consistency.

  + apply composite_reorder.RCT_Permutation.

  + apply composite_reorder.RCT_ordered; auto.

Qed.



Corollary composite_reorder_complete {A: Type}:

  forall cenv f_default f_array f_struct f_union f_members,

    type_func.Complete cenv (@type_func.Env A f_default f_array f_struct f_union f_members (composite_reorder.rebuild_composite_elements cenv)).

Proof.

  intros.

  apply type_func.Completeness.

  apply composite_reorder.RCT_Permutation.

Qed.



Section cuof.



Context (cenv: composite_env).



Fixpoint complete_legal_cosu_type t :=

  match t with

  | Tarray t' _ _ => complete_legal_cosu_type t'

  | Tstruct id _ => match cenv ! id with

                    | Some co => match co_su co with

                                 | Struct => true

                                 | Union => false

                                 end

                    | _ => false

                    end

  | Tunion id _ => match cenv ! id with

                   | Some co => match co_su co with

                                | Struct => false

                                | Union => true

                                end

                   | _ => false

                   end

  | Tfunction _ _ _

  | Tvoid => false

  | _ => true

  end.



Fixpoint composite_complete_legal_cosu_type (m: members): bool :=

  match m with

  | nil => true

  | (_, t) :: m' => complete_legal_cosu_type t && composite_complete_legal_cosu_type m'

  end.



Definition composite_env_complete_legal_cosu_type: Prop :=

  forall (id : positive) (co : composite),

    cenv ! id = Some co -> composite_complete_legal_cosu_type (co_members co) = true.

  

End cuof.



Lemma complete_legal_cosu_type_complete_type: forall cenv: composite_env,

  forall t,

    complete_legal_cosu_type cenv t = true ->

    complete_type cenv t = true.

Proof.

  intros.

  induction t; auto.

  + simpl in *.

    destruct (cenv ! i); auto.

  + simpl in *.

    destruct (cenv ! i); auto.

Qed.



