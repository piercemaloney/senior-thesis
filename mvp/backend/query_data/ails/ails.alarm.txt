
Require Import Bool.
Require Import Reals.
Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)
Require Import trajectory_def.
(* trajectory_def:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.

Record Trajectory : Type := mkTrajectory
  {x : Differential;
   y : Differential;
   theta : Differential;
   phi : Differential;
   h : TypeSpeed;
   cond_x :
    forall t : R, derive_pt x t (cond_diff x t) = (h * cos (theta t))%R;
   cond_y :
    forall t : R, derive_pt y t (cond_diff y t) = (h * sin (theta t))%R;
   cond_phi : forall t : R, (- MaxBank <= phi t <= MaxBank)%R;
   cond_theta :
    forall t : R,
    derive_pt theta t (cond_diff theta t) = (g * (tan (phi t) / h))%R}.

Record EvaderTrajectory : Type := mkEvaderTrajectory
  {tr : Trajectory;
   tr_cond1 : forall t : R, x tr t = (x tr 0 + h tr * t)%R;
   tr_cond2 : forall t : R, y tr t = y tr 0%R;
   tr_cond3 : forall t : R, theta tr t = 0%R;
   tr_cond4 : forall t : R, phi tr t = 0%R}.

Lemma init_tr_derivable_x :
 forall h : TypeSpeed, derivable (fun t : R => (h * t)%R).

Lemma init_tr_derivable_y :
 forall h : TypeSpeed, derivable (fun t : R => 0%R).

Lemma init_tr_cond_x :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => (h * t)%R) t (init_tr_derivable_x h t) =
 (h * cos ((fun t : R => 0) t))%R.

Lemma init_tr_cond_y :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (h * sin ((fun t : R => 0) t))%R.

Lemma init_tr_cond_phi :
 forall t : R,
 (- MaxBank <= (fun t : R => 0) t)%R /\ ((fun t : R => 0) t <= MaxBank)%R.

Lemma fct_der1 : forall t : R, derivable_pt (fun t : R => 0%R) t.

Lemma init_tr_cond_theta :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (fun t : R => (g * (tan 0 / h))%R) t.

Definition init_tr (h : TypeSpeed) : Trajectory :=
  mkTrajectory
    (mkDifferential (fun t : R => (h * t)%R) (init_tr_derivable_x h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h)) h
    (init_tr_cond_x h) (init_tr_cond_y h) init_tr_cond_phi
    (init_tr_cond_theta h).

Lemma MaxBank_encadr : (0 < MaxBank < PI / 4)%R.

Lemma dtheta_rho :
 forall (tr : Trajectory) (t : R),
 (- rho (h tr) <= derive_pt (theta tr) t (cond_diff (theta tr) t) <=
  rho (h tr))%R. *)
Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)
Require Import ycngftys.
(* ycngftys:
Section ycngftys.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.
Require Import constants.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition xi : R -> R := x intr.
Definition yi : R -> R := y intr.
Definition vi : TypeSpeed := h intr.
Definition xP (t : R) : R := (xi t - xi 0)%R.
Definition yP (t : R) : R := (yi t - yi 0)%R.
Definition u (eps : posreal) (t : R) : R :=
  sqrt (Rsqr (xP t) + Rsqr (yP t) + Rsqr eps).
Definition u0 (t : R) : R := sqrt (Rsqr (xP t) + Rsqr (yP t)).

Lemma xi_derivable : derivable xi.

Lemma yi_derivable : derivable yi.

Lemma xP_derivable : derivable xP.

Lemma yP_derivable : derivable yP.

Lemma d_u : forall eps : posreal, derivable (fun t : R => u eps t).

Lemma fct_der2 :
 forall (eps : posreal) (t : R), derivable_pt (fun y : R => Rsqr (u eps y)) t.

Lemma D_Rsqr_u_epsilon_1 :
 forall (eps : posreal) (t : R),
 derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) =
 (2 * u eps t * derive_pt (u eps) t (d_u eps t))%R. 

Lemma xP_derive :
 forall t : R,
 derive_pt xP t (xP_derivable t) = derive_pt xi t (xi_derivable t).

Lemma yP_derive :
 forall t : R,
 derive_pt yP t (yP_derivable t) = derive_pt yi t (yi_derivable t).

Lemma fct_der3 :
 forall (eps : posreal) (t : R),
 derivable_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t.

Lemma D_Rsqr_u_epsilon_2 :
 forall (eps : posreal) (t : R),
 (derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) <= 2 * u0 t * vi)%R.

Lemma u_stric_pos : forall (eps : posreal) (t : R), (0 < u eps t)%R.

Lemma u_pos : forall (eps : posreal) (t : R), (0 <= u eps t)%R.

Lemma u0_pos : forall t : R, (0 <= u0 t)%R.

Lemma Rsqr_u_epsilon :
 forall (eps : posreal) (t : R), Rsqr (u eps t) = (Rsqr (u0 t) + Rsqr eps)%R.

Lemma u0_u_epsilon : forall (eps : posreal) (t : R), (u0 t <= u eps t)%R.

Lemma u_epsilon_le_v :
 forall (eps : posreal) (t : R), (derive_pt (u eps) t (d_u eps t) <= vi)%R.

Lemma vit_derivable : derivable (fun t : R => (vi * t)%R).

Lemma derive_vit :
 forall t : R, derive_pt (fun t : R => (vi * t)%R) t (vit_derivable t) = vi.

Lemma u_epsilon_le_vt :
 forall (eps : posreal) (t : R), (0 <= t)%R -> (u eps t - eps <= vi * t)%R.

Lemma Rsqr_u :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + 2 * eps * vi * t)%R.

Lemma Rsqr_u_Rsqr_vt :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + eps)%R.

Theorem YCNGFTYS :
 forall t : R,
 (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.

End ycngftys. *)
Require Import ycngstys.
(* ycngstys:
Section ycngstys.

Require Import Reals.
Require Import trajectory_def.
Require Import trajectory_const.
Require Import constants.
Require Import ycngftys.
Require Import rrho.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition thetat : R -> R := theta intr.
Definition Rs (t : R) : R :=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)).

Axiom
  alphas_exists :
    { f : Differential_D2 |
       forall t : R,
       xi intr t = (Rs t * cos (f t) + xi intr 0)%R /\
       yi intr t = (Rs t * sin (f t) + yi intr 0)%R }.

Definition alphas := let (a,_) := alphas_exists in a.

Lemma alphas_def :
 forall t : R,
 xi intr t = (Rs t * cos (alphas t) + xi intr 0)%R /\
 yi intr t = (Rs t * sin (alphas t) + yi intr 0)%R.

Lemma Rsx : forall t : R, xi intr t = (xi intr 0 + Rs t * cos (alphas t))%R.

Lemma Rsy : forall t : R, yi intr t = (yi intr 0 + Rs t * sin (alphas t))%R.

Lemma Rs_x :
 forall t : R,
 cos (alphas t) <> 0%R -> Rs t = ((xi intr t - xi intr 0) / cos (alphas t))%R.

Lemma Rs_y :
 forall t : R,
 sin (alphas t) <> 0%R -> Rs t = ((yi intr t - yi intr 0) / sin (alphas t))%R.

Lemma Rs_derivable : derivable Rs.

Definition alphas_p : R -> R := d2 alphas.

Lemma fct_der4 :
 forall t : R,
 derivable_pt ((Rs * comp cos alphas_p)%F + fct_cte (xi intr 0)) t.

Lemma Dxi :
 forall t : R,
 derive_pt (xi intr) t (xi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma Dyi :
 forall t : R,
 derive_pt (yi intr) t (yi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma DRs_cos :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * cos (thetat t))%R.

Lemma DRs_sin :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t))%R.

Lemma eq_plus_eq_is_eq :
 forall x y z t : R, x = y -> z = t -> (x + z)%R = (y + t)%R.

Lemma DRs :
 forall t : R,
 derive_pt Rs t (Rs_derivable t) = (vi intr * cos (thetat t - alphas t))%R.

Lemma Rs_alphas :
 forall t : R,
 (Rs t * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t - alphas t))%R.

Lemma fct_der5 :
 forall t : R,
 derivable_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R)
   t.

Lemma D_Rs_alphas1 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (derive_pt Rs t (Rs_derivable t) * derive_pt alphas t (cond_D1 alphas t) +
  Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma thetat_derivable : derivable thetat.

Lemma D_Rs_alphas2 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (vi intr * cos (thetat t - alphas t) *
  (derive_pt thetat t (thetat_derivable t) -
   derive_pt alphas t (cond_D1 alphas t)))%R.

Lemma D_Rs_2 :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) *
  (2 * derive_pt alphas t (cond_D1 alphas t) -
   derive_pt thetat t (thetat_derivable t)))%R =
 (- Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma Rsqr_DRs :
 forall t : R,
 (Rsqr (derive_pt Rs t (Rs_derivable t)) +
  Rsqr (Rs t) * Rsqr (derive_pt alphas t (cond_D1 alphas t)))%R =
 Rsqr (vi intr).

Lemma Rs_pos : forall t : R, (0 <= Rs t)%R.

Lemma Rs_0 : Rs 0 = 0%R.

Lemma D_Rs_0 : (0 <= derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma eq_sym : forall x y : R, x = y -> y = x.

Lemma D_Rs_0_strong : (0 < derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma D_alphas_0 :
 (2 * derive_pt alphas 0 (cond_D1 alphas 0))%R =
 derive_pt thetat 0 (thetat_derivable 0%R).

Lemma D_Rs_pos_non_null :
 forall t : R,
 (0 < t)%R ->
 (forall x : R, (0 < x < t)%R -> (0 < derive_pt Rs x (Rs_derivable x))%R) ->
 (0 < Rs t)%R.

Axiom
  D_Rs_pos :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R -> (0 < derive_pt Rs t (Rs_derivable t))%R.

Axiom
  D_abs_alpha :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R ->
    (- rho (vi intr) / 2 <= derive_pt alphas t (cond_D1 alphas t))%R /\
    (derive_pt alphas t (cond_D1 alphas t) <= rho (vi intr) / 2)%R.

Definition F (t : R) : R :=
  (2 * (vi intr / rho (vi intr)) * sin (rho (vi intr) * (t / 2)))%R.

Lemma F_derivable : derivable F.

Lemma D_F :
 forall t : R,
 derive_pt F t (F_derivable t) = (vi intr * cos (rho (vi intr) * (t / 2)))%R.

Lemma D_F_Rsqr_v :
 forall t : R,
 (Rsqr (derive_pt F t (F_derivable t)) +
  Rsqr (rho (vi intr) / 2) * Rsqr (F t))%R = Rsqr (vi intr).

Definition G (t : R) : R := (Rs t - F t)%R.

Lemma G_derivable : derivable G.

Lemma D_G_alphas :
 forall t : R,
 (derive_pt G t (G_derivable t) *
  (derive_pt Rs t (Rs_derivable t) + derive_pt F t (F_derivable t)))%R =
 (- Rsqr (derive_pt alphas t (cond_D1 alphas t)) * G t * (Rs t + F t) +
  Rsqr (F t) *
  (Rsqr (rho (vi intr) / 2) - Rsqr (derive_pt alphas t (cond_D1 alphas t))))%R.

Lemma Rlt_1_PI2 : (1 < PI / 2)%R.

Lemma D_G_pos :
 forall t : R,
 (0 <= t)%R ->
 (t < 2 / rho (vi intr))%R ->
 (G t <= 0)%R -> (0 <= derive_pt G t (G_derivable t))%R.

Lemma G_0 : G 0 = 0%R.

Axiom
  G_pos :
    forall t : R, (0 <= t)%R -> (t < 2 / rho (vi intr))%R -> (0 <= G t)%R.

Theorem YCNGSTYS :
 forall t : R,
 (0 <= t)%R ->
 (rho (vi intr) * t < 2)%R ->
 (2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)))%R.

End ycngstys. *)
Require Import ails_def.
(* ails_def:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.

Record Bank : Type := mkBank
  {r :> R; cond1 : (- toDeg MaxBank <= r)%R; cond2 : (r <= toDeg MaxBank)%R}.

Record State : Type := mkState {xt : R; yt : R; heading : R; bank : Bank}.

Definition intruderSpeed : TypeSpeed := V.
Definition evaderSpeed : TypeSpeed := V. *)
Require Import math_prop.
(* math_prop:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import constants.
Require Import Omega.

Axiom
  Math_prop_alarm_1 :
    forall (a l : R) (T : TimeT),
    (MinDistance T <= l)%R ->
    (l <= MaxDistance T)%R ->
    (0 <= a)%R ->
    (a <= MinBeta)%R ->
    (Rsqr (l * cos a - v V * T) + Rsqr (l * sin a) <= Rsqr AlertRange)%R.

Axiom
  Math_prop_no_conflict_1 :
    forall (a l x y : R) (T : TimeT),
    (MinDistance T <= l)%R ->
    (l <= MaxDistance T)%R ->
    (MinBeta <= a)%R ->
    (a <= PI / 2)%R ->
    (l * sin a + r_V * (cos (rho_V * T) - 1) <= y)%R ->
    (r_V * sin (rho_V * T) - l * cos a <= x)%R ->
    (Rsqr ConflictRange < Rsqr x + Rsqr y)%R.

Lemma MinBeta_pos : (0 < MinBeta)%R.

Lemma Math_prop_y_a_PI2 :
 forall (a l : R) (T : TimeT),
 (MinBeta <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l)%R ->
 (l * sin MinBeta + r_V * (cos (rho_V * T) - 1) <=
  l * sin a + r_V * (cos (rho_V * T) - 1))%R. 

Lemma Math_prop_approx_y_a_PI2 :
 forall (a l1 l2 : R) (T : TimeT),
 (0 <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l1)%R ->
 (l1 <= l2)%R ->
 (l1 * sin_lb a + r_ub V * (cos_lb (rho_ub V * MaxT) - 1) <=
  l2 * sin a + r_V * (cos (rho_V * T) - 1))%R.

Lemma Math_prop_x_a_PI2 :
 forall (a l : R) (T : TimeT),
 (MinBeta <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l)%R ->
 (r_V * sin (rho_V * T) - l * cos MinBeta <=
  r_V * sin (rho_V * T) - l * cos a)%R.

Lemma Math_prop_approx_x_a_PI2 :
 forall (a l1 l2 : R) (T : TimeT),
 (0 <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l1)%R ->
 (l1 <= l2)%R ->
 (r_lb V * sin_lb (rho_lb V * MinT) - l2 * cos_ub a <=
  r_V * sin (rho_V * T) - l1 * cos a)%R.

Lemma Math_prop_no_conflict_2 :
 forall (a l x y : R) (T : TimeT),
 (MinDistance T <= l)%R ->
 (l <= MaxDistance T)%R ->
 (3 * (PI / 2) <= a)%R ->
 (a <= 2 * PI - MinBeta)%R ->
 (y <= l * sin a - r_V * (cos (rho_V * T) - 1))%R ->
 (r_V * sin (rho_V * T) - l * cos a <= x)%R ->
 (Rsqr ConflictRange < Rsqr x + Rsqr y)%R.

Lemma Math_prop_alarm_2 :
 forall (a l : R) (T : TimeT),
 (MinDistance T <= l)%R ->
 (l <= MaxDistance T)%R ->
 (2 * PI - MinBeta <= a)%R ->
 (a <= 2 * PI)%R ->
 (Rsqr (l * cos a - v V * T) + Rsqr (l * sin a) <= Rsqr AlertRange)%R. *)
Require Import tau.
(* tau:
Require Import Reals.
Require Import ails_def.
Require Import trajectory_const.

Unset Standard Proposition Elimination Names.

Definition dx (intruder evader : State) (t : R) : R :=
  (xt intruder + t * intruderSpeed * cosd (heading intruder) -
   (xt evader + t * evaderSpeed))%R.
Definition dy (intruder evader : State) (t : R) : R :=
  (yt intruder + t * intruderSpeed * sind (heading intruder) - yt evader)%R.
Definition dxdt (intruder : State) : R :=
  (intruderSpeed * cosd (heading intruder) - evaderSpeed)%R.
Definition dydt (intruder : State) : R :=
  (intruderSpeed * sind (heading intruder))%R.
Definition RR (intruder evader : State) (t : R) : R :=
  sqrt (Rsqr (dx intruder evader t) + Rsqr (dy intruder evader t)).
Definition div_tau (intruder evader : State) : R :=
  (Rsqr (dxdt intruder) + Rsqr (dydt intruder))%R.

Lemma Req_EM_var : forall r1 r2 : R, {r1 = r2} + {r1 <> r2}. 

Definition tau (intruder evader : State) (t : R) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dx intruder evader t * dxdt intruder +
        dy intruder evader t * dydt intruder) / div_tau intruder evader)%R
  end.  
Definition tmin (intruder evader : State) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dxdt intruder * (xt intruder - xt evader) +
        dydt intruder * (yt intruder - yt evader)) / 
       div_tau intruder evader)%R
  end.

Lemma tau_tmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader t = (tmin intruder evader - t)%R.

Definition Ax2_R (intruder : State) : R :=
  (Rsqr (sind (heading intruder) * intruderSpeed) +
   Rsqr (- evaderSpeed + cosd (heading intruder) * intruderSpeed))%R.

Lemma Ax2_R_pos : forall intruder : State, (0 <= Ax2_R intruder)%R.

Definition Bx_R (intruder evader : State) : R :=
  (-2 * (yt evader * sind (heading intruder) * intruderSpeed) +
   2 * (yt intruder * sind (heading intruder) * intruderSpeed) -
   2 * (cosd (heading intruder) * xt evader * intruderSpeed) +
   2 * (cosd (heading intruder) * xt intruder * intruderSpeed) +
   2 * (xt evader * evaderSpeed) - 2 * (xt intruder * evaderSpeed))%R.

Definition C_R (intruder evader : State) : R :=
  (Rsqr (yt intruder - yt evader) + Rsqr (xt intruder - xt evader))%R.

Lemma Rsqr_R :
 forall (intruder evader : State) (t : R),
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr t + Bx_R intruder evader * t + C_R intruder evader)%R.

Definition Rsqr_Rmin (intruder evader : State) : R :=
  match Req_EM_var (Ax2_R intruder) 0 with
  | left _ => 0%R
  | right _ =>
      ((4 * Ax2_R intruder * C_R intruder evader -
        Rsqr (Bx_R intruder evader)) / (4 * Ax2_R intruder))%R
  end.

Lemma tmin_0 :
 forall intruder evader : State,
 div_tau intruder evader <> 0%R ->
 tmin intruder evader = (- Bx_R intruder evader / (2 * Ax2_R intruder))%R.

Lemma Ax2_R_0_div_tau :
 forall intruder evader : State,
 div_tau intruder evader = 0%R -> Ax2_R intruder = 0%R.

Lemma div_tau_0_Ax2_R :
 forall intruder evader : State,
 Ax2_R intruder = 0%R -> div_tau intruder evader = 0%R.

Lemma R_Rmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr (t - tmin intruder evader) +
  Rsqr_Rmin intruder evader)%R.

Lemma dx_dxdt :
 forall (intruder evader : State) (t : R),
 (xt intruder - xt evader + t * dxdt intruder)%R = dx intruder evader t.

Lemma dy_dydt :
 forall (intruder evader : State) (t : R),
 (yt intruder - yt evader + t * dydt intruder)%R = dy intruder evader t.

Lemma R_equal_when_zero :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader = 0%R ->
 RR intruder evader t1 = RR intruder evader t2.

Lemma RR_pos :
 forall (intruder evader : State) (t : R), (0 <= RR intruder evader t)%R.

Lemma derivative_eq_zero_tmin :
 forall (intruder evader : State) (t : R),
 (RR intruder evader (tmin intruder evader) <= RR intruder evader t)%R.

Lemma derivative_eq_zero_min :
 forall (intruder evader : State) (t1 t2 : R),
 (RR intruder evader (t1 + tau intruder evader t1) <=
  RR intruder evader (t1 + t2))%R.

Lemma asymptotic_decrease_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (t2 <= tmin intruder evader)%R ->
 (t1 <= t2)%R -> (RR intruder evader t2 <= RR intruder evader t1)%R.

Lemma asymptotic_decrease_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (t2 <= tau intruder evader t)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t2) <= RR intruder evader (t + t1))%R.

Lemma asymptotic_increase_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (tmin intruder evader <= t1)%R ->
 (t1 <= t2)%R -> (RR intruder evader t1 <= RR intruder evader t2)%R.

Lemma asymptotic_increase_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (tau intruder evader t <= t1)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t1) <= RR intruder evader (t + t2))%R.

Lemma tau_equal_when_zero :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader = 0%R -> tau intruder evader t = 0%R.

Lemma asymptotic_tau_gt :
 forall (intruder evader : State) (t dt : R),
 (0 <= dt)%R ->
 (RR intruder evader (t + dt) < RR intruder evader t)%R ->
 (0 < tau intruder evader t)%R.

Lemma tau_is_uniform :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader (t1 + t2) = (tau intruder evader t1 - t2)%R.

Lemma tau_gt_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t < tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t < tau intruder evader t1)%R.

Lemma tau_ge_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t <= tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t <= tau intruder evader t1)%R. *)
Require Import ails.
(* ails:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.
Require Import ails_def.
Require Import tau.
Require Import Omega.

Unset Standard Proposition Elimination Names.

Fixpoint rest (p r s n : nat) {struct n} : nat :=
  match n with
  | O => r
  | S n' =>
      match s with
      | O => 0
      | S O => rest p 0 p n'
      | S s' => rest p (S r) s' n'
      end
  end.
  
Definition mod_ (m n : nat) : nat := rest n 0 n m.

Lemma mod_eq_0 : forall m : nat, mod_ 0 m = 0.

Definition trkrate (phi : Bank) : R :=
  toDeg (g * (tand phi / v intruderSpeed)).

Lemma cond1_0 : (- toDeg MaxBank <= 0)%R.

Lemma cond2_0 : (0 <= toDeg MaxBank)%R.

Lemma trkrate0 : trkrate (mkBank 0 cond1_0 cond2_0) = 0%R.

Definition distance (s1 s2 : State) : R :=
  sqrt (Rsqr (xt s2 - xt s1) + Rsqr (yt s2 - yt s1)).

Lemma distance_sym : forall s1 s2 : State, distance s1 s2 = distance s2 s1.

Definition alerting_distance (s1 s2 : State) : Prop :=
  (distance s1 s2 <= AlertRange)%R.

Definition conflict_distance (s1 s2 : State) : Prop :=
  (distance s1 s2 <= ConflictRange)%R.

Definition chkrange (range tpred : R) : Prop :=
  (range <= AlertRange)%R /\ (tpred <= AlertTime)%R.

Definition chktrack (intruder evader : State) (tpred : R) : Prop :=
  let tau := tau intruder evader 0 in
  match Rle_dec tau 0 with
  | left _ => chkrange (RR intruder evader 0) tpred
  | right _ =>
      match Rlt_dec AlertTime (tpred + tau) with
      | left _ => (RR intruder evader AlertTime <= AlertRange)%R
      | right _ => (RR intruder evader tau <= AlertRange)%R
      end
  end.

Definition arc_loop (intruder evader : State) (arcrad trkrate : R)
  (idtrk iarc : nat) : Prop :=
  match iarc with
  | S p => False
  | O =>
      let tpred := (INR iarc * tstep)%R in
      let xloc := (xt evader + v evaderSpeed * tpred)%R in
      let yloc := yt evader in
      let xtrk :=
        match Rlt_le_dec 0 trkrate with
        | left _ =>
            (xt intruder +
             arcrad *
             (sind (heading intruder + trkrate * tpred) -
              sind (heading intruder)))%R
        | right _ =>
            (xt intruder +
             arcrad *
             (sind (heading intruder) - sind (heading intruder) +
              trkrate * tpred))%R
        end in
      let ytrk :=
        match Rlt_le_dec 0 trkrate with
        | left _ =>
            (yt intruder +
             arcrad *
             (cosd (heading intruder) -
              cosd (heading intruder + trkrate * tpred)))%R
        | right _ =>
            (yt intruder +
             arcrad *
             (cosd (heading intruder + trkrate * tpred) -
              cosd (heading intruder)))%R
        end in
      match mod_ iarc idtrk with
      | O =>
          let tantrk := (heading intruder + tpred * trkrate)%R in
          let int := mkState xtrk ytrk tantrk (bank intruder) in
          let eva := mkState xloc yloc (heading evader) (bank evader) in
          chktrack int eva tpred
      | _ =>
          let range := sqrt (Rsqr (xtrk - xloc) + Rsqr (ytrk - yloc)) in
          chkrange range tpred
      end
  end.

Definition ails_alert (intruder evader : State) : Prop :=
  let phi := bank intruder in
  let trkrate := trkrate phi in
  match Req_EM_var trkrate 0 with
  | left _ => chktrack intruder evader 0
  | right _ =>
      let arcrad := (Rsqr (v intruderSpeed) / (g * tand (r phi)))%R in
      let idtrk :=
        match Rle_dec 3 trkrate with
        | left _ => 1
        | right _ =>
            match Rle_dec (3 / 2) trkrate with
            | left _ => 2
            | right _ =>
                match Rle_dec (3 / 4) trkrate with
                | left _ => 4
                | right _ => 8
                end
            end
        end in
      arc_loop intruder evader arcrad trkrate idtrk 0
  end.

Lemma R_distance :
 forall intruder evader : State,
 RR intruder evader 0 = distance intruder evader.

Lemma step1 :
 forall evader intruder : State,
 alerting_distance evader intruder -> chktrack intruder evader 0.

Lemma step2 :
 forall (evader intruder : State) (x : nat),
 (distance evader intruder <= AlertRange)%R ->
 trkrate (bank intruder) <> 0%R ->
 arc_loop intruder evader (Rsqr intruderSpeed / (g * tand (bank intruder)))
   (trkrate (bank intruder)) x 0.

Theorem alarm_at_alerting_distance :
 forall evader intruder : State,
 alerting_distance evader intruder -> ails_alert intruder evader. *)
Require Import trajectory.
(* trajectory:
Section trajectory.

Require Import Bool.
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.
Require Import constants.
Require Import ycngftys.
Require Import ycngstys.
Require Import Omega.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.
Variable T : TimeT.

Lemma thetat_derivable : derivable (thetat intr).

Definition xe : R := x (tr evad) T.
Definition ye : R := y (tr evad) T.
Definition ve : R := v (h (tr evad)).
Definition r_vi : R := r (vi intr).
Definition rho_vi : R := rho (vi intr).
Definition Die (ti te : R) : R :=
  sqrt
    (Rsqr (xi intr ti - x (tr evad) te) + Rsqr (yi intr ti - y (tr evad) te)).
Definition conflict (t : R) : bool :=
  match Rle_dec (Die t t) ConflictRange with
  | left _ => true
  | right _ => false
  end.

Lemma Dx :
 forall t : R,
 derive_pt (xi intr) t (xi_derivable intr t) =
 (vi intr * cos (thetat intr t))%R.

Lemma Dy :
 forall t : R,
 derive_pt (yi intr) t (yi_derivable intr t) =
 (vi intr * sin (thetat intr t))%R.

Axiom r_sin_rho : (ConflictRange < r_vi * sin rho_vi)%R.

Definition l : R := Die 0 T.
Definition d : R := Die 0 0.

Axiom
  beta_exists :
    { beta : R |
       xe = (l * cos beta + xi intr 0)%R /\
       ye = (yi intr 0 - l * sin beta)%R /\
       (0 <= beta + thetat intr 0 < 2 * PI)%R }.

Definition beta := let (a,_) := beta_exists in a.

Lemma beta_def :
 xe = (l * cos beta + xi intr 0)%R /\
 ye = (yi intr 0 - l * sin beta)%R /\ (0 <= beta + thetat intr 0 < 2 * PI)%R.

Definition Omega (a : R) : bool :=
  match Rle_dec (PI / 2) a with
  | left _ =>
      match Rle_dec a (3 * (PI / 2)) with
      | left _ => true
      | right _ => false
      end
  | right _ => false
  end.

Lemma xe_0 : xe = (l * cos beta + xi intr 0)%R.

Lemma ye_0 : ye = (yi intr 0 - l * sin beta)%R.

Lemma d_l_beta :
 Rsqr d = (Rsqr (ve * T) + Rsqr l - 2 * ve * T * l * cos beta)%R.

Definition yp (t : R) : R :=
  (- sin (thetat intr 0) * (xi intr t - xe) +
   cos (thetat intr 0) * (yi intr t - ye))%R.

Hint Resolve xi_derivable yi_derivable: diff.

Lemma yp_derivable : derivable yp.
Hint Resolve yp_derivable: diff.

Definition xp (t : R) : R :=
  (cos (thetat intr 0) * (xi intr t - xe) +
   sin (thetat intr 0) * (yi intr t - ye))%R.

Lemma xp_derivable : derivable xp.
Hint Resolve xp_derivable: diff.

Definition Rsqr_evader_distance (t : R) : R :=
  (Rsqr (xi intr t - xe) + Rsqr (yi intr t - ye))%R.

Lemma Rsqr_evader_distance_derivable : derivable Rsqr_evader_distance.
Hint Resolve Rsqr_evader_distance_derivable: diff.

Definition Rsqr_intruder_distance (t : R) : R :=
  (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0))%R.

Lemma Rsqr_intruder_distance_derivable : derivable Rsqr_intruder_distance.
Hint Resolve Rsqr_intruder_distance_derivable: diff.

Lemma Rsqr_evader_distance_pos :
 forall t : R, (0 <= Rsqr_evader_distance t)%R.

Lemma Rsqr_intruder_distance_pos :
 forall t : R, (0 <= Rsqr_intruder_distance t)%R.

Definition e (t : R) : R := sqrt (Rsqr_evader_distance t).
Definition i (t : R) : R := sqrt (Rsqr_intruder_distance t).

Lemma conflict_T_e_0 : conflict T = true -> (e T <= ConflictRange)%R. 

Lemma conflict_T_e_1 : (e T <= ConflictRange)%R -> conflict T = true.

Lemma L : Rsqr l = (Rsqr (xe - xi intr 0) + Rsqr (ye - yi intr 0))%R.

Lemma L_intruder : forall t : R, (l <= e t + i t)%R.

Lemma l_is_pos : (0 <= l)%R.

Lemma L_e : forall t : R, (e t <= l + i t)%R.

Lemma L_i : forall t : R, (i t <= l + e t)%R.

Lemma theta_inv :
 forall t : R,
 (0 <= t)%R ->
 (thetat intr 0 - rho_vi * t <= thetat intr t)%R /\
 (thetat intr t <= thetat intr 0 + rho_vi * t)%R.

Lemma rho_t_pos : forall t : R, (0 <= t)%R -> (0 <= rho_vi * t)%R.

Lemma rho_t_le :
 forall t1 t2 : R, (t1 <= t2)%R -> (rho_vi * t1 <= rho_vi * t2)%R.

Lemma Dyp :
 forall t : R,
 derive_pt yp t (yp_derivable t) =
 (v (vi intr) * sin (thetat intr t - thetat intr 0))%R.

Lemma Dyp0_PI2 :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI / 2)%R ->
 (- (vi intr * sin (rho_vi * t)) <= derive_pt yp t (yp_derivable t) <=
  vi intr * sin (rho_vi * t))%R.

Lemma yp0 : yp 0 = (l * sin (thetat intr 0 + beta))%R.

Definition hy (t : R) : R := (r_vi * cos (rho_vi * t))%R.

Lemma hy_derivable : derivable hy.

Lemma Dhy :
 forall t : R,
 derive_pt hy t (hy_derivable t) = (- vi intr * sin (rho_vi * t))%R.

Lemma ypt :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI / 2)%R -> (hy t - hy 0 <= yp t - yp 0 <= hy 0 - hy t)%R.

Lemma ypt_PI2 :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI / 2)%R ->
 (l * sin (beta + thetat intr 0) + r_vi * (cos (rho_vi * t) - 1) <= yp t)%R /\
 (yp t <= l * sin (beta + thetat intr 0) - r_vi * (cos (rho_vi * t) - 1))%R.

Lemma Dxp :
 forall t : R,
 derive_pt xp t (xp_derivable t) =
 (vi intr * cos (thetat intr t - thetat intr 0))%R.

Lemma Dx0_PI :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R ->
 (vi intr * cos (rho_vi * t) <= derive_pt xp t (xp_derivable t))%R.

Lemma xp0 : xp 0 = (- l * cos (thetat intr 0 + beta))%R.

Definition hx (t : R) : R := (r_vi * sin (rho_vi * t))%R.

Lemma hx_derivable : derivable hx.

Lemma Dhx :
 forall t : R,
 derive_pt hx t (hx_derivable t) = (vi intr * cos (rho_vi * t))%R.

Lemma xpt :
 forall t : R, (0 <= t)%R -> (rho_vi * t <= PI)%R -> (hx t <= xp t - xp 0)%R.

Lemma r_sin_pos :
 forall t : R,
 (0 <= t)%R -> (rho_vi * t <= PI)%R -> (0 <= r_vi * sin (rho_vi * t))%R.

Lemma xpt_pos :
 forall t : R, (0 <= t)%R -> (rho_vi * t <= PI)%R -> (0 <= xp t - xp 0)%R.

Lemma xpt_PI :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R ->
 (r_vi * sin (rho_vi * t) - l * cos (beta + thetat intr 0) <= xp t)%R.

Lemma Omega_defeq :
 forall x : R, Omega x = true -> (PI / 2 <= x <= 3 * (PI / 2))%R.

Lemma neg_cos_var : forall x : R, cos (x - PI) = (- cos x)%R.

Lemma xp0_pos : Omega (beta + thetat intr 0) = true -> (0 <= xp 0)%R.

Lemma xpt_Omega :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R ->
 Omega (beta + thetat intr 0) = true -> (r_vi * sin (rho_vi * t) <= xp t)%R.

Lemma isometric_evader :
 forall t : R, Rsqr_evader_distance t = (Rsqr (xp t) + Rsqr (yp t))%R.

Lemma xpt_xp0 :
 forall t : R,
 (xp t - xp 0)%R =
 (cos (thetat intr 0) * (xi intr t - xi intr 0) +
  sin (thetat intr 0) * (yi intr t - yi intr 0))%R.

Lemma ypt_yp0 :
 forall t : R,
 (yp t - yp 0)%R =
 (- sin (thetat intr 0) * (xi intr t - xi intr 0) +
  cos (thetat intr 0) * (yi intr t - yi intr 0))%R.

Lemma isometric_intruder :
 forall t : R,
 Rsqr_intruder_distance t = (Rsqr (xp t - xp 0) + Rsqr (yp t - yp 0))%R.

Lemma majoration :
 forall t : R,
 (Rsqr (yp t) <= Rsqr_evader_distance t)%R /\
 (Rsqr (xp t) <= Rsqr_evader_distance t)%R.

Lemma YCNGFTYS_evader :
 forall t : R, (0 <= t)%R -> (l - v (vi intr) * t <= e t)%R.

Lemma YCNGSTYS_evader :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t < 2)%R -> (2 * r_vi * sin (rho_vi * (t / 2)) - l <= e t)%R.

Lemma xp_pos :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R -> Omega (beta + thetat intr 0) = true -> (0 <= xp t)%R.

Lemma no_conflict_xp_1_Omega :
 forall t : R,
 (1 <= t)%R ->
 (rho_vi * t <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true -> (ConflictRange < xp t)%R.

Lemma no_conflict_scenario_1_Omega :
 forall t : R,
 (1 <= t)%R ->
 (rho_vi * t <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true ->
 (Rsqr ConflictRange < Rsqr_evader_distance t)%R.

Lemma no_conflict_scenario_0_1s :
 forall t : R,
 (0 <= t)%R ->
 (t < 1)%R -> (ConflictRange + vi intr < l)%R -> (ConflictRange < e t)%R.

Lemma no_conflict_gt_max_t :
 forall t : R,
 let MaxDistance := (vi intr * t + ConflictRange)%R in
 (0 <= t)%R -> (MaxDistance < l)%R -> (ConflictRange < e t)%R.

Lemma no_conflict_lt_min_t :
 forall t : R,
 let MinDistance := (2 * r_vi * sin (rho_vi * (t / 2)) - ConflictRange)%R in
 (0 <= t)%R ->
 (0 <= rho_vi * t)%R ->
 (rho_vi * t < 2)%R -> (l < MinDistance)%R -> (ConflictRange < e t)%R.

Lemma no_conflict_Omega_t :
 forall t : R,
 (ConflictRange + vi intr < l)%R ->
 (0 <= t)%R ->
 (rho_vi * t <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true -> (ConflictRange < e t)%R.

Theorem no_conflict_gt_max :
 let MaxDistance := (vi intr * T + ConflictRange)%R in
 (MaxDistance < l)%R -> conflict T = false.

Theorem no_conflict_lt_min :
 let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in
 (0 <= rho_vi * T)%R ->
 (rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false.

Theorem no_conflict_Omega :
 (ConflictRange + v (vi intr) < l)%R ->
 (rho_vi * T <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true -> conflict T = false.

End trajectory. *)
Require Import measure2state.
(* measure2state:
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ails_def.
Require Import Omega.

Lemma cond1_sty :
 forall (tr : Trajectory) (t : R), (- toDeg MaxBank <= toDeg (phi tr t))%R.

Lemma cond2_sty :
 forall (tr : Trajectory) (t : R), (toDeg (phi tr t) <= toDeg MaxBank)%R.

Definition measure2state (tr : Trajectory) (t : R) : State :=
  mkState (x tr t) (y tr t) (toDeg (theta tr t))
    (mkBank (toDeg (phi tr t)) (cond1_sty tr t) (cond2_sty tr t)). *)
Require Import ails_trajectory.
(* ails_trajectory:
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ycngftys.
Require Import ycngstys.
Require Import tau.
Require Import ails.
Require Import trajectory.
Require Import measure2state.

Lemma d_distance :
 forall (intr : Trajectory) (evad : EvaderTrajectory),
 distance (measure2state (tr evad) 0) (measure2state intr 0) = d intr evad.

Lemma R_T :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h (tr evad) = V ->
 Rsqr (RR (measure2state intr 0) (measure2state (tr evad) 0) T) =
 (Rsqr (l intr evad T * cos (beta intr evad T + thetat intr 0) - V * T) +
  Rsqr (l intr evad T * sin (beta intr evad T + thetat intr 0)))%R. *)

Unset Standard Proposition Elimination Names.

Lemma AlertRange_pos : (0 < AlertRange)%R.
unfold AlertRange in |- *; prove_sup.
Qed.

Lemma conflict_beta_theta :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (beta intr evad T + thetat intr 0 <= MinBeta)%R \/
 (2 * PI - MinBeta < beta intr evad T + thetat intr 0)%R.
Proof with trivial.
intros intr evad T hyp_intr; intros; set (beta_p := beta intr evad T) in H1;
 set (thetat_p := thetat intr) in H1; set (l_p := l intr evad T) in H, H0;
 set (conflict_p := conflict intr evad) in H2;
assert (hyp1 : r_V = r_vi intr)...
unfold r_V, r_vi in |- *; unfold vi in |- *; rewrite hyp_intr...
assert (hyp2 : rho_V = rho_vi intr)...
unfold rho_V, rho_vi in |- *; unfold vi in |- *; rewrite hyp_intr...
case (Rtotal_order (beta_p + thetat_p 0%R) MinBeta); intro...
left; left...
elim H3; intro...
left; right...
case (Rlt_le_dec (2 * PI - MinBeta) (beta_p + thetat_p 0%R)); intro...
right...
assert (H5 := conflict_T_e_0 intr evad T H2)...
cut (0 <= e intr evad T T)%R...
cut (0 <= ConflictRange)%R...
intros; assert (H8 := Rsqr_incr_1 (e intr evad T T) ConflictRange H5 H7 H6);
 unfold e in H8; rewrite isometric_evader in H8; rewrite Rsqr_sqrt in H8...
change (MinBeta < beta_p + thetat_p 0)%R in H4;
 cut
  ((beta_p + thetat_p 0 < PI / 2)%R \/ (3 * (PI / 2) < beta_p + thetat_p 0)%R)...
intro; elim H9; intro...
cut
 (l_p * sin (beta_p + thetat_p 0) + r_V * (cos (rho_V * T) - 1) <=
  yp intr evad T T)%R...
cut
 (r_V * sin (rho_V * T) - l_p * cos (beta_p + thetat_p 0) <= xp intr evad T T)%R...
intros;
 generalize
  (Math_prop_no_conflict_1 (beta_p + thetat_p 0%R) l_p 
     (xp intr evad T T) (yp intr evad T T) T H H0
     (Rlt_le MinBeta (beta_p + thetat_p 0%R) H4)
     (Rlt_le (beta_p + thetat_p 0%R) (PI / 2) H10) H12 H11); 
 intro;
 generalize
  (Rlt_le_trans (Rsqr ConflictRange)
     (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T)) 
     (Rsqr ConflictRange) H13 H8); intro;
 elim (Rlt_irrefl (Rsqr ConflictRange) H14)...
rewrite hyp1; rewrite hyp2...
apply (xpt_PI intr evad T)...
left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...
rewrite <- hyp2; left; apply Rlt_trans with (PI / 2)%R...
apply rho_t_PI2...
apply PI2_Rlt_PI...
rewrite hyp1; rewrite hyp2; cut (0 <= T)%R...
cut (rho_vi intr * T <= PI / 2)%R...
intros; generalize (ypt_PI2 intr evad T T H12 H11); intro...
elim H13; intros...
rewrite <- hyp2; left; apply rho_t_PI2...
left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...
cut
 (yp intr evad T T <=
  l_p * sin (beta_p + thetat_p 0) - r_V * (cos (rho_V * T) - 1))%R...
cut
 (r_V * sin (rho_V * T) - l_p * cos (beta_p + thetat_p 0) <= xp intr evad T T)%R...
intros;
 generalize
  (Math_prop_no_conflict_2 (beta_p + thetat_p 0%R) l_p 
     (xp intr evad T T) (yp intr evad T T) T H H0
     (Rlt_le (3 * (PI / 2)) (beta_p + thetat_p 0%R) H10) r H12 H11); 
 intro...
elim
 (Rlt_irrefl (Rsqr ConflictRange)
    (Rlt_le_trans (Rsqr ConflictRange)
       (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T))
       (Rsqr ConflictRange) H13 H8))...
rewrite hyp1; rewrite hyp2; apply (xpt_PI intr evad T)...
left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...
rewrite <- hyp2; left; apply Rlt_trans with (PI / 2)%R...
apply rho_t_PI2...
apply PI2_Rlt_PI...
rewrite hyp1; rewrite hyp2; cut (0 <= T)%R...
cut (rho_vi intr * T <= PI / 2)%R...
intros; generalize (ypt_PI2 intr evad T T H12 H11); intro; elim H13; intros...
rewrite <- hyp2; left; apply rho_t_PI2...
left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...
cut (Omega (beta_p + thetat_p 0%R) = false)...
unfold Omega in |- *; case (Rle_dec (PI / 2) (beta_p + thetat_p 0%R)); intro...
case (Rle_dec (beta_p + thetat_p 0%R) (3 * (PI / 2))); intros...
elim diff_true_false...
right; auto with real...
intro; left; auto with real...
apply Rplus_le_le_0_compat; apply Rle_0_sqr...
unfold ConflictRange in |- *; left; prove_sup...
unfold e in |- *; apply sqrt_positivity; apply Rsqr_evader_distance_pos...
Qed.

Lemma alarm_NOT_Omega_T :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (RR (measure2state intr 0) (measure2state (tr evad) 0) T <= AlertRange)%R.
Proof with trivial.
intros intr evad T hyp_intr hyp_evad; intros; apply Rsqr_incr_0_var...
rewrite R_T...
generalize (conflict_beta_theta intr evad T hyp_intr H H0 H1 H2); intro;
 elim H3; intro...
cut (0 <= beta intr evad T + thetat intr 0)%R...
intro;
 apply
  (Math_prop_alarm_1 (beta intr evad T + thetat intr 0) 
     (l intr evad T) T H H0 H5 H4)...
generalize (beta_def intr evad T); intro; decompose [and] H5; intros...
cut (beta intr evad T + thetat intr 0 <= 2 * PI)%R...
intro;
 apply
  (Math_prop_alarm_2 (beta intr evad T + thetat intr 0) 
     (l intr evad T) T H H0
     (Rlt_le (2 * PI - MinBeta) (beta intr evad T + thetat intr 0) H4))...
generalize (beta_def intr evad T); intro; decompose [and] H5; intros; left...

left; apply AlertRange_pos...
Qed.

Lemma alarm_NOT_Omega_tau :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 (RR (measure2state intr 0) (measure2state (tr evad) 0)
    (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) <= AlertRange)%R.
Proof with trivial.
intros intr evad T hyp_intr hyp_evad; intros;
 apply
  Rle_trans with (RR (measure2state intr 0) (measure2state (tr evad) 0) T)...
generalize
 (derivative_eq_zero_min (measure2state intr 0) (measure2state (tr evad) 0) 0
    T); repeat rewrite Rplus_0_l; intro...
apply (alarm_NOT_Omega_T intr evad T hyp_intr hyp_evad H H0 H1 H2)...
Qed.

Lemma alarm_NOT_Omega_AlertTime :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (AlertTime < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 (RR (measure2state intr 0) (measure2state (tr evad) 0) AlertTime <=
  AlertRange)%R.
Proof with trivial.
intros intr evad T hyp_intr hyp_evad; intros;
 apply
  Rle_trans with (RR (measure2state intr 0) (measure2state (tr evad) 0) T)...
rewrite <- (Rplus_0_l AlertTime); rewrite <- (Rplus_0_l T);
 apply asymptotic_decrease_tau...
left...
unfold AlertTime in |- *; apply Rle_trans with MaxT...
apply (cond_2 T)...
unfold MaxT in |- *; left; prove_sup...
apply (alarm_NOT_Omega_T _ _ _ hyp_intr hyp_evad H H0 H1 H2)...
Qed.

Lemma chktrack_NOT_Omega_trkrate_eq_0 :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 chktrack (measure2state intr 0) (measure2state (tr evad) 0) 0.
Proof with trivial.
intros intr evad T hyp_intr hyp_evad; intros; unfold chktrack in |- *;
 case (Rle_dec (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) 0);
 intro...
elim
 (Rlt_irrefl 0
    (Rlt_le_trans 0
       (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) 0 H3 r))...
rewrite Rplus_0_l;
 case
  (Rlt_dec AlertTime
     (tau (measure2state intr 0) (measure2state (tr evad) 0) 0)); 
 intro...
apply (alarm_NOT_Omega_AlertTime intr evad T)...
apply (alarm_NOT_Omega_tau intr evad T)...
Qed.

Theorem ails_alarm_tau_gt0 :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 conflict intr evad T = true ->
 ails_alert (measure2state intr 0) (measure2state (tr evad) 0).
Proof with trivial.
intros intr evad T hyp_intr hyp_evad; intros; unfold ails_alert in |- *;
 case (Req_EM_var (trkrate (bank (measure2state intr 0))) 0); 
 intro...
apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
case (Rle_dec 3 (trkrate (bank (measure2state intr 0)))); intro...
unfold arc_loop in |- *; rewrite mod_eq_0...
case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); intro...
unfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;
 repeat rewrite Rplus_0_r; unfold intruderSpeed in |- *;
 replace (v V) with 250%R...
cut
 (let z := 250%R in
  mkState
    (xt (measure2state intr 0) +
     Rsqr z / (g * tand (bank (measure2state intr 0))) *
     (sind (heading (measure2state intr 0)) -
      sind (heading (measure2state intr 0))))
    (yt (measure2state intr 0) +
     Rsqr z / (g * tand (bank (measure2state intr 0))) *
     (cosd (heading (measure2state intr 0)) -
      cosd (heading (measure2state intr 0))))
    (heading (measure2state intr 0)) (bank (measure2state intr 0)) =
  measure2state intr 0)...
intro; rewrite H4...
cut
 (mkState (xt (measure2state (tr evad) 0)) (yt (measure2state (tr evad) 0))
    (heading (measure2state (tr evad) 0)) (bank (measure2state (tr evad) 0)) =
  measure2state (tr evad) 0)...
intro; rewrite H5...
apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
unfold Rminus in |- *; repeat rewrite Rplus_opp_r; repeat rewrite Rmult_0_r;
 repeat rewrite Rplus_0_r...
unfold INR in |- *; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;
 repeat rewrite Rplus_0_r; unfold Rminus in |- *; repeat rewrite Rplus_opp_r;
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
case (Rle_dec (3 / 2) (trkrate (bank (measure2state intr 0)))); intro...
unfold arc_loop in |- *; rewrite mod_eq_0;
 case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); 
 intro...
repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
case (Rle_dec (3 / 4) (trkrate (bank (measure2state intr 0)))); intro...
unfold arc_loop in |- *; rewrite mod_eq_0;
 case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); 
 intro...
repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
unfold arc_loop in |- *; rewrite mod_eq_0;
 case (Rlt_le_dec 0 (trkrate (bank (measure2state intr 0)))); 
 intro...
repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 
 unfold Rdiv in |- *; repeat rewrite Rmult_0_r; repeat rewrite Rplus_0_r;
 apply (chktrack_NOT_Omega_trkrate_eq_0 intr evad T)...
Qed.
