

Require Import Reals.

Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)

Require Import trajectory_def.
(* trajectory_def:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.

Record Trajectory : Type := mkTrajectory
  {x : Differential;
   y : Differential;
   theta : Differential;
   phi : Differential;
   h : TypeSpeed;
   cond_x :
    forall t : R, derive_pt x t (cond_diff x t) = (h * cos (theta t))%R;
   cond_y :
    forall t : R, derive_pt y t (cond_diff y t) = (h * sin (theta t))%R;
   cond_phi : forall t : R, (- MaxBank <= phi t <= MaxBank)%R;
   cond_theta :
    forall t : R,
    derive_pt theta t (cond_diff theta t) = (g * (tan (phi t) / h))%R}.

Record EvaderTrajectory : Type := mkEvaderTrajectory
  {tr : Trajectory;
   tr_cond1 : forall t : R, x tr t = (x tr 0 + h tr * t)%R;
   tr_cond2 : forall t : R, y tr t = y tr 0%R;
   tr_cond3 : forall t : R, theta tr t = 0%R;
   tr_cond4 : forall t : R, phi tr t = 0%R}.

Lemma init_tr_derivable_x :
 forall h : TypeSpeed, derivable (fun t : R => (h * t)%R).

Lemma init_tr_derivable_y :
 forall h : TypeSpeed, derivable (fun t : R => 0%R).

Lemma init_tr_cond_x :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => (h * t)%R) t (init_tr_derivable_x h t) =
 (h * cos ((fun t : R => 0) t))%R.

Lemma init_tr_cond_y :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (h * sin ((fun t : R => 0) t))%R.

Lemma init_tr_cond_phi :
 forall t : R,
 (- MaxBank <= (fun t : R => 0) t)%R /\ ((fun t : R => 0) t <= MaxBank)%R.

Lemma fct_der1 : forall t : R, derivable_pt (fun t : R => 0%R) t.

Lemma init_tr_cond_theta :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (fun t : R => (g * (tan 0 / h))%R) t.

Definition init_tr (h : TypeSpeed) : Trajectory :=
  mkTrajectory
    (mkDifferential (fun t : R => (h * t)%R) (init_tr_derivable_x h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h)) h
    (init_tr_cond_x h) (init_tr_cond_y h) init_tr_cond_phi
    (init_tr_cond_theta h).

Lemma MaxBank_encadr : (0 < MaxBank < PI / 4)%R.

Lemma dtheta_rho :
 forall (tr : Trajectory) (t : R),
 (- rho (h tr) <= derive_pt (theta tr) t (cond_diff (theta tr) t) <=
  rho (h tr))%R. *)

Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)

Require Import ails_def.
(* ails_def:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.

Record Bank : Type := mkBank
  {r :> R; cond1 : (- toDeg MaxBank <= r)%R; cond2 : (r <= toDeg MaxBank)%R}.

Record State : Type := mkState {xt : R; yt : R; heading : R; bank : Bank}.

Definition intruderSpeed : TypeSpeed := V.
Definition evaderSpeed : TypeSpeed := V. *)

Require Import Omega.



Lemma cond1_sty :

 forall (tr : Trajectory) (t : R), (- toDeg MaxBank <= toDeg (phi tr t))%R.

Proof with trivial.

intros; unfold toDeg in |- *; repeat rewrite Rmult_assoc;

 rewrite <- Ropp_mult_distr_l_reverse; rewrite (Rmult_comm (- MaxBank));

 rewrite (Rmult_comm (phi tr t)); apply Rmult_le_compat_l...

left; apply Rmult_lt_0_compat... 

unfold plat in |- *; prove_sup0...

apply Rinv_0_lt_compat; apply PI_RGT_0...

generalize (cond_phi tr); intro H; elim (H t)...

Qed.



Lemma cond2_sty :

 forall (tr : Trajectory) (t : R), (toDeg (phi tr t) <= toDeg MaxBank)%R.

Proof with trivial.

intros; unfold toDeg in |- *; repeat rewrite Rmult_assoc;

 rewrite (Rmult_comm MaxBank); rewrite (Rmult_comm (phi tr t));

 apply Rmult_le_compat_l...

left; apply Rmult_lt_0_compat... 

unfold plat in |- *; prove_sup...

apply Rinv_0_lt_compat; apply PI_RGT_0...

generalize (cond_phi tr); intro H; elim (H t)...

Qed.



Definition measure2state (tr : Trajectory) (t : R) : State :=

  mkState (x tr t) (y tr t) (toDeg (theta tr t))

    (mkBank (toDeg (phi tr t)) (cond1_sty tr t) (cond2_sty tr t)).
