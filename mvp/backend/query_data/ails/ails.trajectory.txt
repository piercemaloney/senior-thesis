

Section trajectory.



Require Import Bool.

Require Import Reals.

Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)

Require Import rrho.
(* rrho:
Require Import Reals.
Require Import trajectory_const.

Definition rho (h : TypeSpeed) : R := (g * (tan MaxBank / h))%R.
Definition r (h : TypeSpeed) : R := (h / rho h)%R.
Definition rho_ub (h : TypeSpeed) : R := (g * (tan_ub_MaxBank / h))%R.
Definition rho_lb (h : TypeSpeed) : R := (g * (tan_lb_MaxBank / h))%R.

Lemma TypeSpeed_pos : forall h : TypeSpeed, (0 < h)%R.

Lemma g_pos : (0 < g)%R.

Lemma rho_ub_0 : forall h : TypeSpeed, (rho h < rho_ub h)%R.

Lemma rho_lb_0 : forall h : TypeSpeed, (rho_lb h < rho h)%R.

Definition r_ub (h : TypeSpeed) : R := (h / rho_lb h)%R.
Definition r_lb (h : TypeSpeed) : R := (h / rho_ub h)%R.

Lemma tan_lb_MaxBank_pos : (0 < tan_lb_MaxBank)%R.

Lemma tan_ub_MaxBank_pos : (0 < tan_ub_MaxBank)%R.

Lemma rho_lb_pos : forall h : TypeSpeed, (0 < rho_lb h)%R.

Lemma rho_pos : forall h : TypeSpeed, (0 < rho h)%R.

Lemma rho_ub_pos : forall h : TypeSpeed, (0 < rho_ub h)%R.

Lemma r_ub_0 : forall h : TypeSpeed, (r h < r_ub h)%R.

Lemma r_lb_0 : forall h : TypeSpeed, (r_lb h < r h)%R.

Lemma rho_PI2 : forall h : TypeSpeed, (rho h <= PI / 2)%R.

Lemma rho_strict_decreasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (rho h2 < rho h1)%R.

Lemma r_stric_increasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (r h1 < r h2)%R. *)

Require Import trajectory_def.
(* trajectory_def:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.

Record Trajectory : Type := mkTrajectory
  {x : Differential;
   y : Differential;
   theta : Differential;
   phi : Differential;
   h : TypeSpeed;
   cond_x :
    forall t : R, derive_pt x t (cond_diff x t) = (h * cos (theta t))%R;
   cond_y :
    forall t : R, derive_pt y t (cond_diff y t) = (h * sin (theta t))%R;
   cond_phi : forall t : R, (- MaxBank <= phi t <= MaxBank)%R;
   cond_theta :
    forall t : R,
    derive_pt theta t (cond_diff theta t) = (g * (tan (phi t) / h))%R}.

Record EvaderTrajectory : Type := mkEvaderTrajectory
  {tr : Trajectory;
   tr_cond1 : forall t : R, x tr t = (x tr 0 + h tr * t)%R;
   tr_cond2 : forall t : R, y tr t = y tr 0%R;
   tr_cond3 : forall t : R, theta tr t = 0%R;
   tr_cond4 : forall t : R, phi tr t = 0%R}.

Lemma init_tr_derivable_x :
 forall h : TypeSpeed, derivable (fun t : R => (h * t)%R).

Lemma init_tr_derivable_y :
 forall h : TypeSpeed, derivable (fun t : R => 0%R).

Lemma init_tr_cond_x :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => (h * t)%R) t (init_tr_derivable_x h t) =
 (h * cos ((fun t : R => 0) t))%R.

Lemma init_tr_cond_y :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (h * sin ((fun t : R => 0) t))%R.

Lemma init_tr_cond_phi :
 forall t : R,
 (- MaxBank <= (fun t : R => 0) t)%R /\ ((fun t : R => 0) t <= MaxBank)%R.

Lemma fct_der1 : forall t : R, derivable_pt (fun t : R => 0%R) t.

Lemma init_tr_cond_theta :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (fun t : R => (g * (tan 0 / h))%R) t.

Definition init_tr (h : TypeSpeed) : Trajectory :=
  mkTrajectory
    (mkDifferential (fun t : R => (h * t)%R) (init_tr_derivable_x h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h)) h
    (init_tr_cond_x h) (init_tr_cond_y h) init_tr_cond_phi
    (init_tr_cond_theta h).

Lemma MaxBank_encadr : (0 < MaxBank < PI / 4)%R.

Lemma dtheta_rho :
 forall (tr : Trajectory) (t : R),
 (- rho (h tr) <= derive_pt (theta tr) t (cond_diff (theta tr) t) <=
  rho (h tr))%R. *)

Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)

Require Import ycngftys.
(* ycngftys:
Section ycngftys.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.
Require Import constants.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition xi : R -> R := x intr.
Definition yi : R -> R := y intr.
Definition vi : TypeSpeed := h intr.
Definition xP (t : R) : R := (xi t - xi 0)%R.
Definition yP (t : R) : R := (yi t - yi 0)%R.
Definition u (eps : posreal) (t : R) : R :=
  sqrt (Rsqr (xP t) + Rsqr (yP t) + Rsqr eps).
Definition u0 (t : R) : R := sqrt (Rsqr (xP t) + Rsqr (yP t)).

Lemma xi_derivable : derivable xi.

Lemma yi_derivable : derivable yi.

Lemma xP_derivable : derivable xP.

Lemma yP_derivable : derivable yP.

Lemma d_u : forall eps : posreal, derivable (fun t : R => u eps t).

Lemma fct_der2 :
 forall (eps : posreal) (t : R), derivable_pt (fun y : R => Rsqr (u eps y)) t.

Lemma D_Rsqr_u_epsilon_1 :
 forall (eps : posreal) (t : R),
 derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) =
 (2 * u eps t * derive_pt (u eps) t (d_u eps t))%R. 

Lemma xP_derive :
 forall t : R,
 derive_pt xP t (xP_derivable t) = derive_pt xi t (xi_derivable t).

Lemma yP_derive :
 forall t : R,
 derive_pt yP t (yP_derivable t) = derive_pt yi t (yi_derivable t).

Lemma fct_der3 :
 forall (eps : posreal) (t : R),
 derivable_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t.

Lemma D_Rsqr_u_epsilon_2 :
 forall (eps : posreal) (t : R),
 (derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) <= 2 * u0 t * vi)%R.

Lemma u_stric_pos : forall (eps : posreal) (t : R), (0 < u eps t)%R.

Lemma u_pos : forall (eps : posreal) (t : R), (0 <= u eps t)%R.

Lemma u0_pos : forall t : R, (0 <= u0 t)%R.

Lemma Rsqr_u_epsilon :
 forall (eps : posreal) (t : R), Rsqr (u eps t) = (Rsqr (u0 t) + Rsqr eps)%R.

Lemma u0_u_epsilon : forall (eps : posreal) (t : R), (u0 t <= u eps t)%R.

Lemma u_epsilon_le_v :
 forall (eps : posreal) (t : R), (derive_pt (u eps) t (d_u eps t) <= vi)%R.

Lemma vit_derivable : derivable (fun t : R => (vi * t)%R).

Lemma derive_vit :
 forall t : R, derive_pt (fun t : R => (vi * t)%R) t (vit_derivable t) = vi.

Lemma u_epsilon_le_vt :
 forall (eps : posreal) (t : R), (0 <= t)%R -> (u eps t - eps <= vi * t)%R.

Lemma Rsqr_u :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + 2 * eps * vi * t)%R.

Lemma Rsqr_u_Rsqr_vt :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + eps)%R.

Theorem YCNGFTYS :
 forall t : R,
 (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.

End ycngftys. *)

Require Import ycngstys.
(* ycngstys:
Section ycngstys.

Require Import Reals.
Require Import trajectory_def.
Require Import trajectory_const.
Require Import constants.
Require Import ycngftys.
Require Import rrho.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition thetat : R -> R := theta intr.
Definition Rs (t : R) : R :=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)).

Axiom
  alphas_exists :
    { f : Differential_D2 |
       forall t : R,
       xi intr t = (Rs t * cos (f t) + xi intr 0)%R /\
       yi intr t = (Rs t * sin (f t) + yi intr 0)%R }.

Definition alphas := let (a,_) := alphas_exists in a.

Lemma alphas_def :
 forall t : R,
 xi intr t = (Rs t * cos (alphas t) + xi intr 0)%R /\
 yi intr t = (Rs t * sin (alphas t) + yi intr 0)%R.

Lemma Rsx : forall t : R, xi intr t = (xi intr 0 + Rs t * cos (alphas t))%R.

Lemma Rsy : forall t : R, yi intr t = (yi intr 0 + Rs t * sin (alphas t))%R.

Lemma Rs_x :
 forall t : R,
 cos (alphas t) <> 0%R -> Rs t = ((xi intr t - xi intr 0) / cos (alphas t))%R.

Lemma Rs_y :
 forall t : R,
 sin (alphas t) <> 0%R -> Rs t = ((yi intr t - yi intr 0) / sin (alphas t))%R.

Lemma Rs_derivable : derivable Rs.

Definition alphas_p : R -> R := d2 alphas.

Lemma fct_der4 :
 forall t : R,
 derivable_pt ((Rs * comp cos alphas_p)%F + fct_cte (xi intr 0)) t.

Lemma Dxi :
 forall t : R,
 derive_pt (xi intr) t (xi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma Dyi :
 forall t : R,
 derive_pt (yi intr) t (yi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma DRs_cos :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * cos (thetat t))%R.

Lemma DRs_sin :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t))%R.

Lemma eq_plus_eq_is_eq :
 forall x y z t : R, x = y -> z = t -> (x + z)%R = (y + t)%R.

Lemma DRs :
 forall t : R,
 derive_pt Rs t (Rs_derivable t) = (vi intr * cos (thetat t - alphas t))%R.

Lemma Rs_alphas :
 forall t : R,
 (Rs t * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t - alphas t))%R.

Lemma fct_der5 :
 forall t : R,
 derivable_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R)
   t.

Lemma D_Rs_alphas1 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (derive_pt Rs t (Rs_derivable t) * derive_pt alphas t (cond_D1 alphas t) +
  Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma thetat_derivable : derivable thetat.

Lemma D_Rs_alphas2 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (vi intr * cos (thetat t - alphas t) *
  (derive_pt thetat t (thetat_derivable t) -
   derive_pt alphas t (cond_D1 alphas t)))%R.

Lemma D_Rs_2 :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) *
  (2 * derive_pt alphas t (cond_D1 alphas t) -
   derive_pt thetat t (thetat_derivable t)))%R =
 (- Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma Rsqr_DRs :
 forall t : R,
 (Rsqr (derive_pt Rs t (Rs_derivable t)) +
  Rsqr (Rs t) * Rsqr (derive_pt alphas t (cond_D1 alphas t)))%R =
 Rsqr (vi intr).

Lemma Rs_pos : forall t : R, (0 <= Rs t)%R.

Lemma Rs_0 : Rs 0 = 0%R.

Lemma D_Rs_0 : (0 <= derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma eq_sym : forall x y : R, x = y -> y = x.

Lemma D_Rs_0_strong : (0 < derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma D_alphas_0 :
 (2 * derive_pt alphas 0 (cond_D1 alphas 0))%R =
 derive_pt thetat 0 (thetat_derivable 0%R).

Lemma D_Rs_pos_non_null :
 forall t : R,
 (0 < t)%R ->
 (forall x : R, (0 < x < t)%R -> (0 < derive_pt Rs x (Rs_derivable x))%R) ->
 (0 < Rs t)%R.

Axiom
  D_Rs_pos :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R -> (0 < derive_pt Rs t (Rs_derivable t))%R.

Axiom
  D_abs_alpha :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R ->
    (- rho (vi intr) / 2 <= derive_pt alphas t (cond_D1 alphas t))%R /\
    (derive_pt alphas t (cond_D1 alphas t) <= rho (vi intr) / 2)%R.

Definition F (t : R) : R :=
  (2 * (vi intr / rho (vi intr)) * sin (rho (vi intr) * (t / 2)))%R.

Lemma F_derivable : derivable F.

Lemma D_F :
 forall t : R,
 derive_pt F t (F_derivable t) = (vi intr * cos (rho (vi intr) * (t / 2)))%R.

Lemma D_F_Rsqr_v :
 forall t : R,
 (Rsqr (derive_pt F t (F_derivable t)) +
  Rsqr (rho (vi intr) / 2) * Rsqr (F t))%R = Rsqr (vi intr).

Definition G (t : R) : R := (Rs t - F t)%R.

Lemma G_derivable : derivable G.

Lemma D_G_alphas :
 forall t : R,
 (derive_pt G t (G_derivable t) *
  (derive_pt Rs t (Rs_derivable t) + derive_pt F t (F_derivable t)))%R =
 (- Rsqr (derive_pt alphas t (cond_D1 alphas t)) * G t * (Rs t + F t) +
  Rsqr (F t) *
  (Rsqr (rho (vi intr) / 2) - Rsqr (derive_pt alphas t (cond_D1 alphas t))))%R.

Lemma Rlt_1_PI2 : (1 < PI / 2)%R.

Lemma D_G_pos :
 forall t : R,
 (0 <= t)%R ->
 (t < 2 / rho (vi intr))%R ->
 (G t <= 0)%R -> (0 <= derive_pt G t (G_derivable t))%R.

Lemma G_0 : G 0 = 0%R.

Axiom
  G_pos :
    forall t : R, (0 <= t)%R -> (t < 2 / rho (vi intr))%R -> (0 <= G t)%R.

Theorem YCNGSTYS :
 forall t : R,
 (0 <= t)%R ->
 (rho (vi intr) * t < 2)%R ->
 (2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)))%R.

End ycngstys. *)

Require Import Omega.



Unset Standard Proposition Elimination Names.



Variable intr : Trajectory.

Variable evad : EvaderTrajectory.

Variable T : TimeT.



Lemma thetat_derivable : derivable (thetat intr).

unfold thetat in |- *; apply (cond_diff (theta intr)).

Qed.



Definition xe : R := x (tr evad) T.

Definition ye : R := y (tr evad) T.

Definition ve : R := v (h (tr evad)).

Definition r_vi : R := r (vi intr).

Definition rho_vi : R := rho (vi intr).

Definition Die (ti te : R) : R :=

  sqrt

    (Rsqr (xi intr ti - x (tr evad) te) + Rsqr (yi intr ti - y (tr evad) te)).

Definition conflict (t : R) : bool :=

  match Rle_dec (Die t t) ConflictRange with

  | left _ => true

  | right _ => false

  end.



Lemma Dx :

 forall t : R,

 derive_pt (xi intr) t (xi_derivable intr t) =

 (vi intr * cos (thetat intr t))%R.

intro; unfold xi, vi, thetat in |- *.

assert (H := cond_x intr t).

rewrite <- H.

apply pr_nu.

Qed.



Lemma Dy :

 forall t : R,

 derive_pt (yi intr) t (yi_derivable intr t) =

 (vi intr * sin (thetat intr t))%R.

intro; unfold yi, vi, thetat in |- *.

assert (H := cond_y intr t).

rewrite <- H.

apply pr_nu.

Qed.



Axiom r_sin_rho : (ConflictRange < r_vi * sin rho_vi)%R.



Definition l : R := Die 0 T.

Definition d : R := Die 0 0.



Axiom

  beta_exists :

    { beta : R |

       xe = (l * cos beta + xi intr 0)%R /\

       ye = (yi intr 0 - l * sin beta)%R /\

       (0 <= beta + thetat intr 0 < 2 * PI)%R }.



Definition beta := let (a,_) := beta_exists in a.



Lemma beta_def :

 xe = (l * cos beta + xi intr 0)%R /\

 ye = (yi intr 0 - l * sin beta)%R /\ (0 <= beta + thetat intr 0 < 2 * PI)%R.

unfold beta in |- *; case beta_exists; trivial.

Qed.



Definition Omega (a : R) : bool :=

  match Rle_dec (PI / 2) a with

  | left _ =>

      match Rle_dec a (3 * (PI / 2)) with

      | left _ => true

      | right _ => false

      end

  | right _ => false

  end.



Lemma xe_0 : xe = (l * cos beta + xi intr 0)%R.

Proof with trivial.

generalize beta_def; intro; elim H...

Qed.



Lemma ye_0 : ye = (yi intr 0 - l * sin beta)%R.

Proof with trivial.

generalize beta_def; intro; elim H; intros _ H0; elim H0...

Qed.



Lemma d_l_beta :

 Rsqr d = (Rsqr (ve * T) + Rsqr l - 2 * ve * T * l * cos beta)%R.

Proof with trivial.

unfold d in |- *; unfold Die in |- *; rewrite Rsqr_sqrt...

replace (xi intr 0 - x (tr evad) 0)%R with

 (xi intr 0 - xe + (xe - x (tr evad) 0))%R...

replace (yi intr 0 - y (tr evad) 0)%R with

 (yi intr 0 - ye + (ye - y (tr evad) 0))%R...

repeat rewrite Rsqr_plus; cut ((ye - y (tr evad) 0)%R = 0%R)...

intro; rewrite H; repeat rewrite Rmult_0_r; rewrite Rsqr_0;

 repeat rewrite Rplus_0_r; cut ((xe - x (tr evad) 0)%R = (ve * T)%R)...

intro; rewrite H0;

 replace

  (Rsqr (xi intr 0 - xe) + Rsqr (ve * T) + 2 * (xi intr 0 - xe) * (ve * T) +

   Rsqr (yi intr 0 - ye))%R with

  (Rsqr (ve * T) + (Rsqr (xi intr 0 - xe) + Rsqr (yi intr 0 - ye)) +

   2 * (xi intr 0 - xe) * (ve * T))%R...

cut (Rsqr l = (Rsqr (xi intr 0 - xe) + Rsqr (yi intr 0 - ye))%R)...

intro; rewrite <- H1; rewrite xe_0; ring...

unfold l in |- *; unfold Die in |- *; rewrite Rsqr_sqrt;

 [ unfold xe, ye in |- * | apply Rplus_le_le_0_compat; apply Rle_0_sqr ]...

ring...

unfold xe, ve in |- *; rewrite (tr_cond1 evad); ring...

unfold ye, ve in |- *; rewrite (tr_cond2 evad); unfold Rminus in |- *;

 rewrite Rplus_opp_r...

ring...

ring...

apply Rplus_le_le_0_compat; apply Rle_0_sqr...

Qed.



Definition yp (t : R) : R :=

  (- sin (thetat intr 0) * (xi intr t - xe) +

   cos (thetat intr 0) * (yi intr t - ye))%R.



Hint Resolve xi_derivable yi_derivable: diff.



Lemma yp_derivable : derivable yp.

unfold yp in |- *; set (thetat_p := thetat intr); set (xi_p := xi intr);

 set (yi_p := yi intr); reg.

apply (yi_derivable intr).

apply (xi_derivable intr).

Qed.

Hint Resolve yp_derivable: diff.



Definition xp (t : R) : R :=

  (cos (thetat intr 0) * (xi intr t - xe) +

   sin (thetat intr 0) * (yi intr t - ye))%R.



Lemma xp_derivable : derivable xp.

unfold xp in |- *; set (thetat_p := thetat intr); set (xi_p := xi intr);

 set (yi_p := yi intr); reg.

apply (yi_derivable intr).

apply (xi_derivable intr).

Qed.

Hint Resolve xp_derivable: diff.



Definition Rsqr_evader_distance (t : R) : R :=

  (Rsqr (xi intr t - xe) + Rsqr (yi intr t - ye))%R.



Lemma Rsqr_evader_distance_derivable : derivable Rsqr_evader_distance.

unfold Rsqr_evader_distance in |- *.

set (xi_p := xi intr); set (yi_p := yi intr); reg. 

apply (yi_derivable intr).

apply (xi_derivable intr).

Qed.

Hint Resolve Rsqr_evader_distance_derivable: diff.



Definition Rsqr_intruder_distance (t : R) : R :=

  (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0))%R.



Lemma Rsqr_intruder_distance_derivable : derivable Rsqr_intruder_distance.

unfold Rsqr_intruder_distance in |- *; set (xi_p := xi intr);

 set (yi_p := yi intr); reg.

apply (yi_derivable intr).

apply (xi_derivable intr).

Qed.

Hint Resolve Rsqr_intruder_distance_derivable: diff.



Lemma Rsqr_evader_distance_pos :

 forall t : R, (0 <= Rsqr_evader_distance t)%R.

intro; unfold Rsqr_evader_distance in |- *; apply Rplus_le_le_0_compat;

 apply Rle_0_sqr.

Qed.



Lemma Rsqr_intruder_distance_pos :

 forall t : R, (0 <= Rsqr_intruder_distance t)%R.

intro; unfold Rsqr_intruder_distance in |- *; apply Rplus_le_le_0_compat;

 apply Rle_0_sqr.

Qed.



Definition e (t : R) : R := sqrt (Rsqr_evader_distance t).

Definition i (t : R) : R := sqrt (Rsqr_intruder_distance t).



Lemma conflict_T_e_0 : conflict T = true -> (e T <= ConflictRange)%R. 

Proof with trivial.

unfold conflict in |- *; cut (e T = Die T T)...

intro; case (Rle_dec (Die T T) ConflictRange); intros;

 [ rewrite H; exact r | elim diff_false_true ]...

Qed.



Lemma conflict_T_e_1 : (e T <= ConflictRange)%R -> conflict T = true.

Proof with trivial.

intro; cut (e T = Die T T)...

intro; rewrite H0 in H; unfold conflict in |- *;

 case (Rle_dec (Die T T) ConflictRange); intro...

elim n; assumption...

Qed.



Lemma L : Rsqr l = (Rsqr (xe - xi intr 0) + Rsqr (ye - yi intr 0))%R.

rewrite xe_0; rewrite ye_0; unfold Rminus in |- *;

 rewrite <- (Rplus_comm (- (l * sin beta))); repeat rewrite Rplus_assoc;

 repeat rewrite Rplus_opp_r; repeat rewrite Rplus_0_r; 

 rewrite <- Rsqr_neg; repeat rewrite Rsqr_mult;

 rewrite <- (Rmult_comm (Rsqr (sin beta))); rewrite sin2;

 unfold Rminus in |- *; rewrite Rmult_plus_distr_r; 

 ring.

Qed.



Lemma L_intruder : forall t : R, (l <= e t + i t)%R.

intro; apply Rsqr_incr_0.

rewrite Rsqr_plus.

cut

 (Rsqr l =

  (Rsqr (e t) + Rsqr (i t) +

   2 *

   ((xe - xi intr t) * (xi intr t - xi intr 0) +

    (ye - yi intr t) * (yi intr t - yi intr 0)))%R).

intro.

rewrite H.

apply Rplus_le_compat_l.

repeat rewrite Rmult_assoc.

apply Rmult_le_compat_l.

left; prove_sup0.

unfold e, i in |- *.

unfold Rsqr_evader_distance, Rsqr_intruder_distance in |- *.

rewrite (Rsqr_neg (xi intr t - xe)).

rewrite (Rsqr_neg (yi intr t - ye)).

replace (- (xi intr t - xe))%R with (xe - xi intr t)%R.

replace (- (yi intr t - ye))%R with (ye - yi intr t)%R.

apply sqrt_cauchy.

ring.

ring.

rewrite L.

unfold e, i in |- *.

repeat rewrite Rsqr_sqrt.

unfold Rsqr_evader_distance, Rsqr_intruder_distance in |- *.

replace (xe - xi intr 0)%R with (xe - xi intr t + (xi intr t - xi intr 0))%R.

replace (ye - yi intr 0)%R with (ye - yi intr t + (yi intr t - yi intr 0))%R.

repeat rewrite Rsqr_plus.

rewrite (Rsqr_neg (xe - xi intr t)).

rewrite (Rsqr_neg (ye - yi intr t)).

replace (- (xe - xi intr t))%R with (xi intr t - xe)%R.

replace (- (ye - yi intr t))%R with (yi intr t - ye)%R.

ring.

ring.

ring.

ring.

ring.

apply Rsqr_intruder_distance_pos.

apply Rsqr_evader_distance_pos.

unfold l in |- *; unfold Die in |- *.

apply sqrt_positivity.

apply Rplus_le_le_0_compat; apply Rle_0_sqr.

unfold e, i in |- *; apply Rplus_le_le_0_compat; apply sqrt_positivity.

apply Rsqr_evader_distance_pos.

apply Rsqr_intruder_distance_pos.

Qed.



Lemma l_is_pos : (0 <= l)%R.

unfold l in |- *; unfold Die in |- *; apply sqrt_positivity;

 apply Rplus_le_le_0_compat; apply Rle_0_sqr.

Qed.



Lemma L_e : forall t : R, (e t <= l + i t)%R.

intro.

apply Rsqr_incr_0.

rewrite Rsqr_plus.

cut

 (Rsqr (e t) =

  (Rsqr l + Rsqr (i t) +

   2 *

   ((xi intr t - xi intr 0) * (xi intr 0 - xe) +

    (yi intr t - yi intr 0) * (yi intr 0 - ye)))%R).

intro.

rewrite H.

apply Rplus_le_compat_l.

repeat rewrite Rmult_assoc.

apply Rmult_le_compat_l.

left; prove_sup0.

cut (l = sqrt (Rsqr (xe - xi intr 0) + Rsqr (ye - yi intr 0))).

intro.

rewrite H0.

unfold i in |- *.

unfold Rsqr_intruder_distance in |- *.

rewrite (Rsqr_neg (xe - xi intr 0)).

rewrite (Rsqr_neg (ye - yi intr 0)).

replace (- (xe - xi intr 0))%R with (xi intr 0 - xe)%R.

replace (- (ye - yi intr 0))%R with (yi intr 0 - ye)%R.

rewrite <-

 (Rmult_comm

    (sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0))))

 .

apply sqrt_cauchy.

ring.

ring.

apply Rsqr_inj.

apply l_is_pos.

apply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr.

rewrite Rsqr_sqrt.

apply L.

apply Rplus_le_le_0_compat; apply Rle_0_sqr.

rewrite L.

unfold e, i in |- *.

repeat rewrite Rsqr_sqrt.

unfold Rsqr_evader_distance, Rsqr_intruder_distance in |- *.

replace (xi intr t - xe)%R with (xi intr t - xi intr 0 + (xi intr 0 - xe))%R.

replace (yi intr t - ye)%R with (yi intr t - yi intr 0 + (yi intr 0 - ye))%R.

repeat rewrite Rsqr_plus.

rewrite (Rsqr_neg (xe - xi intr 0)).

rewrite (Rsqr_neg (ye - yi intr 0)).

replace (- (xe - xi intr 0))%R with (xi intr 0 - xe)%R.

replace (- (ye - yi intr 0))%R with (yi intr 0 - ye)%R.

ring.

ring.

ring.

ring.

ring.

apply Rsqr_intruder_distance_pos.

apply Rsqr_evader_distance_pos.

unfold e in |- *.

apply sqrt_positivity.

apply Rsqr_evader_distance_pos.

apply Rplus_le_le_0_compat.

apply l_is_pos.

unfold i in |- *.

apply sqrt_positivity.

apply Rsqr_intruder_distance_pos.

Qed.



Lemma L_i : forall t : R, (i t <= l + e t)%R.

intro.

apply Rsqr_incr_0.

rewrite Rsqr_plus.

cut

 (Rsqr (i t) =

  (Rsqr l + Rsqr (e t) +

   2 *

   ((xi intr t - xe) * (xe - xi intr 0) + (yi intr t - ye) * (ye - yi intr 0)))%R).

intro.

rewrite H.

apply Rplus_le_compat_l.

repeat rewrite Rmult_assoc.

apply Rmult_le_compat_l.

left; prove_sup0.

cut (l = sqrt (Rsqr (xe - xi intr 0) + Rsqr (ye - yi intr 0))).

intro.

rewrite H0.

unfold e in |- *.

unfold Rsqr_evader_distance in |- *.

rewrite <-

 (Rmult_comm (sqrt (Rsqr (xi intr t - xe) + Rsqr (yi intr t - ye))))

 .

apply sqrt_cauchy.

apply Rsqr_inj.

apply l_is_pos.

apply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr.

rewrite Rsqr_sqrt.

apply L.

apply Rplus_le_le_0_compat; apply Rle_0_sqr.

rewrite L.

unfold e, i in |- *.

repeat rewrite Rsqr_sqrt.

unfold Rsqr_evader_distance, Rsqr_intruder_distance in |- *.

replace (xi intr t - xi intr 0)%R with (xi intr t - xe + (xe - xi intr 0))%R.

replace (yi intr t - yi intr 0)%R with (yi intr t - ye + (ye - yi intr 0))%R.

repeat rewrite Rsqr_plus.

ring.

ring.

ring.

apply Rsqr_evader_distance_pos.

apply Rsqr_intruder_distance_pos.

unfold i in |- *.

apply sqrt_positivity.

apply Rsqr_intruder_distance_pos.

apply Rplus_le_le_0_compat.

apply l_is_pos.

unfold e in |- *.

apply sqrt_positivity.

apply Rsqr_evader_distance_pos.

Qed.



Lemma theta_inv :

 forall t : R,

 (0 <= t)%R ->

 (thetat intr 0 - rho_vi * t <= thetat intr t)%R /\

 (thetat intr t <= thetat intr 0 + rho_vi * t)%R.

Proof with trivial.

generalize (dtheta_rho intr); intros; split...

unfold thetat in |- *; cut (derivable (fun y : R => (- rho_vi * y)%R));

 [ intro X | reg ]...

cut

 (forall z : R,

  derive_pt (fun y : R => (- rho_vi * y)%R) z (X z) = (- rho_vi)%R);

 [ intro | intro; reg ]...

apply Rplus_le_reg_l with (- theta intr 0)%R...

replace (- theta intr 0 + (theta intr 0 - rho_vi * t))%R with

 (- rho_vi * t - - rho_vi * 0)%R; [ idtac | ring ]...

replace (- theta intr 0 + theta intr t)%R with

 (theta intr t - theta intr 0)%R; [ idtac | ring ]...

apply

 (IAF_var (theta intr) (fun y : R => (- rho_vi * y)%R) 0 t

    (cond_diff (theta intr)) X H0)...

intros; rewrite (H1 c); unfold rho_vi in |- *; unfold vi in |- *; elim (H c);

 intros H4 _; assumption...

unfold thetat in |- *; cut (derivable (fun y : R => (rho_vi * y)%R));

 [ intro X | reg ]...

cut (forall z : R, derive_pt (fun y : R => (rho_vi * y)%R) z (X z) = rho_vi);

 [ intro | intro; reg ]...

apply Rplus_le_reg_l with (- theta intr 0)%R...

replace (- theta intr 0 + (theta intr 0 + rho_vi * t))%R with

 (rho_vi * t - rho_vi * 0)%R; [ idtac | ring ]...

replace (- theta intr 0 + theta intr t)%R with

 (theta intr t - theta intr 0)%R; [ idtac | ring ]...

apply

 (IAF_var (fun y : R => (rho_vi * y)%R) (theta intr) 0 t X

    (cond_diff (theta intr)) H0)...

intros; rewrite (H1 c); unfold rho_vi in |- *; unfold vi in |- *; elim (H c)...

Qed.



Lemma rho_t_pos : forall t : R, (0 <= t)%R -> (0 <= rho_vi * t)%R.

Proof with trivial.

intros; apply Rmult_le_pos...

left; unfold rho_vi in |- *; apply rho_pos...

Qed.



Lemma rho_t_le :

 forall t1 t2 : R, (t1 <= t2)%R -> (rho_vi * t1 <= rho_vi * t2)%R.

Proof with trivial.

intros; apply Rmult_le_compat_l...

left; unfold rho_vi in |- *; apply rho_pos...

Qed.



Lemma Dyp :

 forall t : R,

 derive_pt yp t (yp_derivable t) =

 (v (vi intr) * sin (thetat intr t - thetat intr 0))%R.

intro; unfold yp in |- *.

assert (H := xi_derivable intr t).

assert (H0 := yi_derivable intr t).

assert (H1 := thetat_derivable t).

set (xi_p := xi intr) in H |- *.

set (yi_p := yi intr) in H0 |- *.

set (thetat_p := thetat intr) in H1 |- *.

reg.

assert (H2 := cond_x intr t).

assert (H3 := cond_y intr t).

replace (derive_pt xi_p t H) with

 (derive_pt (x intr) t (cond_diff (x intr) t)); [ idtac | apply pr_nu ].

replace (derive_pt yi_p t H0) with

 (derive_pt (y intr) t (cond_diff (y intr) t)); [ idtac | apply pr_nu ].

rewrite H2; rewrite H3.

rewrite sin_minus.

unfold fct_cte, vi, thetat_p, thetat in |- *.

ring.

Qed.



Lemma Dyp0_PI2 :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI / 2)%R ->

 (- (vi intr * sin (rho_vi * t)) <= derive_pt yp t (yp_derivable t) <=

  vi intr * sin (rho_vi * t))%R.

Proof with trivial.

intros...

rewrite Dyp...

generalize (theta_inv t H); intro; elim H1; intros...

cut (thetat intr t - thetat intr 0 <= rho_vi * t)%R...

cut (- (rho_vi * t) <= thetat intr t - thetat intr 0)%R...

intros...

split...

replace (- (vi intr * sin (rho_vi * t)))%R with

 (vi intr * - sin (rho_vi * t))%R...

apply Rmult_le_compat_l...

left; apply TypeSpeed_pos...

rewrite <- (sin_neg (rho_vi * t))...

apply sin_incr_1...

apply Ropp_ge_le_contravar; apply Rle_ge...

apply Rle_trans with 0%R...

rewrite <- Ropp_0...

apply Ropp_ge_le_contravar; apply Rle_ge; apply (rho_t_pos t H)...

left; apply PI2_RGT_0...

apply Rle_trans with (- (rho_vi * t))%R...

apply Ropp_ge_le_contravar...

apply Rle_ge...

apply Rle_trans with (rho_vi * t)%R...

ring...

apply Rmult_le_compat_l...

left; apply TypeSpeed_pos...

apply sin_incr_1...

apply Rle_trans with (- (rho_vi * t))%R...

apply Ropp_ge_le_contravar; apply Rle_ge...

apply Rle_trans with (rho_vi * t)%R...

apply Rle_trans with 0%R...

rewrite <- Ropp_0; apply Ropp_ge_le_contravar; apply Rle_ge; left;

 apply PI2_RGT_0...

apply (rho_t_pos t H)...

apply Rplus_le_reg_l with (thetat intr 0)...

unfold Rminus in |- *...

rewrite (Rplus_comm (thetat intr t))...

repeat rewrite <- Rplus_assoc...

rewrite Rplus_opp_r...

rewrite Rplus_0_l...

apply Rplus_le_reg_l with (thetat intr 0)...

unfold Rminus in |- *...

rewrite (Rplus_comm (thetat intr t))...

repeat rewrite <- Rplus_assoc...

rewrite Rplus_opp_r...

rewrite Rplus_0_l...

Qed.



Lemma yp0 : yp 0 = (l * sin (thetat intr 0 + beta))%R.

unfold yp in |- *; rewrite xe_0; rewrite ye_0;

 rewrite <- (Rplus_comm (xi intr 0)); unfold Rminus in |- *;

 repeat rewrite Ropp_plus_distr; repeat rewrite <- Rplus_assoc;

 repeat rewrite Rplus_opp_r; repeat rewrite Rplus_0_l; 

 rewrite sin_plus; ring.

Qed.



Definition hy (t : R) : R := (r_vi * cos (rho_vi * t))%R.



Lemma hy_derivable : derivable hy.

unfold hy in |- *; reg.

Qed.



Lemma Dhy :

 forall t : R,

 derive_pt hy t (hy_derivable t) = (- vi intr * sin (rho_vi * t))%R.

Proof with trivial.

intro; unfold hy in |- *; reg...

replace (vi intr:R) with (r_vi * rho_vi)%R.

ring.

unfold rho_vi, r_vi in |- *; unfold r in |- *.

field.

assert (H := rho_pos (vi intr)); red in |- *; intro; rewrite H0 in H;

 elim (Rlt_irrefl _ H)...

Qed.



Lemma ypt :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI / 2)%R -> (hy t - hy 0 <= yp t - yp 0 <= hy 0 - hy t)%R.

Proof with trivial.

intros; split...

apply (IAF_var yp hy 0 t yp_derivable hy_derivable H)...

intros; elim H1; intros...

generalize

 (Dyp0_PI2 c H2

    (Rle_trans (rho_vi * c) (rho_vi * t) (PI / 2) (rho_t_le c t H3) H0));

 intro...

elim H4; intros...

cut (derive_pt hy c (hy_derivable c) = (- (vi intr * sin (rho_vi * c)))%R)...

intro...

rewrite <- H7 in H5...

rewrite Dhy; ring...

replace (hy 0 - hy t)%R with ((- hy)%F t - (- hy)%F 0)%R...

apply

 (IAF_var (- hy)%F yp 0 t (derivable_opp hy hy_derivable) yp_derivable H)... 

intros; elim H1; intros...

generalize

 (Dyp0_PI2 c H2

    (Rle_trans (rho_vi * c) (rho_vi * t) (PI / 2) (rho_t_le c t H3) H0));

 intro...

elim H4; intros...

cut ((- derive_pt hy c (hy_derivable c))%R = (vi intr * sin (rho_vi * c))%R)...

intro; rewrite <- H7 in H6...

replace (derive_pt (- hy) c (derivable_opp hy hy_derivable c)) with

 (derive_pt (- hy) c (derivable_pt_opp hy c (hy_derivable c)));

 [ idtac | apply pr_nu ]...

rewrite (derive_pt_opp hy c (hy_derivable c))...

rewrite Dhy; ring...

unfold opp_fct in |- *; ring...

Qed.



Lemma ypt_PI2 :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI / 2)%R ->

 (l * sin (beta + thetat intr 0) + r_vi * (cos (rho_vi * t) - 1) <= yp t)%R /\

 (yp t <= l * sin (beta + thetat intr 0) - r_vi * (cos (rho_vi * t) - 1))%R.

intros; generalize (ypt t H H0); intro; elim H1; intros; split;

 [ unfold hy in H2; unfold Rminus in H2; rewrite yp0 in H2;

    rewrite Rmult_0_r in H2; rewrite cos_0 in H2; rewrite Rmult_1_r in H2;

    generalize

     (Rplus_le_compat_r (l * sin (thetat intr 0 + beta))

        (r_vi * cos (rho_vi * t) + - r_vi)

        (yp t + - (l * sin (thetat intr 0 + beta))) H2);

    replace (r_vi * cos (rho_vi * t) + - r_vi)%R with

     (r_vi * (cos (rho_vi * t) - 1))%R;

    [ repeat rewrite Rplus_assoc; rewrite Rplus_opp_l; rewrite Rplus_0_r;

       intro; rewrite <- (Rplus_comm (r_vi * (cos (rho_vi * t) - 1)));

       rewrite (Rplus_comm beta); assumption

    | ring ]

 | unfold hy in H3; unfold Rminus in H3; rewrite yp0 in H3;

    rewrite Rmult_0_r in H3; rewrite cos_0 in H3; rewrite Rmult_1_r in H3;

    generalize

     (Rplus_le_compat_r (l * sin (thetat intr 0 + beta))

        (yp t + - (l * sin (thetat intr 0 + beta)))

        (r_vi + - (r_vi * cos (rho_vi * t))) H3);

    replace (r_vi + - (r_vi * cos (rho_vi * t)))%R with

     (- (r_vi * (cos (rho_vi * t) - 1)))%R;

    [ repeat rewrite Rplus_assoc; rewrite Rplus_opp_l; rewrite Rplus_0_r;

       intro; unfold Rminus in |- *; rewrite (Rplus_comm beta);

       rewrite <- (Rplus_comm (- (r_vi * (cos (rho_vi * t) + -1))));

       assumption

    | unfold Rminus in |- *; rewrite Rmult_plus_distr_l; ring ] ].

Qed.



Lemma Dxp :

 forall t : R,

 derive_pt xp t (xp_derivable t) =

 (vi intr * cos (thetat intr t - thetat intr 0))%R.

intro; unfold xp in |- *.

assert (H := xi_derivable intr t).

assert (H0 := yi_derivable intr t).

assert (H1 := thetat_derivable t).

set (xi_p := xi intr) in H |- *.

set (yi_p := yi intr) in H0 |- *.

set (thetat_p := thetat intr) in H1 |- *.

reg.

assert (H2 := cond_x intr t).

assert (H3 := cond_y intr t).

replace (derive_pt yi_p t H0) with

 (derive_pt (y intr) t (cond_diff (y intr) t)); [ idtac | apply pr_nu ].

replace (derive_pt xi_p t H) with

 (derive_pt (x intr) t (cond_diff (x intr) t)); [ idtac | apply pr_nu ].

unfold vi in |- *.

rewrite H2; rewrite H3; rewrite cos_minus; unfold thetat_p, thetat; ring.

Qed.



Lemma Dx0_PI :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI)%R ->

 (vi intr * cos (rho_vi * t) <= derive_pt xp t (xp_derivable t))%R.

intros; rewrite Dxp; apply Rmult_le_compat_l;

 [ left; apply TypeSpeed_pos

 | generalize (theta_inv t H); intro; elim H1; intros;

    case (Rcase_abs (thetat intr t - thetat intr 0)); 

    intro;

    [ cut (thetat intr 0 - thetat intr t <= rho_vi * t)%R;

       [ cut (- (rho_vi * t) <= thetat intr 0 - thetat intr t)%R;

          [ intros; rewrite <- (cos_neg (thetat intr t - thetat intr 0));

             replace (- (thetat intr t - thetat intr 0))%R with

              (thetat intr 0 - thetat intr t)%R;

             [ apply cos_decr_1;

                [ left;

                   generalize

                    (Ropp_lt_gt_contravar (thetat intr t - thetat intr 0) 0 r);

                   rewrite Ropp_0;

                   replace (- (thetat intr t - thetat intr 0))%R with

                    (thetat intr 0 - thetat intr t)%R;

                   [ intro; assumption | ring ]

                | apply Rle_trans with (rho_vi * t)%R; assumption

                | apply (rho_t_pos t H)

                | assumption

                | assumption ]

             | ring ]

          | apply Rplus_le_reg_l with (thetat intr t + rho_vi * t)%R;

             repeat rewrite Rplus_assoc; rewrite Rplus_opp_r;

             rewrite Rplus_0_r;

             replace

              (thetat intr t + (rho_vi * t + (thetat intr 0 - thetat intr t)))%R

              with (thetat intr 0 + rho_vi * t)%R; 

             [ assumption | ring ] ]

       | apply Rplus_le_reg_l with (thetat intr t - rho_vi * t)%R;

          unfold Rminus in |- *; repeat rewrite Rplus_assoc;

          rewrite Rplus_opp_l; rewrite Rplus_0_r; rewrite Rplus_comm;

          repeat rewrite Rplus_assoc; rewrite Rplus_opp_l; 

          rewrite Rplus_0_r; rewrite Rplus_comm; assumption ]

    | generalize (Rge_le (thetat intr t - thetat intr 0) 0 r); intro;

       cut (thetat intr t - thetat intr 0 <= rho_vi * t)%R;

       [ cut (- (rho_vi * t) <= thetat intr t - thetat intr 0)%R;

          [ intros; apply cos_decr_1;

             [ assumption

             | apply Rle_trans with (rho_vi * t)%R; assumption

             | apply (rho_t_pos t H)

             | assumption

             | assumption ]

          | apply Rplus_le_reg_l with (thetat intr 0); unfold Rminus in |- *;

             rewrite (Rplus_comm (thetat intr t));

             repeat rewrite <- Rplus_assoc; rewrite Rplus_opp_r;

             rewrite Rplus_0_l; assumption ]

       | apply Rplus_le_reg_l with (thetat intr 0); unfold Rminus in |- *;

          rewrite (Rplus_comm (thetat intr t)); repeat rewrite <- Rplus_assoc;

          rewrite Rplus_opp_r; rewrite Rplus_0_l; assumption ] ] ].

Qed.



Lemma xp0 : xp 0 = (- l * cos (thetat intr 0 + beta))%R.

unfold xp in |- *; rewrite xe_0; rewrite ye_0;

 rewrite <- (Rplus_comm (xi intr 0)); unfold Rminus in |- *;

 repeat rewrite Ropp_plus_distr; repeat rewrite <- Rplus_assoc;

 repeat rewrite Rplus_opp_r; repeat rewrite Rplus_0_l; 

 rewrite cos_plus; ring.

Qed.



Definition hx (t : R) : R := (r_vi * sin (rho_vi * t))%R.



Lemma hx_derivable : derivable hx.

unfold hx in |- *; reg.

Qed.



Lemma Dhx :

 forall t : R,

 derive_pt hx t (hx_derivable t) = (vi intr * cos (rho_vi * t))%R.

Proof with trivial.

intro; unfold hx in |- *; reg...

replace (vi intr:R) with (r_vi * rho_vi)%R.

ring.

unfold rho_vi, r_vi in |- *; unfold r in |- *.

field.

assert (H := rho_pos (vi intr)); red in |- *; intro; rewrite H0 in H;

 elim (Rlt_irrefl _ H)...

Qed.



Lemma xpt :

 forall t : R, (0 <= t)%R -> (rho_vi * t <= PI)%R -> (hx t <= xp t - xp 0)%R.

intros; replace (hx t) with (hx t - hx 0)%R.

apply (IAF_var xp hx 0 t xp_derivable hx_derivable H); intros; rewrite Dhx;

 elim H1; intros;

 apply

  (Dx0_PI c H2 (Rle_trans (rho_vi * c) (rho_vi * t) PI (rho_t_le c t H3) H0)). 

unfold hx in |- *; rewrite Rmult_0_r; rewrite sin_0; unfold Rminus in |- *;

 rewrite Rmult_0_r; rewrite Ropp_0; apply Rplus_0_r.

Qed.



Lemma r_sin_pos :

 forall t : R,

 (0 <= t)%R -> (rho_vi * t <= PI)%R -> (0 <= r_vi * sin (rho_vi * t))%R.

intros; apply Rmult_le_pos;

 [ left; unfold r_vi in |- *; unfold r in |- *; unfold Rdiv in |- *;

    apply Rmult_lt_0_compat;

    [ apply (TypeSpeed_pos (vi intr))

    | apply Rinv_0_lt_compat; apply (rho_pos (vi intr)) ]

 | apply sin_ge_0; [ apply (rho_t_pos t H) | assumption ] ].

Qed.



Lemma xpt_pos :

 forall t : R, (0 <= t)%R -> (rho_vi * t <= PI)%R -> (0 <= xp t - xp 0)%R.

intros; generalize (xpt t H H0); unfold hx in |- *; intro;

 apply Rle_trans with (r_vi * sin (rho_vi * t))%R;

 [ apply (r_sin_pos t H H0) | assumption ].

Qed.



Lemma xpt_PI :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI)%R ->

 (r_vi * sin (rho_vi * t) - l * cos (beta + thetat intr 0) <= xp t)%R.

intros; generalize (xpt t H H0); intro; unfold Rminus, hx in H1;

 rewrite xp0 in H1;

 generalize

  (Rplus_le_compat_l (- l * cos (thetat intr 0 + beta))

     (r_vi * sin (rho_vi * t)) (xp t + - (- l * cos (thetat intr 0 + beta)))

     H1); rewrite <- (Rplus_comm (r_vi * sin (rho_vi * t)));

 rewrite (Rplus_comm (- l * cos (thetat intr 0 + beta)));

 repeat rewrite Rplus_assoc; rewrite Rplus_opp_l; rewrite Rplus_0_r;

 rewrite (Rplus_comm beta); unfold Rminus in |- *; 

 intro;

 replace (- (l * cos (thetat intr 0 + beta)))%R with

  (- l * cos (thetat intr 0 + beta))%R; [ assumption | ring ].

Qed.



Lemma Omega_defeq :

 forall x : R, Omega x = true -> (PI / 2 <= x <= 3 * (PI / 2))%R.

Proof with trivial.

intro x; unfold Omega in |- *...

case (Rle_dec (PI / 2) x); intro...

case (Rle_dec x (3 * (PI / 2))); intros...

split...

elim diff_false_true...

intro; elim diff_false_true...

Qed.



Lemma neg_cos_var : forall x : R, cos (x - PI) = (- cos x)%R.

intro; rewrite cos_minus; rewrite cos_PI; rewrite sin_PI; ring.

Qed.



Lemma xp0_pos : Omega (beta + thetat intr 0) = true -> (0 <= xp 0)%R.

Proof with trivial.

intro; generalize (Omega_defeq (beta + thetat intr 0) H); intro; rewrite xp0;

 replace (- l * cos (thetat intr 0 + beta))%R with

  (l * - cos (thetat intr 0 + beta))%R...

apply Rmult_le_pos...

apply l_is_pos...

rewrite <- neg_cos_var; unfold Rminus in |- *; elim H0; intros;

 apply cos_ge_0...

apply Rplus_le_reg_l with PI; replace (PI + - (PI / 2))%R with (PI / 2)%R...

rewrite (Rplus_comm PI); repeat rewrite Rplus_assoc; rewrite Rplus_opp_l;

 rewrite Rplus_0_r; rewrite <- (Rplus_comm beta)...

pattern PI at 2 in |- *; rewrite double_var; ring... 

apply Rplus_le_reg_l with PI; replace (PI + PI / 2)%R with (3 * (PI / 2))%R...

rewrite (Rplus_comm PI); repeat rewrite Rplus_assoc; rewrite Rplus_opp_l;

 rewrite Rplus_0_r; rewrite <- (Rplus_comm beta)...

pattern PI at 2 in |- *; rewrite double_var; ring... 

ring...

Qed.



Lemma xpt_Omega :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI)%R ->

 Omega (beta + thetat intr 0) = true -> (r_vi * sin (rho_vi * t) <= xp t)%R.

intros; generalize (xpt t H H0); intro; generalize (xp0_pos H1); intro;

 unfold hx in H2;

 generalize

  (Rplus_le_compat_r (xp 0) (r_vi * sin (rho_vi * t)) (xp t - xp 0) H2);

 unfold Rminus in |- *; repeat rewrite Rplus_assoc; 

 rewrite Rplus_opp_l; rewrite Rplus_0_r; intro;

 apply (plus_le_is_le (r_vi * sin (rho_vi * t)) (xp 0) (xp t) H3 H4).

Qed.



Lemma isometric_evader :

 forall t : R, Rsqr_evader_distance t = (Rsqr (xp t) + Rsqr (yp t))%R.

intro; unfold Rsqr_evader_distance, xp, yp in |- *; repeat rewrite Rsqr_plus;

 ring_simplify; repeat rewrite Rsqr_mult;

 rewrite <- (Rsqr_neg (sin (thetat intr 0)));

 pattern (Rsqr (xi intr t - xe)) at 1 in |- *.

 replace (Rsqr (xi intr t - xe)) with

 ((Rsqr (sin (thetat intr 0)) + Rsqr (cos (thetat intr 0))) *

  Rsqr (xi intr t - xe))%R.

 pattern (Rsqr (yi intr t - ye)) at 1 in |- *.

 replace (Rsqr (yi intr t - ye)) with

  ((Rsqr (sin (thetat intr 0)) + Rsqr (cos (thetat intr 0))) *

   Rsqr (yi intr t - ye))%R.

 ring.

 rewrite sin2_cos2 in |- *;  ring.

 rewrite sin2_cos2 in |- *;  ring.

Qed.



Lemma xpt_xp0 :

 forall t : R,

 (xp t - xp 0)%R =

 (cos (thetat intr 0) * (xi intr t - xi intr 0) +

  sin (thetat intr 0) * (yi intr t - yi intr 0))%R.

intro; unfold xp in |- *; ring.

Qed.



Lemma ypt_yp0 :

 forall t : R,

 (yp t - yp 0)%R =

 (- sin (thetat intr 0) * (xi intr t - xi intr 0) +

  cos (thetat intr 0) * (yi intr t - yi intr 0))%R.

intro; unfold yp in |- *; ring.

Qed.



Lemma isometric_intruder :

 forall t : R,

 Rsqr_intruder_distance t = (Rsqr (xp t - xp 0) + Rsqr (yp t - yp 0))%R.

intro; unfold Rsqr_intruder_distance in |- *; rewrite xpt_xp0;

 rewrite ypt_yp0; repeat rewrite Rsqr_plus; ring_simplify;

 repeat rewrite Rsqr_mult;

 rewrite <- Rsqr_neg.

 pattern (Rsqr (xi intr t - xi intr 0)) at 1 in |- *.

 replace (Rsqr (xi intr t - xi intr 0)) with

 ((Rsqr (sin (thetat intr 0)) + Rsqr (cos (thetat intr 0))) *

  Rsqr (xi intr t - xi intr 0))%R.

 pattern (Rsqr (yi intr t - yi intr 0)) at 1 in |- *.

 replace (Rsqr (yi intr t - yi intr 0)) with

  ((Rsqr (sin (thetat intr 0)) + Rsqr (cos (thetat intr 0))) *

   Rsqr (yi intr t - yi intr 0))%R.

 ring.

 rewrite sin2_cos2 in |- *;  ring.

 rewrite sin2_cos2 in |- *;  ring.

Qed.



Lemma majoration :

 forall t : R,

 (Rsqr (yp t) <= Rsqr_evader_distance t)%R /\

 (Rsqr (xp t) <= Rsqr_evader_distance t)%R.

intro; generalize (isometric_evader t); intro; split;

 [ rewrite H; pattern (Rsqr (yp t)) at 1 in |- *;

    rewrite <- (Rplus_0_l (Rsqr (yp t))); apply Rplus_le_compat_r;

    apply Rle_0_sqr

 | rewrite H; pattern (Rsqr (xp t)) at 1 in |- *;

    rewrite <- (Rplus_0_r (Rsqr (xp t))); apply Rplus_le_compat_l;

    apply Rle_0_sqr ].

Qed.



Lemma YCNGFTYS_evader :

 forall t : R, (0 <= t)%R -> (l - v (vi intr) * t <= e t)%R.

intros; cut (i t <= vi intr * t)%R;

 [ intros; unfold Rminus in |- *; rewrite Rplus_comm;

    apply Rplus_le_reg_l with (vi intr * t)%R; repeat rewrite <- Rplus_assoc;

    rewrite Rplus_opp_r; rewrite Rplus_0_l; rewrite Rplus_comm;

    apply Rle_trans with (e t + i t)%R;

    [ apply L_intruder | apply Rplus_le_compat_l; assumption ]

 | unfold i in |- *; unfold Rsqr_intruder_distance in |- *;

    apply (YCNGFTYS intr t H) ].

Qed.



Lemma YCNGSTYS_evader :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t < 2)%R -> (2 * r_vi * sin (rho_vi * (t / 2)) - l <= e t)%R.

intros; cut (2 * r_vi * sin (rho_vi * (t / 2)) <= i t)%R;

 [ intro; intros; unfold Rminus in |- *; rewrite Rplus_comm;

    apply Rplus_le_reg_l with l; repeat rewrite <- Rplus_assoc;

    rewrite Rplus_opp_r; rewrite Rplus_0_l; apply Rle_trans with (i t);

    [ assumption | apply L_i ]

 | unfold i in |- *; unfold Rsqr_intruder_distance in |- *;

    apply (YCNGSTYS intr t H H0) ].

Qed.



Lemma xp_pos :

 forall t : R,

 (0 <= t)%R ->

 (rho_vi * t <= PI)%R -> Omega (beta + thetat intr 0) = true -> (0 <= xp t)%R.

intros; apply Rle_trans with (r_vi * sin (rho_vi * t))%R;

 [ apply Rmult_le_pos;

    [ unfold r_vi in |- *; unfold r in |- *; left; unfold Rdiv in |- *;

       apply Rmult_lt_0_compat;

       [ apply TypeSpeed_pos | apply Rinv_0_lt_compat; apply rho_pos ]

    | apply sin_ge_0;

       [ apply Rmult_le_pos;

          [ unfold rho_vi in |- *; left; apply rho_pos | assumption ]

       | assumption ] ]

 | apply (xpt_Omega t H H0 H1) ].

Qed.



Lemma no_conflict_xp_1_Omega :

 forall t : R,

 (1 <= t)%R ->

 (rho_vi * t <= PI - rho_vi)%R ->

 Omega (beta + thetat intr 0) = true -> (ConflictRange < xp t)%R.

Proof with trivial.

intros; apply Rlt_le_trans with (r_vi * sin rho_vi)%R...

apply r_sin_rho...

apply Rle_trans with (r_vi * sin (rho_vi * t))%R...

apply Rmult_le_compat_l...

left; unfold r_vi in |- *; unfold r in |- *; unfold Rdiv in |- *;

 apply Rmult_lt_0_compat...

apply TypeSpeed_pos...

apply Rinv_0_lt_compat; apply rho_pos...

case (Rle_dec (rho_vi * t) (PI / 2)); intro...

cut (rho_vi <= rho_vi * t)%R...

intro; apply sin_incr_1...

left; apply Rlt_trans with 0%R...

apply _PI2_RLT_0...

unfold rho_vi in |- *; apply rho_pos...

apply Rle_trans with (rho_vi * t)%R...

left; apply Rlt_le_trans with 0%R...

apply _PI2_RLT_0...

apply rho_t_pos...

left; apply Rlt_le_trans with 1%R; try apply Rlt_0_1...

pattern rho_vi at 1 in |- *; rewrite <- (Rmult_1_r rho_vi)...

apply Rmult_le_compat_l...

left; unfold rho_vi in |- *; apply rho_pos...

cut (PI / 2 < rho_vi * t)%R...

intro; cut (rho_vi <= PI - rho_vi * t)%R...

cut (PI - rho_vi * t <= PI / 2)%R...

intros; rewrite <- (sin_PI_x (rho_vi * t))...

apply sin_incr_1...

left; apply Rlt_trans with 0%R...

apply _PI2_RLT_0...

unfold rho_vi in |- *; apply rho_pos...

apply Rle_trans with (PI - rho_vi * t)%R...

apply Rle_trans with rho_vi...

left; apply Rlt_trans with 0%R...

apply _PI2_RLT_0...

unfold rho_vi in |- *; apply rho_pos...

left...

apply Rplus_lt_reg_l with (- (PI / 2) + rho_vi * t)%R...

replace (- (PI / 2) + rho_vi * t + (PI - rho_vi * t))%R with (PI / 2)%R...

replace (- (PI / 2) + rho_vi * t + PI / 2)%R with (rho_vi * t)%R...

ring...

unfold Rminus in |- *; unfold Rdiv in |- *;

 replace (- (PI * / 2) + rho_vi * t + (PI + - (rho_vi * t)))%R with

  (- (PI * / 2) + PI + (rho_vi * t + - (rho_vi * t)))%R...

rewrite Rplus_opp_r; rewrite Rplus_0_r...

pattern PI at 3 in |- *; rewrite double_var...

unfold Rdiv in |- *; ring...

ring...

apply Rplus_le_reg_l with (rho_vi * t - rho_vi)%R...

unfold Rminus in |- *...

repeat rewrite Rplus_assoc...

rewrite Rplus_opp_l; rewrite Rplus_0_r...

rewrite (Rplus_comm (rho_vi * t))...

repeat rewrite Rplus_assoc...

rewrite Rplus_opp_l; rewrite Rplus_0_r...

rewrite <- (Rplus_comm PI)...

auto with real...

cut (0 <= t)%R...

cut (rho_vi * t <= PI)%R...

intros...

generalize (xpt t H3 H2); intro...

generalize (xp0_pos H1); intro...

unfold Rminus in H4...

generalize (Rplus_le_compat_r (xp 0) (hx t) (xp t + - xp 0) H4)...

repeat rewrite Rplus_assoc; rewrite Rplus_opp_l; rewrite Rplus_0_r...

intro...

generalize (plus_le_is_le (hx t) (xp 0) (xp t) H5 H6)...

apply Rle_trans with (PI - rho_vi)%R...

apply Rplus_le_reg_l with (- PI)%R...

unfold Rminus in |- *...

repeat rewrite <- Rplus_assoc...

repeat rewrite Rplus_opp_l...

rewrite Rplus_0_l...

rewrite <- Ropp_0...

apply Ropp_ge_le_contravar; apply Rle_ge; left; unfold rho_vi in |- *;

 apply rho_pos...

left; apply Rlt_le_trans with 1%R; try apply Rlt_0_1...

Qed.



Lemma no_conflict_scenario_1_Omega :

 forall t : R,

 (1 <= t)%R ->

 (rho_vi * t <= PI - rho_vi)%R ->

 Omega (beta + thetat intr 0) = true ->

 (Rsqr ConflictRange < Rsqr_evader_distance t)%R.

Proof with trivial.

intros; apply Rlt_le_trans with (Rsqr (xp t))...

apply Rsqr_incrst_1...

apply (no_conflict_xp_1_Omega t H H0 H1)...

unfold ConflictRange in |- *; left; prove_sup...

cut ((0 <= t)%R /\ (rho_vi * t <= PI)%R)...

intro; elim H2; intros; apply (xp_pos t H3 H4 H1)...

split...

left; apply Rlt_le_trans with 1%R; try apply Rlt_0_1...

unfold Rminus in H0;

 generalize (Rplus_le_compat_r rho_vi (rho_vi * t) (PI + - rho_vi) H0);

 repeat rewrite Rplus_assoc; rewrite Rplus_opp_l; rewrite Rplus_0_r; 

 intro; apply (plus_le_is_le (rho_vi * t) rho_vi PI)...

unfold rho_vi in |- *; left; apply rho_pos...

elim (majoration t)...

Qed.



Lemma no_conflict_scenario_0_1s :

 forall t : R,

 (0 <= t)%R ->

 (t < 1)%R -> (ConflictRange + vi intr < l)%R -> (ConflictRange < e t)%R.

Proof with trivial.

intros; apply Rlt_le_trans with (l - vi intr * t)%R...

apply Rplus_lt_reg_l with (v (vi intr));

 rewrite <- (Rplus_comm ConflictRange); apply Rlt_trans with l...

apply Rplus_lt_reg_l with (- l)%R; rewrite Rplus_opp_l;

 replace (- l + (vi intr + (l - vi intr * t)))%R with (vi intr * (1 - t))%R...

apply Rmult_lt_0_compat...

apply TypeSpeed_pos...

generalize (Rplus_lt_compat_r (- t) t 1 H0); rewrite Rplus_opp_r...

unfold Rminus in |- *; rewrite Rmult_plus_distr_l; ring...

apply (YCNGFTYS_evader t H)...

Qed.



Lemma no_conflict_gt_max_t :

 forall t : R,

 let MaxDistance := (vi intr * t + ConflictRange)%R in

 (0 <= t)%R -> (MaxDistance < l)%R -> (ConflictRange < e t)%R.

Proof with trivial.

intros; apply Rlt_le_trans with (l - vi intr * t)%R...

unfold MaxDistance in H0; rewrite Rplus_comm in H0;

 generalize

  (Rplus_lt_compat_r (- (vi intr * t)) (ConflictRange + vi intr * t) l H0);

 repeat rewrite Rplus_assoc; rewrite Rplus_opp_r; rewrite Rplus_0_r...

apply (YCNGFTYS_evader t H)...

Qed.



Lemma no_conflict_lt_min_t :

 forall t : R,

 let MinDistance := (2 * r_vi * sin (rho_vi * (t / 2)) - ConflictRange)%R in

 (0 <= t)%R ->

 (0 <= rho_vi * t)%R ->

 (rho_vi * t < 2)%R -> (l < MinDistance)%R -> (ConflictRange < e t)%R.

Proof with trivial.

intros; apply Rlt_le_trans with (2 * r_vi * sin (rho_vi * (t / 2)) - l)%R...

unfold MinDistance in H2; apply Rplus_lt_reg_l with (- ConflictRange + l)%R;

 replace (- ConflictRange + l + ConflictRange)%R with l...

replace (- ConflictRange + l + (2 * r_vi * sin (rho_vi * (t / 2)) - l))%R

 with (2 * r_vi * sin (rho_vi * (t / 2)) - ConflictRange)%R; 

 try ring...

ring...

apply (YCNGSTYS_evader t H H1)...

Qed.



Lemma no_conflict_Omega_t :

 forall t : R,

 (ConflictRange + vi intr < l)%R ->

 (0 <= t)%R ->

 (rho_vi * t <= PI - rho_vi)%R ->

 Omega (beta + thetat intr 0) = true -> (ConflictRange < e t)%R.

intros; case (Rle_dec 1 t); intro.

apply Rsqr_incrst_0.

unfold e in |- *; rewrite Rsqr_sqrt. 

apply (no_conflict_scenario_1_Omega t r H1 H2).

apply Rsqr_evader_distance_pos.

left; unfold ConflictRange in |- *; prove_sup.

unfold e in |- *; apply sqrt_positivity; apply Rsqr_evader_distance_pos.

cut (t < 1)%R.

intro; apply (no_conflict_scenario_0_1s t H0 H3 H).

auto with real.

Qed.



Theorem no_conflict_gt_max :

 let MaxDistance := (vi intr * T + ConflictRange)%R in

 (MaxDistance < l)%R -> conflict T = false.

Proof with trivial.

intros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);

 intro...

cut (0 <= T)%R...

intro; generalize (no_conflict_gt_max_t T H0 H); intro; cut (e T = Die T T)...

intro; rewrite H2 in H1;

 elim

  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H1))...

left; apply Rlt_le_trans with MinT...

apply MinT_is_pos...

apply (cond_1 T)...

Qed.



Theorem no_conflict_lt_min :

 let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in

 (0 <= rho_vi * T)%R ->

 (rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false.

Proof with trivial.

intros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);

 intro...

cut (0 <= T)%R...

intro; generalize (no_conflict_lt_min_t T H2 H H0 H1); intro;

 cut (e T = Die T T)...

intro; rewrite H4 in H3;

 elim

  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...

left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...

Qed.



Theorem no_conflict_Omega :

 (ConflictRange + v (vi intr) < l)%R ->

 (rho_vi * T <= PI - rho_vi)%R ->

 Omega (beta + thetat intr 0) = true -> conflict T = false.

Proof with trivial.

intros; unfold conflict in |- *; case (Rle_dec (Die T T) ConflictRange);

 intro...

cut (0 <= T)%R...

intro; generalize (no_conflict_Omega_t T H H2 H0 H1); intro;

 cut (e T = Die T T)...

intro; rewrite H4 in H3;

 elim

  (Rlt_irrefl (Die T T) (Rle_lt_trans (Die T T) ConflictRange (Die T T) r H3))...

left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...

Qed.



End trajectory.

