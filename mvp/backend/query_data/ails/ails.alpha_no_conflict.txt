
Require Import Bool.
Require Import Reals.
Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)
Require Import rrho.
(* rrho:
Require Import Reals.
Require Import trajectory_const.

Definition rho (h : TypeSpeed) : R := (g * (tan MaxBank / h))%R.
Definition r (h : TypeSpeed) : R := (h / rho h)%R.
Definition rho_ub (h : TypeSpeed) : R := (g * (tan_ub_MaxBank / h))%R.
Definition rho_lb (h : TypeSpeed) : R := (g * (tan_lb_MaxBank / h))%R.

Lemma TypeSpeed_pos : forall h : TypeSpeed, (0 < h)%R.

Lemma g_pos : (0 < g)%R.

Lemma rho_ub_0 : forall h : TypeSpeed, (rho h < rho_ub h)%R.

Lemma rho_lb_0 : forall h : TypeSpeed, (rho_lb h < rho h)%R.

Definition r_ub (h : TypeSpeed) : R := (h / rho_lb h)%R.
Definition r_lb (h : TypeSpeed) : R := (h / rho_ub h)%R.

Lemma tan_lb_MaxBank_pos : (0 < tan_lb_MaxBank)%R.

Lemma tan_ub_MaxBank_pos : (0 < tan_ub_MaxBank)%R.

Lemma rho_lb_pos : forall h : TypeSpeed, (0 < rho_lb h)%R.

Lemma rho_pos : forall h : TypeSpeed, (0 < rho h)%R.

Lemma rho_ub_pos : forall h : TypeSpeed, (0 < rho_ub h)%R.

Lemma r_ub_0 : forall h : TypeSpeed, (r h < r_ub h)%R.

Lemma r_lb_0 : forall h : TypeSpeed, (r_lb h < r h)%R.

Lemma rho_PI2 : forall h : TypeSpeed, (rho h <= PI / 2)%R.

Lemma rho_strict_decreasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (rho h2 < rho h1)%R.

Lemma r_stric_increasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (r h1 < r h2)%R. *)
Require Import trajectory_def.
(* trajectory_def:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.

Record Trajectory : Type := mkTrajectory
  {x : Differential;
   y : Differential;
   theta : Differential;
   phi : Differential;
   h : TypeSpeed;
   cond_x :
    forall t : R, derive_pt x t (cond_diff x t) = (h * cos (theta t))%R;
   cond_y :
    forall t : R, derive_pt y t (cond_diff y t) = (h * sin (theta t))%R;
   cond_phi : forall t : R, (- MaxBank <= phi t <= MaxBank)%R;
   cond_theta :
    forall t : R,
    derive_pt theta t (cond_diff theta t) = (g * (tan (phi t) / h))%R}.

Record EvaderTrajectory : Type := mkEvaderTrajectory
  {tr : Trajectory;
   tr_cond1 : forall t : R, x tr t = (x tr 0 + h tr * t)%R;
   tr_cond2 : forall t : R, y tr t = y tr 0%R;
   tr_cond3 : forall t : R, theta tr t = 0%R;
   tr_cond4 : forall t : R, phi tr t = 0%R}.

Lemma init_tr_derivable_x :
 forall h : TypeSpeed, derivable (fun t : R => (h * t)%R).

Lemma init_tr_derivable_y :
 forall h : TypeSpeed, derivable (fun t : R => 0%R).

Lemma init_tr_cond_x :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => (h * t)%R) t (init_tr_derivable_x h t) =
 (h * cos ((fun t : R => 0) t))%R.

Lemma init_tr_cond_y :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (h * sin ((fun t : R => 0) t))%R.

Lemma init_tr_cond_phi :
 forall t : R,
 (- MaxBank <= (fun t : R => 0) t)%R /\ ((fun t : R => 0) t <= MaxBank)%R.

Lemma fct_der1 : forall t : R, derivable_pt (fun t : R => 0%R) t.

Lemma init_tr_cond_theta :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (fun t : R => (g * (tan 0 / h))%R) t.

Definition init_tr (h : TypeSpeed) : Trajectory :=
  mkTrajectory
    (mkDifferential (fun t : R => (h * t)%R) (init_tr_derivable_x h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h)) h
    (init_tr_cond_x h) (init_tr_cond_y h) init_tr_cond_phi
    (init_tr_cond_theta h).

Lemma MaxBank_encadr : (0 < MaxBank < PI / 4)%R.

Lemma dtheta_rho :
 forall (tr : Trajectory) (t : R),
 (- rho (h tr) <= derive_pt (theta tr) t (cond_diff (theta tr) t) <=
  rho (h tr))%R. *)
Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)
Require Import ycngftys.
(* ycngftys:
Section ycngftys.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.
Require Import constants.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition xi : R -> R := x intr.
Definition yi : R -> R := y intr.
Definition vi : TypeSpeed := h intr.
Definition xP (t : R) : R := (xi t - xi 0)%R.
Definition yP (t : R) : R := (yi t - yi 0)%R.
Definition u (eps : posreal) (t : R) : R :=
  sqrt (Rsqr (xP t) + Rsqr (yP t) + Rsqr eps).
Definition u0 (t : R) : R := sqrt (Rsqr (xP t) + Rsqr (yP t)).

Lemma xi_derivable : derivable xi.

Lemma yi_derivable : derivable yi.

Lemma xP_derivable : derivable xP.

Lemma yP_derivable : derivable yP.

Lemma d_u : forall eps : posreal, derivable (fun t : R => u eps t).

Lemma fct_der2 :
 forall (eps : posreal) (t : R), derivable_pt (fun y : R => Rsqr (u eps y)) t.

Lemma D_Rsqr_u_epsilon_1 :
 forall (eps : posreal) (t : R),
 derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) =
 (2 * u eps t * derive_pt (u eps) t (d_u eps t))%R. 

Lemma xP_derive :
 forall t : R,
 derive_pt xP t (xP_derivable t) = derive_pt xi t (xi_derivable t).

Lemma yP_derive :
 forall t : R,
 derive_pt yP t (yP_derivable t) = derive_pt yi t (yi_derivable t).

Lemma fct_der3 :
 forall (eps : posreal) (t : R),
 derivable_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t.

Lemma D_Rsqr_u_epsilon_2 :
 forall (eps : posreal) (t : R),
 (derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) <= 2 * u0 t * vi)%R.

Lemma u_stric_pos : forall (eps : posreal) (t : R), (0 < u eps t)%R.

Lemma u_pos : forall (eps : posreal) (t : R), (0 <= u eps t)%R.

Lemma u0_pos : forall t : R, (0 <= u0 t)%R.

Lemma Rsqr_u_epsilon :
 forall (eps : posreal) (t : R), Rsqr (u eps t) = (Rsqr (u0 t) + Rsqr eps)%R.

Lemma u0_u_epsilon : forall (eps : posreal) (t : R), (u0 t <= u eps t)%R.

Lemma u_epsilon_le_v :
 forall (eps : posreal) (t : R), (derive_pt (u eps) t (d_u eps t) <= vi)%R.

Lemma vit_derivable : derivable (fun t : R => (vi * t)%R).

Lemma derive_vit :
 forall t : R, derive_pt (fun t : R => (vi * t)%R) t (vit_derivable t) = vi.

Lemma u_epsilon_le_vt :
 forall (eps : posreal) (t : R), (0 <= t)%R -> (u eps t - eps <= vi * t)%R.

Lemma Rsqr_u :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + 2 * eps * vi * t)%R.

Lemma Rsqr_u_Rsqr_vt :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + eps)%R.

Theorem YCNGFTYS :
 forall t : R,
 (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.

End ycngftys. *)
Require Import ycngstys.
(* ycngstys:
Section ycngstys.

Require Import Reals.
Require Import trajectory_def.
Require Import trajectory_const.
Require Import constants.
Require Import ycngftys.
Require Import rrho.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition thetat : R -> R := theta intr.
Definition Rs (t : R) : R :=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)).

Axiom
  alphas_exists :
    { f : Differential_D2 |
       forall t : R,
       xi intr t = (Rs t * cos (f t) + xi intr 0)%R /\
       yi intr t = (Rs t * sin (f t) + yi intr 0)%R }.

Definition alphas := let (a,_) := alphas_exists in a.

Lemma alphas_def :
 forall t : R,
 xi intr t = (Rs t * cos (alphas t) + xi intr 0)%R /\
 yi intr t = (Rs t * sin (alphas t) + yi intr 0)%R.

Lemma Rsx : forall t : R, xi intr t = (xi intr 0 + Rs t * cos (alphas t))%R.

Lemma Rsy : forall t : R, yi intr t = (yi intr 0 + Rs t * sin (alphas t))%R.

Lemma Rs_x :
 forall t : R,
 cos (alphas t) <> 0%R -> Rs t = ((xi intr t - xi intr 0) / cos (alphas t))%R.

Lemma Rs_y :
 forall t : R,
 sin (alphas t) <> 0%R -> Rs t = ((yi intr t - yi intr 0) / sin (alphas t))%R.

Lemma Rs_derivable : derivable Rs.

Definition alphas_p : R -> R := d2 alphas.

Lemma fct_der4 :
 forall t : R,
 derivable_pt ((Rs * comp cos alphas_p)%F + fct_cte (xi intr 0)) t.

Lemma Dxi :
 forall t : R,
 derive_pt (xi intr) t (xi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma Dyi :
 forall t : R,
 derive_pt (yi intr) t (yi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma DRs_cos :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * cos (thetat t))%R.

Lemma DRs_sin :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t))%R.

Lemma eq_plus_eq_is_eq :
 forall x y z t : R, x = y -> z = t -> (x + z)%R = (y + t)%R.

Lemma DRs :
 forall t : R,
 derive_pt Rs t (Rs_derivable t) = (vi intr * cos (thetat t - alphas t))%R.

Lemma Rs_alphas :
 forall t : R,
 (Rs t * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t - alphas t))%R.

Lemma fct_der5 :
 forall t : R,
 derivable_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R)
   t.

Lemma D_Rs_alphas1 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (derive_pt Rs t (Rs_derivable t) * derive_pt alphas t (cond_D1 alphas t) +
  Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma thetat_derivable : derivable thetat.

Lemma D_Rs_alphas2 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (vi intr * cos (thetat t - alphas t) *
  (derive_pt thetat t (thetat_derivable t) -
   derive_pt alphas t (cond_D1 alphas t)))%R.

Lemma D_Rs_2 :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) *
  (2 * derive_pt alphas t (cond_D1 alphas t) -
   derive_pt thetat t (thetat_derivable t)))%R =
 (- Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma Rsqr_DRs :
 forall t : R,
 (Rsqr (derive_pt Rs t (Rs_derivable t)) +
  Rsqr (Rs t) * Rsqr (derive_pt alphas t (cond_D1 alphas t)))%R =
 Rsqr (vi intr).

Lemma Rs_pos : forall t : R, (0 <= Rs t)%R.

Lemma Rs_0 : Rs 0 = 0%R.

Lemma D_Rs_0 : (0 <= derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma eq_sym : forall x y : R, x = y -> y = x.

Lemma D_Rs_0_strong : (0 < derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma D_alphas_0 :
 (2 * derive_pt alphas 0 (cond_D1 alphas 0))%R =
 derive_pt thetat 0 (thetat_derivable 0%R).

Lemma D_Rs_pos_non_null :
 forall t : R,
 (0 < t)%R ->
 (forall x : R, (0 < x < t)%R -> (0 < derive_pt Rs x (Rs_derivable x))%R) ->
 (0 < Rs t)%R.

Axiom
  D_Rs_pos :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R -> (0 < derive_pt Rs t (Rs_derivable t))%R.

Axiom
  D_abs_alpha :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R ->
    (- rho (vi intr) / 2 <= derive_pt alphas t (cond_D1 alphas t))%R /\
    (derive_pt alphas t (cond_D1 alphas t) <= rho (vi intr) / 2)%R.

Definition F (t : R) : R :=
  (2 * (vi intr / rho (vi intr)) * sin (rho (vi intr) * (t / 2)))%R.

Lemma F_derivable : derivable F.

Lemma D_F :
 forall t : R,
 derive_pt F t (F_derivable t) = (vi intr * cos (rho (vi intr) * (t / 2)))%R.

Lemma D_F_Rsqr_v :
 forall t : R,
 (Rsqr (derive_pt F t (F_derivable t)) +
  Rsqr (rho (vi intr) / 2) * Rsqr (F t))%R = Rsqr (vi intr).

Definition G (t : R) : R := (Rs t - F t)%R.

Lemma G_derivable : derivable G.

Lemma D_G_alphas :
 forall t : R,
 (derive_pt G t (G_derivable t) *
  (derive_pt Rs t (Rs_derivable t) + derive_pt F t (F_derivable t)))%R =
 (- Rsqr (derive_pt alphas t (cond_D1 alphas t)) * G t * (Rs t + F t) +
  Rsqr (F t) *
  (Rsqr (rho (vi intr) / 2) - Rsqr (derive_pt alphas t (cond_D1 alphas t))))%R.

Lemma Rlt_1_PI2 : (1 < PI / 2)%R.

Lemma D_G_pos :
 forall t : R,
 (0 <= t)%R ->
 (t < 2 / rho (vi intr))%R ->
 (G t <= 0)%R -> (0 <= derive_pt G t (G_derivable t))%R.

Lemma G_0 : G 0 = 0%R.

Axiom
  G_pos :
    forall t : R, (0 <= t)%R -> (t < 2 / rho (vi intr))%R -> (0 <= G t)%R.

Theorem YCNGSTYS :
 forall t : R,
 (0 <= t)%R ->
 (rho (vi intr) * t < 2)%R ->
 (2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)))%R.

End ycngstys. *)
Require Import ails_def.
(* ails_def:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.

Record Bank : Type := mkBank
  {r :> R; cond1 : (- toDeg MaxBank <= r)%R; cond2 : (r <= toDeg MaxBank)%R}.

Record State : Type := mkState {xt : R; yt : R; heading : R; bank : Bank}.

Definition intruderSpeed : TypeSpeed := V.
Definition evaderSpeed : TypeSpeed := V. *)
Require Import math_prop.
(* math_prop:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import constants.
Require Import Omega.

Axiom
  Math_prop_alarm_1 :
    forall (a l : R) (T : TimeT),
    (MinDistance T <= l)%R ->
    (l <= MaxDistance T)%R ->
    (0 <= a)%R ->
    (a <= MinBeta)%R ->
    (Rsqr (l * cos a - v V * T) + Rsqr (l * sin a) <= Rsqr AlertRange)%R.

Axiom
  Math_prop_no_conflict_1 :
    forall (a l x y : R) (T : TimeT),
    (MinDistance T <= l)%R ->
    (l <= MaxDistance T)%R ->
    (MinBeta <= a)%R ->
    (a <= PI / 2)%R ->
    (l * sin a + r_V * (cos (rho_V * T) - 1) <= y)%R ->
    (r_V * sin (rho_V * T) - l * cos a <= x)%R ->
    (Rsqr ConflictRange < Rsqr x + Rsqr y)%R.

Lemma MinBeta_pos : (0 < MinBeta)%R.

Lemma Math_prop_y_a_PI2 :
 forall (a l : R) (T : TimeT),
 (MinBeta <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l)%R ->
 (l * sin MinBeta + r_V * (cos (rho_V * T) - 1) <=
  l * sin a + r_V * (cos (rho_V * T) - 1))%R. 

Lemma Math_prop_approx_y_a_PI2 :
 forall (a l1 l2 : R) (T : TimeT),
 (0 <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l1)%R ->
 (l1 <= l2)%R ->
 (l1 * sin_lb a + r_ub V * (cos_lb (rho_ub V * MaxT) - 1) <=
  l2 * sin a + r_V * (cos (rho_V * T) - 1))%R.

Lemma Math_prop_x_a_PI2 :
 forall (a l : R) (T : TimeT),
 (MinBeta <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l)%R ->
 (r_V * sin (rho_V * T) - l * cos MinBeta <=
  r_V * sin (rho_V * T) - l * cos a)%R.

Lemma Math_prop_approx_x_a_PI2 :
 forall (a l1 l2 : R) (T : TimeT),
 (0 <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l1)%R ->
 (l1 <= l2)%R ->
 (r_lb V * sin_lb (rho_lb V * MinT) - l2 * cos_ub a <=
  r_V * sin (rho_V * T) - l1 * cos a)%R.

Lemma Math_prop_no_conflict_2 :
 forall (a l x y : R) (T : TimeT),
 (MinDistance T <= l)%R ->
 (l <= MaxDistance T)%R ->
 (3 * (PI / 2) <= a)%R ->
 (a <= 2 * PI - MinBeta)%R ->
 (y <= l * sin a - r_V * (cos (rho_V * T) - 1))%R ->
 (r_V * sin (rho_V * T) - l * cos a <= x)%R ->
 (Rsqr ConflictRange < Rsqr x + Rsqr y)%R.

Lemma Math_prop_alarm_2 :
 forall (a l : R) (T : TimeT),
 (MinDistance T <= l)%R ->
 (l <= MaxDistance T)%R ->
 (2 * PI - MinBeta <= a)%R ->
 (a <= 2 * PI)%R ->
 (Rsqr (l * cos a - v V * T) + Rsqr (l * sin a) <= Rsqr AlertRange)%R. *)
Section alpha_no_conflict.

Require Import tau.
(* tau:
Require Import Reals.
Require Import ails_def.
Require Import trajectory_const.

Unset Standard Proposition Elimination Names.

Definition dx (intruder evader : State) (t : R) : R :=
  (xt intruder + t * intruderSpeed * cosd (heading intruder) -
   (xt evader + t * evaderSpeed))%R.
Definition dy (intruder evader : State) (t : R) : R :=
  (yt intruder + t * intruderSpeed * sind (heading intruder) - yt evader)%R.
Definition dxdt (intruder : State) : R :=
  (intruderSpeed * cosd (heading intruder) - evaderSpeed)%R.
Definition dydt (intruder : State) : R :=
  (intruderSpeed * sind (heading intruder))%R.
Definition RR (intruder evader : State) (t : R) : R :=
  sqrt (Rsqr (dx intruder evader t) + Rsqr (dy intruder evader t)).
Definition div_tau (intruder evader : State) : R :=
  (Rsqr (dxdt intruder) + Rsqr (dydt intruder))%R.

Lemma Req_EM_var : forall r1 r2 : R, {r1 = r2} + {r1 <> r2}. 

Definition tau (intruder evader : State) (t : R) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dx intruder evader t * dxdt intruder +
        dy intruder evader t * dydt intruder) / div_tau intruder evader)%R
  end.  
Definition tmin (intruder evader : State) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dxdt intruder * (xt intruder - xt evader) +
        dydt intruder * (yt intruder - yt evader)) / 
       div_tau intruder evader)%R
  end.

Lemma tau_tmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader t = (tmin intruder evader - t)%R.

Definition Ax2_R (intruder : State) : R :=
  (Rsqr (sind (heading intruder) * intruderSpeed) +
   Rsqr (- evaderSpeed + cosd (heading intruder) * intruderSpeed))%R.

Lemma Ax2_R_pos : forall intruder : State, (0 <= Ax2_R intruder)%R.

Definition Bx_R (intruder evader : State) : R :=
  (-2 * (yt evader * sind (heading intruder) * intruderSpeed) +
   2 * (yt intruder * sind (heading intruder) * intruderSpeed) -
   2 * (cosd (heading intruder) * xt evader * intruderSpeed) +
   2 * (cosd (heading intruder) * xt intruder * intruderSpeed) +
   2 * (xt evader * evaderSpeed) - 2 * (xt intruder * evaderSpeed))%R.

Definition C_R (intruder evader : State) : R :=
  (Rsqr (yt intruder - yt evader) + Rsqr (xt intruder - xt evader))%R.

Lemma Rsqr_R :
 forall (intruder evader : State) (t : R),
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr t + Bx_R intruder evader * t + C_R intruder evader)%R.

Definition Rsqr_Rmin (intruder evader : State) : R :=
  match Req_EM_var (Ax2_R intruder) 0 with
  | left _ => 0%R
  | right _ =>
      ((4 * Ax2_R intruder * C_R intruder evader -
        Rsqr (Bx_R intruder evader)) / (4 * Ax2_R intruder))%R
  end.

Lemma tmin_0 :
 forall intruder evader : State,
 div_tau intruder evader <> 0%R ->
 tmin intruder evader = (- Bx_R intruder evader / (2 * Ax2_R intruder))%R.

Lemma Ax2_R_0_div_tau :
 forall intruder evader : State,
 div_tau intruder evader = 0%R -> Ax2_R intruder = 0%R.

Lemma div_tau_0_Ax2_R :
 forall intruder evader : State,
 Ax2_R intruder = 0%R -> div_tau intruder evader = 0%R.

Lemma R_Rmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr (t - tmin intruder evader) +
  Rsqr_Rmin intruder evader)%R.

Lemma dx_dxdt :
 forall (intruder evader : State) (t : R),
 (xt intruder - xt evader + t * dxdt intruder)%R = dx intruder evader t.

Lemma dy_dydt :
 forall (intruder evader : State) (t : R),
 (yt intruder - yt evader + t * dydt intruder)%R = dy intruder evader t.

Lemma R_equal_when_zero :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader = 0%R ->
 RR intruder evader t1 = RR intruder evader t2.

Lemma RR_pos :
 forall (intruder evader : State) (t : R), (0 <= RR intruder evader t)%R.

Lemma derivative_eq_zero_tmin :
 forall (intruder evader : State) (t : R),
 (RR intruder evader (tmin intruder evader) <= RR intruder evader t)%R.

Lemma derivative_eq_zero_min :
 forall (intruder evader : State) (t1 t2 : R),
 (RR intruder evader (t1 + tau intruder evader t1) <=
  RR intruder evader (t1 + t2))%R.

Lemma asymptotic_decrease_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (t2 <= tmin intruder evader)%R ->
 (t1 <= t2)%R -> (RR intruder evader t2 <= RR intruder evader t1)%R.

Lemma asymptotic_decrease_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (t2 <= tau intruder evader t)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t2) <= RR intruder evader (t + t1))%R.

Lemma asymptotic_increase_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (tmin intruder evader <= t1)%R ->
 (t1 <= t2)%R -> (RR intruder evader t1 <= RR intruder evader t2)%R.

Lemma asymptotic_increase_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (tau intruder evader t <= t1)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t1) <= RR intruder evader (t + t2))%R.

Lemma tau_equal_when_zero :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader = 0%R -> tau intruder evader t = 0%R.

Lemma asymptotic_tau_gt :
 forall (intruder evader : State) (t dt : R),
 (0 <= dt)%R ->
 (RR intruder evader (t + dt) < RR intruder evader t)%R ->
 (0 < tau intruder evader t)%R.

Lemma tau_is_uniform :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader (t1 + t2) = (tau intruder evader t1 - t2)%R.

Lemma tau_gt_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t < tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t < tau intruder evader t1)%R.

Lemma tau_ge_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t <= tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t <= tau intruder evader t1)%R. *)
Require Import ails.
(* ails:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.
Require Import ails_def.
Require Import tau.
Require Import Omega.

Unset Standard Proposition Elimination Names.

Fixpoint rest (p r s n : nat) {struct n} : nat :=
  match n with
  | O => r
  | S n' =>
      match s with
      | O => 0
      | S O => rest p 0 p n'
      | S s' => rest p (S r) s' n'
      end
  end.
  
Definition mod_ (m n : nat) : nat := rest n 0 n m.

Lemma mod_eq_0 : forall m : nat, mod_ 0 m = 0.

Definition trkrate (phi : Bank) : R :=
  toDeg (g * (tand phi / v intruderSpeed)).

Lemma cond1_0 : (- toDeg MaxBank <= 0)%R.

Lemma cond2_0 : (0 <= toDeg MaxBank)%R.

Lemma trkrate0 : trkrate (mkBank 0 cond1_0 cond2_0) = 0%R.

Definition distance (s1 s2 : State) : R :=
  sqrt (Rsqr (xt s2 - xt s1) + Rsqr (yt s2 - yt s1)).

Lemma distance_sym : forall s1 s2 : State, distance s1 s2 = distance s2 s1.

Definition alerting_distance (s1 s2 : State) : Prop :=
  (distance s1 s2 <= AlertRange)%R.

Definition conflict_distance (s1 s2 : State) : Prop :=
  (distance s1 s2 <= ConflictRange)%R.

Definition chkrange (range tpred : R) : Prop :=
  (range <= AlertRange)%R /\ (tpred <= AlertTime)%R.

Definition chktrack (intruder evader : State) (tpred : R) : Prop :=
  let tau := tau intruder evader 0 in
  match Rle_dec tau 0 with
  | left _ => chkrange (RR intruder evader 0) tpred
  | right _ =>
      match Rlt_dec AlertTime (tpred + tau) with
      | left _ => (RR intruder evader AlertTime <= AlertRange)%R
      | right _ => (RR intruder evader tau <= AlertRange)%R
      end
  end.

Definition arc_loop (intruder evader : State) (arcrad trkrate : R)
  (idtrk iarc : nat) : Prop :=
  match iarc with
  | S p => False
  | O =>
      let tpred := (INR iarc * tstep)%R in
      let xloc := (xt evader + v evaderSpeed * tpred)%R in
      let yloc := yt evader in
      let xtrk :=
        match Rlt_le_dec 0 trkrate with
        | left _ =>
            (xt intruder +
             arcrad *
             (sind (heading intruder + trkrate * tpred) -
              sind (heading intruder)))%R
        | right _ =>
            (xt intruder +
             arcrad *
             (sind (heading intruder) - sind (heading intruder) +
              trkrate * tpred))%R
        end in
      let ytrk :=
        match Rlt_le_dec 0 trkrate with
        | left _ =>
            (yt intruder +
             arcrad *
             (cosd (heading intruder) -
              cosd (heading intruder + trkrate * tpred)))%R
        | right _ =>
            (yt intruder +
             arcrad *
             (cosd (heading intruder + trkrate * tpred) -
              cosd (heading intruder)))%R
        end in
      match mod_ iarc idtrk with
      | O =>
          let tantrk := (heading intruder + tpred * trkrate)%R in
          let int := mkState xtrk ytrk tantrk (bank intruder) in
          let eva := mkState xloc yloc (heading evader) (bank evader) in
          chktrack int eva tpred
      | _ =>
          let range := sqrt (Rsqr (xtrk - xloc) + Rsqr (ytrk - yloc)) in
          chkrange range tpred
      end
  end.

Definition ails_alert (intruder evader : State) : Prop :=
  let phi := bank intruder in
  let trkrate := trkrate phi in
  match Req_EM_var trkrate 0 with
  | left _ => chktrack intruder evader 0
  | right _ =>
      let arcrad := (Rsqr (v intruderSpeed) / (g * tand (r phi)))%R in
      let idtrk :=
        match Rle_dec 3 trkrate with
        | left _ => 1
        | right _ =>
            match Rle_dec (3 / 2) trkrate with
            | left _ => 2
            | right _ =>
                match Rle_dec (3 / 4) trkrate with
                | left _ => 4
                | right _ => 8
                end
            end
        end in
      arc_loop intruder evader arcrad trkrate idtrk 0
  end.

Lemma R_distance :
 forall intruder evader : State,
 RR intruder evader 0 = distance intruder evader.

Lemma step1 :
 forall evader intruder : State,
 alerting_distance evader intruder -> chktrack intruder evader 0.

Lemma step2 :
 forall (evader intruder : State) (x : nat),
 (distance evader intruder <= AlertRange)%R ->
 trkrate (bank intruder) <> 0%R ->
 arc_loop intruder evader (Rsqr intruderSpeed / (g * tand (bank intruder)))
   (trkrate (bank intruder)) x 0.

Theorem alarm_at_alerting_distance :
 forall evader intruder : State,
 alerting_distance evader intruder -> ails_alert intruder evader. *)
Require Import trajectory.
(* trajectory:
Section trajectory.

Require Import Bool.
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.
Require Import constants.
Require Import ycngftys.
Require Import ycngstys.
Require Import Omega.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.
Variable T : TimeT.

Lemma thetat_derivable : derivable (thetat intr).

Definition xe : R := x (tr evad) T.
Definition ye : R := y (tr evad) T.
Definition ve : R := v (h (tr evad)).
Definition r_vi : R := r (vi intr).
Definition rho_vi : R := rho (vi intr).
Definition Die (ti te : R) : R :=
  sqrt
    (Rsqr (xi intr ti - x (tr evad) te) + Rsqr (yi intr ti - y (tr evad) te)).
Definition conflict (t : R) : bool :=
  match Rle_dec (Die t t) ConflictRange with
  | left _ => true
  | right _ => false
  end.

Lemma Dx :
 forall t : R,
 derive_pt (xi intr) t (xi_derivable intr t) =
 (vi intr * cos (thetat intr t))%R.

Lemma Dy :
 forall t : R,
 derive_pt (yi intr) t (yi_derivable intr t) =
 (vi intr * sin (thetat intr t))%R.

Axiom r_sin_rho : (ConflictRange < r_vi * sin rho_vi)%R.

Definition l : R := Die 0 T.
Definition d : R := Die 0 0.

Axiom
  beta_exists :
    { beta : R |
       xe = (l * cos beta + xi intr 0)%R /\
       ye = (yi intr 0 - l * sin beta)%R /\
       (0 <= beta + thetat intr 0 < 2 * PI)%R }.

Definition beta := let (a,_) := beta_exists in a.

Lemma beta_def :
 xe = (l * cos beta + xi intr 0)%R /\
 ye = (yi intr 0 - l * sin beta)%R /\ (0 <= beta + thetat intr 0 < 2 * PI)%R.

Definition Omega (a : R) : bool :=
  match Rle_dec (PI / 2) a with
  | left _ =>
      match Rle_dec a (3 * (PI / 2)) with
      | left _ => true
      | right _ => false
      end
  | right _ => false
  end.

Lemma xe_0 : xe = (l * cos beta + xi intr 0)%R.

Lemma ye_0 : ye = (yi intr 0 - l * sin beta)%R.

Lemma d_l_beta :
 Rsqr d = (Rsqr (ve * T) + Rsqr l - 2 * ve * T * l * cos beta)%R.

Definition yp (t : R) : R :=
  (- sin (thetat intr 0) * (xi intr t - xe) +
   cos (thetat intr 0) * (yi intr t - ye))%R.

Hint Resolve xi_derivable yi_derivable: diff.

Lemma yp_derivable : derivable yp.
Hint Resolve yp_derivable: diff.

Definition xp (t : R) : R :=
  (cos (thetat intr 0) * (xi intr t - xe) +
   sin (thetat intr 0) * (yi intr t - ye))%R.

Lemma xp_derivable : derivable xp.
Hint Resolve xp_derivable: diff.

Definition Rsqr_evader_distance (t : R) : R :=
  (Rsqr (xi intr t - xe) + Rsqr (yi intr t - ye))%R.

Lemma Rsqr_evader_distance_derivable : derivable Rsqr_evader_distance.
Hint Resolve Rsqr_evader_distance_derivable: diff.

Definition Rsqr_intruder_distance (t : R) : R :=
  (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0))%R.

Lemma Rsqr_intruder_distance_derivable : derivable Rsqr_intruder_distance.
Hint Resolve Rsqr_intruder_distance_derivable: diff.

Lemma Rsqr_evader_distance_pos :
 forall t : R, (0 <= Rsqr_evader_distance t)%R.

Lemma Rsqr_intruder_distance_pos :
 forall t : R, (0 <= Rsqr_intruder_distance t)%R.

Definition e (t : R) : R := sqrt (Rsqr_evader_distance t).
Definition i (t : R) : R := sqrt (Rsqr_intruder_distance t).

Lemma conflict_T_e_0 : conflict T = true -> (e T <= ConflictRange)%R. 

Lemma conflict_T_e_1 : (e T <= ConflictRange)%R -> conflict T = true.

Lemma L : Rsqr l = (Rsqr (xe - xi intr 0) + Rsqr (ye - yi intr 0))%R.

Lemma L_intruder : forall t : R, (l <= e t + i t)%R.

Lemma l_is_pos : (0 <= l)%R.

Lemma L_e : forall t : R, (e t <= l + i t)%R.

Lemma L_i : forall t : R, (i t <= l + e t)%R.

Lemma theta_inv :
 forall t : R,
 (0 <= t)%R ->
 (thetat intr 0 - rho_vi * t <= thetat intr t)%R /\
 (thetat intr t <= thetat intr 0 + rho_vi * t)%R.

Lemma rho_t_pos : forall t : R, (0 <= t)%R -> (0 <= rho_vi * t)%R.

Lemma rho_t_le :
 forall t1 t2 : R, (t1 <= t2)%R -> (rho_vi * t1 <= rho_vi * t2)%R.

Lemma Dyp :
 forall t : R,
 derive_pt yp t (yp_derivable t) =
 (v (vi intr) * sin (thetat intr t - thetat intr 0))%R.

Lemma Dyp0_PI2 :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI / 2)%R ->
 (- (vi intr * sin (rho_vi * t)) <= derive_pt yp t (yp_derivable t) <=
  vi intr * sin (rho_vi * t))%R.

Lemma yp0 : yp 0 = (l * sin (thetat intr 0 + beta))%R.

Definition hy (t : R) : R := (r_vi * cos (rho_vi * t))%R.

Lemma hy_derivable : derivable hy.

Lemma Dhy :
 forall t : R,
 derive_pt hy t (hy_derivable t) = (- vi intr * sin (rho_vi * t))%R.

Lemma ypt :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI / 2)%R -> (hy t - hy 0 <= yp t - yp 0 <= hy 0 - hy t)%R.

Lemma ypt_PI2 :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI / 2)%R ->
 (l * sin (beta + thetat intr 0) + r_vi * (cos (rho_vi * t) - 1) <= yp t)%R /\
 (yp t <= l * sin (beta + thetat intr 0) - r_vi * (cos (rho_vi * t) - 1))%R.

Lemma Dxp :
 forall t : R,
 derive_pt xp t (xp_derivable t) =
 (vi intr * cos (thetat intr t - thetat intr 0))%R.

Lemma Dx0_PI :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R ->
 (vi intr * cos (rho_vi * t) <= derive_pt xp t (xp_derivable t))%R.

Lemma xp0 : xp 0 = (- l * cos (thetat intr 0 + beta))%R.

Definition hx (t : R) : R := (r_vi * sin (rho_vi * t))%R.

Lemma hx_derivable : derivable hx.

Lemma Dhx :
 forall t : R,
 derive_pt hx t (hx_derivable t) = (vi intr * cos (rho_vi * t))%R.

Lemma xpt :
 forall t : R, (0 <= t)%R -> (rho_vi * t <= PI)%R -> (hx t <= xp t - xp 0)%R.

Lemma r_sin_pos :
 forall t : R,
 (0 <= t)%R -> (rho_vi * t <= PI)%R -> (0 <= r_vi * sin (rho_vi * t))%R.

Lemma xpt_pos :
 forall t : R, (0 <= t)%R -> (rho_vi * t <= PI)%R -> (0 <= xp t - xp 0)%R.

Lemma xpt_PI :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R ->
 (r_vi * sin (rho_vi * t) - l * cos (beta + thetat intr 0) <= xp t)%R.

Lemma Omega_defeq :
 forall x : R, Omega x = true -> (PI / 2 <= x <= 3 * (PI / 2))%R.

Lemma neg_cos_var : forall x : R, cos (x - PI) = (- cos x)%R.

Lemma xp0_pos : Omega (beta + thetat intr 0) = true -> (0 <= xp 0)%R.

Lemma xpt_Omega :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R ->
 Omega (beta + thetat intr 0) = true -> (r_vi * sin (rho_vi * t) <= xp t)%R.

Lemma isometric_evader :
 forall t : R, Rsqr_evader_distance t = (Rsqr (xp t) + Rsqr (yp t))%R.

Lemma xpt_xp0 :
 forall t : R,
 (xp t - xp 0)%R =
 (cos (thetat intr 0) * (xi intr t - xi intr 0) +
  sin (thetat intr 0) * (yi intr t - yi intr 0))%R.

Lemma ypt_yp0 :
 forall t : R,
 (yp t - yp 0)%R =
 (- sin (thetat intr 0) * (xi intr t - xi intr 0) +
  cos (thetat intr 0) * (yi intr t - yi intr 0))%R.

Lemma isometric_intruder :
 forall t : R,
 Rsqr_intruder_distance t = (Rsqr (xp t - xp 0) + Rsqr (yp t - yp 0))%R.

Lemma majoration :
 forall t : R,
 (Rsqr (yp t) <= Rsqr_evader_distance t)%R /\
 (Rsqr (xp t) <= Rsqr_evader_distance t)%R.

Lemma YCNGFTYS_evader :
 forall t : R, (0 <= t)%R -> (l - v (vi intr) * t <= e t)%R.

Lemma YCNGSTYS_evader :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t < 2)%R -> (2 * r_vi * sin (rho_vi * (t / 2)) - l <= e t)%R.

Lemma xp_pos :
 forall t : R,
 (0 <= t)%R ->
 (rho_vi * t <= PI)%R -> Omega (beta + thetat intr 0) = true -> (0 <= xp t)%R.

Lemma no_conflict_xp_1_Omega :
 forall t : R,
 (1 <= t)%R ->
 (rho_vi * t <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true -> (ConflictRange < xp t)%R.

Lemma no_conflict_scenario_1_Omega :
 forall t : R,
 (1 <= t)%R ->
 (rho_vi * t <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true ->
 (Rsqr ConflictRange < Rsqr_evader_distance t)%R.

Lemma no_conflict_scenario_0_1s :
 forall t : R,
 (0 <= t)%R ->
 (t < 1)%R -> (ConflictRange + vi intr < l)%R -> (ConflictRange < e t)%R.

Lemma no_conflict_gt_max_t :
 forall t : R,
 let MaxDistance := (vi intr * t + ConflictRange)%R in
 (0 <= t)%R -> (MaxDistance < l)%R -> (ConflictRange < e t)%R.

Lemma no_conflict_lt_min_t :
 forall t : R,
 let MinDistance := (2 * r_vi * sin (rho_vi * (t / 2)) - ConflictRange)%R in
 (0 <= t)%R ->
 (0 <= rho_vi * t)%R ->
 (rho_vi * t < 2)%R -> (l < MinDistance)%R -> (ConflictRange < e t)%R.

Lemma no_conflict_Omega_t :
 forall t : R,
 (ConflictRange + vi intr < l)%R ->
 (0 <= t)%R ->
 (rho_vi * t <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true -> (ConflictRange < e t)%R.

Theorem no_conflict_gt_max :
 let MaxDistance := (vi intr * T + ConflictRange)%R in
 (MaxDistance < l)%R -> conflict T = false.

Theorem no_conflict_lt_min :
 let MinDistance := (2 * r_vi * sin (rho_vi * (T / 2)) - ConflictRange)%R in
 (0 <= rho_vi * T)%R ->
 (rho_vi * T < 2)%R -> (l < MinDistance)%R -> conflict T = false.

Theorem no_conflict_Omega :
 (ConflictRange + v (vi intr) < l)%R ->
 (rho_vi * T <= PI - rho_vi)%R ->
 Omega (beta + thetat intr 0) = true -> conflict T = false.

End trajectory. *)
Require Import measure2state.
(* measure2state:
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ails_def.
Require Import Omega.

Lemma cond1_sty :
 forall (tr : Trajectory) (t : R), (- toDeg MaxBank <= toDeg (phi tr t))%R.

Lemma cond2_sty :
 forall (tr : Trajectory) (t : R), (toDeg (phi tr t) <= toDeg MaxBank)%R.

Definition measure2state (tr : Trajectory) (t : R) : State :=
  mkState (x tr t) (y tr t) (toDeg (theta tr t))
    (mkBank (toDeg (phi tr t)) (cond1_sty tr t) (cond2_sty tr t)). *)
Require Import ails_trajectory.
(* ails_trajectory:
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ycngftys.
Require Import ycngstys.
Require Import tau.
Require Import ails.
Require Import trajectory.
Require Import measure2state.

Lemma d_distance :
 forall (intr : Trajectory) (evad : EvaderTrajectory),
 distance (measure2state (tr evad) 0) (measure2state intr 0) = d intr evad.

Lemma R_T :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h (tr evad) = V ->
 Rsqr (RR (measure2state intr 0) (measure2state (tr evad) 0) T) =
 (Rsqr (l intr evad T * cos (beta intr evad T + thetat intr 0) - V * T) +
  Rsqr (l intr evad T * sin (beta intr evad T + thetat intr 0)))%R. *)
Require Import alarm.
(* alarm:
Require Import Bool.
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ycngftys.
Require Import ycngstys.
Require Import ails_def.
Require Import math_prop.
Require Import tau.
Require Import ails.
Require Import trajectory.
Require Import measure2state.
Require Import ails_trajectory.

Unset Standard Proposition Elimination Names.

Lemma AlertRange_pos : (0 < AlertRange)%R.

Lemma conflict_beta_theta :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (beta intr evad T + thetat intr 0 <= MinBeta)%R \/
 (2 * PI - MinBeta < beta intr evad T + thetat intr 0)%R.

Lemma alarm_NOT_Omega_T :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (RR (measure2state intr 0) (measure2state (tr evad) 0) T <= AlertRange)%R.

Lemma alarm_NOT_Omega_tau :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 (RR (measure2state intr 0) (measure2state (tr evad) 0)
    (tau (measure2state intr 0) (measure2state (tr evad) 0) 0) <= AlertRange)%R.

Lemma alarm_NOT_Omega_AlertTime :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (AlertTime < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 (RR (measure2state intr 0) (measure2state (tr evad) 0) AlertTime <=
  AlertRange)%R.

Lemma chktrack_NOT_Omega_trkrate_eq_0 :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 conflict intr evad T = true ->
 (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 chktrack (measure2state intr 0) (measure2state (tr evad) 0) 0.

Theorem ails_alarm_tau_gt0 :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 Omega (beta intr evad T + thetat intr 0) = false ->
 (0 < tau (measure2state intr 0) (measure2state (tr evad) 0) 0)%R ->
 conflict intr evad T = true ->
 ails_alert (measure2state intr 0) (measure2state (tr evad) 0). *)

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.
Variable T : TimeT.

Definition Alpha (a : R) : bool :=
  let a1 :=
    ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
     (2 * ve evad * T))%R in
  let a2 := (l intr evad T * cos a)%R in
  match Rle_dec a1 a2 with
  | left _ => true
  | right _ => false
  end.

Lemma Alpha_d_AlertRange_0 :
 Alpha (beta intr evad T) = true -> (d intr evad <= AlertRange)%R.
Proof with trivial.
unfold Alpha in |- *;
 case
  (Rle_dec
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
      (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))); 
 intros...
unfold Rdiv in r; cut (0 < 2 * ve evad * T)%R...
intro;
 generalize
  (Rmult_le_compat_r (2 * ve evad * T)
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) *
      / (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))
     (Rlt_le 0 (2 * ve evad * T) H0) r); repeat rewrite Rmult_assoc;
 rewrite <- Rinv_l_sym...
rewrite Rmult_1_r; intro;
 generalize
  (Rplus_le_compat_l
     (Rsqr AlertRange -
      2 * l intr evad T * ve evad * T * cos (beta intr evad T))
     (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange)
     (l intr evad T * (cos (beta intr evad T) * (2 * (ve evad * T)))) H1);
 replace
  (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
   l intr evad T * (cos (beta intr evad T) * (2 * (ve evad * T))))%R with
  (Rsqr AlertRange)...
replace
 (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
  (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange))%R with
 (Rsqr (ve evad * T) + Rsqr (l intr evad T) -
  2 * ve evad * T * l intr evad T * cos (beta intr evad T))%R...
rewrite <- d_l_beta...
intro; apply Rsqr_incr_0_var...
left; apply AlertRange_pos...
ring...
ring...
repeat apply prod_neq_R0...
discrR...
red in |- *; intro; generalize (TypeSpeed_pos (h (tr evad))); intro;
 unfold ve in H1; rewrite H1 in H2; elim (Rlt_irrefl 0 H2)...
cut (0 < T)%R...
intro...
red in |- *; intro; rewrite H2 in H1; elim (Rlt_irrefl 0 H1)...
apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
repeat apply Rmult_lt_0_compat...
prove_sup0...
unfold ve in |- *; apply (TypeSpeed_pos (h (tr evad)))...
apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
elim diff_false_true...
Qed.

Lemma Alpha_d_AlertRange_1 :
 (d intr evad <= AlertRange)%R -> Alpha (beta intr evad T) = true.
Proof with trivial.
intros; unfold Alpha in |- *;
 case
  (Rle_dec
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
      (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))); 
 intro...
elim n; unfold Rdiv in |- *; cut (0 < 2 * ve evad * T)%R...
intro; apply Rmult_le_reg_l with (2 * ve evad * T)%R...
rewrite <-
 (Rmult_comm
    ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) *
     / (2 * ve evad * T))); repeat rewrite Rmult_assoc; 
 rewrite <- Rinv_l_sym...
rewrite Rmult_1_r;
 apply
  Rplus_le_reg_l
   with
     (Rsqr AlertRange -
      2 * l intr evad T * ve evad * T * cos (beta intr evad T))%R;
 replace
  (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
   (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange))%R with
  (Rsqr (ve evad * T) + Rsqr (l intr evad T) -
   2 * ve evad * T * l intr evad T * cos (beta intr evad T))%R...
rewrite <- d_l_beta;
 replace
  (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
   2 * (ve evad * (T * (l intr evad T * cos (beta intr evad T)))))%R with
  (Rsqr AlertRange)...
apply Rsqr_incr_1...
unfold d in |- *; unfold Die in |- *; apply sqrt_positivity;
 apply Rplus_le_le_0_compat; apply Rle_0_sqr...
left; apply AlertRange_pos...
ring...
ring...
repeat apply prod_neq_R0...
discrR...
red in |- *; intro; generalize (TypeSpeed_pos (h (tr evad))); intro;
 unfold ve in H1; rewrite H1 in H2; elim (Rlt_irrefl 0 H2)...
cut (0 < T)%R...
intro; red in |- *; intro; rewrite H2 in H1; elim (Rlt_irrefl 0 H1)...
apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
repeat apply Rmult_lt_0_compat;
 [ prove_sup0
 | unfold ve in |- *; apply (TypeSpeed_pos (h (tr evad)))
 | apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ] ]...
Qed.

Lemma Alpha_d_AlertRange_2 :
 Alpha (beta intr evad T) = false -> (AlertRange < d intr evad)%R.
Proof with trivial.
unfold Alpha in |- *;
 case
  (Rle_dec
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
      (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))); 
 intros...
elim diff_true_false...
unfold Rdiv in n; cut (0 < 2 * ve evad * T)%R...
intro...
cut
 (l intr evad T * cos (beta intr evad T) <
  (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) *
  / (2 * ve evad * T))%R...
intro;
 generalize
  (Rmult_lt_compat_r (2 * ve evad * T)
     (l intr evad T * cos (beta intr evad T))
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) *
      / (2 * ve evad * T)) H0 H1); repeat rewrite Rmult_assoc;
 rewrite <- Rinv_l_sym...
rewrite Rmult_1_r; intro;
 generalize
  (Rplus_lt_compat_l
     (Rsqr AlertRange -
      2 * l intr evad T * ve evad * T * cos (beta intr evad T))
     (l intr evad T * (cos (beta intr evad T) * (2 * (ve evad * T))))
     (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) H2);
 replace
  (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
   l intr evad T * (cos (beta intr evad T) * (2 * (ve evad * T))))%R with
  (Rsqr AlertRange)...
replace
 (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
  (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange))%R with
 (Rsqr (ve evad * T) + Rsqr (l intr evad T) -
  2 * ve evad * T * l intr evad T * cos (beta intr evad T))%R...
rewrite <- d_l_beta...
intro; apply Rsqr_incrst_0...
left; apply AlertRange_pos...
unfold d in |- *; unfold Die in |- *; apply sqrt_positivity;
 apply Rplus_le_le_0_compat; apply Rle_0_sqr...
ring...
ring...
repeat apply prod_neq_R0...
discrR...
red in |- *; intro; generalize (TypeSpeed_pos (h (tr evad))); intro;
 unfold ve in H2; rewrite H2 in H3; elim (Rlt_irrefl 0 H3)...
cut (0 < T)%R...
intro...
red in |- *; intro; rewrite H3 in H2; elim (Rlt_irrefl 0 H2)...
apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
auto with real...
repeat apply Rmult_lt_0_compat...
prove_sup0...
unfold ve in |- *; apply (TypeSpeed_pos (h (tr evad)))...
apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
Qed.

Lemma Alpha_d_AlertRange_3 :
 (AlertRange < d intr evad)%R -> Alpha (beta intr evad T) = false.
Proof with trivial.
intros; unfold Alpha in |- *;
 case
  (Rle_dec
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
      (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))); 
 intro...
unfold Rdiv in r; cut (0 < 2 * ve evad * T)%R...
intro;
 generalize
  (Rmult_le_compat_l (2 * ve evad * T)
     ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) *
      / (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))
     (Rlt_le 0 (2 * ve evad * T) H0) r)...
rewrite <-
 (Rmult_comm
    ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) *
     / (2 * ve evad * T))); repeat rewrite Rmult_assoc; 
 rewrite <- Rinv_l_sym...
rewrite Rmult_1_r; intro...
generalize
 (Rplus_le_compat_l
    (Rsqr AlertRange -
     2 * l intr evad T * ve evad * T * cos (beta intr evad T))
    (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange)
    (2 * (ve evad * (T * (l intr evad T * cos (beta intr evad T))))) H1)...
replace
 (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
  (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange))%R with
 (Rsqr (ve evad * T) + Rsqr (l intr evad T) -
  2 * ve evad * T * l intr evad T * cos (beta intr evad T))%R...
rewrite <- d_l_beta;
 replace
  (Rsqr AlertRange - 2 * l intr evad T * ve evad * T * cos (beta intr evad T) +
   2 * (ve evad * (T * (l intr evad T * cos (beta intr evad T)))))%R with
  (Rsqr AlertRange)...
intro...
generalize
 (Rsqr_incr_0_var (d intr evad) AlertRange H2
    (Rlt_le 0 AlertRange AlertRange_pos))...
intro...
elim (Rlt_irrefl (d intr evad) (Rle_lt_trans _ _ _ H3 H))...
ring...
ring...
repeat apply prod_neq_R0...
discrR...
red in |- *; intro; generalize (TypeSpeed_pos (h (tr evad))); intro;
 unfold ve in H1; rewrite H1 in H2; elim (Rlt_irrefl 0 H2)...
cut (0 < T)%R...
intro...
red in |- *; intro; rewrite H2 in H1; elim (Rlt_irrefl 0 H1)...
apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
repeat apply Rmult_lt_0_compat;
 [ prove_sup0
 | unfold ve in |- *; apply (TypeSpeed_pos (h (tr evad)))
 | apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ] ]...
Qed.

Axiom
  cos_beta_NOT_Alpha :
    Alpha (beta intr evad T) = false ->
    h intr = V ->
    h (tr evad) = V ->
    (MinDistance T <= l intr evad T)%R ->
    (l intr evad T <= MaxDistance T)%R ->
    (cos (beta intr evad T) <= cos MinBeta)%R.

Lemma tau_le_0_diverg :
 (tau (measure2state intr 0) (measure2state (tr evad) 0) 0 <= 0)%R ->
 (d intr evad <= RR (measure2state intr 0) (measure2state (tr evad) 0) T)%R.
Proof with trivial.
intro; rewrite <- d_distance; rewrite distance_sym; rewrite <- R_distance...
cut (0 <= T)%R...
intro;
 generalize
  (asymptotic_increase_tau (measure2state intr 0) (measure2state (tr evad) 0)
     0 0 T H H0); intro...
repeat rewrite Rplus_0_l in H1...
left; apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
Qed.

Lemma R_T_d_diff_0 :
 h (tr evad) = V ->
 (0 < l intr evad T)%R ->
 (d intr evad <= RR (measure2state intr 0) (measure2state (tr evad) 0) T)%R ->
 (cos (beta intr evad T + thetat intr 0) <= cos (beta intr evad T))%R.
Proof with trivial.
intros hyp_evad H...
cut (0 <= d intr evad)%R...
cut (0 <= RR (measure2state intr 0) (measure2state (tr evad) 0) T)%R...
intros...
generalize
 (Rsqr_incr_1 _ (RR (measure2state intr 0) (measure2state (tr evad) 0) T) H2
    H1 H0); intro...
rewrite R_T in H3...
rewrite (d_l_beta intr evad T) in H3...
unfold ve in H3...
rewrite hyp_evad in H3...
rewrite Rsqr_minus in H3...
repeat rewrite Rsqr_mult in H3...
rewrite cos2 in H3...
generalize
 (Rplus_le_compat_l (- Rsqr (l intr evad T) - Rsqr V * Rsqr T)
    (Rsqr V * Rsqr T + Rsqr (l intr evad T) -
     2 * V * T * l intr evad T * cos (beta intr evad T))
    (Rsqr (l intr evad T) *
     (1 - Rsqr (sin (beta intr evad T + thetat intr 0))) + 
     Rsqr V * Rsqr T -
     2 * (l intr evad T * cos (beta intr evad T + thetat intr 0)) * (V * T) +
     Rsqr (l intr evad T) * Rsqr (sin (beta intr evad T + thetat intr 0))) H3)...
replace
 (- Rsqr (l intr evad T) - Rsqr V * Rsqr T +
  (Rsqr V * Rsqr T + Rsqr (l intr evad T) -
   2 * V * T * l intr evad T * cos (beta intr evad T)))%R with
 (2 * V * T * l intr evad T * - cos (beta intr evad T))%R...
replace
 (- Rsqr (l intr evad T) - Rsqr V * Rsqr T +
  (Rsqr (l intr evad T) * (1 - Rsqr (sin (beta intr evad T + thetat intr 0))) +
   Rsqr V * Rsqr T -
   2 * (l intr evad T * cos (beta intr evad T + thetat intr 0)) * (V * T) +
   Rsqr (l intr evad T) * Rsqr (sin (beta intr evad T + thetat intr 0))))%R
 with
 (2 * V * T * l intr evad T * - cos (beta intr evad T + thetat intr 0))%R...
intro...
rewrite <- (Ropp_involutive (cos (beta intr evad T)))...
rewrite <- (Ropp_involutive (cos (beta intr evad T + thetat intr 0)))...
apply Ropp_ge_le_contravar...
apply Rle_ge...
apply Rmult_le_reg_l with (2 * V * T * l intr evad T)%R...
apply Rmult_lt_0_compat...
prove_sup0... 

apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...
ring...
ring...

apply RR_pos...
unfold d in |- *; unfold Die in |- *; apply sqrt_positivity...
apply Rplus_le_le_0_compat; apply Rle_0_sqr...
Qed.

Lemma R_T_d_diff_1 :
 h (tr evad) = V ->
 (cos (beta intr evad T + thetat intr 0) <= cos (beta intr evad T))%R ->
 (d intr evad <= RR (measure2state intr 0) (measure2state (tr evad) 0) T)%R.
Proof with trivial.
intros...
apply Rsqr_incr_0...
rewrite R_T...
rewrite (d_l_beta intr evad T)...
unfold ve in |- *...
rewrite H...
rewrite Rsqr_minus...
repeat rewrite Rsqr_mult...
rewrite cos2...
replace
 (Rsqr (l intr evad T) * (1 - Rsqr (sin (beta intr evad T + thetat intr 0))) +
  Rsqr V * Rsqr T -
  2 * (l intr evad T * cos (beta intr evad T + thetat intr 0)) * (V * T) +
  Rsqr (l intr evad T) * Rsqr (sin (beta intr evad T + thetat intr 0)))%R
 with
 (Rsqr V * Rsqr T + Rsqr (l intr evad T) -
  2 * (l intr evad T * cos (beta intr evad T + thetat intr 0)) * (V * T))%R...
unfold Rminus in |- *...
apply Rplus_le_compat_l...
apply Ropp_ge_le_contravar...
apply Rle_ge...
repeat rewrite Rmult_assoc...
apply Rmult_le_compat_l...
left; prove_sup0...
rewrite <- (Rmult_comm (V * T))...
rewrite (Rmult_comm (l intr evad T))...
repeat rewrite Rmult_assoc...
apply Rmult_le_compat_l...
left; apply TypeSpeed_pos...
apply Rmult_le_compat_l...
left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ]...
rewrite <- (Rmult_comm (l intr evad T))...
apply Rmult_le_compat_l...
apply l_is_pos...
unfold Rminus in |- *...
rewrite Rmult_plus_distr_l...
ring...

unfold d in |- *; unfold Die in |- *; apply sqrt_positivity;
 apply Rplus_le_le_0_compat; apply Rle_0_sqr...
apply RR_pos...
Qed.

Lemma cos_no_conflict :
 h intr = V ->
 h (tr evad) = V ->
 Alpha (beta intr evad T) = false ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 (cos (beta intr evad T + thetat intr 0) <= cos (beta intr evad T))%R ->
 Omega (thetat intr 0 + beta intr evad T) = false ->
 conflict intr evad T = false.
Proof with trivial.
intros hyp_intr hyp_evad; intros...
unfold conflict in |- *...
cut
 (l intr evad T * cos (beta intr evad T) <
  (Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
  (2 * ve evad * T))%R...
cut
 ((thetat intr 0 + beta intr evad T < PI / 2)%R \/
  (PI / 2 <= thetat intr 0 + beta intr evad T)%R /\
  (3 * (PI / 2) < thetat intr 0 + beta intr evad T)%R)...
intros...
case (Rle_dec (Die intr evad T T) ConflictRange); intro...
unfold Die in r...
generalize (isometric_evader intr evad T T)...
unfold Rsqr_evader_distance in |- *...
unfold xe, ye in |- *...
intro...
rewrite H6 in r...
cut (0 <= T)%R...
cut (rho_vi intr * T <= PI / 2)%R...
intros...
generalize (ypt_PI2 intr evad T T H8 H7); intro...
generalize
 (xpt_PI intr evad T T H8
    (Rle_trans (rho_vi intr * T) (PI / 2) PI H7
       (Rlt_le (PI / 2) PI PI2_Rlt_PI))); intro...
elim H4; intros...
rewrite Rplus_comm in H11...
cut (MinBeta <= beta intr evad T + thetat intr 0)%R...
intro...
elim H9; intros...
generalize
 (Math_prop_no_conflict_1 (beta intr evad T + thetat intr 0) 
    (l intr evad T) (xp intr evad T T) (yp intr evad T T) T H0 H1 H12
    (Rlt_le (beta intr evad T + thetat intr 0) (PI / 2) H11))...
unfold r_V, rho_V in |- *...
unfold r_vi, rho_vi in H13...
unfold r_vi, rho_vi in H10...
unfold vi in H10...
rewrite hyp_intr in H10...
unfold vi in H13...
rewrite hyp_intr in H13...
intro...
generalize (H15 H13 H10)...
intro...
cut (0 <= sqrt (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T)))%R...
cut (0 <= ConflictRange)%R...
intros...
generalize
 (Rsqr_incr_1 (sqrt (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T)))
    ConflictRange r H18 H17); intro...
rewrite Rsqr_sqrt in H19...
elim
 (Rlt_irrefl (Rsqr ConflictRange)
    (Rlt_le_trans (Rsqr ConflictRange)
       (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T))
       (Rsqr ConflictRange) H16 H19))...
apply Rplus_le_le_0_compat; apply Rle_0_sqr...
unfold ConflictRange in |- *; left; prove_sup...
apply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr...
apply cos_decr_0...
generalize (beta_def intr evad T); intro...
decompose [and] H12...
left; apply Rlt_trans with (PI / 2)%R...
apply PI2_Rlt_PI...
left; apply MinBeta_pos...
unfold MinBeta in |- *...
left; apply Rlt_trans with 1%R...
unfold Rdiv in |- *...
apply Rmult_lt_reg_l with 1000%R...
prove_sup...
rewrite Rmult_1_r; rewrite (Rmult_comm 1000); rewrite Rmult_assoc...
rewrite <- Rinv_l_sym; [ prove_sup | discrR ]...
apply Rlt_trans with (PI / 2)%R...
apply Rlt_1_PI2...
apply PI2_Rlt_PI...
apply Rle_trans with (cos (beta intr evad T))...
apply cos_beta_NOT_Alpha...
elim H11; intros...
rewrite (Rplus_comm (thetat intr 0)) in H13...
cut (beta intr evad T + thetat intr 0 <= 2 * PI - MinBeta)%R...
intro...
generalize
 (Math_prop_no_conflict_2 (beta intr evad T + thetat intr 0) 
    (l intr evad T) (xp intr evad T T) (yp intr evad T T) T H0 H1
    (Rlt_le (3 * (PI / 2)) (beta intr evad T + thetat intr 0) H13) H14);
 intro...
unfold r_V, rho_V in H15...
unfold r_vi, rho_vi in H10...
elim H9; intros...
unfold r_vi, rho_vi in H17...
unfold vi in H17...
rewrite hyp_intr in H17...
unfold vi in H10...
rewrite hyp_intr in H10...
generalize (H15 H17 H10); intro...
cut (0 <= sqrt (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T)))%R...
cut (0 <= ConflictRange)%R...
intros...
generalize
 (Rsqr_incr_1 (sqrt (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T)))
    ConflictRange r H20 H19); intro...
rewrite Rsqr_sqrt in H21...
elim
 (Rlt_irrefl (Rsqr ConflictRange)
    (Rlt_le_trans (Rsqr ConflictRange)
       (Rsqr (xp intr evad T T) + Rsqr (yp intr evad T T))
       (Rsqr ConflictRange) H18 H21))...
apply Rplus_le_le_0_compat; apply Rle_0_sqr...
unfold ConflictRange in |- *; left; prove_sup...
apply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr...
apply cos_incr_0...
left; apply Rlt_trans with (3 * (PI / 2))%R...
pattern PI at 1 in |- *; rewrite <- (Rplus_0_r PI)...
replace (3 * (PI / 2))%R with (PI + PI / 2)%R...
apply Rplus_lt_compat_l...
apply PI2_RGT_0...
pattern PI at 1 in |- *; rewrite double_var; ring...
generalize (beta_def intr evad T); intro...
decompose [and] H14...
left...
left...
apply Rplus_lt_reg_l with (MinBeta - PI)%R...
replace (MinBeta - PI + PI)%R with MinBeta...
replace (MinBeta - PI + (2 * PI - MinBeta))%R with PI...
unfold MinBeta in |- *...
apply Rlt_trans with 1%R...
unfold Rdiv in |- *...
apply Rmult_lt_reg_l with 1000%R...
prove_sup...
rewrite (Rmult_comm 1000); rewrite Rmult_assoc; rewrite <- Rinv_l_sym;
 [ repeat rewrite Rmult_1_r; prove_sup | discrR ]...
apply Rlt_trans with (PI / 2)%R...
apply Rlt_1_PI2...
apply PI2_Rlt_PI...
ring...
ring...
unfold Rminus in |- *...
pattern (2 * PI)%R at 2 in |- *; rewrite <- (Rplus_0_r (2 * PI))...
apply Rplus_le_compat_l...
left; rewrite <- Ropp_0...
apply Ropp_lt_gt_contravar...
apply MinBeta_pos...
unfold Rminus in |- *...
rewrite (Rplus_comm (2 * PI))...
generalize (cos_period (- MinBeta) 1)...
unfold INR in |- *...
rewrite Rmult_1_r...
intro...
rewrite H14...
rewrite cos_neg...
apply Rle_trans with (cos (beta intr evad T))...
apply cos_beta_NOT_Alpha...
left; replace (rho_vi intr) with rho_V...
apply rho_t_PI2...
unfold rho_vi, rho_V in |- *...
unfold vi in |- *; rewrite hyp_intr...
left; apply Rlt_le_trans with MinT...
apply MinT_is_pos...
apply (cond_1 T)...
cut (Omega (thetat intr 0 + beta intr evad T) = false)...
unfold Omega in |- *...
case (Rle_dec (PI / 2) (thetat intr 0 + beta intr evad T)); intro...
case (Rle_dec (thetat intr 0 + beta intr evad T) (3 * (PI / 2))); intros...
elim diff_true_false...
right...
split...
auto with real...
intro...
left; auto with real...
cut (Alpha (beta intr evad T) = false)...
unfold Alpha in |- *...
case
 (Rle_dec
    ((Rsqr (ve evad * T) + Rsqr (l intr evad T) - Rsqr AlertRange) /
     (2 * ve evad * T)) (l intr evad T * cos (beta intr evad T))); 
 intros...
elim diff_true_false...
auto with real...
Qed.

Theorem ails_no_conflict_tau_le0 :
 h intr = V ->
 h (tr evad) = V ->
 (MinDistance T <= l intr evad T)%R ->
 (l intr evad T <= MaxDistance T)%R ->
 (AlertRange < d intr evad)%R ->
 Omega (thetat intr 0 + beta intr evad T) = false ->
 (tau (measure2state intr 0) (measure2state (tr evad) 0) 0 <= 0)%R ->
 conflict intr evad T = false.
Proof with trivial.
intros; apply cos_no_conflict...
apply (Alpha_d_AlertRange_3 H3)...
apply R_T_d_diff_0...
apply Rlt_le_trans with (MinDistance T)...
apply MinDistance_pos...
apply tau_le_0_diverg...
Qed.

End alpha_no_conflict.
