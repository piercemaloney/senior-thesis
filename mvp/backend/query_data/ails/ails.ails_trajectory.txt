

Require Import Reals.

Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)

Require Import trajectory_def.
(* trajectory_def:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.

Record Trajectory : Type := mkTrajectory
  {x : Differential;
   y : Differential;
   theta : Differential;
   phi : Differential;
   h : TypeSpeed;
   cond_x :
    forall t : R, derive_pt x t (cond_diff x t) = (h * cos (theta t))%R;
   cond_y :
    forall t : R, derive_pt y t (cond_diff y t) = (h * sin (theta t))%R;
   cond_phi : forall t : R, (- MaxBank <= phi t <= MaxBank)%R;
   cond_theta :
    forall t : R,
    derive_pt theta t (cond_diff theta t) = (g * (tan (phi t) / h))%R}.

Record EvaderTrajectory : Type := mkEvaderTrajectory
  {tr : Trajectory;
   tr_cond1 : forall t : R, x tr t = (x tr 0 + h tr * t)%R;
   tr_cond2 : forall t : R, y tr t = y tr 0%R;
   tr_cond3 : forall t : R, theta tr t = 0%R;
   tr_cond4 : forall t : R, phi tr t = 0%R}.

Lemma init_tr_derivable_x :
 forall h : TypeSpeed, derivable (fun t : R => (h * t)%R).

Lemma init_tr_derivable_y :
 forall h : TypeSpeed, derivable (fun t : R => 0%R).

Lemma init_tr_cond_x :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => (h * t)%R) t (init_tr_derivable_x h t) =
 (h * cos ((fun t : R => 0) t))%R.

Lemma init_tr_cond_y :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (h * sin ((fun t : R => 0) t))%R.

Lemma init_tr_cond_phi :
 forall t : R,
 (- MaxBank <= (fun t : R => 0) t)%R /\ ((fun t : R => 0) t <= MaxBank)%R.

Lemma fct_der1 : forall t : R, derivable_pt (fun t : R => 0%R) t.

Lemma init_tr_cond_theta :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (fun t : R => (g * (tan 0 / h))%R) t.

Definition init_tr (h : TypeSpeed) : Trajectory :=
  mkTrajectory
    (mkDifferential (fun t : R => (h * t)%R) (init_tr_derivable_x h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h)) h
    (init_tr_cond_x h) (init_tr_cond_y h) init_tr_cond_phi
    (init_tr_cond_theta h).

Lemma MaxBank_encadr : (0 < MaxBank < PI / 4)%R.

Lemma dtheta_rho :
 forall (tr : Trajectory) (t : R),
 (- rho (h tr) <= derive_pt (theta tr) t (cond_diff (theta tr) t) <=
  rho (h tr))%R. *)

Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)

Require Import ycngftys.
(* ycngftys:
Section ycngftys.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.
Require Import constants.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition xi : R -> R := x intr.
Definition yi : R -> R := y intr.
Definition vi : TypeSpeed := h intr.
Definition xP (t : R) : R := (xi t - xi 0)%R.
Definition yP (t : R) : R := (yi t - yi 0)%R.
Definition u (eps : posreal) (t : R) : R :=
  sqrt (Rsqr (xP t) + Rsqr (yP t) + Rsqr eps).
Definition u0 (t : R) : R := sqrt (Rsqr (xP t) + Rsqr (yP t)).

Lemma xi_derivable : derivable xi.

Lemma yi_derivable : derivable yi.

Lemma xP_derivable : derivable xP.

Lemma yP_derivable : derivable yP.

Lemma d_u : forall eps : posreal, derivable (fun t : R => u eps t).

Lemma fct_der2 :
 forall (eps : posreal) (t : R), derivable_pt (fun y : R => Rsqr (u eps y)) t.

Lemma D_Rsqr_u_epsilon_1 :
 forall (eps : posreal) (t : R),
 derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) =
 (2 * u eps t * derive_pt (u eps) t (d_u eps t))%R. 

Lemma xP_derive :
 forall t : R,
 derive_pt xP t (xP_derivable t) = derive_pt xi t (xi_derivable t).

Lemma yP_derive :
 forall t : R,
 derive_pt yP t (yP_derivable t) = derive_pt yi t (yi_derivable t).

Lemma fct_der3 :
 forall (eps : posreal) (t : R),
 derivable_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t.

Lemma D_Rsqr_u_epsilon_2 :
 forall (eps : posreal) (t : R),
 (derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) <= 2 * u0 t * vi)%R.

Lemma u_stric_pos : forall (eps : posreal) (t : R), (0 < u eps t)%R.

Lemma u_pos : forall (eps : posreal) (t : R), (0 <= u eps t)%R.

Lemma u0_pos : forall t : R, (0 <= u0 t)%R.

Lemma Rsqr_u_epsilon :
 forall (eps : posreal) (t : R), Rsqr (u eps t) = (Rsqr (u0 t) + Rsqr eps)%R.

Lemma u0_u_epsilon : forall (eps : posreal) (t : R), (u0 t <= u eps t)%R.

Lemma u_epsilon_le_v :
 forall (eps : posreal) (t : R), (derive_pt (u eps) t (d_u eps t) <= vi)%R.

Lemma vit_derivable : derivable (fun t : R => (vi * t)%R).

Lemma derive_vit :
 forall t : R, derive_pt (fun t : R => (vi * t)%R) t (vit_derivable t) = vi.

Lemma u_epsilon_le_vt :
 forall (eps : posreal) (t : R), (0 <= t)%R -> (u eps t - eps <= vi * t)%R.

Lemma Rsqr_u :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + 2 * eps * vi * t)%R.

Lemma Rsqr_u_Rsqr_vt :
 forall (eps : posreal) (t : R),
 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + eps)%R.

Theorem YCNGFTYS :
 forall t : R,
 (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.

End ycngftys. *)

Require Import ycngstys.
(* ycngstys:
Section ycngstys.

Require Import Reals.
Require Import trajectory_def.
Require Import trajectory_const.
Require Import constants.
Require Import ycngftys.
Require Import rrho.

Unset Standard Proposition Elimination Names.

Variable intr : Trajectory.

Definition thetat : R -> R := theta intr.
Definition Rs (t : R) : R :=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)).

Axiom
  alphas_exists :
    { f : Differential_D2 |
       forall t : R,
       xi intr t = (Rs t * cos (f t) + xi intr 0)%R /\
       yi intr t = (Rs t * sin (f t) + yi intr 0)%R }.

Definition alphas := let (a,_) := alphas_exists in a.

Lemma alphas_def :
 forall t : R,
 xi intr t = (Rs t * cos (alphas t) + xi intr 0)%R /\
 yi intr t = (Rs t * sin (alphas t) + yi intr 0)%R.

Lemma Rsx : forall t : R, xi intr t = (xi intr 0 + Rs t * cos (alphas t))%R.

Lemma Rsy : forall t : R, yi intr t = (yi intr 0 + Rs t * sin (alphas t))%R.

Lemma Rs_x :
 forall t : R,
 cos (alphas t) <> 0%R -> Rs t = ((xi intr t - xi intr 0) / cos (alphas t))%R.

Lemma Rs_y :
 forall t : R,
 sin (alphas t) <> 0%R -> Rs t = ((yi intr t - yi intr 0) / sin (alphas t))%R.

Lemma Rs_derivable : derivable Rs.

Definition alphas_p : R -> R := d2 alphas.

Lemma fct_der4 :
 forall t : R,
 derivable_pt ((Rs * comp cos alphas_p)%F + fct_cte (xi intr 0)) t.

Lemma Dxi :
 forall t : R,
 derive_pt (xi intr) t (xi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma Dyi :
 forall t : R,
 derive_pt (yi intr) t (yi_derivable intr t) =
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R.

Lemma DRs_cos :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * cos (alphas t) -
  Rs t * sin (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * cos (thetat t))%R.

Lemma DRs_sin :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) * sin (alphas t) +
  Rs t * cos (alphas t) * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t))%R.

Lemma eq_plus_eq_is_eq :
 forall x y z t : R, x = y -> z = t -> (x + z)%R = (y + t)%R.

Lemma DRs :
 forall t : R,
 derive_pt Rs t (Rs_derivable t) = (vi intr * cos (thetat t - alphas t))%R.

Lemma Rs_alphas :
 forall t : R,
 (Rs t * derive_pt alphas t (cond_D1 alphas t))%R =
 (vi intr * sin (thetat t - alphas t))%R.

Lemma fct_der5 :
 forall t : R,
 derivable_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R)
   t.

Lemma D_Rs_alphas1 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (derive_pt Rs t (Rs_derivable t) * derive_pt alphas t (cond_D1 alphas t) +
  Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma thetat_derivable : derivable thetat.

Lemma D_Rs_alphas2 :
 forall t : R,
 derive_pt (fun y : R => (Rs y * derive_pt alphas y (cond_D1 alphas y))%R) t
   (fct_der5 t) =
 (vi intr * cos (thetat t - alphas t) *
  (derive_pt thetat t (thetat_derivable t) -
   derive_pt alphas t (cond_D1 alphas t)))%R.

Lemma D_Rs_2 :
 forall t : R,
 (derive_pt Rs t (Rs_derivable t) *
  (2 * derive_pt alphas t (cond_D1 alphas t) -
   derive_pt thetat t (thetat_derivable t)))%R =
 (- Rs t * derive_pt (derive alphas (cond_D1 alphas)) t (cond_D2 alphas t))%R.

Lemma Rsqr_DRs :
 forall t : R,
 (Rsqr (derive_pt Rs t (Rs_derivable t)) +
  Rsqr (Rs t) * Rsqr (derive_pt alphas t (cond_D1 alphas t)))%R =
 Rsqr (vi intr).

Lemma Rs_pos : forall t : R, (0 <= Rs t)%R.

Lemma Rs_0 : Rs 0 = 0%R.

Lemma D_Rs_0 : (0 <= derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma eq_sym : forall x y : R, x = y -> y = x.

Lemma D_Rs_0_strong : (0 < derive_pt Rs 0 (Rs_derivable 0))%R.

Lemma D_alphas_0 :
 (2 * derive_pt alphas 0 (cond_D1 alphas 0))%R =
 derive_pt thetat 0 (thetat_derivable 0%R).

Lemma D_Rs_pos_non_null :
 forall t : R,
 (0 < t)%R ->
 (forall x : R, (0 < x < t)%R -> (0 < derive_pt Rs x (Rs_derivable x))%R) ->
 (0 < Rs t)%R.

Axiom
  D_Rs_pos :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R -> (0 < derive_pt Rs t (Rs_derivable t))%R.

Axiom
  D_abs_alpha :
    forall t : R,
    (0 <= t)%R ->
    (t < 2 / rho (vi intr))%R ->
    (- rho (vi intr) / 2 <= derive_pt alphas t (cond_D1 alphas t))%R /\
    (derive_pt alphas t (cond_D1 alphas t) <= rho (vi intr) / 2)%R.

Definition F (t : R) : R :=
  (2 * (vi intr / rho (vi intr)) * sin (rho (vi intr) * (t / 2)))%R.

Lemma F_derivable : derivable F.

Lemma D_F :
 forall t : R,
 derive_pt F t (F_derivable t) = (vi intr * cos (rho (vi intr) * (t / 2)))%R.

Lemma D_F_Rsqr_v :
 forall t : R,
 (Rsqr (derive_pt F t (F_derivable t)) +
  Rsqr (rho (vi intr) / 2) * Rsqr (F t))%R = Rsqr (vi intr).

Definition G (t : R) : R := (Rs t - F t)%R.

Lemma G_derivable : derivable G.

Lemma D_G_alphas :
 forall t : R,
 (derive_pt G t (G_derivable t) *
  (derive_pt Rs t (Rs_derivable t) + derive_pt F t (F_derivable t)))%R =
 (- Rsqr (derive_pt alphas t (cond_D1 alphas t)) * G t * (Rs t + F t) +
  Rsqr (F t) *
  (Rsqr (rho (vi intr) / 2) - Rsqr (derive_pt alphas t (cond_D1 alphas t))))%R.

Lemma Rlt_1_PI2 : (1 < PI / 2)%R.

Lemma D_G_pos :
 forall t : R,
 (0 <= t)%R ->
 (t < 2 / rho (vi intr))%R ->
 (G t <= 0)%R -> (0 <= derive_pt G t (G_derivable t))%R.

Lemma G_0 : G 0 = 0%R.

Axiom
  G_pos :
    forall t : R, (0 <= t)%R -> (t < 2 / rho (vi intr))%R -> (0 <= G t)%R.

Theorem YCNGSTYS :
 forall t : R,
 (0 <= t)%R ->
 (rho (vi intr) * t < 2)%R ->
 (2 * r (vi intr) * sin (rho (vi intr) * (t / 2)) <=
  sqrt (Rsqr (xi intr t - xi intr 0) + Rsqr (yi intr t - yi intr 0)))%R.

End ycngstys. *)

Require Import tau.
(* tau:
Require Import Reals.
Require Import ails_def.
Require Import trajectory_const.

Unset Standard Proposition Elimination Names.

Definition dx (intruder evader : State) (t : R) : R :=
  (xt intruder + t * intruderSpeed * cosd (heading intruder) -
   (xt evader + t * evaderSpeed))%R.
Definition dy (intruder evader : State) (t : R) : R :=
  (yt intruder + t * intruderSpeed * sind (heading intruder) - yt evader)%R.
Definition dxdt (intruder : State) : R :=
  (intruderSpeed * cosd (heading intruder) - evaderSpeed)%R.
Definition dydt (intruder : State) : R :=
  (intruderSpeed * sind (heading intruder))%R.
Definition RR (intruder evader : State) (t : R) : R :=
  sqrt (Rsqr (dx intruder evader t) + Rsqr (dy intruder evader t)).
Definition div_tau (intruder evader : State) : R :=
  (Rsqr (dxdt intruder) + Rsqr (dydt intruder))%R.

Lemma Req_EM_var : forall r1 r2 : R, {r1 = r2} + {r1 <> r2}. 

Definition tau (intruder evader : State) (t : R) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dx intruder evader t * dxdt intruder +
        dy intruder evader t * dydt intruder) / div_tau intruder evader)%R
  end.  
Definition tmin (intruder evader : State) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dxdt intruder * (xt intruder - xt evader) +
        dydt intruder * (yt intruder - yt evader)) / 
       div_tau intruder evader)%R
  end.

Lemma tau_tmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader t = (tmin intruder evader - t)%R.

Definition Ax2_R (intruder : State) : R :=
  (Rsqr (sind (heading intruder) * intruderSpeed) +
   Rsqr (- evaderSpeed + cosd (heading intruder) * intruderSpeed))%R.

Lemma Ax2_R_pos : forall intruder : State, (0 <= Ax2_R intruder)%R.

Definition Bx_R (intruder evader : State) : R :=
  (-2 * (yt evader * sind (heading intruder) * intruderSpeed) +
   2 * (yt intruder * sind (heading intruder) * intruderSpeed) -
   2 * (cosd (heading intruder) * xt evader * intruderSpeed) +
   2 * (cosd (heading intruder) * xt intruder * intruderSpeed) +
   2 * (xt evader * evaderSpeed) - 2 * (xt intruder * evaderSpeed))%R.

Definition C_R (intruder evader : State) : R :=
  (Rsqr (yt intruder - yt evader) + Rsqr (xt intruder - xt evader))%R.

Lemma Rsqr_R :
 forall (intruder evader : State) (t : R),
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr t + Bx_R intruder evader * t + C_R intruder evader)%R.

Definition Rsqr_Rmin (intruder evader : State) : R :=
  match Req_EM_var (Ax2_R intruder) 0 with
  | left _ => 0%R
  | right _ =>
      ((4 * Ax2_R intruder * C_R intruder evader -
        Rsqr (Bx_R intruder evader)) / (4 * Ax2_R intruder))%R
  end.

Lemma tmin_0 :
 forall intruder evader : State,
 div_tau intruder evader <> 0%R ->
 tmin intruder evader = (- Bx_R intruder evader / (2 * Ax2_R intruder))%R.

Lemma Ax2_R_0_div_tau :
 forall intruder evader : State,
 div_tau intruder evader = 0%R -> Ax2_R intruder = 0%R.

Lemma div_tau_0_Ax2_R :
 forall intruder evader : State,
 Ax2_R intruder = 0%R -> div_tau intruder evader = 0%R.

Lemma R_Rmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr (t - tmin intruder evader) +
  Rsqr_Rmin intruder evader)%R.

Lemma dx_dxdt :
 forall (intruder evader : State) (t : R),
 (xt intruder - xt evader + t * dxdt intruder)%R = dx intruder evader t.

Lemma dy_dydt :
 forall (intruder evader : State) (t : R),
 (yt intruder - yt evader + t * dydt intruder)%R = dy intruder evader t.

Lemma R_equal_when_zero :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader = 0%R ->
 RR intruder evader t1 = RR intruder evader t2.

Lemma RR_pos :
 forall (intruder evader : State) (t : R), (0 <= RR intruder evader t)%R.

Lemma derivative_eq_zero_tmin :
 forall (intruder evader : State) (t : R),
 (RR intruder evader (tmin intruder evader) <= RR intruder evader t)%R.

Lemma derivative_eq_zero_min :
 forall (intruder evader : State) (t1 t2 : R),
 (RR intruder evader (t1 + tau intruder evader t1) <=
  RR intruder evader (t1 + t2))%R.

Lemma asymptotic_decrease_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (t2 <= tmin intruder evader)%R ->
 (t1 <= t2)%R -> (RR intruder evader t2 <= RR intruder evader t1)%R.

Lemma asymptotic_decrease_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (t2 <= tau intruder evader t)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t2) <= RR intruder evader (t + t1))%R.

Lemma asymptotic_increase_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (tmin intruder evader <= t1)%R ->
 (t1 <= t2)%R -> (RR intruder evader t1 <= RR intruder evader t2)%R.

Lemma asymptotic_increase_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (tau intruder evader t <= t1)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t1) <= RR intruder evader (t + t2))%R.

Lemma tau_equal_when_zero :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader = 0%R -> tau intruder evader t = 0%R.

Lemma asymptotic_tau_gt :
 forall (intruder evader : State) (t dt : R),
 (0 <= dt)%R ->
 (RR intruder evader (t + dt) < RR intruder evader t)%R ->
 (0 < tau intruder evader t)%R.

Lemma tau_is_uniform :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader (t1 + t2) = (tau intruder evader t1 - t2)%R.

Lemma tau_gt_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t < tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t < tau intruder evader t1)%R.

Lemma tau_ge_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t <= tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t <= tau intruder evader t1)%R. *)

Require Import ails.
(* ails:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.
Require Import ails_def.
Require Import tau.
Require Import Omega.

Unset Standard Proposition Elimination Names.

Fixpoint rest (p r s n : nat) {struct n} : nat :=
  match n with
  | O => r
  | S n' =>
      match s with
      | O => 0
      | S O => rest p 0 p n'
      | S s' => rest p (S r) s' n'
      end
  end.
  
Definition mod_ (m n : nat) : nat := rest n 0 n m.

Lemma mod_eq_0 : forall m : nat, mod_ 0 m = 0.

Definition trkrate (phi : Bank) : R :=
  toDeg (g * (tand phi / v intruderSpeed)).

Lemma cond1_0 : (- toDeg MaxBank <= 0)%R.

Lemma cond2_0 : (0 <= toDeg MaxBank)%R.

Lemma trkrate0 : trkrate (mkBank 0 cond1_0 cond2_0) = 0%R.

Definition distance (s1 s2 : State) : R :=
  sqrt (Rsqr (xt s2 - xt s1) + Rsqr (yt s2 - yt s1)).

Lemma distance_sym : forall s1 s2 : State, distance s1 s2 = distance s2 s1.

Definition alerting_distance (s1 s2 : State) : Prop :=
  (distance s1 s2 <= AlertRange)%R.

Definition conflict_distance (s1 s2 : State) : Prop :=
  (distance s1 s2 <= ConflictRange)%R.

Definition chkrange (range tpred : R) : Prop :=
  (range <= AlertRange)%R /\ (tpred <= AlertTime)%R.

Definition chktrack (intruder evader : State) (tpred : R) : Prop :=
  let tau := tau intruder evader 0 in
  match Rle_dec tau 0 with
  | left _ => chkrange (RR intruder evader 0) tpred
  | right _ =>
      match Rlt_dec AlertTime (tpred + tau) with
      | left _ => (RR intruder evader AlertTime <= AlertRange)%R
      | right _ => (RR intruder evader tau <= AlertRange)%R
      end
  end.

Definition arc_loop (intruder evader : State) (arcrad trkrate : R)
  (idtrk iarc : nat) : Prop :=
  match iarc with
  | S p => False
  | O =>
      let tpred := (INR iarc * tstep)%R in
      let xloc := (xt evader + v evaderSpeed * tpred)%R in
      let yloc := yt evader in
      let xtrk :=
        match Rlt_le_dec 0 trkrate with
        | left _ =>
            (xt intruder +
             arcrad *
             (sind (heading intruder + trkrate * tpred) -
              sind (heading intruder)))%R
        | right _ =>
            (xt intruder +
             arcrad *
             (sind (heading intruder) - sind (heading intruder) +
              trkrate * tpred))%R
        end in
      let ytrk :=
        match Rlt_le_dec 0 trkrate with
        | left _ =>
            (yt intruder +
             arcrad *
             (cosd (heading intruder) -
              cosd (heading intruder + trkrate * tpred)))%R
        | right _ =>
            (yt intruder +
             arcrad *
             (cosd (heading intruder + trkrate * tpred) -
              cosd (heading intruder)))%R
        end in
      match mod_ iarc idtrk with
      | O =>
          let tantrk := (heading intruder + tpred * trkrate)%R in
          let int := mkState xtrk ytrk tantrk (bank intruder) in
          let eva := mkState xloc yloc (heading evader) (bank evader) in
          chktrack int eva tpred
      | _ =>
          let range := sqrt (Rsqr (xtrk - xloc) + Rsqr (ytrk - yloc)) in
          chkrange range tpred
      end
  end.

Definition ails_alert (intruder evader : State) : Prop :=
  let phi := bank intruder in
  let trkrate := trkrate phi in
  match Req_EM_var trkrate 0 with
  | left _ => chktrack intruder evader 0
  | right _ =>
      let arcrad := (Rsqr (v intruderSpeed) / (g * tand (r phi)))%R in
      let idtrk :=
        match Rle_dec 3 trkrate with
        | left _ => 1
        | right _ =>
            match Rle_dec (3 / 2) trkrate with
            | left _ => 2
            | right _ =>
                match Rle_dec (3 / 4) trkrate with
                | left _ => 4
                | right _ => 8
                end
            end
        end in
      arc_loop intruder evader arcrad trkrate idtrk 0
  end.

Lemma R_distance :
 forall intruder evader : State,
 RR intruder evader 0 = distance intruder evader.

Lemma step1 :
 forall evader intruder : State,
 alerting_distance evader intruder -> chktrack intruder evader 0.

Lemma step2 :
 forall (evader intruder : State) (x : nat),
 (distance evader intruder <= AlertRange)%R ->
 trkrate (bank intruder) <> 0%R ->
 arc_loop intruder evader (Rsqr intruderSpeed / (g * tand (bank intruder)))
   (trkrate (bank intruder)) x 0.

Theorem alarm_at_alerting_distance :
 forall evader intruder : State,
 alerting_distance evader intruder -> ails_alert intruder evader. *)

Require Import trajectory.
(* trajectory:
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ycngftys.
Require Import ycngstys.
Require Import tau.
Require Import ails.
Require Import trajectory.
Require Import measure2state.

Lemma d_distance :
 forall (intr : Trajectory) (evad : EvaderTrajectory),
 distance (measure2state (tr evad) 0) (measure2state intr 0) = d intr evad.

Lemma R_T :
 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),
 h (tr evad) = V ->
 Rsqr (RR (measure2state intr 0) (measure2state (tr evad) 0) T) =
 (Rsqr (l intr evad T * cos (beta intr evad T + thetat intr 0) - V * T) +
  Rsqr (l intr evad T * sin (beta intr evad T + thetat intr 0)))%R. *)

Require Import measure2state.
(* measure2state:
Require Import Reals.
Require Import trajectory_const.
Require Import trajectory_def.
Require Import constants.
Require Import ails_def.
Require Import Omega.

Lemma cond1_sty :
 forall (tr : Trajectory) (t : R), (- toDeg MaxBank <= toDeg (phi tr t))%R.

Lemma cond2_sty :
 forall (tr : Trajectory) (t : R), (toDeg (phi tr t) <= toDeg MaxBank)%R.

Definition measure2state (tr : Trajectory) (t : R) : State :=
  mkState (x tr t) (y tr t) (toDeg (theta tr t))
    (mkBank (toDeg (phi tr t)) (cond1_sty tr t) (cond2_sty tr t)). *)



Lemma d_distance :

 forall (intr : Trajectory) (evad : EvaderTrajectory),

 distance (measure2state (tr evad) 0) (measure2state intr 0) = d intr evad.

Proof with trivial.

unfold distance, d in |- *; unfold Die in |- *; simpl in |- *;

 unfold xi, yi in |- *...

Qed.



Lemma R_T :

 forall (intr : Trajectory) (evad : EvaderTrajectory) (T : TimeT),

 h (tr evad) = V ->

 Rsqr (RR (measure2state intr 0) (measure2state (tr evad) 0) T) =

 (Rsqr (l intr evad T * cos (beta intr evad T + thetat intr 0) - V * T) +

  Rsqr (l intr evad T * sin (beta intr evad T + thetat intr 0)))%R.

Proof with trivial.

intros intr evad T hyp_evad; rewrite Rsqr_minus...

unfold Rminus in |- *...

repeat rewrite Rplus_assoc...

set (z := 250%R)...

rewrite

 (Rplus_comm (Rsqr (l intr evad T * cos (beta intr evad T + thetat intr 0))))

 ...

repeat rewrite Rplus_assoc...

replace

 (Rsqr (l intr evad T * sin (beta intr evad T + thetat intr 0)) +

  Rsqr (l intr evad T * cos (beta intr evad T + thetat intr 0)))%R with

 (Rsqr (l intr evad T))...

rewrite <- (Rplus_comm (Rsqr (l intr evad T)))...

repeat rewrite <- Rplus_assoc...

replace

 (2 * (l intr evad T * cos (beta intr evad T + thetat intr 0)) * (V * T))%R

 with

 (2 * (l intr evad T * (V * T) * cos (beta intr evad T + thetat intr 0)))%R...

cut

 (l intr evad T =

  dist_euc (x (tr evad) T) (y (tr evad) T) (x intr 0%R) (y intr 0%R))...

intro...

rewrite H...

cut

 ((V * T)%R =

  dist_euc (x (tr evad) 0%R + T * z - T * z * cos (thetat intr 0))

    (y (tr evad) 0%R - T * z * sin (thetat intr 0)) 

    (x (tr evad) T) (y (tr evad) T))...

intro...

rewrite H0...

cut

 (RR (measure2state intr 0) (measure2state (tr evad) 0) T =

  dist_euc (x (tr evad) 0%R + T * z - T * z * cos (thetat intr 0))

    (y (tr evad) 0%R - T * z * sin (thetat intr 0)) 

    (x intr 0%R) (y intr 0%R))...

intro; rewrite H1...

replace

 (Rsqr

    (dist_euc (x (tr evad) 0 + T * z - T * z * cos (thetat intr 0))

       (y (tr evad) 0 - T * z * sin (thetat intr 0)) 

       (x (tr evad) T) (y (tr evad) T)) +

  Rsqr (dist_euc (x (tr evad) T) (y (tr evad) T) (x intr 0) (y intr 0)) +

  -

  (2 *

   (dist_euc (x (tr evad) T) (y (tr evad) T) (x intr 0) (y intr 0) *

    dist_euc (x (tr evad) 0 + T * z - T * z * cos (thetat intr 0))

      (y (tr evad) 0 - T * z * sin (thetat intr 0)) 

      (x (tr evad) T) (y (tr evad) T) *

    cos (beta intr evad T + thetat intr 0))))%R with

 (Rsqr

    (dist_euc (x (tr evad) 0 + T * z - T * z * cos (thetat intr 0))

       (y (tr evad) 0 - T * z * sin (thetat intr 0)) 

       (x (tr evad) T) (y (tr evad) T)) +

  Rsqr (dist_euc (x (tr evad) T) (y (tr evad) T) (x intr 0) (y intr 0)) -

  2 *

  (dist_euc (x (tr evad) T) (y (tr evad) T) (x intr 0) (y intr 0) *

   dist_euc (x (tr evad) 0 + T * z - T * z * cos (thetat intr 0))

     (y (tr evad) 0 - T * z * sin (thetat intr 0)) 

     (x (tr evad) T) (y (tr evad) T) * cos (beta intr evad T + thetat intr 0)))%R...

apply law_cosines...

unfold dist_euc in |- *...

replace

 (sqrt

    (Rsqr (x (tr evad) T - x intr 0%R) + Rsqr (y (tr evad) T - y intr 0%R)))

 with (l intr evad T)...

generalize (tr_cond1 evad (val T))...

intro; rewrite H2...

generalize (tr_cond2 evad (val T)); intro...

rewrite H3...

replace

 (x (tr evad) 0 + T * z - T * z * cos (thetat intr 0) -

  (x (tr evad) 0 + h (tr evad) * T))%R with (- T * z * cos (thetat intr 0))%R...

replace (y (tr evad) 0 - T * z * sin (thetat intr 0) - y (tr evad) 0)%R with

 (- T * z * sin (thetat intr 0))%R...

replace

 (Rsqr (- T * z * cos (thetat intr 0)) + Rsqr (- T * z * sin (thetat intr 0)))%R

 with (Rsqr (T * z))...

rewrite sqrt_Rsqr...

rewrite <- H2...

rewrite <- H3...

generalize xe_0; intro...

unfold xe, xi in H4...

rewrite (H4 intr evad T)...

generalize ye_0; intro...

unfold ye, yi in H5...

rewrite (H5 intr evad T)...

replace (x intr 0 - (l intr evad T * cos (beta intr evad T) + x intr 0))%R

 with (- (l intr evad T * cos (beta intr evad T)))%R...

unfold Rminus in |- *...

replace

 (y intr 0 + - (y intr 0 + - (l intr evad T * sin (beta intr evad T))))%R

 with (l intr evad T * sin (beta intr evad T))%R...

rewrite cos_plus...

unfold Rminus in |- *...

rewrite Rmult_plus_distr_l...

replace

 (- (l intr evad T * cos (beta intr evad T)) *

  (- T * z * cos (thetat intr 0)) +

  l intr evad T * sin (beta intr evad T) * (- T * z * sin (thetat intr 0)))%R

 with

 (l intr evad T * cos (beta intr evad T) * T * z * cos (thetat intr 0) +

  l intr evad T * - sin (beta intr evad T) * T * z * sin (thetat intr 0))%R...

replace (- (sin (beta intr evad T) * sin (thetat intr 0)))%R with

 (- sin (beta intr evad T) * sin (thetat intr 0))%R...

repeat rewrite <- Rmult_assoc...

repeat rewrite Rmult_assoc...

pattern (cos (beta intr evad T)) at 1 in |- *;

 rewrite (Rmult_comm (cos (beta intr evad T)))...

repeat rewrite <- Rmult_assoc...

replace

 (l intr evad T * T * z * cos (beta intr evad T) * cos (thetat intr 0))%R

 with

 (l intr evad T * T * z * cos (thetat intr 0) * cos (beta intr evad T))%R...

apply Rplus_eq_compat_l...

repeat rewrite Rmult_assoc...

apply Rmult_eq_compat_l...

repeat rewrite <- Rmult_assoc...

repeat rewrite <- (Rmult_comm (sin (thetat intr 0)))...

repeat rewrite Rmult_assoc...

apply Rmult_eq_compat_l...

rewrite (Rmult_comm (- sin (beta intr evad T)))...

repeat rewrite Rmult_assoc...

repeat rewrite Rmult_assoc...

repeat apply Rmult_eq_compat_l...

ring...

rewrite Ropp_mult_distr_l_reverse...

rewrite <- Ropp_mult_distr_l_reverse...

replace

 (- l intr evad T * cos (beta intr evad T) * (- T * z * cos (thetat intr 0)))%R

 with

 (l intr evad T * cos (beta intr evad T) * T * z * cos (thetat intr 0))%R...

apply Rplus_eq_compat_l...

repeat rewrite Rmult_assoc...

apply Rmult_eq_compat_l...

repeat rewrite <- Rmult_assoc...

repeat rewrite <- (Rmult_comm (sin (thetat intr 0)))...

apply Rmult_eq_compat_l...

repeat rewrite <- (Rmult_comm z)...

apply Rmult_eq_compat_l...

ring...

repeat rewrite <- Rmult_assoc...

repeat rewrite <- (Rmult_comm (cos (thetat intr 0)))...

apply Rmult_eq_compat_l...

repeat rewrite <- (Rmult_comm z)...

apply Rmult_eq_compat_l...

ring...

ring...

ring...

left; apply Rmult_lt_0_compat...

apply Rlt_le_trans with MinT...

apply MinT_is_pos...

apply (cond_1 T)...

unfold z in |- *; prove_sup...

replace (- T * z * cos (thetat intr 0))%R with

 (- T * (z * cos (thetat intr 0)))%R...

replace (- T * z * sin (thetat intr 0))%R with

 (- T * (z * sin (thetat intr 0)))%R...

repeat rewrite Rsqr_mult...

repeat rewrite <- Rsqr_neg...

rewrite cos2...

unfold Rminus in |- *; rewrite Rmult_plus_distr_l...

rewrite Rmult_1_r...

ring...

repeat rewrite Rmult_assoc...

repeat rewrite Rmult_assoc...

unfold Rminus in |- *...

rewrite (Rplus_comm (y (tr evad) 0%R))...

repeat rewrite Rplus_assoc...

rewrite Rplus_opp_r; rewrite Rplus_0_r...

repeat rewrite <- Ropp_mult_distr_l_reverse...

rewrite hyp_evad...

replace (v V) with z...

unfold Rminus in |- *...

ring...

unfold Rminus in |- *; unfold RR, dist_euc in |- *...

replace

 (sqrt

    (Rsqr (dx (measure2state intr 0) (measure2state (tr evad) 0) T) +

     Rsqr (dy (measure2state intr 0) (measure2state (tr evad) 0) T))) with

 (sqrt

    (Rsqr

       (x intr 0%R + T * z * cosd (toDeg (theta intr 0%R)) -

        (x (tr evad) 0%R + T * z)) +

     Rsqr

       (y intr 0%R + T * z * sind (toDeg (theta intr 0%R)) - y (tr evad) 0%R)))...

unfold cosd, sind, thetat in |- *...

rewrite rad_deg...

rewrite

 (Rsqr_neg

    (x intr 0%R + T * z * cos (theta intr 0%R) - (x (tr evad) 0%R + T * z)))

 ...

rewrite

 (Rsqr_neg (y intr 0%R + T * z * sin (theta intr 0%R) - y (tr evad) 0%R))

 ...

replace

 (- (x intr 0 + T * z * cos (theta intr 0) - (x (tr evad) 0 + T * z)))%R with

 (x (tr evad) 0 + T * z - T * z * cos (theta intr 0) - x intr 0)%R...

replace (- (y intr 0 + T * z * sin (theta intr 0) - y (tr evad) 0))%R with

 (y (tr evad) 0 - T * z * sin (theta intr 0) - y intr 0)%R...

unfold Rminus in |- *...

repeat rewrite Ropp_plus_distr...

rewrite Ropp_involutive...

rewrite <- (Rplus_comm (y (tr evad) 0%R))...

repeat rewrite Rplus_assoc...

apply Rplus_eq_compat_l...

rewrite (Rplus_comm (- y intr 0%R))...

unfold Rminus in |- *...

repeat rewrite Ropp_plus_distr...

repeat rewrite Ropp_involutive...

rewrite <- (Rplus_comm (x (tr evad) 0%R + T * z))...

repeat rewrite Rplus_assoc...

repeat apply Rplus_eq_compat_l...

rewrite (Rplus_comm (- x intr 0%R))...

cut (v V = z)...

intro...

rewrite H0...

unfold dist_euc in |- *...

generalize (tr_cond1 evad (val T)); intro...

generalize (tr_cond2 evad (val T)); intro...

rewrite H1...

rewrite H2...

rewrite hyp_evad...

rewrite H0...

replace

 (x (tr evad) 0 + T * z - T * z * cos (thetat intr 0) -

  (x (tr evad) 0 + z * T))%R with (- (T * z * cos (thetat intr 0)))%R...

replace (y (tr evad) 0 - T * z * sin (thetat intr 0) - y (tr evad) 0)%R with

 (- (T * z * sin (thetat intr 0)))%R...

repeat rewrite <- Rsqr_neg...

repeat rewrite Rsqr_mult...

rewrite cos2...

replace

 (Rsqr T * Rsqr z * (1 - Rsqr (sin (thetat intr 0))) +

  Rsqr T * Rsqr z * Rsqr (sin (thetat intr 0)))%R with 

 (Rsqr T * Rsqr z)%R...

rewrite <- Rsqr_mult...

rewrite sqrt_Rsqr...

apply Rmult_comm...

left; apply Rmult_lt_0_compat...

apply Rlt_le_trans with MinT...

apply MinT_is_pos...

apply (cond_1 T)...

unfold z in |- *; prove_sup...

unfold Rminus in |- *...

rewrite Rmult_plus_distr_l...

rewrite Rmult_1_r...

ring...

unfold Rminus in |- *...

rewrite (Rplus_comm (y (tr evad) 0%R))...

rewrite Rplus_assoc...

rewrite Rplus_opp_r...

symmetry  in |- *; apply Rplus_0_r...

unfold Rminus in |- *...

rewrite Ropp_plus_distr...

rewrite (Rplus_comm (- x (tr evad) 0%R))...

repeat rewrite Rplus_assoc...

rewrite (Rplus_comm (x (tr evad) 0%R))...

repeat rewrite Rplus_assoc...

rewrite Rplus_opp_l; rewrite Rplus_0_r...

ring...

unfold l, dist_euc in |- *...

unfold Die in |- *...

unfold xi, yi in |- *...

rewrite (Rsqr_neg (x intr 0%R - x (tr evad) T))...

rewrite (Rsqr_neg (y intr 0%R - y (tr evad) T))...

unfold Rminus in |- *...

repeat rewrite Ropp_plus_distr...

repeat rewrite Ropp_involutive...

rewrite <- (Rplus_comm (x (tr evad) T))...

rewrite <- (Rplus_comm (y (tr evad) T))...

repeat rewrite Rmult_assoc...

repeat apply Rmult_eq_compat_l...

rewrite <- (Rmult_comm (V * T))...

repeat rewrite Rmult_assoc...

repeat rewrite Rsqr_mult...

rewrite sin2...

unfold Rminus in |- *...

rewrite Rmult_plus_distr_l...

rewrite Rmult_1_r...

ring...

Qed.
