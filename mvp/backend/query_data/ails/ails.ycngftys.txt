

Section ycngftys.



Require Import Reals.

Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)

Require Import rrho.
(* rrho:
Require Import Reals.
Require Import trajectory_const.

Definition rho (h : TypeSpeed) : R := (g * (tan MaxBank / h))%R.
Definition r (h : TypeSpeed) : R := (h / rho h)%R.
Definition rho_ub (h : TypeSpeed) : R := (g * (tan_ub_MaxBank / h))%R.
Definition rho_lb (h : TypeSpeed) : R := (g * (tan_lb_MaxBank / h))%R.

Lemma TypeSpeed_pos : forall h : TypeSpeed, (0 < h)%R.

Lemma g_pos : (0 < g)%R.

Lemma rho_ub_0 : forall h : TypeSpeed, (rho h < rho_ub h)%R.

Lemma rho_lb_0 : forall h : TypeSpeed, (rho_lb h < rho h)%R.

Definition r_ub (h : TypeSpeed) : R := (h / rho_lb h)%R.
Definition r_lb (h : TypeSpeed) : R := (h / rho_ub h)%R.

Lemma tan_lb_MaxBank_pos : (0 < tan_lb_MaxBank)%R.

Lemma tan_ub_MaxBank_pos : (0 < tan_ub_MaxBank)%R.

Lemma rho_lb_pos : forall h : TypeSpeed, (0 < rho_lb h)%R.

Lemma rho_pos : forall h : TypeSpeed, (0 < rho h)%R.

Lemma rho_ub_pos : forall h : TypeSpeed, (0 < rho_ub h)%R.

Lemma r_ub_0 : forall h : TypeSpeed, (r h < r_ub h)%R.

Lemma r_lb_0 : forall h : TypeSpeed, (r_lb h < r h)%R.

Lemma rho_PI2 : forall h : TypeSpeed, (rho h <= PI / 2)%R.

Lemma rho_strict_decreasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (rho h2 < rho h1)%R.

Lemma r_stric_increasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (r h1 < r h2)%R. *)

Require Import trajectory_def.
(* trajectory_def:
Require Import Reals.
Require Import trajectory_const.
Require Import rrho.

Record Trajectory : Type := mkTrajectory
  {x : Differential;
   y : Differential;
   theta : Differential;
   phi : Differential;
   h : TypeSpeed;
   cond_x :
    forall t : R, derive_pt x t (cond_diff x t) = (h * cos (theta t))%R;
   cond_y :
    forall t : R, derive_pt y t (cond_diff y t) = (h * sin (theta t))%R;
   cond_phi : forall t : R, (- MaxBank <= phi t <= MaxBank)%R;
   cond_theta :
    forall t : R,
    derive_pt theta t (cond_diff theta t) = (g * (tan (phi t) / h))%R}.

Record EvaderTrajectory : Type := mkEvaderTrajectory
  {tr : Trajectory;
   tr_cond1 : forall t : R, x tr t = (x tr 0 + h tr * t)%R;
   tr_cond2 : forall t : R, y tr t = y tr 0%R;
   tr_cond3 : forall t : R, theta tr t = 0%R;
   tr_cond4 : forall t : R, phi tr t = 0%R}.

Lemma init_tr_derivable_x :
 forall h : TypeSpeed, derivable (fun t : R => (h * t)%R).

Lemma init_tr_derivable_y :
 forall h : TypeSpeed, derivable (fun t : R => 0%R).

Lemma init_tr_cond_x :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => (h * t)%R) t (init_tr_derivable_x h t) =
 (h * cos ((fun t : R => 0) t))%R.

Lemma init_tr_cond_y :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (h * sin ((fun t : R => 0) t))%R.

Lemma init_tr_cond_phi :
 forall t : R,
 (- MaxBank <= (fun t : R => 0) t)%R /\ ((fun t : R => 0) t <= MaxBank)%R.

Lemma fct_der1 : forall t : R, derivable_pt (fun t : R => 0%R) t.

Lemma init_tr_cond_theta :
 forall (h : TypeSpeed) (t : R),
 derive_pt (fun t : R => 0%R) t (init_tr_derivable_y h t) =
 (fun t : R => (g * (tan 0 / h))%R) t.

Definition init_tr (h : TypeSpeed) : Trajectory :=
  mkTrajectory
    (mkDifferential (fun t : R => (h * t)%R) (init_tr_derivable_x h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h))
    (mkDifferential (fun t : R => 0%R) (init_tr_derivable_y h)) h
    (init_tr_cond_x h) (init_tr_cond_y h) init_tr_cond_phi
    (init_tr_cond_theta h).

Lemma MaxBank_encadr : (0 < MaxBank < PI / 4)%R.

Lemma dtheta_rho :
 forall (tr : Trajectory) (t : R),
 (- rho (h tr) <= derive_pt (theta tr) t (cond_diff (theta tr) t) <=
  rho (h tr))%R. *)

Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)



Unset Standard Proposition Elimination Names.



Variable intr : Trajectory.



Definition xi : R -> R := x intr.

Definition yi : R -> R := y intr.

Definition vi : TypeSpeed := h intr.

Definition xP (t : R) : R := (xi t - xi 0)%R.

Definition yP (t : R) : R := (yi t - yi 0)%R.

Definition u (eps : posreal) (t : R) : R :=

  sqrt (Rsqr (xP t) + Rsqr (yP t) + Rsqr eps).

Definition u0 (t : R) : R := sqrt (Rsqr (xP t) + Rsqr (yP t)).



Lemma xi_derivable : derivable xi.

unfold xi in |- *; apply (cond_diff (x intr)).

Qed.



Lemma yi_derivable : derivable yi.

unfold yi in |- *; apply (cond_diff (y intr)).

Qed.



Lemma xP_derivable : derivable xP.

unfold xP in |- *.

reg; apply xi_derivable.

Qed.



Lemma yP_derivable : derivable yP.

unfold yP in |- *.

reg; apply yi_derivable.

Qed.



Lemma d_u : forall eps : posreal, derivable (fun t : R => u eps t).

intro.

unfold u in |- *; unfold derivable in |- *; intro.

reg.

apply yP_derivable.

apply xP_derivable.

apply Rle_lt_trans with (Rsqr (xP x) + Rsqr (yP x))%R.

apply Rplus_le_le_0_compat; apply Rle_0_sqr.

rewrite Rplus_assoc.

apply Rplus_lt_compat_l.

pattern (Rsqr (yP x)) at 1 in |- *; rewrite <- Rplus_0_r.

apply Rplus_lt_compat_l.

apply Rsqr_pos_lt.

red in |- *; intro; assert (H0 := cond_pos eps); rewrite H in H0;

 elim (Rlt_irrefl _ H0).

Qed.



Lemma fct_der2 :

 forall (eps : posreal) (t : R), derivable_pt (fun y : R => Rsqr (u eps y)) t.

intros; set (f := u eps); reg.

apply (d_u eps).

Qed.



Lemma D_Rsqr_u_epsilon_1 :

 forall (eps : posreal) (t : R),

 derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) =

 (2 * u eps t * derive_pt (u eps) t (d_u eps t))%R. 

intros; set (f := u eps).

cut (derivable_pt f t); [ intro H | apply (d_u eps t) ].

cut (derive_pt f t H = derive_pt f t (d_u eps t)); [ intro | apply pr_nu ].

reg.

Qed.



Lemma xP_derive :

 forall t : R,

 derive_pt xP t (xP_derivable t) = derive_pt xi t (xi_derivable t).

intro; unfold xP in |- *; reg.

apply pr_nu.

apply xi_derivable.

Qed.



Lemma yP_derive :

 forall t : R,

 derive_pt yP t (yP_derivable t) = derive_pt yi t (yi_derivable t).

intro; unfold yP in |- *; reg.

apply pr_nu.

apply yi_derivable.

Qed.



Lemma fct_der3 :

 forall (eps : posreal) (t : R),

 derivable_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t.

intros; reg.

apply yP_derivable.

apply xP_derivable.

Qed.



Lemma D_Rsqr_u_epsilon_2 :

 forall (eps : posreal) (t : R),

 (derive_pt (fun y : R => Rsqr (u eps y)) t (fct_der2 eps t) <= 2 * u0 t * vi)%R.

intros; set (f := u eps).

replace (derive_pt (fun y : R => Rsqr (f y)) t (fct_der2 eps t)) with

 (derive_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t

    (fct_der3 eps t)).

replace

 (derive_pt (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R) t

    (fct_der3 eps t)) with

 (2 * derive_pt xP t (xP_derivable t) * xP t +

  2 * derive_pt yP t (yP_derivable t) * yP t)%R.

rewrite (xP_derive t).

rewrite (yP_derive t).

assert (H0 := cond_x intr t).

assert (H1 := cond_y intr t).

cut

 (derive_pt (x intr) t (cond_diff (x intr) t) =

  derive_pt xi t (xi_derivable t)); [ intro | apply pr_nu ].

cut

 (derive_pt (y intr) t (cond_diff (y intr) t) =

  derive_pt yi t (yi_derivable t)); [ intro | apply pr_nu ].

rewrite <- H; rewrite <- H2; rewrite H1; rewrite H0.

unfold vi in |- *.

repeat rewrite Rmult_assoc.

rewrite <- Rmult_plus_distr_l.

apply Rmult_le_compat_l.

left; prove_sup0.

rewrite <- Rmult_plus_distr_l.

rewrite (Rmult_comm (u0 t)); apply Rmult_le_compat_l.

left; apply (TypeSpeed_pos (h intr)).

generalize

 (sqrt_cauchy (cos (theta intr t)) (sin (theta intr t)) (xP t) (yP t));

 rewrite (Rplus_comm (Rsqr (cos (theta intr t)))); 

 rewrite sin2_cos2; rewrite sqrt_1; rewrite Rmult_1_l; 

 intro H8; unfold u0 in |- *; assumption.

set (H0 := xP_derivable t).

set (H1 := yP_derivable t).

symmetry  in |- *; reg.

unfold derive_pt in |- *; unfold derivable_pt_abs in |- *;

 cut

  (forall l : R,

   derivable_pt_lim (fun y : R => (Rsqr (xP y) + (Rsqr (yP y) + Rsqr eps))%R)

     t l <-> derivable_pt_lim (fun y : R => Rsqr (f y)) t l).

intro; unfold projT1 in |- *.

case (fct_der3 eps t); intros.

case (fct_der2 eps t); intros.

assert (H0 := H x).

unfold derivable_pt_abs in d.

elim H0; intros; fold f in d0.

assert (H3 := H1 d).

eapply uniqueness_limite.

apply H3.

apply d0.

intro; unfold derivable_pt_lim in |- *.

split; intros.

elim (H eps0 H0); intros.

exists x; intros; unfold f in |- *; unfold u in |- *.

repeat rewrite Rsqr_sqrt.

repeat rewrite Rplus_assoc.

apply H1; assumption.

repeat apply Rplus_le_le_0_compat; try apply Rle_0_sqr.

repeat apply Rplus_le_le_0_compat; try apply Rle_0_sqr.

elim (H eps0 H0); intros.

exists x; intros; unfold f in H1; unfold u in H1.

replace

 ((Rsqr (xP (t + h)) + (Rsqr (yP (t + h)) + Rsqr eps) -

   (Rsqr (xP t) + (Rsqr (yP t) + Rsqr eps))) / h - l)%R with

 ((Rsqr (sqrt (Rsqr (xP (t + h)) + Rsqr (yP (t + h)) + Rsqr eps)) -

   Rsqr (sqrt (Rsqr (xP t) + Rsqr (yP t) + Rsqr eps))) / h - l)%R.

apply H1; assumption.

repeat rewrite Rsqr_sqrt.

repeat rewrite Rplus_assoc; reflexivity.

repeat apply Rplus_le_le_0_compat; try apply Rle_0_sqr.

repeat apply Rplus_le_le_0_compat; try apply Rle_0_sqr.

Qed.



Lemma u_stric_pos : forall (eps : posreal) (t : R), (0 < u eps t)%R.

intros; unfold u in |- *; apply sqrt_lt_R0; apply Rplus_le_lt_0_compat;

 [ apply Rplus_le_le_0_compat; apply Rle_0_sqr

 | apply Rsqr_pos_lt; red in |- *; intro H; generalize (cond_pos eps);

    intro H0; rewrite H in H0; elim (Rlt_irrefl 0 H0) ].

Qed.



Lemma u_pos : forall (eps : posreal) (t : R), (0 <= u eps t)%R.

intros; left; apply u_stric_pos.

Qed.



Lemma u0_pos : forall t : R, (0 <= u0 t)%R.

intros; unfold u0 in |- *; apply sqrt_positivity; apply Rplus_le_le_0_compat;

 apply Rle_0_sqr.

Qed.



Lemma Rsqr_u_epsilon :

 forall (eps : posreal) (t : R), Rsqr (u eps t) = (Rsqr (u0 t) + Rsqr eps)%R.

intros; apply sqrt_inj;

 [ apply Rle_0_sqr

 | apply Rplus_le_le_0_compat; apply Rle_0_sqr

 | rewrite sqrt_Rsqr;

    [ unfold u0 in |- *; rewrite Rsqr_sqrt;

       [ unfold u in |- *; reflexivity

       | apply Rplus_le_le_0_compat; apply Rle_0_sqr ]

    | apply (u_pos eps t) ] ].

Qed.



Lemma u0_u_epsilon : forall (eps : posreal) (t : R), (u0 t <= u eps t)%R.

intros; apply Rsqr_incr_0;

 [ unfold u0, u in |- *; repeat rewrite Rsqr_sqrt;

    [ rewrite <- (Rplus_0_r (Rsqr (xP t) + Rsqr (yP t)));

       repeat rewrite Rplus_assoc; repeat apply Rplus_le_compat_l;

       rewrite Rplus_0_l; apply Rle_0_sqr

    | repeat apply Rplus_le_le_0_compat; apply Rle_0_sqr

    | apply Rplus_le_le_0_compat; apply Rle_0_sqr ]

 | apply u0_pos

 | apply u_pos ].

Qed.



Lemma u_epsilon_le_v :

 forall (eps : posreal) (t : R), (derive_pt (u eps) t (d_u eps t) <= vi)%R.

intros.

generalize (D_Rsqr_u_epsilon_2 eps t); intro H.

rewrite (D_Rsqr_u_epsilon_1 eps t) in H.

repeat rewrite Rmult_assoc in H.

assert (Hyp : (0 < 2)%R).

prove_sup0.

generalize

 (Rmult_le_reg_l 2 (u eps t * derive_pt (u eps) t (d_u eps t)) 

    (u0 t * vi) Hyp H); intro H1.

generalize (u0_u_epsilon eps t); intro H2;

 generalize

  (Rmult_le_compat_r (v vi) (u0 t) (u eps t) (Rlt_le 0 vi (TypeSpeed_pos vi))

     H2); intro H3.

generalize

 (Rle_trans (u eps t * derive_pt (u eps) t (d_u eps t)) 

    (u0 t * vi) (u eps t * vi) H1 H3); intro H4.

apply

 (Rmult_le_reg_l (u eps t) (derive_pt (u eps) t (d_u eps t)) vi

    (u_stric_pos eps t) H4).

Qed.



Lemma vit_derivable : derivable (fun t : R => (vi * t)%R).

reg.

Qed.



Lemma derive_vit :

 forall t : R, derive_pt (fun t : R => (vi * t)%R) t (vit_derivable t) = vi.

intro; reg.

Qed.



Lemma u_epsilon_le_vt :

 forall (eps : posreal) (t : R), (0 <= t)%R -> (u eps t - eps <= vi * t)%R.

intros.

generalize

 (IAF_var (fun t : R => (vi * t)%R) (fun t : R => u eps t) 0 t vit_derivable

    (d_u eps) H); intros.

cut (u eps 0 = eps).

intro H1.

rewrite <- H1.

elim H0; intros.

rewrite Rmult_0_r in H2; unfold Rminus in H2; rewrite Ropp_0 in H2;

 rewrite Rplus_0_r in H2; left; assumption.

rewrite Rmult_0_r in H2; unfold Rminus in H2; rewrite Ropp_0 in H2;

 rewrite Rplus_0_r in H2; right; assumption.

rewrite (derive_vit c); apply (u_epsilon_le_v eps c).

unfold u in |- *; unfold xP in |- *; unfold yP in |- *; unfold Rminus in |- *;

 repeat rewrite Rplus_opp_r; rewrite Rsqr_0; repeat rewrite Rplus_0_l;

 apply (sqrt_Rsqr eps (Rlt_le 0 eps (cond_pos eps))).

Qed.



Lemma Rsqr_u :

 forall (eps : posreal) (t : R),

 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + 2 * eps * vi * t)%R.

intros; cut (u eps t <= vi * t + eps)%R.

intro H0; generalize (u_pos eps t); intro H1;

 generalize

  (Rsqr_incr_1 (u eps t) (vi * t + eps) H0 H1

     (Rle_trans 0 (u eps t) (vi * t + eps) H1 H0)); 

 intro H2; rewrite Rsqr_plus in H2; rewrite Rsqr_u_epsilon in H2;

 rewrite Rsqr_mult in H2; rewrite <- (Rplus_comm (2 * (vi * t) * eps)) in H2;

 generalize

  (Rplus_le_compat_r (- Rsqr eps) (Rsqr (u0 t) + Rsqr eps)

     (2 * (vi * t) * eps + (Rsqr vi * Rsqr t + Rsqr eps)) H2);

 unfold Rminus in |- *; repeat rewrite Rplus_assoc;

 repeat rewrite Rplus_opp_r; repeat rewrite Rplus_0_r; 

 intro H3;

 replace (Rsqr vi * Rsqr t + 2 * eps * vi * t)%R with

  (2 * (vi * t) * eps + Rsqr vi * Rsqr t)%R.

assumption.

ring.

apply Rplus_le_reg_l with (- eps)%R; rewrite Rplus_comm;

 replace (- eps + (vi * t + eps))%R with (vi * t)%R.

generalize (u_epsilon_le_vt eps t H); unfold Rminus in |- *; intro;

 assumption.

ring.

Qed.



Lemma Rsqr_u_Rsqr_vt :

 forall (eps : posreal) (t : R),

 (0 <= t)%R -> (Rsqr (u0 t) <= Rsqr vi * Rsqr t + eps)%R.

intros; case (Rtotal_order 0 t); intro.

cut (0 < eps / (2 * vi * t))%R.

intro; generalize (Rsqr_u (mkposreal (eps / (2 * vi * t)) H1) t H);

 simpl in |- *;

 replace (2 * (eps / (2 * vi * t)) * vi * t)%R with (eps * 1)%R.

rewrite Rmult_1_r; intro; assumption.

unfold Rdiv in |- *; repeat rewrite Rinv_mult_distr.

replace (2 * (eps * (/ 2 * / vi * / t)) * vi * t)%R with

 (eps * (2 * / 2) * (/ vi * vi) * (/ t * t))%R.

repeat rewrite <- Rinv_l_sym.

rewrite <- Rinv_r_sym.

repeat rewrite Rmult_1_r; reflexivity.

discrR.

red in |- *; intro H2; rewrite H2 in H0; elim (Rlt_irrefl 0 H0).

generalize (TypeSpeed_pos vi); intro H2; red in |- *; intro H3;

 rewrite H3 in H2; elim (Rlt_irrefl 0 H2).

ring.

discrR.

generalize (TypeSpeed_pos vi); intro H2; red in |- *; intro H3;

 rewrite H3 in H2; elim (Rlt_irrefl 0 H2).

apply prod_neq_R0.

discrR.

generalize (TypeSpeed_pos vi); intro H2; red in |- *; intro H3;

 rewrite H3 in H2; elim (Rlt_irrefl 0 H2).

red in |- *; intro H2; rewrite H2 in H0; elim (Rlt_irrefl 0 H0).

unfold Rdiv in |- *; apply Rmult_lt_0_compat.

apply (cond_pos eps).

apply Rinv_0_lt_compat; repeat apply Rmult_lt_0_compat.

prove_sup0.

apply (TypeSpeed_pos vi).

assumption.

elim H0; intro.

rewrite <- H1; unfold u0 in |- *; unfold xP, yP in |- *;

 unfold Rminus in |- *; repeat rewrite Rplus_opp_r; 

 repeat rewrite Rsqr_0; rewrite Rmult_0_r; repeat rewrite Rplus_0_l;

 rewrite sqrt_0; rewrite Rsqr_0; left; apply (cond_pos eps).

elim (Rlt_irrefl 0 (Rle_lt_trans 0 t 0 H H1)).

Qed.



Theorem YCNGFTYS :

 forall t : R,

 (0 <= t)%R -> (sqrt (Rsqr (xi t - xi 0) + Rsqr (yi t - yi 0)) <= v vi * t)%R.

intros; apply Rsqr_incr_0.

rewrite Rsqr_mult; apply le_epsilon; intros;

 generalize (Rsqr_u_Rsqr_vt (mkposreal eps H0) t H); 

 simpl in |- *; unfold u0 in |- *; unfold xP, yP in |- *; 

 intro H1; assumption.

apply sqrt_positivity; apply Rplus_le_le_0_compat; apply Rle_0_sqr.

apply Rmult_le_pos; [ left; apply (TypeSpeed_pos vi) | assumption ].

Qed.



End ycngftys.

