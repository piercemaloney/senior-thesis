
Require Import Reals.
Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)
Require Import rrho.
(* rrho:
Require Import Reals.
Require Import trajectory_const.

Definition rho (h : TypeSpeed) : R := (g * (tan MaxBank / h))%R.
Definition r (h : TypeSpeed) : R := (h / rho h)%R.
Definition rho_ub (h : TypeSpeed) : R := (g * (tan_ub_MaxBank / h))%R.
Definition rho_lb (h : TypeSpeed) : R := (g * (tan_lb_MaxBank / h))%R.

Lemma TypeSpeed_pos : forall h : TypeSpeed, (0 < h)%R.

Lemma g_pos : (0 < g)%R.

Lemma rho_ub_0 : forall h : TypeSpeed, (rho h < rho_ub h)%R.

Lemma rho_lb_0 : forall h : TypeSpeed, (rho_lb h < rho h)%R.

Definition r_ub (h : TypeSpeed) : R := (h / rho_lb h)%R.
Definition r_lb (h : TypeSpeed) : R := (h / rho_ub h)%R.

Lemma tan_lb_MaxBank_pos : (0 < tan_lb_MaxBank)%R.

Lemma tan_ub_MaxBank_pos : (0 < tan_ub_MaxBank)%R.

Lemma rho_lb_pos : forall h : TypeSpeed, (0 < rho_lb h)%R.

Lemma rho_pos : forall h : TypeSpeed, (0 < rho h)%R.

Lemma rho_ub_pos : forall h : TypeSpeed, (0 < rho_ub h)%R.

Lemma r_ub_0 : forall h : TypeSpeed, (r h < r_ub h)%R.

Lemma r_lb_0 : forall h : TypeSpeed, (r_lb h < r h)%R.

Lemma rho_PI2 : forall h : TypeSpeed, (rho h <= PI / 2)%R.

Lemma rho_strict_decreasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (rho h2 < rho h1)%R.

Lemma r_stric_increasing :
 forall h1 h2 : TypeSpeed, (h1 < h2)%R -> (r h1 < r h2)%R. *)
Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)
Require Import Omega.

Axiom
  Math_prop_alarm_1 :
    forall (a l : R) (T : TimeT),
    (MinDistance T <= l)%R ->
    (l <= MaxDistance T)%R ->
    (0 <= a)%R ->
    (a <= MinBeta)%R ->
    (Rsqr (l * cos a - v V * T) + Rsqr (l * sin a) <= Rsqr AlertRange)%R.

Axiom
  Math_prop_no_conflict_1 :
    forall (a l x y : R) (T : TimeT),
    (MinDistance T <= l)%R ->
    (l <= MaxDistance T)%R ->
    (MinBeta <= a)%R ->
    (a <= PI / 2)%R ->
    (l * sin a + r_V * (cos (rho_V * T) - 1) <= y)%R ->
    (r_V * sin (rho_V * T) - l * cos a <= x)%R ->
    (Rsqr ConflictRange < Rsqr x + Rsqr y)%R.

Lemma MinBeta_pos : (0 < MinBeta)%R.
unfold MinBeta in |- *; unfold Rdiv in |- *.
apply Rmult_lt_0_compat; [ prove_sup | apply Rinv_0_lt_compat; prove_sup ].
Qed.

Lemma Math_prop_y_a_PI2 :
 forall (a l : R) (T : TimeT),
 (MinBeta <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l)%R ->
 (l * sin MinBeta + r_V * (cos (rho_V * T) - 1) <=
  l * sin a + r_V * (cos (rho_V * T) - 1))%R. 
intros; apply Rplus_le_compat_r; apply Rmult_le_compat_l;
 [ assumption
 | apply sin_incr_1;
    [ left; apply Rlt_trans with 0%R;
       [ apply _PI2_RLT_0 | apply MinBeta_pos ]
    | apply Rle_trans with a; assumption
    | left; apply Rlt_trans with 0%R;
       [ apply _PI2_RLT_0
       | apply Rlt_le_trans with MinBeta; [ apply MinBeta_pos | assumption ] ]
    | assumption
    | assumption ] ].
Qed.

Lemma Math_prop_approx_y_a_PI2 :
 forall (a l1 l2 : R) (T : TimeT),
 (0 <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l1)%R ->
 (l1 <= l2)%R ->
 (l1 * sin_lb a + r_ub V * (cos_lb (rho_ub V * MaxT) - 1) <=
  l2 * sin a + r_V * (cos (rho_V * T) - 1))%R.
intros; apply Rplus_le_compat.
apply Rle_trans with (l1 * sin a)%R.
apply Rmult_le_compat_l.
assumption.
generalize (SIN a H (Rlt_le a PI (Rle_lt_trans a (PI / 2) PI H0 PI2_Rlt_PI)));
 intro; elim H3; intros; assumption.
apply Rmult_le_compat_r.
apply (sin_ge_0 a H (Rlt_le a PI (Rle_lt_trans a (PI / 2) PI H0 PI2_Rlt_PI))).
assumption.
rewrite <- (Ropp_involutive (r_ub V * (cos_lb (rho_ub V * MaxT) - 1)));
 rewrite <- (Ropp_involutive (r_V * (cos (rho_V * T) - 1)));
 apply Ropp_ge_le_contravar; apply Rle_ge;
 replace (- (r_V * (cos (rho_V * T) - 1)))%R with
  (r_V * (1 - cos (rho_V * T)))%R.
replace (- (r_ub V * (cos_lb (rho_ub V * MaxT) - 1)))%R with
 (r_ub V * (1 - cos_lb (rho_ub V * MaxT)))%R.
apply Rmult_le_compat.
left; apply r_V_is_pos.
apply Rplus_le_reg_l with (cos (rho_V * T)); rewrite Rplus_0_r;
 rewrite Rplus_comm; unfold Rminus in |- *; repeat rewrite Rplus_assoc;
 rewrite Rplus_opp_l; rewrite Rplus_0_r; generalize (COS_bound (rho_V * T));
 intro; elim H3; intros; assumption.
unfold r_V in |- *; left; apply r_ub_0.
apply Rplus_le_reg_l with (Ropp 1); unfold Rminus in |- *;
 repeat rewrite <- Rplus_assoc; repeat rewrite Rplus_opp_l;
 repeat rewrite Rplus_0_l; apply Ropp_ge_le_contravar; 
 apply Rle_ge; apply Rle_trans with (cos (rho_ub V * MaxT)).
cut (- PI / 2 <= rho_ub V * MaxT <= PI / 2)%R.
intro; elim H3; intros; generalize (COS (rho_ub V * MaxT) H4 H5); intro;
 elim H6; intros; assumption.
split.
left; apply Rlt_le_trans with 0%R.
replace (- PI / 2)%R with (- (PI / 2))%R.
apply _PI2_RLT_0.
unfold Rdiv in |- *; symmetry  in |- *; apply Ropp_mult_distr_l_reverse.
apply Rmult_le_pos.
left; apply rho_ub_pos.
left; unfold MaxT in |- *.
prove_sup.
cut (MaxT <= MaxT)%R.
intro; left; apply (rho_ub_t_PI2 V (mkTimeT MaxT MinT_MaxT H3)).
right; reflexivity.
apply cos_decr_1.
left; apply Rmult_lt_0_compat.
apply rho_V_is_pos.
apply Rlt_le_trans with MinT.
apply MinT_is_pos.
apply (cond_1 T).
left; apply Rlt_trans with (PI / 2)%R.
apply (rho_t_PI2 T). 
apply PI2_Rlt_PI.
left; apply Rmult_lt_0_compat.
apply rho_ub_pos.
unfold MaxT in |- *; prove_sup.
left; apply Rlt_trans with (PI / 2)%R.
cut (MaxT <= MaxT)%R.
intro; apply (rho_ub_t_PI2 V (mkTimeT MaxT MinT_MaxT H3)).
right; reflexivity.
apply PI2_Rlt_PI.
apply Rmult_le_compat.
left; apply rho_V_is_pos.
left; apply Rlt_le_trans with MinT; [ apply MinT_is_pos | apply (cond_1 T) ].
left; unfold rho_V in |- *; apply rho_ub_0.
apply (cond_2 T).
ring.
ring.
Qed.

Lemma Math_prop_x_a_PI2 :
 forall (a l : R) (T : TimeT),
 (MinBeta <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l)%R ->
 (r_V * sin (rho_V * T) - l * cos MinBeta <=
  r_V * sin (rho_V * T) - l * cos a)%R.
intros; unfold Rminus in |- *; apply Rplus_le_compat_l;
 apply Ropp_ge_le_contravar; apply Rle_ge; apply Rmult_le_compat_l;
 [ assumption
 | apply cos_decr_1;
    [ left; apply MinBeta_pos
    | apply Rle_trans with a;
       [ assumption
       | left; apply Rle_lt_trans with (PI / 2)%R;
          [ assumption | apply PI2_Rlt_PI ] ]
    | left; apply Rlt_le_trans with MinBeta;
       [ apply MinBeta_pos | assumption ]
    | left; apply Rle_lt_trans with (PI / 2)%R;
       [ assumption | apply PI2_Rlt_PI ]
    | assumption ] ].
Qed.

Lemma Math_prop_approx_x_a_PI2 :
 forall (a l1 l2 : R) (T : TimeT),
 (0 <= a)%R ->
 (a <= PI / 2)%R ->
 (0 <= l1)%R ->
 (l1 <= l2)%R ->
 (r_lb V * sin_lb (rho_lb V * MinT) - l2 * cos_ub a <=
  r_V * sin (rho_V * T) - l1 * cos a)%R.
intros; unfold Rminus in |- *; apply Rplus_le_compat.
apply Rmult_le_compat.
left; unfold r_lb in |- *; unfold Rdiv in |- *; apply Rmult_lt_0_compat;
 [ apply TypeSpeed_pos | apply Rinv_0_lt_compat; apply rho_ub_pos ].
apply sin_lb_ge_0.
left; apply Rmult_lt_0_compat; [ apply rho_lb_pos | apply MinT_is_pos ].
apply Rle_trans with (rho_V * MinT)%R.
apply Rmult_le_compat_r.
left; apply MinT_is_pos.
unfold rho_V in |- *; left; apply rho_lb_0.
cut (MinT <= MinT)%R.
intro; left; apply (rho_t_PI2 (mkTimeT MinT H3 MinT_MaxT)).
right; reflexivity.
unfold r_V in |- *; left; apply r_lb_0.
apply Rle_trans with (sin (rho_lb V * MinT)).
cut (0 <= rho_lb V * MinT <= PI)%R.
intro; elim H3; intros.
generalize (SIN (rho_lb V * MinT) H4 H5); intro; elim H6; intros; assumption.
split.
left; apply Rmult_lt_0_compat.
apply rho_lb_pos.
apply MinT_is_pos.
left; apply Rle_lt_trans with (PI / 2)%R.
apply Rle_trans with (rho_V * MinT)%R.
apply Rmult_le_compat_r.
left; apply MinT_is_pos.
unfold rho_V in |- *; left; apply rho_lb_0.
cut (MinT <= MinT)%R.
intro; left; apply (rho_t_PI2 (mkTimeT MinT H3 MinT_MaxT)).
right; reflexivity.
apply PI2_Rlt_PI.
apply sin_incr_1.
left; apply Rlt_trans with 0%R.
apply _PI2_RLT_0.
apply Rmult_lt_0_compat.
apply rho_lb_pos.
apply MinT_is_pos.
apply Rle_trans with (rho_V * MinT)%R.
apply Rmult_le_compat_r.
left; apply MinT_is_pos.
unfold rho_V in |- *; left; apply rho_lb_0.
cut (MinT <= MinT)%R.
intro; left; apply (rho_t_PI2 (mkTimeT MinT H3 MinT_MaxT)).
right; reflexivity.
left; apply Rlt_trans with 0%R.
apply _PI2_RLT_0.
apply Rmult_lt_0_compat.
apply rho_V_is_pos.
apply Rlt_le_trans with MinT.
apply MinT_is_pos.
apply (cond_1 T).
left; apply (rho_t_PI2 T).
apply Rmult_le_compat.
left; apply rho_lb_pos.
left; apply MinT_is_pos.
left; unfold rho_V in |- *; apply rho_lb_0.
apply (cond_1 T).
apply Ropp_ge_le_contravar; apply Rle_ge.
apply Rmult_le_compat.
assumption.
apply cos_ge_0.
left; apply Rlt_le_trans with 0%R.
apply _PI2_RLT_0.
assumption.
assumption.
assumption.
cut (- PI / 2 <= a)%R.
intro; generalize (COS a H3 H0); intro; elim H4; intros; assumption.
left; apply Rlt_le_trans with 0%R.
replace (- PI / 2)%R with (- (PI / 2))%R.
apply _PI2_RLT_0.
unfold Rdiv in |- *; symmetry  in |- *; apply Ropp_mult_distr_l_reverse.
assumption.
Qed.

Lemma Math_prop_no_conflict_2 :
 forall (a l x y : R) (T : TimeT),
 (MinDistance T <= l)%R ->
 (l <= MaxDistance T)%R ->
 (3 * (PI / 2) <= a)%R ->
 (a <= 2 * PI - MinBeta)%R ->
 (y <= l * sin a - r_V * (cos (rho_V * T) - 1))%R ->
 (r_V * sin (rho_V * T) - l * cos a <= x)%R ->
 (Rsqr ConflictRange < Rsqr x + Rsqr y)%R.
intros.
cut (MinBeta <= 2 * PI - a)%R.
cut (2 * PI - a <= PI / 2)%R.
cut (l * sin (2 * PI - a) + r_V * (cos (rho_V * T) - 1) <= - y)%R.
intros; rewrite (Rsqr_neg y);
 apply (Math_prop_no_conflict_1 (2 * PI - a) l x (- y) T H H0 H7 H6 H5).
replace (2 * PI - a)%R with (- a + 2 * INR 1 * PI)%R;
 [ rewrite (cos_period (- a) 1); rewrite cos_neg; assumption | simpl; ring ].
replace (2 * PI - a)%R with (- a + 2 * INR 1 * PI)%R;
 [ rewrite (sin_period (- a) 1); rewrite sin_neg;
    replace (l * - sin a + r_V * (cos (rho_V * T) - 1))%R with
     (- (l * sin a - r_V * (cos (rho_V * T) - 1)))%R;
    [ apply Ropp_ge_le_contravar; apply Rle_ge; assumption | simpl; ring ]
 | simpl; ring ].
generalize (Rplus_le_compat_l (PI / 2 - a) (3 * (PI / 2)) a H1);
 replace (PI / 2 - a + 3 * (PI / 2))%R with (2 * PI - a)%R.
replace (PI / 2 - a + a)%R with (PI / 2)%R.
intro; assumption.
unfold Rminus in |- *; rewrite Rplus_assoc; rewrite Rplus_opp_l;
 rewrite Rplus_0_r; reflexivity. 
rewrite double.
pattern PI at 1 2 in |- *; rewrite double_var.
ring.
generalize (Rplus_le_compat_l (MinBeta - a) a (2 * PI - MinBeta) H2);
 replace (MinBeta - a + (2 * PI - MinBeta))%R with (2 * PI - a)%R;
 [ replace (MinBeta - a + a)%R with MinBeta; [ intro; assumption | ring ]
 | ring ].
Qed.

Lemma Math_prop_alarm_2 :
 forall (a l : R) (T : TimeT),
 (MinDistance T <= l)%R ->
 (l <= MaxDistance T)%R ->
 (2 * PI - MinBeta <= a)%R ->
 (a <= 2 * PI)%R ->
 (Rsqr (l * cos a - v V * T) + Rsqr (l * sin a) <= Rsqr AlertRange)%R.
intros.
cut (0 <= 2 * PI - a)%R.
cut (2 * PI - a <= MinBeta)%R.
cut (cos (2 * PI - a) = cos a).
cut (sin (2 * PI - a) = (- sin a)%R).
intros; rewrite Rsqr_mult; rewrite (Rsqr_neg (sin a)); rewrite <- H3;
 rewrite <- H4; rewrite <- Rsqr_mult;
 apply (Math_prop_alarm_1 (2 * PI - a) l T H H0 H6 H5).
replace (2 * PI - a)%R with (- a + 2 * INR 1 * PI)%R;
 [ rewrite (sin_period (- a) 1); apply sin_neg | simpl; ring ].
replace (2 * PI - a)%R with (- a + 2 * INR 1 * PI)%R;
 [ rewrite (cos_period (- a) 1); apply cos_neg | simpl; ring ].
generalize (Rplus_le_compat_l (MinBeta - a) (2 * PI - MinBeta) a H1);
 replace (MinBeta - a + (2 * PI - MinBeta))%R with (2 * PI - a)%R;
 [ replace (MinBeta - a + a)%R with MinBeta; [ intro; assumption | ring ]
 | ring ].
generalize (Rplus_le_compat_r (- a) a (2 * PI) H2); rewrite Rplus_opp_r;
 intro; assumption.
Qed.
