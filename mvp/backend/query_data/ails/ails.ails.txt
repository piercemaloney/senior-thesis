

Require Import Reals.

Require Import trajectory_const.
(* trajectory_const:
Require Import Reals.
Require Export pi_ineq.

Definition g : R := (322 / 10)%R.
Definition ConflictRange : R := 200%R.
Definition MinSpeed : R := 201%R.
Definition MaxSpeed : R := 880%R.
Definition MaxBank : R := (61 / 100)%R.

Record TypeSpeed : Type := mkTypeSpeed
  {v :> R; v_cond1 : (MinSpeed <= v)%R; v_cond2 : (v <= MaxSpeed)%R}.

Definition tan_lb_MaxBank : R := (6 / 10)%R.
Definition tan_ub_MaxBank : R := (7 / 10)%R.

Lemma tanBank_def :
 forall x : R, (- MaxBank <= x)%R -> (x <= MaxBank)%R -> cos x <> 0%R.

Axiom tan_MaxBank_approx : (tan_lb_MaxBank < tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_ub : (tan MaxBank < tan_ub_MaxBank)%R.

Lemma tan_MaxBank_lb : (tan_lb_MaxBank < tan MaxBank)%R.

Lemma tan_MaxBank_pos : (0 < tan MaxBank)%R. *)

Require Import constants.
(* constants:
Section constants.

Require Import Reals.
Require Import trajectory_const.
Require Import rrho.
Require Import trajectory_def.

Variable intr : Trajectory.
Variable evad : EvaderTrajectory.

Lemma Rle_201_250 : (MinSpeed <= 250)%R.

Lemma Rle_250_880 : (250 <= MaxSpeed)%R.

Definition V : TypeSpeed := mkTypeSpeed 250 Rle_201_250 Rle_250_880.
Definition r_V : R := r V.
Definition rho_V : R := rho V.
Definition AlertTime : R := 19%R.
Definition AlertRange : R := 1400%R.
Definition tstep : R := (/ 2)%R.
Definition MaxStep : R := 1%R.
Definition MaxT : R := 10%R.
Definition MinT : R := (MaxT - tstep)%R.
Definition m (t : R) : R :=
  let z := IZR 2 in (z * r_V * sin (rho_V * (t / z)))%R.
Definition m_rho_ub (t : R) : R :=
  let z := IZR 2 in (z * r_lb V * sin_lb (rho_lb V * (t / z)))%R.

Record TimeT : Type := mkTimeT
  {val :> R; cond_1 : (MinT <= val)%R; cond_2 : (val <= MaxT)%R}.

Lemma MinT_is_pos : (0 < MinT)%R.

Theorem rho_ub_t_PI2 :
 forall (h : TypeSpeed) (t : TimeT), (rho_ub h * t < PI / 2)%R.

Theorem rho_t_PI2 : forall t : TimeT, (rho_V * t < PI / 2)%R.

Lemma rho_t_2 : forall t : TimeT, (rho_V * t < 2)%R.

Lemma r_V_is_pos : (0 < r_V)%R.

Lemma rho_V_is_pos : (0 < rho_V)%R.

Lemma m_le : forall t1 t2 : TimeT, (t1 <= t2)%R -> (m t1 <= m t2)%R.

Lemma m_rho_ub_0 : forall t : TimeT, (m_rho_ub t <= m t)%R.

Lemma m_rho_T_pos : forall t : TimeT, (0 < m t)%R.

Variable T : TimeT.

Definition MaxDistance : R := (V * T + ConflictRange)%R.
Definition MinDistance : R := (m T - ConflictRange)%R.
Definition MaxDistance_ub : R := (V * MaxT + ConflictRange)%R.
Definition MinDistance_lb : R := (m_rho_ub MinT - ConflictRange)%R.

Lemma MaxDistance_ub_0 : (MaxDistance <= MaxDistance_ub)%R.

Lemma MinT_MaxT : (MinT <= MaxT)%R.

Lemma MinDistance_lb_0 : (MinDistance_lb <= MinDistance)%R.

Axiom MinDistance_lb_majoration : (V + ConflictRange < MinDistance_lb)%R.

Lemma MinDistance_lb_pos : (0 < MinDistance_lb)%R.

Lemma MinDistance_pos : (0 < MinDistance)%R.

Definition MinBeta : R := (539 / 1000)%R.

End constants. *)

Require Import ails_def.
(* ails_def:
Require Import Reals.
Require Import trajectory_const.
Require Import constants.

Record Bank : Type := mkBank
  {r :> R; cond1 : (- toDeg MaxBank <= r)%R; cond2 : (r <= toDeg MaxBank)%R}.

Record State : Type := mkState {xt : R; yt : R; heading : R; bank : Bank}.

Definition intruderSpeed : TypeSpeed := V.
Definition evaderSpeed : TypeSpeed := V. *)

Require Import tau.
(* tau:
Require Import Reals.
Require Import ails_def.
Require Import trajectory_const.

Unset Standard Proposition Elimination Names.

Definition dx (intruder evader : State) (t : R) : R :=
  (xt intruder + t * intruderSpeed * cosd (heading intruder) -
   (xt evader + t * evaderSpeed))%R.
Definition dy (intruder evader : State) (t : R) : R :=
  (yt intruder + t * intruderSpeed * sind (heading intruder) - yt evader)%R.
Definition dxdt (intruder : State) : R :=
  (intruderSpeed * cosd (heading intruder) - evaderSpeed)%R.
Definition dydt (intruder : State) : R :=
  (intruderSpeed * sind (heading intruder))%R.
Definition RR (intruder evader : State) (t : R) : R :=
  sqrt (Rsqr (dx intruder evader t) + Rsqr (dy intruder evader t)).
Definition div_tau (intruder evader : State) : R :=
  (Rsqr (dxdt intruder) + Rsqr (dydt intruder))%R.

Lemma Req_EM_var : forall r1 r2 : R, {r1 = r2} + {r1 <> r2}. 

Definition tau (intruder evader : State) (t : R) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dx intruder evader t * dxdt intruder +
        dy intruder evader t * dydt intruder) / div_tau intruder evader)%R
  end.  
Definition tmin (intruder evader : State) : R :=
  match Req_EM_var (div_tau intruder evader) 0 with
  | left _ => 0%R
  | right _ =>
      (-
       (dxdt intruder * (xt intruder - xt evader) +
        dydt intruder * (yt intruder - yt evader)) / 
       div_tau intruder evader)%R
  end.

Lemma tau_tmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader t = (tmin intruder evader - t)%R.

Definition Ax2_R (intruder : State) : R :=
  (Rsqr (sind (heading intruder) * intruderSpeed) +
   Rsqr (- evaderSpeed + cosd (heading intruder) * intruderSpeed))%R.

Lemma Ax2_R_pos : forall intruder : State, (0 <= Ax2_R intruder)%R.

Definition Bx_R (intruder evader : State) : R :=
  (-2 * (yt evader * sind (heading intruder) * intruderSpeed) +
   2 * (yt intruder * sind (heading intruder) * intruderSpeed) -
   2 * (cosd (heading intruder) * xt evader * intruderSpeed) +
   2 * (cosd (heading intruder) * xt intruder * intruderSpeed) +
   2 * (xt evader * evaderSpeed) - 2 * (xt intruder * evaderSpeed))%R.

Definition C_R (intruder evader : State) : R :=
  (Rsqr (yt intruder - yt evader) + Rsqr (xt intruder - xt evader))%R.

Lemma Rsqr_R :
 forall (intruder evader : State) (t : R),
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr t + Bx_R intruder evader * t + C_R intruder evader)%R.

Definition Rsqr_Rmin (intruder evader : State) : R :=
  match Req_EM_var (Ax2_R intruder) 0 with
  | left _ => 0%R
  | right _ =>
      ((4 * Ax2_R intruder * C_R intruder evader -
        Rsqr (Bx_R intruder evader)) / (4 * Ax2_R intruder))%R
  end.

Lemma tmin_0 :
 forall intruder evader : State,
 div_tau intruder evader <> 0%R ->
 tmin intruder evader = (- Bx_R intruder evader / (2 * Ax2_R intruder))%R.

Lemma Ax2_R_0_div_tau :
 forall intruder evader : State,
 div_tau intruder evader = 0%R -> Ax2_R intruder = 0%R.

Lemma div_tau_0_Ax2_R :
 forall intruder evader : State,
 Ax2_R intruder = 0%R -> div_tau intruder evader = 0%R.

Lemma R_Rmin :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader <> 0%R ->
 Rsqr (RR intruder evader t) =
 (Ax2_R intruder * Rsqr (t - tmin intruder evader) +
  Rsqr_Rmin intruder evader)%R.

Lemma dx_dxdt :
 forall (intruder evader : State) (t : R),
 (xt intruder - xt evader + t * dxdt intruder)%R = dx intruder evader t.

Lemma dy_dydt :
 forall (intruder evader : State) (t : R),
 (yt intruder - yt evader + t * dydt intruder)%R = dy intruder evader t.

Lemma R_equal_when_zero :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader = 0%R ->
 RR intruder evader t1 = RR intruder evader t2.

Lemma RR_pos :
 forall (intruder evader : State) (t : R), (0 <= RR intruder evader t)%R.

Lemma derivative_eq_zero_tmin :
 forall (intruder evader : State) (t : R),
 (RR intruder evader (tmin intruder evader) <= RR intruder evader t)%R.

Lemma derivative_eq_zero_min :
 forall (intruder evader : State) (t1 t2 : R),
 (RR intruder evader (t1 + tau intruder evader t1) <=
  RR intruder evader (t1 + t2))%R.

Lemma asymptotic_decrease_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (t2 <= tmin intruder evader)%R ->
 (t1 <= t2)%R -> (RR intruder evader t2 <= RR intruder evader t1)%R.

Lemma asymptotic_decrease_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (t2 <= tau intruder evader t)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t2) <= RR intruder evader (t + t1))%R.

Lemma asymptotic_increase_tmin :
 forall (intruder evader : State) (t1 t2 : R),
 (tmin intruder evader <= t1)%R ->
 (t1 <= t2)%R -> (RR intruder evader t1 <= RR intruder evader t2)%R.

Lemma asymptotic_increase_tau :
 forall (intruder evader : State) (t t1 t2 : R),
 (tau intruder evader t <= t1)%R ->
 (t1 <= t2)%R ->
 (RR intruder evader (t + t1) <= RR intruder evader (t + t2))%R.

Lemma tau_equal_when_zero :
 forall (intruder evader : State) (t : R),
 div_tau intruder evader = 0%R -> tau intruder evader t = 0%R.

Lemma asymptotic_tau_gt :
 forall (intruder evader : State) (t dt : R),
 (0 <= dt)%R ->
 (RR intruder evader (t + dt) < RR intruder evader t)%R ->
 (0 < tau intruder evader t)%R.

Lemma tau_is_uniform :
 forall (intruder evader : State) (t1 t2 : R),
 div_tau intruder evader <> 0%R ->
 tau intruder evader (t1 + t2) = (tau intruder evader t1 - t2)%R.

Lemma tau_gt_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t < tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t < tau intruder evader t1)%R.

Lemma tau_ge_time :
 forall (intruder evader : State) (t1 t2 t : R),
 (t <= tau intruder evader t2)%R ->
 (t1 <= t2)%R -> (t <= tau intruder evader t1)%R. *)

Require Import Omega.



Unset Standard Proposition Elimination Names.



Fixpoint rest (p r s n : nat) {struct n} : nat :=

  match n with

  | O => r

  | S n' =>

      match s with

      | O => 0

      | S O => rest p 0 p n'

      | S s' => rest p (S r) s' n'

      end

  end.

  

Definition mod_ (m n : nat) : nat := rest n 0 n m.



Lemma mod_eq_0 : forall m : nat, mod_ 0 m = 0.

Proof with trivial.

intro m; unfold mod_ in |- *; unfold rest in |- *...

Qed.



Definition trkrate (phi : Bank) : R :=

  toDeg (g * (tand phi / v intruderSpeed)).



Lemma cond1_0 : (- toDeg MaxBank <= 0)%R.

left; rewrite <- Ropp_0; apply Ropp_lt_gt_contravar; unfold toDeg in |- *;

repeat simple apply Rmult_lt_0_compat.

unfold MaxBank in |- *; unfold Rdiv in |- *; apply Rmult_lt_0_compat.

prove_sup.

apply Rinv_0_lt_compat; prove_sup.

unfold plat in |- *; prove_sup.

apply Rinv_0_lt_compat; apply PI_RGT_0.

Qed.



Lemma cond2_0 : (0 <= toDeg MaxBank)%R.

left; unfold toDeg in |- *; repeat simple apply Rmult_lt_0_compat.

unfold MaxBank in |- *; unfold Rdiv in |- *; apply Rmult_lt_0_compat.

prove_sup.

apply Rinv_0_lt_compat; prove_sup.

unfold plat in |- *; prove_sup.

apply Rinv_0_lt_compat; apply PI_RGT_0.

Qed.



Lemma trkrate0 : trkrate (mkBank 0 cond1_0 cond2_0) = 0%R.

Proof with trivial.

unfold trkrate in |- *; replace (r (mkBank 0 cond1_0 cond2_0)) with 0%R...

unfold toDeg, tand in |- *; unfold toRad in |- *; repeat rewrite Rmult_0_l;

 rewrite tan_0; unfold Rdiv in |- *; repeat rewrite Rmult_assoc;

 repeat rewrite Rmult_0_l; apply Rmult_0_r...

Qed.



Definition distance (s1 s2 : State) : R :=

  sqrt (Rsqr (xt s2 - xt s1) + Rsqr (yt s2 - yt s1)).



Lemma distance_sym : forall s1 s2 : State, distance s1 s2 = distance s2 s1.

Proof with trivial.

intros; unfold distance in |- *; rewrite (Rsqr_neg (xt s2 - xt s1));

 rewrite (Rsqr_neg (yt s2 - yt s1)); repeat rewrite Ropp_minus_distr...

Qed.



Definition alerting_distance (s1 s2 : State) : Prop :=

  (distance s1 s2 <= AlertRange)%R.



Definition conflict_distance (s1 s2 : State) : Prop :=

  (distance s1 s2 <= ConflictRange)%R.



Definition chkrange (range tpred : R) : Prop :=

  (range <= AlertRange)%R /\ (tpred <= AlertTime)%R.



Definition chktrack (intruder evader : State) (tpred : R) : Prop :=

  let tau := tau intruder evader 0 in

  match Rle_dec tau 0 with

  | left _ => chkrange (RR intruder evader 0) tpred

  | right _ =>

      match Rlt_dec AlertTime (tpred + tau) with

      | left _ => (RR intruder evader AlertTime <= AlertRange)%R

      | right _ => (RR intruder evader tau <= AlertRange)%R

      end

  end.



Definition arc_loop (intruder evader : State) (arcrad trkrate : R)

  (idtrk iarc : nat) : Prop :=

  match iarc with

  | S p => False

  | O =>

      let tpred := (INR iarc * tstep)%R in

      let xloc := (xt evader + v evaderSpeed * tpred)%R in

      let yloc := yt evader in

      let xtrk :=

        match Rlt_le_dec 0 trkrate with

        | left _ =>

            (xt intruder +

             arcrad *

             (sind (heading intruder + trkrate * tpred) -

              sind (heading intruder)))%R

        | right _ =>

            (xt intruder +

             arcrad *

             (sind (heading intruder) - sind (heading intruder) +

              trkrate * tpred))%R

        end in

      let ytrk :=

        match Rlt_le_dec 0 trkrate with

        | left _ =>

            (yt intruder +

             arcrad *

             (cosd (heading intruder) -

              cosd (heading intruder + trkrate * tpred)))%R

        | right _ =>

            (yt intruder +

             arcrad *

             (cosd (heading intruder + trkrate * tpred) -

              cosd (heading intruder)))%R

        end in

      match mod_ iarc idtrk with

      | O =>

          let tantrk := (heading intruder + tpred * trkrate)%R in

          let int := mkState xtrk ytrk tantrk (bank intruder) in

          let eva := mkState xloc yloc (heading evader) (bank evader) in

          chktrack int eva tpred

      | _ =>

          let range := sqrt (Rsqr (xtrk - xloc) + Rsqr (ytrk - yloc)) in

          chkrange range tpred

      end

  end.



Definition ails_alert (intruder evader : State) : Prop :=

  let phi := bank intruder in

  let trkrate := trkrate phi in

  match Req_EM_var trkrate 0 with

  | left _ => chktrack intruder evader 0

  | right _ =>

      let arcrad := (Rsqr (v intruderSpeed) / (g * tand (r phi)))%R in

      let idtrk :=

        match Rle_dec 3 trkrate with

        | left _ => 1

        | right _ =>

            match Rle_dec (3 / 2) trkrate with

            | left _ => 2

            | right _ =>

                match Rle_dec (3 / 4) trkrate with

                | left _ => 4

                | right _ => 8

                end

            end

        end in

      arc_loop intruder evader arcrad trkrate idtrk 0

  end.



Lemma R_distance :

 forall intruder evader : State,

 RR intruder evader 0 = distance intruder evader.

Proof with trivial.

intros; unfold RR, distance in |- *; unfold dx, dy in |- *;

 repeat rewrite Rmult_0_l; repeat rewrite Rplus_0_r;

 rewrite (Rsqr_neg (xt intruder - xt evader));

 rewrite (Rsqr_neg (yt intruder - yt evader));

 repeat rewrite Ropp_minus_distr...

Qed.



Lemma step1 :

 forall evader intruder : State,

 alerting_distance evader intruder -> chktrack intruder evader 0.

Proof with trivial.

intros; unfold alerting_distance in H; unfold chktrack in |- *;

 case (Rle_dec (tau intruder evader 0) 0); intro...

unfold chkrange in |- *; split...

rewrite R_distance; rewrite distance_sym...

unfold AlertTime in |- *; left; prove_sup...

case (Rlt_dec AlertTime (0 + tau intruder evader 0)); intro...

rewrite Rplus_0_l in r; cut (0 <= AlertTime)%R...

intro;

 assert

  (H1 :=

   asymptotic_decrease_tau intruder evader 0 0 AlertTime

     (Rlt_le AlertTime (tau intruder evader 0) r) H0);

 repeat rewrite Rplus_0_l in H1; rewrite R_distance in H1;

 rewrite distance_sym in H1; apply Rle_trans with (distance evader intruder)...

unfold AlertTime in |- *; left; prove_sup...

assert (H0 := derivative_eq_zero_min intruder evader 0 0);

 repeat rewrite Rplus_0_l in H0; rewrite R_distance in H0;

 rewrite distance_sym in H0; apply Rle_trans with (distance evader intruder)...

Qed.



Lemma step2 :

 forall (evader intruder : State) (x : nat),

 (distance evader intruder <= AlertRange)%R ->

 trkrate (bank intruder) <> 0%R ->

 arc_loop intruder evader (Rsqr intruderSpeed / (g * tand (bank intruder)))

   (trkrate (bank intruder)) x 0.

Proof with trivial.

intros evader intruder x H n; unfold arc_loop in |- *; rewrite mod_eq_0;

 case (Rlt_le_dec 0 (trkrate (bank intruder)))...

cut (INR 0 = 0%R)...

intros; rewrite H0; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;

 repeat rewrite Rplus_0_r;

 cut

  (mkState

     (xt intruder +

      Rsqr intruderSpeed / (g * tand (bank intruder)) *

      (sind (heading intruder) - sind (heading intruder)))

     (yt intruder +

      Rsqr intruderSpeed / (g * tand (bank intruder)) *

      (cosd (heading intruder) - cosd (heading intruder))) 

     (heading intruder) (bank intruder) = intruder)...

cut (mkState (xt evader) (yt evader) (heading evader) (bank evader) = evader)...

intros; rewrite H1; rewrite H2; unfold chktrack in |- *;

 case (Rle_dec (tau intruder evader 0) 0); intro...

unfold chkrange in |- *; split...

unfold RR in |- *; unfold dx, dy in |- *; repeat rewrite Rmult_0_l;

 repeat rewrite Rplus_0_r; unfold distance in H...

unfold AlertTime in |- *; left; prove_sup...

rewrite Rplus_0_l; case (Rlt_dec AlertTime (tau intruder evader 0)); intro...

cut (0 <= AlertTime)%R...

intro;

 assert

  (H4 :=

   asymptotic_decrease_tau intruder evader 0 0 AlertTime (Rlt_le _ _ r0) H3);

 repeat rewrite Rplus_0_l in H4; apply Rle_trans with (RR intruder evader 0)...

unfold RR in |- *; unfold dx, dy in |- *; repeat rewrite Rmult_0_l;

 repeat rewrite Rplus_0_r...

unfold AlertTime in |- *; left; prove_sup...

assert (H3 := derivative_eq_zero_min intruder evader 0 0);

 repeat rewrite Rplus_0_l in H3; apply Rle_trans with (RR intruder evader 0)...

unfold RR in |- *; unfold dx, dy in |- *; repeat rewrite Rmult_0_l;

 repeat rewrite Rplus_0_r...

unfold xt, yt in |- *; case evader...

unfold xt, yt in |- *; case intruder; intros; unfold Rminus in |- *;

 repeat rewrite Rplus_opp_r; repeat rewrite Rmult_0_r;

 repeat rewrite Rplus_0_r...

cut (INR 0 = 0%R)...

intros; rewrite H0; repeat rewrite Rmult_0_l; repeat rewrite Rmult_0_r;

 repeat rewrite Rplus_0_r;

 cut

  (mkState

     (xt intruder +

      Rsqr intruderSpeed / (g * tand (bank intruder)) *

      (sind (heading intruder) - sind (heading intruder)))

     (yt intruder +

      Rsqr intruderSpeed / (g * tand (bank intruder)) *

      (cosd (heading intruder) - cosd (heading intruder))) 

     (heading intruder) (bank intruder) = intruder)... cut

  (mkState (xt evader) (yt evader) (heading evader) (bank evader) = evader)...

intros; rewrite H1; rewrite H2; unfold chktrack in |- *;

 case (Rle_dec (tau intruder evader 0) 0); intro...

unfold chkrange in |- *; split...

unfold RR in |- *; unfold dx, dy in |- *; repeat rewrite Rmult_0_l;

 repeat rewrite Rplus_0_r; unfold distance in H...

unfold AlertTime in |- *; left; prove_sup...

rewrite Rplus_0_l; case (Rlt_dec AlertTime (tau intruder evader 0)); intro...

cut (0 <= AlertTime)%R...

intro;

 assert

  (H4 :=

   asymptotic_decrease_tau intruder evader 0 0 AlertTime (Rlt_le _ _ r0) H3);

 repeat rewrite Rplus_0_l in H4; apply Rle_trans with (RR intruder evader 0)...

unfold RR in |- *; unfold dx, dy in |- *; repeat rewrite Rmult_0_l;

 repeat rewrite Rplus_0_r...

unfold AlertTime in |- *; left; prove_sup...

assert (H3 := derivative_eq_zero_min intruder evader 0 0);

 repeat rewrite Rplus_0_l in H3; apply Rle_trans with (RR intruder evader 0)...

unfold RR in |- *; unfold dx, dy in |- *; repeat rewrite Rmult_0_l;

 repeat rewrite Rplus_0_r...

unfold xt, yt in |- *; case evader...

unfold xt, yt in |- *; case intruder; intros; unfold Rminus in |- *;

 repeat rewrite Rplus_opp_r; repeat rewrite Rmult_0_r;

 repeat rewrite Rplus_0_r...

Qed.



Theorem alarm_at_alerting_distance :

 forall evader intruder : State,

 alerting_distance evader intruder -> ails_alert intruder evader.

Proof with trivial.

intros; unfold ails_alert in |- *;

 case (Req_EM_var (trkrate (bank intruder)) 0); intro...

apply (step1 _ _ H)...

unfold alerting_distance in H; case (Rle_dec 3 (trkrate (bank intruder)));

 intro...

apply step2...

case (Rle_dec (3 / 2) (trkrate (bank intruder))); intro...

apply step2...

case (Rle_dec (3 / 4) (trkrate (bank intruder))); intro; apply step2...

Qed.

