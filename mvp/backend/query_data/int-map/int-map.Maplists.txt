

Require Import BinNat.

Require Import Ndigits.

Require Import Ndec.

Require Import Map.

Require Import Fset.
(* Fset:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.

Section Dom.

  Variables A B : Type.

  Fixpoint MapDomRestrTo (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => M0 A
                        | _ => m
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => M0 A
          | M1 a' y' =>
              match MapGet A m a' with
              | None => M0 A
              | Some y => M1 A a' y
              end
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrTo m1 m'1) (MapDomRestrTo m2 m'2)
          end
    end.

  Lemma MapDomRestrTo_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrTo m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => None
          | _ => MapGet A m a0
          end).

  Fixpoint MapDomRestrBy (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => m
                        | _ => M0 A
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => m
          | M1 a' y' => MapRemove A m a'
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrBy m1 m'1) (MapDomRestrBy m2 m'2)
          end
    end.

  Lemma MapDomRestrBy_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrBy m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => MapGet A m a0
          | _ => None
          end).

  Definition in_dom (a:ad) (m:Map A) :=
    match MapGet A m a with
    | None => false
    | _ => true
    end.

  Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.

  Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.

  Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.

  Lemma in_dom_M1_2 :
   forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.

  Lemma in_dom_some :
   forall (m:Map A) (a:ad),
     in_dom a m = true -> {y : A | MapGet A m a = Some y}.

  Lemma in_dom_none :
   forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.

  Lemma in_dom_put :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_put_behind :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_remove :
   forall (m:Map A) (a0 a:ad),
     in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).

  Lemma in_dom_merge :
   forall (m m':Map A) (a:ad),
     in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').

  Lemma in_dom_delta :
   forall (m m':Map A) (a:ad),
     in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').

End Dom.

Section InDom.

  Variables A B : Type.

  Lemma in_dom_restrto :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrTo A B m m') =
     andb (in_dom A a m) (in_dom B a m').

  Lemma in_dom_restrby :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrBy A B m m') =
     andb (in_dom A a m) (negb (in_dom B a m')).

End InDom.

Definition FSet := Map unit.

Section FSetDefs.

  Variable A : Type.

  Definition in_FSet : ad -> FSet -> bool := in_dom unit.

  Fixpoint MapDom (m:Map A) : FSet :=
    match m with
    | M0 => M0 unit
    | M1 a _ => M1 unit a tt
    | M2 m m' => M2 unit (MapDom m) (MapDom m')
    end.

  Lemma MapDom_semantics_1 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y -> in_FSet a (MapDom m) = true.

  Lemma MapDom_semantics_2 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.

  Lemma MapDom_semantics_3 :
   forall (m:Map A) (a:ad),
     MapGet A m a = None -> in_FSet a (MapDom m) = false.

  Lemma MapDom_semantics_4 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = false -> MapGet A m a = None.

  Lemma MapDom_Dom :
   forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).

  Definition FSetUnion (s s':FSet) : FSet := MapMerge unit s s'.

  Lemma in_FSet_union :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').

  Definition FSetInter (s s':FSet) : FSet := MapDomRestrTo unit unit s s'.

  Lemma in_FSet_inter :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').

  Definition FSetDiff (s s':FSet) : FSet := MapDomRestrBy unit unit s s'.

  Lemma in_FSet_diff :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).

  Definition FSetDelta (s s':FSet) : FSet := MapDelta unit s s'.

  Lemma in_FSet_delta :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').

End FSetDefs.

Lemma FSet_Dom : forall s:FSet, MapDom unit s = s. *)

Require Import Mapaxioms.
(* Mapaxioms:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.

Section MapAxioms.

  Variables A B C : Type.

  Lemma eqm_sym : forall f f':ad -> option A, eqm A f f' -> eqm A f' f.

  Lemma eqm_refl : forall f:ad -> option A, eqm A f f.

  Lemma eqm_trans :
   forall f f' f'':ad -> option A, eqm A f f' -> eqm A f' f'' -> eqm A f f''.

  Definition eqmap (m m':Map A) := eqm A (MapGet A m) (MapGet A m').

  Lemma eqmap_sym : forall m m':Map A, eqmap m m' -> eqmap m' m.

  Lemma eqmap_refl : forall m:Map A, eqmap m m.

  Lemma eqmap_trans :
   forall m m' m'':Map A, eqmap m m' -> eqmap m' m'' -> eqmap m m''.

  Lemma MapPut_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut A m a y) (MapMerge A m (M1 A a y)).

  Lemma MapPut_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A), eqmap (MapPut A m a y) (MapPut A m' a y).

  Lemma MapPut_behind_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut_behind A m a y) (MapMerge A (M1 A a y) m).

  Lemma MapPut_behind_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A),
       eqmap (MapPut_behind A m a y) (MapPut_behind A m' a y).

  Lemma MapMerge_empty_m_1 : forall m:Map A, MapMerge A (M0 A) m = m.

  Lemma MapMerge_empty_m : forall m:Map A, eqmap (MapMerge A (M0 A) m) m.

  Lemma MapMerge_m_empty_1 : forall m:Map A, MapMerge A m (M0 A) = m.

  Lemma MapMerge_m_empty : forall m:Map A, eqmap (MapMerge A m (M0 A)) m.

  Lemma MapMerge_empty_l :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m (M0 A).

  Lemma MapMerge_empty_r :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m' (M0 A).

  Lemma MapMerge_assoc :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapMerge A m m') m'')
       (MapMerge A m (MapMerge A m' m'')).

  Lemma MapMerge_idempotent : forall m:Map A, eqmap (MapMerge A m m) m.

  Lemma MapMerge_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m'2).

  Lemma MapMerge_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m2).

  Lemma MapMerge_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m1 m'2).

  Lemma MapMerge_RestrTo_l :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapDomRestrTo A A m m') m'')
       (MapDomRestrTo A A (MapMerge A m m'') (MapMerge A m' m'')).

  Lemma MapRemove_as_RestrBy :
   forall (m:Map A) (a:ad) (y:B),
     eqmap (MapRemove A m a) (MapDomRestrBy A B m (M1 B a y)).

  Lemma MapRemove_ext :
   forall m m':Map A,
     eqmap m m' -> forall a:ad, eqmap (MapRemove A m a) (MapRemove A m' a).

  Lemma MapDomRestrTo_empty_m_1 :
   forall m:Map B, MapDomRestrTo A B (M0 A) m = M0 A.

  Lemma MapDomRestrTo_empty_m :
   forall m:Map B, eqmap (MapDomRestrTo A B (M0 A) m) (M0 A).

  Lemma MapDomRestrTo_m_empty_1 :
   forall m:Map A, MapDomRestrTo A B m (M0 B) = M0 A.

  Lemma MapDomRestrTo_m_empty :
   forall m:Map A, eqmap (MapDomRestrTo A B m (M0 B)) (M0 A).

  Lemma MapDomRestrTo_assoc :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrTo B C m' m'')).

  Lemma MapDomRestrTo_idempotent :
   forall m:Map A, eqmap (MapDomRestrTo A A m m) m.

  Lemma MapDomRestrTo_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrTo A B m m') (MapDomRestrTo A unit m (MapDom B m')).

  Lemma MapDomRestrBy_empty_m_1 :
   forall m:Map B, MapDomRestrBy A B (M0 A) m = M0 A.

  Lemma MapDomRestrBy_empty_m :
   forall m:Map B, eqmap (MapDomRestrBy A B (M0 A) m) (M0 A).

  Lemma MapDomRestrBy_m_empty_1 :
   forall m:Map A, MapDomRestrBy A B m (M0 B) = m.

  Lemma MapDomRestrBy_m_empty :
   forall m:Map A, eqmap (MapDomRestrBy A B m (M0 B)) m.

  Lemma MapDomRestrBy_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrBy A B m m') (MapDomRestrBy A unit m (MapDom B m')).

  Lemma MapDomRestrBy_m_m_1 :
   forall m:Map A, eqmap (MapDomRestrBy A A m m) (M0 A).

  Lemma MapDomRestrBy_By :
   forall (m:Map A) (m' m'':Map B),
     eqmap (MapDomRestrBy A B (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B m (MapMerge B m' m'')).

  Lemma MapDomRestrBy_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrBy_To :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrBy B C m' m'')).

  Lemma MapDomRestrBy_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrTo_By :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrTo A C m (MapDomRestrBy C B m'' m')).

  Lemma MapDomRestrTo_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrTo A C m m'') m').

  Lemma MapDomRestrTo_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrTo A C m m'') m').

  Lemma MapMerge_DomRestrTo :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrTo A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrTo A B m m'') (MapDomRestrTo A B m' m'')).

  Lemma MapMerge_DomRestrBy :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrBy A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrBy A B m m'') (MapDomRestrBy A B m' m'')).

  Lemma MapDelta_empty_m_1 : forall m:Map A, MapDelta A (M0 A) m = m.

  Lemma MapDelta_empty_m : forall m:Map A, eqmap (MapDelta A (M0 A) m) m.

  Lemma MapDelta_m_empty_1 : forall m:Map A, MapDelta A m (M0 A) = m.

  Lemma MapDelta_m_empty : forall m:Map A, eqmap (MapDelta A m (M0 A)) m.

  Lemma MapDelta_nilpotent : forall m:Map A, eqmap (MapDelta A m m) (M0 A).

  Lemma MapDelta_as_Merge :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapMerge A (MapDomRestrBy A A m m') (MapDomRestrBy A A m' m)).

  Lemma MapDelta_as_DomRestrBy :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

  Lemma MapDelta_as_DomRestrBy_2 :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m' m)).

  Lemma MapDelta_sym :
   forall m m':Map A, eqmap (MapDelta A m m') (MapDelta A m' m).

  Lemma MapDelta_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m'2).

  Lemma MapDelta_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m2).

  Lemma MapDelta_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m1 m'2).

  Lemma MapDom_Split_1 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')).
 
  Lemma MapDom_Split_2 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrBy A B m m') (MapDomRestrTo A B m m')).

  Lemma MapDom_Split_3 :
   forall (m:Map A) (m':Map B),
     eqmap
       (MapDomRestrTo A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m'))
       (M0 A).

End MapAxioms.

Lemma MapDomRestrTo_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m'2).

Lemma MapDomRestrTo_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m2).

Lemma MapDomRestrTo_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m1 m'2).

Lemma MapDomRestrBy_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m'2).

Lemma MapDomRestrBy_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m2).

Lemma MapDomRestrBy_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m1 m'2).

Lemma MapDomRestrBy_m_m :
 forall (A:Type) (m:Map A),
   eqmap A (MapDomRestrBy A unit m (MapDom A m)) (M0 A).

Lemma FSetDelta_assoc :
 forall s s' s'':FSet,
   eqmap unit (MapDelta _ (MapDelta _ s s') s'')
     (MapDelta _ s (MapDelta _ s' s'')).

Lemma FSet_ext :
 forall s s':FSet,
   (forall a:ad, in_FSet a s = in_FSet a s') -> eqmap unit s s'.

Lemma FSetUnion_comm :
 forall s s':FSet, eqmap unit (FSetUnion s s') (FSetUnion s' s).

Lemma FSetUnion_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetUnion s s') s'')
     (FSetUnion s (FSetUnion s' s'')).

Lemma FSetUnion_M0_s : forall s:FSet, eqmap unit (FSetUnion (M0 unit) s) s.

Lemma FSetUnion_s_M0 : forall s:FSet, eqmap unit (FSetUnion s (M0 unit)) s.

Lemma FSetUnion_idempotent : forall s:FSet, eqmap unit (FSetUnion s s) s.

Lemma FSetInter_comm :
 forall s s':FSet, eqmap unit (FSetInter s s') (FSetInter s' s).

Lemma FSetInter_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetInter s s') s'')
     (FSetInter s (FSetInter s' s'')).

Lemma FSetInter_M0_s :
 forall s:FSet, eqmap unit (FSetInter (M0 unit) s) (M0 unit).

Lemma FSetInter_s_M0 :
 forall s:FSet, eqmap unit (FSetInter s (M0 unit)) (M0 unit).

Lemma FSetInter_idempotent : forall s:FSet, eqmap unit (FSetInter s s) s.

Lemma FSetUnion_Inter_l :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetInter s s') s'')
     (FSetInter (FSetUnion s s'') (FSetUnion s' s'')).

Lemma FSetUnion_Inter_r :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion s (FSetInter s' s''))
     (FSetInter (FSetUnion s s') (FSetUnion s s'')).

Lemma FSetInter_Union_l :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetUnion s s') s'')
     (FSetUnion (FSetInter s s'') (FSetInter s' s'')).

Lemma FSetInter_Union_r :
 forall s s' s'':FSet,
   eqmap unit (FSetInter s (FSetUnion s' s''))
     (FSetUnion (FSetInter s s') (FSetInter s s'')). *)

Require Import Mapsubset.
(* Mapsubset:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.
Require Import Mapaxioms.
Require Import Mapiter.

Section MapSubsetDef.

  Variables A B : Type.

  Definition MapSubset (m:Map A) (m':Map B) :=
    forall a:ad, in_dom A a m = true -> in_dom B a m' = true.

  Definition MapSubset_1 (m:Map A) (m':Map B) :=
    match MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m with
    | None => true
    | _ => false
    end.

  Definition MapSubset_2 (m:Map A) (m':Map B) :=
    eqmap A (MapDomRestrBy A B m m') (M0 A).

  Lemma MapSubset_imp_1 :
   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.

  Lemma MapSubset_1_imp :
   forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.

  Lemma map_dom_empty_1 :
   forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.

  Lemma map_dom_empty_2 :
   forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).

  Lemma MapSubset_imp_2 :
   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.

  Lemma MapSubset_2_imp :
   forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.

End MapSubsetDef.

Section MapSubsetOrder.

  Variables A B C : Type.

  Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.

  Lemma MapSubset_antisym :
   forall (m:Map A) (m':Map B),
     MapSubset A B m m' ->
     MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').

  Lemma MapSubset_trans :
   forall (m:Map A) (m':Map B) (m'':Map C),
     MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.

End MapSubsetOrder.

Section FSubsetOrder.

  Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.

  Lemma FSubset_antisym :
   forall s s':FSet,
     MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.

  Lemma FSubset_trans :
   forall s s' s'':FSet,
     MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.

End FSubsetOrder.

Section MapSubsetExtra.

  Variables A B : Type.

  Lemma MapSubset_Dom_1 :
   forall (m:Map A) (m':Map B),
     MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').

  Lemma MapSubset_Dom_2 :
   forall (m:Map A) (m':Map B),
     MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.

  Lemma MapSubset_1_Dom :
   forall (m:Map A) (m':Map B),
     MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').

  Lemma MapSubset_Put :
   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).

  Lemma MapSubset_Put_mono :
   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),
     MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').

  Lemma MapSubset_Put_behind :
   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).

  Lemma MapSubset_Put_behind_mono :
   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),
     MapSubset A B m m' ->
     MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').

  Lemma MapSubset_Remove :
   forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.

  Lemma MapSubset_Remove_mono :
   forall (m:Map A) (m':Map B) (a:ad),
     MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).

  Lemma MapSubset_Merge_l :
   forall m m':Map A, MapSubset A A m (MapMerge A m m').

  Lemma MapSubset_Merge_r :
   forall m m':Map A, MapSubset A A m' (MapMerge A m m').

  Lemma MapSubset_Merge_mono :
   forall (m m':Map A) (m'' m''':Map B),
     MapSubset A B m m'' ->
     MapSubset A B m' m''' ->
     MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').

  Lemma MapSubset_DomRestrTo_l :
   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.

  Lemma MapSubset_DomRestrTo_r :
   forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.

  Lemma MapSubset_ext :
   forall (m0 m1:Map A) (m2 m3:Map B),
     eqmap A m0 m1 ->
     eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.

  Variables C D : Type.

  Lemma MapSubset_DomRestrTo_mono :
   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),
     MapSubset _ _ m m'' ->
     MapSubset _ _ m' m''' ->
     MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').

  Lemma MapSubset_DomRestrBy_l :
   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.

  Lemma MapSubset_DomRestrBy_mono :
   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),
     MapSubset _ _ m m'' ->
     MapSubset _ _ m''' m' ->
     MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
  
End MapSubsetExtra.

Section MapDisjointDef.

  Variables A B : Type.

  Definition MapDisjoint (m:Map A) (m':Map B) :=
    forall a:ad, in_dom A a m = true -> in_dom B a m' = true -> False.

  Definition MapDisjoint_1 (m:Map A) (m':Map B) :=
    match MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m with
    | None => true
    | _ => false
    end.

  Definition MapDisjoint_2 (m:Map A) (m':Map B) :=
    eqmap A (MapDomRestrTo A B m m') (M0 A).

  Lemma MapDisjoint_imp_1 :
   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.

  Lemma MapDisjoint_1_imp :
   forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.

  Lemma MapDisjoint_imp_2 :
   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.

  Lemma MapDisjoint_2_imp :
   forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.

  Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.

  Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).

End MapDisjointDef.

Section MapDisjointExtra.

  Variables A B : Type.

  Lemma MapDisjoint_ext :
   forall (m0 m1:Map A) (m2 m3:Map B),
     eqmap A m0 m1 ->
     eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.

  Lemma MapMerge_disjoint :
   forall m m':Map A,
     MapDisjoint A A m m' ->
     forall a:ad,
       in_dom A a (MapMerge A m m') =
       orb (andb (in_dom A a m) (negb (in_dom A a m')))
         (andb (in_dom A a m') (negb (in_dom A a m))).

  Lemma MapDisjoint_M2_l :
   forall (m0 m1:Map A) (m2 m3:Map B),
     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.

  Lemma MapDisjoint_M2_r :
   forall (m0 m1:Map A) (m2 m3:Map B),
     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.

  Lemma MapDisjoint_M2 :
   forall (m0 m1:Map A) (m2 m3:Map B),
     MapDisjoint A B m0 m2 ->
     MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).

  Lemma MapDisjoint_M1_l :
   forall (m:Map A) (a:ad) (y:B),
     MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.

  Lemma MapDisjoint_M1_r :
   forall (m:Map A) (a:ad) (y:B),
     MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.

  Lemma MapDisjoint_M1_conv_l :
   forall (m:Map A) (a:ad) (y:B),
     in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.

  Lemma MapDisjoint_M1_conv_r :
   forall (m:Map A) (a:ad) (y:B),
     in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
 
  Lemma MapDisjoint_sym :
   forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.

  Lemma MapDisjoint_empty :
   forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).

  Lemma MapDelta_disjoint :
   forall m m':Map A,
     MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').

  Variable C : Type.

  Lemma MapDomRestr_disjoint :
   forall (m:Map A) (m':Map B) (m'':Map C),
     MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').

  Lemma MapDelta_RestrTo_disjoint :
   forall m m':Map A,
     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').

  Lemma MapDelta_RestrTo_disjoint_2 :
   forall m m':Map A,
     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).

  Variable D : Type.

  Lemma MapSubset_Disjoint :
   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),
     MapSubset _ _ m m' ->
     MapSubset _ _ m'' m''' ->
     MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.

  Lemma MapSubset_Disjoint_l :
   forall (m:Map A) (m':Map B) (m'':Map C),
     MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.

  Lemma MapSubset_Disjoint_r :
   forall (m:Map A) (m'':Map C) (m''':Map D),
     MapSubset _ _ m'' m''' ->
     MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.

End MapDisjointExtra. *)

Require Import Mapcard.
(* Mapcard:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Mapaxioms.
Require Import Mapiter.
Require Import Fset.
Require Import Mapsubset.
Require Import List.
Require Import Lsort.
Require Import Peano_dec.

Section MapCard.

  Variables A B : Type.

  Lemma MapCard_M0 : MapCard A (M0 A) = 0.

  Lemma MapCard_M1 : forall (a:ad) (y:A), MapCard A (M1 A a y) = 1.

  Lemma MapCard_is_O :
   forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.

  Lemma MapCard_is_not_O :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.

  Lemma MapCard_is_one :
   forall m:Map A,
     MapCard A m = 1 -> {a : ad &  {y : A | MapGet A m a = Some y}}.

  Lemma MapCard_is_one_unique :
   forall m:Map A,
     MapCard A m = 1 ->
     forall (a a':ad) (y y':A),
       MapGet A m a = Some y ->
       MapGet A m a' = Some y' -> a = a' /\ y = y'.

  Lemma length_as_fold :
   forall (C:Type) (l:list C),
     length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.

  Lemma length_as_fold_2 :
   forall l:alist A,
     length l =
     fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.

  Lemma MapCard_as_Fold_1 :
   forall (m:Map A) (pf:ad -> ad),
     MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.

  Lemma MapCard_as_Fold :
   forall m:Map A,
     MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.
 
  Lemma MapCard_as_length :
   forall m:Map A, MapCard A m = length (alist_of_Map A m).

  Lemma MapCard_Put1_equals_2 :
   forall (p:positive) (a a':ad) (y y':A),
     MapCard A (MapPut1 A a y a' y' p) = 2.

  Lemma MapCard_Put_sum :
   forall (m m':Map A) (a:ad) (y:A) (n n':nat),
     m' = MapPut A m a y ->
     n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.

  Lemma MapCard_Put_lb :
   forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.

  Lemma MapCard_Put_ub :
   forall (m:Map A) (a:ad) (y:A),
     MapCard A (MapPut A m a y) <= S (MapCard A m).

  Lemma MapCard_Put_1 :
   forall (m:Map A) (a:ad) (y:A),
     MapCard A (MapPut A m a y) = MapCard A m ->
     {y : A | MapGet A m a = Some y}.

  Lemma MapCard_Put_2 :
   forall (m:Map A) (a:ad) (y:A),
     MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.

  Lemma MapCard_Put_1_conv :
   forall (m:Map A) (a:ad) (y y':A),
     MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.

  Lemma MapCard_Put_2_conv :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).

  Lemma MapCard_ext :
   forall m m':Map A,
     eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.

  Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).

  Lemma MapCard_Dom_Put_behind :
   forall (m:Map A) (a:ad) (y:A),
     MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).

  Lemma MapCard_Put_behind_Put :
   forall (m:Map A) (a:ad) (y:A),
     MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).

  Lemma MapCard_Put_behind_sum :
   forall (m m':Map A) (a:ad) (y:A) (n n':nat),
     m' = MapPut_behind A m a y ->
     n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.

  Lemma MapCard_makeM2 :
   forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.
 
  Lemma MapCard_Remove_sum :
   forall (m m':Map A) (a:ad) (n n':nat),
     m' = MapRemove A m a ->
     n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.

  Lemma MapCard_Remove_ub :
   forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.

  Lemma MapCard_Remove_lb :
   forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.

  Lemma MapCard_Remove_1 :
   forall (m:Map A) (a:ad),
     MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.

  Lemma MapCard_Remove_2 :
   forall (m:Map A) (a:ad),
     S (MapCard A (MapRemove A m a)) = MapCard A m ->
     {y : A | MapGet A m a = Some y}.

  Lemma MapCard_Remove_1_conv :
   forall (m:Map A) (a:ad),
     MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.

  Lemma MapCard_Remove_2_conv :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.

  Lemma MapMerge_Restr_Card :
   forall m m':Map A,
     MapCard A m + MapCard A m' =
     MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').

  Lemma MapMerge_disjoint_Card :
   forall m m':Map A,
     MapDisjoint A A m m' ->
     MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.

  Lemma MapSplit_Card :
   forall (m:Map A) (m':Map B),
     MapCard A m =
     MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').

  Lemma MapMerge_Card_ub :
   forall m m':Map A,
     MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.

  Lemma MapDomRestrTo_Card_ub_l :
   forall (m:Map A) (m':Map B),
     MapCard A (MapDomRestrTo A B m m') <= MapCard A m.

  Lemma MapDomRestrBy_Card_ub_l :
   forall (m:Map A) (m':Map B),
     MapCard A (MapDomRestrBy A B m m') <= MapCard A m.

  Lemma MapMerge_Card_disjoint :
   forall m m':Map A,
     MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' ->
     MapDisjoint A A m m'.

  Lemma MapCard_is_Sn :
   forall (m:Map A) (n:nat),
     MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.

End MapCard.

Section MapCard2.

  Variables A B : Type.

  Lemma MapSubset_card_eq_1 :
   forall (n:nat) (m:Map A) (m':Map B),
     MapSubset _ _ m m' ->
     MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.

  Lemma MapDomRestrTo_Card_ub_r :
   forall (m:Map A) (m':Map B),
     MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.

End MapCard2.

Section MapCard3.

  Variables A B : Type.

  Lemma MapMerge_Card_lb_l :
   forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.

  Lemma MapMerge_Card_lb_r :
   forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.

  Lemma MapDomRestrBy_Card_lb :
   forall (m:Map A) (m':Map B),
     MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.

  Lemma MapSubset_Card_le :
   forall (m:Map A) (m':Map B),
     MapSubset A B m m' -> MapCard A m <= MapCard B m'.

  Lemma MapSubset_card_eq :
   forall (m:Map A) (m':Map B),
     MapSubset _ _ m m' ->
     MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').

End MapCard3. *)

Require Import Mapcanon.
(* Mapcanon:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Mapaxioms.
Require Import Mapiter.
Require Import Fset.
Require Import List.
Require Import Lsort.
Require Import Mapsubset.
Require Import Mapcard.

Section MapCanon.

  Variable A : Type.

  Inductive mapcanon : Map A -> Prop :=
    | M0_canon : mapcanon (M0 A)
    | M1_canon : forall (a:ad) (y:A), mapcanon (M1 A a y)
    | M2_canon :
        forall m1 m2:Map A,
          mapcanon m1 ->
          mapcanon m2 -> 2 <= MapCard A (M2 A m1 m2) -> mapcanon (M2 A m1 m2).

  Lemma mapcanon_M2 :
   forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> 2 <= MapCard A (M2 A m1 m2).

  Lemma mapcanon_M2_1 :
   forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m1.

  Lemma mapcanon_M2_2 :
   forall m1 m2:Map A, mapcanon (M2 A m1 m2) -> mapcanon m2.

  Lemma M2_eqmap_1 :
   forall m0 m1 m2 m3:Map A,
     eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m0 m2.

  Lemma M2_eqmap_2 :
   forall m0 m1 m2 m3:Map A,
     eqmap A (M2 A m0 m1) (M2 A m2 m3) -> eqmap A m1 m3.

  Lemma mapcanon_unique :
   forall m m':Map A, mapcanon m -> mapcanon m' -> eqmap A m m' -> m = m'.

  Lemma MapPut1_canon :
   forall (p:positive) (a a':ad) (y y':A), mapcanon (MapPut1 A a y a' y' p).

  Lemma MapPut_canon :
   forall m:Map A,
     mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut A m a y).

  Lemma MapPut_behind_canon :
   forall m:Map A,
     mapcanon m -> forall (a:ad) (y:A), mapcanon (MapPut_behind A m a y).

  Lemma makeM2_canon :
   forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (makeM2 A m m').

  Fixpoint MapCanonicalize (m:Map A) : Map A :=
    match m with
    | M2 m0 m1 => makeM2 A (MapCanonicalize m0) (MapCanonicalize m1)
    | _ => m
    end.

  Lemma mapcanon_exists_1 : forall m:Map A, eqmap A m (MapCanonicalize m).

  Lemma mapcanon_exists_2 : forall m:Map A, mapcanon (MapCanonicalize m).

  Lemma mapcanon_exists :
   forall m:Map A, {m' : Map A | eqmap A m m' /\ mapcanon m'}.

  Lemma MapRemove_canon :
   forall m:Map A, mapcanon m -> forall a:ad, mapcanon (MapRemove A m a).

  Lemma MapMerge_canon :
   forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapMerge A m m').

  Lemma MapDelta_canon :
   forall m m':Map A, mapcanon m -> mapcanon m' -> mapcanon (MapDelta A m m').

  Variable B : Type.

  Lemma MapDomRestrTo_canon :
   forall m:Map A,
     mapcanon m -> forall m':Map B, mapcanon (MapDomRestrTo A B m m').

  Lemma MapDomRestrBy_canon :
   forall m:Map A,
     mapcanon m -> forall m':Map B, mapcanon (MapDomRestrBy A B m m').

  Lemma Map_of_alist_canon : forall l:alist A, mapcanon (Map_of_alist A l).

  Lemma MapSubset_c_1 :
   forall (m:Map A) (m':Map B),
     mapcanon m -> MapSubset A B m m' -> MapDomRestrBy A B m m' = M0 A.

  Lemma MapSubset_c_2 :
   forall (m:Map A) (m':Map B),
     MapDomRestrBy A B m m' = M0 A -> MapSubset A B m m'.

End MapCanon.

Section FSetCanon.

  Variable A : Type.

  Lemma MapDom_canon :
   forall m:Map A, mapcanon A m -> mapcanon unit (MapDom A m).

End FSetCanon.

Section MapFoldCanon.

  Variables A B : Type.

  Lemma MapFold_canon_1 :
   forall m0:Map B,
     mapcanon B m0 ->
     forall op:Map B -> Map B -> Map B,
       (forall m1:Map B,
          mapcanon B m1 ->
          forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) ->
       forall f:ad -> A -> Map B,
         (forall (a:ad) (y:A), mapcanon B (f a y)) ->
         forall (m:Map A) (pf:ad -> ad),
           mapcanon B (MapFold1 A (Map B) m0 op f pf m).

  Lemma MapFold_canon :
   forall m0:Map B,
     mapcanon B m0 ->
     forall op:Map B -> Map B -> Map B,
       (forall m1:Map B,
          mapcanon B m1 ->
          forall m2:Map B, mapcanon B m2 -> mapcanon B (op m1 m2)) ->
       forall f:ad -> A -> Map B,
         (forall (a:ad) (y:A), mapcanon B (f a y)) ->
         forall m:Map A, mapcanon B (MapFold A (Map B) m0 op f m).

  Lemma MapCollect_canon :
   forall f:ad -> A -> Map B,
     (forall (a:ad) (y:A), mapcanon B (f a y)) ->
     forall m:Map A, mapcanon B (MapCollect A B f m).

End MapFoldCanon. *)

Require Import Mapc.
(* Mapc:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import NArith.
Require Import Map.
Require Import Mapaxioms.
Require Import Fset.
Require Import Mapiter.
Require Import Mapsubset.
Require Import List.
Require Import Lsort.
Require Import Mapcard.
Require Import Mapcanon.

Section MapC.

  Variables A B C : Type.

  Lemma MapPut_as_Merge_c :
   forall m:Map A,
     mapcanon A m ->
     forall (a:ad) (y:A), MapPut A m a y = MapMerge A m (M1 A a y).

  Lemma MapPut_behind_as_Merge_c :
   forall m:Map A,
     mapcanon A m ->
     forall (a:ad) (y:A), MapPut_behind A m a y = MapMerge A (M1 A a y) m.

  Lemma MapMerge_empty_m_c : forall m:Map A, MapMerge A (M0 A) m = m.

  Lemma MapMerge_assoc_c :
   forall m m' m'':Map A,
     mapcanon A m ->
     mapcanon A m' ->
     mapcanon A m'' ->
     MapMerge A (MapMerge A m m') m'' = MapMerge A m (MapMerge A m' m'').

  Lemma MapMerge_idempotent_c :
   forall m:Map A, mapcanon A m -> MapMerge A m m = m.

  Lemma MapMerge_RestrTo_l_c :
   forall m m' m'':Map A,
     mapcanon A m ->
     mapcanon A m'' ->
     MapMerge A (MapDomRestrTo A A m m') m'' =
     MapDomRestrTo A A (MapMerge A m m'') (MapMerge A m' m'').

  Lemma MapRemove_as_RestrBy_c :
   forall m:Map A,
     mapcanon A m ->
     forall (a:ad) (y:B), MapRemove A m a = MapDomRestrBy A B m (M1 B a y).

  Lemma MapDomRestrTo_assoc_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrTo A C (MapDomRestrTo A B m m') m'' =
     MapDomRestrTo A B m (MapDomRestrTo B C m' m'').

  Lemma MapDomRestrTo_idempotent_c :
   forall m:Map A, mapcanon A m -> MapDomRestrTo A A m m = m.

  Lemma MapDomRestrTo_Dom_c :
   forall (m:Map A) (m':Map B),
     mapcanon A m ->
     MapDomRestrTo A B m m' = MapDomRestrTo A unit m (MapDom B m').

  Lemma MapDomRestrBy_Dom_c :
   forall (m:Map A) (m':Map B),
     mapcanon A m ->
     MapDomRestrBy A B m m' = MapDomRestrBy A unit m (MapDom B m').

  Lemma MapDomRestrBy_By_c :
   forall (m:Map A) (m' m'':Map B),
     mapcanon A m ->
     MapDomRestrBy A B (MapDomRestrBy A B m m') m'' =
     MapDomRestrBy A B m (MapMerge B m' m'').

  Lemma MapDomRestrBy_By_comm_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrBy A C (MapDomRestrBy A B m m') m'' =
     MapDomRestrBy A B (MapDomRestrBy A C m m'') m'.

  Lemma MapDomRestrBy_To_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrBy A C (MapDomRestrTo A B m m') m'' =
     MapDomRestrTo A B m (MapDomRestrBy B C m' m'').

  Lemma MapDomRestrBy_To_comm_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrBy A C (MapDomRestrTo A B m m') m'' =
     MapDomRestrTo A B (MapDomRestrBy A C m m'') m'.

  Lemma MapDomRestrTo_By_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrTo A C (MapDomRestrBy A B m m') m'' =
     MapDomRestrTo A C m (MapDomRestrBy C B m'' m').

  Lemma MapDomRestrTo_By_comm_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrTo A C (MapDomRestrBy A B m m') m'' =
     MapDomRestrBy A B (MapDomRestrTo A C m m'') m'.

  Lemma MapDomRestrTo_To_comm_c :
   forall (m:Map A) (m':Map B) (m'':Map C),
     mapcanon A m ->
     MapDomRestrTo A C (MapDomRestrTo A B m m') m'' =
     MapDomRestrTo A B (MapDomRestrTo A C m m'') m'.

  Lemma MapMerge_DomRestrTo_c :
   forall (m m':Map A) (m'':Map B),
     mapcanon A m ->
     mapcanon A m' ->
     MapDomRestrTo A B (MapMerge A m m') m'' =
     MapMerge A (MapDomRestrTo A B m m'') (MapDomRestrTo A B m' m'').

  Lemma MapMerge_DomRestrBy_c :
   forall (m m':Map A) (m'':Map B),
     mapcanon A m ->
     mapcanon A m' ->
     MapDomRestrBy A B (MapMerge A m m') m'' =
     MapMerge A (MapDomRestrBy A B m m'') (MapDomRestrBy A B m' m'').

  Lemma MapDelta_nilpotent_c :
   forall m:Map A, mapcanon A m -> MapDelta A m m = M0 A.

  Lemma MapDelta_as_Merge_c :
   forall m m':Map A,
     mapcanon A m ->
     mapcanon A m' ->
     MapDelta A m m' =
     MapMerge A (MapDomRestrBy A A m m') (MapDomRestrBy A A m' m).

  Lemma MapDelta_as_DomRestrBy_c :
   forall m m':Map A,
     mapcanon A m ->
     mapcanon A m' ->
     MapDelta A m m' =
     MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m').

  Lemma MapDelta_as_DomRestrBy_2_c :
   forall m m':Map A,
     mapcanon A m ->
     mapcanon A m' ->
     MapDelta A m m' =
     MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m' m).

  Lemma MapDelta_sym_c :
   forall m m':Map A,
     mapcanon A m -> mapcanon A m' -> MapDelta A m m' = MapDelta A m' m.

  Lemma MapDom_Split_1_c :
   forall (m:Map A) (m':Map B),
     mapcanon A m ->
     m = MapMerge A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m').

  Lemma MapDom_Split_2_c :
   forall (m:Map A) (m':Map B),
     mapcanon A m ->
     m = MapMerge A (MapDomRestrBy A B m m') (MapDomRestrTo A B m m').

  Lemma MapDom_Split_3_c :
   forall (m:Map A) (m':Map B),
     mapcanon A m ->
     MapDomRestrTo A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m') =
     M0 A.

  Lemma Map_of_alist_of_Map_c :
   forall m:Map A, mapcanon A m -> Map_of_alist A (alist_of_Map A m) = m.

  Lemma alist_of_Map_of_alist_c :
   forall l:alist A,
     alist_sorted_2 A l -> alist_of_Map A (Map_of_alist A l) = l.

  Lemma MapSubset_antisym_c :
   forall (m:Map A) (m':Map B),
     mapcanon A m ->
     mapcanon B m' ->
     MapSubset A B m m' -> MapSubset B A m' m -> MapDom A m = MapDom B m'.

  Lemma FSubset_antisym_c :
   forall s s':FSet,
     mapcanon unit s ->
     mapcanon unit s' -> MapSubset _ _ s s' -> MapSubset _ _ s' s -> s = s'.

  Lemma MapDisjoint_empty_c :
   forall m:Map A, mapcanon A m -> MapDisjoint A A m m -> m = M0 A.

  Lemma MapDelta_disjoint_c :
   forall m m':Map A,
     mapcanon A m ->
     mapcanon A m' ->
     MapDisjoint A A m m' -> MapDelta A m m' = MapMerge A m m'.

End MapC.

Lemma FSetDelta_assoc_c :
 forall s s' s'':FSet,
   mapcanon unit s ->
   mapcanon unit s' ->
   mapcanon unit s'' ->
   MapDelta _ (MapDelta _ s s') s'' = MapDelta _ s (MapDelta _ s' s'').

Lemma FSet_ext_c :
 forall s s':FSet,
   mapcanon unit s ->
   mapcanon unit s' -> (forall a:ad, in_FSet a s = in_FSet a s') -> s = s'.

Lemma FSetUnion_comm_c :
 forall s s':FSet,
   mapcanon unit s -> mapcanon unit s' -> FSetUnion s s' = FSetUnion s' s.

Lemma FSetUnion_assoc_c :
 forall s s' s'':FSet,
   mapcanon unit s ->
   mapcanon unit s' ->
   mapcanon unit s'' ->
   FSetUnion (FSetUnion s s') s'' = FSetUnion s (FSetUnion s' s'').

Lemma FSetUnion_M0_s_c : forall s:FSet, FSetUnion (M0 unit) s = s.

Lemma FSetUnion_s_M0_c : forall s:FSet, FSetUnion s (M0 unit) = s.

Lemma FSetUnion_idempotent :
 forall s:FSet, mapcanon unit s -> FSetUnion s s = s.

Lemma FSetInter_comm_c :
 forall s s':FSet,
   mapcanon unit s -> mapcanon unit s' -> FSetInter s s' = FSetInter s' s.

Lemma FSetInter_assoc_c :
 forall s s' s'':FSet,
   mapcanon unit s ->
   FSetInter (FSetInter s s') s'' = FSetInter s (FSetInter s' s'').

Lemma FSetInter_M0_s_c : forall s:FSet, FSetInter (M0 unit) s = M0 unit.

Lemma FSetInter_s_M0_c : forall s:FSet, FSetInter s (M0 unit) = M0 unit.

Lemma FSetInter_idempotent :
 forall s:FSet, mapcanon unit s -> FSetInter s s = s.

Lemma FSetUnion_Inter_l_c :
 forall s s' s'':FSet,
   mapcanon unit s ->
   mapcanon unit s'' ->
   FSetUnion (FSetInter s s') s'' =
   FSetInter (FSetUnion s s'') (FSetUnion s' s'').

Lemma FSetUnion_Inter_r :
 forall s s' s'':FSet,
   mapcanon unit s ->
   mapcanon unit s' ->
   FSetUnion s (FSetInter s' s'') =
   FSetInter (FSetUnion s s') (FSetUnion s s'').

Lemma FSetInter_Union_l_c :
 forall s s' s'':FSet,
   mapcanon unit s ->
   mapcanon unit s' ->
   FSetInter (FSetUnion s s') s'' =
   FSetUnion (FSetInter s s'') (FSetInter s' s'').

Lemma FSetInter_Union_r :
 forall s s' s'':FSet,
   mapcanon unit s ->
   mapcanon unit s' ->
   FSetInter s (FSetUnion s' s'') =
   FSetUnion (FSetInter s s') (FSetInter s s''). *)

Require Import Bool.

Require Import Sumbool.

Require Import List.

Require Import Arith.

Require Import Mapiter.
(* Mapiter:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Mapaxioms.
Require Import Fset.
Require Import List.

Section MapIter.

  Variable A : Type.

  Section MapSweepDef.

  Variable f : ad -> A -> bool.

  Definition MapSweep2 (a0:ad) (y:A) :=
    if f a0 y then Some (a0, y) else None.

  Fixpoint MapSweep1 (pf:ad -> ad) (m:Map A) {struct m} : 
   option (ad * A) :=
    match m with
    | M0 => None
    | M1 a y => MapSweep2 (pf a) y
    | M2 m m' =>
        match MapSweep1 (fun a:ad => pf (Ndouble a)) m with
        | Some r => Some r
        | None => MapSweep1 (fun a:ad => pf (Ndouble_plus_one a)) m'
        end
    end.

  Definition MapSweep (m:Map A) := MapSweep1 (fun a:ad => a) m.

  Lemma MapSweep_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> f a y = true.

  Lemma MapSweep_semantics_1 :
   forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.

  Lemma MapSweep_semantics_2_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.

  Lemma MapSweep_semantics_2_2 :
   forall (m:Map A) (pf fp:ad -> ad),
     (forall a0:ad, fp (pf a0) = a0) ->
     forall (a:ad) (y:A),
       MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.

  Lemma MapSweep_semantics_2 :
   forall (m:Map A) (a:ad) (y:A),
     MapSweep m = Some (a, y) -> MapGet A m a = Some y.

  Lemma MapSweep_semantics_3_1 :
   forall (m:Map A) (pf:ad -> ad),
     MapSweep1 pf m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.

  Lemma MapSweep_semantics_3 :
   forall m:Map A,
     MapSweep m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.

  Lemma MapSweep_semantics_4_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f (pf a) y = true ->
     {a' : ad &  {y' : A | MapSweep1 pf m = Some (a', y')}}.

  Lemma MapSweep_semantics_4 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f a y = true -> {a' : ad &  {y' : A | MapSweep m = Some (a', y')}}.

  End MapSweepDef.

  Variable B : Type.

  Fixpoint MapCollect1 (f:ad -> A -> Map B) (pf:ad -> ad) 
   (m:Map A) {struct m} : Map B :=
    match m with
    | M0 => M0 B
    | M1 a y => f (pf a) y
    | M2 m1 m2 =>
        MapMerge B (MapCollect1 f (fun a0:ad => pf (Ndouble a0)) m1)
          (MapCollect1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
    end.

  Definition MapCollect (f:ad -> A -> Map B) (m:Map A) :=
    MapCollect1 f (fun a:ad => a) m.

  Section MapFoldDef.

    Variable M : Type.
    Variable neutral : M.
    Variable op : M -> M -> M.

    Fixpoint MapFold1 (f:ad -> A -> M) (pf:ad -> ad) 
     (m:Map A) {struct m} : M :=
      match m with
      | M0 => neutral
      | M1 a y => f (pf a) y
      | M2 m1 m2 =>
          op (MapFold1 f (fun a0:ad => pf (Ndouble a0)) m1)
            (MapFold1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
      end.

    Definition MapFold (f:ad -> A -> M) (m:Map A) :=
      MapFold1 f (fun a:ad => a) m.

    Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.

    Lemma MapFold_M1 :
     forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.

    Variable State : Type.
    Variable f : State -> ad -> A -> State * M.

    Fixpoint MapFold1_state (state:State) (pf:ad -> ad) 
     (m:Map A) {struct m} : State * M :=
      match m with
      | M0 => (state, neutral)
      | M1 a y => f state (pf a) y
      | M2 m1 m2 =>
          match MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m1 with
          | (state1, x1) =>
              match
                MapFold1_state state1
                  (fun a0:ad => pf (Ndouble_plus_one a0)) m2
              with
              | (state2, x2) => (state2, op x1 x2)
              end
          end
      end.

    Definition MapFold_state (state:State) :=
      MapFold1_state state (fun a:ad => a).

    Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).

    Lemma MapFold_state_stateless_1 :
     forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad),
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.

    Lemma MapFold_state_stateless :
     forall g:ad -> A -> M,
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall (state:State) (m:Map A),
         snd (MapFold_state state m) = MapFold g m.

  End MapFoldDef.

  Lemma MapCollect_as_Fold :
   forall (f:ad -> A -> Map B) (m:Map A),
     MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.

  Definition alist := list (ad * A).
  Definition anil := nil (A:=(ad * A)).
  Definition acons := cons (A:=(ad * A)).
  Definition aapp := app (A:=(ad * A)).

  Definition alist_of_Map :=
    MapFold alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil).

  Fixpoint alist_semantics (l:alist) : ad -> option A :=
    match l with
    | nil => fun _:ad => None
    | (a, y) :: l' =>
        fun a0:ad => if Neqb a a0 then Some y else alist_semantics l' a0
    end.

  Lemma alist_semantics_app :
   forall (l l':alist) (a:ad),
     alist_semantics (aapp l l') a =
     match alist_semantics l a with
     | None => alist_semantics l' a
     | Some y => Some y
     end.

  Lemma alist_of_Map_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     alist_semantics
       (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf
          m) a = Some y -> {a' : ad | a = pf a'}.

  Definition ad_inj (pf:ad -> ad) :=
    forall a0 a1:ad, pf a0 = pf a1 -> a0 = a1.

  Lemma ad_comp_double_inj :
   forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).

  Lemma ad_comp_double_plus_un_inj :
   forall pf:ad -> ad,
     ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).

  Lemma alist_of_Map_semantics_1 :
   forall (m:Map A) (pf:ad -> ad),
     ad_inj pf ->
     forall a:ad,
       MapGet A m a =
       alist_semantics
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            pf m) (pf a).

  Lemma alist_of_Map_semantics :
   forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).

  Fixpoint Map_of_alist (l:alist) : Map A :=
    match l with
    | nil => M0 A
    | (a, y) :: l' => MapPut A (Map_of_alist l') a y
    end.

  Lemma Map_of_alist_semantics :
   forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).

  Lemma Map_of_alist_of_Map :
   forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.

  Lemma alist_of_Map_of_alist :
   forall l:alist,
     eqm A (alist_semantics (alist_of_Map (Map_of_alist l)))
       (alist_semantics l).

  Lemma fold_right_aapp :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     forall (f:ad -> A -> M) (l l':alist),
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (aapp l l') =
       op
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l)
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l').

  Lemma MapFold_as_fold_1 :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad),
       MapFold1 M neutral op f pf m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral
         (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf
            m).

  Lemma MapFold_as_fold :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A),
       MapFold M neutral op f m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (alist_of_Map m).

  Lemma alist_MapMerge_semantics :
   forall m m':Map A,
     eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).

  Lemma alist_MapMerge_semantics_disjoint :
   forall m m':Map A,
     eqmap A (MapDomRestrTo A A m m') (M0 A) ->
     eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).

  Lemma alist_semantics_disjoint_comm :
   forall l l':alist,
     eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) ->
     eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).

End MapIter. *)

Require Import Mapfold.
(* Mapfold:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.
Require Import Mapaxioms.
Require Import Mapiter.
Require Import Lsort.
Require Import Mapsubset.
Require Import List.

Section MapFoldResults.

  Variable A : Type.

  Variable M : Type.
  Variable neutral : M.
  Variable op : M -> M -> M.

  Variable nleft : forall a:M, op neutral a = a.
  Variable nright : forall a:M, op a neutral = a.
  Variable assoc : forall a b c:M, op (op a b) c = op a (op b c).

  Lemma MapFold_ext :
   forall (f:ad -> A -> M) (m m':Map A),
     eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.

  Lemma MapFold_ext_f_1 :
   forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad),
     (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) ->
     MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.

  Lemma MapFold_ext_f :
   forall (f g:ad -> A -> M) (m:Map A),
     (forall (a:ad) (y:A), MapGet _ m a = Some y -> f a y = g a y) ->
     MapFold _ _ neutral op f m = MapFold _ _ neutral op g m.

  Lemma MapFold1_as_Fold_1 :
   forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad),
     (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) ->
     MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.

  Lemma MapFold1_as_Fold :
   forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A),
     MapFold1 _ _ neutral op f pf m =
     MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.

  Lemma MapFold1_ext :
   forall (f:ad -> A -> M) (m m':Map A),
     eqmap A m m' ->
     forall pf:ad -> ad,
       MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.

  Variable comm : forall a b:M, op a b = op b a.

  Lemma MapFold_Put_disjoint_1 :
   forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) 
     (a1 a2:ad) (y1 y2:A),
     Nxor a1 a2 = Npos p ->
     MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) =
     op (f (pf a1) y1) (f (pf a2) y2).

  Lemma MapFold_Put_disjoint_2 :
   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad),
     MapGet A m a = None ->
     MapFold1 A M neutral op f pf (MapPut A m a y) =
     op (f (pf a) y) (MapFold1 A M neutral op f pf m).

  Lemma MapFold_Put_disjoint :
   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A),
     MapGet A m a = None ->
     MapFold A M neutral op f (MapPut A m a y) =
     op (f a y) (MapFold A M neutral op f m).

  Lemma MapFold_Put_behind_disjoint_2 :
   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad),
     MapGet A m a = None ->
     MapFold1 A M neutral op f pf (MapPut_behind A m a y) =
     op (f (pf a) y) (MapFold1 A M neutral op f pf m).

  Lemma MapFold_Put_behind_disjoint :
   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A),
     MapGet A m a = None ->
     MapFold A M neutral op f (MapPut_behind A m a y) =
     op (f a y) (MapFold A M neutral op f m).

  Lemma MapFold_Merge_disjoint_1 :
   forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad),
     MapDisjoint A A m1 m2 ->
     MapFold1 A M neutral op f pf (MapMerge A m1 m2) =
     op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).

  Lemma MapFold_Merge_disjoint :
   forall (f:ad -> A -> M) (m1 m2:Map A),
     MapDisjoint A A m1 m2 ->
     MapFold A M neutral op f (MapMerge A m1 m2) =
     op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2).
 
End MapFoldResults.

Section MapFoldDistr.

  Variable A : Type.

  Variable M : Type.
  Variable neutral : M.
  Variable op : M -> M -> M.

  Variable M' : Type.
  Variable neutral' : M'.
  Variable op' : M' -> M' -> M'.

  Variable N : Type.

  Variable times : M -> N -> M'.

  Variable absorb : forall c:N, times neutral c = neutral'.
  Variable
    distr :
      forall (a b:M) (c:N), times (op a b) c = op' (times a c) (times b c).

  Lemma MapFold_distr_r_1 :
   forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad),
     times (MapFold1 A M neutral op f pf m) c =
     MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.

  Lemma MapFold_distr_r :
   forall (f:ad -> A -> M) (m:Map A) (c:N),
     times (MapFold A M neutral op f m) c =
     MapFold A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) m.

End MapFoldDistr.

Section MapFoldDistrL.

  Variable A : Type.

  Variable M : Type.
  Variable neutral : M.
  Variable op : M -> M -> M.

  Variable M' : Type.
  Variable neutral' : M'.
  Variable op' : M' -> M' -> M'.

  Variable N : Type.

  Variable times : N -> M -> M'.

  Variable absorb : forall c:N, times c neutral = neutral'.
  Variable
    distr :
      forall (a b:M) (c:N), times c (op a b) = op' (times c a) (times c b).

  Lemma MapFold_distr_l :
   forall (f:ad -> A -> M) (m:Map A) (c:N),
     times c (MapFold A M neutral op f m) =
     MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.

End MapFoldDistrL.

Section MapFoldExists.

  Variable A : Type.

  Lemma MapFold_orb_1 :
   forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad),
     MapFold1 A bool false orb f pf m =
     match MapSweep1 A f pf m with
     | Some _ => true
     | _ => false
     end.

  Lemma MapFold_orb :
   forall (f:ad -> A -> bool) (m:Map A),
     MapFold A bool false orb f m =
     match MapSweep A f m with
     | Some _ => true
     | _ => false
     end.

End MapFoldExists.

Section DMergeDef.

  Variable A : Type.

  Definition DMerge :=
    MapFold (Map A) (Map A) (M0 A) (MapMerge A) (fun (_:ad) (m:Map A) => m).

  Lemma in_dom_DMerge_1 :
   forall (m:Map (Map A)) (a:ad),
     in_dom A a (DMerge m) =
     match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with
     | Some _ => true
     | _ => false
     end.

  Lemma in_dom_DMerge_2 :
   forall (m:Map (Map A)) (a:ad),
     in_dom A a (DMerge m) = true ->
     {b : ad & 
     {m0 : Map A | MapGet _ m b = Some m0 /\ in_dom A a m0 = true}}.

  Lemma in_dom_DMerge_3 :
   forall (m:Map (Map A)) (a b:ad) (m0:Map A),
     MapGet _ m a = Some m0 ->
     in_dom A b m0 = true -> in_dom A b (DMerge m) = true.

End DMergeDef. *)



Section MapLists.



  Fixpoint ad_in_list (a:ad) (l:list ad) {struct l} : bool :=

    match l with

    | nil => false

    | a' :: l' => orb (Neqb a a') (ad_in_list a l')

    end.



  Fixpoint ad_list_stutters (l:list ad) : bool :=

    match l with

    | nil => false

    | a :: l' => orb (ad_in_list a l') (ad_list_stutters l')

    end.



  Lemma ad_in_list_forms_circuit :

   forall (x:ad) (l:list ad),

     ad_in_list x l = true ->

     {l1 : list ad &  {l2 : list ad | l = l1 ++ x :: l2}}.

  Proof.

    simple induction l. intro. discriminate H.

    intros. elim (sumbool_of_bool (Neqb x a)). intro H1. simpl in H0. split with (nil (A:=ad)).

    split with l0. rewrite (Neqb_complete _ _ H1). reflexivity.

    intro H2. simpl in H0. rewrite H2 in H0. simpl in H0. elim (H H0). intros l'1 H3.

    split with (a :: l'1). elim H3. intros l2 H4. split with l2. rewrite H4. reflexivity.

  Qed.



  Lemma ad_list_stutters_has_circuit :

   forall l:list ad,

     ad_list_stutters l = true ->

     {x : ad & 

     {l0 : list ad & 

     {l1 : list ad &  {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.

  Proof.

    simple induction l. intro. discriminate H.

    intros. simpl in H0. elim (orb_true_elim _ _ H0). intro H1. split with a.

    split with (nil (A:=ad)). simpl in |- *. elim (ad_in_list_forms_circuit a l0 H1). intros l1 H2.

    split with l1. elim H2. intros l2 H3. split with l2. rewrite H3. reflexivity.

    intro H1. elim (H H1). intros x H2. split with x. elim H2. intros l1 H3.

    split with (a :: l1). elim H3. intros l2 H4. split with l2. elim H4. intros l3 H5.

    split with l3. rewrite H5. reflexivity.

  Qed.



  Fixpoint Elems (l:list ad) : FSet :=

    match l with

    | nil => M0 unit

    | a :: l' => MapPut _ (Elems l') a tt

    end.



  Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).

  Proof.

    simple induction l. exact (M0_canon unit).

    intros. simpl in |- *. apply MapPut_canon. assumption.

  Qed.



  Lemma Elems_app :

   forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite (MapPut_as_Merge_c unit (Elems l0)).

    rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).

    change

      (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) =

       FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) 

     in |- *.

    rewrite FSetUnion_comm_c. rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).

    rewrite FSetUnion_assoc_c. rewrite (H l'). reflexivity.

    apply M1_canon.

    apply Elems_canon.

    apply Elems_canon.

    apply Elems_canon.

    apply M1_canon.

    apply Elems_canon.

    apply M1_canon.

    apply Elems_canon.

    apply Elems_canon.

  Qed.



  Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite Elems_app. simpl in |- *. rewrite (MapPut_as_Merge_c unit (Elems l0)).

    rewrite H. reflexivity.

    apply Elems_canon.

  Qed.



  Lemma ad_in_elems_in_list :

   forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.

  Proof.

    simple induction l. trivial.

    simpl in |- *. unfold in_FSet in |- *. intros. rewrite (in_dom_put _ (Elems l0) a tt a0).

    rewrite (H a0). reflexivity.

  Qed.



  Lemma ad_list_not_stutters_card :

   forall l:list ad,

     ad_list_stutters l = false -> length l = MapCard _ (Elems l).

  Proof.

    simple induction l. trivial.

    simpl in |- *. intros. rewrite MapCard_Put_2_conv. rewrite H. reflexivity.

    elim (orb_false_elim _ _ H0). trivial.

    elim (sumbool_of_bool (in_FSet a (Elems l0))). rewrite ad_in_elems_in_list.

    intro H1. rewrite H1 in H0. discriminate H0.

    exact (in_dom_none unit (Elems l0) a).

  Qed.



  Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. apply le_trans with (m := S (MapCard _ (Elems l0))). apply MapCard_Put_ub.

    apply le_n_S. assumption.

  Qed.



  Lemma ad_list_stutters_card :

   forall l:list ad,

     ad_list_stutters l = true -> MapCard _ (Elems l) < length l.

  Proof.

    simple induction l. intro. discriminate H.

    intros. simpl in |- *. simpl in H0. elim (orb_true_elim _ _ H0). intro H1.

    rewrite <- (ad_in_elems_in_list l0 a) in H1. elim (in_dom_some _ _ _ H1). intros y H2.

    rewrite (MapCard_Put_1_conv _ _ _ _ tt H2). apply le_lt_trans with (m := length l0).

    apply ad_list_card.

    apply lt_n_Sn.

    intro H1. apply le_lt_trans with (m := S (MapCard _ (Elems l0))). apply MapCard_Put_ub.

    apply lt_n_S. apply H. assumption.

  Qed.



  Lemma ad_list_not_stutters_card_conv :

   forall l:list ad,

     length l = MapCard _ (Elems l) -> ad_list_stutters l = false.

  Proof.

    intros. elim (sumbool_of_bool (ad_list_stutters l)). intro H0.

    cut (MapCard _ (Elems l) < length l). intro. rewrite H in H1. elim (lt_irrefl _ H1).

    exact (ad_list_stutters_card _ H0).

    trivial.

  Qed.



  Lemma ad_list_stutters_card_conv :

   forall l:list ad,

     MapCard _ (Elems l) < length l -> ad_list_stutters l = true.

  Proof.

    intros. elim (sumbool_of_bool (ad_list_stutters l)). trivial.

    intro H0. rewrite (ad_list_not_stutters_card _ H0) in H. elim (lt_irrefl _ H).

  Qed.



  Lemma ad_in_list_l :

   forall (l l':list ad) (a:ad),

     ad_in_list a l = true -> ad_in_list a (l ++ l') = true.

  Proof.

    simple induction l. intros. discriminate H.

    intros. simpl in |- *. simpl in H0. elim (orb_true_elim _ _ H0). intro H1. rewrite H1. reflexivity.

    intro H1. rewrite (H l' a0 H1). apply orb_b_true.

  Qed.



  Lemma ad_list_stutters_app_l :

   forall l l':list ad,

     ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.

  Proof.

    simple induction l. intros. discriminate H.

    intros. simpl in |- *. simpl in H0. elim (orb_true_elim _ _ H0). intro H1.

    rewrite (ad_in_list_l l0 l' a H1). reflexivity.

    intro H1. rewrite (H l' H1). apply orb_b_true.

  Qed.



  Lemma ad_in_list_r :

   forall (l l':list ad) (a:ad),

     ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite (H l' a0 H0). apply orb_b_true. 

  Qed.



  Lemma ad_list_stutters_app_r :

   forall l l':list ad,

     ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite (H l' H0). apply orb_b_true.

  Qed.



  Lemma ad_list_stutters_app_conv_l :

   forall l l':list ad,

     ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.

  Proof.

    intros. elim (sumbool_of_bool (ad_list_stutters l)). intro H0.

    rewrite (ad_list_stutters_app_l l l' H0) in H. discriminate H.

    trivial.

  Qed.



  Lemma ad_list_stutters_app_conv_r :

   forall l l':list ad,

     ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.

  Proof.

    intros. elim (sumbool_of_bool (ad_list_stutters l')). intro H0.

    rewrite (ad_list_stutters_app_r l l' H0) in H. discriminate H.

    trivial.

  Qed.



  Lemma ad_in_list_app_1 :

   forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.

  Proof.

    simple induction l. simpl in |- *. intros. rewrite (Neqb_correct x). reflexivity.

    intros. simpl in |- *. rewrite (H l' x). apply orb_b_true.

  Qed.



  Lemma ad_in_list_app :

   forall (l l':list ad) (x:ad),

     ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite <- orb_assoc. rewrite (H l' x). reflexivity.

  Qed.



  Lemma ad_in_list_rev :

   forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite ad_in_list_app. rewrite (H x). simpl in |- *. rewrite orb_b_false.

    apply orb_comm.

  Qed.



  Lemma ad_list_has_circuit_stutters :

   forall (l0 l1 l2:list ad) (x:ad),

     ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.

  Proof.

    simple induction l0. simpl in |- *. intros. rewrite (ad_in_list_app_1 l1 l2 x). reflexivity.

    intros. simpl in |- *. rewrite (H l1 l2 x). apply orb_b_true.

  Qed.



  Lemma ad_list_stutters_prev_l :

   forall (l l':list ad) (x:ad),

     ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.

  Proof.

    intros. elim (ad_in_list_forms_circuit _ _ H). intros l0 H0. elim H0. intros l1 H1.

    rewrite H1. rewrite app_ass. simpl in |- *. apply ad_list_has_circuit_stutters.

  Qed.



  Lemma ad_list_stutters_prev_conv_l :

   forall (l l':list ad) (x:ad),

     ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.

  Proof.

    intros. elim (sumbool_of_bool (ad_in_list x l)). intro H0.

    rewrite (ad_list_stutters_prev_l l l' x H0) in H. discriminate H.

    trivial.

  Qed.



  Lemma ad_list_stutters_prev_r :

   forall (l l':list ad) (x:ad),

     ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.

  Proof.

    intros. elim (ad_in_list_forms_circuit _ _ H). intros l0 H0. elim H0. intros l1 H1.

    rewrite H1. apply ad_list_has_circuit_stutters.

  Qed.



  Lemma ad_list_stutters_prev_conv_r :

   forall (l l':list ad) (x:ad),

     ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.

  Proof.

    intros. elim (sumbool_of_bool (ad_in_list x l')). intro H0.

    rewrite (ad_list_stutters_prev_r l l' x H0) in H. discriminate H.

    trivial.

  Qed.



  Lemma ad_list_Elems :

   forall l l':list ad,

     MapCard _ (Elems l) = MapCard _ (Elems l') ->

     length l = length l' -> ad_list_stutters l = ad_list_stutters l'.

  Proof.

    intros. elim (sumbool_of_bool (ad_list_stutters l)). intro H1. rewrite H1. apply sym_eq.

    apply ad_list_stutters_card_conv. rewrite <- H. rewrite <- H0. apply ad_list_stutters_card.

    assumption.

    intro H1. rewrite H1. apply sym_eq. apply ad_list_not_stutters_card_conv. rewrite <- H.

    rewrite <- H0. apply ad_list_not_stutters_card. assumption.

  Qed.



  Lemma ad_list_app_length :

   forall l l':list ad, length (l ++ l') = length l + length l'.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite (H l'). reflexivity.

  Qed.



  Lemma ad_list_stutters_permute :

   forall l l':list ad,

     ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).

  Proof.

    intros. apply ad_list_Elems. rewrite Elems_app. rewrite Elems_app.

    rewrite (FSetUnion_comm_c _ _ (Elems_canon l) (Elems_canon l')). reflexivity.

    rewrite ad_list_app_length. rewrite ad_list_app_length. apply plus_comm.

  Qed.



  Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite ad_list_app_length. simpl in |- *. rewrite H. rewrite <- plus_Snm_nSm.

    rewrite <- plus_n_O. reflexivity.

  Qed.



  Lemma ad_list_stutters_rev :

   forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.

  Proof.

    intros. apply ad_list_Elems. rewrite Elems_rev. reflexivity.

    apply ad_list_rev_length.

  Qed.



  Lemma ad_list_app_rev :

   forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.

  Proof.

    simple induction l. trivial.

    intros. simpl in |- *. rewrite (app_ass (rev l0) (a :: nil) (x :: l')). simpl in |- *.

    rewrite (H (x :: l') a). simpl in |- *.

    rewrite (app_ass (rev l0) (a :: nil) (x :: nil)). simpl in |- *.

    rewrite app_ass. simpl in |- *. rewrite app_ass. reflexivity.

  Qed.



  Section ListOfDomDef.



  Variable A : Type.



  Definition ad_list_of_dom :=

    MapFold A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil).



  Lemma ad_in_list_of_dom_in_dom :

   forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.

  Proof.

    unfold ad_list_of_dom in |- *. intros.

    rewrite

     (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad

        (fun (a:ad) (l:list ad) => ad_in_list a l) (

        fun c:ad => refl_equal _) ad_in_list_app

        (fun (a0:ad) (_:A) => a0 :: nil) m a).

    simpl in |- *. rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).

    elim

     (option_sum _

        (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)). intro H. elim H.

    intro r. elim r. intros a0 y H0. rewrite H0. unfold in_dom in |- *.

    elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)). intro H1.

    rewrite (Neqb_complete _ _ H1). rewrite (MapSweep_semantics_2 A _ _ _ _ H0). reflexivity.

    intro H1. discriminate H1.

    intro H. rewrite H. elim (sumbool_of_bool (in_dom A a m)). intro H0.

    elim (in_dom_some A m a H0). intros y H1.

    elim (orb_false_elim _ _ (MapSweep_semantics_3 _ _ _ H _ _ H1)). intro H2.

    rewrite (Neqb_correct a) in H2. discriminate H2.

    exact (sym_eq (y:=_)).

  Qed.



  Lemma Elems_of_list_of_dom :

   forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).

  Proof.

    unfold eqmap, eqm in |- *. intros. elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).

    intro H. elim (in_dom_some _ _ _ H). intro t. elim t. intro H0.

    rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.

    rewrite (ad_in_list_of_dom_in_dom m a) in H. rewrite (MapDom_Dom A m a) in H.

    elim (in_dom_some _ _ _ H). intro t'. elim t'. intro H1. rewrite H1. assumption.

    intro H. rewrite (in_dom_none _ _ _ H).

    rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.

    rewrite (ad_in_list_of_dom_in_dom m a) in H. rewrite (MapDom_Dom A m a) in H.

    rewrite (in_dom_none _ _ _ H). reflexivity.

  Qed.



  Lemma Elems_of_list_of_dom_c :

   forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.

  Proof.

    intros. apply (mapcanon_unique unit). apply Elems_canon.

    apply MapDom_canon. assumption.

    apply Elems_of_list_of_dom.

  Qed.



  Lemma ad_list_of_dom_card_1 :

   forall (m:Map A) (pf:ad -> ad),

     length

       (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil)

          pf m) = MapCard A m.

  Proof.

    simple induction m; try trivial. simpl in |- *. intros. rewrite ad_list_app_length.

    rewrite (H (fun a0:ad => pf (Ndouble a0))). rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).

    reflexivity.

  Qed.



  Lemma ad_list_of_dom_card :

   forall m:Map A, length (ad_list_of_dom m) = MapCard A m.

  Proof.

    exact (fun m:Map A => ad_list_of_dom_card_1 m (fun a:ad => a)).

  Qed.



  Lemma ad_list_of_dom_not_stutters :

   forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.

  Proof.

    intro. apply ad_list_not_stutters_card_conv. rewrite ad_list_of_dom_card. apply sym_eq.

    rewrite (MapCard_Dom A m). apply MapCard_ext. exact (Elems_of_list_of_dom m).

  Qed.



  End ListOfDomDef.



  Lemma ad_list_of_dom_Dom_1 :

   forall (A:Type) (m:Map A) (pf:ad -> ad),

     MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf

       m =

     MapFold1 unit (list ad) nil (app (A:=ad))

       (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).

  Proof.

    simple induction m; try trivial. simpl in |- *. intros. rewrite (H (fun a0:ad => pf (Ndouble a0))).

    rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))). reflexivity.

  Qed.



  Lemma ad_list_of_dom_Dom :

   forall (A:Type) (m:Map A),

     ad_list_of_dom A m = ad_list_of_dom unit (MapDom A m).

  Proof.

    intros. exact (ad_list_of_dom_Dom_1 A m (fun a0:ad => a0)).

  Qed.



End MapLists.
