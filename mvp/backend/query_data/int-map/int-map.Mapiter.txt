
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
(* Map:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.

Global Set Asymmetric Patterns.

Definition ad := N. 

Section MapDefs.

  Variable A : Type.  

  Inductive Map :=
    | M0 : Map
    | M1 : ad -> A -> Map
    | M2 : Map -> Map -> Map.

  Lemma option_sum : forall o:option A, {y : A | o = Some y} + {o = None}.

  Fixpoint MapGet (m:Map) : ad -> option A :=
    match m with
    | M0 => fun a:ad => None
    | M1 x y => fun a:ad => if Neqb x a then Some y else None
    | M2 m1 m2 =>
        fun a:ad =>
          match a with
          | N0 => MapGet m1 N0
          | Npos xH => MapGet m2 N0
          | Npos (xO p) => MapGet m1 (Npos p)
          | Npos (xI p) => MapGet m2 (Npos p)
          end
    end.

  Definition newMap := M0.

  Definition MapSingleton := M1.

  Definition eqm (g g':ad -> option A) := forall a:ad, g a = g' a.

  Lemma newMap_semantics : eqm (MapGet newMap) (fun a:ad => None).

  Lemma MapSingleton_semantics :
   forall (a:ad) (y:A),
     eqm (MapGet (MapSingleton a y))
       (fun a':ad => if Neqb a a' then Some y else None).

  Lemma M1_semantics_1 : forall (a:ad) (y:A), MapGet (M1 a y) a = Some y.

  Lemma M1_semantics_2 :
   forall (a a':ad) (y:A), Neqb a a' = false -> MapGet (M1 a y) a' = None.

  Lemma Map2_semantics_1 :
   forall m m':Map,
     eqm (MapGet m) (fun a:ad => MapGet (M2 m m') (Ndouble a)).

  Lemma Map2_semantics_1_eq :
   forall (m m':Map) (f:ad -> option A),
     eqm (MapGet (M2 m m')) f -> eqm (MapGet m) (fun a:ad => f (Ndouble a)).

  Lemma Map2_semantics_2 :
   forall m m':Map,
     eqm (MapGet m') (fun a:ad => MapGet (M2 m m') (Ndouble_plus_one a)).

  Lemma Map2_semantics_2_eq :
   forall (m m':Map) (f:ad -> option A),
     eqm (MapGet (M2 m m')) f ->
     eqm (MapGet m') (fun a:ad => f (Ndouble_plus_one a)).

  Lemma MapGet_M2_bit_0_0 :
   forall a:ad,
     Nbit0 a = false ->
     forall m m':Map, MapGet (M2 m m') a = MapGet m (Ndiv2 a).

  Lemma MapGet_M2_bit_0_1 :
   forall a:ad,
     Nbit0 a = true ->
     forall m m':Map, MapGet (M2 m m') a = MapGet m' (Ndiv2 a).

  Lemma MapGet_M2_bit_0_if :
   forall (m m':Map) (a:ad),
     MapGet (M2 m m') a =
     (if Nbit0 a then MapGet m' (Ndiv2 a) else MapGet m (Ndiv2 a)).

  Lemma MapGet_M2_bit_0 :
   forall (m m' m'':Map) (a:ad),
     (if Nbit0 a then MapGet (M2 m' m) a else MapGet (M2 m m'') a) =
     MapGet m (Ndiv2 a).

  Lemma Map2_semantics_3 :
   forall m m':Map,
     eqm (MapGet (M2 m m'))
       (fun a:ad =>
          match Nbit0 a with
          | false => MapGet m (Ndiv2 a)
          | true => MapGet m' (Ndiv2 a)
          end).

  Lemma Map2_semantics_3_eq :
   forall (m m':Map) (f f':ad -> option A),
     eqm (MapGet m) f ->
     eqm (MapGet m') f' ->
     eqm (MapGet (M2 m m'))
       (fun a:ad =>
          match Nbit0 a with
          | false => f (Ndiv2 a)
          | true => f' (Ndiv2 a)
          end).

  Fixpoint MapPut1 (a:ad) (y:A) (a':ad) (y':A) (p:positive) {struct p} :
   Map :=
    match p with
    | xO p' =>
        let m := MapPut1 (Ndiv2 a) y (Ndiv2 a') y' p' in
        match Nbit0 a with
        | false => M2 m M0
        | true => M2 M0 m
        end
    | _ =>
        match Nbit0 a with
        | false => M2 (M1 (Ndiv2 a) y) (M1 (Ndiv2 a') y')
        | true => M2 (M1 (Ndiv2 a') y') (M1 (Ndiv2 a) y)
        end
    end.

  Lemma MapGet_if_commute :
   forall (b:bool) (m m':Map) (a:ad),
     MapGet (if b then m else m') a = (if b then MapGet m a else MapGet m' a).

  Lemma MapGet_if_same :
   forall (m:Map) (b:bool) (a:ad), MapGet (if b then m else m) a = MapGet m a.

  Lemma MapGet_M2_bit_0_2 :
   forall (m m' m'':Map) (a:ad),
     MapGet (if Nbit0 a then M2 m m' else M2 m' m'') a =
     MapGet m' (Ndiv2 a).

  Lemma MapPut1_semantics_1 :
   forall (p:positive) (a a':ad) (y y':A),
     Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a = Some y.

  Lemma MapPut1_semantics_2 :
   forall (p:positive) (a a':ad) (y y':A),
     Nxor a a' = Npos p -> MapGet (MapPut1 a y a' y' p) a' = Some y'.

  Lemma MapGet_M2_both_None :
   forall (m m':Map) (a:ad),
     MapGet m (Ndiv2 a) = None ->
     MapGet m' (Ndiv2 a) = None -> MapGet (M2 m m') a = None.
 
  Lemma MapPut1_semantics_3 :
   forall (p:positive) (a a' a0:ad) (y y':A),
     Nxor a a' = Npos p ->
     Neqb a a0 = false ->
     Neqb a' a0 = false -> MapGet (MapPut1 a y a' y' p) a0 = None.

  Lemma MapPut1_semantics :
   forall (p:positive) (a a':ad) (y y':A),
     Nxor a a' = Npos p ->
     eqm (MapGet (MapPut1 a y a' y' p))
       (fun a0:ad =>
          if Neqb a a0
          then Some y
          else if Neqb a' a0 then Some y' else None).

  Lemma MapPut1_semantics' :
   forall (p:positive) (a a':ad) (y y':A),
     Nxor a a' = Npos p ->
     eqm (MapGet (MapPut1 a y a' y' p))
       (fun a0:ad =>
          if Neqb a' a0
          then Some y'
          else if Neqb a a0 then Some y else None).

  Fixpoint MapPut (m:Map) : ad -> A -> Map :=
    match m with
    | M0 => M1
    | M1 a y =>
        fun (a':ad) (y':A) =>
          match Nxor a a' with
          | N0 => M1 a' y'
          | Npos p => MapPut1 a y a' y' p
          end
    | M2 m1 m2 =>
        fun (a:ad) (y:A) =>
          match a with
          | N0 => M2 (MapPut m1 N0 y) m2
          | Npos xH => M2 m1 (MapPut m2 N0 y)
          | Npos (xO p) => M2 (MapPut m1 (Npos p) y) m2
          | Npos (xI p) => M2 m1 (MapPut m2 (Npos p) y)
          end
    end.

  Lemma MapPut_semantics_1 :
   forall (a:ad) (y:A) (a0:ad),
     MapGet (MapPut M0 a y) a0 = MapGet (M1 a y) a0.

  Lemma MapPut_semantics_2_1 :
   forall (a:ad) (y y':A) (a0:ad),
     MapGet (MapPut (M1 a y) a y') a0 =
     (if Neqb a a0 then Some y' else None).

  Lemma MapPut_semantics_2_2 :
   forall (a a':ad) (y y':A) (a0 a'':ad),
     Nxor a a' = a'' ->
     MapGet (MapPut (M1 a y) a' y') a0 =
     (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).

  Lemma MapPut_semantics_2 :
   forall (a a':ad) (y y':A) (a0:ad),
     MapGet (MapPut (M1 a y) a' y') a0 =
     (if Neqb a' a0 then Some y' else if Neqb a a0 then Some y else None).

  Lemma MapPut_semantics_3_1 :
   forall (m m':Map) (a:ad) (y:A),
     MapPut (M2 m m') a y =
     (if Nbit0 a
      then M2 m (MapPut m' (Ndiv2 a) y)
      else M2 (MapPut m (Ndiv2 a) y) m').

  Lemma MapPut_semantics :
   forall (m:Map) (a:ad) (y:A),
     eqm (MapGet (MapPut m a y))
       (fun a':ad => if Neqb a a' then Some y else MapGet m a').

  Fixpoint MapPut_behind (m:Map) : ad -> A -> Map :=
    match m with
    | M0 => M1
    | M1 a y =>
        fun (a':ad) (y':A) =>
          match Nxor a a' with
          | N0 => m
          | Npos p => MapPut1 a y a' y' p
          end
    | M2 m1 m2 =>
        fun (a:ad) (y:A) =>
          match a with
          | N0 => M2 (MapPut_behind m1 N0 y) m2
          | Npos xH => M2 m1 (MapPut_behind m2 N0 y)
          | Npos (xO p) => M2 (MapPut_behind m1 (Npos p) y) m2
          | Npos (xI p) => M2 m1 (MapPut_behind m2 (Npos p) y)
          end
    end.

  Lemma MapPut_behind_semantics_3_1 :
   forall (m m':Map) (a:ad) (y:A),
     MapPut_behind (M2 m m') a y =
     (if Nbit0 a
      then M2 m (MapPut_behind m' (Ndiv2 a) y)
      else M2 (MapPut_behind m (Ndiv2 a) y) m').

  Lemma MapPut_behind_as_before_1 :
   forall a a' a0:ad,
     Neqb a' a0 = false ->
     forall y y':A,
       MapGet (MapPut (M1 a y) a' y') a0 =
       MapGet (MapPut_behind (M1 a y) a' y') a0.

  Lemma MapPut_behind_as_before :
   forall (m:Map) (a:ad) (y:A) (a0:ad),
     Neqb a a0 = false ->
     MapGet (MapPut m a y) a0 = MapGet (MapPut_behind m a y) a0.

  Lemma MapPut_behind_new :
   forall (m:Map) (a:ad) (y:A),
     MapGet (MapPut_behind m a y) a =
     match MapGet m a with
     | Some y' => Some y'
     | _ => Some y
     end.

  Lemma MapPut_behind_semantics :
   forall (m:Map) (a:ad) (y:A),
     eqm (MapGet (MapPut_behind m a y))
       (fun a':ad =>
          match MapGet m a' with
          | Some y' => Some y'
          | _ => if Neqb a a' then Some y else None
          end).

  Definition makeM2 (m m':Map) :=
    match m, m' with
    | M0, M0 => M0
    | M0, M1 a y => M1 (Ndouble_plus_one a) y
    | M1 a y, M0 => M1 (Ndouble a) y
    | _, _ => M2 m m'
    end.

  Lemma makeM2_M2 :
   forall m m':Map, eqm (MapGet (makeM2 m m')) (MapGet (M2 m m')).

  Fixpoint MapRemove (m:Map) : ad -> Map :=
    match m with
    | M0 => fun _:ad => M0
    | M1 a y =>
        fun a':ad => match Neqb a a' with
                     | true => M0
                     | false => m
                     end
    | M2 m1 m2 =>
        fun a:ad =>
          if Nbit0 a
          then makeM2 m1 (MapRemove m2 (Ndiv2 a))
          else makeM2 (MapRemove m1 (Ndiv2 a)) m2
    end.

  Lemma MapRemove_semantics :
   forall (m:Map) (a:ad),
     eqm (MapGet (MapRemove m a))
       (fun a':ad => if Neqb a a' then None else MapGet m a').

  Fixpoint MapCard (m:Map) : nat :=
    match m with
    | M0 => 0
    | M1 _ _ => 1
    | M2 m m' => MapCard m + MapCard m'
    end.

  Fixpoint MapMerge (m:Map) : Map -> Map :=
    match m with
    | M0 => fun m':Map => m'
    | M1 a y => fun m':Map => MapPut_behind m' a y
    | M2 m1 m2 =>
        fun m':Map =>
          match m' with
          | M0 => m
          | M1 a' y' => MapPut m a' y'
          | M2 m'1 m'2 => M2 (MapMerge m1 m'1) (MapMerge m2 m'2)
          end
    end.

  Lemma MapMerge_semantics :
   forall m m':Map,
     eqm (MapGet (MapMerge m m'))
       (fun a0:ad =>
          match MapGet m' a0 with
          | Some y' => Some y'
          | None => MapGet m a0
          end).

  Fixpoint MapDelta (m:Map) : Map -> Map :=
    match m with
    | M0 => fun m':Map => m'
    | M1 a y =>
        fun m':Map =>
          match MapGet m' a with
          | None => MapPut m' a y
          | _ => MapRemove m' a
          end
    | M2 m1 m2 =>
        fun m':Map =>
          match m' with
          | M0 => m
          | M1 a' y' =>
              match MapGet m a' with
              | None => MapPut m a' y'
              | _ => MapRemove m a'
              end
          | M2 m'1 m'2 => makeM2 (MapDelta m1 m'1) (MapDelta m2 m'2)
          end
    end.

  Lemma MapDelta_semantics_comm :
   forall m m':Map, eqm (MapGet (MapDelta m m')) (MapGet (MapDelta m' m)).

  Lemma MapDelta_semantics_1_1 :
   forall (a:ad) (y:A) (m':Map) (a0:ad),
     MapGet (M1 a y) a0 = None ->
     MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = None.

  Lemma MapDelta_semantics_1 :
   forall (m m':Map) (a:ad),
     MapGet m a = None ->
     MapGet m' a = None -> MapGet (MapDelta m m') a = None.

  Lemma MapDelta_semantics_2_1 :
   forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A),
     MapGet (M1 a y) a0 = None ->
     MapGet m' a0 = Some y0 -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.

  Lemma MapDelta_semantics_2_2 :
   forall (a:ad) (y:A) (m':Map) (a0:ad) (y0:A),
     MapGet (M1 a y) a0 = Some y0 ->
     MapGet m' a0 = None -> MapGet (MapDelta (M1 a y) m') a0 = Some y0.

  Lemma MapDelta_semantics_2 :
   forall (m m':Map) (a:ad) (y:A),
     MapGet m a = None ->
     MapGet m' a = Some y -> MapGet (MapDelta m m') a = Some y.

  Lemma MapDelta_semantics_3_1 :
   forall (a0:ad) (y0:A) (m':Map) (a:ad) (y y':A),
     MapGet (M1 a0 y0) a = Some y ->
     MapGet m' a = Some y' -> MapGet (MapDelta (M1 a0 y0) m') a = None.

  Lemma MapDelta_semantics_3 :
   forall (m m':Map) (a:ad) (y y':A),
     MapGet m a = Some y ->
     MapGet m' a = Some y' -> MapGet (MapDelta m m') a = None.

  Lemma MapDelta_semantics :
   forall m m':Map,
     eqm (MapGet (MapDelta m m'))
       (fun a0:ad =>
          match MapGet m a0, MapGet m' a0 with
          | None, Some y' => Some y'
          | Some y, None => Some y
          | _, _ => None
          end).

  Definition MapEmptyp (m:Map) := match m with
                                  | M0 => true
                                  | _ => false
                                  end.

  Lemma MapEmptyp_correct : MapEmptyp M0 = true.

  Lemma MapEmptyp_complete : forall m:Map, MapEmptyp m = true -> m = M0.

End MapDefs. *)
Require Import Mapaxioms.
(* Mapaxioms:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.

Section MapAxioms.

  Variables A B C : Type.

  Lemma eqm_sym : forall f f':ad -> option A, eqm A f f' -> eqm A f' f.

  Lemma eqm_refl : forall f:ad -> option A, eqm A f f.

  Lemma eqm_trans :
   forall f f' f'':ad -> option A, eqm A f f' -> eqm A f' f'' -> eqm A f f''.

  Definition eqmap (m m':Map A) := eqm A (MapGet A m) (MapGet A m').

  Lemma eqmap_sym : forall m m':Map A, eqmap m m' -> eqmap m' m.

  Lemma eqmap_refl : forall m:Map A, eqmap m m.

  Lemma eqmap_trans :
   forall m m' m'':Map A, eqmap m m' -> eqmap m' m'' -> eqmap m m''.

  Lemma MapPut_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut A m a y) (MapMerge A m (M1 A a y)).

  Lemma MapPut_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A), eqmap (MapPut A m a y) (MapPut A m' a y).

  Lemma MapPut_behind_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut_behind A m a y) (MapMerge A (M1 A a y) m).

  Lemma MapPut_behind_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A),
       eqmap (MapPut_behind A m a y) (MapPut_behind A m' a y).

  Lemma MapMerge_empty_m_1 : forall m:Map A, MapMerge A (M0 A) m = m.

  Lemma MapMerge_empty_m : forall m:Map A, eqmap (MapMerge A (M0 A) m) m.

  Lemma MapMerge_m_empty_1 : forall m:Map A, MapMerge A m (M0 A) = m.

  Lemma MapMerge_m_empty : forall m:Map A, eqmap (MapMerge A m (M0 A)) m.

  Lemma MapMerge_empty_l :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m (M0 A).

  Lemma MapMerge_empty_r :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m' (M0 A).

  Lemma MapMerge_assoc :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapMerge A m m') m'')
       (MapMerge A m (MapMerge A m' m'')).

  Lemma MapMerge_idempotent : forall m:Map A, eqmap (MapMerge A m m) m.

  Lemma MapMerge_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m'2).

  Lemma MapMerge_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m2).

  Lemma MapMerge_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m1 m'2).

  Lemma MapMerge_RestrTo_l :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapDomRestrTo A A m m') m'')
       (MapDomRestrTo A A (MapMerge A m m'') (MapMerge A m' m'')).

  Lemma MapRemove_as_RestrBy :
   forall (m:Map A) (a:ad) (y:B),
     eqmap (MapRemove A m a) (MapDomRestrBy A B m (M1 B a y)).

  Lemma MapRemove_ext :
   forall m m':Map A,
     eqmap m m' -> forall a:ad, eqmap (MapRemove A m a) (MapRemove A m' a).

  Lemma MapDomRestrTo_empty_m_1 :
   forall m:Map B, MapDomRestrTo A B (M0 A) m = M0 A.

  Lemma MapDomRestrTo_empty_m :
   forall m:Map B, eqmap (MapDomRestrTo A B (M0 A) m) (M0 A).

  Lemma MapDomRestrTo_m_empty_1 :
   forall m:Map A, MapDomRestrTo A B m (M0 B) = M0 A.

  Lemma MapDomRestrTo_m_empty :
   forall m:Map A, eqmap (MapDomRestrTo A B m (M0 B)) (M0 A).

  Lemma MapDomRestrTo_assoc :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrTo B C m' m'')).

  Lemma MapDomRestrTo_idempotent :
   forall m:Map A, eqmap (MapDomRestrTo A A m m) m.

  Lemma MapDomRestrTo_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrTo A B m m') (MapDomRestrTo A unit m (MapDom B m')).

  Lemma MapDomRestrBy_empty_m_1 :
   forall m:Map B, MapDomRestrBy A B (M0 A) m = M0 A.

  Lemma MapDomRestrBy_empty_m :
   forall m:Map B, eqmap (MapDomRestrBy A B (M0 A) m) (M0 A).

  Lemma MapDomRestrBy_m_empty_1 :
   forall m:Map A, MapDomRestrBy A B m (M0 B) = m.

  Lemma MapDomRestrBy_m_empty :
   forall m:Map A, eqmap (MapDomRestrBy A B m (M0 B)) m.

  Lemma MapDomRestrBy_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrBy A B m m') (MapDomRestrBy A unit m (MapDom B m')).

  Lemma MapDomRestrBy_m_m_1 :
   forall m:Map A, eqmap (MapDomRestrBy A A m m) (M0 A).

  Lemma MapDomRestrBy_By :
   forall (m:Map A) (m' m'':Map B),
     eqmap (MapDomRestrBy A B (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B m (MapMerge B m' m'')).

  Lemma MapDomRestrBy_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrBy_To :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrBy B C m' m'')).

  Lemma MapDomRestrBy_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrTo_By :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrTo A C m (MapDomRestrBy C B m'' m')).

  Lemma MapDomRestrTo_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrTo A C m m'') m').

  Lemma MapDomRestrTo_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrTo A C m m'') m').

  Lemma MapMerge_DomRestrTo :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrTo A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrTo A B m m'') (MapDomRestrTo A B m' m'')).

  Lemma MapMerge_DomRestrBy :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrBy A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrBy A B m m'') (MapDomRestrBy A B m' m'')).

  Lemma MapDelta_empty_m_1 : forall m:Map A, MapDelta A (M0 A) m = m.

  Lemma MapDelta_empty_m : forall m:Map A, eqmap (MapDelta A (M0 A) m) m.

  Lemma MapDelta_m_empty_1 : forall m:Map A, MapDelta A m (M0 A) = m.

  Lemma MapDelta_m_empty : forall m:Map A, eqmap (MapDelta A m (M0 A)) m.

  Lemma MapDelta_nilpotent : forall m:Map A, eqmap (MapDelta A m m) (M0 A).

  Lemma MapDelta_as_Merge :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapMerge A (MapDomRestrBy A A m m') (MapDomRestrBy A A m' m)).

  Lemma MapDelta_as_DomRestrBy :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

  Lemma MapDelta_as_DomRestrBy_2 :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m' m)).

  Lemma MapDelta_sym :
   forall m m':Map A, eqmap (MapDelta A m m') (MapDelta A m' m).

  Lemma MapDelta_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m'2).

  Lemma MapDelta_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m2).

  Lemma MapDelta_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m1 m'2).

  Lemma MapDom_Split_1 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')).
 
  Lemma MapDom_Split_2 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrBy A B m m') (MapDomRestrTo A B m m')).

  Lemma MapDom_Split_3 :
   forall (m:Map A) (m':Map B),
     eqmap
       (MapDomRestrTo A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m'))
       (M0 A).

End MapAxioms.

Lemma MapDomRestrTo_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m'2).

Lemma MapDomRestrTo_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m2).

Lemma MapDomRestrTo_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m1 m'2).

Lemma MapDomRestrBy_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m'2).

Lemma MapDomRestrBy_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m2).

Lemma MapDomRestrBy_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m1 m'2).

Lemma MapDomRestrBy_m_m :
 forall (A:Type) (m:Map A),
   eqmap A (MapDomRestrBy A unit m (MapDom A m)) (M0 A).

Lemma FSetDelta_assoc :
 forall s s' s'':FSet,
   eqmap unit (MapDelta _ (MapDelta _ s s') s'')
     (MapDelta _ s (MapDelta _ s' s'')).

Lemma FSet_ext :
 forall s s':FSet,
   (forall a:ad, in_FSet a s = in_FSet a s') -> eqmap unit s s'.

Lemma FSetUnion_comm :
 forall s s':FSet, eqmap unit (FSetUnion s s') (FSetUnion s' s).

Lemma FSetUnion_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetUnion s s') s'')
     (FSetUnion s (FSetUnion s' s'')).

Lemma FSetUnion_M0_s : forall s:FSet, eqmap unit (FSetUnion (M0 unit) s) s.

Lemma FSetUnion_s_M0 : forall s:FSet, eqmap unit (FSetUnion s (M0 unit)) s.

Lemma FSetUnion_idempotent : forall s:FSet, eqmap unit (FSetUnion s s) s.

Lemma FSetInter_comm :
 forall s s':FSet, eqmap unit (FSetInter s s') (FSetInter s' s).

Lemma FSetInter_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetInter s s') s'')
     (FSetInter s (FSetInter s' s'')).

Lemma FSetInter_M0_s :
 forall s:FSet, eqmap unit (FSetInter (M0 unit) s) (M0 unit).

Lemma FSetInter_s_M0 :
 forall s:FSet, eqmap unit (FSetInter s (M0 unit)) (M0 unit).

Lemma FSetInter_idempotent : forall s:FSet, eqmap unit (FSetInter s s) s.

Lemma FSetUnion_Inter_l :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetInter s s') s'')
     (FSetInter (FSetUnion s s'') (FSetUnion s' s'')).

Lemma FSetUnion_Inter_r :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion s (FSetInter s' s''))
     (FSetInter (FSetUnion s s') (FSetUnion s s'')).

Lemma FSetInter_Union_l :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetUnion s s') s'')
     (FSetUnion (FSetInter s s'') (FSetInter s' s'')).

Lemma FSetInter_Union_r :
 forall s s' s'':FSet,
   eqmap unit (FSetInter s (FSetUnion s' s''))
     (FSetUnion (FSetInter s s') (FSetInter s s'')). *)
Require Import Fset.
(* Fset:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.

Section Dom.

  Variables A B : Type.

  Fixpoint MapDomRestrTo (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => M0 A
                        | _ => m
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => M0 A
          | M1 a' y' =>
              match MapGet A m a' with
              | None => M0 A
              | Some y => M1 A a' y
              end
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrTo m1 m'1) (MapDomRestrTo m2 m'2)
          end
    end.

  Lemma MapDomRestrTo_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrTo m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => None
          | _ => MapGet A m a0
          end).

  Fixpoint MapDomRestrBy (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => m
                        | _ => M0 A
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => m
          | M1 a' y' => MapRemove A m a'
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrBy m1 m'1) (MapDomRestrBy m2 m'2)
          end
    end.

  Lemma MapDomRestrBy_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrBy m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => MapGet A m a0
          | _ => None
          end).

  Definition in_dom (a:ad) (m:Map A) :=
    match MapGet A m a with
    | None => false
    | _ => true
    end.

  Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.

  Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.

  Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.

  Lemma in_dom_M1_2 :
   forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.

  Lemma in_dom_some :
   forall (m:Map A) (a:ad),
     in_dom a m = true -> {y : A | MapGet A m a = Some y}.

  Lemma in_dom_none :
   forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.

  Lemma in_dom_put :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_put_behind :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_remove :
   forall (m:Map A) (a0 a:ad),
     in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).

  Lemma in_dom_merge :
   forall (m m':Map A) (a:ad),
     in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').

  Lemma in_dom_delta :
   forall (m m':Map A) (a:ad),
     in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').

End Dom.

Section InDom.

  Variables A B : Type.

  Lemma in_dom_restrto :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrTo A B m m') =
     andb (in_dom A a m) (in_dom B a m').

  Lemma in_dom_restrby :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrBy A B m m') =
     andb (in_dom A a m) (negb (in_dom B a m')).

End InDom.

Definition FSet := Map unit.

Section FSetDefs.

  Variable A : Type.

  Definition in_FSet : ad -> FSet -> bool := in_dom unit.

  Fixpoint MapDom (m:Map A) : FSet :=
    match m with
    | M0 => M0 unit
    | M1 a _ => M1 unit a tt
    | M2 m m' => M2 unit (MapDom m) (MapDom m')
    end.

  Lemma MapDom_semantics_1 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y -> in_FSet a (MapDom m) = true.

  Lemma MapDom_semantics_2 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.

  Lemma MapDom_semantics_3 :
   forall (m:Map A) (a:ad),
     MapGet A m a = None -> in_FSet a (MapDom m) = false.

  Lemma MapDom_semantics_4 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = false -> MapGet A m a = None.

  Lemma MapDom_Dom :
   forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).

  Definition FSetUnion (s s':FSet) : FSet := MapMerge unit s s'.

  Lemma in_FSet_union :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').

  Definition FSetInter (s s':FSet) : FSet := MapDomRestrTo unit unit s s'.

  Lemma in_FSet_inter :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').

  Definition FSetDiff (s s':FSet) : FSet := MapDomRestrBy unit unit s s'.

  Lemma in_FSet_diff :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).

  Definition FSetDelta (s s':FSet) : FSet := MapDelta unit s s'.

  Lemma in_FSet_delta :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').

End FSetDefs.

Lemma FSet_Dom : forall s:FSet, MapDom unit s = s. *)
Require Import List.

Section MapIter.

  Variable A : Type.

  Section MapSweepDef.

  Variable f : ad -> A -> bool.

  Definition MapSweep2 (a0:ad) (y:A) :=
    if f a0 y then Some (a0, y) else None.

  Fixpoint MapSweep1 (pf:ad -> ad) (m:Map A) {struct m} : 
   option (ad * A) :=
    match m with
    | M0 => None
    | M1 a y => MapSweep2 (pf a) y
    | M2 m m' =>
        match MapSweep1 (fun a:ad => pf (Ndouble a)) m with
        | Some r => Some r
        | None => MapSweep1 (fun a:ad => pf (Ndouble_plus_one a)) m'
        end
    end.

  Definition MapSweep (m:Map A) := MapSweep1 (fun a:ad => a) m.

  Lemma MapSweep_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> f a y = true.
  Proof.
    simple induction m. intros. discriminate H.
    simpl in |- *. intros a y pf a0 y0. elim (sumbool_of_bool (f (pf a) y)). intro H. unfold MapSweep2 in |- *.
    rewrite H. intro H0. inversion H0. rewrite <- H3. assumption.
    intro H. unfold MapSweep2 in |- *. rewrite H. intro H0. discriminate H0.
    simpl in |- *. intros. elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
    intro H2. elim H2. intros r H3. rewrite H3 in H1. inversion H1. rewrite H5 in H3.
    exact (H (fun a0:ad => pf (Ndouble a0)) a y H3).
    intro H2. rewrite H2 in H1. exact (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H1).
  Qed.

  Lemma MapSweep_semantics_1 :
   forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.
  Proof.
    intros. exact (MapSweep_semantics_1_1 m (fun a:ad => a) a y H).
  Qed.

  Lemma MapSweep_semantics_2_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.
  Proof.
    simple induction m. intros. discriminate H.
    simpl in |- *. unfold MapSweep2 in |- *. intros a y pf a0 y0. case (f (pf a) y). intros. split with a.
    inversion H. reflexivity.
    intro. discriminate H.
    intros m0 H m1 H0 pf a y. simpl in |- *.
    elim
     (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)). intro H1. elim H1.
    intros r H2. rewrite H2. intro H3. inversion H3. rewrite H5 in H2.
    elim (H (fun a0:ad => pf (Ndouble a0)) a y H2). intros a0 H6. split with (Ndouble a0).
    assumption.
    intro H1. rewrite H1. intro H2. elim (H0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H2).
    intros a0 H3. split with (Ndouble_plus_one a0). assumption.
  Qed.

  Lemma MapSweep_semantics_2_2 :
   forall (m:Map A) (pf fp:ad -> ad),
     (forall a0:ad, fp (pf a0) = a0) ->
     forall (a:ad) (y:A),
       MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.
  Proof.
    simple induction m. intros. discriminate H0.
    simpl in |- *. intros a y pf fp H a0 y0. unfold MapSweep2 in |- *. elim (sumbool_of_bool (f (pf a) y)).
    intro H0. rewrite H0. intro H1. inversion H1. rewrite (H a). rewrite (Neqb_correct a).
    reflexivity.
    intro H0. rewrite H0. intro H1. discriminate H1.
    intros. rewrite (MapGet_M2_bit_0_if A m0 m1 (fp a)). elim (sumbool_of_bool (Nbit0 (fp a))).
    intro H3. rewrite H3. elim (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)).
    intro H4. simpl in H2. apply
  (H0 (fun a0:ad => pf (Ndouble_plus_one a0))
     (fun a0:ad => Ndiv2 (fp a0))).
    intro. rewrite H1. apply Ndouble_plus_one_div2.
    elim
     (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)). intro H5. elim H5.
    intros r H6. rewrite H6 in H2. inversion H2. rewrite H8 in H6.
    elim (MapSweep_semantics_2_1 m0 (fun a0:ad => pf (Ndouble a0)) a y H6). intros a0 H9.
    rewrite H9 in H3. rewrite (H1 (Ndouble a0)) in H3. rewrite (Ndouble_bit0 a0) in H3.
    discriminate H3.
    intro H5. rewrite H5 in H2. assumption.
    intro H4. simpl in H2. rewrite H4 in H2.
    apply
     (H0 (fun a0:ad => pf (Ndouble_plus_one a0))
        (fun a0:ad => Ndiv2 (fp a0))). intro.
    rewrite H1. apply Ndouble_plus_one_div2.
    assumption.
    intro H3. rewrite H3. simpl in H2.
    elim
     (option_sum (ad * A) (MapSweep1 (fun a0:ad => pf (Ndouble a0)) m0)). intro H4. elim H4.
    intros r H5. rewrite H5 in H2. inversion H2. rewrite H7 in H5.
    apply
     (H (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => Ndiv2 (fp a0))). intro. rewrite H1.
    apply Ndouble_div2.
    assumption.
    intro H4. rewrite H4 in H2.
    elim
     (MapSweep_semantics_2_1 m1 (fun a0:ad => pf (Ndouble_plus_one a0)) a y
        H2).
    intros a0 H5. rewrite H5 in H3. rewrite (H1 (Ndouble_plus_one a0)) in H3.
    rewrite (Ndouble_plus_one_bit0 a0) in H3. discriminate H3.
  Qed.

  Lemma MapSweep_semantics_2 :
   forall (m:Map A) (a:ad) (y:A),
     MapSweep m = Some (a, y) -> MapGet A m a = Some y.
  Proof.
    intros.
    exact
     (MapSweep_semantics_2_2 m (fun a0:ad => a0) (fun a0:ad => a0)
        (fun a0:ad => refl_equal a0) a y H).
  Qed.

  Lemma MapSweep_semantics_3_1 :
   forall (m:Map A) (pf:ad -> ad),
     MapSweep1 pf m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.
  Proof.
    simple induction m. intros. discriminate H0.
    simpl in |- *. unfold MapSweep2 in |- *. intros a y pf. elim (sumbool_of_bool (f (pf a) y)). intro H.
    rewrite H. intro. discriminate H0.
    intro H. rewrite H. intros H0 a0 y0. elim (sumbool_of_bool (Neqb a a0)). intro H1. rewrite H1.
    intro H2. inversion H2. rewrite <- H4. rewrite <- (Neqb_complete _ _ H1). assumption.
    intro H1. rewrite H1. intro. discriminate H2.
    intros. simpl in H1. elim (option_sum (ad * A) (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
    intro H3. elim H3. intros r H4. rewrite H4 in H1. discriminate H1.
    intro H3. rewrite H3 in H1. elim (sumbool_of_bool (Nbit0 a)). intro H4.
    rewrite (MapGet_M2_bit_0_1 A a H4 m0 m1) in H2. rewrite <- (Ndiv2_double_plus_one a H4).
    exact (H0 (fun a:ad => pf (Ndouble_plus_one a)) H1 (Ndiv2 a) y H2).
    intro H4. rewrite (MapGet_M2_bit_0_0 A a H4 m0 m1) in H2. rewrite <- (Ndiv2_double a H4).
    exact (H (fun a:ad => pf (Ndouble a)) H3 (Ndiv2 a) y H2).
  Qed.

  Lemma MapSweep_semantics_3 :
   forall m:Map A,
     MapSweep m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.
  Proof.
    intros.
    exact (MapSweep_semantics_3_1 m (fun a0:ad => a0) H a y H0).
  Qed.

  Lemma MapSweep_semantics_4_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f (pf a) y = true ->
     {a' : ad &  {y' : A | MapSweep1 pf m = Some (a', y')}}.
  Proof.
    simple induction m. intros. discriminate H.
    intros. elim (sumbool_of_bool (Neqb a a1)). intro H1. split with (pf a1). split with y.
    rewrite (Neqb_complete _ _ H1). unfold MapSweep1, MapSweep2 in |- *.
    rewrite (Neqb_complete _ _ H1) in H. rewrite (M1_semantics_1 _ a1 a0) in H.
    inversion H. rewrite H0. reflexivity.

    intro H1. rewrite (M1_semantics_2 _ a a1 a0 H1) in H. discriminate H.

    intros. elim (sumbool_of_bool (Nbit0 a)). intro H3.
    rewrite (MapGet_M2_bit_0_1 _ _ H3 m0 m1) in H.
    rewrite <- (Ndiv2_double_plus_one a H3) in H0.
    elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) (Ndiv2 a) y H H0). intros a'' H4. elim H4.
    intros y'' H5. simpl in |- *. elim (option_sum _ (MapSweep1 (fun a:ad => pf (Ndouble a)) m0)).
    intro H6. elim H6. intro r. elim r. intros a''' y''' H7. rewrite H7. split with a'''.
    split with y'''. reflexivity.
    intro H6. rewrite H6. split with a''. split with y''. assumption.
    intro H3. rewrite (MapGet_M2_bit_0_0 _ _ H3 m0 m1) in H.
    rewrite <- (Ndiv2_double a H3) in H0.
    elim (X (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a) y H H0). intros a'' H4. elim H4.
    intros y'' H5. split with a''. split with y''. simpl in |- *. rewrite H5. reflexivity.
  Qed.

  Lemma MapSweep_semantics_4 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f a y = true -> {a' : ad &  {y' : A | MapSweep m = Some (a', y')}}.
  Proof.
    intros. exact (MapSweep_semantics_4_1 m (fun a0:ad => a0) a y H H0).
  Qed.

  End MapSweepDef.

  Variable B : Type.

  Fixpoint MapCollect1 (f:ad -> A -> Map B) (pf:ad -> ad) 
   (m:Map A) {struct m} : Map B :=
    match m with
    | M0 => M0 B
    | M1 a y => f (pf a) y
    | M2 m1 m2 =>
        MapMerge B (MapCollect1 f (fun a0:ad => pf (Ndouble a0)) m1)
          (MapCollect1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
    end.

  Definition MapCollect (f:ad -> A -> Map B) (m:Map A) :=
    MapCollect1 f (fun a:ad => a) m.

  Section MapFoldDef.

    Variable M : Type.
    Variable neutral : M.
    Variable op : M -> M -> M.

    Fixpoint MapFold1 (f:ad -> A -> M) (pf:ad -> ad) 
     (m:Map A) {struct m} : M :=
      match m with
      | M0 => neutral
      | M1 a y => f (pf a) y
      | M2 m1 m2 =>
          op (MapFold1 f (fun a0:ad => pf (Ndouble a0)) m1)
            (MapFold1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
      end.

    Definition MapFold (f:ad -> A -> M) (m:Map A) :=
      MapFold1 f (fun a:ad => a) m.

    Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.
    Proof.
      trivial.
    Qed.

    Lemma MapFold_M1 :
     forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.
    Proof.
      trivial.
    Qed.

    Variable State : Type.
    Variable f : State -> ad -> A -> State * M.

    Fixpoint MapFold1_state (state:State) (pf:ad -> ad) 
     (m:Map A) {struct m} : State * M :=
      match m with
      | M0 => (state, neutral)
      | M1 a y => f state (pf a) y
      | M2 m1 m2 =>
          match MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m1 with
          | (state1, x1) =>
              match
                MapFold1_state state1
                  (fun a0:ad => pf (Ndouble_plus_one a0)) m2
              with
              | (state2, x2) => (state2, op x1 x2)
              end
          end
      end.

    Definition MapFold_state (state:State) :=
      MapFold1_state state (fun a:ad => a).

    Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).
    Proof.
      simple induction x. trivial.
    Qed.

    Lemma MapFold_state_stateless_1 :
     forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad),
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.
    Proof.
      simple induction m. trivial.
      intros. simpl in |- *. apply H.
      intros. simpl in |- *. rewrite
  (pair_sp _ _ (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0))
  .
      rewrite (H g (fun a0:ad => pf (Ndouble a0)) H1 state).
      rewrite
       (pair_sp _ _
          (MapFold1_state
             (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0))
             (fun a0:ad => pf (Ndouble_plus_one a0)) m1))
       .
      simpl in |- *.
      rewrite
       (H0 g (fun a0:ad => pf (Ndouble_plus_one a0)) H1
          (fst (MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m0)))
       .
      reflexivity.
    Qed.

    Lemma MapFold_state_stateless :
     forall g:ad -> A -> M,
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall (state:State) (m:Map A),
         snd (MapFold_state state m) = MapFold g m.
    Proof.
      intros. exact (MapFold_state_stateless_1 m g (fun a0:ad => a0) H state).
    Qed.

  End MapFoldDef.

  Lemma MapCollect_as_Fold :
   forall (f:ad -> A -> Map B) (m:Map A),
     MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.
  Proof.
    simple induction m; trivial.
  Qed.

  Definition alist := list (ad * A).
  Definition anil := nil (A:=(ad * A)).
  Definition acons := cons (A:=(ad * A)).
  Definition aapp := app (A:=(ad * A)).

  Definition alist_of_Map :=
    MapFold alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil).

  Fixpoint alist_semantics (l:alist) : ad -> option A :=
    match l with
    | nil => fun _:ad => None
    | (a, y) :: l' =>
        fun a0:ad => if Neqb a a0 then Some y else alist_semantics l' a0
    end.

  Lemma alist_semantics_app :
   forall (l l':alist) (a:ad),
     alist_semantics (aapp l l') a =
     match alist_semantics l a with
     | None => alist_semantics l' a
     | Some y => Some y
     end.
  Proof.
    unfold aapp in |- *. simple induction l. trivial.
    intros. elim a. intros a1 y1. simpl in |- *. case (Neqb a1 a0). reflexivity.
    apply H.
  Qed.

  Lemma alist_of_Map_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     alist_semantics
       (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf
          m) a = Some y -> {a' : ad | a = pf a'}.
  Proof.
    simple induction m. simpl in |- *. intros. discriminate H.
    simpl in |- *. intros a y pf a0 y0. elim (sumbool_of_bool (Neqb (pf a) a0)). intro H. rewrite H.
    intro H0. split with a. rewrite (Neqb_complete _ _ H). reflexivity.
    intro H. rewrite H. intro H0. discriminate H0.
    intros. change
   (alist_semantics
      (aapp
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            (fun a0:ad => pf (Ndouble a0)) m0)
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) a = 
    Some y) in H.
    rewrite
     (alist_semantics_app
        (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil)
           (fun a0:ad => pf (Ndouble a0)) m0)
        (MapFold1 alist anil aapp (fun (a0:ad) (y0:A) => acons (a0, y0) anil)
           (fun a0:ad => pf (Ndouble_plus_one a0)) m1) a)
      in H.
    elim
     (option_sum A
        (alist_semantics
           (MapFold1 alist anil aapp
              (fun (a0:ad) (y0:A) => acons (a0, y0) anil)
              (fun a0:ad => pf (Ndouble a0)) m0) a)).
    intro H2. elim H2. intros y0 H3. elim (X (fun a0:ad => pf (Ndouble a0)) a y0 H3). intros a0 H4.
    split with (Ndouble a0). assumption.
    intro H2. rewrite H2 in H. elim (X0 (fun a0:ad => pf (Ndouble_plus_one a0)) a y H).
    intros a0 H3. split with (Ndouble_plus_one a0). assumption.
  Qed.

  Definition ad_inj (pf:ad -> ad) :=
    forall a0 a1:ad, pf a0 = pf a1 -> a0 = a1.

  Lemma ad_comp_double_inj :
   forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).
  Proof.
    unfold ad_inj in |- *. intros. apply Ndouble_inj. exact (H _ _ H0).
  Qed.

  Lemma ad_comp_double_plus_un_inj :
   forall pf:ad -> ad,
     ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).
  Proof.
    unfold ad_inj in |- *. intros. apply Ndouble_plus_one_inj. exact (H _ _ H0).
  Qed.

  Lemma alist_of_Map_semantics_1 :
   forall (m:Map A) (pf:ad -> ad),
     ad_inj pf ->
     forall a:ad,
       MapGet A m a =
       alist_semantics
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            pf m) (pf a).
  Proof.
    simple induction m. trivial.
    simpl in |- *. intros. elim (sumbool_of_bool (Neqb a a1)). intro H0. rewrite H0.
    rewrite (Neqb_complete _ _ H0). rewrite (Neqb_correct (pf a1)). reflexivity.
    intro H0. rewrite H0. elim (sumbool_of_bool (Neqb (pf a) (pf a1))). intro H1.
    rewrite (H a a1 (Neqb_complete _ _ H1)) in H0. rewrite (Neqb_correct a1) in H0.
    discriminate H0.
    intro H1. rewrite H1. reflexivity.
    intros. change
   (MapGet A (M2 A m0 m1) a =
    alist_semantics
      (aapp
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            (fun a0:ad => pf (Ndouble a0)) m0)
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            (fun a0:ad => pf (Ndouble_plus_one a0)) m1)) (
      pf a)) in |- *.
    rewrite alist_semantics_app. rewrite (MapGet_M2_bit_0_if A m0 m1 a).
    elim (Ndouble_or_double_plus_un a). intro H2. elim H2. intros a0 H3. rewrite H3.
    rewrite (Ndouble_bit0 a0).
    rewrite <-
     (H (fun a1:ad => pf (Ndouble a1)) (ad_comp_double_inj pf H1) a0)
     .
    rewrite Ndouble_div2. case (MapGet A m0 a0); trivial.
    elim
     (option_sum A
        (alist_semantics
           (MapFold1 alist anil aapp
              (fun (a1:ad) (y:A) => acons (a1, y) anil)
              (fun a1:ad => pf (Ndouble_plus_one a1)) m1)
           (pf (Ndouble a0)))).
    intro H4. elim H4. intros y H5.
    elim
     (alist_of_Map_semantics_1_1 m1 (fun a1:ad => pf (Ndouble_plus_one a1))
        (pf (Ndouble a0)) y H5).
    intros a1 H6. cut (Nbit0 (Ndouble a0) = Nbit0 (Ndouble_plus_one a1)).
    intro. rewrite (Ndouble_bit0 a0) in H7. rewrite (Ndouble_plus_one_bit0 a1) in H7.
    discriminate H7.
    rewrite (H1 (Ndouble a0) (Ndouble_plus_one a1) H6). reflexivity.
    intro H4. rewrite H4. reflexivity.
    intro H2. elim H2. intros a0 H3. rewrite H3. rewrite (Ndouble_plus_one_bit0 a0).
    rewrite <-
     (H0 (fun a1:ad => pf (Ndouble_plus_one a1))
        (ad_comp_double_plus_un_inj pf H1) a0).
    rewrite Ndouble_plus_one_div2.
    elim
     (option_sum A
        (alist_semantics
           (MapFold1 alist anil aapp
              (fun (a1:ad) (y:A) => acons (a1, y) anil)
              (fun a1:ad => pf (Ndouble a1)) m0)
           (pf (Ndouble_plus_one a0)))).
    intro H4. elim H4. intros y H5.
    elim
     (alist_of_Map_semantics_1_1 m0 (fun a1:ad => pf (Ndouble a1))
        (pf (Ndouble_plus_one a0)) y H5).
    intros a1 H6. cut (Nbit0 (Ndouble_plus_one a0) = Nbit0 (Ndouble a1)).
    intro H7. rewrite (Ndouble_plus_one_bit0 a0) in H7. rewrite (Ndouble_bit0 a1) in H7.
    discriminate H7.
    rewrite (H1 (Ndouble_plus_one a0) (Ndouble a1) H6). reflexivity.
    intro H4. rewrite H4. reflexivity.
  Qed.

  Lemma alist_of_Map_semantics :
   forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).
  Proof.
    unfold eqm in |- *. intros. exact
  (alist_of_Map_semantics_1 m (fun a0:ad => a0)
     (fun (a0 a1:ad) (p:a0 = a1) => p) a).
  Qed.

  Fixpoint Map_of_alist (l:alist) : Map A :=
    match l with
    | nil => M0 A
    | (a, y) :: l' => MapPut A (Map_of_alist l') a y
    end.

  Lemma Map_of_alist_semantics :
   forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).
  Proof.
    unfold eqm in |- *. simple induction l. trivial.
    intros r l0 H a. elim r. intros a0 y0. simpl in |- *. elim (sumbool_of_bool (Neqb a0 a)).
    intro H0. rewrite H0. rewrite (Neqb_complete _ _ H0).
    rewrite (MapPut_semantics A (Map_of_alist l0) a y0 a). rewrite (Neqb_correct a).
    reflexivity.
    intro H0. rewrite H0. rewrite (MapPut_semantics A (Map_of_alist l0) a0 y0 a).
    rewrite H0. apply H.
  Qed.

  Lemma Map_of_alist_of_Map :
   forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.
  Proof.
    unfold eqmap in |- *. intro. apply eqm_trans with (f' := alist_semantics (alist_of_Map m)).
    apply eqm_sym. apply Map_of_alist_semantics.
    apply eqm_sym. apply alist_of_Map_semantics.
  Qed.

  Lemma alist_of_Map_of_alist :
   forall l:alist,
     eqm A (alist_semantics (alist_of_Map (Map_of_alist l)))
       (alist_semantics l).
  Proof.
    intro. apply eqm_trans with (f' := MapGet A (Map_of_alist l)).
    apply eqm_sym. apply alist_of_Map_semantics.
    apply eqm_sym. apply Map_of_alist_semantics.
  Qed.

  Lemma fold_right_aapp :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     forall (f:ad -> A -> M) (l l':alist),
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (aapp l l') =
       op
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l)
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l').
  Proof.
    simple induction l. simpl in |- *. intro. rewrite H0. reflexivity.
    intros r l0 H1 l'. elim r. intros a y. simpl in |- *. rewrite H. rewrite (H1 l'). reflexivity.
  Qed.

  Lemma MapFold_as_fold_1 :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad),
       MapFold1 M neutral op f pf m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral
         (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf
            m).
  Proof.
    simple induction m. trivial.
    intros. simpl in |- *. rewrite H1. reflexivity.
    intros. simpl in |- *. rewrite (fold_right_aapp M neutral op H H0 f).
    rewrite (H2 (fun a0:ad => pf (Ndouble a0))). rewrite (H3 (fun a0:ad => pf (Ndouble_plus_one a0))).
    reflexivity.
  Qed.

  Lemma MapFold_as_fold :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A),
       MapFold M neutral op f m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (alist_of_Map m).
  Proof.
    intros. exact (MapFold_as_fold_1 M neutral op H H0 H1 f m (fun a0:ad => a0)).
  Qed.

  Lemma alist_MapMerge_semantics :
   forall m m':Map A,
     eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).
  Proof.
    unfold eqm in |- *. intros. rewrite alist_semantics_app. rewrite <- (alist_of_Map_semantics m a).
    rewrite <- (alist_of_Map_semantics m' a).
    rewrite <- (alist_of_Map_semantics (MapMerge A m m') a).
    rewrite (MapMerge_semantics A m m' a). reflexivity.
  Qed.

  Lemma alist_MapMerge_semantics_disjoint :
   forall m m':Map A,
     eqmap A (MapDomRestrTo A A m m') (M0 A) ->
     eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).
  Proof.
    unfold eqm in |- *. intros. rewrite alist_semantics_app. rewrite <- (alist_of_Map_semantics m a).
    rewrite <- (alist_of_Map_semantics m' a).
    rewrite <- (alist_of_Map_semantics (MapMerge A m m') a). rewrite (MapMerge_semantics A m m' a).
    elim (option_sum _ (MapGet A m a)). intro H0. elim H0. intros y H1. rewrite H1.
    elim (option_sum _ (MapGet A m' a)). intro H2. elim H2. intros y' H3.
    cut (MapGet A (MapDomRestrTo A A m m') a = None).
    rewrite (MapDomRestrTo_semantics A A m m' a). rewrite H3. rewrite H1. intro. discriminate H4.
    exact (H a).
    intro H2. rewrite H2. reflexivity.
    intro H0. rewrite H0. case (MapGet A m' a); trivial.
  Qed.

  Lemma alist_semantics_disjoint_comm :
   forall l l':alist,
     eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) ->
     eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).
  Proof.
    unfold eqm in |- *. intros. rewrite (alist_semantics_app l l' a). rewrite (alist_semantics_app l' l a).
    rewrite <- (alist_of_Map_of_alist l a). rewrite <- (alist_of_Map_of_alist l' a).
    rewrite <-
     (alist_semantics_app (alist_of_Map (Map_of_alist l))
        (alist_of_Map (Map_of_alist l')) a).
    rewrite <-
     (alist_semantics_app (alist_of_Map (Map_of_alist l'))
        (alist_of_Map (Map_of_alist l)) a).
    rewrite (alist_MapMerge_semantics (Map_of_alist l) (Map_of_alist l') a).
    rewrite
     (alist_MapMerge_semantics_disjoint (Map_of_alist l) (
        Map_of_alist l') H a).
    reflexivity.
  Qed.

End MapIter.
