

Require Import Bool.

Require Import Sumbool.

Require Import Arith.

Require Import NArith.

Require Import Ndigits.

Require Import Ndec.

Require Import Map.

Require Import Fset.
(* Fset:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.

Section Dom.

  Variables A B : Type.

  Fixpoint MapDomRestrTo (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => M0 A
                        | _ => m
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => M0 A
          | M1 a' y' =>
              match MapGet A m a' with
              | None => M0 A
              | Some y => M1 A a' y
              end
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrTo m1 m'1) (MapDomRestrTo m2 m'2)
          end
    end.

  Lemma MapDomRestrTo_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrTo m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => None
          | _ => MapGet A m a0
          end).

  Fixpoint MapDomRestrBy (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => m
                        | _ => M0 A
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => m
          | M1 a' y' => MapRemove A m a'
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrBy m1 m'1) (MapDomRestrBy m2 m'2)
          end
    end.

  Lemma MapDomRestrBy_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrBy m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => MapGet A m a0
          | _ => None
          end).

  Definition in_dom (a:ad) (m:Map A) :=
    match MapGet A m a with
    | None => false
    | _ => true
    end.

  Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.

  Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.

  Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.

  Lemma in_dom_M1_2 :
   forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.

  Lemma in_dom_some :
   forall (m:Map A) (a:ad),
     in_dom a m = true -> {y : A | MapGet A m a = Some y}.

  Lemma in_dom_none :
   forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.

  Lemma in_dom_put :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_put_behind :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_remove :
   forall (m:Map A) (a0 a:ad),
     in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).

  Lemma in_dom_merge :
   forall (m m':Map A) (a:ad),
     in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').

  Lemma in_dom_delta :
   forall (m m':Map A) (a:ad),
     in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').

End Dom.

Section InDom.

  Variables A B : Type.

  Lemma in_dom_restrto :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrTo A B m m') =
     andb (in_dom A a m) (in_dom B a m').

  Lemma in_dom_restrby :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrBy A B m m') =
     andb (in_dom A a m) (negb (in_dom B a m')).

End InDom.

Definition FSet := Map unit.

Section FSetDefs.

  Variable A : Type.

  Definition in_FSet : ad -> FSet -> bool := in_dom unit.

  Fixpoint MapDom (m:Map A) : FSet :=
    match m with
    | M0 => M0 unit
    | M1 a _ => M1 unit a tt
    | M2 m m' => M2 unit (MapDom m) (MapDom m')
    end.

  Lemma MapDom_semantics_1 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y -> in_FSet a (MapDom m) = true.

  Lemma MapDom_semantics_2 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.

  Lemma MapDom_semantics_3 :
   forall (m:Map A) (a:ad),
     MapGet A m a = None -> in_FSet a (MapDom m) = false.

  Lemma MapDom_semantics_4 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = false -> MapGet A m a = None.

  Lemma MapDom_Dom :
   forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).

  Definition FSetUnion (s s':FSet) : FSet := MapMerge unit s s'.

  Lemma in_FSet_union :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').

  Definition FSetInter (s s':FSet) : FSet := MapDomRestrTo unit unit s s'.

  Lemma in_FSet_inter :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').

  Definition FSetDiff (s s':FSet) : FSet := MapDomRestrBy unit unit s s'.

  Lemma in_FSet_diff :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).

  Definition FSetDelta (s s':FSet) : FSet := MapDelta unit s s'.

  Lemma in_FSet_delta :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').

End FSetDefs.

Lemma FSet_Dom : forall s:FSet, MapDom unit s = s. *)

Require Import Mapaxioms.
(* Mapaxioms:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.

Section MapAxioms.

  Variables A B C : Type.

  Lemma eqm_sym : forall f f':ad -> option A, eqm A f f' -> eqm A f' f.

  Lemma eqm_refl : forall f:ad -> option A, eqm A f f.

  Lemma eqm_trans :
   forall f f' f'':ad -> option A, eqm A f f' -> eqm A f' f'' -> eqm A f f''.

  Definition eqmap (m m':Map A) := eqm A (MapGet A m) (MapGet A m').

  Lemma eqmap_sym : forall m m':Map A, eqmap m m' -> eqmap m' m.

  Lemma eqmap_refl : forall m:Map A, eqmap m m.

  Lemma eqmap_trans :
   forall m m' m'':Map A, eqmap m m' -> eqmap m' m'' -> eqmap m m''.

  Lemma MapPut_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut A m a y) (MapMerge A m (M1 A a y)).

  Lemma MapPut_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A), eqmap (MapPut A m a y) (MapPut A m' a y).

  Lemma MapPut_behind_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut_behind A m a y) (MapMerge A (M1 A a y) m).

  Lemma MapPut_behind_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A),
       eqmap (MapPut_behind A m a y) (MapPut_behind A m' a y).

  Lemma MapMerge_empty_m_1 : forall m:Map A, MapMerge A (M0 A) m = m.

  Lemma MapMerge_empty_m : forall m:Map A, eqmap (MapMerge A (M0 A) m) m.

  Lemma MapMerge_m_empty_1 : forall m:Map A, MapMerge A m (M0 A) = m.

  Lemma MapMerge_m_empty : forall m:Map A, eqmap (MapMerge A m (M0 A)) m.

  Lemma MapMerge_empty_l :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m (M0 A).

  Lemma MapMerge_empty_r :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m' (M0 A).

  Lemma MapMerge_assoc :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapMerge A m m') m'')
       (MapMerge A m (MapMerge A m' m'')).

  Lemma MapMerge_idempotent : forall m:Map A, eqmap (MapMerge A m m) m.

  Lemma MapMerge_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m'2).

  Lemma MapMerge_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m2).

  Lemma MapMerge_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m1 m'2).

  Lemma MapMerge_RestrTo_l :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapDomRestrTo A A m m') m'')
       (MapDomRestrTo A A (MapMerge A m m'') (MapMerge A m' m'')).

  Lemma MapRemove_as_RestrBy :
   forall (m:Map A) (a:ad) (y:B),
     eqmap (MapRemove A m a) (MapDomRestrBy A B m (M1 B a y)).

  Lemma MapRemove_ext :
   forall m m':Map A,
     eqmap m m' -> forall a:ad, eqmap (MapRemove A m a) (MapRemove A m' a).

  Lemma MapDomRestrTo_empty_m_1 :
   forall m:Map B, MapDomRestrTo A B (M0 A) m = M0 A.

  Lemma MapDomRestrTo_empty_m :
   forall m:Map B, eqmap (MapDomRestrTo A B (M0 A) m) (M0 A).

  Lemma MapDomRestrTo_m_empty_1 :
   forall m:Map A, MapDomRestrTo A B m (M0 B) = M0 A.

  Lemma MapDomRestrTo_m_empty :
   forall m:Map A, eqmap (MapDomRestrTo A B m (M0 B)) (M0 A).

  Lemma MapDomRestrTo_assoc :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrTo B C m' m'')).

  Lemma MapDomRestrTo_idempotent :
   forall m:Map A, eqmap (MapDomRestrTo A A m m) m.

  Lemma MapDomRestrTo_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrTo A B m m') (MapDomRestrTo A unit m (MapDom B m')).

  Lemma MapDomRestrBy_empty_m_1 :
   forall m:Map B, MapDomRestrBy A B (M0 A) m = M0 A.

  Lemma MapDomRestrBy_empty_m :
   forall m:Map B, eqmap (MapDomRestrBy A B (M0 A) m) (M0 A).

  Lemma MapDomRestrBy_m_empty_1 :
   forall m:Map A, MapDomRestrBy A B m (M0 B) = m.

  Lemma MapDomRestrBy_m_empty :
   forall m:Map A, eqmap (MapDomRestrBy A B m (M0 B)) m.

  Lemma MapDomRestrBy_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrBy A B m m') (MapDomRestrBy A unit m (MapDom B m')).

  Lemma MapDomRestrBy_m_m_1 :
   forall m:Map A, eqmap (MapDomRestrBy A A m m) (M0 A).

  Lemma MapDomRestrBy_By :
   forall (m:Map A) (m' m'':Map B),
     eqmap (MapDomRestrBy A B (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B m (MapMerge B m' m'')).

  Lemma MapDomRestrBy_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrBy_To :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrBy B C m' m'')).

  Lemma MapDomRestrBy_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrTo_By :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrTo A C m (MapDomRestrBy C B m'' m')).

  Lemma MapDomRestrTo_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrTo A C m m'') m').

  Lemma MapDomRestrTo_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrTo A C m m'') m').

  Lemma MapMerge_DomRestrTo :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrTo A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrTo A B m m'') (MapDomRestrTo A B m' m'')).

  Lemma MapMerge_DomRestrBy :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrBy A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrBy A B m m'') (MapDomRestrBy A B m' m'')).

  Lemma MapDelta_empty_m_1 : forall m:Map A, MapDelta A (M0 A) m = m.

  Lemma MapDelta_empty_m : forall m:Map A, eqmap (MapDelta A (M0 A) m) m.

  Lemma MapDelta_m_empty_1 : forall m:Map A, MapDelta A m (M0 A) = m.

  Lemma MapDelta_m_empty : forall m:Map A, eqmap (MapDelta A m (M0 A)) m.

  Lemma MapDelta_nilpotent : forall m:Map A, eqmap (MapDelta A m m) (M0 A).

  Lemma MapDelta_as_Merge :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapMerge A (MapDomRestrBy A A m m') (MapDomRestrBy A A m' m)).

  Lemma MapDelta_as_DomRestrBy :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

  Lemma MapDelta_as_DomRestrBy_2 :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m' m)).

  Lemma MapDelta_sym :
   forall m m':Map A, eqmap (MapDelta A m m') (MapDelta A m' m).

  Lemma MapDelta_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m'2).

  Lemma MapDelta_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m2).

  Lemma MapDelta_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m1 m'2).

  Lemma MapDom_Split_1 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')).
 
  Lemma MapDom_Split_2 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrBy A B m m') (MapDomRestrTo A B m m')).

  Lemma MapDom_Split_3 :
   forall (m:Map A) (m':Map B),
     eqmap
       (MapDomRestrTo A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m'))
       (M0 A).

End MapAxioms.

Lemma MapDomRestrTo_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m'2).

Lemma MapDomRestrTo_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m2).

Lemma MapDomRestrTo_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m1 m'2).

Lemma MapDomRestrBy_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m'2).

Lemma MapDomRestrBy_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m2).

Lemma MapDomRestrBy_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m1 m'2).

Lemma MapDomRestrBy_m_m :
 forall (A:Type) (m:Map A),
   eqmap A (MapDomRestrBy A unit m (MapDom A m)) (M0 A).

Lemma FSetDelta_assoc :
 forall s s' s'':FSet,
   eqmap unit (MapDelta _ (MapDelta _ s s') s'')
     (MapDelta _ s (MapDelta _ s' s'')).

Lemma FSet_ext :
 forall s s':FSet,
   (forall a:ad, in_FSet a s = in_FSet a s') -> eqmap unit s s'.

Lemma FSetUnion_comm :
 forall s s':FSet, eqmap unit (FSetUnion s s') (FSetUnion s' s).

Lemma FSetUnion_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetUnion s s') s'')
     (FSetUnion s (FSetUnion s' s'')).

Lemma FSetUnion_M0_s : forall s:FSet, eqmap unit (FSetUnion (M0 unit) s) s.

Lemma FSetUnion_s_M0 : forall s:FSet, eqmap unit (FSetUnion s (M0 unit)) s.

Lemma FSetUnion_idempotent : forall s:FSet, eqmap unit (FSetUnion s s) s.

Lemma FSetInter_comm :
 forall s s':FSet, eqmap unit (FSetInter s s') (FSetInter s' s).

Lemma FSetInter_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetInter s s') s'')
     (FSetInter s (FSetInter s' s'')).

Lemma FSetInter_M0_s :
 forall s:FSet, eqmap unit (FSetInter (M0 unit) s) (M0 unit).

Lemma FSetInter_s_M0 :
 forall s:FSet, eqmap unit (FSetInter s (M0 unit)) (M0 unit).

Lemma FSetInter_idempotent : forall s:FSet, eqmap unit (FSetInter s s) s.

Lemma FSetUnion_Inter_l :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetInter s s') s'')
     (FSetInter (FSetUnion s s'') (FSetUnion s' s'')).

Lemma FSetUnion_Inter_r :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion s (FSetInter s' s''))
     (FSetInter (FSetUnion s s') (FSetUnion s s'')).

Lemma FSetInter_Union_l :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetUnion s s') s'')
     (FSetUnion (FSetInter s s'') (FSetInter s' s'')).

Lemma FSetInter_Union_r :
 forall s s' s'':FSet,
   eqmap unit (FSetInter s (FSetUnion s' s''))
     (FSetUnion (FSetInter s s') (FSetInter s s'')). *)

Require Import Mapiter.
(* Mapiter:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Mapaxioms.
Require Import Fset.
Require Import List.

Section MapIter.

  Variable A : Type.

  Section MapSweepDef.

  Variable f : ad -> A -> bool.

  Definition MapSweep2 (a0:ad) (y:A) :=
    if f a0 y then Some (a0, y) else None.

  Fixpoint MapSweep1 (pf:ad -> ad) (m:Map A) {struct m} : 
   option (ad * A) :=
    match m with
    | M0 => None
    | M1 a y => MapSweep2 (pf a) y
    | M2 m m' =>
        match MapSweep1 (fun a:ad => pf (Ndouble a)) m with
        | Some r => Some r
        | None => MapSweep1 (fun a:ad => pf (Ndouble_plus_one a)) m'
        end
    end.

  Definition MapSweep (m:Map A) := MapSweep1 (fun a:ad => a) m.

  Lemma MapSweep_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> f a y = true.

  Lemma MapSweep_semantics_1 :
   forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.

  Lemma MapSweep_semantics_2_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.

  Lemma MapSweep_semantics_2_2 :
   forall (m:Map A) (pf fp:ad -> ad),
     (forall a0:ad, fp (pf a0) = a0) ->
     forall (a:ad) (y:A),
       MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.

  Lemma MapSweep_semantics_2 :
   forall (m:Map A) (a:ad) (y:A),
     MapSweep m = Some (a, y) -> MapGet A m a = Some y.

  Lemma MapSweep_semantics_3_1 :
   forall (m:Map A) (pf:ad -> ad),
     MapSweep1 pf m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.

  Lemma MapSweep_semantics_3 :
   forall m:Map A,
     MapSweep m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.

  Lemma MapSweep_semantics_4_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f (pf a) y = true ->
     {a' : ad &  {y' : A | MapSweep1 pf m = Some (a', y')}}.

  Lemma MapSweep_semantics_4 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f a y = true -> {a' : ad &  {y' : A | MapSweep m = Some (a', y')}}.

  End MapSweepDef.

  Variable B : Type.

  Fixpoint MapCollect1 (f:ad -> A -> Map B) (pf:ad -> ad) 
   (m:Map A) {struct m} : Map B :=
    match m with
    | M0 => M0 B
    | M1 a y => f (pf a) y
    | M2 m1 m2 =>
        MapMerge B (MapCollect1 f (fun a0:ad => pf (Ndouble a0)) m1)
          (MapCollect1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
    end.

  Definition MapCollect (f:ad -> A -> Map B) (m:Map A) :=
    MapCollect1 f (fun a:ad => a) m.

  Section MapFoldDef.

    Variable M : Type.
    Variable neutral : M.
    Variable op : M -> M -> M.

    Fixpoint MapFold1 (f:ad -> A -> M) (pf:ad -> ad) 
     (m:Map A) {struct m} : M :=
      match m with
      | M0 => neutral
      | M1 a y => f (pf a) y
      | M2 m1 m2 =>
          op (MapFold1 f (fun a0:ad => pf (Ndouble a0)) m1)
            (MapFold1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
      end.

    Definition MapFold (f:ad -> A -> M) (m:Map A) :=
      MapFold1 f (fun a:ad => a) m.

    Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.

    Lemma MapFold_M1 :
     forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.

    Variable State : Type.
    Variable f : State -> ad -> A -> State * M.

    Fixpoint MapFold1_state (state:State) (pf:ad -> ad) 
     (m:Map A) {struct m} : State * M :=
      match m with
      | M0 => (state, neutral)
      | M1 a y => f state (pf a) y
      | M2 m1 m2 =>
          match MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m1 with
          | (state1, x1) =>
              match
                MapFold1_state state1
                  (fun a0:ad => pf (Ndouble_plus_one a0)) m2
              with
              | (state2, x2) => (state2, op x1 x2)
              end
          end
      end.

    Definition MapFold_state (state:State) :=
      MapFold1_state state (fun a:ad => a).

    Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).

    Lemma MapFold_state_stateless_1 :
     forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad),
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.

    Lemma MapFold_state_stateless :
     forall g:ad -> A -> M,
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall (state:State) (m:Map A),
         snd (MapFold_state state m) = MapFold g m.

  End MapFoldDef.

  Lemma MapCollect_as_Fold :
   forall (f:ad -> A -> Map B) (m:Map A),
     MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.

  Definition alist := list (ad * A).
  Definition anil := nil (A:=(ad * A)).
  Definition acons := cons (A:=(ad * A)).
  Definition aapp := app (A:=(ad * A)).

  Definition alist_of_Map :=
    MapFold alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil).

  Fixpoint alist_semantics (l:alist) : ad -> option A :=
    match l with
    | nil => fun _:ad => None
    | (a, y) :: l' =>
        fun a0:ad => if Neqb a a0 then Some y else alist_semantics l' a0
    end.

  Lemma alist_semantics_app :
   forall (l l':alist) (a:ad),
     alist_semantics (aapp l l') a =
     match alist_semantics l a with
     | None => alist_semantics l' a
     | Some y => Some y
     end.

  Lemma alist_of_Map_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     alist_semantics
       (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf
          m) a = Some y -> {a' : ad | a = pf a'}.

  Definition ad_inj (pf:ad -> ad) :=
    forall a0 a1:ad, pf a0 = pf a1 -> a0 = a1.

  Lemma ad_comp_double_inj :
   forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).

  Lemma ad_comp_double_plus_un_inj :
   forall pf:ad -> ad,
     ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).

  Lemma alist_of_Map_semantics_1 :
   forall (m:Map A) (pf:ad -> ad),
     ad_inj pf ->
     forall a:ad,
       MapGet A m a =
       alist_semantics
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            pf m) (pf a).

  Lemma alist_of_Map_semantics :
   forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).

  Fixpoint Map_of_alist (l:alist) : Map A :=
    match l with
    | nil => M0 A
    | (a, y) :: l' => MapPut A (Map_of_alist l') a y
    end.

  Lemma Map_of_alist_semantics :
   forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).

  Lemma Map_of_alist_of_Map :
   forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.

  Lemma alist_of_Map_of_alist :
   forall l:alist,
     eqm A (alist_semantics (alist_of_Map (Map_of_alist l)))
       (alist_semantics l).

  Lemma fold_right_aapp :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     forall (f:ad -> A -> M) (l l':alist),
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (aapp l l') =
       op
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l)
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l').

  Lemma MapFold_as_fold_1 :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad),
       MapFold1 M neutral op f pf m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral
         (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf
            m).

  Lemma MapFold_as_fold :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A),
       MapFold M neutral op f m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (alist_of_Map m).

  Lemma alist_MapMerge_semantics :
   forall m m':Map A,
     eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).

  Lemma alist_MapMerge_semantics_disjoint :
   forall m m':Map A,
     eqmap A (MapDomRestrTo A A m m') (M0 A) ->
     eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).

  Lemma alist_semantics_disjoint_comm :
   forall l l':alist,
     eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) ->
     eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).

End MapIter. *)



Section MapSubsetDef.



  Variables A B : Type.



  Definition MapSubset (m:Map A) (m':Map B) :=

    forall a:ad, in_dom A a m = true -> in_dom B a m' = true.



  Definition MapSubset_1 (m:Map A) (m':Map B) :=

    match MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m with

    | None => true

    | _ => false

    end.



  Definition MapSubset_2 (m:Map A) (m':Map B) :=

    eqmap A (MapDomRestrBy A B m m') (M0 A).



  Lemma MapSubset_imp_1 :

   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.

  Proof.

    unfold MapSubset, MapSubset_1 in |- *. intros.

    elim

     (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)).

    intro H0. elim H0. intro r. elim r. intros a y H1. cut (negb (in_dom B a m') = true).

    intro. cut (in_dom A a m = false). intro. unfold in_dom in H3.

    rewrite (MapSweep_semantics_2 _ _ m a y H1) in H3. discriminate H3.

    elim (sumbool_of_bool (in_dom A a m)). intro H3. rewrite (H a H3) in H2. discriminate H2.

    trivial.

    exact (MapSweep_semantics_1 _ _ m a y H1).

    intro H0. rewrite H0. reflexivity.

  Qed.



  Lemma MapSubset_1_imp :

   forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.

  Proof.

    unfold MapSubset, MapSubset_1 in |- *. unfold in_dom at 2 in |- *. intros. elim (option_sum _ (MapGet A m a)).

    intro H1. elim H1. intros y H2.

    elim

     (option_sum _ (MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m)). intro H3.

    elim H3. intro r. elim r. intros a' y' H4. rewrite H4 in H. discriminate H.

    intro H3. cut (negb (in_dom B a m') = false). intro. rewrite (negb_intro (in_dom B a m')).

    rewrite H4. reflexivity.

    exact (MapSweep_semantics_3 _ _ m H3 a y H2).

    intro H1. rewrite H1 in H0. discriminate H0.

  Qed.



  Lemma map_dom_empty_1 :

   forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.

  Proof.

    unfold eqmap, eqm, in_dom in |- *. intros. rewrite (H a). reflexivity.

  Qed.



  Lemma map_dom_empty_2 :

   forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).

  Proof.

    unfold eqmap, eqm, in_dom in |- *. intros.

    cut

     (match MapGet A m a with

      | None => false

      | Some _ => true

      end = false).

    case (MapGet A m a); trivial.

    intros. discriminate H0.

    exact (H a).

  Qed.



  Lemma MapSubset_imp_2 :

   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.

  Proof.

    unfold MapSubset, MapSubset_2 in |- *. intros. apply map_dom_empty_2. intro. rewrite in_dom_restrby.

    elim (sumbool_of_bool (in_dom A a m)). intro H0. rewrite H0. rewrite (H a H0). reflexivity.

    intro H0. rewrite H0. reflexivity.

  Qed.



  Lemma MapSubset_2_imp :

   forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.

  Proof.

    unfold MapSubset, MapSubset_2 in |- *. intros. cut (in_dom _ a (MapDomRestrBy A B m m') = false).

    rewrite in_dom_restrby. intro. elim (andb_false_elim _ _ H1). rewrite H0.

    intro H2. discriminate H2.

    intro H2. rewrite (negb_intro (in_dom B a m')). rewrite H2. reflexivity.

    exact (map_dom_empty_1 _ H a).

  Qed.



End MapSubsetDef.



Section MapSubsetOrder.



  Variables A B C : Type.



  Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.

  Proof.

      unfold MapSubset in |- *. trivial.

  Qed.



  Lemma MapSubset_antisym :

   forall (m:Map A) (m':Map B),

     MapSubset A B m m' ->

     MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').

  Proof.

    unfold MapSubset, eqmap, eqm in |- *. intros. elim (option_sum _ (MapGet _ (MapDom A m) a)).

    intro H1. elim H1. intro t. elim t. intro H2. elim (option_sum _ (MapGet _ (MapDom B m') a)).

    intro H3. elim H3. intro t'. elim t'. intro H4. rewrite H4. exact H2. 

    intro H3. cut (in_dom B a m' = true). intro. rewrite (MapDom_Dom B m' a) in H4.

    unfold in_FSet, in_dom in H4. rewrite H3 in H4. discriminate H4.

    apply H. rewrite (MapDom_Dom A m a). unfold in_FSet, in_dom in |- *. rewrite H2. reflexivity.

    intro H1. elim (option_sum _ (MapGet _ (MapDom B m') a)). intro H2. elim H2. intros t H3.

    cut (in_dom A a m = true). intro. rewrite (MapDom_Dom A m a) in H4. unfold in_FSet, in_dom in H4.

    rewrite H1 in H4. discriminate H4.

    apply H0. rewrite (MapDom_Dom B m' a). unfold in_FSet, in_dom in |- *. rewrite H3. reflexivity.

    intro H2. rewrite H2. exact H1.

  Qed.



  Lemma MapSubset_trans :

   forall (m:Map A) (m':Map B) (m'':Map C),

     MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.

  Proof.

    unfold MapSubset in |- *. intros. apply H0. apply H. assumption.

  Qed.



End MapSubsetOrder.



Section FSubsetOrder.



  Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.

  Proof.

    exact (MapSubset_refl unit).

  Qed.



  Lemma FSubset_antisym :

   forall s s':FSet,

     MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.

  Proof.

    intros. rewrite <- (FSet_Dom s). rewrite <- (FSet_Dom s').

    exact (MapSubset_antisym _ _ s s' H H0).

  Qed.



  Lemma FSubset_trans :

   forall s s' s'':FSet,

     MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.

  Proof.

    exact (MapSubset_trans unit unit unit).

  Qed.



End FSubsetOrder.



Section MapSubsetExtra.



  Variables A B : Type.



  Lemma MapSubset_Dom_1 :

   forall (m:Map A) (m':Map B),

     MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').

  Proof.

    unfold MapSubset in |- *. intros. elim (MapDom_semantics_2 _ m a H0). intros y H1.

    cut (in_dom A a m = true -> in_dom B a m' = true). intro. unfold in_dom in H2.

    rewrite H1 in H2. elim (option_sum _ (MapGet B m' a)). intro H3. elim H3.

    intros y' H4. exact (MapDom_semantics_1 _ m' a y' H4).

    intro H3. rewrite H3 in H2. cut (false = true). intro. discriminate H4.

    apply H2. reflexivity.

    exact (H a).

  Qed.



  Lemma MapSubset_Dom_2 :

   forall (m:Map A) (m':Map B),

     MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.

  Proof.

    unfold MapSubset in |- *. intros. unfold in_dom in H0. elim (option_sum _ (MapGet A m a)).

    intro H1. elim H1. intros y H2.

    elim (MapDom_semantics_2 _ _ _ (H a (MapDom_semantics_1 _ _ _ _ H2))). intros y' H3.

    unfold in_dom in |- *. rewrite H3. reflexivity.

    intro H1. rewrite H1 in H0. discriminate H0.

  Qed.



  Lemma MapSubset_1_Dom :

   forall (m:Map A) (m':Map B),

     MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').

  Proof.

    intros. elim (sumbool_of_bool (MapSubset_1 A B m m')). intro H. rewrite H.

    apply sym_eq. apply MapSubset_imp_1. apply MapSubset_Dom_1. exact (MapSubset_1_imp _ _ _ _ H).

    intro H. rewrite H. elim (sumbool_of_bool (MapSubset_1 unit unit (MapDom A m) (MapDom B m'))).

    intro H0.

    rewrite

     (MapSubset_imp_1 _ _ _ _

        (MapSubset_Dom_2 _ _ (MapSubset_1_imp _ _ _ _ H0)))

      in H.

    discriminate H.

    intro. apply sym_eq. assumption.

  Qed.



  Lemma MapSubset_Put :

   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_put. rewrite H. apply orb_b_true.

  Qed.



  Lemma MapSubset_Put_mono :

   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),

     MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_put. rewrite (in_dom_put A m a y a0) in H0.

    elim (orb_true_elim _ _ H0). intro H1. rewrite H1. reflexivity.

    intro H1. rewrite (H _ H1). apply orb_b_true.

  Qed.



  Lemma MapSubset_Put_behind :

   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_put_behind. rewrite H. apply orb_b_true.

  Qed.



  Lemma MapSubset_Put_behind_mono :

   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),

     MapSubset A B m m' ->

     MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_put_behind.

    rewrite (in_dom_put_behind A m a y a0) in H0.

    elim (orb_true_elim _ _ H0). intro H1. rewrite H1. reflexivity.

    intro H1. rewrite (H _ H1). apply orb_b_true.

  Qed.



  Lemma MapSubset_Remove :

   forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.

  Proof.

    unfold MapSubset in |- *. intros. unfold MapSubset in |- *. intros. rewrite (in_dom_remove _ m a a0) in H.

    elim (andb_prop _ _ H). trivial.

  Qed.



  Lemma MapSubset_Remove_mono :

   forall (m:Map A) (m':Map B) (a:ad),

     MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_remove. rewrite (in_dom_remove A m a a0) in H0.

    elim (andb_prop _ _ H0). intros. rewrite H1. rewrite (H _ H2). reflexivity.

  Qed.



  Lemma MapSubset_Merge_l :

   forall m m':Map A, MapSubset A A m (MapMerge A m m').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_merge. rewrite H. reflexivity.

  Qed.



  Lemma MapSubset_Merge_r :

   forall m m':Map A, MapSubset A A m' (MapMerge A m m').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_merge. rewrite H. apply orb_b_true.

  Qed.



  Lemma MapSubset_Merge_mono :

   forall (m m':Map A) (m'' m''':Map B),

     MapSubset A B m m'' ->

     MapSubset A B m' m''' ->

     MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_merge. rewrite (in_dom_merge A m m' a) in H1.

    elim (orb_true_elim _ _ H1). intro H2. rewrite (H _ H2). reflexivity.

    intro H2. rewrite (H0 _ H2). apply orb_b_true.

  Qed.



  Lemma MapSubset_DomRestrTo_l :

   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.

  Proof.

    unfold MapSubset in |- *. intros. rewrite (in_dom_restrto _ _ m m' a) in H. elim (andb_prop _ _ H).

    trivial.

  Qed.



  Lemma MapSubset_DomRestrTo_r :

   forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.

  Proof.

    unfold MapSubset in |- *. intros. rewrite (in_dom_restrto _ _ m m' a) in H. elim (andb_prop _ _ H).

    trivial.

  Qed.



  Lemma MapSubset_ext :

   forall (m0 m1:Map A) (m2 m3:Map B),

     eqmap A m0 m1 ->

     eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.

  Proof.

    intros. apply MapSubset_2_imp. unfold MapSubset_2 in |- *.

    apply eqmap_trans with (m' := MapDomRestrBy A B m0 m2). apply MapDomRestrBy_ext. apply eqmap_sym.

    assumption.

    apply eqmap_sym. assumption.

    exact (MapSubset_imp_2 _ _ _ _ H1).

  Qed.



  Variables C D : Type.



  Lemma MapSubset_DomRestrTo_mono :

   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),

     MapSubset _ _ m m'' ->

     MapSubset _ _ m' m''' ->

     MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_restrto. rewrite (in_dom_restrto A B m m' a) in H1.

    elim (andb_prop _ _ H1). intros. rewrite (H _ H2). rewrite (H0 _ H3). reflexivity.

  Qed.



  Lemma MapSubset_DomRestrBy_l :

   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.

  Proof.

    unfold MapSubset in |- *. intros. rewrite (in_dom_restrby _ _ m m' a) in H. elim (andb_prop _ _ H).

    trivial.

  Qed.



  Lemma MapSubset_DomRestrBy_mono :

   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),

     MapSubset _ _ m m'' ->

     MapSubset _ _ m''' m' ->

     MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').

  Proof.

    unfold MapSubset in |- *. intros. rewrite in_dom_restrby. rewrite (in_dom_restrby A B m m' a) in H1.

    elim (andb_prop _ _ H1). intros. rewrite (H _ H2). elim (sumbool_of_bool (in_dom D a m''')).

    intro H4. rewrite (H0 _ H4) in H3. discriminate H3.

    intro H4. rewrite H4. reflexivity.

  Qed.

  

End MapSubsetExtra.



Section MapDisjointDef.



  Variables A B : Type.



  Definition MapDisjoint (m:Map A) (m':Map B) :=

    forall a:ad, in_dom A a m = true -> in_dom B a m' = true -> False.



  Definition MapDisjoint_1 (m:Map A) (m':Map B) :=

    match MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m with

    | None => true

    | _ => false

    end.



  Definition MapDisjoint_2 (m:Map A) (m':Map B) :=

    eqmap A (MapDomRestrTo A B m m') (M0 A).



  Lemma MapDisjoint_imp_1 :

   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.

  Proof.

    unfold MapDisjoint, MapDisjoint_1 in |- *. intros.

    elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)). intro H0. elim H0.

    intro r. elim r. intros a y H1. cut (in_dom A a m = true -> in_dom B a m' = true -> False).

    intro. unfold in_dom at 1 in H2. rewrite (MapSweep_semantics_2 _ _ _ _ _ H1) in H2.

    rewrite (MapSweep_semantics_1 _ _ _ _ _ H1) in H2. elim (H2 (refl_equal _) (refl_equal _)).

    exact (H a).

    intro H0. rewrite H0. reflexivity.

  Qed.



  Lemma MapDisjoint_1_imp :

   forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.

  Proof.

    unfold MapDisjoint, MapDisjoint_1 in |- *. intros.

    elim (option_sum _ (MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m)). intro H2. elim H2.

    intro r. elim r. intros a' y' H3. rewrite H3 in H. discriminate H.

    intro H2. unfold in_dom in H0. elim (option_sum _ (MapGet A m a)). intro H3. elim H3.

    intros y H4. rewrite (MapSweep_semantics_3 _ _ _ H2 a y H4) in H1. discriminate H1.

    intro H3. rewrite H3 in H0. discriminate H0.

  Qed.



  Lemma MapDisjoint_imp_2 :

   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.

  Proof.

    unfold MapDisjoint, MapDisjoint_2 in |- *. unfold eqmap, eqm in |- *. intros.

    rewrite (MapDomRestrTo_semantics A B m m' a).

    cut (in_dom A a m = true -> in_dom B a m' = true -> False). intro.

    elim (option_sum _ (MapGet A m a)). intro H1. elim H1. intros y H2. unfold in_dom at 1 in H0.

    elim (option_sum _ (MapGet B m' a)). intro H3. elim H3. intros y' H4. unfold in_dom at 1 in H0.

    rewrite H4 in H0. rewrite H2 in H0. elim (H0 (refl_equal _) (refl_equal _)).

    intro H3. rewrite H3. reflexivity.

    intro H1. rewrite H1. case (MapGet B m' a); reflexivity.

    exact (H a).

  Qed.



  Lemma MapDisjoint_2_imp :

   forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.

  Proof.

    unfold MapDisjoint, MapDisjoint_2 in |- *. unfold eqmap, eqm in |- *. intros. elim (in_dom_some _ _ _ H0).

    intros y H2. elim (in_dom_some _ _ _ H1). intros y' H3.

    cut (MapGet A (MapDomRestrTo A B m m') a = None). intro.

    rewrite (MapDomRestrTo_semantics _ _ m m' a) in H4. rewrite H3 in H4. rewrite H2 in H4.

    discriminate H4.

    exact (H a).

  Qed.



  Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.

  Proof.

    unfold MapDisjoint, in_dom in |- *. intros. discriminate H.

  Qed.



  Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).

  Proof.

    unfold MapDisjoint, in_dom in |- *. intros. discriminate H0.

  Qed.



End MapDisjointDef.



Section MapDisjointExtra.



  Variables A B : Type.



  Lemma MapDisjoint_ext :

   forall (m0 m1:Map A) (m2 m3:Map B),

     eqmap A m0 m1 ->

     eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.

  Proof.

    intros. apply MapDisjoint_2_imp. unfold MapDisjoint_2 in |- *.

    apply eqmap_trans with (m' := MapDomRestrTo A B m0 m2). apply eqmap_sym. apply MapDomRestrTo_ext.

    assumption.

    assumption.

    exact (MapDisjoint_imp_2 _ _ _ _ H1).

  Qed.



  Lemma MapMerge_disjoint :

   forall m m':Map A,

     MapDisjoint A A m m' ->

     forall a:ad,

       in_dom A a (MapMerge A m m') =

       orb (andb (in_dom A a m) (negb (in_dom A a m')))

         (andb (in_dom A a m') (negb (in_dom A a m))).

  Proof.

    unfold MapDisjoint in |- *. intros. rewrite in_dom_merge. elim (sumbool_of_bool (in_dom A a m)).

    intro H0. rewrite H0. elim (sumbool_of_bool (in_dom A a m')). intro H1. elim (H a H0 H1).

    intro H1. rewrite H1. reflexivity.

    intro H0. rewrite H0. simpl in |- *. rewrite andb_b_true. reflexivity.

  Qed.



  Lemma MapDisjoint_M2_l :

   forall (m0 m1:Map A) (m2 m3:Map B),

     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.

  Proof.

    unfold MapDisjoint, in_dom in |- *. intros. elim (option_sum _ (MapGet A m0 a)). intro H2.

    elim H2. intros y H3. elim (option_sum _ (MapGet B m2 a)). intro H4. elim H4.

    intros y' H5. apply (H (Ndouble a)).

    rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m0 m1).

    rewrite (Ndouble_div2 a). rewrite H3. reflexivity.

    rewrite (MapGet_M2_bit_0_0 _ (Ndouble a) (Ndouble_bit0 a) m2 m3).

    rewrite (Ndouble_div2 a). rewrite H5. reflexivity.

    intro H4. rewrite H4 in H1. discriminate H1.

    intro H2. rewrite H2 in H0. discriminate H0.

  Qed.



  Lemma MapDisjoint_M2_r :

   forall (m0 m1:Map A) (m2 m3:Map B),

     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.

  Proof.

    unfold MapDisjoint, in_dom in |- *. intros. elim (option_sum _ (MapGet A m1 a)). intro H2.

    elim H2. intros y H3. elim (option_sum _ (MapGet B m3 a)). intro H4. elim H4.

    intros y' H5. apply (H (Ndouble_plus_one a)).

    rewrite

     (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a)

        m0 m1).

    rewrite (Ndouble_plus_one_div2 a). rewrite H3. reflexivity.

    rewrite

     (MapGet_M2_bit_0_1 _ (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a)

        m2 m3).

    rewrite (Ndouble_plus_one_div2 a). rewrite H5. reflexivity.

    intro H4. rewrite H4 in H1. discriminate H1.

    intro H2. rewrite H2 in H0. discriminate H0.

  Qed.



  Lemma MapDisjoint_M2 :

   forall (m0 m1:Map A) (m2 m3:Map B),

     MapDisjoint A B m0 m2 ->

     MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).

  Proof.

    unfold MapDisjoint, in_dom in |- *. intros. elim (sumbool_of_bool (Nbit0 a)). intro H3.

    rewrite (MapGet_M2_bit_0_1 A a H3 m0 m1) in H1.

    rewrite (MapGet_M2_bit_0_1 B a H3 m2 m3) in H2. exact (H0 (Ndiv2 a) H1 H2).

    intro H3. rewrite (MapGet_M2_bit_0_0 A a H3 m0 m1) in H1.

    rewrite (MapGet_M2_bit_0_0 B a H3 m2 m3) in H2. exact (H (Ndiv2 a) H1 H2).

  Qed.



  Lemma MapDisjoint_M1_l :

   forall (m:Map A) (a:ad) (y:B),

     MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.

  Proof.

    unfold MapDisjoint in |- *. intros. elim (sumbool_of_bool (in_dom A a m)). intro H0.

    elim (H a (in_dom_M1_1 B a y) H0).

    trivial.

  Qed.



  Lemma MapDisjoint_M1_r :

   forall (m:Map A) (a:ad) (y:B),

     MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.

  Proof.

    unfold MapDisjoint in |- *. intros. elim (sumbool_of_bool (in_dom A a m)). intro H0.

    elim (H a H0 (in_dom_M1_1 B a y)).

    trivial.

  Qed.



  Lemma MapDisjoint_M1_conv_l :

   forall (m:Map A) (a:ad) (y:B),

     in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.

  Proof.

    unfold MapDisjoint in |- *. intros. rewrite (in_dom_M1_2 B a a0 y H0) in H. rewrite H1 in H.

    discriminate H.

  Qed.



  Lemma MapDisjoint_M1_conv_r :

   forall (m:Map A) (a:ad) (y:B),

     in_dom A a m = false -> MapDisjoint A B m (M1 B a y).

  Proof.

    unfold MapDisjoint in |- *. intros. rewrite (in_dom_M1_2 B a a0 y H1) in H. rewrite H0 in H.

    discriminate H.

  Qed.

 

  Lemma MapDisjoint_sym :

   forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.

  Proof.

    unfold MapDisjoint in |- *. intros. exact (H _ H1 H0).

  Qed.



  Lemma MapDisjoint_empty :

   forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).

  Proof.

    unfold eqmap, eqm in |- *. intros. rewrite <- (MapDomRestrTo_idempotent A m a).

    exact (MapDisjoint_imp_2 A A m m H a).

  Qed.



  Lemma MapDelta_disjoint :

   forall m m':Map A,

     MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').

  Proof.

    intros.

    apply eqmap_trans with

     (m' := MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

    apply MapDelta_as_DomRestrBy.

    apply eqmap_trans with (m' := MapDomRestrBy A A (MapMerge A m m') (M0 A)).

    apply MapDomRestrBy_ext. apply eqmap_refl.

    exact (MapDisjoint_imp_2 A A m m' H).

    apply MapDomRestrBy_m_empty.

  Qed.



  Variable C : Type.



  Lemma MapDomRestr_disjoint :

   forall (m:Map A) (m':Map B) (m'':Map C),

     MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').

  Proof.

    unfold MapDisjoint in |- *. intros m m' m'' a. rewrite in_dom_restrto. rewrite in_dom_restrby.

    intros. elim (andb_prop _ _ H). elim (andb_prop _ _ H0). intros. rewrite H4 in H2.

    discriminate H2.

  Qed.



  Lemma MapDelta_RestrTo_disjoint :

   forall m m':Map A,

     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').

  Proof.

    unfold MapDisjoint in |- *. intros m m' a. rewrite in_dom_delta. rewrite in_dom_restrto.

    intros. elim (andb_prop _ _ H0). intros. rewrite H1 in H. rewrite H2 in H. discriminate H.

  Qed.



  Lemma MapDelta_RestrTo_disjoint_2 :

   forall m m':Map A,

     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).

  Proof.

    unfold MapDisjoint in |- *. intros m m' a. rewrite in_dom_delta. rewrite in_dom_restrto.

    intros. elim (andb_prop _ _ H0). intros. rewrite H1 in H. rewrite H2 in H. discriminate H.

  Qed.



  Variable D : Type.



  Lemma MapSubset_Disjoint :

   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),

     MapSubset _ _ m m' ->

     MapSubset _ _ m'' m''' ->

     MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.

  Proof.

    unfold MapSubset, MapDisjoint in |- *. intros. exact (H1 _ (H _ H2) (H0 _ H3)).

  Qed.



  Lemma MapSubset_Disjoint_l :

   forall (m:Map A) (m':Map B) (m'':Map C),

     MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.

  Proof.

    unfold MapSubset, MapDisjoint in |- *. intros. exact (H0 _ (H _ H1) H2).

  Qed.



  Lemma MapSubset_Disjoint_r :

   forall (m:Map A) (m'':Map C) (m''':Map D),

     MapSubset _ _ m'' m''' ->

     MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.

  Proof.

    unfold MapSubset, MapDisjoint in |- *. intros. exact (H0 _ H1 (H _ H2)).

  Qed.



End MapDisjointExtra.
