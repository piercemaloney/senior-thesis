

Require Import Bool.

Require Import Sumbool.

Require Import Arith.

Require Import NArith.

Require Import Ndigits.

Require Import Ndec.

Require Import Map.

Require Import Mapaxioms.
(* Mapaxioms:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.

Section MapAxioms.

  Variables A B C : Type.

  Lemma eqm_sym : forall f f':ad -> option A, eqm A f f' -> eqm A f' f.

  Lemma eqm_refl : forall f:ad -> option A, eqm A f f.

  Lemma eqm_trans :
   forall f f' f'':ad -> option A, eqm A f f' -> eqm A f' f'' -> eqm A f f''.

  Definition eqmap (m m':Map A) := eqm A (MapGet A m) (MapGet A m').

  Lemma eqmap_sym : forall m m':Map A, eqmap m m' -> eqmap m' m.

  Lemma eqmap_refl : forall m:Map A, eqmap m m.

  Lemma eqmap_trans :
   forall m m' m'':Map A, eqmap m m' -> eqmap m' m'' -> eqmap m m''.

  Lemma MapPut_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut A m a y) (MapMerge A m (M1 A a y)).

  Lemma MapPut_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A), eqmap (MapPut A m a y) (MapPut A m' a y).

  Lemma MapPut_behind_as_Merge :
   forall (m:Map A) (a:ad) (y:A),
     eqmap (MapPut_behind A m a y) (MapMerge A (M1 A a y) m).

  Lemma MapPut_behind_ext :
   forall m m':Map A,
     eqmap m m' ->
     forall (a:ad) (y:A),
       eqmap (MapPut_behind A m a y) (MapPut_behind A m' a y).

  Lemma MapMerge_empty_m_1 : forall m:Map A, MapMerge A (M0 A) m = m.

  Lemma MapMerge_empty_m : forall m:Map A, eqmap (MapMerge A (M0 A) m) m.

  Lemma MapMerge_m_empty_1 : forall m:Map A, MapMerge A m (M0 A) = m.

  Lemma MapMerge_m_empty : forall m:Map A, eqmap (MapMerge A m (M0 A)) m.

  Lemma MapMerge_empty_l :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m (M0 A).

  Lemma MapMerge_empty_r :
   forall m m':Map A, eqmap (MapMerge A m m') (M0 A) -> eqmap m' (M0 A).

  Lemma MapMerge_assoc :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapMerge A m m') m'')
       (MapMerge A m (MapMerge A m' m'')).

  Lemma MapMerge_idempotent : forall m:Map A, eqmap (MapMerge A m m) m.

  Lemma MapMerge_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m'2).

  Lemma MapMerge_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapMerge A m1 m2) (MapMerge A m'1 m2).

  Lemma MapMerge_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapMerge A m1 m2) (MapMerge A m1 m'2).

  Lemma MapMerge_RestrTo_l :
   forall m m' m'':Map A,
     eqmap (MapMerge A (MapDomRestrTo A A m m') m'')
       (MapDomRestrTo A A (MapMerge A m m'') (MapMerge A m' m'')).

  Lemma MapRemove_as_RestrBy :
   forall (m:Map A) (a:ad) (y:B),
     eqmap (MapRemove A m a) (MapDomRestrBy A B m (M1 B a y)).

  Lemma MapRemove_ext :
   forall m m':Map A,
     eqmap m m' -> forall a:ad, eqmap (MapRemove A m a) (MapRemove A m' a).

  Lemma MapDomRestrTo_empty_m_1 :
   forall m:Map B, MapDomRestrTo A B (M0 A) m = M0 A.

  Lemma MapDomRestrTo_empty_m :
   forall m:Map B, eqmap (MapDomRestrTo A B (M0 A) m) (M0 A).

  Lemma MapDomRestrTo_m_empty_1 :
   forall m:Map A, MapDomRestrTo A B m (M0 B) = M0 A.

  Lemma MapDomRestrTo_m_empty :
   forall m:Map A, eqmap (MapDomRestrTo A B m (M0 B)) (M0 A).

  Lemma MapDomRestrTo_assoc :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrTo B C m' m'')).

  Lemma MapDomRestrTo_idempotent :
   forall m:Map A, eqmap (MapDomRestrTo A A m m) m.

  Lemma MapDomRestrTo_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrTo A B m m') (MapDomRestrTo A unit m (MapDom B m')).

  Lemma MapDomRestrBy_empty_m_1 :
   forall m:Map B, MapDomRestrBy A B (M0 A) m = M0 A.

  Lemma MapDomRestrBy_empty_m :
   forall m:Map B, eqmap (MapDomRestrBy A B (M0 A) m) (M0 A).

  Lemma MapDomRestrBy_m_empty_1 :
   forall m:Map A, MapDomRestrBy A B m (M0 B) = m.

  Lemma MapDomRestrBy_m_empty :
   forall m:Map A, eqmap (MapDomRestrBy A B m (M0 B)) m.

  Lemma MapDomRestrBy_Dom :
   forall (m:Map A) (m':Map B),
     eqmap (MapDomRestrBy A B m m') (MapDomRestrBy A unit m (MapDom B m')).

  Lemma MapDomRestrBy_m_m_1 :
   forall m:Map A, eqmap (MapDomRestrBy A A m m) (M0 A).

  Lemma MapDomRestrBy_By :
   forall (m:Map A) (m' m'':Map B),
     eqmap (MapDomRestrBy A B (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B m (MapMerge B m' m'')).

  Lemma MapDomRestrBy_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrBy_To :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B m (MapDomRestrBy B C m' m'')).

  Lemma MapDomRestrBy_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrBy A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrBy A C m m'') m').

  Lemma MapDomRestrTo_By :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrTo A C m (MapDomRestrBy C B m'' m')).

  Lemma MapDomRestrTo_By_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrBy A B m m') m'')
       (MapDomRestrBy A B (MapDomRestrTo A C m m'') m').

  Lemma MapDomRestrTo_To_comm :
   forall (m:Map A) (m':Map B) (m'':Map C),
     eqmap (MapDomRestrTo A C (MapDomRestrTo A B m m') m'')
       (MapDomRestrTo A B (MapDomRestrTo A C m m'') m').

  Lemma MapMerge_DomRestrTo :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrTo A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrTo A B m m'') (MapDomRestrTo A B m' m'')).

  Lemma MapMerge_DomRestrBy :
   forall (m m':Map A) (m'':Map B),
     eqmap (MapDomRestrBy A B (MapMerge A m m') m'')
       (MapMerge A (MapDomRestrBy A B m m'') (MapDomRestrBy A B m' m'')).

  Lemma MapDelta_empty_m_1 : forall m:Map A, MapDelta A (M0 A) m = m.

  Lemma MapDelta_empty_m : forall m:Map A, eqmap (MapDelta A (M0 A) m) m.

  Lemma MapDelta_m_empty_1 : forall m:Map A, MapDelta A m (M0 A) = m.

  Lemma MapDelta_m_empty : forall m:Map A, eqmap (MapDelta A m (M0 A)) m.

  Lemma MapDelta_nilpotent : forall m:Map A, eqmap (MapDelta A m m) (M0 A).

  Lemma MapDelta_as_Merge :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapMerge A (MapDomRestrBy A A m m') (MapDomRestrBy A A m' m)).

  Lemma MapDelta_as_DomRestrBy :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m m')).

  Lemma MapDelta_as_DomRestrBy_2 :
   forall m m':Map A,
     eqmap (MapDelta A m m')
       (MapDomRestrBy A A (MapMerge A m m') (MapDomRestrTo A A m' m)).

  Lemma MapDelta_sym :
   forall m m':Map A, eqmap (MapDelta A m m') (MapDelta A m' m).

  Lemma MapDelta_ext :
   forall m1 m2 m'1 m'2:Map A,
     eqmap m1 m'1 ->
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m'2).

  Lemma MapDelta_ext_l :
   forall m1 m'1 m2:Map A,
     eqmap m1 m'1 -> eqmap (MapDelta A m1 m2) (MapDelta A m'1 m2).

  Lemma MapDelta_ext_r :
   forall m1 m2 m'2:Map A,
     eqmap m2 m'2 -> eqmap (MapDelta A m1 m2) (MapDelta A m1 m'2).

  Lemma MapDom_Split_1 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m')).
 
  Lemma MapDom_Split_2 :
   forall (m:Map A) (m':Map B),
     eqmap m (MapMerge A (MapDomRestrBy A B m m') (MapDomRestrTo A B m m')).

  Lemma MapDom_Split_3 :
   forall (m:Map A) (m':Map B),
     eqmap
       (MapDomRestrTo A A (MapDomRestrTo A B m m') (MapDomRestrBy A B m m'))
       (M0 A).

End MapAxioms.

Lemma MapDomRestrTo_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m'2).

Lemma MapDomRestrTo_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m'1 m2).

Lemma MapDomRestrTo_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrTo A B m1 m2) (MapDomRestrTo A B m1 m'2).

Lemma MapDomRestrBy_ext :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A) 
   (m'2:Map B),
   eqmap A m1 m'1 ->
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m'2).

Lemma MapDomRestrBy_ext_l :
 forall (A B:Type) (m1:Map A) (m2:Map B) (m'1:Map A),
   eqmap A m1 m'1 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m'1 m2).

Lemma MapDomRestrBy_ext_r :
 forall (A B:Type) (m1:Map A) (m2 m'2:Map B),
   eqmap B m2 m'2 ->
   eqmap A (MapDomRestrBy A B m1 m2) (MapDomRestrBy A B m1 m'2).

Lemma MapDomRestrBy_m_m :
 forall (A:Type) (m:Map A),
   eqmap A (MapDomRestrBy A unit m (MapDom A m)) (M0 A).

Lemma FSetDelta_assoc :
 forall s s' s'':FSet,
   eqmap unit (MapDelta _ (MapDelta _ s s') s'')
     (MapDelta _ s (MapDelta _ s' s'')).

Lemma FSet_ext :
 forall s s':FSet,
   (forall a:ad, in_FSet a s = in_FSet a s') -> eqmap unit s s'.

Lemma FSetUnion_comm :
 forall s s':FSet, eqmap unit (FSetUnion s s') (FSetUnion s' s).

Lemma FSetUnion_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetUnion s s') s'')
     (FSetUnion s (FSetUnion s' s'')).

Lemma FSetUnion_M0_s : forall s:FSet, eqmap unit (FSetUnion (M0 unit) s) s.

Lemma FSetUnion_s_M0 : forall s:FSet, eqmap unit (FSetUnion s (M0 unit)) s.

Lemma FSetUnion_idempotent : forall s:FSet, eqmap unit (FSetUnion s s) s.

Lemma FSetInter_comm :
 forall s s':FSet, eqmap unit (FSetInter s s') (FSetInter s' s).

Lemma FSetInter_assoc :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetInter s s') s'')
     (FSetInter s (FSetInter s' s'')).

Lemma FSetInter_M0_s :
 forall s:FSet, eqmap unit (FSetInter (M0 unit) s) (M0 unit).

Lemma FSetInter_s_M0 :
 forall s:FSet, eqmap unit (FSetInter s (M0 unit)) (M0 unit).

Lemma FSetInter_idempotent : forall s:FSet, eqmap unit (FSetInter s s) s.

Lemma FSetUnion_Inter_l :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion (FSetInter s s') s'')
     (FSetInter (FSetUnion s s'') (FSetUnion s' s'')).

Lemma FSetUnion_Inter_r :
 forall s s' s'':FSet,
   eqmap unit (FSetUnion s (FSetInter s' s''))
     (FSetInter (FSetUnion s s') (FSetUnion s s'')).

Lemma FSetInter_Union_l :
 forall s s' s'':FSet,
   eqmap unit (FSetInter (FSetUnion s s') s'')
     (FSetUnion (FSetInter s s'') (FSetInter s' s'')).

Lemma FSetInter_Union_r :
 forall s s' s'':FSet,
   eqmap unit (FSetInter s (FSetUnion s' s''))
     (FSetUnion (FSetInter s s') (FSetInter s s'')). *)

Require Import Mapiter.
(* Mapiter:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Mapaxioms.
Require Import Fset.
Require Import List.

Section MapIter.

  Variable A : Type.

  Section MapSweepDef.

  Variable f : ad -> A -> bool.

  Definition MapSweep2 (a0:ad) (y:A) :=
    if f a0 y then Some (a0, y) else None.

  Fixpoint MapSweep1 (pf:ad -> ad) (m:Map A) {struct m} : 
   option (ad * A) :=
    match m with
    | M0 => None
    | M1 a y => MapSweep2 (pf a) y
    | M2 m m' =>
        match MapSweep1 (fun a:ad => pf (Ndouble a)) m with
        | Some r => Some r
        | None => MapSweep1 (fun a:ad => pf (Ndouble_plus_one a)) m'
        end
    end.

  Definition MapSweep (m:Map A) := MapSweep1 (fun a:ad => a) m.

  Lemma MapSweep_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> f a y = true.

  Lemma MapSweep_semantics_1 :
   forall (m:Map A) (a:ad) (y:A), MapSweep m = Some (a, y) -> f a y = true.

  Lemma MapSweep_semantics_2_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapSweep1 pf m = Some (a, y) -> {a' : ad | a = pf a'}.

  Lemma MapSweep_semantics_2_2 :
   forall (m:Map A) (pf fp:ad -> ad),
     (forall a0:ad, fp (pf a0) = a0) ->
     forall (a:ad) (y:A),
       MapSweep1 pf m = Some (a, y) -> MapGet A m (fp a) = Some y.

  Lemma MapSweep_semantics_2 :
   forall (m:Map A) (a:ad) (y:A),
     MapSweep m = Some (a, y) -> MapGet A m a = Some y.

  Lemma MapSweep_semantics_3_1 :
   forall (m:Map A) (pf:ad -> ad),
     MapSweep1 pf m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f (pf a) y = false.

  Lemma MapSweep_semantics_3 :
   forall m:Map A,
     MapSweep m = None ->
     forall (a:ad) (y:A), MapGet A m a = Some y -> f a y = false.

  Lemma MapSweep_semantics_4_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f (pf a) y = true ->
     {a' : ad &  {y' : A | MapSweep1 pf m = Some (a', y')}}.

  Lemma MapSweep_semantics_4 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y ->
     f a y = true -> {a' : ad &  {y' : A | MapSweep m = Some (a', y')}}.

  End MapSweepDef.

  Variable B : Type.

  Fixpoint MapCollect1 (f:ad -> A -> Map B) (pf:ad -> ad) 
   (m:Map A) {struct m} : Map B :=
    match m with
    | M0 => M0 B
    | M1 a y => f (pf a) y
    | M2 m1 m2 =>
        MapMerge B (MapCollect1 f (fun a0:ad => pf (Ndouble a0)) m1)
          (MapCollect1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
    end.

  Definition MapCollect (f:ad -> A -> Map B) (m:Map A) :=
    MapCollect1 f (fun a:ad => a) m.

  Section MapFoldDef.

    Variable M : Type.
    Variable neutral : M.
    Variable op : M -> M -> M.

    Fixpoint MapFold1 (f:ad -> A -> M) (pf:ad -> ad) 
     (m:Map A) {struct m} : M :=
      match m with
      | M0 => neutral
      | M1 a y => f (pf a) y
      | M2 m1 m2 =>
          op (MapFold1 f (fun a0:ad => pf (Ndouble a0)) m1)
            (MapFold1 f (fun a0:ad => pf (Ndouble_plus_one a0)) m2)
      end.

    Definition MapFold (f:ad -> A -> M) (m:Map A) :=
      MapFold1 f (fun a:ad => a) m.

    Lemma MapFold_empty : forall f:ad -> A -> M, MapFold f (M0 A) = neutral.

    Lemma MapFold_M1 :
     forall (f:ad -> A -> M) (a:ad) (y:A), MapFold f (M1 A a y) = f a y.

    Variable State : Type.
    Variable f : State -> ad -> A -> State * M.

    Fixpoint MapFold1_state (state:State) (pf:ad -> ad) 
     (m:Map A) {struct m} : State * M :=
      match m with
      | M0 => (state, neutral)
      | M1 a y => f state (pf a) y
      | M2 m1 m2 =>
          match MapFold1_state state (fun a0:ad => pf (Ndouble a0)) m1 with
          | (state1, x1) =>
              match
                MapFold1_state state1
                  (fun a0:ad => pf (Ndouble_plus_one a0)) m2
              with
              | (state2, x2) => (state2, op x1 x2)
              end
          end
      end.

    Definition MapFold_state (state:State) :=
      MapFold1_state state (fun a:ad => a).

    Lemma pair_sp : forall (B C:Type) (x:B * C), x = (fst x, snd x).

    Lemma MapFold_state_stateless_1 :
     forall (m:Map A) (g:ad -> A -> M) (pf:ad -> ad),
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall state:State, snd (MapFold1_state state pf m) = MapFold1 g pf m.

    Lemma MapFold_state_stateless :
     forall g:ad -> A -> M,
       (forall (state:State) (a:ad) (y:A), snd (f state a y) = g a y) ->
       forall (state:State) (m:Map A),
         snd (MapFold_state state m) = MapFold g m.

  End MapFoldDef.

  Lemma MapCollect_as_Fold :
   forall (f:ad -> A -> Map B) (m:Map A),
     MapCollect f m = MapFold (Map B) (M0 B) (MapMerge B) f m.

  Definition alist := list (ad * A).
  Definition anil := nil (A:=(ad * A)).
  Definition acons := cons (A:=(ad * A)).
  Definition aapp := app (A:=(ad * A)).

  Definition alist_of_Map :=
    MapFold alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil).

  Fixpoint alist_semantics (l:alist) : ad -> option A :=
    match l with
    | nil => fun _:ad => None
    | (a, y) :: l' =>
        fun a0:ad => if Neqb a a0 then Some y else alist_semantics l' a0
    end.

  Lemma alist_semantics_app :
   forall (l l':alist) (a:ad),
     alist_semantics (aapp l l') a =
     match alist_semantics l a with
     | None => alist_semantics l' a
     | Some y => Some y
     end.

  Lemma alist_of_Map_semantics_1_1 :
   forall (m:Map A) (pf:ad -> ad) (a:ad) (y:A),
     alist_semantics
       (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil) pf
          m) a = Some y -> {a' : ad | a = pf a'}.

  Definition ad_inj (pf:ad -> ad) :=
    forall a0 a1:ad, pf a0 = pf a1 -> a0 = a1.

  Lemma ad_comp_double_inj :
   forall pf:ad -> ad, ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble a0)).

  Lemma ad_comp_double_plus_un_inj :
   forall pf:ad -> ad,
     ad_inj pf -> ad_inj (fun a0:ad => pf (Ndouble_plus_one a0)).

  Lemma alist_of_Map_semantics_1 :
   forall (m:Map A) (pf:ad -> ad),
     ad_inj pf ->
     forall a:ad,
       MapGet A m a =
       alist_semantics
         (MapFold1 alist anil aapp (fun (a0:ad) (y:A) => acons (a0, y) anil)
            pf m) (pf a).

  Lemma alist_of_Map_semantics :
   forall m:Map A, eqm A (MapGet A m) (alist_semantics (alist_of_Map m)).

  Fixpoint Map_of_alist (l:alist) : Map A :=
    match l with
    | nil => M0 A
    | (a, y) :: l' => MapPut A (Map_of_alist l') a y
    end.

  Lemma Map_of_alist_semantics :
   forall l:alist, eqm A (alist_semantics l) (MapGet A (Map_of_alist l)).

  Lemma Map_of_alist_of_Map :
   forall m:Map A, eqmap A (Map_of_alist (alist_of_Map m)) m.

  Lemma alist_of_Map_of_alist :
   forall l:alist,
     eqm A (alist_semantics (alist_of_Map (Map_of_alist l)))
       (alist_semantics l).

  Lemma fold_right_aapp :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     forall (f:ad -> A -> M) (l l':alist),
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (aapp l l') =
       op
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l)
         (fold_right
            (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m) neutral
            l').

  Lemma MapFold_as_fold_1 :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A) (pf:ad -> ad),
       MapFold1 M neutral op f pf m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral
         (MapFold1 alist anil aapp (fun (a:ad) (y:A) => acons (a, y) anil) pf
            m).

  Lemma MapFold_as_fold :
   forall (M:Type) (neutral:M) (op:M -> M -> M),
     (forall a b c:M, op (op a b) c = op a (op b c)) ->
     (forall a:M, op neutral a = a) ->
     (forall a:M, op a neutral = a) ->
     forall (f:ad -> A -> M) (m:Map A),
       MapFold M neutral op f m =
       fold_right (fun (r:ad * A) (m:M) => let (a, y) := r in op (f a y) m)
         neutral (alist_of_Map m).

  Lemma alist_MapMerge_semantics :
   forall m m':Map A,
     eqm A (alist_semantics (aapp (alist_of_Map m') (alist_of_Map m)))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).

  Lemma alist_MapMerge_semantics_disjoint :
   forall m m':Map A,
     eqmap A (MapDomRestrTo A A m m') (M0 A) ->
     eqm A (alist_semantics (aapp (alist_of_Map m) (alist_of_Map m')))
       (alist_semantics (alist_of_Map (MapMerge A m m'))).

  Lemma alist_semantics_disjoint_comm :
   forall l l':alist,
     eqmap A (MapDomRestrTo A A (Map_of_alist l) (Map_of_alist l')) (M0 A) ->
     eqm A (alist_semantics (aapp l l')) (alist_semantics (aapp l' l)).

End MapIter. *)

Require Import Fset.
(* Fset:
Require Import Bool.
Require Import Sumbool.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.

Section Dom.

  Variables A B : Type.

  Fixpoint MapDomRestrTo (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => M0 A
                        | _ => m
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => M0 A
          | M1 a' y' =>
              match MapGet A m a' with
              | None => M0 A
              | Some y => M1 A a' y
              end
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrTo m1 m'1) (MapDomRestrTo m2 m'2)
          end
    end.

  Lemma MapDomRestrTo_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrTo m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => None
          | _ => MapGet A m a0
          end).

  Fixpoint MapDomRestrBy (m:Map A) : Map B -> Map A :=
    match m with
    | M0 => fun _:Map B => M0 A
    | M1 a y =>
        fun m':Map B => match MapGet B m' a with
                        | None => m
                        | _ => M0 A
                        end
    | M2 m1 m2 =>
        fun m':Map B =>
          match m' with
          | M0 => m
          | M1 a' y' => MapRemove A m a'
          | M2 m'1 m'2 =>
              makeM2 A (MapDomRestrBy m1 m'1) (MapDomRestrBy m2 m'2)
          end
    end.

  Lemma MapDomRestrBy_semantics :
   forall (m:Map A) (m':Map B),
     eqm A (MapGet A (MapDomRestrBy m m'))
       (fun a0:ad =>
          match MapGet B m' a0 with
          | None => MapGet A m a0
          | _ => None
          end).

  Definition in_dom (a:ad) (m:Map A) :=
    match MapGet A m a with
    | None => false
    | _ => true
    end.

  Lemma in_dom_M0 : forall a:ad, in_dom a (M0 A) = false.

  Lemma in_dom_M1 : forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = Neqb a a0.

  Lemma in_dom_M1_1 : forall (a:ad) (y:A), in_dom a (M1 A a y) = true.

  Lemma in_dom_M1_2 :
   forall (a a0:ad) (y:A), in_dom a0 (M1 A a y) = true -> a = a0.

  Lemma in_dom_some :
   forall (m:Map A) (a:ad),
     in_dom a m = true -> {y : A | MapGet A m a = Some y}.

  Lemma in_dom_none :
   forall (m:Map A) (a:ad), in_dom a m = false -> MapGet A m a = None.

  Lemma in_dom_put :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_put_behind :
   forall (m:Map A) (a0:ad) (y0:A) (a:ad),
     in_dom a (MapPut_behind A m a0 y0) = orb (Neqb a a0) (in_dom a m).

  Lemma in_dom_remove :
   forall (m:Map A) (a0 a:ad),
     in_dom a (MapRemove A m a0) = andb (negb (Neqb a a0)) (in_dom a m).

  Lemma in_dom_merge :
   forall (m m':Map A) (a:ad),
     in_dom a (MapMerge A m m') = orb (in_dom a m) (in_dom a m').

  Lemma in_dom_delta :
   forall (m m':Map A) (a:ad),
     in_dom a (MapDelta A m m') = xorb (in_dom a m) (in_dom a m').

End Dom.

Section InDom.

  Variables A B : Type.

  Lemma in_dom_restrto :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrTo A B m m') =
     andb (in_dom A a m) (in_dom B a m').

  Lemma in_dom_restrby :
   forall (m:Map A) (m':Map B) (a:ad),
     in_dom A a (MapDomRestrBy A B m m') =
     andb (in_dom A a m) (negb (in_dom B a m')).

End InDom.

Definition FSet := Map unit.

Section FSetDefs.

  Variable A : Type.

  Definition in_FSet : ad -> FSet -> bool := in_dom unit.

  Fixpoint MapDom (m:Map A) : FSet :=
    match m with
    | M0 => M0 unit
    | M1 a _ => M1 unit a tt
    | M2 m m' => M2 unit (MapDom m) (MapDom m')
    end.

  Lemma MapDom_semantics_1 :
   forall (m:Map A) (a:ad) (y:A),
     MapGet A m a = Some y -> in_FSet a (MapDom m) = true.

  Lemma MapDom_semantics_2 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = true -> {y : A | MapGet A m a = Some y}.

  Lemma MapDom_semantics_3 :
   forall (m:Map A) (a:ad),
     MapGet A m a = None -> in_FSet a (MapDom m) = false.

  Lemma MapDom_semantics_4 :
   forall (m:Map A) (a:ad),
     in_FSet a (MapDom m) = false -> MapGet A m a = None.

  Lemma MapDom_Dom :
   forall (m:Map A) (a:ad), in_dom A a m = in_FSet a (MapDom m).

  Definition FSetUnion (s s':FSet) : FSet := MapMerge unit s s'.

  Lemma in_FSet_union :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetUnion s s') = orb (in_FSet a s) (in_FSet a s').

  Definition FSetInter (s s':FSet) : FSet := MapDomRestrTo unit unit s s'.

  Lemma in_FSet_inter :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetInter s s') = andb (in_FSet a s) (in_FSet a s').

  Definition FSetDiff (s s':FSet) : FSet := MapDomRestrBy unit unit s s'.

  Lemma in_FSet_diff :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDiff s s') = andb (in_FSet a s) (negb (in_FSet a s')).

  Definition FSetDelta (s s':FSet) : FSet := MapDelta unit s s'.

  Lemma in_FSet_delta :
   forall (s s':FSet) (a:ad),
     in_FSet a (FSetDelta s s') = xorb (in_FSet a s) (in_FSet a s').

End FSetDefs.

Lemma FSet_Dom : forall s:FSet, MapDom unit s = s. *)

Require Import Mapsubset.
(* Mapsubset:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import Fset.
Require Import Mapaxioms.
Require Import Mapiter.

Section MapSubsetDef.

  Variables A B : Type.

  Definition MapSubset (m:Map A) (m':Map B) :=
    forall a:ad, in_dom A a m = true -> in_dom B a m' = true.

  Definition MapSubset_1 (m:Map A) (m':Map B) :=
    match MapSweep A (fun (a:ad) (_:A) => negb (in_dom B a m')) m with
    | None => true
    | _ => false
    end.

  Definition MapSubset_2 (m:Map A) (m':Map B) :=
    eqmap A (MapDomRestrBy A B m m') (M0 A).

  Lemma MapSubset_imp_1 :
   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_1 m m' = true.

  Lemma MapSubset_1_imp :
   forall (m:Map A) (m':Map B), MapSubset_1 m m' = true -> MapSubset m m'.

  Lemma map_dom_empty_1 :
   forall m:Map A, eqmap A m (M0 A) -> forall a:ad, in_dom _ a m = false.

  Lemma map_dom_empty_2 :
   forall m:Map A, (forall a:ad, in_dom _ a m = false) -> eqmap A m (M0 A).

  Lemma MapSubset_imp_2 :
   forall (m:Map A) (m':Map B), MapSubset m m' -> MapSubset_2 m m'.

  Lemma MapSubset_2_imp :
   forall (m:Map A) (m':Map B), MapSubset_2 m m' -> MapSubset m m'.

End MapSubsetDef.

Section MapSubsetOrder.

  Variables A B C : Type.

  Lemma MapSubset_refl : forall m:Map A, MapSubset A A m m.

  Lemma MapSubset_antisym :
   forall (m:Map A) (m':Map B),
     MapSubset A B m m' ->
     MapSubset B A m' m -> eqmap unit (MapDom A m) (MapDom B m').

  Lemma MapSubset_trans :
   forall (m:Map A) (m':Map B) (m'':Map C),
     MapSubset A B m m' -> MapSubset B C m' m'' -> MapSubset A C m m''.

End MapSubsetOrder.

Section FSubsetOrder.

  Lemma FSubset_refl : forall s:FSet, MapSubset _ _ s s.

  Lemma FSubset_antisym :
   forall s s':FSet,
     MapSubset _ _ s s' -> MapSubset _ _ s' s -> eqmap unit s s'.

  Lemma FSubset_trans :
   forall s s' s'':FSet,
     MapSubset _ _ s s' -> MapSubset _ _ s' s'' -> MapSubset _ _ s s''.

End FSubsetOrder.

Section MapSubsetExtra.

  Variables A B : Type.

  Lemma MapSubset_Dom_1 :
   forall (m:Map A) (m':Map B),
     MapSubset A B m m' -> MapSubset unit unit (MapDom A m) (MapDom B m').

  Lemma MapSubset_Dom_2 :
   forall (m:Map A) (m':Map B),
     MapSubset unit unit (MapDom A m) (MapDom B m') -> MapSubset A B m m'.

  Lemma MapSubset_1_Dom :
   forall (m:Map A) (m':Map B),
     MapSubset_1 A B m m' = MapSubset_1 unit unit (MapDom A m) (MapDom B m').

  Lemma MapSubset_Put :
   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut A m a y).

  Lemma MapSubset_Put_mono :
   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),
     MapSubset A B m m' -> MapSubset A B (MapPut A m a y) (MapPut B m' a y').

  Lemma MapSubset_Put_behind :
   forall (m:Map A) (a:ad) (y:A), MapSubset A A m (MapPut_behind A m a y).

  Lemma MapSubset_Put_behind_mono :
   forall (m:Map A) (m':Map B) (a:ad) (y:A) (y':B),
     MapSubset A B m m' ->
     MapSubset A B (MapPut_behind A m a y) (MapPut_behind B m' a y').

  Lemma MapSubset_Remove :
   forall (m:Map A) (a:ad), MapSubset A A (MapRemove A m a) m.

  Lemma MapSubset_Remove_mono :
   forall (m:Map A) (m':Map B) (a:ad),
     MapSubset A B m m' -> MapSubset A B (MapRemove A m a) (MapRemove B m' a).

  Lemma MapSubset_Merge_l :
   forall m m':Map A, MapSubset A A m (MapMerge A m m').

  Lemma MapSubset_Merge_r :
   forall m m':Map A, MapSubset A A m' (MapMerge A m m').

  Lemma MapSubset_Merge_mono :
   forall (m m':Map A) (m'' m''':Map B),
     MapSubset A B m m'' ->
     MapSubset A B m' m''' ->
     MapSubset A B (MapMerge A m m') (MapMerge B m'' m''').

  Lemma MapSubset_DomRestrTo_l :
   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrTo A B m m') m.

  Lemma MapSubset_DomRestrTo_r :
   forall (m:Map A) (m':Map B), MapSubset A B (MapDomRestrTo A B m m') m'.

  Lemma MapSubset_ext :
   forall (m0 m1:Map A) (m2 m3:Map B),
     eqmap A m0 m1 ->
     eqmap B m2 m3 -> MapSubset A B m0 m2 -> MapSubset A B m1 m3.

  Variables C D : Type.

  Lemma MapSubset_DomRestrTo_mono :
   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),
     MapSubset _ _ m m'' ->
     MapSubset _ _ m' m''' ->
     MapSubset _ _ (MapDomRestrTo _ _ m m') (MapDomRestrTo _ _ m'' m''').

  Lemma MapSubset_DomRestrBy_l :
   forall (m:Map A) (m':Map B), MapSubset A A (MapDomRestrBy A B m m') m.

  Lemma MapSubset_DomRestrBy_mono :
   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),
     MapSubset _ _ m m'' ->
     MapSubset _ _ m''' m' ->
     MapSubset _ _ (MapDomRestrBy _ _ m m') (MapDomRestrBy _ _ m'' m''').
  
End MapSubsetExtra.

Section MapDisjointDef.

  Variables A B : Type.

  Definition MapDisjoint (m:Map A) (m':Map B) :=
    forall a:ad, in_dom A a m = true -> in_dom B a m' = true -> False.

  Definition MapDisjoint_1 (m:Map A) (m':Map B) :=
    match MapSweep A (fun (a:ad) (_:A) => in_dom B a m') m with
    | None => true
    | _ => false
    end.

  Definition MapDisjoint_2 (m:Map A) (m':Map B) :=
    eqmap A (MapDomRestrTo A B m m') (M0 A).

  Lemma MapDisjoint_imp_1 :
   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_1 m m' = true.

  Lemma MapDisjoint_1_imp :
   forall (m:Map A) (m':Map B), MapDisjoint_1 m m' = true -> MapDisjoint m m'.

  Lemma MapDisjoint_imp_2 :
   forall (m:Map A) (m':Map B), MapDisjoint m m' -> MapDisjoint_2 m m'.

  Lemma MapDisjoint_2_imp :
   forall (m:Map A) (m':Map B), MapDisjoint_2 m m' -> MapDisjoint m m'.

  Lemma Map_M0_disjoint : forall m:Map B, MapDisjoint (M0 A) m.

  Lemma Map_disjoint_M0 : forall m:Map A, MapDisjoint m (M0 B).

End MapDisjointDef.

Section MapDisjointExtra.

  Variables A B : Type.

  Lemma MapDisjoint_ext :
   forall (m0 m1:Map A) (m2 m3:Map B),
     eqmap A m0 m1 ->
     eqmap B m2 m3 -> MapDisjoint A B m0 m2 -> MapDisjoint A B m1 m3.

  Lemma MapMerge_disjoint :
   forall m m':Map A,
     MapDisjoint A A m m' ->
     forall a:ad,
       in_dom A a (MapMerge A m m') =
       orb (andb (in_dom A a m) (negb (in_dom A a m')))
         (andb (in_dom A a m') (negb (in_dom A a m))).

  Lemma MapDisjoint_M2_l :
   forall (m0 m1:Map A) (m2 m3:Map B),
     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m0 m2.

  Lemma MapDisjoint_M2_r :
   forall (m0 m1:Map A) (m2 m3:Map B),
     MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3) -> MapDisjoint A B m1 m3.

  Lemma MapDisjoint_M2 :
   forall (m0 m1:Map A) (m2 m3:Map B),
     MapDisjoint A B m0 m2 ->
     MapDisjoint A B m1 m3 -> MapDisjoint A B (M2 A m0 m1) (M2 B m2 m3).

  Lemma MapDisjoint_M1_l :
   forall (m:Map A) (a:ad) (y:B),
     MapDisjoint B A (M1 B a y) m -> in_dom A a m = false.

  Lemma MapDisjoint_M1_r :
   forall (m:Map A) (a:ad) (y:B),
     MapDisjoint A B m (M1 B a y) -> in_dom A a m = false.

  Lemma MapDisjoint_M1_conv_l :
   forall (m:Map A) (a:ad) (y:B),
     in_dom A a m = false -> MapDisjoint B A (M1 B a y) m.

  Lemma MapDisjoint_M1_conv_r :
   forall (m:Map A) (a:ad) (y:B),
     in_dom A a m = false -> MapDisjoint A B m (M1 B a y).
 
  Lemma MapDisjoint_sym :
   forall (m:Map A) (m':Map B), MapDisjoint A B m m' -> MapDisjoint B A m' m.

  Lemma MapDisjoint_empty :
   forall m:Map A, MapDisjoint A A m m -> eqmap A m (M0 A).

  Lemma MapDelta_disjoint :
   forall m m':Map A,
     MapDisjoint A A m m' -> eqmap A (MapDelta A m m') (MapMerge A m m').

  Variable C : Type.

  Lemma MapDomRestr_disjoint :
   forall (m:Map A) (m':Map B) (m'':Map C),
     MapDisjoint A B (MapDomRestrTo A C m m'') (MapDomRestrBy B C m' m'').

  Lemma MapDelta_RestrTo_disjoint :
   forall m m':Map A,
     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m m').

  Lemma MapDelta_RestrTo_disjoint_2 :
   forall m m':Map A,
     MapDisjoint A A (MapDelta A m m') (MapDomRestrTo A A m' m).

  Variable D : Type.

  Lemma MapSubset_Disjoint :
   forall (m:Map A) (m':Map B) (m'':Map C) (m''':Map D),
     MapSubset _ _ m m' ->
     MapSubset _ _ m'' m''' ->
     MapDisjoint _ _ m' m''' -> MapDisjoint _ _ m m''.

  Lemma MapSubset_Disjoint_l :
   forall (m:Map A) (m':Map B) (m'':Map C),
     MapSubset _ _ m m' -> MapDisjoint _ _ m' m'' -> MapDisjoint _ _ m m''.

  Lemma MapSubset_Disjoint_r :
   forall (m:Map A) (m'':Map C) (m''':Map D),
     MapSubset _ _ m'' m''' ->
     MapDisjoint _ _ m m''' -> MapDisjoint _ _ m m''.

End MapDisjointExtra. *)

Require Import List.

Require Import Lsort.
(* Lsort:
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import NArith.
Require Import Ndigits.
Require Import Ndec.
Require Import Map.
Require Import List.
Require Import Mapiter.

Section LSort.

  Variable A : Type.

  Fixpoint alist_sorted (l:alist A) : bool :=
    match l with
    | nil => true
    | (a, _) :: l' =>
        match l' with
        | nil => true
        | (a', y') :: l'' => andb (Nless a a') (alist_sorted l')
        end
    end.

  Fixpoint alist_nth_ad (n:nat) (l:alist A) {struct l} : ad :=
    match l with
    | nil => N0 
    | (a, y) :: l' => match n with
                      | O => a
                      | S n' => alist_nth_ad n' l'
                      end
    end.

  Definition alist_sorted_1 (l:alist A) :=
    forall n:nat,
      S (S n) <= length l ->
      Nless (alist_nth_ad n l) (alist_nth_ad (S n) l) = true.

  Lemma alist_sorted_imp_1 :
   forall l:alist A, alist_sorted l = true -> alist_sorted_1 l.

  Definition alist_sorted_2 (l:alist A) :=
    forall m n:nat,
      m < n ->
      S n <= length l -> Nless (alist_nth_ad m l) (alist_nth_ad n l) = true.

  Lemma alist_sorted_1_imp_2 :
   forall l:alist A, alist_sorted_1 l -> alist_sorted_2 l.

  Lemma alist_sorted_2_imp :
   forall l:alist A, alist_sorted_2 l -> alist_sorted l = true.

  Lemma app_length :
   forall (C:Type) (l l':list C), length (l ++ l') = length l + length l'.

  Lemma aapp_length :
   forall l l':alist A, length (aapp A l l') = length l + length l'.

  Lemma alist_nth_ad_aapp_1 :
   forall (l l':alist A) (n:nat),
     S n <= length l -> alist_nth_ad n (aapp A l l') = alist_nth_ad n l.

  Lemma alist_nth_ad_aapp_2 :
   forall (l l':alist A) (n:nat),
     S n <= length l' ->
     alist_nth_ad (length l + n) (aapp A l l') = alist_nth_ad n l'.

  Lemma interval_split :
   forall p q n:nat,
     S n <= p + q -> {n' : nat | S n' <= q /\ n = p + n'} + {S n <= p}.

  Lemma alist_conc_sorted :
   forall l l':alist A,
     alist_sorted_2 l ->
     alist_sorted_2 l' ->
     (forall n n':nat,
        S n <= length l ->
        S n' <= length l' ->
        Nless (alist_nth_ad n l) (alist_nth_ad n' l') = true) ->
     alist_sorted_2 (aapp A l l').

  Lemma alist_nth_ad_semantics :
   forall (l:alist A) (n:nat),
     S n <= length l ->
     {y : A | alist_semantics A l (alist_nth_ad n l) = Some y}.

  Lemma alist_of_Map_nth_ad :
   forall (m:Map A) (pf:ad -> ad) (l:alist A),
     l =
     MapFold1 A (alist A) (anil A) (aapp A)
       (fun (a0:ad) (y:A) => acons A (a0, y) (anil A)) pf m ->
     forall n:nat, S n <= length l -> {a' : ad | alist_nth_ad n l = pf a'}.

  Definition ad_monotonic (pf:ad -> ad) :=
    forall a a':ad, Nless a a' = true -> Nless (pf a) (pf a') = true.

  Lemma Ndouble_monotonic : ad_monotonic Ndouble.

  Lemma Ndouble_plus_one_monotonic : ad_monotonic Ndouble_plus_one.

  Lemma ad_comp_monotonic :
   forall pf pf':ad -> ad,
     ad_monotonic pf ->
     ad_monotonic pf' -> ad_monotonic (fun a0:ad => pf (pf' a0)).

  Lemma ad_comp_double_monotonic :
   forall pf:ad -> ad,
     ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble a0)).

  Lemma ad_comp_double_plus_un_monotonic :
   forall pf:ad -> ad,
     ad_monotonic pf -> ad_monotonic (fun a0:ad => pf (Ndouble_plus_one a0)).

  Lemma alist_of_Map_sorts_1 :
   forall (m:Map A) (pf:ad -> ad),
     ad_monotonic pf ->
     alist_sorted_2
       (MapFold1 A (alist A) (anil A) (aapp A)
          (fun (a:ad) (y:A) => acons A (a, y) (anil A)) pf m).

  Lemma alist_of_Map_sorts :
   forall m:Map A, alist_sorted (alist_of_Map A m) = true.

  Lemma alist_of_Map_sorts1 :
   forall m:Map A, alist_sorted_1 (alist_of_Map A m).
 
  Lemma alist_of_Map_sorts2 :
   forall m:Map A, alist_sorted_2 (alist_of_Map A m).

  Lemma alist_too_low :
   forall (l:alist A) (a a':ad) (y:A),
     Nless a a' = true ->
     alist_sorted_2 ((a', y) :: l) ->
     alist_semantics A ((a', y) :: l) a = None.

  Lemma alist_semantics_nth_ad :
   forall (l:alist A) (a:ad) (y:A),
     alist_semantics A l a = Some y ->
     {n : nat | S n <= length l /\ alist_nth_ad n l = a}.

  Lemma alist_semantics_tail :
   forall (l:alist A) (a:ad) (y:A),
     alist_sorted_2 ((a, y) :: l) ->
     eqm A (alist_semantics A l)
       (fun a0:ad =>
          if Neqb a a0 then None else alist_semantics A ((a, y) :: l) a0).

  Lemma alist_semantics_same_tail :
   forall (l l':alist A) (a:ad) (y:A),
     alist_sorted_2 ((a, y) :: l) ->
     alist_sorted_2 ((a, y) :: l') ->
     eqm A (alist_semantics A ((a, y) :: l))
       (alist_semantics A ((a, y) :: l')) ->
     eqm A (alist_semantics A l) (alist_semantics A l').

  Lemma alist_sorted_tail :
   forall (l:alist A) (a:ad) (y:A),
     alist_sorted_2 ((a, y) :: l) -> alist_sorted_2 l.

  Lemma alist_canonical :
   forall l l':alist A,
     eqm A (alist_semantics A l) (alist_semantics A l') ->
     alist_sorted_2 l -> alist_sorted_2 l' -> l = l'.

End LSort. *)

Require Import Peano_dec.



Section MapCard.



  Variables A B : Type.



  Lemma MapCard_M0 : MapCard A (M0 A) = 0.

  Proof.

    trivial.

  Qed.



  Lemma MapCard_M1 : forall (a:ad) (y:A), MapCard A (M1 A a y) = 1.

  Proof.

    trivial.

  Qed.



  Lemma MapCard_is_O :

   forall m:Map A, MapCard A m = 0 -> forall a:ad, MapGet A m a = None.

  Proof.

    simple induction m. trivial.

    intros a y H. discriminate H.

    intros. simpl in H1. elim (plus_is_O _ _ H1). intros. rewrite (MapGet_M2_bit_0_if A m0 m1 a).

    case (Nbit0 a). apply H0. assumption.

    apply H. assumption.

  Qed.



  Lemma MapCard_is_not_O :

   forall (m:Map A) (a:ad) (y:A),

     MapGet A m a = Some y -> {n : nat | MapCard A m = S n}.

  Proof.

    simple induction m. intros. discriminate H.

    intros a y a0 y0 H. simpl in H. elim (sumbool_of_bool (Neqb a a0)). intro H0. split with 0.

    reflexivity.

    intro H0. rewrite H0 in H. discriminate H.

    intros. elim (sumbool_of_bool (Nbit0 a)). intro H2.

    rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H. elim (X0 (Ndiv2 a) y H). intros n H3.

    simpl in |- *. rewrite H3. split with (MapCard A m0 + n).

    rewrite <- (plus_Snm_nSm (MapCard A m0) n). reflexivity.

    intro H2. rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H. elim (X (Ndiv2 a) y H).

    intros n H3. simpl in |- *. rewrite H3. split with (n + MapCard A m1). reflexivity.

  Qed.



  Lemma MapCard_is_one :

   forall m:Map A,

     MapCard A m = 1 -> {a : ad &  {y : A | MapGet A m a = Some y}}.

  Proof.

    simple induction m. intro. discriminate H.

    intros a y H. split with a. split with y. apply M1_semantics_1.

    intros. simpl in H. elim (plus_is_one (MapCard A m0) (MapCard A m1) H).

    intro H2. elim H2. intros H3 H4. elim (X0 H4). intros a H5. split with (Ndouble_plus_one a).

    rewrite (MapGet_M2_bit_0_1 A _ (Ndouble_plus_one_bit0 a) m0 m1).

    rewrite Ndouble_plus_one_div2. exact H5.

    intro H2. elim H2. intros H3 H4. elim (X H3). intros a H5. split with (Ndouble a).

    rewrite (MapGet_M2_bit_0_0 A _ (Ndouble_bit0 a) m0 m1).

    rewrite Ndouble_div2. exact H5.

  Qed.



  Lemma MapCard_is_one_unique :

   forall m:Map A,

     MapCard A m = 1 ->

     forall (a a':ad) (y y':A),

       MapGet A m a = Some y ->

       MapGet A m a' = Some y' -> a = a' /\ y = y'.

  Proof.

    simple induction m. intro. discriminate H.

    intros. elim (sumbool_of_bool (Neqb a a1)). intro H2. rewrite (Neqb_complete _ _ H2) in H0.

    rewrite (M1_semantics_1 A a1 a0) in H0. inversion H0. elim (sumbool_of_bool (Neqb a a')).

    intro H5. rewrite (Neqb_complete _ _ H5) in H1. rewrite (M1_semantics_1 A a' a0) in H1.

    inversion H1. rewrite <- (Neqb_complete _ _ H2). rewrite <- (Neqb_complete _ _ H5).

    rewrite <- H4. rewrite <- H6. split; reflexivity.

    intro H5. rewrite (M1_semantics_2 A a a' a0 H5) in H1. discriminate H1.

    intro H2. rewrite (M1_semantics_2 A a a1 a0 H2) in H0. discriminate H0.

    intros. simpl in H1. elim (plus_is_one _ _ H1). intro H4. elim H4. intros.

    rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2. elim (sumbool_of_bool (Nbit0 a)).

    intro H7. rewrite H7 in H2. rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.

    elim (sumbool_of_bool (Nbit0 a')). intro H8. rewrite H8 in H3. elim (H0 H6 _ _ _ _ H2 H3).

    intros. split. rewrite <- (Ndiv2_double_plus_one a H7).

    rewrite <- (Ndiv2_double_plus_one a' H8). rewrite H9. reflexivity.

    assumption.

    intro H8. rewrite H8 in H3. rewrite (MapCard_is_O m0 H5 (Ndiv2 a')) in H3.

    discriminate H3.

    intro H7. rewrite H7 in H2. rewrite (MapCard_is_O m0 H5 (Ndiv2 a)) in H2.

    discriminate H2.

    intro H4. elim H4. intros. rewrite (MapGet_M2_bit_0_if A m0 m1 a) in H2.

    elim (sumbool_of_bool (Nbit0 a)). intro H7. rewrite H7 in H2.

    rewrite (MapCard_is_O m1 H6 (Ndiv2 a)) in H2. discriminate H2.

    intro H7. rewrite H7 in H2. rewrite (MapGet_M2_bit_0_if A m0 m1 a') in H3.

    elim (sumbool_of_bool (Nbit0 a')). intro H8. rewrite H8 in H3.

    rewrite (MapCard_is_O m1 H6 (Ndiv2 a')) in H3. discriminate H3.

    intro H8. rewrite H8 in H3. elim (H H5 _ _ _ _ H2 H3). intros. split.

    rewrite <- (Ndiv2_double a H7). rewrite <- (Ndiv2_double a' H8).

    rewrite H9. reflexivity.

    assumption.

  Qed.



  Lemma length_as_fold :

   forall (C:Type) (l:list C),

     length l = fold_right (fun (_:C) (n:nat) => S n) 0 l.

  Proof.

    simple induction l. reflexivity.

    intros. simpl in |- *. rewrite H. reflexivity.

  Qed.



  Lemma length_as_fold_2 :

   forall l:alist A,

     length l =

     fold_right (fun (r:ad * A) (n:nat) => let (a, y) := r in 1 + n) 0 l.

  Proof.

    simple induction l. reflexivity.

    intros. simpl in |- *. rewrite H. elim a; reflexivity.

  Qed.



  Lemma MapCard_as_Fold_1 :

   forall (m:Map A) (pf:ad -> ad),

     MapCard A m = MapFold1 A nat 0 plus (fun (_:ad) (_:A) => 1) pf m.

  Proof.

    simple induction m. trivial.

    trivial.

    intros. simpl in |- *. rewrite <- (H (fun a0:ad => pf (Ndouble a0))).

    rewrite <- (H0 (fun a0:ad => pf (Ndouble_plus_one a0))). reflexivity.

  Qed.



  Lemma MapCard_as_Fold :

   forall m:Map A,

     MapCard A m = MapFold A nat 0 plus (fun (_:ad) (_:A) => 1) m.

  Proof.

    intro. exact (MapCard_as_Fold_1 m (fun a0:ad => a0)).

  Qed.

 

  Lemma MapCard_as_length :

   forall m:Map A, MapCard A m = length (alist_of_Map A m).

  Proof.

    intro. rewrite MapCard_as_Fold. rewrite length_as_fold_2.

    apply MapFold_as_fold with

     (op := plus) (neutral := 0) (f := fun (_:ad) (_:A) => 1). exact plus_assoc_reverse.

    trivial.

    intro. rewrite <- plus_n_O. reflexivity.

  Qed.



  Lemma MapCard_Put1_equals_2 :

   forall (p:positive) (a a':ad) (y y':A),

     MapCard A (MapPut1 A a y a' y' p) = 2.

  Proof.

    simple induction p. intros. simpl in |- *. case (Nbit0 a); reflexivity.

    intros. simpl in |- *. case (Nbit0 a). exact (H (Ndiv2 a) (Ndiv2 a') y y').

    simpl in |- *. rewrite <- plus_n_O. exact (H (Ndiv2 a) (Ndiv2 a') y y').

    intros. simpl in |- *. case (Nbit0 a); reflexivity.

  Qed.



  Lemma MapCard_Put_sum :

   forall (m m':Map A) (a:ad) (y:A) (n n':nat),

     m' = MapPut A m a y ->

     n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.

  Proof.

    simple induction m. simpl in |- *. intros. rewrite H in H1. simpl in H1. right.

    rewrite H0. rewrite H1. reflexivity.

    intros a y m' a0 y0 n n' H H0 H1. simpl in H. elim (Ndiscr (Nxor a a0)). intro H2.

    elim H2. intros p H3. rewrite H3 in H. rewrite H in H1.

    rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H1. simpl in H0. right.

    rewrite H0. rewrite H1. reflexivity.

    intro H2. rewrite H2 in H. rewrite H in H1. simpl in H1. simpl in H0. left.

    rewrite H0. rewrite H1. reflexivity.

    intros. simpl in H0. rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H.

    elim (sumbool_of_bool (Nbit0 a)). intro H4. rewrite H4 in H.

    elim

     (X0 (MapPut A m1 (Ndiv2 a) y) (Ndiv2 a) y (

        MapCard A m1) (MapCard A (MapPut A m1 (Ndiv2 a) y)) (

        refl_equal _) (refl_equal _) (refl_equal _)).

    intro H5. rewrite H in H1. simpl in H1. rewrite H5 in H1. rewrite <- H0 in H1. left.

    assumption.

    intro H5. rewrite H in H1. simpl in H1. rewrite H5 in H1.

    rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)) in H1.

    simpl in H1. rewrite <- H0 in H1. right. assumption.

    intro H4. rewrite H4 in H.

    elim

     (X (MapPut A m0 (Ndiv2 a) y) (Ndiv2 a) y (

        MapCard A m0) (MapCard A (MapPut A m0 (Ndiv2 a) y)) (

        refl_equal _) (refl_equal _) (refl_equal _)).

    intro H5. rewrite H in H1. simpl in H1. rewrite H5 in H1. rewrite <- H0 in H1.

    left. assumption.

    intro H5. rewrite H in H1. simpl in H1. rewrite H5 in H1. simpl in H1. rewrite <- H0 in H1.

    right. assumption.

  Qed.



  Lemma MapCard_Put_lb :

   forall (m:Map A) (a:ad) (y:A), MapCard A (MapPut A m a y) >= MapCard A m.

  Proof.

    unfold ge in |- *. intros.

    elim

     (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m)

        (MapCard A (MapPut A m a y)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H. rewrite H. apply le_n.

    intro H. rewrite H. apply le_n_Sn.

  Qed.



  Lemma MapCard_Put_ub :

   forall (m:Map A) (a:ad) (y:A),

     MapCard A (MapPut A m a y) <= S (MapCard A m).

  Proof.

    intros.

    elim

     (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m)

        (MapCard A (MapPut A m a y)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H. rewrite H. apply le_n_Sn.

    intro H. rewrite H. apply le_n.

  Qed.



  Lemma MapCard_Put_1 :

   forall (m:Map A) (a:ad) (y:A),

     MapCard A (MapPut A m a y) = MapCard A m ->

     {y : A | MapGet A m a = Some y}.

  Proof.

    simple induction m. intros. discriminate H.

    intros a y a0 y0 H. simpl in H. elim (Ndiscr (Nxor a a0)). intro H0. elim H0.

    intros p H1. rewrite H1 in H. rewrite (MapCard_Put1_equals_2 p a a0 y y0) in H.

    discriminate H.

    intro H0. rewrite H0 in H. rewrite (Nxor_eq _ _ H0). split with y. apply M1_semantics_1.

    intros. rewrite (MapPut_semantics_3_1 A m0 m1 a y) in H. elim (sumbool_of_bool (Nbit0 a)).

    intro H2. rewrite H2 in H. simpl in H. elim (X0 (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)).

    intros y0 H3. split with y0. rewrite <- H3. exact (MapGet_M2_bit_0_1 A a H2 m0 m1).

    intro H2. rewrite H2 in H. simpl in H.

    rewrite

     (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1))

      in H.

    rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H.

    elim (X (Ndiv2 a) y ((fun n m p:nat => plus_reg_l m p n) _ _ _ H)). intros y0 H3. split with y0.

    rewrite <- H3. exact (MapGet_M2_bit_0_0 A a H2 m0 m1).

  Qed.



  Lemma MapCard_Put_2 :

   forall (m:Map A) (a:ad) (y:A),

     MapCard A (MapPut A m a y) = S (MapCard A m) -> MapGet A m a = None.

  Proof.

    simple induction m. trivial.

    intros. simpl in H. elim (sumbool_of_bool (Neqb a a1)). intro H0.

    rewrite (Neqb_complete _ _ H0) in H. rewrite (Nxor_nilpotent a1) in H. discriminate H.

    intro H0. exact (M1_semantics_2 A a a1 a0 H0).

    intros. elim (sumbool_of_bool (Nbit0 a)). intro H2.

    rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1). apply (H0 (Ndiv2 a) y).

    apply (fun n m p:nat => plus_reg_l m p n) with (n := MapCard A m0).

    rewrite <- (plus_Snm_nSm (MapCard A m0) (MapCard A m1)). simpl in H1. simpl in |- *. rewrite <- H1.

    clear H1.

    induction a. discriminate H2.

    induction p. reflexivity.

    discriminate H2.

    reflexivity.

    intro H2. rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1). apply (H (Ndiv2 a) y).

    cut

     (MapCard A (MapPut A m0 (Ndiv2 a) y) + MapCard A m1 =

      S (MapCard A m0) + MapCard A m1).

    intro. rewrite (plus_comm (MapCard A (MapPut A m0 (Ndiv2 a) y)) (MapCard A m1))

   in H3.

    rewrite (plus_comm (S (MapCard A m0)) (MapCard A m1)) in H3. exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H3).

    simpl in |- *. simpl in H1. rewrite <- H1. induction a. trivial.

    induction p. discriminate H2.

    reflexivity.

    discriminate H2.

  Qed.



  Lemma MapCard_Put_1_conv :

   forall (m:Map A) (a:ad) (y y':A),

     MapGet A m a = Some y -> MapCard A (MapPut A m a y') = MapCard A m.

  Proof.

    intros.

    elim

     (MapCard_Put_sum m (MapPut A m a y') a y' (MapCard A m)

        (MapCard A (MapPut A m a y')) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    trivial.

    intro H0. rewrite (MapCard_Put_2 m a y' H0) in H. discriminate H.

  Qed.



  Lemma MapCard_Put_2_conv :

   forall (m:Map A) (a:ad) (y:A),

     MapGet A m a = None -> MapCard A (MapPut A m a y) = S (MapCard A m).

  Proof.

    intros.

    elim

     (MapCard_Put_sum m (MapPut A m a y) a y (MapCard A m)

        (MapCard A (MapPut A m a y)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H0. elim (MapCard_Put_1 m a y H0). intros y' H1. rewrite H1 in H. discriminate H.

    trivial.

  Qed.



  Lemma MapCard_ext :

   forall m m':Map A,

     eqm A (MapGet A m) (MapGet A m') -> MapCard A m = MapCard A m'.

  Proof.

    unfold eqm in |- *. intros. rewrite (MapCard_as_length m). rewrite (MapCard_as_length m').

    rewrite (alist_canonical A (alist_of_Map A m) (alist_of_Map A m')). reflexivity.

    unfold eqm in |- *. intro. rewrite (Map_of_alist_semantics A (alist_of_Map A m) a).

    rewrite (Map_of_alist_semantics A (alist_of_Map A m') a). rewrite (Map_of_alist_of_Map A m' a).

    rewrite (Map_of_alist_of_Map A m a). exact (H a).

    apply alist_of_Map_sorts2.

    apply alist_of_Map_sorts2.

  Qed.



  Lemma MapCard_Dom : forall m:Map A, MapCard A m = MapCard unit (MapDom A m).

  Proof.

    simple induction m; trivial. intros. simpl in |- *. rewrite H. rewrite H0. reflexivity.

  Qed.



  Lemma MapCard_Dom_Put_behind :

   forall (m:Map A) (a:ad) (y:A),

     MapDom A (MapPut_behind A m a y) = MapDom A (MapPut A m a y).

  Proof.

    simple induction m. trivial.

    intros a y a0 y0. simpl in |- *. elim (Ndiscr (Nxor a a0)). intro H. elim H.

    intros p H0. rewrite H0. reflexivity.

    intro H. rewrite H. rewrite (Nxor_eq _ _ H). reflexivity.

    intros. simpl in |- *. elim (Ndiscr a). intro H1. elim H1. intros p H2. rewrite H2. case p.

    intro p0. simpl in |- *. rewrite H0. reflexivity.

    intro p0. simpl in |- *. rewrite H. reflexivity.

    simpl in |- *. rewrite H0. reflexivity.

    intro H1. rewrite H1. simpl in |- *. rewrite H. reflexivity.

  Qed.



  Lemma MapCard_Put_behind_Put :

   forall (m:Map A) (a:ad) (y:A),

     MapCard A (MapPut_behind A m a y) = MapCard A (MapPut A m a y).

  Proof.

    intros. rewrite MapCard_Dom. rewrite MapCard_Dom. rewrite MapCard_Dom_Put_behind.

    reflexivity.

  Qed.



  Lemma MapCard_Put_behind_sum :

   forall (m m':Map A) (a:ad) (y:A) (n n':nat),

     m' = MapPut_behind A m a y ->

     n = MapCard A m -> n' = MapCard A m' -> {n' = n} + {n' = S n}.

  Proof.

    intros. apply (MapCard_Put_sum m (MapPut A m a y) a y n n'); trivial.

    rewrite <- MapCard_Put_behind_Put. rewrite <- H. assumption.

  Qed.



  Lemma MapCard_makeM2 :

   forall m m':Map A, MapCard A (makeM2 A m m') = MapCard A m + MapCard A m'.

  Proof.

    intros. rewrite (MapCard_ext _ _ (makeM2_M2 A m m')). reflexivity.

  Qed.

 

  Lemma MapCard_Remove_sum :

   forall (m m':Map A) (a:ad) (n n':nat),

     m' = MapRemove A m a ->

     n = MapCard A m -> n' = MapCard A m' -> {n = n'} + {n = S n'}.

  Proof.

    simple induction m. simpl in |- *. intros. rewrite H in H1. simpl in H1. left. rewrite H1. assumption.

    simpl in |- *. intros. elim (sumbool_of_bool (Neqb a a1)). intro H2. rewrite H2 in H.

    rewrite H in H1. simpl in H1. right. rewrite H1. assumption.

    intro H2. rewrite H2 in H. rewrite H in H1. simpl in H1. left. rewrite H1. assumption.

    intros. simpl in H1. simpl in H. elim (sumbool_of_bool (Nbit0 a)). intro H4.

    rewrite H4 in H. rewrite H in H1.

    rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.

    elim

     (X0 (MapRemove A m1 (Ndiv2 a)) (Ndiv2 a) (

        MapCard A m1) (MapCard A (MapRemove A m1 (Ndiv2 a)))

        (refl_equal _) (refl_equal _) (refl_equal _)).

    simpl in H0;  intro H5. rewrite H5 in H0. left. rewrite H1. exact H0.

    simpl in H0; intro H5. rewrite H5 in H0.

    rewrite <-

     (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a))))

      in H0.

    right. rewrite H1. exact H0.

    intro H4. rewrite H4 in H. rewrite H in H1.

    rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.

    elim

     (X (MapRemove A m0 (Ndiv2 a)) (Ndiv2 a) (

        MapCard A m0) (MapCard A (MapRemove A m0 (Ndiv2 a)))

        (refl_equal _) (refl_equal _) (refl_equal _)).

    simpl in H0; intro H5. rewrite H5 in H0. left. rewrite H1. exact H0.

    simpl in H0; intro H5. rewrite H5 in H0. right. rewrite H1. exact H0.

  Qed.



  Lemma MapCard_Remove_ub :

   forall (m:Map A) (a:ad), MapCard A (MapRemove A m a) <= MapCard A m.

  Proof.

    intros.

    elim

     (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m)

        (MapCard A (MapRemove A m a)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H. rewrite H. apply le_n.

    intro H. rewrite H. apply le_n_Sn.

  Qed.



  Lemma MapCard_Remove_lb :

   forall (m:Map A) (a:ad), S (MapCard A (MapRemove A m a)) >= MapCard A m.

  Proof.

    unfold ge in |- *. intros.

    elim

     (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m)

        (MapCard A (MapRemove A m a)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H. rewrite H. apply le_n_Sn.

    intro H. rewrite H. apply le_n.

  Qed.



  Lemma MapCard_Remove_1 :

   forall (m:Map A) (a:ad),

     MapCard A (MapRemove A m a) = MapCard A m -> MapGet A m a = None.

  Proof.

    simple induction m. trivial.

    simpl in |- *. intros a y a0 H. elim (sumbool_of_bool (Neqb a a0)). intro H0.

    rewrite H0 in H. discriminate H.

    intro H0. rewrite H0. reflexivity.

    intros. simpl in H1. elim (sumbool_of_bool (Nbit0 a)). intro H2. rewrite H2 in H1.

    rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H1.

    rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1). apply H0. exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H1).

    intro H2. rewrite H2 in H1.

    rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H1.

    rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1). apply H.

    rewrite

     (plus_comm (MapCard A (MapRemove A m0 (Ndiv2 a))) (MapCard A m1))

      in H1.

    rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H1. exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H1).

  Qed.



  Lemma MapCard_Remove_2 :

   forall (m:Map A) (a:ad),

     S (MapCard A (MapRemove A m a)) = MapCard A m ->

     {y : A | MapGet A m a = Some y}.

  Proof.

    simple induction m. intros. discriminate H.

    intros a y a0 H. simpl in H. elim (sumbool_of_bool (Neqb a a0)). intro H0.

    rewrite (Neqb_complete _ _ H0). split with y. exact (M1_semantics_1 A a0 y).

    intro H0. rewrite H0 in H. discriminate H.

    intros. simpl in H. elim (sumbool_of_bool (Nbit0 a)). intro H0. rewrite H0 in H.

    rewrite (MapCard_makeM2 m0 (MapRemove A m1 (Ndiv2 a))) in H.

    rewrite (MapGet_M2_bit_0_1 A a H0 m0 m1). apply X0.

    change

      (S (MapCard A m0) + MapCard A (MapRemove A m1 (Ndiv2 a)) =

       MapCard A m0 + MapCard A m1) in H.

    rewrite

     (plus_Snm_nSm (MapCard A m0) (MapCard A (MapRemove A m1 (Ndiv2 a))))

      in H.

    exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H).

    intro H2. rewrite H2 in H. rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1). apply X.

    rewrite (MapCard_makeM2 (MapRemove A m0 (Ndiv2 a)) m1) in H.

    change

      (S (MapCard A (MapRemove A m0 (Ndiv2 a))) + MapCard A m1 =

       MapCard A m0 + MapCard A m1) in H.

    rewrite

     (plus_comm (S (MapCard A (MapRemove A m0 (Ndiv2 a)))) (MapCard A m1))

      in H.

    rewrite (plus_comm (MapCard A m0) (MapCard A m1)) in H. exact ((fun n m p:nat => plus_reg_l m p n) _ _ _ H).

  Qed.



  Lemma MapCard_Remove_1_conv :

   forall (m:Map A) (a:ad),

     MapGet A m a = None -> MapCard A (MapRemove A m a) = MapCard A m.

  Proof.

    intros.

    elim

     (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m)

        (MapCard A (MapRemove A m a)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H0. rewrite H0. reflexivity.

    intro H0. elim (MapCard_Remove_2 m a (sym_eq H0)). intros y H1. rewrite H1 in H.

    discriminate H.

  Qed.



  Lemma MapCard_Remove_2_conv :

   forall (m:Map A) (a:ad) (y:A),

     MapGet A m a = Some y -> S (MapCard A (MapRemove A m a)) = MapCard A m.

  Proof.

    intros.

    elim

     (MapCard_Remove_sum m (MapRemove A m a) a (MapCard A m)

        (MapCard A (MapRemove A m a)) (refl_equal _) (

        refl_equal _) (refl_equal _)).

    intro H0. rewrite (MapCard_Remove_1 m a (sym_eq H0)) in H. discriminate H.

    intro H0. rewrite H0. reflexivity.

  Qed.



  Lemma MapMerge_Restr_Card :

   forall m m':Map A,

     MapCard A m + MapCard A m' =

     MapCard A (MapMerge A m m') + MapCard A (MapDomRestrTo A A m m').

  Proof.

    simple induction m. simpl in |- *. intro. apply plus_n_O.

    simpl in |- *. intros a y m'. elim (option_sum A (MapGet A m' a)). intro H. elim H. intros y0 H0.

    rewrite H0. rewrite MapCard_Put_behind_Put. rewrite (MapCard_Put_1_conv m' a y0 y H0).

    simpl in |- *. rewrite <- plus_Snm_nSm. apply plus_n_O.

    intro H. rewrite H. rewrite MapCard_Put_behind_Put. rewrite (MapCard_Put_2_conv m' a y H).

    apply plus_n_O.

    intros.

    change

      (MapCard A m0 + MapCard A m1 + MapCard A m' =

       MapCard A (MapMerge A (M2 A m0 m1) m') +

       MapCard A (MapDomRestrTo A A (M2 A m0 m1) m')) 

     in |- *.

    elim m'. reflexivity.

    intros a y. unfold MapMerge in |- *. unfold MapDomRestrTo in |- *.

    elim (option_sum A (MapGet A (M2 A m0 m1) a)). intro H1. elim H1. intros y0 H2. rewrite H2.

    rewrite (MapCard_Put_1_conv (M2 A m0 m1) a y0 y H2). reflexivity.

    intro H1. rewrite H1. rewrite (MapCard_Put_2_conv (M2 A m0 m1) a y H1). simpl in |- *.

    rewrite <- (plus_Snm_nSm (MapCard A m0 + MapCard A m1) 0). reflexivity.

    intros. simpl in |- *.

    rewrite

     (plus_permute_2_in_4 (MapCard A m0) (MapCard A m1) (

        MapCard A m2) (MapCard A m3)).

    rewrite (H m2). rewrite (H0 m3).

    rewrite

     (MapCard_makeM2 (MapDomRestrTo A A m0 m2) (MapDomRestrTo A A m1 m3))

     .

    apply plus_permute_2_in_4.

  Qed.



  Lemma MapMerge_disjoint_Card :

   forall m m':Map A,

     MapDisjoint A A m m' ->

     MapCard A (MapMerge A m m') = MapCard A m + MapCard A m'.

  Proof.

    intros. rewrite (MapMerge_Restr_Card m m').

    rewrite (MapCard_ext _ _ (MapDisjoint_imp_2 _ _ _ _ H)). apply plus_n_O.

  Qed.



  Lemma MapSplit_Card :

   forall (m:Map A) (m':Map B),

     MapCard A m =

     MapCard A (MapDomRestrTo A B m m') + MapCard A (MapDomRestrBy A B m m').

  Proof.

    intros. rewrite (MapCard_ext _ _ (MapDom_Split_1 A B m m')). apply MapMerge_disjoint_Card.

    apply MapDisjoint_2_imp. unfold MapDisjoint_2 in |- *. apply MapDom_Split_3.

  Qed.



  Lemma MapMerge_Card_ub :

   forall m m':Map A,

     MapCard A (MapMerge A m m') <= MapCard A m + MapCard A m'.

  Proof.

    intros. rewrite MapMerge_Restr_Card. apply le_plus_l.

  Qed.



  Lemma MapDomRestrTo_Card_ub_l :

   forall (m:Map A) (m':Map B),

     MapCard A (MapDomRestrTo A B m m') <= MapCard A m.

  Proof.

    intros. rewrite (MapSplit_Card m m'). apply le_plus_l.

  Qed.



  Lemma MapDomRestrBy_Card_ub_l :

   forall (m:Map A) (m':Map B),

     MapCard A (MapDomRestrBy A B m m') <= MapCard A m.

  Proof.

    intros. rewrite (MapSplit_Card m m'). apply le_plus_r.

  Qed.



  Lemma MapMerge_Card_disjoint :

   forall m m':Map A,

     MapCard A (MapMerge A m m') = MapCard A m + MapCard A m' ->

     MapDisjoint A A m m'.

  Proof.

    simple induction m. intros. apply Map_M0_disjoint.

    simpl in |- *. intros. rewrite (MapCard_Put_behind_Put m' a a0) in H. unfold MapDisjoint, in_dom in |- *.

    simpl in |- *. intros. elim (sumbool_of_bool (Neqb a a1)). intro H2.

    rewrite (Neqb_complete _ _ H2) in H. rewrite (MapCard_Put_2 m' a1 a0 H) in H1.

    discriminate H1.

    intro H2. rewrite H2 in H0. discriminate H0.

    simple induction m'. intros. apply Map_disjoint_M0.

    intros a y H1. rewrite <- (MapCard_ext _ _ (MapPut_as_Merge A (M2 A m0 m1) a y)) in H1.

    unfold MapCard at 3 in H1. rewrite <- (plus_Snm_nSm (MapCard A (M2 A m0 m1)) 0) in H1.

    rewrite <- (plus_n_O (S (MapCard A (M2 A m0 m1)))) in H1. unfold MapDisjoint, in_dom in |- *.

    unfold MapGet at 2 in |- *. intros. elim (sumbool_of_bool (Neqb a a0)). intro H4.

    rewrite <- (Neqb_complete _ _ H4) in H2. rewrite (MapCard_Put_2 _ _ _ H1) in H2.

    discriminate H2.

    intro H4. rewrite H4 in H3. discriminate H3.

    intros. unfold MapDisjoint in |- *. intros. elim (sumbool_of_bool (Nbit0 a)). intro H6.

    unfold MapDisjoint in H0. apply H0 with (m' := m3) (a := Ndiv2 a). apply le_antisym.

    apply MapMerge_Card_ub.

    apply (fun p n m:nat => plus_le_reg_l n m p) with

     (p := MapCard A m0 + MapCard A m2).

    rewrite

     (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) (

        MapCard A m1) (MapCard A m3)).

    change

      (MapCard A (M2 A (MapMerge A m0 m2) (MapMerge A m1 m3)) =

       MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) 

     in H3.

    rewrite <- H3. simpl in |- *. apply plus_le_compat_r. apply MapMerge_Card_ub.

    elim (in_dom_some _ _ _ H4). intros y H7. rewrite (MapGet_M2_bit_0_1 _ a H6 m0 m1) in H7.

    unfold in_dom in |- *. rewrite H7. reflexivity.

    elim (in_dom_some _ _ _ H5). intros y H7. rewrite (MapGet_M2_bit_0_1 _ a H6 m2 m3) in H7.

    unfold in_dom in |- *. rewrite H7. reflexivity.

    intro H6. unfold MapDisjoint in H. apply H with (m' := m2) (a := Ndiv2 a). apply le_antisym.

    apply MapMerge_Card_ub.

    apply (fun p n m:nat => plus_le_reg_l n m p) with

     (p := MapCard A m1 + MapCard A m3).

    rewrite

     (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A m0 + MapCard A m2))

     .

    rewrite

     (plus_permute_2_in_4 (MapCard A m0) (MapCard A m2) (

        MapCard A m1) (MapCard A m3)).

    rewrite

     (plus_comm (MapCard A m1 + MapCard A m3) (MapCard A (MapMerge A m0 m2)))

     .

    change

      (MapCard A (MapMerge A m0 m2) + MapCard A (MapMerge A m1 m3) =

       MapCard A m0 + MapCard A m1 + (MapCard A m2 + MapCard A m3)) 

     in H3.

    rewrite <- H3. apply plus_le_compat_l. apply MapMerge_Card_ub.

    elim (in_dom_some _ _ _ H4). intros y H7. rewrite (MapGet_M2_bit_0_0 _ a H6 m0 m1) in H7.

    unfold in_dom in |- *. rewrite H7. reflexivity.

    elim (in_dom_some _ _ _ H5). intros y H7. rewrite (MapGet_M2_bit_0_0 _ a H6 m2 m3) in H7.

    unfold in_dom in |- *. rewrite H7. reflexivity.

  Qed.



  Lemma MapCard_is_Sn :

   forall (m:Map A) (n:nat),

     MapCard _ m = S n -> {a : ad | in_dom _ a m = true}.

  Proof.

    simple induction m. intros. discriminate H.

    intros a y n H. split with a. unfold in_dom in |- *. rewrite (M1_semantics_1 _ a y). reflexivity.

    intros. simpl in H1. elim (O_or_S (MapCard _ m0)). intro H2. elim H2. intros m2 H3.

    elim (H _ (sym_eq H3)). intros a H4. split with (Ndouble a). unfold in_dom in |- *.

    rewrite (MapGet_M2_bit_0_0 A (Ndouble a) (Ndouble_bit0 a) m0 m1).

    rewrite (Ndouble_div2 a). elim (in_dom_some _ _ _ H4). intros y H5. rewrite H5. reflexivity.

    intro H2. rewrite <- H2 in H1. simpl in H1. elim (H0 _ H1). intros a H3.

    split with (Ndouble_plus_one a). unfold in_dom in |- *.

    rewrite

     (MapGet_M2_bit_0_1 A (Ndouble_plus_one a) (Ndouble_plus_one_bit0 a)

        m0 m1).

    rewrite (Ndouble_plus_one_div2 a). elim (in_dom_some _ _ _ H3). intros y H4. rewrite H4.

    reflexivity.

  Qed.



End MapCard.



Section MapCard2.



  Variables A B : Type.



  Lemma MapSubset_card_eq_1 :

   forall (n:nat) (m:Map A) (m':Map B),

     MapSubset _ _ m m' ->

     MapCard _ m = n -> MapCard _ m' = n -> MapSubset _ _ m' m.

  Proof.

    simple induction n. intros. unfold MapSubset, in_dom in |- *. intro. rewrite (MapCard_is_O _ m H0 a).

    rewrite (MapCard_is_O _ m' H1 a). intro H2. discriminate H2.

    intros. elim (MapCard_is_Sn A m n0 H1). intros a H3. elim (in_dom_some _ _ _ H3).

    intros y H4. elim (in_dom_some _ _ _ (H0 _ H3)). intros y' H6.

    cut (eqmap _ (MapPut _ (MapRemove _ m a) a y) m). intro.

    cut (eqmap _ (MapPut _ (MapRemove _ m' a) a y') m'). intro.

    apply MapSubset_ext with

     (m0 := MapPut _ (MapRemove _ m' a) a y')

     (m2 := MapPut _ (MapRemove _ m a) a y).

    assumption.

    assumption.

    apply MapSubset_Put_mono. apply H. apply MapSubset_Remove_mono. assumption.

    rewrite <- (MapCard_Remove_2_conv _ m a y H4) in H1. inversion_clear H1. reflexivity.

    rewrite <- (MapCard_Remove_2_conv _ m' a y' H6) in H2. inversion_clear H2. reflexivity.

    unfold eqmap, eqm in |- *. intro. rewrite (MapPut_semantics _ (MapRemove B m' a) a y' a0).

    elim (sumbool_of_bool (Neqb a a0)). intro H7. rewrite H7. rewrite <- (Neqb_complete _ _ H7).

    apply sym_eq. assumption.

    intro H7. rewrite H7. rewrite (MapRemove_semantics _ m' a a0). rewrite H7. reflexivity.

    unfold eqmap, eqm in |- *. intro. rewrite (MapPut_semantics _ (MapRemove A m a) a y a0).

    elim (sumbool_of_bool (Neqb a a0)). intro H7. rewrite H7. rewrite <- (Neqb_complete _ _ H7).

    apply sym_eq. assumption.

    intro H7. rewrite H7. rewrite (MapRemove_semantics A m a a0). rewrite H7. reflexivity.

  Qed.



  Lemma MapDomRestrTo_Card_ub_r :

   forall (m:Map A) (m':Map B),

     MapCard A (MapDomRestrTo A B m m') <= MapCard B m'.

  Proof.

    simple induction m. intro. simpl in |- *. apply le_O_n.

    intros a y m'. simpl in |- *. elim (option_sum B (MapGet B m' a)). intro H. elim H. intros y0 H0.

    rewrite H0. elim (MapCard_is_not_O B m' a y0 H0). intros n H1. rewrite H1. simpl in |- *.

    apply le_n_S. apply le_O_n.

    intro H. rewrite H. simpl in |- *. apply le_O_n.

    simple induction m'. simpl in |- *. apply le_O_n.



    intros a y. unfold MapDomRestrTo in |- *. case (MapGet A (M2 A m0 m1) a). simpl in |- *. 

    intro. simpl in |- *. apply le_n.

    apply le_O_n.

    intros. simpl in |- *. rewrite

  (MapCard_makeM2 A (MapDomRestrTo A B m0 m2) (MapDomRestrTo A B m1 m3))

  .

    apply plus_le_compat. apply H.

    apply H0.

  Qed.



End MapCard2.



Section MapCard3.



  Variables A B : Type.



  Lemma MapMerge_Card_lb_l :

   forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m.

  Proof.

    unfold ge in |- *. intros. apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m')).

    rewrite (plus_comm (MapCard A m') (MapCard A m)).

    rewrite (plus_comm (MapCard A m') (MapCard A (MapMerge A m m'))).

    rewrite (MapMerge_Restr_Card A m m'). apply plus_le_compat_l. apply MapDomRestrTo_Card_ub_r.

  Qed.



  Lemma MapMerge_Card_lb_r :

   forall m m':Map A, MapCard A (MapMerge A m m') >= MapCard A m'.

  Proof.

    unfold ge in |- *. intros. apply ((fun p n m:nat => plus_le_reg_l n m p) (MapCard A m)). rewrite (MapMerge_Restr_Card A m m').

    rewrite

     (plus_comm (MapCard A (MapMerge A m m'))

        (MapCard A (MapDomRestrTo A A m m'))).

    apply plus_le_compat_r. apply MapDomRestrTo_Card_ub_l.

  Qed.



  Lemma MapDomRestrBy_Card_lb :

   forall (m:Map A) (m':Map B),

     MapCard B m' + MapCard A (MapDomRestrBy A B m m') >= MapCard A m.

  Proof.

    unfold ge in |- *. intros. rewrite (MapSplit_Card A B m m'). apply plus_le_compat_r.

    apply MapDomRestrTo_Card_ub_r.

  Qed.



  Lemma MapSubset_Card_le :

   forall (m:Map A) (m':Map B),

     MapSubset A B m m' -> MapCard A m <= MapCard B m'.

  Proof.

    intros. apply le_trans with (m := MapCard B m' + MapCard A (MapDomRestrBy A B m m')).

    exact (MapDomRestrBy_Card_lb m m').

    rewrite (MapCard_ext _ _ _ (MapSubset_imp_2 _ _ _ _ H)). simpl in |- *. rewrite <- plus_n_O.

    apply le_n.

  Qed.



  Lemma MapSubset_card_eq :

   forall (m:Map A) (m':Map B),

     MapSubset _ _ m m' ->

     MapCard _ m' <= MapCard _ m -> eqmap _ (MapDom _ m) (MapDom _ m').

  Proof.

    intros. apply MapSubset_antisym. assumption.

    cut (MapCard B m' = MapCard A m). intro. apply (MapSubset_card_eq_1 A B (MapCard A m)).

    assumption.

    reflexivity.

    assumption.

    apply le_antisym. assumption.

    apply MapSubset_Card_le. assumption.

  Qed.



End MapCard3.
