
Require Export Jordan2. 
(* Jordan2:
Require Export Jordan1. 
Require Euclid.
Require Compare.
Require Recdef.
Require Arith.

Inductive set:Set:=
    Vs : set | Is : set -> dart -> set.

Fixpoint exds(s:set)(z:dart){struct s}:Prop:=
  match s with
     Vs => False
   | Is s0 x => x=z \/ exds s0 z
  end.

Lemma exds_dec: forall(s:set)(z:dart),
  {exds s z}+{~exds s z}.

Lemma not_exds_Vs: forall s:set,
  (forall z:dart, ~exds s z) -> s = Vs.

Lemma not_exds_diff: forall(s:set)(z:dart),
  ~exds s z -> 
    forall(t:dart), exds s t -> z <> t.

Fixpoint Ds(s:set)(z:dart){struct s}:set:=
  match s with
     Vs => Vs
   | Is s0 x =>
       if eq_dart_dec x z then (Ds s0 z)
       else Is (Ds s0 z) x
  end.

Lemma not_exds_Ds:forall(s:set)(z:dart),
   ~exds (Ds s z) z.

Lemma exds_Ds:forall(s:set)(x z:dart),
   x <> z ->
     (exds s z <-> exds (Ds s x) z).

Lemma exds_Ds_diff:forall(s:set)(x z:dart),
   exds (Ds s x) z -> x <> z.

Lemma Ds_s:forall(s:set)(z:dart),
  ~exds s z <-> Ds s z = s.

Lemma not_exds_Ds_bis:forall(s:set)(x z:dart),
   ~exds s z -> ~exds (Ds s x) z.

Lemma exds_Ds_exds:forall(s:set)(x z:dart),
   exds (Ds s x) z -> exds s z.

Fixpoint card(s:set):nat:=
  match s with
     Vs => 0%nat
   | Is s0 x => 
       if exds_dec s0 x then card s0
       else (1 + card s0)%nat
  end.

Lemma card_Ds:forall (s:set)(z:dart),
  (card (Ds s z) <= card s)%nat.

Lemma not_exds_card_Ds:forall (s:set)(z:dart),
  ~exds s z -> card (Ds s z) = card s.

Lemma exds_card_pos:forall (s:set)(z:dart),
  exds s z -> (0 < card s)%nat.

Lemma exds_card_Ds:forall (s:set)(z:dart),
  exds s z -> card (Ds s z) = (card s - 1)%nat.

Lemma exds_card_Ds_inf:forall (s:set)(z:dart),
  exds s z -> (card (Ds s z) < card s)%nat.

Fixpoint fmap_to_set(m:fmap):set:=
 match m with
     V => Vs
   | I m0 x _ _ => Is (fmap_to_set m0) x
   | L m0 _ _ _ => (fmap_to_set m0)
 end.

Lemma exd_exds:forall(m:fmap)(z:dart),
  exd m z <-> exds (fmap_to_set m) z.

Fixpoint ndN (m:fmap):nat:=
 match m with
    V => 0%nat
  | I m0 x _ _ => 
       if exd_dec m0 x then ndN m0
       else (1 + ndN m0)%nat
  | L m0 _ _ _ => ndN m0
 end.

Lemma nd_card:forall(m:fmap),
  ndN m = card (fmap_to_set m).

Fixpoint set_minus(s1 s2:set){struct s1}:set:=
 match s1 with
     Vs => Vs
   | Is s0 x =>
       if exds_dec s2 x then set_minus s0 s2
       else Is (set_minus s0 s2) x
 end.

Lemma not_exds_minus: forall(s1 s2:set)(z:dart),
  ~ exds s1 z ->
     ~ exds (set_minus s1 s2) z.

Lemma exds_set_minus: forall(s1 s2:set)(z:dart),
  exds s1 z -> ~exds s2 z ->
     exds (set_minus s1 s2) z.

Lemma not_exds_set_minus: forall(s1 s2:set)(z:dart),
  exds s2 z -> ~exds (set_minus s1 s2) z.

Lemma exds_set_minus_eq:forall(s1 s2:set)(z:dart),
  (exds s1 z /\ ~exds s2 z) <-> exds (set_minus s1 s2) z.

Inductive incls(s1 s2:set):Prop:=
  exds2 : (forall z:dart, exds s1 z -> exds s2 z) 
          -> incls s1 s2.

Lemma set_minus_s_Ds :forall(s1 s2:set)(x:dart), 
  ~ exds s1 x -> exds s2 x -> 
     set_minus s1 (Ds s2 x) = set_minus s1 s2. 

Lemma card_minus_set:forall(s1 s2:set),
  incls s2 s1 -> 
    (card (set_minus s1 s2) + card s2 = card s1)%nat.

Definition impls(s1 s2:set):Prop:=
  forall z:dart, exds s1 z -> exds s2 z.

Definition eqs(s1 s2:set):Prop:=
  forall z:dart, exds s1 z <-> exds s2 z.

Definition disjs(s1 s2:set):Prop:=
  forall z:dart, exds s1 z -> exds s2 z -> False.

Definition Rs(sy sx:set):=
  (card sy < card sx)%nat.

Lemma Acc_set:forall s:set, Acc Rs s.

Lemma Rs_wf : well_founded Rs.

Lemma exds_Rs_Ds:
 forall(s:set)(z:dart),
   exds s z -> Rs (Ds s z) s.

Fixpoint Iter(g:dart->dart)(n:nat)(z:dart){struct n}:dart:=
  match n with
    0%nat => z
  | S n0 => g (Iter g n0 z)
 end.

Module Type Sigf.

Parameter f : fmap -> dart -> dart.
Parameter f_1 : fmap -> dart -> dart.
Axiom exd_f:forall (m:fmap)(z:dart),
  inv_hmap m -> (exd m z <-> exd m (f m z)).
Axiom bij_f : forall m:fmap, 
  inv_hmap m -> bij_dart (exd m) (f m).
Axiom exd_f_1:forall (m:fmap)(z:dart),
  inv_hmap m -> (exd m z <-> exd m (f_1 m z)).
Axiom bij_f_1 : forall m:fmap, 
  inv_hmap m -> bij_dart (exd m) (f_1 m).
Axiom f_1_f : forall (m:fmap)(z:dart), 
  inv_hmap m -> exd m z -> f_1 m (f m z) = z.
Axiom f_f_1 : forall (m:fmap )(z:dart), 
  inv_hmap m -> exd m z -> f m (f_1 m z) = z.
End Sigf.

Module Mf(M:Sigf)<:Sigf 
   with Definition f:=M.f
   with Definition f_1:=M.f_1.
Definition f:=M.f.
Definition f_1:=M.f_1.
Definition exd_f:=M.exd_f.
Definition exd_f_1:=M.exd_f_1.
Definition bij_f:=M.bij_f.
Definition bij_f_1:=M.bij_f_1.
Definition f_1_f:=M.f_1_f.
Definition f_f_1:=M.f_f_1.

Lemma exd_Iter_f:forall(m:fmap)(n:nat)(z:dart),
  inv_hmap m -> (exd m z <-> exd m (Iter (f m) n z)).

Lemma exd_Iter_f_1:forall(m:fmap)(n:nat)(z:dart),
  inv_hmap m -> (exd m z <-> exd m (Iter (f_1 m) n z)).

Theorem Iter_rem_F :
 forall (m:fmap)(z:dart),
  forall sx: set, (forall sy: set, Rs sy sx -> set)
    -> set.

Definition Iter_rem_aux(m:fmap)(z:dart):
  set -> set
 := Fix Rs_wf (fun _:set => set) (Iter_rem_F m z).

Definition Iter_upb_aux(m:fmap)(z:dart)(s:set):nat:=
  ((ndN m) - (card (Iter_rem_aux m z s)))%nat.

Definition Iter_rem(m:fmap)(z:dart):set:=
  Iter_rem_aux m z (fmap_to_set m).

Definition Iter_upb(m:fmap)(z:dart):nat:=
  ((ndN m) - (card (Iter_rem m z)))%nat.

Definition Iter_orb_aux(m:fmap)(z:dart)(s:set):set:=
  set_minus (fmap_to_set m) (Iter_rem_aux m z s).

Definition Iter_orb(m:fmap)(z:dart):set:=
  set_minus (fmap_to_set m) (Iter_rem m z).

Theorem Iter_rem_aux_equation :
  forall(m:fmap)(z:dart)(sx:set),
  Iter_rem_aux m z sx =
    let n := ((ndN m) - (card sx))%nat in
    let zn := Iter (f m) n z in
    if exds_dec sx zn
    then Iter_rem_aux m z (Ds sx zn)
    else sx.

Definition P1
 (m:fmap)(z:dart)(s:set):Prop:=
    let sr := Iter_rem_aux m z s in
    let n := Iter_upb_aux m z s in
    ~ exds sr (Iter (f m) n z).

Lemma not_exds_rem_upb :
  forall(m:fmap)(z:dart)(s:set),
   let sr := Iter_rem_aux m z s in
    let n := Iter_upb_aux m z s in
    ~ exds sr (Iter (f m) n z).

Lemma not_exds_Iter_rem_upb :
 forall(m:fmap)(z:dart),
  let n:= Iter_upb m z in
   ~ exds (Iter_rem m z) (Iter (f m) n z).

Lemma  exd_Iter_upb:
  forall(m:fmap)(z:dart), inv_hmap m ->
   exd m z -> exd m (Iter (f m) (Iter_upb m z) z).

Lemma exd_Iter_orb_upb :
 forall(m:fmap)(z:dart),
  inv_hmap m -> exd m z ->
   let n:= Iter_upb m z in
     exds (Iter_orb m z) (Iter (f m) n z).

Lemma exds_rem_orb:forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m t ->
  (~exds (Iter_rem m z) t <-> exds (Iter_orb m z) t).

Definition R3
 (m:fmap)(z t:dart)(s:set):Prop:=
  ~ exds s t ->
   let sr := Iter_rem_aux m z s in
    ~ exds sr t.

Lemma LR3:forall(m:fmap)(z t:dart)(s:set),
  ~ exds s t ->
   let sr := Iter_rem_aux m z s in
    ~ exds sr t.

Definition R2
 (m:fmap)(z:dart)(s:set):Prop:=
   let sr := Iter_rem_aux m z s in
    ~ exds sr (Iter (f m) (ndN m - card s)%nat z).

Lemma LR2 :
  forall(m:fmap)(z:dart)(s:set),
   let sr := Iter_rem_aux m z s in
    ~ exds sr (Iter (f m) (ndN m - card s)%nat z).

Definition R1
 (m:fmap)(z:dart)(i:nat)(s:set):Prop:=
   let sr := Iter_rem_aux m z s in
   let n := Iter_upb_aux m z s in
      (ndN m - card s <= i <= n)%nat -> 
       ~ exds sr (Iter (f m) i z).
Lemma LR1 :
  forall(m:fmap)(z:dart)(i:nat)(s:set),
   let sr := Iter_rem_aux m z s in
   let n := Iter_upb_aux m z s in
     (ndN m - card s <= i <= n)%nat -> 
      ~ exds sr (Iter (f m) i z).

Lemma not_exds_Iter_f_i :
  forall(m:fmap)(z:dart)(i:nat),
   let sr := Iter_rem m z in
   let n := Iter_upb m z in
     (i <= n)%nat -> ~ exds sr (Iter (f m) i z).

Lemma exds_Iter_f_i :
  forall(m:fmap)(z:dart)(i:nat),
  inv_hmap m -> exd m z ->
   let s := Iter_orb m z in
   let n := Iter_upb m z in
     (i <= n)%nat -> exds s (Iter (f m) i z).

Definition P2
 (m:fmap)(z:dart)(s:set):Prop:=
  (card s < ndN m ->
    card (Iter_rem_aux m z s) < ndN m)%nat.

Lemma card_rem_aux:forall(m:fmap)(z:dart)(s:set),
  (card s < ndN m ->
    card (Iter_rem_aux m z s) < ndN m)%nat.

Definition P2_bis
 (m:fmap)(z:dart)(s:set):Prop:=
  (card s <= ndN m ->
    card (Iter_rem_aux m z s) <= ndN m)%nat.

Lemma card_rem_aux_bis:forall(m:fmap)(z:dart)(s:set),
   (card s <= ndN m ->
    card (Iter_rem_aux m z s) <= ndN m)%nat.

Lemma upb_pos_aux:forall(m:fmap)(z:dart),
  exd m z ->
      (card (Iter_rem m z) < ndN m)%nat.

Theorem upb_pos:forall(m:fmap)(z:dart),
  exd m z -> (0 < Iter_upb m z)%nat.

Definition Q1(m:fmap)(z:dart)(s:set):Prop:=
   (card (Iter_rem_aux m z s) <= card s)%nat.

Lemma LQ1:forall(m:fmap)(z:dart)(s:set),
   (card (Iter_rem_aux m z s) <= card s)%nat.

Definition Q2(m:fmap)(z:dart)(s:set):Prop:=
  exds s (Iter (f m) (ndN m - card s)%nat z) ->
      (card (Iter_rem_aux m z s) < card s)%nat.

Lemma LQ2:forall(m:fmap)(z:dart)(s:set),
  exds s (Iter (f m) (ndN m - card s) z) ->
      (card (Iter_rem_aux m z s) < card s)%nat.

Definition PL2(m:fmap)(z t:dart)(x:set):Prop:=
  inv_hmap m -> exd m z -> exds x t ->
    let sr:= Iter_rem_aux m z x in
    let zn0 := (Iter (f m) (ndN m - card x)%nat z) in
    ~exds sr t -> 
       exds x zn0 -> 
        ~ exds (Iter_rem_aux m z (Ds x zn0)) t.

Lemma L2:forall(m:fmap)(z t:dart)(x:set),
  inv_hmap m -> exd m z -> exds x t ->
    let sr:= Iter_rem_aux m z x in
    let zn0 := (Iter (f m) (ndN m - card x)%nat z) in
    ~exds sr t -> 
       exds x zn0 -> 
        ~ exds (Iter_rem_aux m z (Ds x zn0)) t.

Definition PL3(m:fmap)(z t:dart)(x:set):Prop:=
  inv_hmap m -> exd m z -> exds x t ->
    let sr:= Iter_rem_aux m z x in
    let zn0 := (Iter (f m) (ndN m - card x)%nat z) in
    ~exds sr t -> 
       exds x zn0.

Lemma L3:forall(m:fmap)(z t:dart)(x:set),
  inv_hmap m -> exd m z -> exds x t ->
    let sr:= Iter_rem_aux m z x in
    let zn0 := (Iter (f m) (ndN m - card x)%nat z) in
    ~exds sr t -> 
       exds x zn0. 

Definition P4(m:fmap)(z t:dart)(s:set):Set:=
 inv_hmap m -> exd m z -> exds s t ->
   (card s <= ndN m)%nat ->
   let sr:= Iter_rem_aux m z s in
   let nr:= Iter_upb_aux m z s in
   ~ exds sr t ->
      {i:nat | (i < nr)%nat /\ Iter (f m) i z = t}.

Lemma ex_i_aux :forall(m:fmap)(z t:dart)(s:set),
 inv_hmap m -> exd m z -> exds s t ->
   (card s <= ndN m)%nat ->
   let sr:= Iter_rem_aux m z s in
   let nr:= Iter_upb_aux m z s in
   ~ exds sr t ->
      {i:nat | (i < nr)%nat /\ Iter (f m) i z = t}.

Lemma ex_i :forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m z -> exd m t ->
   let sr:= Iter_rem m z in
   let nr:= Iter_upb m z in
   ~ exds sr t ->
      {i : nat | (i < nr)%nat /\ Iter (f m) i z = t}.

Lemma ex_i_upb :forall(m:fmap)(z:dart),
 inv_hmap m -> exd m z -> 
   let nr:= Iter_upb m z in
 {i : nat | (i < nr)%nat /\ Iter (f m) i z = Iter (f m) nr z}.

Lemma Iter_plus:forall(m:fmap)(z:dart)(p i:nat),
 inv_hmap m -> exd m z -> 
   Iter (f m) (p + i)%nat z = Iter (f m) i z -> 
      Iter (f m) p z = z.

Lemma Iter_plus_inv:forall(m:fmap)(z:dart)(p i:nat),
 inv_hmap m -> exd m z -> 
   Iter (f m) p z = z -> 
     Iter (f m) (p + i)%nat z = Iter (f m) i z.

Lemma Iter_mult:forall(m:fmap)(z:dart)(n p:nat),
 inv_hmap m -> exd m z -> 
     Iter (f m) p z = z ->  Iter (f m) (n*p)%nat z = z.

Lemma Iter_plus_mult:forall(m:fmap)(z:dart)(n p i:nat),
 inv_hmap m -> exd m z -> 
    Iter (f m) p z = z -> 
      Iter (f m) (i + n*p)%nat z = Iter (f m) i z.

Lemma Iter_comp:forall(m:fmap)(i j:nat)(z:dart),
  Iter (f m) (i+j)%nat z = Iter (f m) i (Iter (f m) j z).

Lemma f_1_Iter_f:forall(m:fmap)(i:nat)(z:dart),
  inv_hmap m -> exd m z ->
    (f_1 m) (Iter (f m) (S i) z) = Iter (f m) i z.

Lemma Iter_f_f_1  :forall(m:fmap)(i j:nat)(z:dart),
  inv_hmap m -> exd m z -> (j <= i)%nat ->
    Iter (f_1 m) j (Iter (f m) i z) = 
        Iter (f m) (i - j)%nat z.

Lemma Iter_f_f_1_i:forall(m:fmap)(i:nat)(z:dart),
  inv_hmap m -> exd m z -> 
    Iter (f_1 m) i (Iter (f m) i z) = z. 

Lemma Iter_f_Si:forall(m:fmap)(i:nat)(z:dart),
  inv_hmap m -> exd m z -> 
    Iter (f m) (S i) z = Iter (f m) i (f m z).

Lemma Iter_f_1_Si:forall(m:fmap)(i:nat)(z:dart),
  inv_hmap m -> exd m z -> 
    Iter (f_1 m) (S i) z = Iter (f_1 m) i (f_1 m z).
   
Definition diff_int_aux
  (m:fmap)(z:dart)(a b:nat)(t:dart): Prop:=
   forall i : nat, (a <= i <= b)%nat -> 
     Iter (f m) i z <> t.

Lemma diff_int_aux_dec:forall(m:fmap)(z:dart)(a b:nat)(t:dart),
  {diff_int_aux m z a b t} + {~diff_int_aux m z a b t}.

Definition diff_int
  (m:fmap)(z:dart)(a b:nat): Prop:=
   forall i j : nat, (a <= i /\ i < j /\ j <= b)%nat -> 
     Iter (f m) i z <> Iter (f m) j z.

Lemma diff_int_le:forall(m:fmap)(z:dart)(a b:nat),
  (b <= a)%nat -> diff_int m z a b.

Lemma diff_int_dec:forall(m:fmap)(z:dart)(a b:nat),
  {diff_int m z a b} + {~diff_int m z a b}.

Definition exds_int(m:fmap)(z:dart)(a b:nat)(s:set):Prop:=
  forall i:nat, (a <= i <= b)%nat ->  
    exds s (Iter (f m) i z).

Lemma exds_int_gt:forall(m:fmap)(z:dart)(a b:nat)(s:set),
  (b < a)%nat -> exds_int m z a b s.

Lemma exds_int_dec : forall(m:fmap)(z:dart)(a b:nat)(s:set),
  {exds_int m z a b s} + {~exds_int m z a b s}.

Lemma rem_1_step :forall(m:fmap)(z:dart)(s:set),
 inv_hmap m ->  
   let sr:= Iter_rem_aux m z s in
   let nr:= Iter_upb_aux m z s in
     (card sr + 1 <= card s <-> 
       exds s (Iter (f m) (ndN m - card s) z))%nat. 

Lemma rem_2_steps :forall(m:fmap)(z:dart)(s:set),
 inv_hmap m -> 
   let sr:= Iter_rem_aux m z s in
   let nr:= Iter_upb_aux m z s in
     (card sr + 2 <= card s -> 
       exds (Ds s (Iter (f m) (ndN m - card s) z)) 
         (Iter (f m) (ndN m + 1 - card s) z))%nat. 

Definition P6(m:fmap)(z:dart)(s:set):Prop:= 
 inv_hmap m ->
  (card s <= ndN m ->
   let n0:= ndN m - card s in
   let nr:= Iter_upb_aux m z s in
    exds s (Iter (f m) n0 z) -> 
      exds_int m z n0 (nr - 1) s)%nat.

Lemma LP6:forall(m:fmap)(z:dart)(s:set),
 inv_hmap m ->
  (card s <= ndN m ->
   let n0:= ndN m - card s in
   let nr:= Iter_upb_aux m z s in
    exds s (Iter (f m) n0 z) -> 
      exds_int m z n0 (nr - 1) s)%nat.

Definition P7(m:fmap)(z:dart)(s:set):Prop:= 
 inv_hmap m ->
  (card s <= ndN m ->
   let n0:= ndN m - card s in
   let nr:= Iter_upb_aux m z s in
   exds s (Iter (f m) n0 z) -> 
     forall j:nat, n0 < j <= nr - 1 ->
       Iter (f m) n0 z <> Iter (f m) j z)%nat.

Lemma LP7:forall(m:fmap)(z:dart)(s:set),
inv_hmap m ->
  (card s <= ndN m ->
   let n0:= ndN m - card s in
   let nr:= Iter_upb_aux m z s in
   exds s (Iter (f m) n0 z) -> 
     forall j:nat, n0 < j <= nr - 1 ->
       Iter (f m) n0 z <> Iter (f m) j z)%nat.

Definition P8(m:fmap)(z:dart)(s:set):Prop:= 
 inv_hmap m ->
  (card s <= ndN m ->
   let n0:= ndN m - card s in
   let nr:= Iter_upb_aux m z s in
    exds s (Iter (f m) n0 z) -> 
     diff_int m z n0 (nr - 1))%nat.

Lemma LP8:forall(m:fmap)(z:dart)(s:set),
 inv_hmap m ->
  (card s <= ndN m ->
   let n0:= ndN m - card s in
   let nr:= Iter_upb_aux m z s in
    exds s (Iter (f m) n0 z) -> 
     diff_int m z n0 (nr - 1))%nat.

Definition diff_orb(m:fmap)(z:dart):Prop:=
 let nr:= Iter_upb_aux m z (fmap_to_set m) in
  (diff_int m z 0 (nr - 1))%nat.

Theorem exd_diff_orb:forall(m:fmap)(z:dart),
   inv_hmap m -> exd m z ->
      diff_orb m z.

Theorem Iter_upb_period:forall(m:fmap)(z:dart),
 inv_hmap m -> exd m z ->
  let nr:= Iter_upb m z in
    Iter (f m) nr z = z.

Lemma Iter_period:forall(m:fmap)(z:dart)(i n:nat),
 inv_hmap m -> exd m z ->
  let p:= Iter_upb m z in
    Iter (f m) (i + n*p)%nat z = Iter (f m) i z.

Import Euclid.

Lemma mod_p:forall(m:fmap)(z:dart)(i:nat),
 inv_hmap m -> exd m z ->
  let p := Iter_upb m z in
   {j :nat | Iter (f m) i z  = Iter (f m) j z /\ (j < p)%nat}.

Export Compare.

Lemma period_uniform : forall(m:fmap)(z:dart)(i:nat),
 inv_hmap m -> exd m z ->
    Iter_upb m z = Iter_upb m (Iter (f m) i z).

Lemma unicity_mod_p:forall(m:fmap)(z:dart)(j k:nat),
 inv_hmap m -> exd m z ->
  let p := Iter_upb m z in
   (j < p)%nat -> (k < p)%nat -> 
    Iter (f m) j z = Iter (f m) k z -> j = k.

Definition expo(m:fmap)(z t:dart):Prop:=
   exd m z /\ exists i:nat, Iter (f m) i z = t.

Definition expo1
 (m:fmap)(z t:dart):Prop:=
   exd m z /\
     let p:= Iter_upb m z in 
       exists j:nat, (j < p)%nat /\ Iter (f m) j z = t.

Lemma expo_expo1: 
  forall(m:fmap)(z t:dart), inv_hmap m ->
    (expo m z t <-> expo1 m z t). 

Definition modulo(m:fmap)(z:dart)(i:dart)
    (hi:inv_hmap m)(he:exd m z):nat.

Lemma expo_exd:
  forall(m:fmap)(z t:dart),
   inv_hmap m -> expo m z t -> exd m t.

Lemma expo_refl:
  forall(m:fmap)(z:dart), exd m z -> expo m z z.

Lemma expo_trans:
  forall(m:fmap)(z t u:dart),
  expo m z t -> expo m t u -> expo m z u.

Lemma expo_symm:forall(m:fmap)(z t:dart),
  inv_hmap m -> 
     expo m z t -> expo m t z.

Fixpoint ex_j
 (m:fmap)(z t:dart)(n:nat){struct n}:Prop:=
match n with
   0%nat => z = t
 | S n0 => Iter (f m) n z = t \/ ex_j m z t n0
end. 

Lemma ex_j_dec:
 forall(m:fmap)(z t:dart)(n:nat),
  {ex_j m z t n} + {~ex_j m z t n}.

Lemma ex_j_exist_j:forall(m:fmap)(z t:dart)(n:nat),
  ex_j m z t n <-> 
     exists j :nat, (j <= n)%nat /\ Iter (f m) j z = t.

Lemma expo1_ex_j: 
  forall(m:fmap)(z t:dart), inv_hmap m -> exd m z ->
  let p:= Iter_upb m z in
    (ex_j m z t (p - 1)%nat <-> expo1 m z t).

Lemma expo1_dec : 
  forall (m:fmap)(z t:dart), 
   inv_hmap m -> exd m z ->
     {expo1 m z t} + {~expo1 m z t}.

Lemma expo_dec: forall(m:fmap)(z t:dart),
  inv_hmap m ->  
    {expo m z t} + {~expo m z t}.

Theorem period_expo : forall(m:fmap)(z t:dart),
 inv_hmap m -> expo m z t ->
    Iter_upb m z = Iter_upb m t.

Open Scope nat_scope. 

Theorem period_lub : forall(m:fmap)(z:dart),
 inv_hmap m -> exd m z ->
  let nr:= Iter_upb m z in
   0 < nr /\ Iter (f m) nr z = z /\
    forall i:nat, 0 < i < nr -> Iter (f m) i z <> z.

Import Recdef.

Open Scope nat_scope. 

Lemma ndN_pos:forall(m:fmap)(z:dart),
  exd m z -> 0 < ndN m.

Definition degree(m:fmap)(z:dart):= 
  degree_aux m z 1.

Definition P_degree_pos(m:fmap)(z:dart)(n1 n2:nat):
  Prop:= exd m z -> 0 < n1 -> 0 < n2.

Lemma degree_pos_aux:forall(m:fmap)(z:dart),
  P_degree_pos m z 1 (degree m z).

Theorem degree_pos:forall(m:fmap)(z:dart),
   exd m z -> 0 < degree m z.

Definition P_degree_diff(m:fmap)(z:dart)(n1 n2:nat):
  Prop:= inv_hmap m -> exd m z -> 0 < n1 ->  
    forall i:nat, n1 <= i < n2 -> Iter (f m) i z <> z.

Lemma degree_diff_aux:forall(m:fmap)(z:dart),
  P_degree_diff m z 1 (degree m z).

Theorem degree_diff: forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> 
    forall i:nat, 0 < i < (degree m z) -> 
       Iter (f m) i z <> z.

Lemma degree_bound: forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> degree m z <= ndN m.

Definition P_degree_per(m:fmap)(z:dart)(n1 n2:nat):
  Prop:= inv_hmap m -> exd m z -> 0 < n1 -> n2 <= ndN m ->  
   Iter (f m) n2 z = z.

Lemma degree_per_aux: forall(m:fmap)(z:dart),
    P_degree_per m z 1 (degree m z).

Theorem degree_per: forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> 
    Iter (f m) (degree m z) z = z.

Theorem degree_lub: forall(m:fmap)(z:dart),
 inv_hmap m -> exd m z ->
 let p:= degree m z in
   0 < p /\ Iter (f m) p z = z /\
    forall i:nat, 0 < i < p -> Iter (f m) i z <> z.

Import Arith.

Theorem upb_eq_degree:forall(m:fmap)(z:dart),
 inv_hmap m -> exd m z ->
   Iter_upb m z = degree m z. 

Theorem expo_degree : forall(m:fmap)(z t:dart),
 inv_hmap m -> expo m z t ->
    degree m z = degree m t.

Theorem degree_uniform : forall(m:fmap)(z:dart)(i:nat),
 inv_hmap m -> exd m z ->
    degree m z = degree m (Iter (f m) i z).

Theorem degree_unicity:forall(m:fmap)(z:dart)(j k:nat),
 inv_hmap m -> exd m z ->
  let p := degree m z in
   j < p -> k < p -> 
    Iter (f m) j z = Iter (f m) k z -> j = k.

Open Scope R_scope. 

Lemma incls_orbit:forall(m:fmap)(x:dart),
 inv_hmap m -> exd m x ->
  incls (Iter_orb m x) (fmap_to_set m).

Lemma exds_orb_exd:forall(m:fmap)(x z:dart),
 inv_hmap m -> exd m x ->
  exds (Iter_orb m x) z -> exd m z.

Lemma incls_rem:forall(m:fmap)(x:dart),
 inv_hmap m -> exd m x ->
  incls (Iter_rem m x) (fmap_to_set m).

Lemma card_orbit:forall(m:fmap)(x:dart),
  inv_hmap m -> exd m x ->
      card (Iter_orb m x) = Iter_upb m x.

Lemma exds_orb_ex :forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m z -> 
   let s:= Iter_orb m z in
   let p:= Iter_upb m z in
    exds s t ->
      {i : nat | (i < p)%nat /\ Iter (f m) i z = t}.

Theorem exds_orb_eq_ex :forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m z -> 
   let s:= Iter_orb m z in
   let p:= Iter_upb m z in
 (exds s t <-> 
      exists i:nat,(i < p)%nat /\ Iter (f m) i z = t).

Open Scope nat_scope.

Theorem exds_orb_eq_ex_large :forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m z -> 
   let s:= Iter_orb m z in
   let p:= Iter_upb m z in
 (exds s t <-> exists i:nat, Iter (f m) i z = t).

Theorem expo_eq_exds_orb :forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m z -> 
 (expo m z t <-> exds (Iter_orb m z) t).

Theorem expo1_eq_exds_orb :forall(m:fmap)(z t:dart),
 inv_hmap m -> exd m z -> 
 (expo1 m z t <-> exds (Iter_orb m z) t).

Lemma impls_orb:forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> 
    expo m x y -> 
     impls (Iter_orb m x) (Iter_orb m y).

Lemma eqs_orb:forall(m:fmap)(x y:dart),
  inv_hmap m ->  
    expo m x y -> 
     eqs (Iter_orb m x) (Iter_orb m y).

Lemma orb_impls_expo:forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> exd m y ->
     impls (Iter_orb m x) (Iter_orb m y) -> expo m x y.

Theorem expo_eq_eqs_orb:forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> exd m y ->
    (expo m x y <-> eqs (Iter_orb m x) (Iter_orb m y)).

Lemma disjs_orb:forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> exd m y -> 
   ~expo m x y -> 
     disjs (Iter_orb m x) (Iter_orb m y).

Lemma disjs_orb_not_expo:forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> exd m y -> 
   disjs (Iter_orb m x) (Iter_orb m y) -> ~expo m x y.

Theorem not_expo_disjs_orb:forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> exd m y -> 
   (~expo m x y <-> 
     disjs (Iter_orb m x) (Iter_orb m y)).

Lemma incls_minus: forall(m:fmap)(x y:dart),
  inv_hmap m -> exd m x -> exd m y -> 
   ~expo m x y ->
     let s:= fmap_to_set m in
     let sx:= Iter_orb m x in
     let sy:= Iter_orb m y in
      incls sy (set_minus s sx).

Open Scope nat_scope.

Theorem upb_sum_bound: forall(m:fmap)(x y:dart),
   inv_hmap m -> exd m x -> exd m y -> ~expo m x y ->
     Iter_upb m x + Iter_upb m y <= ndN m.

Theorem degree_sum_bound: forall(m:fmap)(x y:dart),
   inv_hmap m -> exd m x -> exd m y -> ~expo m x y ->
     degree m x + degree m y <= ndN m.

Open Scope R_scope.

Definition between(m:fmap)(z v t:dart):Prop:=
 inv_hmap m -> exd m z ->  
  exists i:nat, exists j:nat, 
   Iter (f m) i z = v /\
     Iter (f m) j z = t /\
       (i <= j < Iter_upb m z)%nat.

Lemma between_expo1:forall(m:fmap)(z v t:dart),
  inv_hmap m -> exd m z -> 
    between m z v t ->
      expo1 m z v /\ expo1 m z t. 

Lemma between_expo:forall(m:fmap)(z v t:dart),
  inv_hmap m -> exd m z -> 
    between m z v t ->
      expo m z v /\ expo m z t. 

Lemma between_expo_refl_1:forall(m:fmap)(z t:dart),
  inv_hmap m -> exd m z -> 
    (between m z z t <-> expo1 m z t). 

Lemma between_expo_refl_2:forall(m:fmap)(z t:dart),
  inv_hmap m -> exd m z -> 
    (between m z t t <-> expo1 m z t). 

Lemma expo_between_1:forall(m:fmap)(z t:dart),
  inv_hmap m -> exd m z -> 
    (expo1 m z t <-> between m z t (f_1 m z)).  

Lemma expo_between_3:forall(m:fmap)(x y z:dart),
  inv_hmap m -> expo1 m x y -> expo1 m x z -> 
    between m x z y \/ between m (f m y) z (f_1 m x). 

End Mf.

Module Type Sigd.
Parameter k:dim.
End Sigd.

Module McA(Md:Sigd)<:Sigf.
Definition f := fun(m:fmap)(z:dart) => cA m Md.k z.
Definition f_1 := fun(m:fmap)(z:dart) => cA_1 m Md.k z.
Definition exd_f := 
   fun(m:fmap)(z:dart) => exd_cA m Md.k z. 
Definition exd_f_1 := 
   fun(m:fmap)(z:dart) => exd_cA_1 m Md.k z. 
Definition bij_f := 
   fun(m:fmap)(h:inv_hmap m) => bij_cA m Md.k h.
Definition bij_f_1 := 
   fun(m:fmap)(h:inv_hmap m) => bij_cA_1 m Md.k h.
Definition f_1_f := fun(m:fmap)(z:dart) => cA_1_cA m Md.k z.
Definition f_f_1 := fun(m:fmap)(z:dart) => cA_cA_1 m Md.k z.
End McA.

Module Md0<:Sigd.
Definition k:=zero.
End Md0.

Module Md1<:Sigd.
Definition k:=one.
End Md1.

Module McA0:=McA Md0.

Module MA0:= Mf McA0.

Module McA1:=McA Md1.

Module MA1:= Mf McA1.

Definition F(m:fmap)(z:dart):=
  A_1 m one (A_1 m zero z).

Definition succf(m:fmap)(z:dart):Prop:=
  pred m zero z /\ pred m one (A_1 m zero z).

Lemma succf_dec :
  forall (m:fmap)(z:dart),
    {succf m z}+{~succf m z}.

Lemma succf_exd : forall (m:fmap)(z:dart),
  inv_hmap m -> succf m z -> exd m z.

Definition F_1 (m:fmap)(z:dart):=
  A m zero (A m one z).

Definition predf(m:fmap)(z:dart):Prop:=
  succ m one z /\ succ m zero (A m one z).

Lemma predf_dec :
  forall (m:fmap)(z:dart),
    {predf m z}+{~predf m z}.

Lemma predf_exd : forall (m:fmap)(z:dart),
  inv_hmap m -> predf m z -> exd m z.

Lemma F_nil : forall m:fmap,
    inv_hmap m -> F m nil = nil.

Lemma F_1_nil : forall m:fmap,
    inv_hmap m -> F_1 m nil = nil.

Lemma succf_exd_F : forall (m:fmap)(z:dart),
  inv_hmap m -> succf m z -> exd m (F m z).

Lemma predf_exd_F_1 : forall (m:fmap)(z:dart),
    inv_hmap m -> predf m z -> exd m (F_1 m z).

Lemma succf_F: forall (m:fmap)(z:dart),
  inv_hmap m -> (succf m z <-> F m z <> nil).

Lemma predf_F_1: forall (m:fmap)(z:dart),
  inv_hmap m -> (predf m z <-> F_1 m z <> nil).

Lemma not_exd_F_nil : forall (m:fmap)(z:dart),
    inv_hmap m -> ~exd m z -> F m z = nil.

Lemma not_exd_F_1_nil : forall (m:fmap)(z:dart),
    inv_hmap m -> ~exd m z -> F_1 m z = nil.

Lemma F_F_1 : forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> exd m (F_1 m z) ->
     F m (F_1 m z) = z.

Lemma F_1_F : forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> exd m (F m z) ->
    F_1 m (F m z) = z.

Lemma inj_F_succf :
   forall m:fmap, inv_hmap m ->
      inj_dart (succf m) (F m).

Lemma inj_F_1_predf :
 forall m:fmap, inv_hmap m ->
      inj_dart (predf m) (F_1 m).

Definition cF (m:fmap)(z:dart):=
  cA_1 m one (cA_1 m zero z).

Definition cF_1 (m:fmap)(z:dart):=
  cA m zero (cA m one z).

Lemma exd_cF_not_nil : forall (m:fmap)(z:dart),
  inv_hmap m -> (exd m z <-> cF m z <> nil).

Lemma exd_cF_1_not_nil : forall (m:fmap)(z:dart),
  inv_hmap m -> (exd m z <-> cF_1 m z <> nil).

Lemma exd_cF : forall (m:fmap)(z:dart),
  inv_hmap m -> (exd m z <-> exd m (cF m z)).

Lemma exd_cF_1 : forall (m:fmap)(z:dart),
  inv_hmap m -> (exd m z <-> exd m (cF_1 m z)).

Lemma inj_cF :
  forall (m:fmap), inv_hmap m ->
      inj_dart (exd m) (cF m).

Lemma inj_cF_1 :
  forall (m:fmap), inv_hmap m ->
    inj_dart (exd m) (cF_1 m).

Lemma cF_cF_1:forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> cF m (cF_1 m z) = z.

Lemma cF_1_cF:forall (m:fmap)(z:dart),
  inv_hmap m -> exd m z -> cF_1 m (cF m z) = z.

Lemma surj_cF :
  forall (m:fmap), inv_hmap m ->
      surj_dart (exd m) (cF m).

Lemma bij_cF :
  forall (m:fmap), inv_hmap m ->
      bij_dart (exd m) (cF m).

Lemma surj_cF_1 :
  forall (m:fmap), inv_hmap m ->
      surj_dart (exd m) (cF_1 m).

Lemma bij_cF_1 :
  forall (m:fmap), inv_hmap m ->
      bij_dart (exd m) (cF_1 m).

Module McF<:Sigf.
Definition f := cF.
Definition f_1 := cF_1.
Definition exd_f := exd_cF. 
Definition exd_f_1 := exd_cF_1. 
Definition bij_f := bij_cF.
Definition bij_f_1 := bij_cF_1.
Definition f_1_f := cF_1_cF.
Definition f_f_1 := cF_cF_1.
End McF.

Module MF:= Mf McF. *)

Fixpoint eqc(m:fmap)(x y:dart){struct m}:Prop:=
 match m with
     V => False
  |  I m0 x0 _ _ => x=x0 /\ y=x0 \/ eqc m0 x y
  |  L m0 _ x0 y0 =>
      eqc m0 x y
     \/ eqc m0 x x0 /\ eqc m0 y0 y
     \/ eqc m0 x y0 /\ eqc m0 x0 y
 end.

Lemma eqc_exd_exd : forall (m:fmap)(x y:dart),
  eqc m x y -> (exd m x /\ exd m y).
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   elim H.
  intro.
    decompose [and] H0.
    rewrite H1.
    rewrite H2.
    tauto.
  generalize (IHm x y).
    tauto.
 simpl in |- *.
   intros.
   generalize (IHm x y).
   generalize (IHm x d0).
   generalize (IHm x d1).
   generalize (IHm d1 y).
   generalize (IHm d0 y).
   tauto.
Qed.

Lemma eqc_dec: forall (m:fmap)(x y:dart),
   {eqc m x y} + {~eqc m x y}.
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   elim (IHm x y).
  tauto.
  elim (eq_dart_dec x d).
   elim (eq_dart_dec y d).
    tauto.
    tauto.
   tauto.
 simpl in |- *.
   intros x y.
   elim (IHm x y).
  tauto.
  elim (IHm x d0).
   elim (IHm d1 y).
    tauto.
    elim (IHm x d1).
     elim (IHm d0 y).
      tauto.
      tauto.
     tauto.
   elim (IHm d1 y).
    elim (IHm x d1).
     elim (IHm d0 y).
      tauto.
      tauto.
     tauto.
    elim (IHm x d1).
     elim (IHm d0 y).
      tauto.
      tauto.
     elim (IHm d0 y).
      tauto.
      tauto.
Qed.

Lemma eqc_refl: forall(m:fmap)(x:dart),
   exd m x -> eqc m x x.
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   generalize (IHm x).
   intro.
   assert (d = x -> x = d).
  intro.
    symmetry  in |- *.
    tauto.
  tauto.
 simpl in |- *.
   intros.
   generalize (IHm x).
   tauto.
Qed.

Lemma eqc_symm: forall(m:fmap)(x y:dart),
   eqc m x y -> eqc m y x.
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   elim H.
  tauto.
  intro.
    generalize (IHm x y).
    tauto.
 simpl in |- *.
   intros.
   elim H.
  left.
    apply IHm.
    tauto.
  clear H.
    intro.
    elim H.
   clear H.
     intro.
     right.
     right.
     split.
    apply IHm.
      tauto.
    apply IHm.
      tauto.
   intros.
     right.
     left.
     split.
    apply IHm; tauto.
    apply IHm; tauto.
Qed.

Lemma eqc_trans: forall(m:fmap)(x y z:dart),
   eqc m x y -> eqc m y z -> eqc m x z.
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   elim H.
  elim H0.
   tauto.
   intro.
     intros.
     elim H2.
     intros.
     rewrite H3.
     rewrite H4 in H1.
     tauto.
  intros.
    elim H0.
   intro.
     elim H2.
     intros.
     rewrite H4.
     rewrite H3 in H1.
     tauto.
   right.
     eapply IHm.
    apply H1.
      tauto.
 simpl in |- *.
   intros.
   elim H.
  clear H.
    elim H0.
   clear H0.
     left.
     eapply IHm.
    apply H0.
      tauto.
   clear H0.
     intros.
     elim H.
    clear H.
      intro.
      right.
      left.
      split.
     apply (IHm x y d0).
      tauto.
      tauto.
     tauto.
    intro.
      right.
      right.
      split.
     apply (IHm x y d1).
      tauto.
      tauto.
     tauto.
  clear H.
    intro.
    elim H.
   clear H.
     intro.
     elim H0.
    clear H0.
      intro.
      right.
      left.
      split.
     tauto.
     apply (IHm d1 y z).
      tauto.
      tauto.
    intros.
      elim H1.
     intros.
       clear H1.
       right.
       left.
       tauto.
     intro.
       clear H1.
       left.
       apply (IHm x d0 z).
      tauto.
      tauto.
   intro.
     clear H.
     elim H0.
    clear H0.
      intro.
      right.
      right.
      split.
     tauto.
     apply (IHm d0 y z).
      tauto.
      tauto.
    clear H0.
      intro.
      elim H.
     clear H.
       intro.
       left.
       apply (IHm x d1 z).
      tauto.
      tauto.
     intro.
       clear H.
       right.
       right.
       tauto.
Qed.

Lemma eqc_cA_r : 
 forall (m:fmap)(k:dim)(x:dart),
    inv_hmap m -> exd m x -> eqc m x (cA m k x).
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   elim (eq_dart_dec d x).
  generalize (eqc_refl m x).
    intros.
    symmetry  in a.
    tauto.
  intro.
    generalize (IHm k x).
    tauto.
 simpl in |- *.
   unfold prec_L in |- *.
   intros.
   decompose [and] H.
   clear H.
   elim (eq_dim_dec d k).
  intro.
    elim (eq_dart_dec d0 x).
   intro.
     rewrite <- a0.
     right.
     left.
     split.
    apply eqc_refl.
      rewrite a0.
      tauto.
    apply eqc_refl.
      tauto.
   intro.
     elim (eq_dart_dec (cA_1 m k d1) x).
    intro.
      assert (d1 = cA m k x).
     rewrite <- a0.
       rewrite cA_cA_1.
      tauto.
      tauto.
      tauto.
     right.
       right.
       rewrite H.
       generalize (IHm k d0 H1 H3).
       generalize (IHm k x H1 H0).
       tauto.
    intro.
      generalize (IHm k x).
      tauto.
  generalize (IHm k x).
    tauto.
Qed.

Lemma eqc_cA_1_r : 
 forall (m:fmap)(k:dim)(x:dart),
    inv_hmap m -> exd m x -> eqc m x (cA_1 m k x).
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   intros.
   elim (eq_dart_dec d x).
  generalize (eqc_refl m x).
    intros.
    symmetry  in a.
    tauto.
  intro.
    generalize (IHm k x).
    tauto.
 simpl in |- *.
   unfold prec_L in |- *.
   intros.
   decompose [and] H.
   clear H.
   elim (eq_dim_dec d k).
  intro.
    elim (eq_dart_dec d1 x).
   intro.
     rewrite <- a0.
     right.
     right.
     split.
    apply eqc_refl.
      tauto.
    apply eqc_refl.
      tauto.
   intro.
     elim (eq_dart_dec (cA m k d0) x).
    intro.
      assert (d0 = cA_1 m k x).
     rewrite <- a0.
       rewrite cA_1_cA.
      tauto.
      tauto.
      tauto.
     right.
       left.
       rewrite H.
       generalize (IHm k x).
       generalize (IHm k d1).
       tauto.
    intro.
      generalize (IHm k x).
      tauto.
  generalize (IHm k x).
    tauto.
Qed.

Lemma eqc_eqc_cA : 
 forall (m:fmap)(k:dim)(x y:dart),
   inv_hmap m ->
     eqc m x y -> eqc m x (cA m k y).
Proof.
intros.
apply eqc_trans with y.
 tauto.
 apply eqc_cA_r.
  tauto.
  generalize (eqc_exd_exd m x y).
    tauto.
Qed.

Lemma eqc_eqc_cA_1 : 
 forall (m:fmap)(k:dim)(x y:dart),
   inv_hmap m ->
     eqc m x y -> eqc m x (cA_1 m k y).
Proof.
intros.
apply eqc_trans with y.
 tauto.
 apply eqc_cA_1_r.
  tauto.
  generalize (eqc_exd_exd m x y).
    tauto.
Qed.

Lemma eqc_cA_1_eqc : 
 forall (m:fmap)(k:dim)(x y:dart),
   inv_hmap m ->
     eqc m (cA_1 m k x) y -> eqc m x y.
Proof.
intros.
generalize (eqc_cA_1_r m k x).
intros.
apply eqc_trans with (cA_1 m k x).
 apply H1.
  tauto.
  generalize (eqc_exd_exd m (cA_1 m k x) y).
    intros.
    generalize (exd_cA_1 m k x).
    tauto.
 tauto.
Qed.

Lemma eqc_cA_eqc : 
 forall (m:fmap)(k:dim)(x y:dart),
   inv_hmap m ->
     eqc m x (cA m k y) -> eqc m x y.
Proof.
intros.
generalize (eqc_cA_r m k y H).
intros.
apply eqc_trans with (cA m k y).
 tauto.
 apply eqc_symm.
   apply H1.
   generalize (eqc_exd_exd m x (cA m k y)).
   intros.
   generalize (exd_cA m k y).
   tauto.
Qed.

Lemma eqc_eqc_cF : 
 forall (m:fmap)(x y:dart),
   inv_hmap m ->
     eqc m x y -> eqc m x (cF m y).
Proof.
unfold cF in |- *.
intros.
assert (eqc m x (cA_1 m zero y)).
 apply eqc_eqc_cA_1.
  tauto.
  tauto.
 eapply eqc_eqc_cA_1.
  tauto.
  tauto.
Qed.

Lemma exd_Iter_cF : 
 forall (m:fmap)(n:nat)(z:dart),
   inv_hmap m -> exd m z ->
     exd m (Iter (cF m) n z).
Proof.
intros.
induction n.
 simpl in |- *.
   tauto.
 simpl in |- *.
   generalize (exd_cF m (Iter (cF m) n z)).
   tauto.
Qed.

Lemma eqc_Iter_cF : 
 forall (m:fmap)(n:nat)(z:dart),
   inv_hmap m -> exd m z ->
     eqc m z (Iter (cF m) n z).
Proof.
intros.
induction n.
 simpl in |- *.
   apply eqc_refl.
   tauto.
 simpl in |- *.
   eapply eqc_trans.
  apply IHn.
    apply eqc_eqc_cF.
   tauto.
   apply eqc_refl.
  apply exd_Iter_cF.
    tauto.
    tauto.
Qed.

Lemma expf_eqc : forall(m:fmap)(x y:dart),
 inv_hmap m ->  
   MF.expo m x y -> eqc m x y.
Proof.
intros.
assert (exd m x).
 unfold MF.expo in H0.
   tauto.
 assert (MF.f = cF).
  tauto.
  unfold MF.expo in H0.
    rewrite H2 in H0.
    intuition.
    elim H4.
    intros n In.
    rewrite <- In.
    apply eqc_Iter_cF.
   tauto.
   tauto.
Qed.

Lemma inv_hmap_dec:forall(m:fmap),
 {inv_hmap m} + {~inv_hmap m}.
Proof.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   unfold prec_I in |- *.
   generalize (eq_dart_dec d nil).
   generalize (exd_dec m d).
   tauto.
 simpl in |- *.
   unfold prec_L in |- *.
   generalize (exd_dec m d0).
   generalize (exd_dec m d1).
   generalize (succ_dec m d d0).
   generalize (pred_dec m d d1).
   generalize (eq_dart_dec (cA m d d0) d1).
   tauto.
Qed.

Definition expf(m:fmap)(x y:dart):Prop:=
  inv_hmap m /\ MF.expo m x y.

Lemma expf_dec : forall(m:fmap)(x y:dart),
  {expf m x y} + {~expf m x y}.
Proof.
unfold expf in |- *.
intros.
generalize (MF.expo_dec m x y).
generalize (inv_hmap_dec m).
tauto.
Qed.

Require Import ZArith.
Open Scope Z_scope.

Fixpoint nd(m:fmap):Z :=
 match m with
    V => 0
  | I m0 x _ _ => nd m0 + 1
  | L m0 _ _ _ => nd m0
 end.

Fixpoint nv(m:fmap):Z :=
 match m with
    V => 0
  | I m0 x _ _ => nv m0 + 1
  | L m0 zero x y => nv m0
  | L m0 one x y => nv m0 - 1
 end.

Fixpoint ne(m:fmap):Z :=
 match m with
    V => 0
  | I m0 x _ _ => ne m0 + 1
  | L m0 zero x y => ne m0 - 1
  | L m0 one x y => ne m0
 end.

Fixpoint nf(m:fmap):Z :=
 match m with
    V => 0
  | I m0 x _ _ => nf m0 + 1
  | L m0 zero x y =>
      let x_1:= cA_1 m0 one x in
      nf m0 +
       if expf_dec m0 x_1 y then 1 else -1
  | L m0 one x y =>
      let y0 := cA m0 zero y in
      nf m0 +
       if expf_dec m0 x y0 then 1 else -1
 end.

Fixpoint nc(m:fmap):Z :=
 match m with
    V => 0
  | I m0 x _ _ => nc m0 + 1
  | L m0 _ x y => nc m0 -
       if eqc_dec m0 x y then 0 else 1
 end.

Definition ec(m:fmap): Z:=
  nv m + ne m + nf m - nd m.

Theorem even_ec : 
   forall m:fmap, inv_hmap m -> Zeven (ec m).
Proof.
unfold ec in |- *.
induction m.
 simpl in |- *.
   tauto.
 simpl in |- *.
   cut
    (nv m + 1 + (ne m + 1) + (nf m + 1) - (nd m + 1) =
     Zsucc (Zsucc (nv m + ne m + nf m - nd m))).
  intros.
    rewrite H.
    apply Zeven_Sn.
    apply Zodd_Sn.
    tauto.
  omega.
 induction d.
  simpl in |- *.
    unfold prec_L in |- *.
    elim (expf_dec m (cA_1 m one d0) d1).
   intro.
     assert
      (nv m + ne m + nf m - nd m = 
   nv m + (ne m - 1) + (nf m + 1) - nd m).
    omega.
    rewrite <- H.
      tauto.
   intro.
     assert
      (nv m + (ne m - 1) + (nf m + -1) - nd m =
       Zpred (Zpred (nv m + ne m + nf m - nd m))).
    unfold Zpred in |- *.
      omega.
    rewrite H.
      intros.
      apply Zeven_pred.
      apply Zodd_pred.
      tauto.
  simpl in |- *.
    unfold prec_L in |- *.
    elim (eq_dart_dec d1 (cA m one d0)).
   intro.
     symmetry  in a.
     tauto.
   intros.
     elim (expf_dec m d0 (cA m zero d1)).
    intro.
      assert
       (nv m - 1 + ne m + (nf m + 1) - nd m = 
         nv m + ne m + nf m - nd m).
     omega.
     rewrite H0.
       tauto.
    intro.
      assert
       (nv m - 1 + ne m + (nf m + -1) - nd m =
        Zpred (Zpred (nv m + ne m + nf m - nd m))).
     unfold Zpred in |- *.
       omega.
     rewrite H0.
       apply Zeven_pred.
       apply Zodd_pred.
       tauto.
Qed.

Theorem genus_theorem : forall m:fmap,
  inv_hmap m -> 2 * (nc m) >= (ec m).
Proof.
intros.
rename H into Invm.
unfold ec.
induction m.
 simpl in |- *.
   omega.
 unfold nc in |- *.
   fold nc in |- *.
   unfold nv in |- *; fold nv in |- *.
   unfold ne in |- *; fold ne in |- *.
   unfold nf in |- *; fold nf in |- *.
   unfold nd in |- *; fold nd in |- *.
   unfold inv_hmap in Invm.
   fold inv_hmap in Invm.
   assert (2 * nc m >= nv m + ne m + nf m - nd m).
  tauto.
  omega.
 unfold inv_hmap in Invm; fold inv_hmap in Invm.
   induction d.
  unfold nc in |- *; fold nc in |- *.
    unfold nv in |- *; fold nv in |- *.
    unfold ne in |- *; fold ne in |- *.
    unfold nf in |- *; fold nf in |- *.
    unfold nd in |- *; fold nd in |- *.
    elim (expf_dec m (cA_1 m one d0) d1).
   intro.
     elim (eqc_dec m d0 d1).
    intro.
      assert (2 * nc m >= nv m + ne m + nf m - nd m).
     tauto.
     omega.
    intro.
      assert (eqc m (cA_1 m one d0) d1).
     apply expf_eqc.
      tauto.
      unfold expf in a.
        tauto.
     absurd (eqc m d0 d1).
      tauto.
      apply (eqc_cA_1_eqc m one d0 d1).
       tauto.
       tauto.
   intro.
     elim (eqc_dec m d0 d1).
    intro.
      assert (2 * nc m >= nv m + ne m + nf m - nd m).
     tauto.
     omega.
    intro.
      assert (2 * nc m >= nv m + ne m + nf m - nd m).
     tauto.
     omega.
  assert (2 * nc m >= nv m + ne m + nf m - nd m).
   tauto.
   clear IHm.
     unfold nc in |- *.
     fold nc in |- *.
     unfold nv in |- *; fold nv in |- *.
     unfold ne in |- *; fold ne in |- *.
     unfold nf in |- *; fold nf in |- *.
     unfold nd in |- *; fold nd in |- *.
     unfold prec_L in Invm.
     elim (eqc_dec m d0 d1).
    intro.
      elim (expf_dec m d0 (cA m zero d1)).
     intro.
       omega.
     intro.
       omega.
    elim (expf_dec m d0 (cA m zero d1)).
     intros.
       assert (eqc m d0 (cA m zero d1)).
      apply expf_eqc.
       tauto.
       unfold expf in a.
         tauto.
      assert (eqc m d0 d1).
       eapply eqc_cA_eqc.
        tauto.
        apply H0.
       tauto.
     intro.
       intro.
       omega.
Qed.

Definition genus(m:fmap):= (nc m) - (ec m)/2.

Theorem genus_corollary : forall m:fmap,
  inv_hmap m -> genus m >= 0.
Proof.
intros.
unfold genus in |- *.
generalize (genus_theorem m H).
generalize (even_ec m).
generalize (ec m).
generalize (nc m).
intros a b.
intros.
cut (a >= b / 2).
intro.
   omega.
 assert (b = 2 * Zdiv2 b).
  apply Zeven_div2.
    tauto.
  rewrite H2 in H1.
    assert (a >= Zdiv2 b).
   omega.
   rewrite H2.
 rewrite Zmult_comm.
     assert (Zdiv2 b * 2 / 2 = Zdiv2 b).
  apply Z_div_mult.
      omega.
    rewrite H4.
      tauto.
Qed.

Definition planar(m:fmap):= genus m = 0.

Lemma Euler_Poincare: forall m:fmap,
  inv_hmap m -> planar m ->
    ec m / 2 = nc m.
Proof.
unfold planar in |- *.
unfold genus in |- *.
intros.
omega.
Qed.

Lemma planar_dec:forall m:fmap,
  {planar m} + {~planar m}. 
Proof.
unfold planar in |- *.
intro.
apply Z_eq_dec.
Qed.

Lemma planar_V: planar V.
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
tauto.
Qed.

Lemma planar_I: forall (m:fmap)(x:dart)(t:tag)(p:point),
   inv_hmap m -> planar m -> prec_I m x -> 
      planar (I m x t p). 
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
unfold prec_I in |- *.
simpl in |- *.
intros.
assert
 (nv m + 1 + (ne m + 1) + (nf m + 1) - (nd m + 1) =
  nv m + ne m + nf m - nd m + 1 * 2).
 omega.
 rewrite H2.
   rewrite Z_div_plus.
  omega.
  omega.
Qed.

Lemma expf_planar_0: forall (m:fmap)(x y:dart),
  inv_hmap m -> planar m -> 
   prec_L m zero x y ->
    expf m (cA_1 m one x) y -> 
      planar (L m zero x y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
unfold prec_L in |- *.
intros.
elim (expf_dec m (cA_1 m one x) y).
 intro.
   elim (eqc_dec m x y).
  intro.
    assert
     (nv m + (ne m - 1) + (nf m + 1) - nd m 
        = nv m + ne m + nf m - nd m).
   omega.
   rewrite H3.
     omega.
  intro.
    elim b.
    eapply eqc_cA_1_eqc.
   tauto.
   apply expf_eqc.
    tauto.
    unfold expf in a.
      decompose [and] a.
      apply H4.
 tauto.
Qed.

Lemma expf_planar_1: forall (m:fmap)(x y:dart),
  inv_hmap m -> planar m ->
    prec_L m one x y ->
      expf m x (cA m zero y) -> 
        planar (L m one x y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
intros m x y Inv E Pr Exp.
   elim (eqc_dec m x y).
  intro.
    elim (expf_dec m x (cA m zero y)).
   intro.
     assert
      (nv m - 1 + ne m + (nf m + 1) - nd m 
          = nv m + ne m + nf m - nd m).
    omega.
    rewrite H.
      omega.
   tauto.
  intro.
    elim b.
    eapply eqc_cA_eqc.
   tauto.
   apply expf_eqc.
    tauto.
    unfold expf in Exp.
      decompose [and] Exp.
      apply H0.
Qed.

Lemma not_eqc_planar: forall (m:fmap)(k:dim)(x y:dart),
  inv_hmap m -> planar m -> 
   prec_L m k x y ->
     ~eqc m x y -> planar (L m k x y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
unfold prec_L in |- *.
intros.
induction k.
 simpl in |- *.
   elim (eqc_dec m x y).
   tauto.
 intro.
   elim (expf_dec m (cA_1 m one x) y).
  intro.
    elim b.
     eapply eqc_cA_1_eqc.
      tauto.
    apply expf_eqc.
    tauto.
  unfold expf in a.
    decompose [and] a.
    apply H4.
   intro.
   assert
    (nv m + (ne m - 1) + (nf m + -1) - nd m =
     nv m + ne m + nf m - nd m + -1 * 2).
   omega.
 rewrite H3 in |- *.
   clear H3.
   rewrite Z_div_plus in |- *.
   omega.
  omega.
  simpl in |- *.
  elim (eqc_dec m x y).
  tauto.
intro.
  elim (expf_dec m x (cA m zero y)).
 intro.
   elim b.
    eapply eqc_cA_eqc.
     tauto.
   apply expf_eqc.
   tauto.
 unfold expf in a.
   decompose [and] a.
   apply H4.
  intro.
  assert
   (nv m - 1 + ne m + (nf m + -1) - nd m =
     nv m + ne m + nf m - nd m + -1 * 2).
  omega.
rewrite H3 in |- *.
  clear H3.
  rewrite Z_div_plus in |- *.
  omega.
 omega.
Qed.

Fixpoint plf(m:fmap):Prop:=
  match m with 
     V => True
   | I m0 x _ _ => plf m0
   | L m0 zero x y => plf m0 /\ 
        (~eqc m0 x y \/ expf m0 (cA_1 m0 one x) y)
   | L m0 one x y => plf m0 /\ 
        (~eqc m0 x y \/ expf m0 x (cA m0 zero y))
  end.

Theorem plf_planar:forall (m:fmap),
  inv_hmap m -> plf m -> planar m.
Proof.
induction m.
 simpl in |- *.
   intros.
   apply planar_V.
simpl in |- *.
  intros.
  apply planar_I.
  tauto.
 tauto.
 tauto.
induction d.
 simpl in |- *.
   intros.
   decompose [and] H0.
   elim H2.
  intro.
    apply not_eqc_planar.
    tauto.
   tauto.
   tauto.
   tauto.
 intro.
   apply expf_planar_0.
   tauto.
  tauto.
  tauto.
  tauto.
simpl in |- *.
   intros.
   decompose [and] H0.
   elim H2.
  intro.
    apply not_eqc_planar.
    tauto.
   tauto.
   tauto.
   tauto.
 intro.
   apply expf_planar_1.
   tauto.
  tauto.
  tauto.
  tauto.
Qed.

Theorem plf_Euler_Poincare: forall m:fmap,
  inv_hmap m -> plf m ->
     ec m / 2 = nc m.
Proof.
intros.
apply Euler_Poincare.
  tauto.
apply plf_planar.
  tauto.
 tauto.
Qed.

Lemma expf_planar_rcp_0: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y -> 
    planar (L m zero x y) ->
      expf m (cA_1 m one x) y -> 
         planar m.
Proof.
unfold planar.
unfold genus in |- *.
unfold ec in |- *.
unfold prec_L in |- *.
simpl in |- *.
intros m x y Pr Inv.
elim (expf_dec m (cA_1 m one x) y).
 intro.
   elim (eqc_dec m x y).
  intros.
    assert
     (nv m + (ne m - 1) + (nf m + 1) - nd m 
         = nv m + ne m + nf m - nd m).
   omega.
   rewrite <- H1.
     omega.
  intro.
    elim b.
    eapply eqc_cA_1_eqc.
   tauto.
   apply expf_eqc.
    tauto.
    unfold expf in a.
      decompose [and] a.
      apply H0.
 tauto.
Qed.

Lemma expf_planar_rcp_1: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y ->
    planar (L m one x y) ->
      expf m x (cA m zero y) -> planar m.
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
unfold prec_L in |- *.
simpl in |- *.
intros m x y Pr Inv.
 elim (expf_dec m x (cA m zero y)).
  elim (eqc_dec m x y).
   intros.
     assert
      (nv m - 1 + ne m + (nf m + 1) - nd m 
        = nv m + ne m + nf m - nd m).
    omega.
    rewrite <- H1.
      omega.
   intros.
     elim b.
     eapply eqc_cA_eqc.
    tauto.
    apply expf_eqc.
     tauto.
     unfold expf in a.
       decompose [and] a.
       apply H2.
  tauto.
Qed.

Theorem weak_planarity_criterion_0: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y -> 
    expf m (cA_1 m one x) y ->
      (planar m <-> planar (L m zero x y)).
Proof.
intros m x y Inv Pr Exp.
split.
 intro.
   eapply expf_planar_0.
  tauto.
  tauto.
  tauto.
  tauto.
 intro.
   eapply expf_planar_rcp_0.
  tauto.
  apply Pr.
    tauto.
    tauto.
Qed.

Theorem weak_planarity_criterion_1: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y -> 
    expf m x (cA m zero y) ->
       (planar m <-> planar (L m one x y)).
Proof.
intros m x y Inv Pr Exp.
split.
 intro.
   eapply expf_planar_1.
  tauto.
  tauto.
  tauto.
  tauto.
 intro.
   eapply expf_planar_rcp_1.
  tauto.
  apply Pr.
    tauto.
    tauto.
Qed.

Lemma planarity_criterion_RCP_0: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y ->
    planar m -> planar (L m zero x y) ->
    (~ eqc m x y \/ expf m (cA_1 m one x) y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
intros m x y Inv Pr E.
unfold prec_L in Pr.
 elim (expf_dec m (cA_1 m one x) y).
  tauto.
  elim (eqc_dec m x y).
   intros.
     assert
      (nv m + (ne m - 1) + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m - 2).
    omega.
    rewrite H0 in H.
      generalize E H.
      generalize (nv m + ne m + nf m - nd m).
      intros.
      assert (z + -1 * 2 = z - 2).
     omega.
     rewrite <- H2 in H1.
       rewrite Z_div_plus in H1.
      absurd (nc m - z / 2 = 0).
       omega.
       tauto.
      omega.
   tauto.
Qed.

Lemma planarity_criterion_RCP_1: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y ->
   planar m -> planar (L m one x y) ->
      (~ eqc m x y \/ expf m x (cA m zero y)).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
intros m x y Inv Pr E.
unfold prec_L in Pr.
 elim (expf_dec m x (cA m zero y)).
  tauto.
  elim (eqc_dec m x y).
   intros.
     assert
      (nv m - 1 + ne m + (nf m + -1) - nd m 
       = nv m + ne m + nf m - nd m - 2).
    omega.
    rewrite H0 in H.
      generalize E H.
      generalize (nv m + ne m + nf m - nd m).
      intros.
      assert ((z + -1 * 2) / 2 = z / 2 + -1).
     apply Z_div_plus.
       auto with zarith.
     assert (z + -1 * 2 = z - 2).
      omega.
      rewrite H3 in H2.
        assert (z / 2 = (z - 2) / 2).
       omega.
       rewrite <- H4 in H2.
         absurd (z / 2 = z / 2 + -1).
        omega.
        tauto.
   tauto.
Qed.

Lemma not_eqc_planar_0:forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y ->
    planar m -> ~eqc m x y -> planar (L m zero x y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
intros m x y Inv Pr E.
unfold prec_L in Pr.
 elim (eqc_dec m x y).
  tauto.
  elim (expf_dec m (cA_1 m one x) y).
   intros.
     elim H.
     eapply eqc_cA_1_eqc.
    tauto.
    apply expf_eqc.
     tauto.
     unfold expf in a.
       decompose [and] a.
       apply H1.
   intros.
     assert
      (nv m + (ne m - 1) + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m + -1 * 2).
    omega.
    rewrite H0.
      rewrite Z_div_plus.
     generalize E.
       generalize (nv m + ne m + nf m - nd m).
       intros.
       omega.
     omega.
Qed.

Lemma not_eqc_planar_1:forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y ->
    planar m -> ~eqc m x y -> planar (L m one x y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
intros m x y Inv Pr E.
unfold prec_L in Pr.
 elim (eqc_dec m x y).
  tauto.
  elim (expf_dec m x (cA m zero y)).
   intros.
     elim H.
     eapply eqc_cA_eqc.
    tauto.
    apply expf_eqc.
     tauto.
     unfold expf in a.
       decompose [and] a.
       apply H1.
   intros.
     assert
      (nv m - 1 + ne m + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m + -1 * 2).
    omega.
    rewrite H0.
      rewrite Z_div_plus.
     generalize E.
       generalize (nv m + ne m + nf m - nd m).
       intros.
       omega.
     omega.
Qed.

Theorem planarity_criterion_0: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y -> planar m ->
    (planar (L m zero x y) <->
      (~ eqc m x y \/ expf m (cA_1 m one x) y)).
Proof.
intros.
split.
 intro.
   simpl in |- *.
   apply planarity_criterion_RCP_0.
  tauto.
  tauto.
  tauto.
  tauto.
 simpl in |- *.
   intro.
   elim H2.
  apply not_eqc_planar_0.
   tauto.
   tauto.
   tauto.
  apply expf_planar_0.
   tauto.
   tauto.
   tauto.
Qed.

Theorem planarity_criterion_1: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y -> planar m ->
   (planar (L m one x y) <->
      (~ eqc m x y \/ expf m x (cA m zero y))).
Proof.
intros.
split.
 intro.
   simpl in |- *.
   apply planarity_criterion_RCP_1.
  tauto.
  tauto.
  tauto.
  tauto.
 simpl in |- *.
   intro.
   elim H2.
  apply not_eqc_planar_1.
   tauto.
   tauto.
   tauto.
  apply expf_planar_1.
   tauto.
   tauto.
   tauto.
Qed.

Lemma incr_genus_0:forall(m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y ->
     genus m <= genus (L m zero x y).
Proof.
unfold planar in |- *.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
unfold prec_L in |- *.
intros m x y Inv Pr.
 elim (expf_dec m (cA_1 m one x) y).
  elim (eqc_dec m x y).
   intros.
     assert
      (nv m + (ne m - 1) + (nf m + 1) - nd m 
         = nv m + ne m + nf m - nd m).
    omega.
    rewrite H.
      omega.
   intros.
     elim b.
     eapply eqc_cA_1_eqc.
    tauto.
    apply expf_eqc.
     tauto.
     unfold expf in a.
       decompose [and] a.
       apply H0.
  elim (eqc_dec m x y).
   intros.
     assert
      (nv m + (ne m - 1) + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m + -1 * 2).
    omega.
    rewrite H.
      rewrite Z_div_plus.
     generalize (nv m + ne m + nf m - nd m).
       intros.
       omega.
     omega.
   intros.
     assert
      (nv m + (ne m - 1) + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m + -1 * 2).
    omega.
    rewrite H.
      rewrite Z_div_plus.
     generalize (nv m + ne m + nf m - nd m).
       intros.
       omega.
     omega.
Qed.

Lemma incr_genus_1:forall(m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y ->
     genus m <= genus (L m one x y).
Proof.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
unfold prec_L in |- *.
intros m x y Inv Pr.
 elim (expf_dec m x (cA m zero y)).
  elim (eqc_dec m x y).
   intros.
     assert
      (nv m - 1 + ne m + (nf m + 1) - nd m 
         = nv m + ne m + nf m - nd m).
    omega.
    rewrite H.
      omega.
   intros.
     elim b.
     eapply eqc_cA_eqc.
    tauto.
    apply expf_eqc.
     tauto.
     unfold expf in a.
       decompose [and] a.
       apply H0.
  intros.
    elim (eqc_dec m x y).
   intros.
     assert
      (nv m - 1 + ne m + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m + -1 * 2).
    omega.
    rewrite H.
      rewrite Z_div_plus.
     omega.
     omega.
   intro.
     assert
      (nv m - 1 + ne m + (nf m + -1) - nd m =
       nv m + ne m + nf m - nd m + -1 * 2).
    omega.
    rewrite H.
      rewrite Z_div_plus.
     omega.
     omega.
Qed.

Theorem incr_genus:forall(m:fmap)(k:dim)(x y:dart),
  inv_hmap m -> prec_L m k x y ->
     genus m <= genus (L m k x y).
Proof.
induction k.
 apply incr_genus_0.
 apply incr_genus_1.
Qed.

Theorem inversion_planarity:forall(m:fmap)(k:dim)(x y:dart),
  inv_hmap m -> prec_L m k x y ->
    planar (L m k x y) -> planar m.
Proof.
unfold planar in |- *.
intros.
assert (genus m <= genus (L m k x y)).
 apply incr_genus.
  tauto.
  tauto.
 generalize (genus_corollary m H).
   omega.
Qed.

Theorem planarity_crit_0: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m zero x y -> 
    (planar (L m zero x y) <->
      (planar m /\ (~ eqc m x y \/ expf m (cA_1 m one x) y))).
Proof.
intros.
split.
 intro.
   assert (planar m).
  eapply inversion_planarity.
   tauto.
   apply H0.
     tauto.
  split.
   tauto.
   generalize (planarity_criterion_0 m x y H H0 H2).
     tauto.
 generalize (planarity_criterion_0 m x y H H0).
   tauto.
Qed.

Theorem planarity_crit_1: forall (m:fmap)(x y:dart),
  inv_hmap m -> prec_L m one x y -> 
    (planar (L m one x y) <->
      (planar m /\ (~ eqc m x y \/ expf m x (cA m zero y)))).
Proof.
intros.
split.
 intro.
   assert (planar m).
  eapply inversion_planarity.
   tauto.
   apply H0.
     tauto.
  split.
   tauto.
   generalize (planarity_criterion_1 m x y H H0 H2).
     tauto.
 generalize (planarity_criterion_1 m x y H H0).
   tauto.
Qed.

Lemma eq_genus_I : forall(m:fmap)(x:dart)(t:tag)(p:point),
   inv_hmap (I m x t p) -> genus (I m x t p) = genus m.
Proof.
unfold genus in |- *.
unfold ec in |- *.
simpl in |- *.
intros.
assert
 (nv m + 1 + (ne m + 1) + (nf m + 1) - (nd m + 1) =
  nv m + ne m + nf m - nd m + 1 * 2).
  omega.
rewrite H0 in |- *.
  rewrite Z_div_plus in |- *.
  omega.
 omega.
Qed.

Theorem planar_plf: forall m:fmap,
  inv_hmap m -> genus m = 0 -> plf m.
Proof.
intros.
induction m.
 simpl in |- *.
    tauto.
simpl in |- *.
  simpl in H.
  apply IHm.
  tauto.
rewrite eq_genus_I in H0.
  tauto.
simpl in |- *.
   tauto.
induction d.
 simpl in |- *.
   simpl in H.
   generalize (planarity_crit_0 m d0 d1).
    tauto.
simpl in |- *.
  simpl in H.
  generalize (planarity_crit_1 m d0 d1).
   tauto.
Qed.

Theorem Euler_Poincare_plf: forall m:fmap,
  inv_hmap m -> ec m / 2 = nc m -> plf m.
Proof.
intros.
apply planar_plf.
  tauto.
unfold genus in |- *.
   omega.
Qed.

Theorem Euler_Poincare_criterion: forall m:fmap,
  inv_hmap m -> (plf m <-> ec m / 2 = nc m).
Proof.
intros.
split.
 apply plf_Euler_Poincare.
    tauto.
apply Euler_Poincare_plf.
   tauto.
Qed.

