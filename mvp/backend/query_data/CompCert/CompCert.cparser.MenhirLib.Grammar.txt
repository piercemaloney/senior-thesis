

Require Import List.

Require Import Syntax.

Require Import Alphabet.
(* Alphabet:
Require Import Int31.
Require Import Cyclic31.
Require Import Omega.
Require Import List.
Require Import Syntax.
Require Import Relations.
Require Import RelationClasses.

Local Obligation Tactic := intros.

Class Comparable (A:Type) := {
  compare : A -> A -> comparison;
  compare_antisym : forall x y, CompOpp (compare x y) = compare y x;
  compare_trans :  forall x y z c,
    (compare x y) = c -> (compare y z) = c -> (compare x z) = c
}.

Theorem compare_refl {A:Type} (C: Comparable A) :
  forall x, compare x x = Eq.

Definition comparableLt {A:Type} (C: Comparable A) : relation A :=
  fun x y => compare x y = Lt.

Class ComparableUsualEq {A:Type} (C: Comparable A) :=
  compare_eq : forall x y, compare x y = Eq -> x = y.

Definition compare_eqb {A:Type} {C:Comparable A} (x y:A) :=
  match compare x y with
    | Eq => true
    | _ => false
  end.

Theorem compare_eqb_iff {A:Type} {C:Comparable A} {U:ComparableUsualEq C} :
  forall x y, compare_eqb x y = true <-> x = y.

Definition compare_eqdec {A:Type} {C:Comparable A} {U:ComparableUsualEq C} (x y:A):
  {x = y} + {x <> y}.

Require Import OrderedTypeAlt.
Require FSetAVL.
Require FMapAVL.
Import OrderedType.

Module Type ComparableM.
  Parameter t : Type.
  Declare Instance tComparable : Comparable t.
End ComparableM.

Module OrderedTypeAlt_from_ComparableM (C:ComparableM) <: OrderedTypeAlt.
  Definition t := C.t.
  Definition compare : t -> t -> comparison := compare.

  Infix "?=" := compare (at level 70, no associativity).

  Lemma compare_sym x y : (y?=x) = CompOpp (x?=y).
  Lemma compare_trans c x y z :
    (x?=y) = c -> (y?=z) = c -> (x?=z) = c.
End OrderedTypeAlt_from_ComparableM.

Module OrderedType_from_ComparableM (C:ComparableM) <: OrderedType.
  Module Alt := OrderedTypeAlt_from_ComparableM C.
  Include (OrderedType_from_Alt Alt).
End OrderedType_from_ComparableM. *)

Require Import Orders.

Require Tuples.



Module Type Alphs.

  Parameters terminal nonterminal : Type.

  Declare Instance TerminalAlph: Alphabet terminal.

  Declare Instance NonTerminalAlph: Alphabet nonterminal.

End Alphs.



Module Symbol(Import A:Alphs).



  Inductive symbol :=

    | T: terminal -> symbol

    | NT: nonterminal -> symbol.



  Program Instance SymbolAlph : Alphabet symbol :=

    { AlphabetComparable := {| compare := fun x y =>

        match x, y return comparison with

          | T _, NT _ => Gt

          | NT _, T _ => Lt

          | T x, T y => compare x y

          | NT x, NT y => compare x y

        end |};

      AlphabetFinite := {| all_list :=

        map T all_list++map NT all_list |} }.

  Next Obligation.

  destruct x; destruct y; intuition; apply compare_antisym.

  Qed.

  Next Obligation.

  destruct x; destruct y; destruct z; intuition; try discriminate.

  apply (compare_trans _ t0); intuition.

  apply (compare_trans _ n0); intuition.

  Qed.

  Next Obligation.

  intros x y.

  destruct x; destruct y; try discriminate; intros.

  rewrite (compare_eq t t0); intuition.

  rewrite (compare_eq n n0); intuition.

  Qed.

  Next Obligation.

  rewrite in_app_iff.

  destruct x; [left | right]; apply in_map; apply all_list_forall.

  Qed.



End Symbol.



Module Type T.

  Export Tuples.



  Include Alphs <+ Symbol.



  Parameter symbol_semantic_type: symbol -> Type.



  Parameter production : Type.

  Declare Instance ProductionAlph : Alphabet production.



  Parameter prod_lhs: production -> nonterminal.

  Parameter prod_rhs_rev: production -> list symbol.

  Parameter prod_action:

    forall p:production,

      arrows_left

        (map symbol_semantic_type (rev (prod_rhs_rev p)))

        (symbol_semantic_type (NT (prod_lhs p))).



End T.



Module Defs(Import G:T).



  Definition token := {t:terminal & symbol_semantic_type (T t)}.



  Inductive parse_tree:

    forall (head_symbol:symbol) (word:list token)

      (semantic_value:symbol_semantic_type head_symbol), Type :=



  | Terminal_pt:

    forall (t:terminal) (sem:symbol_semantic_type (T t)),

      parse_tree (T t)

      [existT (fun t => symbol_semantic_type (T t)) t sem] sem



  | Non_terminal_pt:

    forall {p:production} {word:list token}

      {semantic_values:tuple (map symbol_semantic_type (rev (prod_rhs_rev p)))},

      parse_tree_list (rev (prod_rhs_rev p)) word semantic_values ->

      parse_tree (NT (prod_lhs p)) word (uncurry (prod_action p) semantic_values)



  with parse_tree_list:

    forall (head_symbols:list symbol) (word:list token)

      (semantic_values:tuple (map symbol_semantic_type head_symbols)),

      Type :=



  | Nil_ptl: parse_tree_list [] [] ()



  | Cons_ptl:

  

    forall {head_symbolt:symbol} {wordt:list token}

      {semantic_valuet:symbol_semantic_type head_symbolt},

      parse_tree head_symbolt wordt semantic_valuet ->



    forall {head_symbolsq:list symbol} {wordq:list token}

      {semantic_valuesq:tuple (map symbol_semantic_type head_symbolsq)},

      parse_tree_list head_symbolsq wordq semantic_valuesq ->



      parse_tree_list

        (head_symbolt::head_symbolsq)

        (wordt++wordq)

        (semantic_valuet, semantic_valuesq).



  Fixpoint pt_size {head_symbol word sem} (tree:parse_tree head_symbol word sem) :=

    match tree with

      | Terminal_pt _ _ => 1

      | Non_terminal_pt l => S (ptl_size l)

    end

  with ptl_size {head_symbols word sems} (tree:parse_tree_list head_symbols word sems) :=

    match tree with

      | Nil_ptl => 0

      | Cons_ptl t q =>

         pt_size t + ptl_size q

    end.

End Defs.

