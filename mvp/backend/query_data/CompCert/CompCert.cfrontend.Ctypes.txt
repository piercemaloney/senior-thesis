

Require Import Axioms Coqlib Maps Errors.
(* Axioms:
Require ClassicalFacts.
Require FunctionalExtensionality.

Lemma functional_extensionality_dep:
  forall {A: Type} {B : A -> Type} (f g : forall x : A, B x),
  (forall x, f x = g x) -> f = g.
Proof @FunctionalExtensionality.functional_extensionality_dep.

Lemma functional_extensionality:
  forall {A B: Type} (f g : A -> B), (forall x, f x = g x) -> f = g.
Proof @FunctionalExtensionality.functional_extensionality.

Lemma extensionality:
  forall {A B: Type} (f g : A -> B),  (forall x, f x = g x) -> f = g.
Proof @functional_extensionality.

Axiom proof_irr: ClassicalFacts.proof_irrelevance.

Arguments proof_irr [A]. *)
(* Coqlib:
Require Export String.
Require Export ZArith.
Require Export Znumtheory.
Require Export List.
Require Export Bool.

Global Set Asymmetric Patterns.

Ltac inv H := inversion H; clear H; subst.

Ltac predSpec pred predspec x y :=
  generalize (predspec x y); case (pred x y); intro.

Ltac caseEq name :=
  generalize (eq_refl name); pattern name at -1 in |- *; case name.

Ltac destructEq name :=
  destruct name eqn:?.

Ltac decEq :=
  match goal with
  | [ |- _ = _ ] => f_equal
  | [ |- (?X ?A <> ?X ?B) ] =>
      cut (A <> B); [intro; congruence | try discriminate]
  end.

Ltac byContradiction :=
  cut False; [contradiction|idtac].

Ltac omegaContradiction :=
  cut False; [contradiction|omega].

Lemma modusponens: forall (P Q: Prop), P -> (P -> Q) -> Q.

Ltac exploit x :=
    refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _) _)
 || refine (modusponens _ _ (x _ _) _)
 || refine (modusponens _ _ (x _) _).

Definition peq: forall (x y: positive), {x = y} + {x <> y} := Pos.eq_dec.
Global Opaque peq.

Lemma peq_true:
  forall (A: Type) (x: positive) (a b: A), (if peq x x then a else b) = a.

Lemma peq_false:
  forall (A: Type) (x y: positive) (a b: A), x <> y -> (if peq x y then a else b) = b.

Definition Plt: positive -> positive -> Prop := Pos.lt.

Lemma Plt_ne:
  forall (x y: positive), Plt x y -> x <> y.
Hint Resolve Plt_ne: coqlib.

Lemma Plt_trans:
  forall (x y z: positive), Plt x y -> Plt y z -> Plt x z.
Proof (Pos.lt_trans).

Lemma Plt_succ:
  forall (x: positive), Plt x (Pos.succ x).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_trans_succ:
  forall (x y: positive), Plt x y -> Plt x (Pos.succ y).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_succ_inv:
  forall (x y: positive), Plt x (Pos.succ y) -> Plt x y \/ x = y.

Definition plt (x y: positive) : {Plt x y} + {~ Plt x y}.
Global Opaque plt.

Definition Ple: positive -> positive -> Prop := Pos.le.

Lemma Ple_refl: forall (p: positive), Ple p p.
Proof (Pos.le_refl).

Lemma Ple_trans: forall (p q r: positive), Ple p q -> Ple q r -> Ple p r.
Proof (Pos.le_trans).

Lemma Plt_Ple: forall (p q: positive), Plt p q -> Ple p q.
Proof (Pos.lt_le_incl).

Lemma Ple_succ: forall (p: positive), Ple p (Pos.succ p).

Lemma Plt_Ple_trans:
  forall (p q r: positive), Plt p q -> Ple q r -> Plt p r.
Proof (Pos.lt_le_trans).

Lemma Plt_strict: forall p, ~ Plt p p.
Proof (Pos.lt_irrefl).

Hint Resolve Ple_refl Plt_Ple Ple_succ Plt_strict: coqlib.

Ltac xomega := unfold Plt, Ple in *; zify; omega.
Ltac xomegaContradiction := exfalso; xomega.

Section POSITIVE_ITERATION.

Lemma Plt_wf: well_founded Plt.

Variable A: Type.
Variable v1: A.
Variable f: positive -> A -> A.

Lemma Ppred_Plt:
  forall x, x <> xH -> Plt (Pos.pred x) x.

Let iter (x: positive) (P: forall y, Plt y x -> A) : A :=
  match peq x xH with
  | left EQ => v1
  | right NOTEQ => f (Pos.pred x) (P (Pos.pred x) (Ppred_Plt x NOTEQ))
  end.

Definition positive_rec : positive -> A :=
  Fix Plt_wf (fun _ => A) iter.

Lemma unroll_positive_rec:
  forall x,
  positive_rec x = iter x (fun y _ => positive_rec y).

Lemma positive_rec_base:
  positive_rec 1%positive = v1.

Lemma positive_rec_succ:
  forall x, positive_rec (Pos.succ x) = f x (positive_rec x).

Lemma positive_Peano_ind:
  forall (P: positive -> Prop),
  P xH ->
  (forall x, P x -> P (Pos.succ x)) ->

End POSITIVE_ITERATION.

Definition zeq: forall (x y: Z), {x = y} + {x <> y} := Z.eq_dec.

Lemma zeq_true:
  forall (A: Type) (x: Z) (a b: A), (if zeq x x then a else b) = a.

Lemma zeq_false:
  forall (A: Type) (x y: Z) (a b: A), x <> y -> (if zeq x y then a else b) = b.

Open Scope Z_scope.

Definition zlt: forall (x y: Z), {x < y} + {x >= y} := Z_lt_dec.

Lemma zlt_true:
  forall (A: Type) (x y: Z) (a b: A),
  x < y -> (if zlt x y then a else b) = a.

Lemma zlt_false:
  forall (A: Type) (x y: Z) (a b: A),
  x >= y -> (if zlt x y then a else b) = b.

Definition zle: forall (x y: Z), {x <= y} + {x > y} := Z_le_gt_dec.

Lemma zle_true:
  forall (A: Type) (x y: Z) (a b: A),
  x <= y -> (if zle x y then a else b) = a.

Lemma zle_false:
  forall (A: Type) (x y: Z) (a b: A),
  x > y -> (if zle x y then a else b) = b.

Lemma two_power_nat_O : two_power_nat O = 1.

Lemma two_power_nat_pos : forall n : nat, two_power_nat n > 0.

Lemma two_power_nat_two_p:
  forall x, two_power_nat x = two_p (Z.of_nat x).

Lemma two_p_monotone:
  forall x y, 0 <= x <= y -> two_p x <= two_p y.

Lemma two_p_monotone_strict:
  forall x y, 0 <= x < y -> two_p x < two_p y.

Lemma two_p_strict:
  forall x, x >= 0 -> x < two_p x.

Lemma two_p_strict_2:
  forall x, x >= 0 -> 2 * x - 1 < two_p x.

Lemma Zmin_spec:
  forall x y, Z.min x y = if zlt x y then x else y.

Lemma Zmax_spec:
  forall x y, Z.max x y = if zlt y x then x else y.

Lemma Zmax_bound_l:
  forall x y z, x <= y -> x <= Z.max y z.
Lemma Zmax_bound_r:
  forall x y z, x <= z -> x <= Z.max y z.

Lemma Zdiv_small:
  forall x y, 0 <= x < y -> x / y = 0.

Lemma Zmod_small:
  forall x y, 0 <= x < y -> x mod y = x.

Lemma Zmod_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x mod y = b.

Lemma Zdiv_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x / y = a.

Lemma Zdiv_Zdiv:
  forall a b c,
  b > 0 -> c > 0 -> (a / b) / c = a / (b * c).

Lemma Zmult_le_compat_l_neg :
  forall n m p:Z, n >= m -> p <= 0 -> p * n <= p * m.

Lemma Zdiv_interval_1:
  forall lo hi a b,
  lo <= 0 -> hi > 0 -> b > 0 ->
  lo * b <= a < hi * b ->
  lo <= a/b < hi.

Lemma Zdiv_interval_2:
  forall lo hi a b,
  lo <= a <= hi -> lo <= 0 -> hi >= 0 -> b > 0 ->
  lo <= a/b <= hi.

Lemma Zmod_recombine:
  forall x a b,
  a > 0 -> b > 0 ->
  x mod (a * b) = ((x/b) mod a) * b + (x mod b).

Lemma Zdivides_trans:
  forall x y z, (x | y) -> (y | z) -> (x | z).

Definition Zdivide_dec:
  forall (p q: Z), p > 0 -> { (p|q) } + { ~(p|q) }.
Global Opaque Zdivide_dec.

Lemma Zdivide_interval:
  forall a b c,
  0 < c -> 0 <= a < b -> (c | a) -> (c | b) -> 0 <= a <= b - c.

Definition nat_of_Z: Z -> nat := Z.to_nat.

Lemma nat_of_Z_of_nat:
  forall n, nat_of_Z (Z.of_nat n) = n.

Lemma nat_of_Z_max:
  forall z, Z.of_nat (nat_of_Z z) = Z.max z 0.

Lemma nat_of_Z_eq:
  forall z, z >= 0 -> Z.of_nat (nat_of_Z z) = z.

Lemma nat_of_Z_neg:
  forall n, n <= 0 -> nat_of_Z n = O.

Lemma nat_of_Z_plus:
  forall p q,
  p >= 0 -> q >= 0 ->
  nat_of_Z (p + q) = (nat_of_Z p + nat_of_Z q)%nat.

Definition align (n: Z) (amount: Z) :=
  ((n + amount - 1) / amount) * amount.

Lemma align_le: forall x y, y > 0 -> x <= align x y.

Lemma align_divides: forall x y, y > 0 -> (y | align x y).

Set Implicit Arguments.

Definition option_eq (A: Type) (eqA: forall (x y: A), {x=y} + {x<>y}):
  forall (x y: option A), {x=y} + {x<>y}.
Global Opaque option_eq.

Inductive option_rel (A B: Type) (R: A -> B -> Prop) : option A -> option B -> Prop :=
  | option_rel_none: option_rel R None None
  | option_rel_some: forall x y, R x y -> option_rel R (Some x) (Some y).

Definition option_map (A B: Type) (f: A -> B) (x: option A) : option B :=
  match x with
  | None => None
  | Some y => Some (f y)
  end.

Definition sum_left_map (A B C: Type) (f: A -> B) (x: A + C) : B + C :=
  match x with
  | inl y => inl C (f y)
  | inr z => inr B z
  end.

Hint Resolve in_eq in_cons: coqlib.

Lemma nth_error_in:
  forall (A: Type) (n: nat) (l: list A) (x: A),
  List.nth_error l n = Some x -> In x l.
Hint Resolve nth_error_in: coqlib.

Lemma nth_error_nil:
  forall (A: Type) (idx: nat), nth_error (@nil A) idx = None.
Hint Resolve nth_error_nil: coqlib.

Fixpoint list_length_z_aux (A: Type) (l: list A) (acc: Z) {struct l}: Z :=
  match l with
  | nil => acc
  | hd :: tl => list_length_z_aux tl (Z.succ acc)
  end.

Remark list_length_z_aux_shift:
  forall (A: Type) (l: list A) n m,
  list_length_z_aux l n = list_length_z_aux l m + (n - m).

Definition list_length_z (A: Type) (l: list A) : Z :=
  list_length_z_aux l 0.

Lemma list_length_z_cons:
  forall (A: Type) (hd: A) (tl: list A),
  list_length_z (hd :: tl) = list_length_z tl + 1.

Lemma list_length_z_pos:
  forall (A: Type) (l: list A),
  list_length_z l >= 0.

Lemma list_length_z_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_length_z (map f l) = list_length_z l.

Fixpoint list_nth_z (A: Type) (l: list A) (n: Z) {struct l}: option A :=
  match l with
  | nil => None
  | hd :: tl => if zeq n 0 then Some hd else list_nth_z tl (Z.pred n)
  end.

Lemma list_nth_z_in:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> In x l.

Lemma list_nth_z_map:
  forall (A B: Type) (f: A -> B) (l: list A) n,
  list_nth_z (List.map f l) n = option_map f (list_nth_z l n).

Lemma list_nth_z_range:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> 0 <= n < list_length_z l.

Lemma incl_cons_inv:
  forall (A: Type) (a: A) (b c: list A),
  incl (a :: b) c -> incl b c.
Hint Resolve incl_cons_inv: coqlib.

Lemma incl_app_inv_l:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l1 m.

Lemma incl_app_inv_r:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l2 m.

Hint Resolve  incl_tl incl_refl incl_app_inv_l incl_app_inv_r: coqlib.

Lemma incl_same_head:
  forall (A: Type) (x: A) (l1 l2: list A),
  incl l1 l2 -> incl (x::l1) (x::l2).

Lemma list_map_exten:
  forall (A B: Type) (f f': A -> B) (l: list A),
  (forall x, In x l -> f x = f' x) ->
  List.map f' l = List.map f l.

Lemma list_map_compose:
  forall (A B C: Type) (f: A -> B) (g: B -> C) (l: list A),
  List.map g (List.map f l) = List.map (fun x => g(f x)) l.

Lemma list_map_identity:
  forall (A: Type) (l: list A),
  List.map (fun (x:A) => x) l = l.

Lemma list_map_nth:
  forall (A B: Type) (f: A -> B) (l: list A) (n: nat),
  nth_error (List.map f l) n = option_map f (nth_error l n).

Lemma list_length_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  List.length (List.map f l) = List.length l.

Lemma list_in_map_inv:
  forall (A B: Type) (f: A -> B) (l: list A) (y: B),
  In y (List.map f l) -> exists x:A, y = f x /\ In x l.

Lemma list_append_map:
  forall (A B: Type) (f: A -> B) (l1 l2: list A),
  List.map f (l1 ++ l2) = List.map f l1 ++ List.map f l2.

Lemma list_append_map_inv:
  forall (A B: Type) (f: A -> B) (m1 m2: list B) (l: list A),
  List.map f l = m1 ++ m2 ->

Section LIST_FOLD.

Variables A B: Type.
Variable f: A -> B -> B.

Fixpoint list_fold_left (accu: B) (l: list A) : B :=
  match l with nil => accu | x :: l' => list_fold_left (f x accu) l' end.

Definition list_fold_right (l: list A) (base: B) : B :=
  list_fold_left base (List.rev' l).

Remark list_fold_left_app:
  forall l1 l2 accu,
  list_fold_left accu (l1 ++ l2) = list_fold_left (list_fold_left accu l1) l2.

Lemma list_fold_right_eq:
  forall l base,
  list_fold_right l base =
  match l with nil => base | x :: l' => f x (list_fold_right l' base) end.

Lemma list_fold_right_spec:
  forall l base, list_fold_right l base = List.fold_right f base l.

End LIST_FOLD.

Lemma in_cns:
  forall (A: Type) (x y: A) (l: list A), In x (y :: l) <-> y = x \/ In x l.

Lemma in_app:
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Lemma list_in_insert:
  forall (A: Type) (x: A) (l1 l2: list A) (y: A),
  In x (l1 ++ l2) -> In x (l1 ++ y :: l2).

Definition list_disjoint (A: Type) (l1 l2: list A) : Prop :=
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Lemma list_disjoint_cons_l:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l2 -> list_disjoint (a :: l1) l2.

Lemma list_disjoint_cons_r:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l1 -> list_disjoint l1 (a :: l2).

Lemma list_disjoint_cons_left:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint (a :: l1) l2 -> list_disjoint l1 l2.

Lemma list_disjoint_cons_right:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 (a :: l2) -> list_disjoint l1 l2.

Lemma list_disjoint_notin:
  forall (A: Type) (l1 l2: list A) (a: A),
  list_disjoint l1 l2 -> In a l1 -> ~(In a l2).

Lemma list_disjoint_sym:
  forall (A: Type) (l1 l2: list A),
  list_disjoint l1 l2 -> list_disjoint l2 l1.

Lemma list_disjoint_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l1 l2: list A),
  {list_disjoint l1 l2} + {~list_disjoint l1 l2}.

Definition list_equiv (A : Type) (l1 l2: list A) : Prop :=
  forall x, In x l1 <-> In x l2.

Inductive list_norepet (A: Type) : list A -> Prop :=
  | list_norepet_nil:
      list_norepet nil
  | list_norepet_cons:
      forall hd tl,
      ~(In hd tl) -> list_norepet tl -> list_norepet (hd :: tl).

Lemma list_norepet_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l: list A),
  {list_norepet l} + {~list_norepet l}.

Lemma list_map_norepet:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_norepet l ->
  (forall x y, In x l -> In y l -> x <> y -> f x <> f y) ->
  list_norepet (List.map f l).

Remark list_norepet_append_commut:
  forall (A: Type) (a b: list A),
  list_norepet (a ++ b) -> list_norepet (b ++ a).

Lemma list_norepet_app:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) <->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Lemma list_norepet_append:
  forall (A: Type) (l1 l2: list A),
  list_norepet l1 -> list_norepet l2 -> list_disjoint l1 l2 ->
  list_norepet (l1 ++ l2).

Lemma list_norepet_append_right:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l2.

Lemma list_norepet_append_left:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l1.

Inductive is_tail (A: Type): list A -> list A -> Prop :=
  | is_tail_refl:
      forall c, is_tail c c
  | is_tail_cons:
      forall i c1 c2, is_tail c1 c2 -> is_tail c1 (i :: c2).

Lemma is_tail_in:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> In i c2.

Lemma is_tail_cons_left:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> is_tail c1 c2.

Hint Resolve is_tail_refl is_tail_cons is_tail_in is_tail_cons_left: coqlib.

Lemma is_tail_incl:
  forall (A: Type) (l1 l2: list A), is_tail l1 l2 -> incl l1 l2.

Lemma is_tail_trans:
  forall (A: Type) (l1 l2: list A),
  is_tail l1 l2 -> forall (l3: list A), is_tail l2 l3 -> is_tail l1 l3.

Section FORALL2.

Variable A: Type.
Variable B: Type.
Variable P: A -> B -> Prop.

Inductive list_forall2: list A -> list B -> Prop :=
  | list_forall2_nil:
      list_forall2 nil nil
  | list_forall2_cons:
      forall a1 al b1 bl,
      P a1 b1 ->
      list_forall2 al bl ->
      list_forall2 (a1 :: al) (b1 :: bl).

Lemma list_forall2_app:
  forall a2 b2 a1 b1,
  list_forall2 a1 b1 -> list_forall2 a2 b2 ->
  list_forall2 (a1 ++ a2) (b1 ++ b2).

Lemma list_forall2_length:
  forall l1 l2,
  list_forall2 l1 l2 -> length l1 = length l2.

Lemma list_forall2_in_left:
  forall x1 l1 l2,
  list_forall2 l1 l2 -> In x1 l1 -> exists x2, In x2 l2 /\ P x1 x2.

Lemma list_forall2_in_right:
  forall x2 l1 l2,
  list_forall2 l1 l2 -> In x2 l2 -> exists x1, In x1 l1 /\ P x1 x2.

End FORALL2.

Lemma list_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: list A) (l2: list B),
  list_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, In v1 l1 -> In v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  list_forall2 P2 l1 l2.

Fixpoint list_drop (A: Type) (n: nat) (x: list A) {struct n} : list A :=
  match n with
  | O => x
  | S n' => match x with nil => nil | hd :: tl => list_drop n' tl end
  end.

Lemma list_drop_incl:
  forall (A: Type) (x: A) n (l: list A), In x (list_drop n l) -> In x l.

Lemma list_drop_norepet:
  forall (A: Type) n (l: list A), list_norepet l -> list_norepet (list_drop n l).

Lemma list_map_drop:
  forall (A B: Type) (f: A -> B) n (l: list A),
  list_drop n (map f l) = map f (list_drop n l).

Fixpoint list_repeat {A: Type} (n: nat) (x: A) {struct n} :=
  match n with
  | O => nil
  | S m => x :: list_repeat m x
  end.

Lemma length_list_repeat:
  forall (A: Type) n (x: A), length (list_repeat n x) = n.

Lemma in_list_repeat:
  forall (A: Type) n (x: A) y, In y (list_repeat n x) -> y = x.

Definition proj_sumbool {P Q: Prop} (a: {P} + {Q}) : bool :=
  if a then true else false.

Coercion proj_sumbool: sumbool >-> bool.

Lemma proj_sumbool_true:
  forall (P Q: Prop) (a: {P}+{Q}), proj_sumbool a = true -> P.

Lemma proj_sumbool_is_true:
  forall (P: Prop) (a: {P}+{~P}), P -> proj_sumbool a = true.

Ltac InvBooleans :=
  match goal with
  | [ H: _ && _ = true |- _ ] =>
      destruct (andb_prop _ _ H); clear H; InvBooleans
  | [ H: _ || _ = false |- _ ] =>
      destruct (orb_false_elim _ _ H); clear H; InvBooleans
  | [ H: proj_sumbool ?x = true |- _ ] =>
      generalize (proj_sumbool_true _ H); clear H; intro; InvBooleans
  | _ => idtac
  end.

Section DECIDABLE_EQUALITY.

Variable A: Type.
Variable dec_eq: forall (x y: A), {x=y} + {x<>y}.
Variable B: Type.

Lemma dec_eq_true:
  forall (x: A) (ifso ifnot: B),
  (if dec_eq x x then ifso else ifnot) = ifso.

Lemma dec_eq_false:
  forall (x y: A) (ifso ifnot: B),
  x <> y -> (if dec_eq x y then ifso else ifnot) = ifnot.

Lemma dec_eq_sym:
  forall (x y: A) (ifso ifnot: B),
  (if dec_eq x y then ifso else ifnot) =
  (if dec_eq y x then ifso else ifnot).

End DECIDABLE_EQUALITY.

Section DECIDABLE_PREDICATE.

Variable P: Prop.
Variable dec: {P} + {~P}.
Variable A: Type.

Lemma pred_dec_true:
  forall (a b: A), P -> (if dec then a else b) = a.

Lemma pred_dec_false:
  forall (a b: A), ~P -> (if dec then a else b) = b.

End DECIDABLE_PREDICATE.

Require Import Relations.

Section LEX_ORDER.

Variable A: Type.
Variable B: Type.
Variable ordA: A -> A -> Prop.
Variable ordB: B -> B -> Prop.

Inductive lex_ord: A*B -> A*B -> Prop :=
  | lex_ord_left: forall a1 b1 a2 b2,
      ordA a1 a2 -> lex_ord (a1,b1) (a2,b2)
  | lex_ord_right: forall a b1 b2,
      ordB b1 b2 -> lex_ord (a,b1) (a,b2).

Lemma wf_lex_ord:
  well_founded ordA -> well_founded ordB -> well_founded lex_ord.

Lemma transitive_lex_ord:
  transitive _ ordA -> transitive _ ordB -> transitive _ lex_ord.

End LEX_ORDER.

Inductive nlist (A: Type) : Type :=
  | nbase: A -> nlist A
  | ncons: A -> nlist A -> nlist A.

Definition nfirst {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => a end.

Fixpoint nlast {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => nlast l' end.

Fixpoint nIn {A: Type} (x: A) (l: nlist A) : Prop :=
  match l with
  | nbase a => a = x
  | ncons a l => a = x \/ nIn x l
  end.

Inductive nlist_forall2 {A B: Type} (R: A -> B -> Prop) : nlist A -> nlist B -> Prop :=
  | nbase_forall2: forall a b, R a b -> nlist_forall2 R (nbase a) (nbase b)
  | ncons_forall2: forall a l b m, R a b -> nlist_forall2 R l m -> nlist_forall2 R (ncons a l) (ncons b m).

Lemma nlist_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: nlist A) (l2: nlist B),
  nlist_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, nIn v1 l1 -> nIn v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  nlist_forall2 P2 l1 l2. *)
(* Maps:
Require Import Equivalence EquivDec.
Require Import Coqlib.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Set Implicit Arguments.

Module Type TREE.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter empty: forall (A: Type), t A.
  Parameter get: forall (A: Type), elt -> t A -> option A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Parameter remove: forall (A: Type), elt -> t A -> t A.

  Axiom gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
    Axiom grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Axiom gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Axiom grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Parameter beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool.
  Axiom beq_correct:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true <->
    (forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end).

  Parameter map:
    forall (A B: Type), (elt -> A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Parameter map1:
    forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Parameter combine:
    forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C.
  Axiom gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).

  Parameter elements:
    forall (A: Type), t A -> list (elt * A).
  Axiom elements_correct:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    get i m = Some v -> In (i, v) (elements m).
  Axiom elements_complete:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    In (i, v) (elements m) -> get i m = Some v.
  Axiom elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).
  Axiom elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.
  Axiom elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Parameter fold:
    forall (A B: Type), (B -> elt -> A -> B) -> t A -> B -> B.
  Axiom fold_spec:
    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
  
  Parameter fold1:
    forall (A B: Type), (B -> A -> B) -> t A -> B -> B.
  Axiom fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.
End TREE.

Module Type MAP.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter init: forall (A: Type), A -> t A.
  Parameter get: forall (A: Type), elt -> t A -> A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Axiom gi:
    forall (A: Type) (i: elt) (x: A), get i (init x) = x.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Axiom gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Parameter map: forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End MAP.

Module PTree <: TREE.
  Definition elt := positive.
  Definition elt_eq := peq.

  Inductive tree (A : Type) : Type :=
    | Leaf : tree A
    | Node : tree A -> option A -> tree A -> tree A.

  Arguments Leaf [A].
  Arguments Node [A].
  Scheme tree_ind := Induction for tree Sort Prop.

  Definition t := tree.

  Definition empty (A : Type) := (Leaf : t A).

  Fixpoint get (A : Type) (i : positive) (m : t A) {struct i} : option A :=
    match m with
    | Leaf => None
    | Node l o r =>
        match i with
        | xH => o
        | xO ii => get ii l
        | xI ii => get ii r
        end
    end.

  Fixpoint set (A : Type) (i : positive) (v : A) (m : t A) {struct i} : t A :=
    match m with
    | Leaf =>
        match i with
        | xH => Node Leaf (Some v) Leaf
        | xO ii => Node (set ii v Leaf) None Leaf
        | xI ii => Node Leaf None (set ii v Leaf)
        end
    | Node l o r =>
        match i with
        | xH => Node l (Some v) r
        | xO ii => Node (set ii v l) o r
        | xI ii => Node l o (set ii v r)
        end
    end.

  Fixpoint remove (A : Type) (i : positive) (m : t A) {struct i} : t A :=
    match i with
    | xH =>
        match m with
        | Leaf => Leaf
        | Node Leaf o Leaf => Leaf
        | Node l o r => Node l None r
        end
    | xO ii =>
        match m with
        | Leaf => Leaf
        | Node l None Leaf =>
            match remove ii l with
            | Leaf => Leaf
            | mm => Node mm None Leaf
            end
        | Node l o r => Node (remove ii l) o r
        end
    | xI ii =>
        match m with
        | Leaf => Leaf
        | Node Leaf None r =>
            match remove ii r with
            | Leaf => Leaf
            | mm => Node Leaf None mm
            end
        | Node l o r => Node l o (remove ii r)
        end
    end.

  Theorem gempty:
    forall (A: Type) (i: positive), get i (empty A) = None.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x.

    Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then Some x else get i m.

  Theorem gsident:
    forall (A: Type) (i: positive) (m: t A) (v: A),
    get i m = Some v -> set i v m = m.

  Theorem set2:
    forall (A: Type) (i: elt) (m: t A) (v1 v2: A),
    set i v2 (set i v1 m) = set i v2 m.

  Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf.

  Theorem grs:
    forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None.

  Theorem gro:
    forall (A: Type) (i j: positive) (m: t A),
    i <> j -> get i (remove j m) = get i m.

  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Section BOOLEAN_EQUALITY.

    Variable A: Type.
    Variable beqA: A -> A -> bool.

    Fixpoint bempty (m: t A) : bool :=
      match m with
      | Leaf => true
      | Node l None r => bempty l && bempty r
      | Node l (Some _) r => false
      end.

    Fixpoint beq (m1 m2: t A) {struct m1} : bool :=
      match m1, m2 with
      | Leaf, _ => bempty m2
      | _, Leaf => bempty m1
      | Node l1 o1 r1, Node l2 o2 r2 =>
          match o1, o2 with
          | None, None => true
          | Some y1, Some y2 => beqA y1 y2
          | _, _ => false
          end
          && beq l1 l2 && beq r1 r2
      end.

    Lemma bempty_correct:
      forall m, bempty m = true <-> (forall x, get x m = None).

    Lemma beq_correct:
      forall m1 m2,
      beq m1 m2 = true <->
      (forall (x: elt),
       match get x m1, get x m2 with
       | None, None => True
       | Some y1, Some y2 => beqA y1 y2 = true
       | _, _ => False
       end).

  End BOOLEAN_EQUALITY.

  Fixpoint prev_append (i j: positive) {struct i} : positive :=
    match i with
      | xH => j
      | xI i' => prev_append i' (xI j)
      | xO i' => prev_append i' (xO j)
    end.

  Definition prev (i: positive) : positive :=
    prev_append i xH.

  Lemma prev_append_prev i j:
    prev (prev_append i j) = prev_append j i.

  Lemma prev_involutive i :
    prev (prev i) = i.
  Proof (prev_append_prev i xH).

  Lemma prev_append_inj i j j' :
    prev_append i j = prev_append i j' -> j = j'.

    Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive)
             {struct m} : t B :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node (xmap f l (xO i))
                           (match o with None => None | Some x => Some (f (prev i) x) end)
                           (xmap f r (xI i))
      end.

  Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH.

    Lemma xgmap:
      forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A),
      get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m).

  Theorem gmap:
    forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B :=
    match m with
    | Leaf => Leaf
    | Node l o r => Node (map1 f l) (option_map f o) (map1 f r)
    end.

  Theorem gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A :=
    match l, x, r with
    | Leaf, None, Leaf => Leaf
    | _, _, _ => Node l x r
    end.

  Lemma gnode':
    forall (A: Type) (l r: t A) (x: option A) (i: positive),
    get i (Node' l x r) = get i (Node l x r).

  Fixpoint filter1 (A: Type) (pred: A -> bool) (m: t A) {struct m} : t A :=
    match m with
    | Leaf => Leaf
    | Node l o r =>
        let o' := match o with None => None | Some x => if pred x then o else None end in
        Node' (filter1 pred l) o' (filter1 pred r)
    end.

  Theorem gfilter1:
    forall (A: Type) (pred: A -> bool) (i: elt) (m: t A),
    get i (filter1 pred m) =
    match get i m with None => None | Some x => if pred x then Some x else None end.

  Section COMBINE.

  Variables A B C: Type.
  Variable f: option A -> option B -> option C.
  Hypothesis f_none_none: f None None = None.

  Fixpoint xcombine_l (m : t A) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_l l) (f o None) (xcombine_l r)
      end.

  Lemma xgcombine_l :
          forall (m: t A) (i : positive),
          get i (xcombine_l m) = f (get i m) None.

  Fixpoint xcombine_r (m : t B) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_r l) (f None o) (xcombine_r r)
      end.

  Lemma xgcombine_r :
          forall (m: t B) (i : positive),
          get i (xcombine_r m) = f None (get i m).

  Fixpoint combine (m1: t A) (m2: t B) {struct m1} : t C :=
    match m1 with
    | Leaf => xcombine_r m2
    | Node l1 o1 r1 =>
        match m2 with
        | Leaf => xcombine_l m1
        | Node l2 o2 r2 => Node' (combine l1 l2) (f o1 o2) (combine r1 r2)
        end
    end.

  Theorem gcombine:
      forall (m1: t A) (m2: t B) (i: positive),
      get i (combine m1 m2) = f (get i m1) (get i m2).

  End COMBINE.

  Lemma xcombine_lr :
    forall (A B: Type) (f g : option A -> option A -> option B) (m : t A),
    (forall (i j : option A), f i j = g j i) ->
    xcombine_l f m = xcombine_r g m.

  Theorem combine_commut:
    forall (A B: Type) (f g: option A -> option A -> option B),
    (forall (i j: option A), f i j = g j i) ->
    forall (m1 m2: t A),
    combine f m1 m2 = combine g m2 m1.

    Fixpoint xelements (A : Type) (m : t A) (i : positive)
                       (k: list (positive * A)) {struct m}
                       : list (positive * A) :=
      match m with
      | Leaf => k
      | Node l None r =>
          xelements l (xO i) (xelements r (xI i) k)
      | Node l (Some x) r =>
          xelements l (xO i)
            ((prev i, x) :: xelements r (xI i) k)
      end.

  Definition elements (A: Type) (m : t A) := xelements m xH nil.

  Remark xelements_append:
    forall A (m: t A) i k1 k2,
    xelements m i (k1 ++ k2) = xelements m i k1 ++ k2.

  Remark xelements_leaf:
    forall A i, xelements (@Leaf A) i nil = nil.

  Remark xelements_node:
    forall A (m1: t A) o (m2: t A) i,
    xelements (Node m1 o m2) i nil =
       xelements m1 (xO i) nil
    ++ match o with None => nil | Some v => (prev i, v) :: nil end
    ++ xelements m2 (xI i) nil.

    Lemma xelements_incl:
      forall (A: Type) (m: t A) (i : positive) k x,
      In x k -> In x (xelements m i k).

    Lemma xelements_correct:
      forall (A: Type) (m: t A) (i j : positive) (v: A) k,
      get i m = Some v -> In (prev (prev_append i j), v) (xelements m j k).

  Theorem elements_correct:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    get i m = Some v -> In (i, v) (elements m).

  Lemma in_xelements:
    forall (A: Type) (m: t A) (i k: positive) (v: A) ,
    In (k, v) (xelements m i nil) ->
    exists j, k = prev (prev_append j i) /\ get j m = Some v.

  Theorem elements_complete:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    In (i, v) (elements m) -> get i m = Some v.

  Definition xkeys (A: Type) (m: t A) (i: positive) :=
    List.map (@fst positive A) (xelements m i nil).

  Remark xkeys_leaf:
    forall A i, xkeys (@Leaf A) i = nil.

  Remark xkeys_node:
    forall A (m1: t A) o (m2: t A) i,
    xkeys (Node m1 o m2) i =
       xkeys m1 (xO i)
    ++ match o with None => nil | Some v => prev i :: nil end
    ++ xkeys m2 (xI i).

  Lemma in_xkeys:
    forall (A: Type) (m: t A) (i k: positive),
    In k (xkeys m i) ->
    (exists j, k = prev (prev_append j i)).

  Lemma xelements_keys_norepet:
    forall (A: Type) (m: t A) (i: positive),
    list_norepet (xkeys m i).

  Theorem elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).

  Remark xelements_empty:
    forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil.

  Theorem elements_canonical_order':
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i, option_rel R (get i m) (get i n)) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_canonical_order:
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) ->
    (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.

  Lemma xelements_remove:
    forall (A: Type) v (m: t A) i j,
    get i m = Some v ->
    exists l1 l2,
    xelements m j nil = l1 ++ (prev (prev_append i j), v) :: l2
    /\ xelements (remove i m) j nil = l1 ++ l2.

  Theorem elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B)
                 (i: positive) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := xfold f (xO i) l v in
        xfold f (xI i) r v1
    | Node l (Some x) r =>
        let v1 := xfold f (xO i) l v in
        let v2 := f v1 (prev i) x in
        xfold f (xI i) r v2
    end.

  Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) :=
    xfold f xH m v.

  Lemma xfold_xelements:
    forall (A B: Type) (f: B -> positive -> A -> B) m i v l,
    List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) =

  Theorem fold_spec:
    forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.

  Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := fold1 f l v in
        fold1 f r v1
    | Node l (Some x) r =>
        let v1 := fold1 f l v in
        let v2 := f v1 x in
        fold1 f r v2
    end.

  Lemma fold1_xelements:
    forall (A B: Type) (f: B -> A -> B) m i v l,
    List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) =

  Theorem fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.

End PTree.

Module PMap <: MAP.
  Definition elt := positive.
  Definition elt_eq := peq.

  Definition t (A : Type) : Type := (A * PTree.t A)%type.

  Definition init (A : Type) (x : A) :=
    (x, PTree.empty A).

  Definition get (A : Type) (i : positive) (m : t A) :=
    match PTree.get i (snd m) with
    | Some x => x
    | None => fst m
    end.

  Definition set (A : Type) (i : positive) (x : A) (m : t A) :=
    (fst m, PTree.set i x (snd m)).

  Theorem gi:
    forall (A: Type) (i: positive) (x: A), get i (init x) = x.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then x else get i m.

  Theorem gsident:
    forall (A: Type) (i j: positive) (m: t A),
    get j (set i (get i m) m) = get j m.

  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
    (f (fst m), PTree.map1 f (snd m)).

  Theorem gmap:
    forall (A B: Type) (f: A -> B) (i: positive) (m: t A),
    get i (map f m) = f(get i m).

  Theorem set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End PMap.

Module Type INDEXED_TYPE.
  Parameter t: Type.
  Parameter index: t -> positive.
  Axiom index_inj: forall (x y: t), index x = index y -> x = y.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End INDEXED_TYPE.

Module IMap(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PMap.t.
  Definition init (A: Type) (x: A) := PMap.init x.
  Definition get (A: Type) (i: X.t) (m: t A) := PMap.get (X.index i) m.
  Definition set (A: Type) (i: X.t) (v: A) (m: t A) := PMap.set (X.index i) v m.
  Definition map (A B: Type) (f: A -> B) (m: t A) : t B := PMap.map f m.

  Lemma gi:
    forall (A: Type) (x: A) (i: X.t), get i (init x) = x.

  Lemma gss:
    forall (A: Type) (i: X.t) (x: A) (m: t A), get i (set i x m) = x.

  Lemma gso:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gsspec:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: X.t) (m: t A),

  Lemma set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End IMap.

Module ZIndexed.
  Definition t := Z.
  Definition index (z: Z): positive :=
    match z with
    | Z0 => xH
    | Zpos p => xO p
    | Zneg p => xI p
    end.
  Lemma index_inj: forall (x y: Z), index x = index y -> x = y.
  Definition eq := zeq.
End ZIndexed.

Module ZMap := IMap(ZIndexed).

Module NIndexed.
  Definition t := N.
  Definition index (n: N): positive :=
    match n with
    | N0 => xH
    | Npos p => xO p
    end.
  Lemma index_inj: forall (x y: N), index x = index y -> x = y.
  Lemma eq: forall (x y: N), {x = y} + {x <> y}.
End NIndexed.

Module NMap := IMap(NIndexed).

Module Type EQUALITY_TYPE.
  Parameter t: Type.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End EQUALITY_TYPE.

Module EMap(X: EQUALITY_TYPE) <: MAP.

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t (A: Type) := X.t -> A.
  Definition init (A: Type) (v: A) := fun (_: X.t) => v.
  Definition get (A: Type) (x: X.t) (m: t A) := m x.
  Definition set (A: Type) (x: X.t) (v: A) (m: t A) :=
    fun (y: X.t) => if X.eq y x then v else m y.
  Lemma gi:
    forall (A: Type) (i: elt) (x: A), init x i = x.
  Lemma gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x.
  Lemma gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> (set j x m) i = m i.
  Lemma gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Lemma gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Definition map (A B: Type) (f: A -> B) (m: t A) :=
    fun (x: X.t) => f(m x).
  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End EMap.

Module ITree(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PTree.t.

  Definition empty (A: Type): t A := PTree.empty A.
  Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m.
  Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m.
  Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m.

  Theorem gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Theorem gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Theorem gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Theorem gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
  Theorem grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Theorem gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq.
  Theorem beq_sound:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true ->
    forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end.

  Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine.
  Theorem gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).
End ITree.

Module ZTree := ITree(ZIndexed).

Module Tree_Properties(T: TREE).

Section TREE_FOLD_IND.

Variables V A: Type.
Variable f: A -> T.elt -> V -> A.
Variable P: T.t V -> A -> Prop.
Variable init: A.
Variable m_final: T.t V.

Hypothesis P_compat:
  forall m m' a,
  (forall x, T.get x m = T.get x m') ->
  P m a -> P m' a.

Hypothesis H_base:
  P (T.empty _) init.

Hypothesis H_rec:
  forall m a k v,
  T.get k m = None -> T.get k m_final = Some v -> P m a -> P (T.set k v m) (f a k v).

Let f' (a: A) (p : T.elt * V) := f a (fst p) (snd p).

Let P' (l: list (T.elt * V)) (a: A) : Prop :=
  forall m, list_equiv l (T.elements m) -> P m a.

Remark H_base':
  P' nil init.

Remark H_rec':
  forall k v l a,
  ~In k (List.map (@fst T.elt V) l) ->

Lemma fold_rec_aux:
  forall l1 l2 a,
  list_equiv (l2 ++ l1) (T.elements m_final) ->

Theorem fold_rec:
  P m_final (T.fold f m_final init).

End TREE_FOLD_IND.

Section MEASURE.

Variable V: Type.

Definition cardinal (x: T.t V) : nat := List.length (T.elements x).

Theorem cardinal_remove:
  forall x m y, T.get x m = Some y -> (cardinal (T.remove x m) < cardinal m)%nat.

Theorem cardinal_set:
  forall x m y, T.get x m = None -> (cardinal m < cardinal (T.set x y m))%nat.

End MEASURE.

Section FORALL_EXISTS.

Variable A: Type.

Definition for_all (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b && f x a) m true.

Lemma for_all_correct:
  forall m f,
  for_all m f = true <-> (forall x a, T.get x m = Some a -> f x a = true).

Definition exists_ (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b || f x a) m false.

Lemma exists_correct:
  forall m f,
  exists_ m f = true <-> (exists x a, T.get x m = Some a /\ f x a = true).

Remark exists_for_all:
  forall m f,
  exists_ m f = negb (for_all m (fun x a => negb (f x a))).

Remark for_all_exists:
  forall m f,
  for_all m f = negb (exists_ m (fun x a => negb (f x a))).

Lemma for_all_false:
  forall m f,
  for_all m f = false <-> (exists x a, T.get x m = Some a /\ f x a = false).

Lemma exists_false:
  forall m f,
  exists_ m f = false <-> (forall x a, T.get x m = Some a -> f x a = false).

End FORALL_EXISTS.

Section BOOLEAN_EQUALITY.

Variable A: Type.
Variable beqA: A -> A -> bool.

Theorem beq_false:
  forall m1 m2,
  T.beq beqA m1 m2 = false <->

End BOOLEAN_EQUALITY.

Section EXTENSIONAL_EQUALITY.

Variable A: Type.
Variable eqA: A -> A -> Prop.
Hypothesis eqAeq: Equivalence eqA.

Definition Equal (m1 m2: T.t A) : Prop :=
  forall x, match T.get x m1, T.get x m2 with
                | None, None => True
                | Some a1, Some a2 => a1 === a2
                | _, _ => False
            end.

Lemma Equal_refl: forall m, Equal m m.

Lemma Equal_sym: forall m1 m2, Equal m1 m2 -> Equal m2 m1.

Lemma Equal_trans: forall m1 m2 m3, Equal m1 m2 -> Equal m2 m3 -> Equal m1 m3.

Instance Equal_Equivalence : Equivalence Equal := {
  Equivalence_Reflexive := Equal_refl;
  Equivalence_Symmetric := Equal_sym;
  Equivalence_Transitive := Equal_trans
}.

Hypothesis eqAdec: EqDec A eqA.

Program Definition Equal_dec (m1 m2: T.t A) : { m1 === m2 } + { m1 =/= m2 } :=

Instance Equal_EqDec : EqDec (T.t A) Equal := Equal_dec.

End EXTENSIONAL_EQUALITY.

Section OF_LIST.

Variable A: Type.

Let f := fun (m: T.t A) (k_v: T.elt * A) => T.set (fst k_v) (snd k_v) m.

Definition of_list (l: list (T.elt * A)) : T.t A :=
  List.fold_left f l (T.empty _).

Lemma in_of_list:
  forall l k v, T.get k (of_list l) = Some v -> In (k, v) l.

Lemma of_list_dom:
  forall l k, In k (map fst l) -> exists v, T.get k (of_list l) = Some v.

Remark of_list_unchanged:
  forall k l m, ~In k (map fst l) -> T.get k (List.fold_left f l m) = T.get k m.

Lemma of_list_unique:
  forall k v l1 l2,
  ~In k (map fst l2) -> T.get k (of_list (l1 ++ (k, v) :: l2)) = Some v.

Lemma of_list_norepet:
  forall l k v, list_norepet (map fst l) -> In (k, v) l -> T.get k (of_list l) = Some v.

Lemma of_list_elements:
  forall m k, T.get k (of_list (T.elements m)) = T.get k m.

End OF_LIST.

Lemma of_list_related:
  forall (A B: Type) (R: A -> B -> Prop) k l1 l2,
  list_forall2 (fun ka kb => fst ka = fst kb /\ R (snd ka) (snd kb)) l1 l2 ->
  option_rel R (T.get k (of_list l1)) (T.get k (of_list l2)).

End Tree_Properties.

Module PTree_Properties := Tree_Properties(PTree).

Notation "a ! b" := (PTree.get b a) (at level 1).
Notation "a !! b" := (PMap.get b a) (at level 1). *)
(* Errors:
Require Import String.
Require Import Coqlib.

Close Scope string_scope.

Set Implicit Arguments.

Inductive errcode: Type :=
  | MSG: string -> errcode
  | CTX: positive -> errcode    
  | POS: positive -> errcode.   

Definition errmsg: Type := list errcode.

Definition msg (s: string) : errmsg := MSG s :: nil.

Inductive res (A: Type) : Type :=
| OK: A -> res A
| Error: errmsg -> res A.

Arguments Error [A].

Definition bind (A B: Type) (f: res A) (g: A -> res B) : res B :=
  match f with
  | OK x => g x
  | Error msg => Error msg
  end.

Definition bind2 (A B C: Type) (f: res (A * B)) (g: A -> B -> res C) : res C :=
  match f with
  | OK (x, y) => g x y
  | Error msg => Error msg
  end.

Notation "'do' X <- A ; B" := (bind A (fun X => B))
 (at level 200, X ident, A at level 100, B at level 200)
 : error_monad_scope.

Notation "'do' ( X , Y ) <- A ; B" := (bind2 A (fun X Y => B))
 (at level 200, X ident, Y ident, A at level 100, B at level 200)
 : error_monad_scope.

Remark bind_inversion:
  forall (A B: Type) (f: res A) (g: A -> res B) (y: B),
  bind f g = OK y ->
  exists x, f = OK x /\ g x = OK y.

Remark bind2_inversion:
  forall (A B C: Type) (f: res (A*B)) (g: A -> B -> res C) (z: C),
  bind2 f g = OK z ->
  exists x, exists y, f = OK (x, y) /\ g x y = OK z.

Definition assertion_failed {A: Type} : res A := Error(msg "Assertion failed").

Notation "'assertion' A ; B" := (if A then B else assertion_failed)
  (at level 200, A at level 100, B at level 200)
  : error_monad_scope.

Local Open Scope error_monad_scope.

Fixpoint mmap (A B: Type) (f: A -> res B) (l: list A) {struct l} : res (list B) :=
  match l with
  | nil => OK nil
  | hd :: tl => do hd' <- f hd; do tl' <- mmap f tl; OK (hd' :: tl')
  end.

Remark mmap_inversion:
  forall (A B: Type) (f: A -> res B) (l: list A) (l': list B),
  mmap f l = OK l' ->
  list_forall2 (fun x y => f x = OK y) l l'.

Ltac monadInv1 H :=
  match type of H with
  | (OK _ = OK _) =>
      inversion H; clear H; try subst
  | (Error _ = OK _) =>
      discriminate
  | (bind ?F ?G = OK ?X) =>
      let x := fresh "x" in (
      let EQ1 := fresh "EQ" in (
      let EQ2 := fresh "EQ" in (
      destruct (bind_inversion F G H) as [x [EQ1 EQ2]];
      clear H;
      try (monadInv1 EQ2))))
  | (bind2 ?F ?G = OK ?X) =>
      let x1 := fresh "x" in (
      let x2 := fresh "x" in (
      let EQ1 := fresh "EQ" in (
      let EQ2 := fresh "EQ" in (
      destruct (bind2_inversion F G H) as [x1 [x2 [EQ1 EQ2]]];
      clear H;
      try (monadInv1 EQ2)))))
  | (match ?X with left _ => _ | right _ => assertion_failed end = OK _) =>
      destruct X; [try (monadInv1 H) | discriminate]
  | (match (negb ?X) with true => _ | false => assertion_failed end = OK _) =>
      destruct X as [] eqn:?; [discriminate | try (monadInv1 H)]
  | (match ?X with true => _ | false => assertion_failed end = OK _) =>
      destruct X as [] eqn:?; [try (monadInv1 H) | discriminate]
  | (mmap ?F ?L = OK ?M) =>
      generalize (mmap_inversion F L H); intro
  end.

Ltac monadInv H :=
  monadInv1 H ||
  match type of H with
  | (?F _ _ _ _ _ _ _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ _ _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  | (?F _ = OK _) =>
      ((progress simpl in H) || unfold F in H); monadInv1 H
  end. *)

Require Import AST Linking.
(* AST:
Require Import String.
Require Import Coqlib Maps Errors Integers Floats.
Require Archi.

Set Implicit Arguments.

Definition ident := positive.

Definition ident_eq := peq.

Inductive typ : Type :=
  | Tint                
  | Tfloat              
  | Tlong               
  | Tsingle             
  | Tany32              
  | Tany64.             

Lemma typ_eq: forall (t1 t2: typ), {t1=t2} + {t1<>t2}.
Global Opaque typ_eq.

Definition opt_typ_eq: forall (t1 t2: option typ), {t1=t2} + {t1<>t2}
                     := option_eq typ_eq.

Definition list_typ_eq: forall (l1 l2: list typ), {l1=l2} + {l1<>l2}
                     := list_eq_dec typ_eq.

Definition Tptr : typ := if Archi.ptr64 then Tlong else Tint.

Definition typesize (ty: typ) : Z :=
  match ty with
  | Tint => 4
  | Tfloat => 8
  | Tlong => 8
  | Tsingle => 4
  | Tany32 => 4
  | Tany64 => 8
  end.

Lemma typesize_pos: forall ty, typesize ty > 0.

Lemma typesize_Tptr: typesize Tptr = if Archi.ptr64 then 8 else 4.

Definition subtype (ty1 ty2: typ) : bool :=
  match ty1, ty2 with
  | Tint, Tint => true
  | Tlong, Tlong => true
  | Tfloat, Tfloat => true
  | Tsingle, Tsingle => true
  | (Tint | Tsingle | Tany32), Tany32 => true
  | _, Tany64 => true
  | _, _ => false
  end.

Fixpoint subtype_list (tyl1 tyl2: list typ) : bool :=
  match tyl1, tyl2 with
  | nil, nil => true
  | ty1::tys1, ty2::tys2 => subtype ty1 ty2 && subtype_list tys1 tys2
  | _, _ => false
  end.

Record calling_convention : Type := mkcallconv {
  cc_vararg: bool;                      
  cc_unproto: bool;                     
  cc_structret: bool                    
}.

Definition cc_default :=
  {| cc_vararg := false; cc_unproto := false; cc_structret := false |}.

Definition calling_convention_eq (x y: calling_convention) : {x=y} + {x<>y}.
Global Opaque calling_convention_eq.

Record signature : Type := mksignature {
  sig_args: list typ;
  sig_res: option typ;
  sig_cc: calling_convention
}.

Definition proj_sig_res (s: signature) : typ :=
  match s.(sig_res) with
  | None => Tint
  | Some t => t
  end.

Definition signature_eq: forall (s1 s2: signature), {s1=s2} + {s1<>s2}.
Global Opaque signature_eq.

Definition signature_main :=
  {| sig_args := nil; sig_res := Some Tint; sig_cc := cc_default |}.

Inductive memory_chunk : Type :=
  | Mint8signed     
  | Mint8unsigned   
  | Mint16signed    
  | Mint16unsigned  
  | Mint32          
  | Mint64          
  | Mfloat32        
  | Mfloat64        
  | Many32          
  | Many64.         

Definition chunk_eq: forall (c1 c2: memory_chunk), {c1=c2} + {c1<>c2}.
Global Opaque chunk_eq.

Definition Mptr : memory_chunk := if Archi.ptr64 then Mint64 else Mint32.

Definition type_of_chunk (c: memory_chunk) : typ :=
  match c with
  | Mint8signed => Tint
  | Mint8unsigned => Tint
  | Mint16signed => Tint
  | Mint16unsigned => Tint
  | Mint32 => Tint
  | Mint64 => Tlong
  | Mfloat32 => Tsingle
  | Mfloat64 => Tfloat
  | Many32 => Tany32
  | Many64 => Tany64
  end.

Lemma type_of_Mptr: type_of_chunk Mptr = Tptr.

Definition chunk_of_type (ty: typ) :=
  match ty with
  | Tint => Mint32
  | Tfloat => Mfloat64
  | Tlong => Mint64
  | Tsingle => Mfloat32
  | Tany32 => Many32
  | Tany64 => Many64
  end.

Lemma chunk_of_Tptr: chunk_of_type Tptr = Mptr.

Inductive init_data: Type :=
  | Init_int8: int -> init_data
  | Init_int16: int -> init_data
  | Init_int32: int -> init_data
  | Init_int64: int64 -> init_data
  | Init_float32: float32 -> init_data
  | Init_float64: float -> init_data
  | Init_space: Z -> init_data
  | Init_addrof: ident -> ptrofs -> init_data.  

Definition init_data_size (i: init_data) : Z :=
  match i with
  | Init_int8 _ => 1
  | Init_int16 _ => 2
  | Init_int32 _ => 4
  | Init_int64 _ => 8
  | Init_float32 _ => 4
  | Init_float64 _ => 8
  | Init_addrof _ _ => if Archi.ptr64 then 8 else 4
  | Init_space n => Z.max n 0
  end.

Fixpoint init_data_list_size (il: list init_data) {struct il} : Z :=
  match il with
  | nil => 0
  | i :: il' => init_data_size i + init_data_list_size il'
  end.

Lemma init_data_size_pos:
  forall i, init_data_size i >= 0.

Lemma init_data_list_size_pos:
  forall il, init_data_list_size il >= 0.

Record globvar (V: Type) : Type := mkglobvar {
  gvar_info: V;                    
  gvar_init: list init_data;       
  gvar_readonly: bool;             
  gvar_volatile: bool              
}.

Inductive globdef (F V: Type) : Type :=
  | Gfun (f: F)
  | Gvar (v: globvar V).

Arguments Gfun [F V].
Arguments Gvar [F V].

Record program (F V: Type) : Type := mkprogram {
  prog_defs: list (ident * globdef F V);
  prog_public: list ident;
  prog_main: ident
}.

Definition prog_defs_names (F V: Type) (p: program F V) : list ident :=
  List.map fst p.(prog_defs).

Definition prog_defmap (F V: Type) (p: program F V) : PTree.t (globdef F V) :=
  PTree_Properties.of_list p.(prog_defs).

Section DEFMAP.

Variables F V: Type.
Variable p: program F V.

Lemma in_prog_defmap:
  forall id g, (prog_defmap p)!id = Some g -> In (id, g) (prog_defs p).

Lemma prog_defmap_dom:
  forall id, In id (prog_defs_names p) -> exists g, (prog_defmap p)!id = Some g.

Lemma prog_defmap_unique:
  forall defs1 id g defs2,
  prog_defs p = defs1 ++ (id, g) :: defs2 ->
  ~In id (map fst defs2) ->
  (prog_defmap p)!id = Some g.

Lemma prog_defmap_norepet:
  forall id g,
  list_norepet (prog_defs_names p) ->
  In (id, g) (prog_defs p) ->
  (prog_defmap p)!id = Some g.

End DEFMAP.

Section TRANSF_PROGRAM.

Variable A B V: Type.
Variable transf: A -> B.

Definition transform_program_globdef (idg: ident * globdef A V) : ident * globdef B V :=
  match idg with
  | (id, Gfun f) => (id, Gfun (transf f))
  | (id, Gvar v) => (id, Gvar v)
  end.

Definition transform_program (p: program A V) : program B V :=
  mkprogram
    (List.map transform_program_globdef p.(prog_defs))
    p.(prog_public)
    p.(prog_main).

End TRANSF_PROGRAM.

Local Open Scope error_monad_scope.

Section TRANSF_PROGRAM_GEN.

Variables A B V W: Type.
Variable transf_fun: ident -> A -> res B.
Variable transf_var: ident -> V -> res W.

Definition transf_globvar (i: ident) (g: globvar V) : res (globvar W) :=
  do info' <- transf_var i g.(gvar_info);
  OK (mkglobvar info' g.(gvar_init) g.(gvar_readonly) g.(gvar_volatile)).

Fixpoint transf_globdefs (l: list (ident * globdef A V)) : res (list (ident * globdef B W)) :=
  match l with
  | nil => OK nil
  | (id, Gfun f) :: l' =>
    match transf_fun id f with
      | Error msg => Error (MSG "In function " :: CTX id :: MSG ": " :: msg)
      | OK tf =>
        do tl' <- transf_globdefs l'; OK ((id, Gfun tf) :: tl')
    end
  | (id, Gvar v) :: l' =>
    match transf_globvar id v with
      | Error msg => Error (MSG "In variable " :: CTX id :: MSG ": " :: msg)
      | OK tv =>
        do tl' <- transf_globdefs l'; OK ((id, Gvar tv) :: tl')
    end
  end.

Definition transform_partial_program2 (p: program A V) : res (program B W) :=
  do gl' <- transf_globdefs p.(prog_defs);
  OK (mkprogram gl' p.(prog_public) p.(prog_main)).

End TRANSF_PROGRAM_GEN.

Section TRANSF_PARTIAL_PROGRAM.

Variable A B V: Type.
Variable transf_fun: A -> res B.

Definition transform_partial_program (p: program A V) : res (program B V) :=
  transform_partial_program2 (fun i f => transf_fun f) (fun i v => OK v) p.

End TRANSF_PARTIAL_PROGRAM.

Lemma transform_program_partial_program:
  forall (A B V: Type) (transf_fun: A -> B) (p: program A V),
  transform_partial_program (fun f => OK (transf_fun f)) p = OK (transform_program transf_fun p).

Inductive external_function : Type :=
  | EF_external (name: string) (sg: signature)
       | EF_builtin (name: string) (sg: signature)
       | EF_runtime (name: string) (sg: signature)
       | EF_vload (chunk: memory_chunk)
       | EF_vstore (chunk: memory_chunk)
       | EF_malloc
       | EF_free
       | EF_memcpy (sz: Z) (al: Z)
     
  | EF_annot (kind: positive) (text: string) (targs: list typ)
       | EF_annot_val (kind: positive) (text: string) (targ: typ)
       | EF_inline_asm (text: string) (sg: signature) (clobbers: list string)
       | EF_debug (kind: positive) (text: ident) (targs: list typ).
     Definition ef_sig (ef: external_function): signature :=
  match ef with
  | EF_external name sg => sg
  | EF_builtin name sg => sg
  | EF_runtime name sg => sg
  | EF_vload chunk => mksignature (Tptr :: nil) (Some (type_of_chunk chunk)) cc_default
  | EF_vstore chunk => mksignature (Tptr :: type_of_chunk chunk :: nil) None cc_default
  | EF_malloc => mksignature (Tptr :: nil) (Some Tptr) cc_default
  | EF_free => mksignature (Tptr :: nil) None cc_default
  | EF_memcpy sz al => mksignature (Tptr :: Tptr :: nil) None cc_default
  | EF_annot kind text targs => mksignature targs None cc_default
  | EF_annot_val kind text targ => mksignature (targ :: nil) (Some targ) cc_default
  | EF_inline_asm text sg clob => sg
  | EF_debug kind text targs => mksignature targs None cc_default
  end.

Definition ef_inline (ef: external_function) : bool :=
  match ef with
  | EF_external name sg => false
  | EF_builtin name sg => true
  | EF_runtime name sg => false
  | EF_vload chunk => true
  | EF_vstore chunk => true
  | EF_malloc => false
  | EF_free => false
  | EF_memcpy sz al => true
  | EF_annot kind text targs => true
  | EF_annot_val kind Text rg => true
  | EF_inline_asm text sg clob => true
  | EF_debug kind text targs => true
  end.

Definition ef_reloads (ef: external_function) : bool :=
  match ef with
  | EF_annot kind text targs => false
  | EF_debug kind text targs => false
  | _ => true
  end.

Definition external_function_eq: forall (ef1 ef2: external_function), {ef1=ef2} + {ef1<>ef2}.
Global Opaque external_function_eq.

Inductive fundef (F: Type): Type :=
  | Internal: F -> fundef F
  | External: external_function -> fundef F.

Arguments External [F].

Section TRANSF_FUNDEF.

Variable A B: Type.
Variable transf: A -> B.

Definition transf_fundef (fd: fundef A): fundef B :=
  match fd with
  | Internal f => Internal (transf f)
  | External ef => External ef
  end.

End TRANSF_FUNDEF.

Section TRANSF_PARTIAL_FUNDEF.

Variable A B: Type.
Variable transf_partial: A -> res B.

Definition transf_partial_fundef (fd: fundef A): res (fundef B) :=
  match fd with
  | Internal f => do f' <- transf_partial f; OK (Internal f')
  | External ef => OK (External ef)
  end.

End TRANSF_PARTIAL_FUNDEF.

Set Contextual Implicit.

Inductive rpair (A: Type) : Type :=
  | One (r: A)
  | Twolong (rhi rlo: A).

Definition typ_rpair (A: Type) (typ_of: A -> typ) (p: rpair A): typ :=
  match p with
  | One r => typ_of r
  | Twolong rhi rlo => Tlong
  end.

Definition map_rpair (A B: Type) (f: A -> B) (p: rpair A): rpair B :=
  match p with
  | One r => One (f r)
  | Twolong rhi rlo => Twolong (f rhi) (f rlo)
  end.

Definition regs_of_rpair (A: Type) (p: rpair A): list A :=
  match p with
  | One r => r :: nil
  | Twolong rhi rlo => rhi :: rlo :: nil
  end.

Fixpoint regs_of_rpairs (A: Type) (l: list (rpair A)): list A :=
  match l with
  | nil => nil
  | p :: l => regs_of_rpair p ++ regs_of_rpairs l
  end.

Lemma in_regs_of_rpairs:
  forall (A: Type) (x: A) p, In x (regs_of_rpair p) -> forall l, In p l -> In x (regs_of_rpairs l).

Lemma in_regs_of_rpairs_inv:
  forall (A: Type) (x: A) l, In x (regs_of_rpairs l) -> exists p, In p l /\ In x (regs_of_rpair p).

Definition forall_rpair (A: Type) (P: A -> Prop) (p: rpair A): Prop :=
  match p with
  | One r => P r
  | Twolong rhi rlo => P rhi /\ P rlo
  end.

Inductive builtin_arg (A: Type) : Type :=
  | BA (x: A)
  | BA_int (n: int)
  | BA_long (n: int64)
  | BA_float (f: float)
  | BA_single (f: float32)
  | BA_loadstack (chunk: memory_chunk) (ofs: ptrofs)
  | BA_addrstack (ofs: ptrofs)
  | BA_loadglobal (chunk: memory_chunk) (id: ident) (ofs: ptrofs)
  | BA_addrglobal (id: ident) (ofs: ptrofs)
  | BA_splitlong (hi lo: builtin_arg A)
  | BA_addptr (a1 a2: builtin_arg A).

Inductive builtin_res (A: Type) : Type :=
  | BR (x: A)
  | BR_none
  | BR_splitlong (hi lo: builtin_res A).

Fixpoint globals_of_builtin_arg (A: Type) (a: builtin_arg A) : list ident :=
  match a with
  | BA_loadglobal chunk id ofs => id :: nil
  | BA_addrglobal id ofs => id :: nil
  | BA_splitlong hi lo => globals_of_builtin_arg hi ++ globals_of_builtin_arg lo
  | BA_addptr a1 a2 => globals_of_builtin_arg a1 ++ globals_of_builtin_arg a2
  | _ => nil
  end.

Definition globals_of_builtin_args (A: Type) (al: list (builtin_arg A)) : list ident :=
  List.fold_right (fun a l => globals_of_builtin_arg a ++ l) nil al.

Fixpoint params_of_builtin_arg (A: Type) (a: builtin_arg A) : list A :=
  match a with
  | BA x => x :: nil
  | BA_splitlong hi lo => params_of_builtin_arg hi ++ params_of_builtin_arg lo
  | BA_addptr a1 a2 => params_of_builtin_arg a1 ++ params_of_builtin_arg a2
  | _ => nil
  end.

Definition params_of_builtin_args (A: Type) (al: list (builtin_arg A)) : list A :=
  List.fold_right (fun a l => params_of_builtin_arg a ++ l) nil al.

Fixpoint params_of_builtin_res (A: Type) (a: builtin_res A) : list A :=
  match a with
  | BR x => x :: nil
  | BR_none => nil
  | BR_splitlong hi lo => params_of_builtin_res hi ++ params_of_builtin_res lo
  end.

Fixpoint map_builtin_arg (A B: Type) (f: A -> B) (a: builtin_arg A) : builtin_arg B :=
  match a with
  | BA x => BA (f x)
  | BA_int n => BA_int n
  | BA_long n => BA_long n
  | BA_float n => BA_float n
  | BA_single n => BA_single n
  | BA_loadstack chunk ofs => BA_loadstack chunk ofs
  | BA_addrstack ofs => BA_addrstack ofs
  | BA_loadglobal chunk id ofs => BA_loadglobal chunk id ofs
  | BA_addrglobal id ofs => BA_addrglobal id ofs
  | BA_splitlong hi lo =>
      BA_splitlong (map_builtin_arg f hi) (map_builtin_arg f lo)
  | BA_addptr a1 a2 =>
      BA_addptr (map_builtin_arg f a1) (map_builtin_arg f a2)
  end.

Fixpoint map_builtin_res (A B: Type) (f: A -> B) (a: builtin_res A) : builtin_res B :=
  match a with
  | BR x => BR (f x)
  | BR_none => BR_none
  | BR_splitlong hi lo =>
      BR_splitlong (map_builtin_res f hi) (map_builtin_res f lo)
  end.

Inductive builtin_arg_constraint : Type :=
  | OK_default
  | OK_const
  | OK_addrstack
  | OK_addressing
  | OK_all. *)
(* Linking:
Require Import Coqlib Maps Errors AST.

Class Linker (A: Type) := {
  link: A -> A -> option A;
  linkorder: A -> A -> Prop;
  linkorder_refl: forall x, linkorder x x;
  linkorder_trans: forall x y z, linkorder x y -> linkorder y z -> linkorder x z;
  link_linkorder: forall x y z, link x y = Some z -> linkorder x z /\ linkorder y z
}.

Definition link_fundef {F: Type} (fd1 fd2: fundef F) :=
  match fd1, fd2 with
  | Internal _, Internal _ => None
  | External ef1, External ef2 =>
      if external_function_eq ef1 ef2 then Some (External ef1) else None
  | Internal f, External ef =>
      match ef with EF_external id sg => Some (Internal f) | _ => None end
  | External ef, Internal f =>
      match ef with EF_external id sg => Some (Internal f) | _ => None end
  end.

Global Opaque Linker_fundef.

Inductive init_class : list init_data -> Type :=
  | Init_extern: init_class nil
  | Init_common: forall sz, init_class (Init_space sz :: nil)
  | Init_definitive: forall il, init_class il.

Definition classify_init (i: list init_data) : init_class i :=
  match i with
  | nil => Init_extern
  | Init_space sz :: nil => Init_common sz
  | i => Init_definitive i
  end.

Definition link_varinit (i1 i2: list init_data) :=
  match classify_init i1, classify_init i2 with
  | Init_extern, _ => Some i2
  | _, Init_extern => Some i1
  | Init_common sz1, _ => if zeq sz1 (init_data_list_size i2) then Some i2 else None
  | _, Init_common sz2 => if zeq sz2 (init_data_list_size i1) then Some i1 else None
  | _, _ => None
  end.

Global Opaque Linker_varinit.

Definition link_vardef {V: Type} {LV: Linker V} (v1 v2: globvar V) :=
  match link v1.(gvar_info) v2.(gvar_info) with

Global Opaque Linker_vardef.

Program Instance Linker_unit: Linker unit := {
  link := fun x y => Some tt;
  linkorder := fun x y => True
}.

Global Opaque Linker_unit.

Definition link_def {F V: Type} {LF: Linker F} {LV: Linker V} (gd1 gd2: globdef F V) :=
  match gd1, gd2 with
  | Gfun f1, Gfun f2 =>
      match link f1 f2 with Some f => Some (Gfun f) | None => None end
  | Gvar v1, Gvar v2 =>
      match link v1 v2 with Some v => Some (Gvar v) | None => None end
  | _, _ => None
  end.

Global Opaque Linker_def.

Section LINKER_PROG.

Context {F V: Type} {LF: Linker F} {LV: Linker V} (p1 p2: program F V).

Let dm1 := prog_defmap p1.
Let dm2 := prog_defmap p2.

Definition link_prog_check (x: ident) (gd1: globdef F V) :=
  match dm2!x with
  | None => true
  | Some gd2 =>
      In_dec peq x p1.(prog_public)
      && In_dec peq x p2.(prog_public)
      && match link gd1 gd2 with Some _ => true | None => false end
  end.

Definition link_prog_merge (o1 o2: option (globdef F V)) :=
  match o1, o2 with
  | None, _ => o2
  | _, None => o1
  | Some gd1, Some gd2 => link gd1 gd2
  end.

Definition link_prog :=
  if ident_eq p1.(prog_main) p2.(prog_main)
  && PTree_Properties.for_all dm1 link_prog_check then
    Some {| prog_main := p1.(prog_main);
            prog_public := p1.(prog_public) ++ p2.(prog_public);
            prog_defs := PTree.elements (PTree.combine link_prog_merge dm1 dm2) |}
  else
    None.

Lemma link_prog_inv:
  forall p,
  link_prog = Some p ->
      p1.(prog_main) = p2.(prog_main)

Lemma link_prog_succeeds:
  p1.(prog_main) = p2.(prog_main) ->

Lemma prog_defmap_elements:
  forall (m: PTree.t (globdef F V)) pub mn x,

Lemma prog_defmap_linkorder:
  forall {F V: Type} {LF: Linker F} {LV: Linker V} (p1 p2: program F V) id gd1,
  linkorder p1 p2 ->
  (prog_defmap p1)!id = Some gd1 ->
  exists gd2, (prog_defmap p2)!id = Some gd2 /\ linkorder gd1 gd2.

Global Opaque Linker_prog.

Section MATCH_PROGRAM_GENERIC.

Context {C F1 V1 F2 V2: Type} {LC: Linker C} {LF: Linker F1} {LV: Linker V1}.
Variable match_fundef: C -> F1 -> F2 -> Prop.
Variable match_varinfo: V1 -> V2 -> Prop.

Inductive match_globvar: globvar V1 -> globvar V2 -> Prop :=
  | match_globvar_intro: forall i1 i2 init ro vo,
      match_varinfo i1 i2 ->
      match_globvar (mkglobvar i1 init ro vo) (mkglobvar i2 init ro vo).

Inductive match_globdef (ctx: C): globdef F1 V1 -> globdef F2 V2 -> Prop :=
  | match_globdef_fun: forall ctx' f1 f2,
      linkorder ctx' ctx ->
      match_fundef ctx' f1 f2 ->
      match_globdef ctx (Gfun f1) (Gfun f2)
  | match_globdef_var: forall v1 v2,
      match_globvar v1 v2 ->
      match_globdef ctx (Gvar v1) (Gvar v2).

Definition match_ident_globdef
     (ctx: C) (ig1: ident * globdef F1 V1) (ig2: ident * globdef F2 V2) : Prop :=
  fst ig1 = fst ig2 /\ match_globdef ctx (snd ig1) (snd ig2).

Definition match_program_gen (ctx: C) (p1: program F1 V1) (p2: program F2 V2) : Prop :=
  list_forall2 (match_ident_globdef ctx) p1.(prog_defs) p2.(prog_defs)
  /\ p2.(prog_main) = p1.(prog_main)
  /\ p2.(prog_public) = p1.(prog_public).

Theorem match_program_defmap:
  forall ctx p1 p2, match_program_gen ctx p1 p2 ->
  forall id, option_rel (match_globdef ctx) (prog_defmap p1)!id (prog_defmap p2)!id.

Lemma match_program_gen_main:
  forall ctx p1 p2, match_program_gen ctx p1 p2 -> p2.(prog_main) = p1.(prog_main).

Lemma match_program_public:
  forall ctx p1 p2, match_program_gen ctx p1 p2 -> p2.(prog_public) = p1.(prog_public).

End MATCH_PROGRAM_GENERIC.

Definition match_program {F1 V1 F2 V2: Type} {LF: Linker F1} {LV: Linker V1}
                         (match_fundef: program F1 V1 -> F1 -> F2 -> Prop)
                         (match_varinfo: V1 -> V2 -> Prop)
                         (p1: program F1 V1) (p2: program F2 V2) : Prop :=
  match_program_gen match_fundef match_varinfo p1 p1 p2.

Lemma match_program_main:
  forall {F1 V1 F2 V2: Type} {LF: Linker F1} {LV: Linker V1}
         {match_fundef: program F1 V1 -> F1 -> F2 -> Prop}
         {match_varinfo: V1 -> V2 -> Prop}
         {p1: program F1 V1} {p2: program F2 V2},
  match_program match_fundef match_varinfo p1 p2 -> p2.(prog_main) = p1.(prog_main).

Theorem match_transform_partial_program2:
  forall {C F1 V1 F2 V2: Type} {LC: Linker C} {LF: Linker F1} {LV: Linker V1}
         (match_fundef: C -> F1 -> F2 -> Prop)
         (match_varinfo: V1 -> V2 -> Prop)
         (transf_fun: ident -> F1 -> res F2)
         (transf_var: ident -> V1 -> res V2)
         (ctx: C) (p: program F1 V1) (tp: program F2 V2),
  transform_partial_program2 transf_fun transf_var p = OK tp ->
  (forall i f tf, transf_fun i f = OK tf -> match_fundef ctx f tf) ->
  (forall i v tv, transf_var i v = OK tv -> match_varinfo v tv) ->
  match_program_gen match_fundef match_varinfo ctx p tp.

Theorem match_transform_partial_program_contextual:
  forall {A B V: Type} {LA: Linker A} {LV: Linker V}
         (match_fundef: program A V -> A -> B -> Prop)
         (transf_fun: A -> res B)
         (p: program A V) (tp: program B V),
  transform_partial_program transf_fun p = OK tp ->
  (forall f tf, transf_fun f = OK tf -> match_fundef p f tf) ->
  match_program match_fundef eq p tp.

Theorem match_transform_program_contextual:
  forall {A B V: Type} {LA: Linker A} {LV: Linker V}
         (match_fundef: program A V -> A -> B -> Prop)
         (transf_fun: A -> B)
         (p: program A V),
  (forall f, match_fundef p f (transf_fun f)) ->
  match_program match_fundef eq p (transform_program transf_fun p).

Theorem match_transform_partial_program:
  forall {A B V: Type} {LA: Linker A} {LV: Linker V}
         (transf_fun: A -> res B)
         (p: program A V) (tp: program B V),
  transform_partial_program transf_fun p = OK tp ->
  match_program (fun cu f tf => transf_fun f = OK tf) eq p tp.

Theorem match_transform_program:
  forall {A B V: Type} {LA: Linker A} {LV: Linker V}
         (transf: A -> B)
         (p: program A V),
  match_program (fun cu f tf => tf = transf f) eq p (transform_program transf p).

Section LINK_MATCH_PROGRAM.

Context {C F1 V1 F2 V2: Type} {LC: Linker C} {LF1: Linker F1} {LF2: Linker F2} {LV1: Linker V1} {LV2: Linker V2}.
Variable match_fundef: C -> F1 -> F2 -> Prop.
Variable match_varinfo: V1 -> V2 -> Prop.

Local Transparent Linker_vardef Linker_def Linker_prog.

Hypothesis link_match_fundef:
  forall ctx1 ctx2 f1 tf1 f2 tf2 f,
  link f1 f2 = Some f ->
  match_fundef ctx1 f1 tf1 -> match_fundef ctx2 f2 tf2 ->
  exists tf, link tf1 tf2 = Some tf /\ (match_fundef ctx1 f tf \/ match_fundef ctx2 f tf).

Hypothesis link_match_varinfo:
  forall v1 tv1 v2 tv2 v,
  link v1 v2 = Some v ->
  match_varinfo v1 tv1 -> match_varinfo v2 tv2 ->
  exists tv, link tv1 tv2 = Some tv /\ match_varinfo v tv.

Lemma link_match_globvar:
  forall v1 tv1 v2 tv2 v,
  link v1 v2 = Some v ->
  match_globvar match_varinfo v1 tv1 -> match_globvar match_varinfo v2 tv2 ->
  exists tv, link tv1 tv2 = Some tv /\ match_globvar match_varinfo v tv.

Lemma link_match_globdef:
  forall ctx1 ctx2 ctx g1 tg1 g2 tg2 g,
  linkorder ctx1 ctx -> linkorder ctx2 ctx ->
  link g1 g2 = Some g ->
  match_globdef match_fundef match_varinfo ctx1 g1 tg1 ->
  match_globdef match_fundef match_varinfo ctx2 g2 tg2 ->
  exists tg, link tg1 tg2 = Some tg /\ match_globdef match_fundef match_varinfo ctx g tg.

Lemma match_globdef_linkorder:
  forall ctx ctx' g tg,
  match_globdef match_fundef match_varinfo ctx g tg ->
  linkorder ctx ctx' ->
  match_globdef match_fundef match_varinfo ctx' g tg.

Theorem link_match_program:
  forall ctx1 ctx2 ctx p1 p2 tp1 tp2 p,
  link p1 p2 = Some p ->
  match_program_gen match_fundef match_varinfo ctx1 p1 tp1 ->
  match_program_gen match_fundef match_varinfo ctx2 p2 tp2 ->
  linkorder ctx1 ctx -> linkorder ctx2 ctx ->
  exists tp, link tp1 tp2 = Some tp /\ match_program_gen match_fundef match_varinfo ctx p tp.

End LINK_MATCH_PROGRAM.

Class TransfLink {A B: Type} {LA: Linker A} {LB: Linker B} (transf: A -> B -> Prop) :=
  transf_link:
    forall (p1 p2: A) (tp1 tp2: B) (p: A),
    link p1 p2 = Some p ->
    transf p1 tp1 -> transf p2 tp2 ->
    exists tp, link tp1 tp2 = Some tp /\ transf p tp.

Remark link_transf_partial_fundef:
  forall (A B: Type) (tr1 tr2: A -> res B) (f1 f2: fundef A) (tf1 tf2: fundef B) (f: fundef A),
  link f1 f2 = Some f ->
  transf_partial_fundef tr1 f1 = OK tf1 ->
  transf_partial_fundef tr2 f2 = OK tf2 ->
  exists tf,
      link tf1 tf2 = Some tf
  /\ (transf_partial_fundef tr1 f = OK tf \/ transf_partial_fundef tr2 f = OK tf).

Section LINK_LIST.

Context {A: Type} {LA: Linker A}.

Fixpoint link_list (l: nlist A) : option A :=
  match l with
  | nbase a => Some a
  | ncons a l =>
      match link_list l with None => None | Some b => link a b end
  end.

Lemma link_list_linkorder:
  forall a l b, link_list l = Some b -> nIn a l -> linkorder a b.

End LINK_LIST.

Section LINK_LIST_MATCH.

Context {A B: Type} {LA: Linker A} {LB: Linker B} (prog_match: A -> B -> Prop) {TL: TransfLink prog_match}.

Theorem link_list_match:
  forall al bl, nlist_forall2 prog_match al bl ->
  forall a, link_list al = Some a ->
  exists b, link_list bl = Some b /\ prog_match a b.

End LINK_LIST_MATCH.

Set Implicit Arguments.

Structure Language := mklang { lang_prog :> Type; lang_link: Linker lang_prog }.

Canonical Structure Language_gen (A: Type) (L: Linker A) : Language := @mklang A L.

Record Pass (S T: Language) := mkpass {
  pass_match :> lang_prog S -> lang_prog T -> Prop;
  pass_match_link: @TransfLink (lang_prog S) (lang_prog T) (lang_link S) (lang_link T) pass_match
}.

Arguments mkpass {S} {T} (pass_match) {pass_match_link}.

Program Definition pass_identity (l: Language): Pass l l :=
  {| pass_match := fun p1 p2 => p1 = p2;
     pass_match_link := _ |}.

Program Definition pass_compose {l1 l2 l3: Language} (pass: Pass l1 l2) (pass': Pass l2 l3) : Pass l1 l3 :=
  {| pass_match := fun p1 p3 => exists p2, pass_match pass p1 p2 /\ pass_match pass' p2 p3;
     pass_match_link := _ |}.

Inductive Passes: Language -> Language -> Type :=
  | pass_nil: forall l, Passes l l
  | pass_cons: forall l1 l2 l3, Pass l1 l2 -> Passes l2 l3 -> Passes l1 l3.

Infix ":::" := pass_cons (at level 60, right associativity) : linking_scope.

Fixpoint compose_passes (l l': Language) (passes: Passes l l') : Pass l l' :=
  match passes in Passes l l' return Pass l l' with
  | pass_nil l => pass_identity l
  | pass_cons l1 l2 l3 pass1 passes => pass_compose pass1 (compose_passes passes)
  end.

Lemma nlist_forall2_identity:
  forall (A: Type) (la lb: nlist A),
  nlist_forall2 (fun a b => a = b) la lb -> la = lb.

Lemma nlist_forall2_compose_inv:
  forall (A B C: Type) (R1: A -> B -> Prop) (R2: B -> C -> Prop)
         (la: nlist A) (lc: nlist C),
  nlist_forall2 (fun a c => exists b, R1 a b /\ R2 b c) la lc ->
  exists lb: nlist B, nlist_forall2 R1 la lb /\ nlist_forall2 R2 lb lc.

Theorem link_list_compose_passes:
  forall (src tgt: Language) (passes: Passes src tgt)
         (src_units: nlist src) (tgt_units: nlist tgt),
  nlist_forall2 (pass_match (compose_passes passes)) src_units tgt_units ->
  forall src_prog,
  @link_list _ (lang_link src) src_units = Some src_prog ->
  exists tgt_prog,
  @link_list _ (lang_link tgt) tgt_units = Some tgt_prog
  /\ pass_match (compose_passes passes) src_prog tgt_prog. *)

Require Archi.



Inductive signedness : Type :=

  | Signed: signedness

  | Unsigned: signedness.



Inductive intsize : Type :=

  | I8: intsize

  | I16: intsize

  | I32: intsize

  | IBool: intsize.



Inductive floatsize : Type :=

  | F32: floatsize

  | F64: floatsize.



Record attr : Type := mk_attr {

  attr_volatile: bool;

  attr_alignas: option N         

}.



Definition noattr := {| attr_volatile := false; attr_alignas := None |}.



Inductive type : Type :=

  | Tvoid: type                                    

  | Tint: intsize -> signedness -> attr -> type    

  | Tlong: signedness -> attr -> type              

  | Tfloat: floatsize -> attr -> type              

  | Tpointer: type -> attr -> type                 

  | Tarray: type -> Z -> attr -> type              

  | Tfunction: typelist -> type -> calling_convention -> type    

  | Tstruct: ident -> attr -> type                 

  | Tunion: ident -> attr -> type                  

with typelist : Type :=

  | Tnil: typelist

  | Tcons: type -> typelist -> typelist.



Lemma intsize_eq: forall (s1 s2: intsize), {s1=s2} + {s1<>s2}.

Proof.

  decide equality.

Defined.



Lemma type_eq: forall (ty1 ty2: type), {ty1=ty2} + {ty1<>ty2}

with typelist_eq: forall (tyl1 tyl2: typelist), {tyl1=tyl2} + {tyl1<>tyl2}.

Proof.

  assert (forall (x y: signedness), {x=y} + {x<>y}) by decide equality.

  assert (forall (x y: floatsize), {x=y} + {x<>y}) by decide equality.

  assert (forall (x y: attr), {x=y} + {x<>y}).

  { decide equality. decide equality. apply N.eq_dec. apply bool_dec. }

  generalize ident_eq zeq bool_dec ident_eq intsize_eq; intros.

  decide equality.

  decide equality.

  decide equality.

Defined.



Opaque type_eq typelist_eq.



Definition attr_of_type (ty: type) :=

  match ty with

  | Tvoid => noattr

  | Tint sz si a => a

  | Tlong si a => a

  | Tfloat sz a => a

  | Tpointer elt a => a

  | Tarray elt sz a => a

  | Tfunction args res cc => noattr

  | Tstruct id a => a

  | Tunion id a => a

  end.



Definition change_attributes (f: attr -> attr) (ty: type) : type :=

  match ty with

  | Tvoid => ty

  | Tint sz si a => Tint sz si (f a)

  | Tlong si a => Tlong si (f a)

  | Tfloat sz a => Tfloat sz (f a)

  | Tpointer elt a => Tpointer elt (f a)

  | Tarray elt sz a => Tarray elt sz (f a)

  | Tfunction args res cc => ty

  | Tstruct id a => Tstruct id (f a)

  | Tunion id a => Tunion id (f a)

  end.



Definition remove_attributes (ty: type) : type :=

  change_attributes (fun _ => noattr) ty.



Definition attr_union (a1 a2: attr) : attr :=

  {| attr_volatile := a1.(attr_volatile) || a2.(attr_volatile);

     attr_alignas :=

       match a1.(attr_alignas), a2.(attr_alignas) with

       | None, al => al

       | al, None => al

       | Some n1, Some n2 => Some (N.max n1 n2)

       end

  |}.



Definition merge_attributes (ty: type) (a: attr) : type :=

  change_attributes (attr_union a) ty.



Inductive struct_or_union : Type := Struct | Union.



Definition members : Type := list (ident * type).



Inductive composite_definition : Type :=

  Composite (id: ident) (su: struct_or_union) (m: members) (a: attr).



Definition name_composite_def (c: composite_definition) : ident :=

  match c with Composite id su m a => id end.



Definition composite_def_eq (x y: composite_definition): {x=y} + {x<>y}.

Proof.

  decide equality.

- decide equality. decide equality. apply N.eq_dec. apply bool_dec.

- apply list_eq_dec. decide equality. apply type_eq. apply ident_eq.

- decide equality.

- apply ident_eq.

Defined.



Global Opaque composite_def_eq. 



Record composite : Type := {

  co_su: struct_or_union;

  co_members: members;

  co_attr: attr;

  co_sizeof: Z;

  co_alignof: Z;

  co_rank: nat;

  co_sizeof_pos: co_sizeof >= 0;

  co_alignof_two_p: exists n, co_alignof = two_power_nat n;

  co_sizeof_alignof: (co_alignof | co_sizeof)

}.



Definition composite_env : Type := PTree.t composite.



Definition type_int32s := Tint I32 Signed noattr.

Definition type_bool := Tint IBool Signed noattr.



Definition typeconv (ty: type) : type :=

  match ty with

  | Tint (I8 | I16 | IBool) _ _ => Tint I32 Signed noattr

  | Tarray t sz a       => Tpointer t noattr

  | Tfunction _ _ _     => Tpointer ty noattr

  | _                   => remove_attributes ty

  end.



Definition default_argument_conversion (ty: type) : type :=

  match ty with

  | Tint (I8 | I16 | IBool) _ _ => Tint I32 Signed noattr

  | Tfloat _ _          => Tfloat F64 noattr

  | Tarray t sz a       => Tpointer t noattr

  | Tfunction _ _ _     => Tpointer ty noattr

  | _                   => remove_attributes ty

  end.



Fixpoint complete_type (env: composite_env) (t: type) : bool :=

  match t with

  | Tvoid => false

  | Tint _ _ _ => true

  | Tlong _ _ => true

  | Tfloat _ _ => true

  | Tpointer _ _ => true

  | Tarray t' _ _ => complete_type env t'

  | Tfunction _ _ _ => false

  | Tstruct id _ | Tunion id _ =>

      match env!id with Some co => true | None => false end

  end.



Definition complete_or_function_type (env: composite_env) (t: type) : bool :=

  match t with

  | Tfunction _ _ _ => true

  | _ => complete_type env t

  end.



Definition align_attr (a: attr) (al: Z) : Z :=

  match attr_alignas a with

  | Some l => two_p (Z.of_N l)

  | None => al

  end.



Fixpoint alignof (env: composite_env) (t: type) : Z :=

  align_attr (attr_of_type t)

   (match t with

      | Tvoid => 1

      | Tint I8 _ _ => 1

      | Tint I16 _ _ => 2

      | Tint I32 _ _ => 4

      | Tint IBool _ _ => 1

      | Tlong _ _ => Archi.align_int64

      | Tfloat F32 _ => 4

      | Tfloat F64 _ => Archi.align_float64

      | Tpointer _ _ => if Archi.ptr64 then 8 else 4

      | Tarray t' _ _ => alignof env t'

      | Tfunction _ _ _ => 1

      | Tstruct id _ | Tunion id _ =>

          match env!id with Some co => co_alignof co | None => 1 end

    end).



Remark align_attr_two_p:

  forall al a,

  (exists n, al = two_power_nat n) ->

  (exists n, align_attr a al = two_power_nat n).

Proof.

  intros. unfold align_attr. destruct (attr_alignas a).

  exists (N.to_nat n). rewrite two_power_nat_two_p. rewrite N_nat_Z. auto.

  auto.

Qed.



Lemma alignof_two_p:

  forall env t, exists n, alignof env t = two_power_nat n.

Proof.

  induction t; apply align_attr_two_p; simpl.

  exists 0%nat; auto.

  destruct i.

    exists 0%nat; auto.

    exists 1%nat; auto.

    exists 2%nat; auto.

    exists 0%nat; auto.

    unfold Archi.align_int64. destruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity)).

  destruct f.

    exists 2%nat; auto.

    unfold Archi.align_float64. destruct Archi.ptr64; ((exists 2%nat; reflexivity) || (exists 3%nat; reflexivity)).

  exists (if Archi.ptr64 then 3%nat else 2%nat); destruct Archi.ptr64; auto.

  apply IHt.

  exists 0%nat; auto.

  destruct (env!i). apply co_alignof_two_p. exists 0%nat; auto.

  destruct (env!i). apply co_alignof_two_p. exists 0%nat; auto.

Qed.



Lemma alignof_pos:

  forall env t, alignof env t > 0.

Proof.

  intros. destruct (alignof_two_p env t) as [n EQ]. rewrite EQ. apply two_power_nat_pos.

Qed.



Fixpoint sizeof (env: composite_env) (t: type) : Z :=

  match t with

  | Tvoid => 1

  | Tint I8 _ _ => 1

  | Tint I16 _ _ => 2

  | Tint I32 _ _ => 4

  | Tint IBool _ _ => 1

  | Tlong _ _ => 8

  | Tfloat F32 _ => 4

  | Tfloat F64 _ => 8

  | Tpointer _ _ => if Archi.ptr64 then 8 else 4

  | Tarray t' n _ => sizeof env t' * Z.max 0 n

  | Tfunction _ _ _ => 1

  | Tstruct id _ | Tunion id _ =>

      match env!id with Some co => co_sizeof co | None => 0 end

  end.



Lemma sizeof_pos:

  forall env t, sizeof env t >= 0.

Proof.

  induction t; simpl; try omega.

  destruct i; omega.

  destruct f; omega.

  destruct Archi.ptr64; omega.

  change 0 with (0 * Z.max 0 z) at 2. apply Zmult_ge_compat_r. auto. xomega.

  destruct (env!i). apply co_sizeof_pos. omega.

  destruct (env!i). apply co_sizeof_pos. omega.

Qed.



Fixpoint naturally_aligned (t: type) : Prop :=

  attr_alignas (attr_of_type t) = None /\

  match t with

  | Tarray t' _ _ => naturally_aligned t'

  | _ => True

  end.



Lemma sizeof_alignof_compat:

  forall env t, naturally_aligned t -> (alignof env t | sizeof env t).

Proof.

  induction t; intros [A B]; unfold alignof, align_attr; rewrite A; simpl.

- apply Z.divide_refl.

- destruct i; apply Z.divide_refl.

- exists (8 / Archi.align_int64). unfold Archi.align_int64; destruct Archi.ptr64; reflexivity.

- destruct f. apply Z.divide_refl. exists (8 / Archi.align_float64). unfold Archi.align_float64; destruct Archi.ptr64; reflexivity.

- apply Z.divide_refl.

- apply Z.divide_mul_l; auto.

- apply Z.divide_refl.

- destruct (env!i). apply co_sizeof_alignof. apply Z.divide_0_r.

- destruct (env!i). apply co_sizeof_alignof. apply Z.divide_0_r.

Qed.



Fixpoint alignof_composite (env: composite_env) (m: members) : Z :=

  match m with

  | nil => 1

  | (id, t) :: m' => Z.max (alignof env t) (alignof_composite env m')

  end.



Fixpoint sizeof_struct (env: composite_env) (cur: Z) (m: members) : Z :=

  match m with

  | nil => cur

  | (id, t) :: m' => sizeof_struct env (align cur (alignof env t) + sizeof env t) m'

  end.



Fixpoint sizeof_union (env: composite_env) (m: members) : Z :=

  match m with

  | nil => 0

  | (id, t) :: m' => Z.max (sizeof env t) (sizeof_union env m')

  end.



Lemma alignof_composite_two_p:

  forall env m, exists n, alignof_composite env m = two_power_nat n.

Proof.

  induction m as [|[id t]]; simpl.

- exists 0%nat; auto.

- apply Z.max_case; auto. apply alignof_two_p.

Qed.



Lemma alignof_composite_pos:

  forall env m a, align_attr a (alignof_composite env m) > 0.

Proof.

  intros.

  exploit align_attr_two_p. apply (alignof_composite_two_p env m).

  instantiate (1 := a). intros [n EQ].

  rewrite EQ; apply two_power_nat_pos.

Qed.



Lemma sizeof_struct_incr:

  forall env m cur, cur <= sizeof_struct env cur m.

Proof.

  induction m as [|[id t]]; simpl; intros.

- omega.

- apply Z.le_trans with (align cur (alignof env t)).

  apply align_le. apply alignof_pos.

  apply Z.le_trans with (align cur (alignof env t) + sizeof env t).

  generalize (sizeof_pos env t); omega.

  apply IHm.

Qed.



Lemma sizeof_union_pos:

  forall env m, 0 <= sizeof_union env m.

Proof.

  induction m as [|[id t]]; simpl; xomega.

Qed.



Fixpoint field_offset_rec (env: composite_env) (id: ident) (fld: members) (pos: Z)

                          {struct fld} : res Z :=

  match fld with

  | nil => Error (MSG "Unknown field " :: CTX id :: nil)

  | (id', t) :: fld' =>

      if ident_eq id id'

      then OK (align pos (alignof env t))

      else field_offset_rec env id fld' (align pos (alignof env t) + sizeof env t)

  end.



Definition field_offset (env: composite_env) (id: ident) (fld: members) : res Z :=

  field_offset_rec env id fld 0.



Fixpoint field_type (id: ident) (fld: members) {struct fld} : res type :=

  match fld with

  | nil => Error (MSG "Unknown field " :: CTX id :: nil)

  | (id', t) :: fld' => if ident_eq id id' then OK t else field_type id fld'

  end.



Remark field_offset_rec_in_range:

  forall env id ofs ty fld pos,

  field_offset_rec env id fld pos = OK ofs -> field_type id fld = OK ty ->

  pos <= ofs /\ ofs + sizeof env ty <= sizeof_struct env pos fld.

Proof.

  intros until ty. induction fld as [|[i t]]; simpl; intros.

- discriminate.

- destruct (ident_eq id i); intros.

  inv H. inv H0. split.

  apply align_le. apply alignof_pos. apply sizeof_struct_incr.

  exploit IHfld; eauto. intros [A B]. split; auto.

  eapply Z.le_trans; eauto. apply Z.le_trans with (align pos (alignof env t)).

  apply align_le. apply alignof_pos. generalize (sizeof_pos env t). omega.

Qed.



Lemma field_offset_in_range:

  forall env fld id ofs ty,

  field_offset env id fld = OK ofs -> field_type id fld = OK ty ->

  0 <= ofs /\ ofs + sizeof env ty <= sizeof_struct env 0 fld.

Proof.

  intros. eapply field_offset_rec_in_range; eauto.

Qed.



Lemma field_offset_no_overlap:

  forall env id1 ofs1 ty1 id2 ofs2 ty2 fld,

  field_offset env id1 fld = OK ofs1 -> field_type id1 fld = OK ty1 ->

  field_offset env id2 fld = OK ofs2 -> field_type id2 fld = OK ty2 ->

  id1 <> id2 ->

  ofs1 + sizeof env ty1 <= ofs2 \/ ofs2 + sizeof env ty2 <= ofs1.

Proof.

  intros until fld. unfold field_offset. generalize 0 as pos.

  induction fld as [|[i t]]; simpl; intros.

- discriminate.

- destruct (ident_eq id1 i); destruct (ident_eq id2 i).

+ congruence.

+ subst i. inv H; inv H0.

  exploit field_offset_rec_in_range. eexact H1. eauto. tauto.

+ subst i. inv H1; inv H2.

  exploit field_offset_rec_in_range. eexact H. eauto. tauto.

+ eapply IHfld; eauto.

Qed.



Lemma field_offset_prefix:

  forall env id ofs fld2 fld1,

  field_offset env id fld1 = OK ofs ->

  field_offset env id (fld1 ++ fld2) = OK ofs.

Proof.

  intros until fld1. unfold field_offset. generalize 0 as pos.

  induction fld1 as [|[i t]]; simpl; intros.

- discriminate.

- destruct (ident_eq id i); auto.

Qed.



Lemma field_offset_aligned:

  forall env id fld ofs ty,

  field_offset env id fld = OK ofs -> field_type id fld = OK ty ->

  (alignof env ty | ofs).

Proof.

  intros until ty. unfold field_offset. generalize 0 as pos. revert fld.

  induction fld as [|[i t]]; simpl; intros.

- discriminate.

- destruct (ident_eq id i).

+ inv H; inv H0. apply align_divides. apply alignof_pos.

+ eauto.

Qed.



Inductive mode: Type :=

  | By_value: memory_chunk -> mode

  | By_reference: mode

  | By_copy: mode

  | By_nothing: mode.



Definition access_mode (ty: type) : mode :=

  match ty with

  | Tint I8 Signed _ => By_value Mint8signed

  | Tint I8 Unsigned _ => By_value Mint8unsigned

  | Tint I16 Signed _ => By_value Mint16signed

  | Tint I16 Unsigned _ => By_value Mint16unsigned

  | Tint I32 _ _ => By_value Mint32

  | Tint IBool _ _ => By_value Mint8unsigned

  | Tlong _ _ => By_value Mint64

  | Tfloat F32 _ => By_value Mfloat32

  | Tfloat F64 _ => By_value Mfloat64

  | Tvoid => By_nothing

  | Tpointer _ _ => By_value Mptr

  | Tarray _ _ _ => By_reference

  | Tfunction _ _ _ => By_reference

  | Tstruct _ _ => By_copy

  | Tunion _ _ => By_copy

end.



Definition type_is_volatile (ty: type) : bool :=

  match access_mode ty with

  | By_value _ => attr_volatile (attr_of_type ty)

  | _          => false

  end.



Fixpoint alignof_blockcopy (env: composite_env) (t: type) : Z :=

  match t with

  | Tvoid => 1

  | Tint I8 _ _ => 1

  | Tint I16 _ _ => 2

  | Tint I32 _ _ => 4

  | Tint IBool _ _ => 1

  | Tlong _ _ => 8

  | Tfloat F32 _ => 4

  | Tfloat F64 _ => 8

  | Tpointer _ _ => if Archi.ptr64 then 8 else 4

  | Tarray t' _ _ => alignof_blockcopy env t'

  | Tfunction _ _ _ => 1

  | Tstruct id _ | Tunion id _ =>

      match env!id with

      | Some co => Z.min 8 (co_alignof co)

      | None => 1

      end

  end.



Lemma alignof_blockcopy_1248:

  forall env ty, let a := alignof_blockcopy env ty in a = 1 \/ a = 2 \/ a = 4 \/ a = 8.

Proof.

  assert (X: forall co, let a := Z.min 8 (co_alignof co) in

             a = 1 \/ a = 2 \/ a = 4 \/ a = 8).

  {

    intros. destruct (co_alignof_two_p co) as [n EQ]. unfold a; rewrite EQ.

    destruct n; auto.

    destruct n; auto.

    destruct n; auto.

    right; right; right. apply Z.min_l.

    rewrite two_power_nat_two_p. rewrite ! Nat2Z.inj_succ.

    change 8 with (two_p 3). apply two_p_monotone. omega.

  }

  induction ty; simpl.

  auto.

  destruct i; auto.

  auto.

  destruct f; auto.

  destruct Archi.ptr64; auto.

  apply IHty.

  auto.

  destruct (env!i); auto.

  destruct (env!i); auto.

Qed.



Lemma alignof_blockcopy_pos:

  forall env ty, alignof_blockcopy env ty > 0.

Proof.

  intros. generalize (alignof_blockcopy_1248 env ty). simpl. intuition omega.

Qed.



Lemma sizeof_alignof_blockcopy_compat:

  forall env ty, (alignof_blockcopy env ty | sizeof env ty).

Proof.

  assert (X: forall co, (Z.min 8 (co_alignof co) | co_sizeof co)).

  {

    intros. apply Z.divide_trans with (co_alignof co). 2: apply co_sizeof_alignof.

    destruct (co_alignof_two_p co) as [n EQ]. rewrite EQ.

    destruct n. apply Z.divide_refl.

    destruct n. apply Z.divide_refl.

    destruct n. apply Z.divide_refl.

    apply Z.min_case.

    exists (two_p (Z.of_nat n)).

    change 8 with (two_p 3).

    rewrite <- two_p_is_exp by omega.

    rewrite two_power_nat_two_p. rewrite !Nat2Z.inj_succ. f_equal. omega.

    apply Z.divide_refl.

  }

  induction ty; simpl.

  apply Z.divide_refl.

  apply Z.divide_refl.

  apply Z.divide_refl.

  apply Z.divide_refl.

  apply Z.divide_refl.

  apply Z.divide_mul_l. auto.

  apply Z.divide_refl.

  destruct (env!i). apply X. apply Z.divide_0_r.

  destruct (env!i). apply X. apply Z.divide_0_r.

Qed.



Fixpoint rank_type (ce: composite_env) (t: type) : nat :=

  match t with

  | Tarray t' _ _ => S (rank_type ce t')

  | Tstruct id _ | Tunion id _ =>

      match ce!id with

      | None => O

      | Some co => S (co_rank co)

      end

  | _ => O

  end.



Fixpoint rank_members (ce: composite_env) (m: members) : nat :=

  match m with

  | nil => 0%nat

  | (id, t) :: m => Init.Nat.max (rank_type ce t) (rank_members ce m)

  end.



Fixpoint type_of_params (params: list (ident * type)) : typelist :=

  match params with

  | nil => Tnil

  | (id, ty) :: rem => Tcons ty (type_of_params rem)

  end.



Definition typ_of_type (t: type) : AST.typ :=

  match t with

  | Tvoid => AST.Tint

  | Tint _ _ _ => AST.Tint

  | Tlong _ _ => AST.Tlong

  | Tfloat F32 _ => AST.Tsingle

  | Tfloat F64 _ => AST.Tfloat

  | Tpointer _ _ | Tarray _ _ _ | Tfunction _ _ _ | Tstruct _ _ | Tunion _ _ => AST.Tptr

  end.



Definition opttyp_of_type (t: type) : option AST.typ :=

  if type_eq t Tvoid then None else Some (typ_of_type t).



Fixpoint typlist_of_typelist (tl: typelist) : list AST.typ :=

  match tl with

  | Tnil => nil

  | Tcons hd tl => typ_of_type hd :: typlist_of_typelist tl

  end.



Definition signature_of_type (args: typelist) (res: type) (cc: calling_convention): signature :=

  mksignature (typlist_of_typelist args) (opttyp_of_type res) cc.



Definition sizeof_composite (env: composite_env) (su: struct_or_union) (m: members) : Z :=

  match su with

  | Struct => sizeof_struct env 0 m

  | Union  => sizeof_union env m

  end.



Lemma sizeof_composite_pos:

  forall env su m, 0 <= sizeof_composite env su m.

Proof.

  intros. destruct su; simpl.

  apply sizeof_struct_incr.

  apply sizeof_union_pos.

Qed.



Fixpoint complete_members (env: composite_env) (m: members) : bool :=

  match m with

  | nil => true

  | (id, t) :: m' => complete_type env t && complete_members env m'

  end.



Lemma complete_member:

  forall env id t m,

  In (id, t) m -> complete_members env m = true -> complete_type env t = true.

Proof.

  induction m as [|[id1 t1] m]; simpl; intuition auto.

  InvBooleans; inv H1; auto.

  InvBooleans; eauto.

Qed.



Program Definition composite_of_def

     (env: composite_env) (id: ident) (su: struct_or_union) (m: members) (a: attr)

     : res composite :=

  match env!id, complete_members env m return _ with

  | Some _, _ =>

      Error (MSG "Multiple definitions of struct or union " :: CTX id :: nil)

  | None, false =>

      Error (MSG "Incomplete struct or union " :: CTX id :: nil)

  | None, true =>

      let al := align_attr a (alignof_composite env m) in

      OK {| co_su := su;

            co_members := m;

            co_attr := a;

            co_sizeof := align (sizeof_composite env su m) al;

            co_alignof := al;

            co_rank := rank_members env m;

            co_sizeof_pos := _;

            co_alignof_two_p := _;

            co_sizeof_alignof := _ |}

  end.

Next Obligation.

  apply Z.le_ge. eapply Z.le_trans. eapply sizeof_composite_pos.

  apply align_le; apply alignof_composite_pos.

Defined.

Next Obligation.

  apply align_attr_two_p. apply alignof_composite_two_p.

Defined.

Next Obligation.

  apply align_divides. apply alignof_composite_pos.

Defined.



Local Open Scope error_monad_scope.



Fixpoint add_composite_definitions (env: composite_env) (defs: list composite_definition) : res composite_env :=

  match defs with

  | nil => OK env

  | Composite id su m a :: defs =>

      do co <- composite_of_def env id su m a;

      add_composite_definitions (PTree.set id co env) defs

  end.



Definition build_composite_env (defs: list composite_definition) :=

  add_composite_definitions (PTree.empty _) defs.



Section STABILITY.



Variables env env': composite_env.

Hypothesis extends: forall id co, env!id = Some co -> env'!id = Some co.



Lemma alignof_stable:

  forall t, complete_type env t = true -> alignof env' t = alignof env t.

Proof.

  induction t; simpl; intros; f_equal; auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

Qed.



Lemma sizeof_stable:

  forall t, complete_type env t = true -> sizeof env' t = sizeof env t.

Proof.

  induction t; simpl; intros; auto.

  rewrite IHt by auto. auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

Qed.



Lemma complete_type_stable:

  forall t, complete_type env t = true -> complete_type env' t = true.

Proof.

  induction t; simpl; intros; auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

Qed.



Lemma rank_type_stable:

  forall t, complete_type env t = true -> rank_type env' t = rank_type env t.

Proof.

  induction t; simpl; intros; auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

  destruct (env!i) as [co|] eqn:E; try discriminate.

  erewrite extends by eauto. auto.

Qed.



Lemma alignof_composite_stable:

  forall m, complete_members env m = true -> alignof_composite env' m = alignof_composite env m.

Proof.

  induction m as [|[id t]]; simpl; intros.

  auto.

  InvBooleans. rewrite alignof_stable by auto. rewrite IHm by auto. auto.

Qed.



Lemma sizeof_struct_stable:

  forall m pos, complete_members env m = true -> sizeof_struct env' pos m = sizeof_struct env pos m.

Proof.

  induction m as [|[id t]]; simpl; intros.

  auto.

  InvBooleans. rewrite alignof_stable by auto. rewrite sizeof_stable by auto.

  rewrite IHm by auto. auto.

Qed.



Lemma sizeof_union_stable:

  forall m, complete_members env m = true -> sizeof_union env' m = sizeof_union env m.

Proof.

  induction m as [|[id t]]; simpl; intros.

  auto.

  InvBooleans. rewrite sizeof_stable by auto. rewrite IHm by auto. auto.

Qed.



Lemma sizeof_composite_stable:

  forall su m, complete_members env m = true -> sizeof_composite env' su m = sizeof_composite env su m.

Proof.

  intros. destruct su; simpl.

  apply sizeof_struct_stable; auto.

  apply sizeof_union_stable; auto.

Qed.



Lemma complete_members_stable:

  forall m, complete_members env m = true -> complete_members env' m = true.

Proof.

  induction m as [|[id t]]; simpl; intros.

  auto.

  InvBooleans. rewrite complete_type_stable by auto. rewrite IHm by auto. auto.

Qed.



Lemma rank_members_stable:

  forall m, complete_members env m = true -> rank_members env' m = rank_members env m.

Proof.

  induction m as [|[id t]]; simpl; intros.

  auto.

  InvBooleans. f_equal; auto. apply rank_type_stable; auto.

Qed.



End STABILITY.



Lemma add_composite_definitions_incr:

  forall id co defs env1 env2,

  add_composite_definitions env1 defs = OK env2 ->

  env1!id = Some co -> env2!id = Some co.

Proof.

  induction defs; simpl; intros.

- inv H; auto.

- destruct a; monadInv H.

  eapply IHdefs; eauto. rewrite PTree.gso; auto.

  red; intros; subst id0. unfold composite_of_def in EQ. rewrite H0 in EQ; discriminate.

Qed.



Record composite_consistent (env: composite_env) (co: composite) : Prop := {

  co_consistent_complete:

     complete_members env (co_members co) = true;

  co_consistent_alignof:

     co_alignof co = align_attr (co_attr co) (alignof_composite env (co_members co));

  co_consistent_sizeof:

     co_sizeof co = align (sizeof_composite env (co_su co) (co_members co)) (co_alignof co);

  co_consistent_rank:

     co_rank co = rank_members env (co_members co)

}.



Definition composite_env_consistent (env: composite_env) : Prop :=

  forall id co, env!id = Some co -> composite_consistent env co.



Lemma composite_consistent_stable:

  forall (env env': composite_env)

         (EXTENDS: forall id co, env!id = Some co -> env'!id = Some co)

         co,

  composite_consistent env co -> composite_consistent env' co.

Proof.

  intros. destruct H as [A B C D]. constructor. 

  eapply complete_members_stable; eauto.

  symmetry; rewrite B. f_equal. apply alignof_composite_stable; auto. 

  symmetry; rewrite C. f_equal. apply sizeof_composite_stable; auto.

  symmetry; rewrite D. apply rank_members_stable; auto.

Qed.



Lemma composite_of_def_consistent:

  forall env id su m a co,

  composite_of_def env id su m a = OK co ->

  composite_consistent env co.

Proof.

  unfold composite_of_def; intros. 

  destruct (env!id); try discriminate. destruct (complete_members env m) eqn:C; inv H.

  constructor; auto.

Qed. 



Theorem build_composite_env_consistent:

  forall defs env, build_composite_env defs = OK env -> composite_env_consistent env.

Proof.

  cut (forall defs env0 env,

       add_composite_definitions env0 defs = OK env ->

       composite_env_consistent env0 ->

       composite_env_consistent env).

  intros. eapply H; eauto. red; intros. rewrite PTree.gempty in H1; discriminate.

  induction defs as [|d1 defs]; simpl; intros.

- inv H; auto.

- destruct d1; monadInv H.

  eapply IHdefs; eauto.

  set (env1 := PTree.set id x env0) in *.

  assert (env0!id = None). 

  { unfold composite_of_def in EQ. destruct (env0!id). discriminate. auto. }

  assert (forall id1 co1, env0!id1 = Some co1 -> env1!id1 = Some co1).

  { intros. unfold env1. rewrite PTree.gso; auto. congruence. }

  red; intros. apply composite_consistent_stable with env0; auto.

  unfold env1 in H2; rewrite PTree.gsspec in H2; destruct (peq id0 id).

+ subst id0. inversion H2; clear H2. subst co.

  eapply composite_of_def_consistent; eauto.

+ eapply H0; eauto. 

Qed.



Theorem build_composite_env_charact:

  forall id su m a defs env,

  build_composite_env defs = OK env ->

  In (Composite id su m a) defs ->

  exists co, env!id = Some co /\ co_members co = m /\ co_attr co = a /\ co_su co = su.

Proof.

  intros until defs. unfold build_composite_env. generalize (PTree.empty composite) as env0.

  revert defs. induction defs as [|d1 defs]; simpl; intros.

- contradiction.

- destruct d1; monadInv H.

  destruct H0; [idtac|eapply IHdefs;eauto]. inv H.

  unfold composite_of_def in EQ.

  destruct (env0!id) eqn:E; try discriminate.

  destruct (complete_members env0 m) eqn:C; simplify_eq EQ. clear EQ; intros EQ.

  exists x.

  split. eapply add_composite_definitions_incr; eauto. apply PTree.gss.

  subst x; auto.

Qed.



Theorem build_composite_env_domain:

  forall env defs id co,

  build_composite_env defs = OK env ->

  env!id = Some co ->

  In (Composite id (co_su co) (co_members co) (co_attr co)) defs.

Proof.

  intros env0 defs0 id co.

  assert (REC: forall l env env',

    add_composite_definitions env l = OK env' ->

    env'!id = Some co ->

    env!id = Some co \/ In (Composite id (co_su co) (co_members co) (co_attr co)) l).

  { induction l; simpl; intros. 

  - inv H; auto.

  - destruct a; monadInv H. exploit IHl; eauto.

    unfold composite_of_def in EQ. destruct (env!id0) eqn:E; try discriminate.

    destruct (complete_members env m) eqn:C; simplify_eq EQ. clear EQ; intros EQ.

    rewrite PTree.gsspec. intros [A|A]; auto.

    destruct (peq id id0); auto.

    inv A. rewrite <- H0; auto.

  }

  intros. exploit REC; eauto. rewrite PTree.gempty. intuition congruence.

Qed.



Remark rank_type_members:

  forall ce id t m, In (id, t) m -> (rank_type ce t <= rank_members ce m)%nat.

Proof.

  induction m; simpl; intros; intuition auto.

  subst a. xomega.

  xomega.

Qed.



Lemma rank_struct_member:

  forall ce id a co id1 t1,

  composite_env_consistent ce ->

  ce!id = Some co ->

  In (id1, t1) (co_members co) ->

  (rank_type ce t1 < rank_type ce (Tstruct id a))%nat.

Proof.

  intros; simpl. rewrite H0.

  erewrite co_consistent_rank by eauto.

  exploit (rank_type_members ce); eauto.

  omega.

Qed.



Lemma rank_union_member:

  forall ce id a co id1 t1,

  composite_env_consistent ce ->

  ce!id = Some co ->

  In (id1, t1) (co_members co) ->

  (rank_type ce t1 < rank_type ce (Tunion id a))%nat.

Proof.

  intros; simpl. rewrite H0.

  erewrite co_consistent_rank by eauto.

  exploit (rank_type_members ce); eauto.

  omega.

Qed.



Set Implicit Arguments.



Section PROGRAMS.



Variable F: Type.



Inductive fundef : Type :=

  | Internal: F -> fundef

  | External: external_function -> typelist -> type -> calling_convention -> fundef.



Record program : Type := {

  prog_defs: list (ident * globdef fundef type);

  prog_public: list ident;

  prog_main: ident;

  prog_types: list composite_definition;

  prog_comp_env: composite_env;

  prog_comp_env_eq: build_composite_env prog_types = OK prog_comp_env

}.



Definition program_of_program (p: program) : AST.program fundef type :=

  {| AST.prog_defs := p.(prog_defs);

     AST.prog_public := p.(prog_public);

     AST.prog_main := p.(prog_main) |}.



Coercion program_of_program: program >-> AST.program.



Program Definition make_program (types: list composite_definition)

                                (defs: list (ident * globdef fundef type))

                                (public: list ident)

                                (main: ident) : res program :=

  match build_composite_env types with

  | Error e => Error e

  | OK ce =>

      OK {| prog_defs := defs;

            prog_public := public;

            prog_main := main;

            prog_types := types;

            prog_comp_env := ce;

            prog_comp_env_eq := _ |}

  end.



End PROGRAMS.



Arguments External {F} _ _ _ _.



Unset Implicit Arguments.



Program Instance Linker_types : Linker type := {

  link := fun t1 t2 => if type_eq t1 t2 then Some t1 else None;

  linkorder := fun t1 t2 => t1 = t2

}.

Next Obligation.

  destruct (type_eq x y); inv H. auto.

Defined.



Global Opaque Linker_types.



Definition check_compat_composite (l: list composite_definition) (cd: composite_definition) : bool :=

  List.forallb

    (fun cd' =>

      if ident_eq (name_composite_def cd') (name_composite_def cd) then composite_def_eq cd cd' else true)

    l.



Definition filter_redefs (l1 l2: list composite_definition) :=

  let names1 := map name_composite_def l1 in

  List.filter (fun cd => negb (In_dec ident_eq (name_composite_def cd) names1)) l2.



Definition link_composite_defs (l1 l2: list composite_definition): option (list composite_definition) :=

  if List.forallb (check_compat_composite l2) l1

  then Some (l1 ++ filter_redefs l1 l2)

  else None.



Lemma link_composite_def_inv:

  forall l1 l2 l,

  link_composite_defs l1 l2 = Some l ->

     (forall cd1 cd2, In cd1 l1 -> In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1)

  /\ l = l1 ++ filter_redefs l1 l2

  /\ (forall x, In x l <-> In x l1 \/ In x l2).

Proof.

  unfold link_composite_defs; intros.

  destruct (forallb (check_compat_composite l2) l1) eqn:C; inv H.

  assert (A: 

    forall cd1 cd2, In cd1 l1 -> In cd2 l2 -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1).

  { rewrite forallb_forall in C. intros.

    apply C in H. unfold check_compat_composite in H. rewrite forallb_forall in H. 

    apply H in H0. rewrite H1, dec_eq_true in H0. symmetry; eapply proj_sumbool_true; eauto. }

  split. auto. split. auto. 

  unfold filter_redefs; intros. 

  rewrite in_app_iff. rewrite filter_In. intuition auto. 

  destruct (in_dec ident_eq (name_composite_def x) (map name_composite_def l1)); simpl; auto.

  exploit list_in_map_inv; eauto. intros (y & P & Q).

  assert (x = y) by eauto. subst y. auto.

Qed.



Program Instance Linker_composite_defs : Linker (list composite_definition) := {

  link := link_composite_defs;

  linkorder := @List.incl composite_definition

}.

Next Obligation.

  apply incl_refl.

Defined.

Next Obligation.

  red; intros; eauto.

Defined.

Next Obligation.

  apply link_composite_def_inv in H; destruct H as (A & B & C).

  split; red; intros; apply C; auto.

Defined.



Lemma add_composite_definitions_append:

  forall l1 l2 env env'',

  add_composite_definitions env (l1 ++ l2) = OK env'' <->

  exists env', add_composite_definitions env l1 = OK env' /\ add_composite_definitions env' l2 = OK env''.

Proof.

  induction l1; simpl; intros.

- split; intros. exists env; auto. destruct H as (env' & A & B). congruence.

- destruct a; simpl. destruct (composite_of_def env id su m a); simpl.

  apply IHl1. 

  split; intros. discriminate. destruct H as (env' & A & B); discriminate.

Qed.



Lemma composite_eq:

  forall su1 m1 a1 sz1 al1 r1 pos1 al2p1 szal1

         su2 m2 a2 sz2 al2 r2 pos2 al2p2 szal2,

  su1 = su2 -> m1 = m2 -> a1 = a2 -> sz1 = sz2 -> al1 = al2 -> r1 = r2 ->

  Build_composite su1 m1 a1 sz1 al1 r1 pos1 al2p1 szal1 = Build_composite su2 m2 a2 sz2 al2 r2 pos2 al2p2 szal2.

Proof.

  intros. subst.

  assert (pos1 = pos2) by apply proof_irr. 

  assert (al2p1 = al2p2) by apply proof_irr.

  assert (szal1 = szal2) by apply proof_irr.

  subst. reflexivity.

Qed.



Lemma composite_of_def_eq:

  forall env id co,

  composite_consistent env co ->

  env!id = None ->

  composite_of_def env id (co_su co) (co_members co) (co_attr co) = OK co.

Proof.

  intros. destruct H as [A B C D]. unfold composite_of_def. rewrite H0, A.

  destruct co; simpl in *. f_equal. apply composite_eq; auto. rewrite C, B; auto. 

Qed.



Lemma composite_consistent_unique:

  forall env co1 co2,

  composite_consistent env co1 ->

  composite_consistent env co2 ->

  co_su co1 = co_su co2 ->

  co_members co1 = co_members co2 ->

  co_attr co1 = co_attr co2 ->

  co1 = co2.

Proof.

  intros. destruct H, H0. destruct co1, co2; simpl in *. apply composite_eq; congruence.

Qed.



Lemma composite_of_def_stable:

  forall (env env': composite_env)

         (EXTENDS: forall id co, env!id = Some co -> env'!id = Some co)

         id su m a co,

  env'!id = None ->

  composite_of_def env id su m a = OK co ->

  composite_of_def env' id su m a = OK co.

Proof.

  intros. 

  unfold composite_of_def in H0. 

  destruct (env!id) eqn:E; try discriminate.

  destruct (complete_members env m) eqn:CM; try discriminate.

  transitivity (composite_of_def env' id (co_su co) (co_members co) (co_attr co)).

  inv H0; auto. 

  apply composite_of_def_eq; auto. 

  apply composite_consistent_stable with env; auto. 

  inv H0; constructor; auto.

Qed.



Lemma link_add_composite_definitions:

  forall l0 env0,

  build_composite_env l0 = OK env0 ->

  forall l env1 env1' env2,

  add_composite_definitions env1 l = OK env1' ->

  (forall id co, env1!id = Some co -> env2!id = Some co) ->

  (forall id co, env0!id = Some co -> env2!id = Some co) ->

  (forall id, env2!id = if In_dec ident_eq id (map name_composite_def l0) then env0!id else env1!id) ->

  ((forall cd1 cd2, In cd1 l0 -> In cd2 l -> name_composite_def cd2 = name_composite_def cd1 -> cd2 = cd1)) ->

  { env2' |

      add_composite_definitions env2 (filter_redefs l0 l) = OK env2'

  /\ (forall id co, env1'!id = Some co -> env2'!id = Some co)

  /\ (forall id co, env0!id = Some co -> env2'!id = Some co) }.

Proof.

  induction l; simpl; intros until env2; intros ACD AGREE1 AGREE0 AGREE2 UNIQUE.

- inv ACD. exists env2; auto.

- destruct a. destruct (composite_of_def env1 id su m a) as [x|e] eqn:EQ; try discriminate.

  simpl in ACD.

  generalize EQ. unfold composite_of_def at 1. 

  destruct (env1!id) eqn:E1; try congruence.

  destruct (complete_members env1 m) eqn:CM1; try congruence. 

  intros EQ1.

  simpl. destruct (in_dec ident_eq id (map name_composite_def l0)); simpl.

+ eapply IHl; eauto.

* intros. rewrite PTree.gsspec in H0. destruct (peq id0 id); auto.

  inv H0.

  exploit list_in_map_inv; eauto. intros ([id' su' m' a'] & P & Q).

  assert (X: Composite id su m a = Composite id' su' m' a').

  { eapply UNIQUE. auto. auto. rewrite <- P; auto. }

  inv X.

  exploit build_composite_env_charact; eauto. intros (co' & U & V & W & X). 

  assert (co' = co).

  { apply composite_consistent_unique with env2.

    apply composite_consistent_stable with env0; auto. 

    eapply build_composite_env_consistent; eauto.

    apply composite_consistent_stable with env1; auto.

    inversion EQ1; constructor; auto. 

    inversion EQ1; auto.

    inversion EQ1; auto.

    inversion EQ1; auto. }

  subst co'. apply AGREE0; auto. 

* intros. rewrite AGREE2. destruct (in_dec ident_eq id0 (map name_composite_def l0)); auto. 

  rewrite PTree.gsspec. destruct (peq id0 id); auto. subst id0. contradiction.

+ assert (E2: env2!id = None).

  { rewrite AGREE2. rewrite pred_dec_false by auto. auto. }

  assert (E3: composite_of_def env2 id su m a = OK x).

  { eapply composite_of_def_stable. eexact AGREE1. eauto. eauto. }

  rewrite E3. simpl. eapply IHl; eauto. 

* intros until co; rewrite ! PTree.gsspec. destruct (peq id0 id); auto.

* intros until co; rewrite ! PTree.gsspec. intros. destruct (peq id0 id); auto.

  subst id0. apply AGREE0 in H0. congruence.

* intros. rewrite ! PTree.gsspec. destruct (peq id0 id); auto. subst id0. 

  rewrite pred_dec_false by auto. auto.

Qed.



Theorem link_build_composite_env:

  forall l1 l2 l env1 env2,

  build_composite_env l1 = OK env1 ->

  build_composite_env l2 = OK env2 ->

  link l1 l2 = Some l ->

  { env |

     build_composite_env l = OK env

  /\ (forall id co, env1!id = Some co -> env!id = Some co)

  /\ (forall id co, env2!id = Some co -> env!id = Some co) }.

Proof.

  intros. edestruct link_composite_def_inv as (A & B & C); eauto.

  edestruct link_add_composite_definitions as (env & P & Q & R).

  eexact H.

  eexact H0.

  instantiate (1 := env1). intros. rewrite PTree.gempty in H2; discriminate.

  auto.

  intros. destruct (in_dec ident_eq id (map name_composite_def l1)); auto.

  rewrite PTree.gempty. destruct (env1!id) eqn:E1; auto. 

  exploit build_composite_env_domain. eexact H. eauto.

  intros. apply (in_map name_composite_def) in H2. elim n; auto. 

  auto.

  exists env; split; auto. subst l. apply add_composite_definitions_append. exists env1; auto. 

Qed.



Definition link_fundef {F: Type} (fd1 fd2: fundef F) :=

  match fd1, fd2 with

  | Internal _, Internal _ => None

  | External ef1 targs1 tres1 cc1, External ef2 targs2 tres2 cc2 =>

      if external_function_eq ef1 ef2

      && typelist_eq targs1 targs2

      && type_eq tres1 tres2

      && calling_convention_eq cc1 cc2

      then Some (External ef1 targs1 tres1 cc1)

      else None

  | Internal f, External ef targs tres cc =>

      match ef with EF_external id sg => Some (Internal f) | _ => None end

  | External ef targs tres cc, Internal f =>

      match ef with EF_external id sg => Some (Internal f) | _ => None end

  end.



Inductive linkorder_fundef {F: Type}: fundef F -> fundef F -> Prop :=

  | linkorder_fundef_refl: forall fd,

      linkorder_fundef fd fd

  | linkorder_fundef_ext_int: forall f id sg targs tres cc,

      linkorder_fundef (External (EF_external id sg) targs tres cc) (Internal f).



Program Instance Linker_fundef (F: Type): Linker (fundef F) := {

  link := link_fundef;

  linkorder := linkorder_fundef

}.

Next Obligation.

  constructor.

Defined.

Next Obligation.

  inv H; inv H0; constructor.

Defined.

Next Obligation.

  destruct x, y; simpl in H.

+ discriminate.

+ destruct e; inv H. split; constructor.

+ destruct e; inv H. split; constructor.

+ destruct (external_function_eq e e0 && typelist_eq t t1 && type_eq t0 t2 && calling_convention_eq c c0) eqn:A; inv H.

  InvBooleans. subst. split; constructor.

Defined.



Remark link_fundef_either:

  forall (F: Type) (f1 f2 f: fundef F), link f1 f2 = Some f -> f = f1 \/ f = f2.

Proof.

  simpl; intros. unfold link_fundef in H. destruct f1, f2; try discriminate.

- destruct e; inv H. auto.

- destruct e; inv H. auto.

- destruct (external_function_eq e e0 && typelist_eq t t1 && type_eq t0 t2 && calling_convention_eq c c0); inv H; auto.

Qed.



Global Opaque Linker_fundef.



Definition lift_option {A: Type} (opt: option A) : { x | opt = Some x } + { opt = None }.

Proof.

  destruct opt. left; exists a; auto. right; auto. 

Defined.



Definition link_program {F:Type} (p1 p2: program F): option (program F) :=

  match link (program_of_program p1) (program_of_program p2) with

  | None => None

  | Some p =>

      match lift_option (link p1.(prog_types) p2.(prog_types)) with

      | inright _ => None

      | inleft (exist typs EQ) =>

          match link_build_composite_env

                   p1.(prog_types) p2.(prog_types) typs

                   p1.(prog_comp_env) p2.(prog_comp_env)

                   p1.(prog_comp_env_eq) p2.(prog_comp_env_eq) EQ with

          | exist env (conj P Q) =>

              Some {| prog_defs := p.(AST.prog_defs);

                      prog_public := p.(AST.prog_public);

                      prog_main := p.(AST.prog_main);

                      prog_types := typs;

                      prog_comp_env := env;

                      prog_comp_env_eq := P |}

          end

      end

  end.



Definition linkorder_program {F: Type} (p1 p2: program F) : Prop :=

     linkorder (program_of_program p1) (program_of_program p2)

  /\ (forall id co, p1.(prog_comp_env)!id = Some co -> p2.(prog_comp_env)!id = Some co).



Program Instance Linker_program (F: Type): Linker (program F) := {

  link := link_program;

  linkorder := linkorder_program

}.

Next Obligation.

  split. apply linkorder_refl. auto.

Defined.

Next Obligation.

  destruct H, H0. split. eapply linkorder_trans; eauto.

  intros; auto.

Defined.

Next Obligation.

  revert H. unfold link_program.

  destruct (link (program_of_program x) (program_of_program y)) as [p|] eqn:LP; try discriminate.

  destruct (lift_option (link (prog_types x) (prog_types y))) as [[typs EQ]|EQ]; try discriminate.

  destruct (link_build_composite_env (prog_types x) (prog_types y) typs

       (prog_comp_env x) (prog_comp_env y) (prog_comp_env_eq x)

       (prog_comp_env_eq y) EQ) as (env & P & Q & R).

  destruct (link_linkorder _ _ _ LP). 

  intros X; inv X.

  split; split; auto.

Defined.



Global Opaque Linker_program.



Section LINK_MATCH_PROGRAM.



Context {F G: Type}.

Variable match_fundef: fundef F -> fundef G -> Prop.



Hypothesis link_match_fundef:

  forall f1 tf1 f2 tf2 f,

  link f1 f2 = Some f ->

  match_fundef f1 tf1 -> match_fundef f2 tf2 ->

  exists tf, link tf1 tf2 = Some tf /\ match_fundef f tf.



Let match_program (p: program F) (tp: program G) : Prop :=

    Linking.match_program (fun ctx f tf => match_fundef f tf) eq p tp

 /\ prog_types tp = prog_types p.



Theorem link_match_program:

  forall p1 p2 tp1 tp2 p,

  link p1 p2 = Some p -> match_program p1 tp1 -> match_program p2 tp2 ->

  exists tp, link tp1 tp2 = Some tp /\ match_program p tp.

Proof.

  intros. destruct H0, H1. 

Local Transparent Linker_program.

  simpl in H; unfold link_program in H.

  destruct (link (program_of_program p1) (program_of_program p2)) as [pp|] eqn:LP; try discriminate.

  assert (A: exists tpp,

               link (program_of_program tp1) (program_of_program tp2) = Some tpp

             /\ Linking.match_program (fun ctx f tf => match_fundef f tf) eq pp tpp).

  { eapply Linking.link_match_program. 

  - intros. exploit link_match_fundef; eauto. intros (tf & A & B). exists tf; auto.

  - intros.

    Local Transparent Linker_types.

    simpl in *. destruct (type_eq v1 v2); inv H4. exists v; rewrite dec_eq_true; auto.

  - eauto.

  - eauto.

  - eauto.

  - apply (link_linkorder _ _ _ LP).

  - apply (link_linkorder _ _ _ LP). }

  destruct A as (tpp & TLP & MP).

  simpl; unfold link_program. rewrite TLP.

  destruct (lift_option (link (prog_types p1) (prog_types p2))) as [[typs EQ]|EQ]; try discriminate.

  destruct (link_build_composite_env (prog_types p1) (prog_types p2) typs

           (prog_comp_env p1) (prog_comp_env p2) (prog_comp_env_eq p1)

           (prog_comp_env_eq p2) EQ) as (env & P & Q). 

  rewrite <- H2, <- H3 in EQ.

  destruct (lift_option (link (prog_types tp1) (prog_types tp2))) as [[ttyps EQ']|EQ']; try congruence.

  assert (ttyps = typs) by congruence. subst ttyps. 

  destruct (link_build_composite_env (prog_types tp1) (prog_types tp2) typs

         (prog_comp_env tp1) (prog_comp_env tp2) (prog_comp_env_eq tp1)

         (prog_comp_env_eq tp2) EQ') as (tenv & R & S).

  assert (tenv = env) by congruence. subst tenv.

  econstructor; split; eauto. inv H. split; auto.

  unfold program_of_program; simpl. destruct pp, tpp; exact MP.

Qed.



End LINK_MATCH_PROGRAM.

