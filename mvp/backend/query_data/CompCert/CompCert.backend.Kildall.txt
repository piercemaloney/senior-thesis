

Require Import Coqlib.
(* Coqlib:
Require Export String.
Require Export ZArith.
Require Export Znumtheory.
Require Export List.
Require Export Bool.

Global Set Asymmetric Patterns.

Ltac inv H := inversion H; clear H; subst.

Ltac predSpec pred predspec x y :=
  generalize (predspec x y); case (pred x y); intro.

Ltac caseEq name :=
  generalize (eq_refl name); pattern name at -1 in |- *; case name.

Ltac destructEq name :=
  destruct name eqn:?.

Ltac decEq :=
  match goal with
  | [ |- _ = _ ] => f_equal
  | [ |- (?X ?A <> ?X ?B) ] =>
      cut (A <> B); [intro; congruence | try discriminate]
  end.

Ltac byContradiction :=
  cut False; [contradiction|idtac].

Ltac omegaContradiction :=
  cut False; [contradiction|omega].

Lemma modusponens: forall (P Q: Prop), P -> (P -> Q) -> Q.

Ltac exploit x :=
    refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _ _) _)
 || refine (modusponens _ _ (x _ _ _) _)
 || refine (modusponens _ _ (x _ _) _)
 || refine (modusponens _ _ (x _) _).

Definition peq: forall (x y: positive), {x = y} + {x <> y} := Pos.eq_dec.
Global Opaque peq.

Lemma peq_true:
  forall (A: Type) (x: positive) (a b: A), (if peq x x then a else b) = a.

Lemma peq_false:
  forall (A: Type) (x y: positive) (a b: A), x <> y -> (if peq x y then a else b) = b.

Definition Plt: positive -> positive -> Prop := Pos.lt.

Lemma Plt_ne:
  forall (x y: positive), Plt x y -> x <> y.
Hint Resolve Plt_ne: coqlib.

Lemma Plt_trans:
  forall (x y z: positive), Plt x y -> Plt y z -> Plt x z.
Proof (Pos.lt_trans).

Lemma Plt_succ:
  forall (x: positive), Plt x (Pos.succ x).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_trans_succ:
  forall (x y: positive), Plt x y -> Plt x (Pos.succ y).
Hint Resolve Plt_succ: coqlib.

Lemma Plt_succ_inv:
  forall (x y: positive), Plt x (Pos.succ y) -> Plt x y \/ x = y.

Definition plt (x y: positive) : {Plt x y} + {~ Plt x y}.
Global Opaque plt.

Definition Ple: positive -> positive -> Prop := Pos.le.

Lemma Ple_refl: forall (p: positive), Ple p p.
Proof (Pos.le_refl).

Lemma Ple_trans: forall (p q r: positive), Ple p q -> Ple q r -> Ple p r.
Proof (Pos.le_trans).

Lemma Plt_Ple: forall (p q: positive), Plt p q -> Ple p q.
Proof (Pos.lt_le_incl).

Lemma Ple_succ: forall (p: positive), Ple p (Pos.succ p).

Lemma Plt_Ple_trans:
  forall (p q r: positive), Plt p q -> Ple q r -> Plt p r.
Proof (Pos.lt_le_trans).

Lemma Plt_strict: forall p, ~ Plt p p.
Proof (Pos.lt_irrefl).

Hint Resolve Ple_refl Plt_Ple Ple_succ Plt_strict: coqlib.

Ltac xomega := unfold Plt, Ple in *; zify; omega.
Ltac xomegaContradiction := exfalso; xomega.

Section POSITIVE_ITERATION.

Lemma Plt_wf: well_founded Plt.

Variable A: Type.
Variable v1: A.
Variable f: positive -> A -> A.

Lemma Ppred_Plt:
  forall x, x <> xH -> Plt (Pos.pred x) x.

Let iter (x: positive) (P: forall y, Plt y x -> A) : A :=
  match peq x xH with
  | left EQ => v1
  | right NOTEQ => f (Pos.pred x) (P (Pos.pred x) (Ppred_Plt x NOTEQ))
  end.

Definition positive_rec : positive -> A :=
  Fix Plt_wf (fun _ => A) iter.

Lemma unroll_positive_rec:
  forall x,
  positive_rec x = iter x (fun y _ => positive_rec y).

Lemma positive_rec_base:
  positive_rec 1%positive = v1.

Lemma positive_rec_succ:
  forall x, positive_rec (Pos.succ x) = f x (positive_rec x).

Lemma positive_Peano_ind:
  forall (P: positive -> Prop),
  P xH ->
  (forall x, P x -> P (Pos.succ x)) ->

End POSITIVE_ITERATION.

Definition zeq: forall (x y: Z), {x = y} + {x <> y} := Z.eq_dec.

Lemma zeq_true:
  forall (A: Type) (x: Z) (a b: A), (if zeq x x then a else b) = a.

Lemma zeq_false:
  forall (A: Type) (x y: Z) (a b: A), x <> y -> (if zeq x y then a else b) = b.

Open Scope Z_scope.

Definition zlt: forall (x y: Z), {x < y} + {x >= y} := Z_lt_dec.

Lemma zlt_true:
  forall (A: Type) (x y: Z) (a b: A),
  x < y -> (if zlt x y then a else b) = a.

Lemma zlt_false:
  forall (A: Type) (x y: Z) (a b: A),
  x >= y -> (if zlt x y then a else b) = b.

Definition zle: forall (x y: Z), {x <= y} + {x > y} := Z_le_gt_dec.

Lemma zle_true:
  forall (A: Type) (x y: Z) (a b: A),
  x <= y -> (if zle x y then a else b) = a.

Lemma zle_false:
  forall (A: Type) (x y: Z) (a b: A),
  x > y -> (if zle x y then a else b) = b.

Lemma two_power_nat_O : two_power_nat O = 1.

Lemma two_power_nat_pos : forall n : nat, two_power_nat n > 0.

Lemma two_power_nat_two_p:
  forall x, two_power_nat x = two_p (Z.of_nat x).

Lemma two_p_monotone:
  forall x y, 0 <= x <= y -> two_p x <= two_p y.

Lemma two_p_monotone_strict:
  forall x y, 0 <= x < y -> two_p x < two_p y.

Lemma two_p_strict:
  forall x, x >= 0 -> x < two_p x.

Lemma two_p_strict_2:
  forall x, x >= 0 -> 2 * x - 1 < two_p x.

Lemma Zmin_spec:
  forall x y, Z.min x y = if zlt x y then x else y.

Lemma Zmax_spec:
  forall x y, Z.max x y = if zlt y x then x else y.

Lemma Zmax_bound_l:
  forall x y z, x <= y -> x <= Z.max y z.
Lemma Zmax_bound_r:
  forall x y z, x <= z -> x <= Z.max y z.

Lemma Zdiv_small:
  forall x y, 0 <= x < y -> x / y = 0.

Lemma Zmod_small:
  forall x y, 0 <= x < y -> x mod y = x.

Lemma Zmod_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x mod y = b.

Lemma Zdiv_unique:
  forall x y a b,
  x = a * y + b -> 0 <= b < y -> x / y = a.

Lemma Zdiv_Zdiv:
  forall a b c,
  b > 0 -> c > 0 -> (a / b) / c = a / (b * c).

Lemma Zmult_le_compat_l_neg :
  forall n m p:Z, n >= m -> p <= 0 -> p * n <= p * m.

Lemma Zdiv_interval_1:
  forall lo hi a b,
  lo <= 0 -> hi > 0 -> b > 0 ->
  lo * b <= a < hi * b ->
  lo <= a/b < hi.

Lemma Zdiv_interval_2:
  forall lo hi a b,
  lo <= a <= hi -> lo <= 0 -> hi >= 0 -> b > 0 ->
  lo <= a/b <= hi.

Lemma Zmod_recombine:
  forall x a b,
  a > 0 -> b > 0 ->
  x mod (a * b) = ((x/b) mod a) * b + (x mod b).

Lemma Zdivides_trans:
  forall x y z, (x | y) -> (y | z) -> (x | z).

Definition Zdivide_dec:
  forall (p q: Z), p > 0 -> { (p|q) } + { ~(p|q) }.
Global Opaque Zdivide_dec.

Lemma Zdivide_interval:
  forall a b c,
  0 < c -> 0 <= a < b -> (c | a) -> (c | b) -> 0 <= a <= b - c.

Definition nat_of_Z: Z -> nat := Z.to_nat.

Lemma nat_of_Z_of_nat:
  forall n, nat_of_Z (Z.of_nat n) = n.

Lemma nat_of_Z_max:
  forall z, Z.of_nat (nat_of_Z z) = Z.max z 0.

Lemma nat_of_Z_eq:
  forall z, z >= 0 -> Z.of_nat (nat_of_Z z) = z.

Lemma nat_of_Z_neg:
  forall n, n <= 0 -> nat_of_Z n = O.

Lemma nat_of_Z_plus:
  forall p q,
  p >= 0 -> q >= 0 ->
  nat_of_Z (p + q) = (nat_of_Z p + nat_of_Z q)%nat.

Definition align (n: Z) (amount: Z) :=
  ((n + amount - 1) / amount) * amount.

Lemma align_le: forall x y, y > 0 -> x <= align x y.

Lemma align_divides: forall x y, y > 0 -> (y | align x y).

Set Implicit Arguments.

Definition option_eq (A: Type) (eqA: forall (x y: A), {x=y} + {x<>y}):
  forall (x y: option A), {x=y} + {x<>y}.
Global Opaque option_eq.

Inductive option_rel (A B: Type) (R: A -> B -> Prop) : option A -> option B -> Prop :=
  | option_rel_none: option_rel R None None
  | option_rel_some: forall x y, R x y -> option_rel R (Some x) (Some y).

Definition option_map (A B: Type) (f: A -> B) (x: option A) : option B :=
  match x with
  | None => None
  | Some y => Some (f y)
  end.

Definition sum_left_map (A B C: Type) (f: A -> B) (x: A + C) : B + C :=
  match x with
  | inl y => inl C (f y)
  | inr z => inr B z
  end.

Hint Resolve in_eq in_cons: coqlib.

Lemma nth_error_in:
  forall (A: Type) (n: nat) (l: list A) (x: A),
  List.nth_error l n = Some x -> In x l.
Hint Resolve nth_error_in: coqlib.

Lemma nth_error_nil:
  forall (A: Type) (idx: nat), nth_error (@nil A) idx = None.
Hint Resolve nth_error_nil: coqlib.

Fixpoint list_length_z_aux (A: Type) (l: list A) (acc: Z) {struct l}: Z :=
  match l with
  | nil => acc
  | hd :: tl => list_length_z_aux tl (Z.succ acc)
  end.

Remark list_length_z_aux_shift:
  forall (A: Type) (l: list A) n m,
  list_length_z_aux l n = list_length_z_aux l m + (n - m).

Definition list_length_z (A: Type) (l: list A) : Z :=
  list_length_z_aux l 0.

Lemma list_length_z_cons:
  forall (A: Type) (hd: A) (tl: list A),
  list_length_z (hd :: tl) = list_length_z tl + 1.

Lemma list_length_z_pos:
  forall (A: Type) (l: list A),
  list_length_z l >= 0.

Lemma list_length_z_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_length_z (map f l) = list_length_z l.

Fixpoint list_nth_z (A: Type) (l: list A) (n: Z) {struct l}: option A :=
  match l with
  | nil => None
  | hd :: tl => if zeq n 0 then Some hd else list_nth_z tl (Z.pred n)
  end.

Lemma list_nth_z_in:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> In x l.

Lemma list_nth_z_map:
  forall (A B: Type) (f: A -> B) (l: list A) n,
  list_nth_z (List.map f l) n = option_map f (list_nth_z l n).

Lemma list_nth_z_range:
  forall (A: Type) (l: list A) n x,
  list_nth_z l n = Some x -> 0 <= n < list_length_z l.

Lemma incl_cons_inv:
  forall (A: Type) (a: A) (b c: list A),
  incl (a :: b) c -> incl b c.
Hint Resolve incl_cons_inv: coqlib.

Lemma incl_app_inv_l:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l1 m.

Lemma incl_app_inv_r:
  forall (A: Type) (l1 l2 m: list A),
  incl (l1 ++ l2) m -> incl l2 m.

Hint Resolve  incl_tl incl_refl incl_app_inv_l incl_app_inv_r: coqlib.

Lemma incl_same_head:
  forall (A: Type) (x: A) (l1 l2: list A),
  incl l1 l2 -> incl (x::l1) (x::l2).

Lemma list_map_exten:
  forall (A B: Type) (f f': A -> B) (l: list A),
  (forall x, In x l -> f x = f' x) ->
  List.map f' l = List.map f l.

Lemma list_map_compose:
  forall (A B C: Type) (f: A -> B) (g: B -> C) (l: list A),
  List.map g (List.map f l) = List.map (fun x => g(f x)) l.

Lemma list_map_identity:
  forall (A: Type) (l: list A),
  List.map (fun (x:A) => x) l = l.

Lemma list_map_nth:
  forall (A B: Type) (f: A -> B) (l: list A) (n: nat),
  nth_error (List.map f l) n = option_map f (nth_error l n).

Lemma list_length_map:
  forall (A B: Type) (f: A -> B) (l: list A),
  List.length (List.map f l) = List.length l.

Lemma list_in_map_inv:
  forall (A B: Type) (f: A -> B) (l: list A) (y: B),
  In y (List.map f l) -> exists x:A, y = f x /\ In x l.

Lemma list_append_map:
  forall (A B: Type) (f: A -> B) (l1 l2: list A),
  List.map f (l1 ++ l2) = List.map f l1 ++ List.map f l2.

Lemma list_append_map_inv:
  forall (A B: Type) (f: A -> B) (m1 m2: list B) (l: list A),
  List.map f l = m1 ++ m2 ->

Section LIST_FOLD.

Variables A B: Type.
Variable f: A -> B -> B.

Fixpoint list_fold_left (accu: B) (l: list A) : B :=
  match l with nil => accu | x :: l' => list_fold_left (f x accu) l' end.

Definition list_fold_right (l: list A) (base: B) : B :=
  list_fold_left base (List.rev' l).

Remark list_fold_left_app:
  forall l1 l2 accu,
  list_fold_left accu (l1 ++ l2) = list_fold_left (list_fold_left accu l1) l2.

Lemma list_fold_right_eq:
  forall l base,
  list_fold_right l base =
  match l with nil => base | x :: l' => f x (list_fold_right l' base) end.

Lemma list_fold_right_spec:
  forall l base, list_fold_right l base = List.fold_right f base l.

End LIST_FOLD.

Lemma in_cns:
  forall (A: Type) (x y: A) (l: list A), In x (y :: l) <-> y = x \/ In x l.

Lemma in_app:
  forall (A: Type) (x: A) (l1 l2: list A), In x (l1 ++ l2) <-> In x l1 \/ In x l2.

Lemma list_in_insert:
  forall (A: Type) (x: A) (l1 l2: list A) (y: A),
  In x (l1 ++ l2) -> In x (l1 ++ y :: l2).

Definition list_disjoint (A: Type) (l1 l2: list A) : Prop :=
  forall (x y: A), In x l1 -> In y l2 -> x <> y.

Lemma list_disjoint_cons_l:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l2 -> list_disjoint (a :: l1) l2.

Lemma list_disjoint_cons_r:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 l2 -> ~In a l1 -> list_disjoint l1 (a :: l2).

Lemma list_disjoint_cons_left:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint (a :: l1) l2 -> list_disjoint l1 l2.

Lemma list_disjoint_cons_right:
  forall (A: Type) (a: A) (l1 l2: list A),
  list_disjoint l1 (a :: l2) -> list_disjoint l1 l2.

Lemma list_disjoint_notin:
  forall (A: Type) (l1 l2: list A) (a: A),
  list_disjoint l1 l2 -> In a l1 -> ~(In a l2).

Lemma list_disjoint_sym:
  forall (A: Type) (l1 l2: list A),
  list_disjoint l1 l2 -> list_disjoint l2 l1.

Lemma list_disjoint_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l1 l2: list A),
  {list_disjoint l1 l2} + {~list_disjoint l1 l2}.

Definition list_equiv (A : Type) (l1 l2: list A) : Prop :=
  forall x, In x l1 <-> In x l2.

Inductive list_norepet (A: Type) : list A -> Prop :=
  | list_norepet_nil:
      list_norepet nil
  | list_norepet_cons:
      forall hd tl,
      ~(In hd tl) -> list_norepet tl -> list_norepet (hd :: tl).

Lemma list_norepet_dec:
  forall (A: Type) (eqA_dec: forall (x y: A), {x=y} + {x<>y}) (l: list A),
  {list_norepet l} + {~list_norepet l}.

Lemma list_map_norepet:
  forall (A B: Type) (f: A -> B) (l: list A),
  list_norepet l ->
  (forall x y, In x l -> In y l -> x <> y -> f x <> f y) ->
  list_norepet (List.map f l).

Remark list_norepet_append_commut:
  forall (A: Type) (a b: list A),
  list_norepet (a ++ b) -> list_norepet (b ++ a).

Lemma list_norepet_app:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) <->
  list_norepet l1 /\ list_norepet l2 /\ list_disjoint l1 l2.

Lemma list_norepet_append:
  forall (A: Type) (l1 l2: list A),
  list_norepet l1 -> list_norepet l2 -> list_disjoint l1 l2 ->
  list_norepet (l1 ++ l2).

Lemma list_norepet_append_right:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l2.

Lemma list_norepet_append_left:
  forall (A: Type) (l1 l2: list A),
  list_norepet (l1 ++ l2) -> list_norepet l1.

Inductive is_tail (A: Type): list A -> list A -> Prop :=
  | is_tail_refl:
      forall c, is_tail c c
  | is_tail_cons:
      forall i c1 c2, is_tail c1 c2 -> is_tail c1 (i :: c2).

Lemma is_tail_in:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> In i c2.

Lemma is_tail_cons_left:
  forall (A: Type) (i: A) c1 c2, is_tail (i :: c1) c2 -> is_tail c1 c2.

Hint Resolve is_tail_refl is_tail_cons is_tail_in is_tail_cons_left: coqlib.

Lemma is_tail_incl:
  forall (A: Type) (l1 l2: list A), is_tail l1 l2 -> incl l1 l2.

Lemma is_tail_trans:
  forall (A: Type) (l1 l2: list A),
  is_tail l1 l2 -> forall (l3: list A), is_tail l2 l3 -> is_tail l1 l3.

Section FORALL2.

Variable A: Type.
Variable B: Type.
Variable P: A -> B -> Prop.

Inductive list_forall2: list A -> list B -> Prop :=
  | list_forall2_nil:
      list_forall2 nil nil
  | list_forall2_cons:
      forall a1 al b1 bl,
      P a1 b1 ->
      list_forall2 al bl ->
      list_forall2 (a1 :: al) (b1 :: bl).

Lemma list_forall2_app:
  forall a2 b2 a1 b1,
  list_forall2 a1 b1 -> list_forall2 a2 b2 ->
  list_forall2 (a1 ++ a2) (b1 ++ b2).

Lemma list_forall2_length:
  forall l1 l2,
  list_forall2 l1 l2 -> length l1 = length l2.

Lemma list_forall2_in_left:
  forall x1 l1 l2,
  list_forall2 l1 l2 -> In x1 l1 -> exists x2, In x2 l2 /\ P x1 x2.

Lemma list_forall2_in_right:
  forall x2 l1 l2,
  list_forall2 l1 l2 -> In x2 l2 -> exists x1, In x1 l1 /\ P x1 x2.

End FORALL2.

Lemma list_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: list A) (l2: list B),
  list_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, In v1 l1 -> In v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  list_forall2 P2 l1 l2.

Fixpoint list_drop (A: Type) (n: nat) (x: list A) {struct n} : list A :=
  match n with
  | O => x
  | S n' => match x with nil => nil | hd :: tl => list_drop n' tl end
  end.

Lemma list_drop_incl:
  forall (A: Type) (x: A) n (l: list A), In x (list_drop n l) -> In x l.

Lemma list_drop_norepet:
  forall (A: Type) n (l: list A), list_norepet l -> list_norepet (list_drop n l).

Lemma list_map_drop:
  forall (A B: Type) (f: A -> B) n (l: list A),
  list_drop n (map f l) = map f (list_drop n l).

Fixpoint list_repeat {A: Type} (n: nat) (x: A) {struct n} :=
  match n with
  | O => nil
  | S m => x :: list_repeat m x
  end.

Lemma length_list_repeat:
  forall (A: Type) n (x: A), length (list_repeat n x) = n.

Lemma in_list_repeat:
  forall (A: Type) n (x: A) y, In y (list_repeat n x) -> y = x.

Definition proj_sumbool {P Q: Prop} (a: {P} + {Q}) : bool :=
  if a then true else false.

Coercion proj_sumbool: sumbool >-> bool.

Lemma proj_sumbool_true:
  forall (P Q: Prop) (a: {P}+{Q}), proj_sumbool a = true -> P.

Lemma proj_sumbool_is_true:
  forall (P: Prop) (a: {P}+{~P}), P -> proj_sumbool a = true.

Ltac InvBooleans :=
  match goal with
  | [ H: _ && _ = true |- _ ] =>
      destruct (andb_prop _ _ H); clear H; InvBooleans
  | [ H: _ || _ = false |- _ ] =>
      destruct (orb_false_elim _ _ H); clear H; InvBooleans
  | [ H: proj_sumbool ?x = true |- _ ] =>
      generalize (proj_sumbool_true _ H); clear H; intro; InvBooleans
  | _ => idtac
  end.

Section DECIDABLE_EQUALITY.

Variable A: Type.
Variable dec_eq: forall (x y: A), {x=y} + {x<>y}.
Variable B: Type.

Lemma dec_eq_true:
  forall (x: A) (ifso ifnot: B),
  (if dec_eq x x then ifso else ifnot) = ifso.

Lemma dec_eq_false:
  forall (x y: A) (ifso ifnot: B),
  x <> y -> (if dec_eq x y then ifso else ifnot) = ifnot.

Lemma dec_eq_sym:
  forall (x y: A) (ifso ifnot: B),
  (if dec_eq x y then ifso else ifnot) =
  (if dec_eq y x then ifso else ifnot).

End DECIDABLE_EQUALITY.

Section DECIDABLE_PREDICATE.

Variable P: Prop.
Variable dec: {P} + {~P}.
Variable A: Type.

Lemma pred_dec_true:
  forall (a b: A), P -> (if dec then a else b) = a.

Lemma pred_dec_false:
  forall (a b: A), ~P -> (if dec then a else b) = b.

End DECIDABLE_PREDICATE.

Require Import Relations.

Section LEX_ORDER.

Variable A: Type.
Variable B: Type.
Variable ordA: A -> A -> Prop.
Variable ordB: B -> B -> Prop.

Inductive lex_ord: A*B -> A*B -> Prop :=
  | lex_ord_left: forall a1 b1 a2 b2,
      ordA a1 a2 -> lex_ord (a1,b1) (a2,b2)
  | lex_ord_right: forall a b1 b2,
      ordB b1 b2 -> lex_ord (a,b1) (a,b2).

Lemma wf_lex_ord:
  well_founded ordA -> well_founded ordB -> well_founded lex_ord.

Lemma transitive_lex_ord:
  transitive _ ordA -> transitive _ ordB -> transitive _ lex_ord.

End LEX_ORDER.

Inductive nlist (A: Type) : Type :=
  | nbase: A -> nlist A
  | ncons: A -> nlist A -> nlist A.

Definition nfirst {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => a end.

Fixpoint nlast {A: Type} (l: nlist A) :=
  match l with nbase a => a | ncons a l' => nlast l' end.

Fixpoint nIn {A: Type} (x: A) (l: nlist A) : Prop :=
  match l with
  | nbase a => a = x
  | ncons a l => a = x \/ nIn x l
  end.

Inductive nlist_forall2 {A B: Type} (R: A -> B -> Prop) : nlist A -> nlist B -> Prop :=
  | nbase_forall2: forall a b, R a b -> nlist_forall2 R (nbase a) (nbase b)
  | ncons_forall2: forall a l b m, R a b -> nlist_forall2 R l m -> nlist_forall2 R (ncons a l) (ncons b m).

Lemma nlist_forall2_imply:
  forall (A B: Type) (P1: A -> B -> Prop) (l1: nlist A) (l2: nlist B),
  nlist_forall2 P1 l1 l2 ->
  forall (P2: A -> B -> Prop),
  (forall v1 v2, nIn v1 l1 -> nIn v2 l2 -> P1 v1 v2 -> P2 v1 v2) ->
  nlist_forall2 P2 l1 l2. *)

Require Import Iteration.
(* Iteration:
Require Import Axioms.
Require Import Coqlib.
Require Import Wfsimpl.

Module WfIter.

Section ITERATION.

Variables A B: Type.
Variable step: A -> B + A.
Variable ord: A -> A -> Prop.
Hypothesis ord_wf: well_founded ord.
Hypothesis step_decr: forall a a', step a = inr _ a' -> ord a' a.

Definition step_info (a: A) : {b | step a = inl _ b} + {a' | step a = inr _ a' & ord a' a}.

Definition iterate_F (a: A) (rec: forall a', ord a' a -> B) : B :=
  match step_info a with
  | inl (exist b P) => b
  | inr (exist2 a' P Q) => rec a' Q
  end.

Definition iterate (a: A) : B := Fix ord_wf iterate_F a.

Variable P: A -> Prop.
Variable Q: B -> Prop.

Hypothesis step_prop:
  forall a : A, P a ->
  match step a with inl b => Q b | inr a' => P a' end.

Lemma iterate_prop:
  forall a, P a -> Q (iterate a).

End ITERATION.

End WfIter.

Module PrimIter.

Section ITERATION.

Variables A B: Type.
Variable step: A -> B + A.

Definition num_iterations := 1000000000000%positive.

Definition iter_step (x: positive)
                     (next: forall y, Plt y x -> A -> option B)
                     (s: A) : option B :=
  match peq x xH with
  | left EQ => None
  | right NOTEQ =>
      match step s with
      | inl res => Some res
      | inr s'  => next (Pos.pred x) (Ppred_Plt x NOTEQ) s'
      end
  end.

Definition iter: positive -> A -> option B := Fix Plt_wf iter_step.

Definition iterate := iter num_iterations.

Variable P: A -> Prop.
Variable Q: B -> Prop.

Hypothesis step_prop:
  forall a : A, P a ->
  match step a with inl b => Q b | inr a' => P a' end.

Lemma iter_prop:
  forall n a b, P a -> iter n a = Some b -> Q b.

Lemma iterate_prop:
  forall a b, iterate a = Some b -> P a -> Q b.

End ITERATION.

End PrimIter.

Require Import Classical.
Require Import ClassicalDescription.
Require Import Max.

Module GenIter.

Section ITERATION.

Variables A B: Type.
Variable step: A -> B + A.

Definition B_le (x y: option B) : Prop := x = None \/ y = x.
Definition F_le (x y: A -> option B) : Prop := forall a, B_le (x a) (y a).

Definition F_iter (next: A -> option B) (a: A) : option B :=
  match step a with
  | inl b => Some b
  | inr a' => next a'
  end.

Lemma F_iter_monot:
 forall f g, F_le f g -> F_le (F_iter f) (F_iter g).

Fixpoint iter (n: nat) : A -> option B :=
  match n with
  | O => (fun a => None)
  | S m => F_iter (iter m)
  end.

Lemma iter_monot:
  forall p q, (p <= q)%nat -> F_le (iter p) (iter q).

Lemma iter_either:
  forall a,
  (exists n, exists b, iter n a = Some b) \/
  (forall n, iter n a = None).

Definition converges_to (a: A) (b: option B) : Prop :=
  exists n, forall m, (n <= m)%nat -> iter m a = b.

Lemma converges_to_Some:
  forall a n b, iter n a = Some b -> converges_to a (Some b).

Lemma converges_to_exists:
  forall a, exists b, converges_to a b.

Lemma converges_to_unique:
  forall a b, converges_to a b -> forall b', converges_to a b' -> b = b'.

Lemma converges_to_exists_uniquely:
  forall a, exists! b, converges_to a b .

Definition iterate (a: A) : option B :=
  proj1_sig (constructive_definite_description (converges_to a) (converges_to_exists_uniquely a)).

Lemma converges_to_iterate:
  forall a b, converges_to a b -> iterate a = b.

Lemma iterate_converges_to:
  forall a, converges_to a (iterate a).

Variable P: A -> Prop.
Variable Q: B -> Prop.

Hypothesis step_prop:
  forall a : A, P a ->
  match step a with inl b => Q b | inr a' => P a' end.

Lemma iter_prop:
  forall n a b, P a -> iter n a = Some b -> Q b.

Lemma iterate_prop:
  forall a b, iterate a = Some b -> P a -> Q b.

End ITERATION.

End GenIter. *)

Require Import Maps.
(* Maps:
Require Import Equivalence EquivDec.
Require Import Coqlib.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Set Implicit Arguments.

Module Type TREE.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter empty: forall (A: Type), t A.
  Parameter get: forall (A: Type), elt -> t A -> option A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Parameter remove: forall (A: Type), elt -> t A -> t A.

  Axiom gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
    Axiom grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Axiom gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Axiom grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Parameter beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool.
  Axiom beq_correct:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true <->
    (forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end).

  Parameter map:
    forall (A B: Type), (elt -> A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: elt -> A -> B) (i: elt) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Parameter map1:
    forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Parameter combine:
    forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C.
  Axiom gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).

  Parameter elements:
    forall (A: Type), t A -> list (elt * A).
  Axiom elements_correct:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    get i m = Some v -> In (i, v) (elements m).
  Axiom elements_complete:
    forall (A: Type) (m: t A) (i: elt) (v: A),
    In (i, v) (elements m) -> get i m = Some v.
  Axiom elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).
  Axiom elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.
  Axiom elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Parameter fold:
    forall (A B: Type), (B -> elt -> A -> B) -> t A -> B -> B.
  Axiom fold_spec:
    forall (A B: Type) (f: B -> elt -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.
  
  Parameter fold1:
    forall (A B: Type), (B -> A -> B) -> t A -> B -> B.
  Axiom fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.
End TREE.

Module Type MAP.
  Parameter elt: Type.
  Parameter elt_eq: forall (a b: elt), {a = b} + {a <> b}.
  Parameter t: Type -> Type.
  Parameter init: forall (A: Type), A -> t A.
  Parameter get: forall (A: Type), elt -> t A -> A.
  Parameter set: forall (A: Type), elt -> A -> t A -> t A.
  Axiom gi:
    forall (A: Type) (i: elt) (x: A), get i (init x) = x.
  Axiom gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = x.
  Axiom gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Axiom gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Axiom gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Parameter map: forall (A B: Type), (A -> B) -> t A -> t B.
  Axiom gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End MAP.

Module PTree <: TREE.
  Definition elt := positive.
  Definition elt_eq := peq.

  Inductive tree (A : Type) : Type :=
    | Leaf : tree A
    | Node : tree A -> option A -> tree A -> tree A.

  Arguments Leaf [A].
  Arguments Node [A].
  Scheme tree_ind := Induction for tree Sort Prop.

  Definition t := tree.

  Definition empty (A : Type) := (Leaf : t A).

  Fixpoint get (A : Type) (i : positive) (m : t A) {struct i} : option A :=
    match m with
    | Leaf => None
    | Node l o r =>
        match i with
        | xH => o
        | xO ii => get ii l
        | xI ii => get ii r
        end
    end.

  Fixpoint set (A : Type) (i : positive) (v : A) (m : t A) {struct i} : t A :=
    match m with
    | Leaf =>
        match i with
        | xH => Node Leaf (Some v) Leaf
        | xO ii => Node (set ii v Leaf) None Leaf
        | xI ii => Node Leaf None (set ii v Leaf)
        end
    | Node l o r =>
        match i with
        | xH => Node l (Some v) r
        | xO ii => Node (set ii v l) o r
        | xI ii => Node l o (set ii v r)
        end
    end.

  Fixpoint remove (A : Type) (i : positive) (m : t A) {struct i} : t A :=
    match i with
    | xH =>
        match m with
        | Leaf => Leaf
        | Node Leaf o Leaf => Leaf
        | Node l o r => Node l None r
        end
    | xO ii =>
        match m with
        | Leaf => Leaf
        | Node l None Leaf =>
            match remove ii l with
            | Leaf => Leaf
            | mm => Node mm None Leaf
            end
        | Node l o r => Node (remove ii l) o r
        end
    | xI ii =>
        match m with
        | Leaf => Leaf
        | Node Leaf None r =>
            match remove ii r with
            | Leaf => Leaf
            | mm => Node Leaf None mm
            end
        | Node l o r => Node l o (remove ii r)
        end
    end.

  Theorem gempty:
    forall (A: Type) (i: positive), get i (empty A) = None.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = Some x.

    Lemma gleaf : forall (A : Type) (i : positive), get i (Leaf : t A) = None.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then Some x else get i m.

  Theorem gsident:
    forall (A: Type) (i: positive) (m: t A) (v: A),
    get i m = Some v -> set i v m = m.

  Theorem set2:
    forall (A: Type) (i: elt) (m: t A) (v1 v2: A),
    set i v2 (set i v1 m) = set i v2 m.

  Lemma rleaf : forall (A : Type) (i : positive), remove i (Leaf : t A) = Leaf.

  Theorem grs:
    forall (A: Type) (i: positive) (m: t A), get i (remove i m) = None.

  Theorem gro:
    forall (A: Type) (i j: positive) (m: t A),
    i <> j -> get i (remove j m) = get i m.

  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Section BOOLEAN_EQUALITY.

    Variable A: Type.
    Variable beqA: A -> A -> bool.

    Fixpoint bempty (m: t A) : bool :=
      match m with
      | Leaf => true
      | Node l None r => bempty l && bempty r
      | Node l (Some _) r => false
      end.

    Fixpoint beq (m1 m2: t A) {struct m1} : bool :=
      match m1, m2 with
      | Leaf, _ => bempty m2
      | _, Leaf => bempty m1
      | Node l1 o1 r1, Node l2 o2 r2 =>
          match o1, o2 with
          | None, None => true
          | Some y1, Some y2 => beqA y1 y2
          | _, _ => false
          end
          && beq l1 l2 && beq r1 r2
      end.

    Lemma bempty_correct:
      forall m, bempty m = true <-> (forall x, get x m = None).

    Lemma beq_correct:
      forall m1 m2,
      beq m1 m2 = true <->
      (forall (x: elt),
       match get x m1, get x m2 with
       | None, None => True
       | Some y1, Some y2 => beqA y1 y2 = true
       | _, _ => False
       end).

  End BOOLEAN_EQUALITY.

  Fixpoint prev_append (i j: positive) {struct i} : positive :=
    match i with
      | xH => j
      | xI i' => prev_append i' (xI j)
      | xO i' => prev_append i' (xO j)
    end.

  Definition prev (i: positive) : positive :=
    prev_append i xH.

  Lemma prev_append_prev i j:
    prev (prev_append i j) = prev_append j i.

  Lemma prev_involutive i :
    prev (prev i) = i.
  Proof (prev_append_prev i xH).

  Lemma prev_append_inj i j j' :
    prev_append i j = prev_append i j' -> j = j'.

    Fixpoint xmap (A B : Type) (f : positive -> A -> B) (m : t A) (i : positive)
             {struct m} : t B :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node (xmap f l (xO i))
                           (match o with None => None | Some x => Some (f (prev i) x) end)
                           (xmap f r (xI i))
      end.

  Definition map (A B : Type) (f : positive -> A -> B) m := xmap f m xH.

    Lemma xgmap:
      forall (A B: Type) (f: positive -> A -> B) (i j : positive) (m: t A),
      get i (xmap f m j) = option_map (f (prev (prev_append i j))) (get i m).

  Theorem gmap:
    forall (A B: Type) (f: positive -> A -> B) (i: positive) (m: t A),
    get i (map f m) = option_map (f i) (get i m).

  Fixpoint map1 (A B: Type) (f: A -> B) (m: t A) {struct m} : t B :=
    match m with
    | Leaf => Leaf
    | Node l o r => Node (map1 f l) (option_map f o) (map1 f r)
    end.

  Theorem gmap1:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map1 f m) = option_map f (get i m).

  Definition Node' (A: Type) (l: t A) (x: option A) (r: t A): t A :=
    match l, x, r with
    | Leaf, None, Leaf => Leaf
    | _, _, _ => Node l x r
    end.

  Lemma gnode':
    forall (A: Type) (l r: t A) (x: option A) (i: positive),
    get i (Node' l x r) = get i (Node l x r).

  Fixpoint filter1 (A: Type) (pred: A -> bool) (m: t A) {struct m} : t A :=
    match m with
    | Leaf => Leaf
    | Node l o r =>
        let o' := match o with None => None | Some x => if pred x then o else None end in
        Node' (filter1 pred l) o' (filter1 pred r)
    end.

  Theorem gfilter1:
    forall (A: Type) (pred: A -> bool) (i: elt) (m: t A),
    get i (filter1 pred m) =
    match get i m with None => None | Some x => if pred x then Some x else None end.

  Section COMBINE.

  Variables A B C: Type.
  Variable f: option A -> option B -> option C.
  Hypothesis f_none_none: f None None = None.

  Fixpoint xcombine_l (m : t A) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_l l) (f o None) (xcombine_l r)
      end.

  Lemma xgcombine_l :
          forall (m: t A) (i : positive),
          get i (xcombine_l m) = f (get i m) None.

  Fixpoint xcombine_r (m : t B) {struct m} : t C :=
      match m with
      | Leaf => Leaf
      | Node l o r => Node' (xcombine_r l) (f None o) (xcombine_r r)
      end.

  Lemma xgcombine_r :
          forall (m: t B) (i : positive),
          get i (xcombine_r m) = f None (get i m).

  Fixpoint combine (m1: t A) (m2: t B) {struct m1} : t C :=
    match m1 with
    | Leaf => xcombine_r m2
    | Node l1 o1 r1 =>
        match m2 with
        | Leaf => xcombine_l m1
        | Node l2 o2 r2 => Node' (combine l1 l2) (f o1 o2) (combine r1 r2)
        end
    end.

  Theorem gcombine:
      forall (m1: t A) (m2: t B) (i: positive),
      get i (combine m1 m2) = f (get i m1) (get i m2).

  End COMBINE.

  Lemma xcombine_lr :
    forall (A B: Type) (f g : option A -> option A -> option B) (m : t A),
    (forall (i j : option A), f i j = g j i) ->
    xcombine_l f m = xcombine_r g m.

  Theorem combine_commut:
    forall (A B: Type) (f g: option A -> option A -> option B),
    (forall (i j: option A), f i j = g j i) ->
    forall (m1 m2: t A),
    combine f m1 m2 = combine g m2 m1.

    Fixpoint xelements (A : Type) (m : t A) (i : positive)
                       (k: list (positive * A)) {struct m}
                       : list (positive * A) :=
      match m with
      | Leaf => k
      | Node l None r =>
          xelements l (xO i) (xelements r (xI i) k)
      | Node l (Some x) r =>
          xelements l (xO i)
            ((prev i, x) :: xelements r (xI i) k)
      end.

  Definition elements (A: Type) (m : t A) := xelements m xH nil.

  Remark xelements_append:
    forall A (m: t A) i k1 k2,
    xelements m i (k1 ++ k2) = xelements m i k1 ++ k2.

  Remark xelements_leaf:
    forall A i, xelements (@Leaf A) i nil = nil.

  Remark xelements_node:
    forall A (m1: t A) o (m2: t A) i,
    xelements (Node m1 o m2) i nil =
       xelements m1 (xO i) nil
    ++ match o with None => nil | Some v => (prev i, v) :: nil end
    ++ xelements m2 (xI i) nil.

    Lemma xelements_incl:
      forall (A: Type) (m: t A) (i : positive) k x,
      In x k -> In x (xelements m i k).

    Lemma xelements_correct:
      forall (A: Type) (m: t A) (i j : positive) (v: A) k,
      get i m = Some v -> In (prev (prev_append i j), v) (xelements m j k).

  Theorem elements_correct:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    get i m = Some v -> In (i, v) (elements m).

  Lemma in_xelements:
    forall (A: Type) (m: t A) (i k: positive) (v: A) ,
    In (k, v) (xelements m i nil) ->
    exists j, k = prev (prev_append j i) /\ get j m = Some v.

  Theorem elements_complete:
    forall (A: Type) (m: t A) (i: positive) (v: A),
    In (i, v) (elements m) -> get i m = Some v.

  Definition xkeys (A: Type) (m: t A) (i: positive) :=
    List.map (@fst positive A) (xelements m i nil).

  Remark xkeys_leaf:
    forall A i, xkeys (@Leaf A) i = nil.

  Remark xkeys_node:
    forall A (m1: t A) o (m2: t A) i,
    xkeys (Node m1 o m2) i =
       xkeys m1 (xO i)
    ++ match o with None => nil | Some v => prev i :: nil end
    ++ xkeys m2 (xI i).

  Lemma in_xkeys:
    forall (A: Type) (m: t A) (i k: positive),
    In k (xkeys m i) ->
    (exists j, k = prev (prev_append j i)).

  Lemma xelements_keys_norepet:
    forall (A: Type) (m: t A) (i: positive),
    list_norepet (xkeys m i).

  Theorem elements_keys_norepet:
    forall (A: Type) (m: t A),
    list_norepet (List.map (@fst elt A) (elements m)).

  Remark xelements_empty:
    forall (A: Type) (m: t A) i, (forall i, get i m = None) -> xelements m i nil = nil.

  Theorem elements_canonical_order':
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i, option_rel R (get i m) (get i n)) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_canonical_order:
    forall (A B: Type) (R: A -> B -> Prop) (m: t A) (n: t B),
    (forall i x, get i m = Some x -> exists y, get i n = Some y /\ R x y) ->
    (forall i y, get i n = Some y -> exists x, get i m = Some x /\ R x y) ->
    list_forall2
      (fun i_x i_y => fst i_x = fst i_y /\ R (snd i_x) (snd i_y))
      (elements m) (elements n).

  Theorem elements_extensional:
    forall (A: Type) (m n: t A),
    (forall i, get i m = get i n) ->
    elements m = elements n.

  Lemma xelements_remove:
    forall (A: Type) v (m: t A) i j,
    get i m = Some v ->
    exists l1 l2,
    xelements m j nil = l1 ++ (prev (prev_append i j), v) :: l2
    /\ xelements (remove i m) j nil = l1 ++ l2.

  Theorem elements_remove:
    forall (A: Type) i v (m: t A),
    get i m = Some v ->
    exists l1 l2, elements m = l1 ++ (i,v) :: l2 /\ elements (remove i m) = l1 ++ l2.

  Fixpoint xfold (A B: Type) (f: B -> positive -> A -> B)
                 (i: positive) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := xfold f (xO i) l v in
        xfold f (xI i) r v1
    | Node l (Some x) r =>
        let v1 := xfold f (xO i) l v in
        let v2 := f v1 (prev i) x in
        xfold f (xI i) r v2
    end.

  Definition fold (A B : Type) (f: B -> positive -> A -> B) (m: t A) (v: B) :=
    xfold f xH m v.

  Lemma xfold_xelements:
    forall (A B: Type) (f: B -> positive -> A -> B) m i v l,
    List.fold_left (fun a p => f a (fst p) (snd p)) l (xfold f i m v) =

  Theorem fold_spec:
    forall (A B: Type) (f: B -> positive -> A -> B) (v: B) (m: t A),
    fold f m v =
    List.fold_left (fun a p => f a (fst p) (snd p)) (elements m) v.

  Fixpoint fold1 (A B: Type) (f: B -> A -> B) (m: t A) (v: B) {struct m} : B :=
    match m with
    | Leaf => v
    | Node l None r =>
        let v1 := fold1 f l v in
        fold1 f r v1
    | Node l (Some x) r =>
        let v1 := fold1 f l v in
        let v2 := f v1 x in
        fold1 f r v2
    end.

  Lemma fold1_xelements:
    forall (A B: Type) (f: B -> A -> B) m i v l,
    List.fold_left (fun a p => f a (snd p)) l (fold1 f m v) =

  Theorem fold1_spec:
    forall (A B: Type) (f: B -> A -> B) (v: B) (m: t A),
    fold1 f m v =
    List.fold_left (fun a p => f a (snd p)) (elements m) v.

End PTree.

Module PMap <: MAP.
  Definition elt := positive.
  Definition elt_eq := peq.

  Definition t (A : Type) : Type := (A * PTree.t A)%type.

  Definition init (A : Type) (x : A) :=
    (x, PTree.empty A).

  Definition get (A : Type) (i : positive) (m : t A) :=
    match PTree.get i (snd m) with
    | Some x => x
    | None => fst m
    end.

  Definition set (A : Type) (i : positive) (x : A) (m : t A) :=
    (fst m, PTree.set i x (snd m)).

  Theorem gi:
    forall (A: Type) (i: positive) (x: A), get i (init x) = x.

  Theorem gss:
    forall (A: Type) (i: positive) (x: A) (m: t A), get i (set i x m) = x.

  Theorem gso:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.

  Theorem gsspec:
    forall (A: Type) (i j: positive) (x: A) (m: t A),
    get i (set j x m) = if peq i j then x else get i m.

  Theorem gsident:
    forall (A: Type) (i j: positive) (m: t A),
    get j (set i (get i m) m) = get j m.

  Definition map (A B : Type) (f : A -> B) (m : t A) : t B :=
    (f (fst m), PTree.map1 f (snd m)).

  Theorem gmap:
    forall (A B: Type) (f: A -> B) (i: positive) (m: t A),
    get i (map f m) = f(get i m).

  Theorem set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End PMap.

Module Type INDEXED_TYPE.
  Parameter t: Type.
  Parameter index: t -> positive.
  Axiom index_inj: forall (x y: t), index x = index y -> x = y.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End INDEXED_TYPE.

Module IMap(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PMap.t.
  Definition init (A: Type) (x: A) := PMap.init x.
  Definition get (A: Type) (i: X.t) (m: t A) := PMap.get (X.index i) m.
  Definition set (A: Type) (i: X.t) (v: A) (m: t A) := PMap.set (X.index i) v m.
  Definition map (A B: Type) (f: A -> B) (m: t A) : t B := PMap.map f m.

  Lemma gi:
    forall (A: Type) (x: A) (i: X.t), get i (init x) = x.

  Lemma gss:
    forall (A: Type) (i: X.t) (x: A) (m: t A), get i (set i x m) = x.

  Lemma gso:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gsspec:
    forall (A: Type) (i j: X.t) (x: A) (m: t A),

  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: X.t) (m: t A),

  Lemma set2:
    forall (A: Type) (i: elt) (x y: A) (m: t A),
    set i y (set i x m) = set i y m.

End IMap.

Module ZIndexed.
  Definition t := Z.
  Definition index (z: Z): positive :=
    match z with
    | Z0 => xH
    | Zpos p => xO p
    | Zneg p => xI p
    end.
  Lemma index_inj: forall (x y: Z), index x = index y -> x = y.
  Definition eq := zeq.
End ZIndexed.

Module ZMap := IMap(ZIndexed).

Module NIndexed.
  Definition t := N.
  Definition index (n: N): positive :=
    match n with
    | N0 => xH
    | Npos p => xO p
    end.
  Lemma index_inj: forall (x y: N), index x = index y -> x = y.
  Lemma eq: forall (x y: N), {x = y} + {x <> y}.
End NIndexed.

Module NMap := IMap(NIndexed).

Module Type EQUALITY_TYPE.
  Parameter t: Type.
  Parameter eq: forall (x y: t), {x = y} + {x <> y}.
End EQUALITY_TYPE.

Module EMap(X: EQUALITY_TYPE) <: MAP.

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t (A: Type) := X.t -> A.
  Definition init (A: Type) (v: A) := fun (_: X.t) => v.
  Definition get (A: Type) (x: X.t) (m: t A) := m x.
  Definition set (A: Type) (x: X.t) (v: A) (m: t A) :=
    fun (y: X.t) => if X.eq y x then v else m y.
  Lemma gi:
    forall (A: Type) (i: elt) (x: A), init x i = x.
  Lemma gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), (set i x m) i = x.
  Lemma gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> (set j x m) i = m i.
  Lemma gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then x else get i m.
  Lemma gsident:
    forall (A: Type) (i j: elt) (m: t A), get j (set i (get i m) m) = get j m.
  Definition map (A B: Type) (f: A -> B) (m: t A) :=
    fun (x: X.t) => f(m x).
  Lemma gmap:
    forall (A B: Type) (f: A -> B) (i: elt) (m: t A),
    get i (map f m) = f(get i m).
End EMap.

Module ITree(X: INDEXED_TYPE).

  Definition elt := X.t.
  Definition elt_eq := X.eq.
  Definition t : Type -> Type := PTree.t.

  Definition empty (A: Type): t A := PTree.empty A.
  Definition get (A: Type) (k: elt) (m: t A): option A := PTree.get (X.index k) m.
  Definition set (A: Type) (k: elt) (v: A) (m: t A): t A := PTree.set (X.index k) v m.
  Definition remove (A: Type) (k: elt) (m: t A): t A := PTree.remove (X.index k) m.

  Theorem gempty:
    forall (A: Type) (i: elt), get i (empty A) = None.
  Theorem gss:
    forall (A: Type) (i: elt) (x: A) (m: t A), get i (set i x m) = Some x.
  Theorem gso:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    i <> j -> get i (set j x m) = get i m.
  Theorem gsspec:
    forall (A: Type) (i j: elt) (x: A) (m: t A),
    get i (set j x m) = if elt_eq i j then Some x else get i m.
  Theorem grs:
    forall (A: Type) (i: elt) (m: t A), get i (remove i m) = None.
  Theorem gro:
    forall (A: Type) (i j: elt) (m: t A),
    i <> j -> get i (remove j m) = get i m.
  Theorem grspec:
    forall (A: Type) (i j: elt) (m: t A),
    get i (remove j m) = if elt_eq i j then None else get i m.

  Definition beq: forall (A: Type), (A -> A -> bool) -> t A -> t A -> bool := PTree.beq.
  Theorem beq_sound:
    forall (A: Type) (eqA: A -> A -> bool) (t1 t2: t A),
    beq eqA t1 t2 = true ->
    forall (x: elt),
     match get x t1, get x t2 with
     | None, None => True
     | Some y1, Some y2 => eqA y1 y2 = true
     | _, _ => False
    end.

  Definition combine: forall (A B C: Type), (option A -> option B -> option C) -> t A -> t B -> t C := PTree.combine.
  Theorem gcombine:
    forall (A B C: Type) (f: option A -> option B -> option C),
    f None None = None ->
    forall (m1: t A) (m2: t B) (i: elt),
    get i (combine f m1 m2) = f (get i m1) (get i m2).
End ITree.

Module ZTree := ITree(ZIndexed).

Module Tree_Properties(T: TREE).

Section TREE_FOLD_IND.

Variables V A: Type.
Variable f: A -> T.elt -> V -> A.
Variable P: T.t V -> A -> Prop.
Variable init: A.
Variable m_final: T.t V.

Hypothesis P_compat:
  forall m m' a,
  (forall x, T.get x m = T.get x m') ->
  P m a -> P m' a.

Hypothesis H_base:
  P (T.empty _) init.

Hypothesis H_rec:
  forall m a k v,
  T.get k m = None -> T.get k m_final = Some v -> P m a -> P (T.set k v m) (f a k v).

Let f' (a: A) (p : T.elt * V) := f a (fst p) (snd p).

Let P' (l: list (T.elt * V)) (a: A) : Prop :=
  forall m, list_equiv l (T.elements m) -> P m a.

Remark H_base':
  P' nil init.

Remark H_rec':
  forall k v l a,
  ~In k (List.map (@fst T.elt V) l) ->

Lemma fold_rec_aux:
  forall l1 l2 a,
  list_equiv (l2 ++ l1) (T.elements m_final) ->

Theorem fold_rec:
  P m_final (T.fold f m_final init).

End TREE_FOLD_IND.

Section MEASURE.

Variable V: Type.

Definition cardinal (x: T.t V) : nat := List.length (T.elements x).

Theorem cardinal_remove:
  forall x m y, T.get x m = Some y -> (cardinal (T.remove x m) < cardinal m)%nat.

Theorem cardinal_set:
  forall x m y, T.get x m = None -> (cardinal m < cardinal (T.set x y m))%nat.

End MEASURE.

Section FORALL_EXISTS.

Variable A: Type.

Definition for_all (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b && f x a) m true.

Lemma for_all_correct:
  forall m f,
  for_all m f = true <-> (forall x a, T.get x m = Some a -> f x a = true).

Definition exists_ (m: T.t A) (f: T.elt -> A -> bool) : bool :=
  T.fold (fun b x a => b || f x a) m false.

Lemma exists_correct:
  forall m f,
  exists_ m f = true <-> (exists x a, T.get x m = Some a /\ f x a = true).

Remark exists_for_all:
  forall m f,
  exists_ m f = negb (for_all m (fun x a => negb (f x a))).

Remark for_all_exists:
  forall m f,
  for_all m f = negb (exists_ m (fun x a => negb (f x a))).

Lemma for_all_false:
  forall m f,
  for_all m f = false <-> (exists x a, T.get x m = Some a /\ f x a = false).

Lemma exists_false:
  forall m f,
  exists_ m f = false <-> (forall x a, T.get x m = Some a -> f x a = false).

End FORALL_EXISTS.

Section BOOLEAN_EQUALITY.

Variable A: Type.
Variable beqA: A -> A -> bool.

Theorem beq_false:
  forall m1 m2,
  T.beq beqA m1 m2 = false <->

End BOOLEAN_EQUALITY.

Section EXTENSIONAL_EQUALITY.

Variable A: Type.
Variable eqA: A -> A -> Prop.
Hypothesis eqAeq: Equivalence eqA.

Definition Equal (m1 m2: T.t A) : Prop :=
  forall x, match T.get x m1, T.get x m2 with
                | None, None => True
                | Some a1, Some a2 => a1 === a2
                | _, _ => False
            end.

Lemma Equal_refl: forall m, Equal m m.

Lemma Equal_sym: forall m1 m2, Equal m1 m2 -> Equal m2 m1.

Lemma Equal_trans: forall m1 m2 m3, Equal m1 m2 -> Equal m2 m3 -> Equal m1 m3.

Instance Equal_Equivalence : Equivalence Equal := {
  Equivalence_Reflexive := Equal_refl;
  Equivalence_Symmetric := Equal_sym;
  Equivalence_Transitive := Equal_trans
}.

Hypothesis eqAdec: EqDec A eqA.

Program Definition Equal_dec (m1 m2: T.t A) : { m1 === m2 } + { m1 =/= m2 } :=

Instance Equal_EqDec : EqDec (T.t A) Equal := Equal_dec.

End EXTENSIONAL_EQUALITY.

Section OF_LIST.

Variable A: Type.

Let f := fun (m: T.t A) (k_v: T.elt * A) => T.set (fst k_v) (snd k_v) m.

Definition of_list (l: list (T.elt * A)) : T.t A :=
  List.fold_left f l (T.empty _).

Lemma in_of_list:
  forall l k v, T.get k (of_list l) = Some v -> In (k, v) l.

Lemma of_list_dom:
  forall l k, In k (map fst l) -> exists v, T.get k (of_list l) = Some v.

Remark of_list_unchanged:
  forall k l m, ~In k (map fst l) -> T.get k (List.fold_left f l m) = T.get k m.

Lemma of_list_unique:
  forall k v l1 l2,
  ~In k (map fst l2) -> T.get k (of_list (l1 ++ (k, v) :: l2)) = Some v.

Lemma of_list_norepet:
  forall l k v, list_norepet (map fst l) -> In (k, v) l -> T.get k (of_list l) = Some v.

Lemma of_list_elements:
  forall m k, T.get k (of_list (T.elements m)) = T.get k m.

End OF_LIST.

Lemma of_list_related:
  forall (A B: Type) (R: A -> B -> Prop) k l1 l2,
  list_forall2 (fun ka kb => fst ka = fst kb /\ R (snd ka) (snd kb)) l1 l2 ->
  option_rel R (T.get k (of_list l1)) (T.get k (of_list l2)).

End Tree_Properties.

Module PTree_Properties := Tree_Properties(PTree).

Notation "a ! b" := (PTree.get b a) (at level 1).
Notation "a !! b" := (PMap.get b a) (at level 1). *)

Require Import Lattice.
(* Lattice:
Require Import Coqlib.
Require Import Maps.
Require Import FSets.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module Type SEMILATTICE.

  Parameter t: Type.
  Parameter eq: t -> t -> Prop.
  Axiom eq_refl: forall x, eq x x.
  Axiom eq_sym: forall x y, eq x y -> eq y x.
  Axiom eq_trans: forall x y z, eq x y -> eq y z -> eq x z.
  Parameter beq: t -> t -> bool.
  Axiom beq_correct: forall x y, beq x y = true -> eq x y.
  Parameter ge: t -> t -> Prop.
  Axiom ge_refl: forall x y, eq x y -> ge x y.
  Axiom ge_trans: forall x y z, ge x y -> ge y z -> ge x z.
  Parameter bot: t.
  Axiom ge_bot: forall x, ge x bot.
  Parameter lub: t -> t -> t.
  Axiom ge_lub_left: forall x y, ge (lub x y) x.
  Axiom ge_lub_right: forall x y, ge (lub x y) y.

End SEMILATTICE.

Module Type SEMILATTICE_WITH_TOP.

  Include SEMILATTICE.
  Parameter top: t.
  Axiom ge_top: forall x, ge top x.

End SEMILATTICE_WITH_TOP.

Set Implicit Arguments.

Module LPMap1(L: SEMILATTICE) <: SEMILATTICE.

Definition t := PTree.t L.t.

Definition get (p: positive) (x: t) : L.t :=
  match x!p with None => L.bot | Some x => x end.

Definition set (p: positive) (v: L.t) (x: t) : t :=
  if L.beq v L.bot
  then PTree.remove p x
  else PTree.set p v x.

Lemma gsspec:
  forall p v x q,
  L.eq (get q (set p v x)) (if peq q p then v else get q x).

Definition eq (x y: t) : Prop :=
  forall p, L.eq (get p x) (get p y).

Lemma eq_refl: forall x, eq x x.

Lemma eq_sym: forall x y, eq x y -> eq y x.

Lemma eq_trans: forall x y z, eq x y -> eq y z -> eq x z.

Definition beq (x y: t) : bool := PTree.beq L.beq x y.

Lemma beq_correct: forall x y, beq x y = true -> eq x y.

Definition ge (x y: t) : Prop :=
  forall p, L.ge (get p x) (get p y).

Lemma ge_refl: forall x y, eq x y -> ge x y.

Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.

Definition bot : t := PTree.empty _.

Lemma get_bot: forall p, get p bot = L.bot.

Lemma ge_bot: forall x, ge x bot.

Section COMBINE.

Variable f: option L.t -> option L.t -> option L.t.
Hypothesis f_none_none: f None None = None.

Definition opt_eq (ox oy: option L.t) : Prop :=
  match ox, oy with
  | None, None => True
  | Some x, Some y => L.eq x y
  | _, _ => False
  end.

Lemma opt_eq_refl: forall ox, opt_eq ox ox.

Lemma opt_eq_sym: forall ox oy, opt_eq ox oy -> opt_eq oy ox.

Lemma opt_eq_trans: forall ox oy oz, opt_eq ox oy -> opt_eq oy oz -> opt_eq ox oz.

Definition opt_beq (ox oy: option L.t) : bool :=
  match ox, oy with
  | None, None => true
  | Some x, Some y => L.beq x y
  | _, _ => false
  end.

Lemma opt_beq_correct:
  forall ox oy, opt_beq ox oy = true -> opt_eq ox oy.

Definition tree_eq (m1 m2: PTree.t L.t) : Prop :=
  forall i, opt_eq (PTree.get i m1) (PTree.get i m2).

Lemma tree_eq_refl: forall m, tree_eq m m.

Lemma tree_eq_sym: forall m1 m2, tree_eq m1 m2 -> tree_eq m2 m1.

Lemma tree_eq_trans: forall m1 m2 m3, tree_eq m1 m2 -> tree_eq m2 m3 -> tree_eq m1 m3.

Lemma tree_eq_node:
  forall l1 o1 r1 l2 o2 r2,
  tree_eq l1 l2 -> tree_eq r1 r2 -> opt_eq o1 o2 ->
  tree_eq (PTree.Node l1 o1 r1) (PTree.Node l2 o2 r2).

Lemma tree_eq_node':
  forall l1 o1 r1 l2 o2 r2,
  tree_eq l1 l2 -> tree_eq r1 r2 -> opt_eq o1 o2 ->
  tree_eq (PTree.Node l1 o1 r1) (PTree.Node' l2 o2 r2).

Lemma tree_eq_node'':
  forall l1 o1 r1 l2 o2 r2,
  tree_eq l1 l2 -> tree_eq r1 r2 -> opt_eq o1 o2 ->
  tree_eq (PTree.Node' l1 o1 r1) (PTree.Node' l2 o2 r2).

Hint Resolve opt_beq_correct opt_eq_refl opt_eq_sym
             tree_eq_refl tree_eq_sym
             tree_eq_node tree_eq_node' tree_eq_node'' : combine.

Inductive changed: Type := Unchanged | Changed (m: PTree.t L.t).

Fixpoint combine_l (m : PTree.t L.t) {struct m} : changed :=
  match m with
  | PTree.Leaf =>
      Unchanged
  | PTree.Node l o r =>
      let o' := f o None in
      match combine_l l, combine_l r with
      | Unchanged, Unchanged => if opt_beq o' o then Unchanged else Changed (PTree.Node' l o' r)
      | Unchanged, Changed r' => Changed (PTree.Node' l o' r')
      | Changed l', Unchanged => Changed (PTree.Node' l' o' r)
      | Changed l', Changed r' => Changed (PTree.Node' l' o' r')
      end
  end.

Lemma combine_l_eq:
  forall m,
  tree_eq (match combine_l m with Unchanged => m | Changed m' => m' end)
          (PTree.xcombine_l f m).

Fixpoint combine_r (m : PTree.t L.t) {struct m} : changed :=
  match m with
  | PTree.Leaf =>
      Unchanged
  | PTree.Node l o r =>
      let o' := f None o in
      match combine_r l, combine_r r with
      | Unchanged, Unchanged => if opt_beq o' o then Unchanged else Changed (PTree.Node' l o' r)
      | Unchanged, Changed r' => Changed (PTree.Node' l o' r')
      | Changed l', Unchanged => Changed (PTree.Node' l' o' r)
      | Changed l', Changed r' => Changed (PTree.Node' l' o' r')
      end
  end.

Lemma combine_r_eq:
  forall m,
  tree_eq (match combine_r m with Unchanged => m | Changed m' => m' end)
          (PTree.xcombine_r f m).

Inductive changed2 : Type :=
  | Same
  | Same1
  | Same2
  | CC(m: PTree.t L.t).

Fixpoint xcombine (m1 m2 : PTree.t L.t) {struct m1} : changed2 :=
    match m1, m2 with
    | PTree.Leaf, PTree.Leaf =>
        Same
    | PTree.Leaf, _ =>
        match combine_r m2 with
        | Unchanged => Same2
        | Changed m => CC m
        end
    | _, PTree.Leaf =>
        match combine_l m1 with
        | Unchanged => Same1
        | Changed m => CC m
        end
    | PTree.Node l1 o1 r1, PTree.Node l2 o2 r2 =>
        let o := f o1 o2 in
        match xcombine l1 l2, xcombine r1 r2 with
        | Same, Same =>
            match opt_beq o o1, opt_beq o o2 with
            | true, true => Same
            | true, false => Same1
            | false, true => Same2
            | false, false => CC(PTree.Node' l1 o r1)
            end
        | Same1, Same | Same, Same1 | Same1, Same1 =>
            if opt_beq o o1 then Same1 else CC(PTree.Node' l1 o r1)
        | Same2, Same | Same, Same2 | Same2, Same2 =>
            if opt_beq o o2 then Same2 else CC(PTree.Node' l2 o r2)
        | Same1, Same2 => CC(PTree.Node' l1 o r2)
        | (Same|Same1), CC r => CC(PTree.Node' l1 o r)
        | Same2, Same1 => CC(PTree.Node' l2 o r1)
        | Same2, CC r => CC(PTree.Node' l2 o r)
        | CC l, (Same|Same1) => CC(PTree.Node' l o r1)
        | CC l, Same2 => CC(PTree.Node' l o r2)
        | CC l, CC r => CC(PTree.Node' l o r)
        end
    end.

Lemma xcombine_eq:
  forall m1 m2,
  match xcombine m1 m2 with
  | Same => tree_eq m1 (PTree.combine f m1 m2) /\ tree_eq m2 (PTree.combine f m1 m2)

Definition combine (m1 m2: PTree.t L.t) : PTree.t L.t :=
  match xcombine m1 m2 with
  | Same|Same1 => m1
  | Same2 => m2
  | CC m => m
  end.

Lemma gcombine:
  forall m1 m2 i, opt_eq (PTree.get i (combine m1 m2)) (f (PTree.get i m1) (PTree.get i m2)).

End COMBINE.

Definition lub (x y: t) : t :=
  combine
    (fun a b =>
       match a, b with
       | Some u, Some v => Some (L.lub u v)
       | None, _ => b
       | _, None => a
       end)
    x y.

Lemma gcombine_bot:
  forall f t1 t2 p,
  f None None = None ->
  L.eq (get p (combine f t1 t2))

Lemma ge_lub_left:
  forall x y, ge (lub x y) x.

Lemma ge_lub_right:
  forall x y, ge (lub x y) y.

End LPMap1.

Module LPMap(L: SEMILATTICE_WITH_TOP) <: SEMILATTICE_WITH_TOP.

Inductive t' : Type :=
  | Bot: t'
  | Top_except: PTree.t L.t -> t'.

Definition t: Type := t'.

Definition get (p: positive) (x: t) : L.t :=
  match x with
  | Bot => L.bot
  | Top_except m => match m!p with None => L.top | Some x => x end
  end.

Definition set (p: positive) (v: L.t) (x: t) : t :=
  match x with
  | Bot => Bot
  | Top_except m =>
      if L.beq v L.bot
      then Bot
      else Top_except (if L.beq v L.top then PTree.remove p m else PTree.set p v m)
  end.

Lemma gsspec:
  forall p v x q,
  x <> Bot -> ~L.eq v L.bot ->

Definition eq (x y: t) : Prop :=
  forall p, L.eq (get p x) (get p y).

Lemma eq_refl: forall x, eq x x.

Lemma eq_sym: forall x y, eq x y -> eq y x.

Lemma eq_trans: forall x y z, eq x y -> eq y z -> eq x z.

Definition beq (x y: t) : bool :=
  match x, y with
  | Bot, Bot => true
  | Top_except m, Top_except n => PTree.beq L.beq m n
  | _, _ => false
  end.

Lemma beq_correct: forall x y, beq x y = true -> eq x y.

Definition ge (x y: t) : Prop :=
  forall p, L.ge (get p x) (get p y).

Lemma ge_refl: forall x y, eq x y -> ge x y.

Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.

Definition bot := Bot.

Lemma get_bot: forall p, get p bot = L.bot.

Lemma ge_bot: forall x, ge x bot.

Definition top := Top_except (PTree.empty L.t).

Lemma get_top: forall p, get p top = L.top.

Lemma ge_top: forall x, ge top x.

Module LM := LPMap1(L).

Definition opt_lub (x y: L.t) : option L.t :=
  let z := L.lub x y in
  if L.beq z L.top then None else Some z.

Definition lub (x y: t) : t :=
  match x, y with
  | Bot, _ => y
  | _, Bot => x
  | Top_except m, Top_except n =>
      Top_except
        (LM.combine
           (fun a b =>
              match a, b with
              | Some u, Some v => opt_lub u v
              | _, _ => None
              end)
           m n)
  end.

Lemma gcombine_top:
  forall f t1 t2 p,
  f None None = None ->
  L.eq (get p (Top_except (LM.combine f t1 t2)))

Lemma ge_lub_left:
  forall x y, ge (lub x y) x.

Lemma ge_lub_right:
  forall x y, ge (lub x y) y.

End LPMap.

Module LFSet (S: FSetInterface.WS) <: SEMILATTICE.

  Definition t := S.t.

  Definition eq (x y: t) := S.Equal x y.
  Definition eq_refl: forall x, eq x x := S.eq_refl.
  Definition eq_sym: forall x y, eq x y -> eq y x := S.eq_sym.
  Definition eq_trans: forall x y z, eq x y -> eq y z -> eq x z := S.eq_trans.
  Definition beq: t -> t -> bool := S.equal.
  Definition beq_correct: forall x y, beq x y = true -> eq x y := S.equal_2.

  Definition ge (x y: t) := S.Subset y x.
  Lemma ge_refl: forall x y, eq x y -> ge x y.
  Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.

  Definition  bot: t := S.empty.
  Lemma ge_bot: forall x, ge x bot.

  Definition lub: t -> t -> t := S.union.

  Lemma ge_lub_left: forall x y, ge (lub x y) x.

  Lemma ge_lub_right: forall x y, ge (lub x y) y.

End LFSet.

Module LFlat(X: EQUALITY_TYPE) <: SEMILATTICE_WITH_TOP.

Inductive t' : Type :=
  | Bot: t'
  | Inj: X.t -> t'
  | Top: t'.

Definition t : Type := t'.

Definition eq (x y: t) := (x = y).
Definition eq_refl: forall x, eq x x := (@eq_refl t).
Definition eq_sym: forall x y, eq x y -> eq y x := (@eq_sym t).
Definition eq_trans: forall x y z, eq x y -> eq y z -> eq x z := (@eq_trans t).

Definition beq (x y: t) : bool :=
  match x, y with
  | Bot, Bot => true
  | Inj u, Inj v => if X.eq u v then true else false
  | Top, Top => true
  | _, _ => false
  end.

Lemma beq_correct: forall x y, beq x y = true -> eq x y.

Definition ge (x y: t) : Prop :=
  match x, y with
  | Top, _ => True
  | _, Bot => True
  | Inj a, Inj b => a = b
  | _, _ => False
  end.

Lemma ge_refl: forall x y, eq x y -> ge x y.

Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.

Definition bot: t := Bot.

Lemma ge_bot: forall x, ge x bot.

Definition top: t := Top.

Lemma ge_top: forall x, ge top x.

Definition lub (x y: t) : t :=
  match x, y with
  | Bot, _ => y
  | _, Bot => x
  | Top, _ => Top
  | _, Top => Top
  | Inj a, Inj b => if X.eq a b then Inj a else Top
  end.

Lemma ge_lub_left: forall x y, ge (lub x y) x.

Lemma ge_lub_right: forall x y, ge (lub x y) y.

End LFlat.

Module LBoolean <: SEMILATTICE_WITH_TOP.

Definition t := bool.

Definition eq (x y: t) := (x = y).
Definition eq_refl: forall x, eq x x := (@eq_refl t).
Definition eq_sym: forall x y, eq x y -> eq y x := (@eq_sym t).
Definition eq_trans: forall x y z, eq x y -> eq y z -> eq x z := (@eq_trans t).

Definition beq : t -> t -> bool := eqb.

Lemma beq_correct: forall x y, beq x y = true -> eq x y.
Proof eqb_prop.

Definition ge (x y: t) : Prop := x = y \/ x = true.

Lemma ge_refl: forall x y, eq x y -> ge x y.

Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.

Definition bot := false.

Lemma ge_bot: forall x, ge x bot.

Definition top := true.

Lemma ge_top: forall x, ge top x.

Definition lub (x y: t) := x || y.

Lemma ge_lub_left: forall x y, ge (lub x y) x.

Lemma ge_lub_right: forall x y, ge (lub x y) y.

End LBoolean.

Module LOption(L: SEMILATTICE) <: SEMILATTICE_WITH_TOP.

Definition t: Type := option L.t.

Definition eq (x y: t) : Prop :=
  match x, y with
  | None, None => True
  | Some x1, Some y1 => L.eq x1 y1
  | _, _ => False
  end.

Lemma eq_refl: forall x, eq x x.

Lemma eq_sym: forall x y, eq x y -> eq y x.

Lemma eq_trans: forall x y z, eq x y -> eq y z -> eq x z.

Definition beq (x y: t) : bool :=
  match x, y with
  | None, None => true
  | Some x1, Some y1 => L.beq x1 y1
  | _, _ => false
  end.

Lemma beq_correct: forall x y, beq x y = true -> eq x y.

Definition ge (x y: t) : Prop :=
  match x, y with
  | None, _ => True
  | _, None => False
  | Some x1, Some y1 => L.ge x1 y1
  end.

Lemma ge_refl: forall x y, eq x y -> ge x y.

Lemma ge_trans: forall x y z, ge x y -> ge y z -> ge x z.

Definition bot : t := Some L.bot.

Lemma ge_bot: forall x, ge x bot.

Definition lub (x y: t) : t :=
  match x, y with
  | None, _ => None
  | _, None => None
  | Some x1, Some y1 => Some (L.lub x1 y1)
  end.

Lemma ge_lub_left: forall x y, ge (lub x y) x.

Lemma ge_lub_right: forall x y, ge (lub x y) y.

Definition top : t := None.

Lemma ge_top: forall x, ge top x.

End LOption. *)



Local Unset Elimination Schemes.

Local Unset Case Analysis Schemes.



Module Type DATAFLOW_SOLVER.



  Declare Module L: SEMILATTICE.



  Parameter fixpoint:

    forall {A: Type} (code: PTree.t A) (successors: A -> list positive)

           (transf: positive -> L.t -> L.t)

           (ep: positive) (ev: L.t),

    option (PMap.t L.t).



  Axiom fixpoint_solution:

    forall A (code: PTree.t A) successors transf ep ev res n instr s,

    fixpoint code successors transf ep ev = Some res ->

    code!n = Some instr -> In s (successors instr) ->

    (forall n, L.eq (transf n L.bot) L.bot) ->

    L.ge res!!s (transf n res!!n).



  Axiom fixpoint_entry:

    forall A (code: PTree.t A) successors transf ep ev res,

    fixpoint code successors transf ep ev = Some res ->

    L.ge res!!ep ev.



  Axiom fixpoint_invariant:

    forall A (code: PTree.t A) successors transf ep ev

           (P: L.t -> Prop),

    P L.bot ->

    (forall x y, P x -> P y -> P (L.lub x y)) ->

    (forall pc instr x, code!pc = Some instr -> P x -> P (transf pc x)) ->

    P ev ->

    forall res pc,

    fixpoint code successors transf ep ev = Some res ->

    P res!!pc.



End DATAFLOW_SOLVER.



Module Type NODE_SET.



  Parameter t: Type.

  Parameter empty: t.

  Parameter add: positive -> t -> t.

  Parameter pick: t -> option (positive * t).

  Parameter all_nodes: forall {A: Type}, PTree.t A -> t.



  Parameter In: positive -> t -> Prop.

  Axiom empty_spec:

    forall n, ~In n empty.

  Axiom add_spec:

    forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.

  Axiom pick_none:

    forall s n, pick s = None -> ~In n s.

  Axiom pick_some:

    forall s n s', pick s = Some(n, s') ->

    forall n', In n' s <-> n = n' \/ In n' s'.

  Axiom all_nodes_spec:

    forall A (code: PTree.t A) n instr,

    code!n = Some instr -> In n (all_nodes code).



End NODE_SET.



Section REACHABLE.



Context {A: Type} (code: PTree.t A) (successors: A -> list positive).



Inductive reachable: positive -> positive -> Prop :=

  | reachable_refl: forall n, reachable n n

  | reachable_left: forall n1 n2 n3 i,

      code!n1 = Some i -> In n2 (successors i) -> reachable n2 n3 ->

      reachable n1 n3.



Scheme reachable_ind := Induction for reachable Sort Prop.



Lemma reachable_trans:

  forall n1 n2, reachable n1 n2 -> forall n3, reachable n2 n3 -> reachable n1 n3.

Proof.

  induction 1; intros.

- auto.

- econstructor; eauto.

Qed.



Lemma reachable_right:

  forall n1 n2 n3 i,

  reachable n1 n2 -> code!n2 = Some i -> In n3 (successors i) ->

  reachable n1 n3.

Proof.

  intros. apply reachable_trans with n2; auto. econstructor; eauto. constructor.

Qed.



End REACHABLE.



Module Dataflow_Solver (LAT: SEMILATTICE) (NS: NODE_SET) <:

                          DATAFLOW_SOLVER with Module L := LAT.



Module L := LAT.



Section Kildall.



Context {A: Type}.

Variable code: PTree.t A.

Variable successors: A -> list positive.

Variable transf: positive -> L.t -> L.t.



Record state : Type :=

  mkstate { aval: PTree.t L.t; worklist: NS.t; visited: positive -> Prop }.



Definition abstr_value (n: positive) (s: state) : L.t :=

  match s.(aval)!n with

  | None => L.bot

  | Some v => v

  end.



Definition propagate_succ (s: state) (out: L.t) (n: positive) :=

  match s.(aval)!n with

  | None =>

      {| aval := PTree.set n out s.(aval);

         worklist := NS.add n s.(worklist);

         visited := fun p => p = n \/ s.(visited) p |}

  | Some oldl =>

      let newl := L.lub oldl out in

      if L.beq oldl newl

      then s

      else {| aval := PTree.set n newl s.(aval);

              worklist := NS.add n s.(worklist);

              visited := fun p => p = n \/ s.(visited) p |}

  end.



Fixpoint propagate_succ_list (s: state) (out: L.t) (succs: list positive)

                             {struct succs} : state :=

  match succs with

  | nil => s

  | n :: rem => propagate_succ_list (propagate_succ s out n) out rem

  end.



Definition step (s: state) : PMap.t L.t + state :=

  match NS.pick s.(worklist) with

  | None =>

      inl _ (L.bot, s.(aval))

  | Some(n, rem) =>

      match code!n with

      | None =>

          inr _ {| aval := s.(aval); worklist := rem; visited := s.(visited) |}

      | Some instr =>

          inr _ (propagate_succ_list

                  {| aval := s.(aval); worklist := rem; visited := s.(visited) |}

                  (transf n (abstr_value n s))

                  (successors instr))

      end

  end.



Definition fixpoint_from (start: state) : option (PMap.t L.t) :=

  PrimIter.iterate _ _ step start.



Definition start_state (enode: positive) (eval: L.t) :=

  {| aval := PTree.set enode eval (PTree.empty L.t);

     worklist := NS.add enode NS.empty;

     visited := fun n => n = enode |}.



Definition fixpoint (enode: positive) (eval: L.t) :=

  fixpoint_from (start_state enode eval).



Definition start_state_nodeset (enodes: NS.t) :=

  {| aval := PTree.empty L.t;

     worklist := enodes;

     visited := fun n => NS.In n enodes |}.



Definition fixpoint_nodeset (enodes: NS.t) :=

  fixpoint_from (start_state_nodeset enodes).



Definition start_state_allnodes :=

  {| aval := PTree.empty L.t;

     worklist := NS.all_nodes code;

     visited := fun n => exists instr, code!n = Some instr |}.



Definition fixpoint_allnodes :=

  fixpoint_from start_state_allnodes.



Inductive optge: option L.t -> option L.t -> Prop :=

  | optge_some: forall l l',

      L.ge l l' -> optge (Some l) (Some l')

  | optge_none: forall ol,

      optge ol None.



Remark optge_refl: forall ol, optge ol ol.

Proof. destruct ol; constructor. apply L.ge_refl; apply L.eq_refl. Qed.



Remark optge_trans: forall ol1 ol2 ol3, optge ol1 ol2 -> optge ol2 ol3 -> optge ol1 ol3.

Proof.

  intros. inv H0.

  inv H. constructor. eapply L.ge_trans; eauto.

  constructor.

Qed.



Remark optge_abstr_value:

  forall st st' n,

  optge st.(aval)!n st'.(aval)!n ->

  L.ge (abstr_value n st) (abstr_value n st').

Proof.

  intros. unfold abstr_value. inv H. auto. apply L.ge_bot.

Qed.



Lemma propagate_succ_charact:

  forall st out n,

  let st' := propagate_succ st out n in

     optge st'.(aval)!n (Some out)

  /\ (forall s, n <> s -> st'.(aval)!s = st.(aval)!s)

  /\ (forall s, optge st'.(aval)!s st.(aval)!s)

  /\ (NS.In n st'.(worklist) \/ st'.(aval)!n = st.(aval)!n)

  /\ (forall n', NS.In n' st.(worklist) -> NS.In n' st'.(worklist))

  /\ (forall n', NS.In n' st'.(worklist) -> n' = n \/ NS.In n' st.(worklist))

  /\ (forall n', st.(visited) n' -> st'.(visited) n')

  /\ (forall n', st'.(visited) n' -> NS.In n' st'.(worklist) \/ st.(visited) n')

  /\ (forall n', st.(aval)!n' = None -> st'.(aval)!n' <> None -> st'.(visited) n').

Proof.

  unfold propagate_succ; intros; simpl.

  destruct st.(aval)!n as [v|] eqn:E;

  [predSpec L.beq L.beq_correct v (L.lub v out) | idtac].

- 

  repeat split; intros.

  + rewrite E. constructor. eapply L.ge_trans. apply L.ge_refl. apply H; auto. apply L.ge_lub_right.

  + apply optge_refl.

  + right; auto.

  + auto.

  + auto.

  + auto.

  + auto.

  + congruence.

- 

  simpl; repeat split; intros.

  + rewrite PTree.gss. constructor. apply L.ge_lub_right.

  + rewrite PTree.gso by auto. auto.

  + rewrite PTree.gsspec. destruct (peq s n).

    subst s. rewrite E. constructor. apply L.ge_lub_left.

    apply optge_refl.

  + rewrite NS.add_spec. auto.

  + rewrite NS.add_spec. auto.

  + rewrite NS.add_spec in H0. intuition.

  + auto.

  + destruct H0; auto. subst n'. rewrite NS.add_spec; auto.

  + rewrite PTree.gsspec in H1. destruct (peq n' n). auto. congruence.

- 

  simpl; repeat split; intros.

  + rewrite PTree.gss. apply optge_refl.

  + rewrite PTree.gso by auto. auto.

  + rewrite PTree.gsspec. destruct (peq s n).

    subst s. rewrite E. constructor.

    apply optge_refl.

  + rewrite NS.add_spec. auto.

  + rewrite NS.add_spec. auto.

  + rewrite NS.add_spec in H. intuition.

  + auto.

  + destruct H; auto. subst n'. rewrite NS.add_spec. auto.

  + rewrite PTree.gsspec in H0. destruct (peq n' n). auto. congruence.

Qed.



Lemma propagate_succ_list_charact:

  forall out l st,

  let st' := propagate_succ_list st out l in

     (forall n, In n l -> optge st'.(aval)!n (Some out))

  /\ (forall n, ~In n l -> st'.(aval)!n = st.(aval)!n)

  /\ (forall n, optge st'.(aval)!n st.(aval)!n)

  /\ (forall n, NS.In n st'.(worklist) \/ st'.(aval)!n = st.(aval)!n)

  /\ (forall n', NS.In n' st.(worklist) -> NS.In n' st'.(worklist))

  /\ (forall n', NS.In n' st'.(worklist) -> In n' l \/ NS.In n' st.(worklist))

  /\ (forall n', st.(visited) n' -> st'.(visited) n')

  /\ (forall n', st'.(visited) n' -> NS.In n' st'.(worklist) \/ st.(visited) n')

  /\ (forall n', st.(aval)!n' = None -> st'.(aval)!n' <> None -> st'.(visited) n').

Proof.

  induction l; simpl; intros.

- repeat split; intros.

  + contradiction.

  + apply optge_refl.

  + auto.

  + auto.

  + auto.

  + auto.

  + auto.

  + congruence.

- generalize (propagate_succ_charact st out a).

  set (st1 := propagate_succ st out a).

  intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).

  generalize (IHl st1).

  set (st2 := propagate_succ_list st1 out l).

  intros (B1 & B2 & B3 & B4 & B5 & B6 & B7 & B8 & B9). clear IHl.

  repeat split; intros.

  + destruct H.

    * subst n. eapply optge_trans; eauto.

    * auto.

  + rewrite B2 by tauto. apply A2; tauto.

  + eapply optge_trans; eauto.

  + destruct (B4 n). auto.

    destruct (peq n a).

    * subst n. destruct A4. left; auto. right; congruence.

    * right. rewrite H. auto.

  + eauto.

  + exploit B6; eauto. intros [P|P]. auto.

    exploit A6; eauto. intuition.

  + eauto.

  + specialize (B8 n'); specialize (A8 n'). intuition.

  + destruct st1.(aval)!n' eqn:ST1.

    apply B7. apply A9; auto. congruence.

    apply B9; auto.

Qed.



Inductive steps: state -> state -> Prop :=

  | steps_base: forall s, steps s s

  | steps_right: forall s1 s2 s3, steps s1 s2 -> step s2 = inr s3 -> steps s1 s3.



Scheme steps_ind := Induction for steps Sort Prop.



Lemma fixpoint_from_charact:

  forall start res,

  fixpoint_from start = Some res ->

  exists st, steps start st /\ NS.pick st.(worklist) = None /\ res = (L.bot, st.(aval)).

Proof.

  unfold fixpoint; intros.

  eapply (PrimIter.iterate_prop _ _ step

              (fun st => steps start st)

              (fun res => exists st, steps start st /\ NS.pick (worklist st) = None /\ res = (L.bot, aval st))); eauto.

  intros. destruct (step a) eqn:E.

  exists a; split; auto.

  unfold step in E. destruct (NS.pick (worklist a)) as [[n rem]|].

  destruct (code!n); discriminate.

  inv E. auto.

  eapply steps_right; eauto.

  constructor.

Qed.



Lemma step_incr:

  forall n s1 s2, step s1 = inr s2 ->

  optge s2.(aval)!n s1.(aval)!n /\ (s1.(visited) n -> s2.(visited) n).

Proof.

  unfold step; intros.

  destruct (NS.pick (worklist s1)) as [[p rem] | ]; try discriminate.

  destruct (code!p) as [instr|]; inv H.

  + generalize (propagate_succ_list_charact

                     (transf p (abstr_value p s1))

                     (successors instr)

                     {| aval := aval s1; worklist := rem; visited := visited s1 |}).

      simpl.

      set (s' := propagate_succ_list {| aval := aval s1; worklist := rem; visited := visited s1 |}

                    (transf p (abstr_value p s1)) (successors instr)).

      intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).

      auto.

  + split. apply optge_refl. auto.

Qed.



Lemma steps_incr:

  forall n s1 s2, steps s1 s2 ->

  optge s2.(aval)!n s1.(aval)!n /\ (s1.(visited) n -> s2.(visited) n).

Proof.

  induction 1.

- split. apply optge_refl. auto.

- destruct IHsteps. exploit (step_incr n); eauto. intros [P Q].

  split. eapply optge_trans; eauto. eauto.

Qed.



Record good_state (st: state) : Prop := {

  gs_stable: forall n,

    st.(visited) n ->

    NS.In n st.(worklist) \/

    (forall i s,

     code!n = Some i -> In s (successors i) ->

     optge st.(aval)!s (Some (transf n (abstr_value n st))));

  gs_defined: forall n v,

    st.(aval)!n = Some v -> st.(visited) n

}.



Lemma step_state_good:

  forall st pc rem instr,

  NS.pick st.(worklist) = Some (pc, rem) ->

  code!pc = Some instr ->

  good_state st ->

  good_state (propagate_succ_list (mkstate st.(aval) rem st.(visited))

                                  (transf pc (abstr_value pc st))

                                  (successors instr)).

Proof.

  intros until instr; intros PICK CODEAT [GOOD1 GOOD2].

  generalize (NS.pick_some _ _ _ PICK); intro PICK2.

  set (out := transf pc (abstr_value pc st)).

  generalize (propagate_succ_list_charact out (successors instr) {| aval := aval st; worklist := rem; visited := visited st |}).

  set (st' := propagate_succ_list {| aval := aval st; worklist := rem; visited := visited st |} out

                                  (successors instr)).

  simpl; intros (A1 & A2 & A3 & A4 & A5 & A6 & A7 & A8 & A9).

  constructor; intros.

- 

  destruct (A8 n H); auto. destruct (A4 n); auto.

  replace (abstr_value n st') with (abstr_value n st)

  by (unfold abstr_value; rewrite H1; auto).

  exploit GOOD1; eauto. intros [P|P].

+ 

  rewrite PICK2 in P; destruct P.

  * 

    subst n. fold out. right; intros.

    assert (i = instr) by congruence. subst i.

    apply A1; auto.

  * 

    left. apply A5; auto.

+ 

  right; intros. apply optge_trans with st.(aval)!s; eauto.

- 

  destruct st.(aval)!n as [v'|] eqn:ST.

  + apply A7. eapply GOOD2; eauto.

  + apply A9; auto. congruence.

Qed.



Lemma step_state_good_2:

  forall st pc rem,

  good_state st ->

  NS.pick (worklist st) = Some (pc, rem) ->

  code!pc = None ->

  good_state (mkstate st.(aval) rem st.(visited)).

Proof.

  intros until rem; intros [GOOD1 GOOD2] PICK CODE.

  generalize (NS.pick_some _ _ _ PICK); intro PICK2.

  constructor; simpl; intros.

- 

  exploit GOOD1; eauto. intros [P | P].

  + rewrite PICK2 in P. destruct P; auto.

    subst n. right; intros. congruence.

  + right; exact P.

- 

  eapply GOOD2; eauto.

Qed.



Lemma steps_state_good:

  forall st1 st2, steps st1 st2 -> good_state st1 -> good_state st2.

Proof.

  induction 1; intros.

- auto.

- unfold step in e.

  destruct (NS.pick (worklist s2)) as [[n rem] | ] eqn:PICK; try discriminate.

  destruct (code!n) as [instr|] eqn:CODE; inv e.

  eapply step_state_good; eauto.

  eapply step_state_good_2; eauto.

Qed.



Lemma start_state_good:

  forall enode eval, good_state (start_state enode eval).

Proof.

  intros. unfold start_state; constructor; simpl; intros.

- subst n. rewrite NS.add_spec; auto.

- rewrite PTree.gsspec in H. rewrite PTree.gempty in H.

  destruct (peq n enode). auto. discriminate.

Qed.



Lemma start_state_nodeset_good:

  forall enodes, good_state (start_state_nodeset enodes).

Proof.

  intros. unfold start_state_nodeset; constructor; simpl; intros.

- left. auto.

- rewrite PTree.gempty in H. congruence.

Qed.



Lemma start_state_allnodes_good:

  good_state start_state_allnodes.

Proof.

  unfold start_state_allnodes; constructor; simpl; intros.

- destruct H as [instr CODE]. left. eapply NS.all_nodes_spec; eauto.

- rewrite PTree.gempty in H. congruence.

Qed.



Lemma reachable_visited:

  forall st, good_state st -> NS.pick st.(worklist) = None ->

  forall p q, reachable code successors p q -> st.(visited) p -> st.(visited) q.

Proof.

  intros st [GOOD1 GOOD2] PICK. induction 1; intros.

- auto.

- eapply IHreachable; eauto.

  exploit GOOD1; eauto. intros [P | P].

  eelim NS.pick_none; eauto.

  exploit P; eauto. intros OGE; inv OGE. eapply GOOD2; eauto.

Qed.



Theorem fixpoint_solution:

  forall ep ev res n instr s,

  fixpoint ep ev = Some res ->

  code!n = Some instr ->

  In s (successors instr) ->

  (forall n, L.eq (transf n L.bot) L.bot) ->

  L.ge res!!s (transf n res!!n).

Proof.

  unfold fixpoint; intros.

  exploit fixpoint_from_charact; eauto. intros (st & STEPS & PICK & RES).

  exploit steps_state_good; eauto. apply start_state_good. intros [GOOD1 GOOD2].

  rewrite RES; unfold PMap.get; simpl.

  destruct st.(aval)!n as [v|] eqn:STN.

- destruct (GOOD1 n) as [P|P]; eauto.

  eelim NS.pick_none; eauto.

  exploit P; eauto. unfold abstr_value; rewrite STN. intros OGE; inv OGE. auto.

- apply L.ge_trans with L.bot. apply L.ge_bot. apply L.ge_refl. apply L.eq_sym. eauto.

Qed.



Theorem fixpoint_entry:

  forall ep ev res,

  fixpoint ep ev = Some res ->

  L.ge res!!ep ev.

Proof.

  unfold fixpoint; intros.

  exploit fixpoint_from_charact; eauto. intros (st & STEPS & PICK & RES).

  exploit (steps_incr ep); eauto. simpl. rewrite PTree.gss. intros [P Q].

  rewrite RES; unfold PMap.get; simpl. inv P; auto.

Qed.



Theorem fixpoint_allnodes_solution:

  forall res n instr s,

  fixpoint_allnodes = Some res ->

  code!n = Some instr ->

  In s (successors instr) ->

  L.ge res!!s (transf n res!!n).

Proof.

  unfold fixpoint_allnodes; intros.

  exploit fixpoint_from_charact; eauto. intros (st & STEPS & PICK & RES).

  exploit steps_state_good; eauto. apply start_state_allnodes_good. intros [GOOD1 GOOD2].

  exploit (steps_incr n); eauto. simpl. intros [U V].

  exploit (GOOD1 n). apply V. exists instr; auto. intros [P|P].

  eelim NS.pick_none; eauto.

  exploit P; eauto. intros OGE. rewrite RES; unfold PMap.get; simpl.

  inv OGE. assumption.

Qed.



Theorem fixpoint_nodeset_solution:

  forall enodes res e n instr s,

  fixpoint_nodeset enodes = Some res ->

  NS.In e enodes ->

  reachable code successors e n ->

  code!n = Some instr ->

  In s (successors instr) ->

  L.ge res!!s (transf n res!!n).

Proof.

  unfold fixpoint_nodeset; intros.

  exploit fixpoint_from_charact; eauto. intros (st & STEPS & PICK & RES).

  exploit steps_state_good; eauto. apply start_state_nodeset_good. intros GOOD.

  exploit (steps_incr e); eauto. simpl. intros [U V].

  assert (st.(visited) n).

  { eapply reachable_visited; eauto. }

  destruct GOOD as [GOOD1 GOOD2].

  exploit (GOOD1 n); eauto. intros [P|P].

  eelim NS.pick_none; eauto.

  exploit P; eauto. intros OGE. rewrite RES; unfold PMap.get; simpl.

  inv OGE. assumption.

Qed.



Theorem fixpoint_invariant:

  forall ep ev

    (P: L.t -> Prop)

    (P_bot: P L.bot)

    (P_lub: forall x y, P x -> P y -> P (L.lub x y))

    (P_transf: forall pc instr x, code!pc = Some instr -> P x -> P (transf pc x))

    (P_entrypoint: P ev)

    res pc,

  fixpoint ep ev = Some res ->

  P res!!pc.

Proof.

  intros.

  set (inv := fun st => forall x, P (abstr_value x st)).

  assert (inv (start_state ep ev)).

  {

    red; simpl; intros. unfold abstr_value, start_state; simpl.

    rewrite PTree.gsspec. rewrite PTree.gempty.

    destruct (peq x ep). auto. auto.

  }

  assert (forall st v n, inv st -> P v -> inv (propagate_succ st v n)).

  {

    unfold inv, propagate_succ. intros.

    destruct (aval st)!n as [oldl|] eqn:E.

    destruct (L.beq oldl (L.lub oldl v)).

    auto.

    unfold abstr_value. simpl. rewrite PTree.gsspec. destruct (peq x n).

    apply P_lub; auto. replace oldl with (abstr_value n st). auto.

    unfold abstr_value; rewrite E; auto.

    apply H1.

    unfold abstr_value. simpl. rewrite PTree.gsspec. destruct (peq x n).

    auto.

    apply H1.

  }

  assert (forall l st v, inv st -> P v -> inv (propagate_succ_list st v l)).

  {

    induction l; intros; simpl. auto.

    apply IHl; auto.

  }

  assert (forall st1 st2, steps st1 st2 -> inv st1 -> inv st2).

  {

    induction 1; intros.

    auto.

    unfold step in e. destruct (NS.pick (worklist s2)) as [[n rem]|]; try discriminate.

    destruct (code!n) as [instr|] eqn:INSTR; inv e.

    apply H2. apply IHsteps; auto. eapply P_transf; eauto. apply IHsteps; auto.

    apply IHsteps; auto.

  }

  unfold fixpoint in H. exploit fixpoint_from_charact; eauto.

  intros (st & STEPS & PICK & RES).

  replace (res!!pc) with (abstr_value pc st). eapply H3; eauto.

  rewrite RES; auto.

Qed.



End Kildall.



End Dataflow_Solver.



Definition successors_list (successors: PTree.t (list positive)) (pc: positive) : list positive :=

  match successors!pc with None => nil | Some l => l end.



Notation "a !!! b" := (successors_list a b) (at level 1).



Section Predecessor.



Context {A: Type}.

Variable code: PTree.t A.

Variable successors: A -> list positive.



Fixpoint add_successors (pred: PTree.t (list positive))

                        (from: positive) (tolist: list positive)

                        {struct tolist} : PTree.t (list positive) :=

  match tolist with

  | nil => pred

  | to :: rem => add_successors (PTree.set to (from :: pred!!!to) pred) from rem

  end.



Lemma add_successors_correct:

  forall tolist from pred n s,

  In n pred!!!s \/ (n = from /\ In s tolist) ->

  In n (add_successors pred from tolist)!!!s.

Proof.

  induction tolist; simpl; intros.

  tauto.

  apply IHtolist.

  unfold successors_list at 1. rewrite PTree.gsspec. destruct (peq s a).

  subst a. destruct H. auto with coqlib.

  destruct H. subst n. auto with coqlib.

  fold (successors_list pred s). intuition congruence.

Qed.



Definition make_predecessors : PTree.t (list positive) :=

  PTree.fold (fun pred pc instr => add_successors pred pc (successors instr))

             code (PTree.empty (list positive)).



Lemma make_predecessors_correct_1:

  forall n instr s,

  code!n = Some instr -> In s (successors instr) ->

  In n make_predecessors!!!s.

Proof.

  intros until s.

  set (P := fun m p => m!n = Some instr -> In s (successors instr) ->

                       In n p!!!s).

  unfold make_predecessors.

  apply PTree_Properties.fold_rec with (P := P); unfold P; intros.



  apply H0; auto. rewrite H; auto.



  rewrite PTree.gempty in H; congruence.



  apply add_successors_correct.

  rewrite PTree.gsspec in H2. destruct (peq n k).

  inv H2. auto.

  auto.

Qed.



Lemma make_predecessors_correct_2:

  forall n instr s,

  code!n = Some instr -> In s (successors instr) ->

  exists l, make_predecessors!s = Some l /\ In n l.

Proof.

  intros. exploit make_predecessors_correct_1; eauto.

  unfold successors_list. destruct (make_predecessors!s); simpl; intros.

  exists l; auto.

  contradiction.

Qed.



Lemma reachable_predecessors:

  forall p q,

  reachable code successors p q ->

  reachable make_predecessors (fun l => l) q p.

Proof.

  induction 1.

- constructor.

- exploit make_predecessors_correct_2; eauto. intros [l [P Q]].

  eapply reachable_right; eauto.

Qed.



End Predecessor.



Module Type BACKWARD_DATAFLOW_SOLVER.



  Declare Module L: SEMILATTICE.



  Parameter fixpoint:

    forall {A: Type} (code: PTree.t A) (successors: A -> list positive)

           (transf: positive -> L.t -> L.t),

    option (PMap.t L.t).



  Axiom fixpoint_solution:

    forall A (code: PTree.t A) successors transf res n instr s,

    fixpoint code successors transf = Some res ->

    code!n = Some instr -> In s (successors instr) ->

    (forall n a, code!n = None -> L.eq (transf n a) L.bot) ->

    L.ge res!!n (transf s res!!s).



  Parameter fixpoint_allnodes:

    forall {A: Type} (code: PTree.t A) (successors: A -> list positive)

           (transf: positive -> L.t -> L.t),

    option (PMap.t L.t).



  Axiom fixpoint_allnodes_solution:

    forall A (code: PTree.t A) successors transf res n instr s,

    fixpoint_allnodes code successors transf = Some res ->

    code!n = Some instr -> In s (successors instr) ->

    L.ge res!!n (transf s res!!s).



End BACKWARD_DATAFLOW_SOLVER.



Module Backward_Dataflow_Solver (LAT: SEMILATTICE) (NS: NODE_SET):

                   BACKWARD_DATAFLOW_SOLVER with Module L := LAT.



Module L := LAT.



Module DS := Dataflow_Solver L NS.



Section Kildall.



Context {A: Type}.

Variable code: PTree.t A.

Variable successors: A -> list positive.

Variable transf: positive -> L.t -> L.t.



Section Exit_points.



Definition sequential_node (pc: positive) (instr: A): bool :=

  existsb (fun s => match code!s with None => false | Some _ => plt s pc end)

          (successors instr).



Definition exit_points : NS.t :=

  PTree.fold

    (fun ep pc instr =>

       if sequential_node pc instr

       then ep

       else NS.add pc ep)

    code NS.empty.



Lemma exit_points_charact:

  forall n,

  NS.In n exit_points <-> exists i, code!n = Some i /\ sequential_node n i = false.

Proof.

  intros n. unfold exit_points. eapply PTree_Properties.fold_rec.

- 

  intros. rewrite <- H. auto.

- 

  simpl. split; intros.

  eelim NS.empty_spec; eauto.

  destruct H as [i [P Q]]. rewrite PTree.gempty in P. congruence.

- 

  intros. destruct (sequential_node k v) eqn:SN.

  + rewrite H1. rewrite PTree.gsspec. destruct (peq n k).

    subst. split; intros [i [P Q]]. congruence. inv P. congruence.

    tauto.

  + rewrite NS.add_spec. rewrite H1. rewrite PTree.gsspec. destruct (peq n k).

    subst. split. intros. exists v; auto. auto.

    split. intros [P | [i [P Q]]]. congruence. exists i; auto.

    intros [i [P Q]]. right; exists i; auto.

Qed.



Lemma reachable_exit_points:

  forall pc i,

  code!pc = Some i -> exists x, NS.In x exit_points /\ reachable code successors pc x.

Proof.

  intros pc0. pattern pc0. apply (well_founded_ind Plt_wf).

  intros pc HR i CODE.

  destruct (sequential_node pc i) eqn:SN.

- 

  unfold sequential_node in SN. rewrite existsb_exists in SN.

  destruct SN as [s [P Q]]. destruct (code!s) as [i'|] eqn:CS; try discriminate. InvBooleans.

  exploit (HR s); eauto. intros [x [U V]].

  exists x; split; auto. eapply reachable_left; eauto.

- 

  exists pc; split.

  rewrite exit_points_charact. exists i; auto. constructor.

Qed.



Lemma reachable_exit_points_predecessor:

  forall pc i,

  code!pc = Some i ->

  exists x, NS.In x exit_points /\ reachable (make_predecessors code successors) (fun l => l) x pc.

Proof.

  intros. exploit reachable_exit_points; eauto. intros [x [P Q]].

  exists x; split; auto. apply reachable_predecessors. auto.

Qed.



End Exit_points.



Definition fixpoint :=

  DS.fixpoint_nodeset

    (make_predecessors code successors) (fun l => l)

    transf exit_points.



Theorem fixpoint_solution:

  forall res n instr s,

  fixpoint = Some res ->

  code!n = Some instr -> In s (successors instr) ->

  (forall n a, code!n = None -> L.eq (transf n a) L.bot) ->

  L.ge res!!n (transf s res!!s).

Proof.

  intros.

  exploit (make_predecessors_correct_2 code); eauto. intros [l [P Q]].

  destruct code!s as [instr'|] eqn:CS.

- exploit reachable_exit_points_predecessor. eexact CS. intros (ep & U & V).

  unfold fixpoint in H. eapply DS.fixpoint_nodeset_solution; eauto.

- apply L.ge_trans with L.bot. apply L.ge_bot.

  apply L.ge_refl. apply L.eq_sym. auto.

Qed.



Definition fixpoint_allnodes :=

  DS.fixpoint_allnodes

    (make_predecessors code successors) (fun l => l)

    transf.



Theorem fixpoint_allnodes_solution:

  forall res n instr s,

  fixpoint_allnodes = Some res ->

  code!n = Some instr -> In s (successors instr) ->

  L.ge res!!n (transf s res!!s).

Proof.

  intros.

  exploit (make_predecessors_correct_2 code); eauto. intros [l [P Q]].

  unfold fixpoint_allnodes in H.

  eapply DS.fixpoint_allnodes_solution; eauto.

Qed.



End Kildall.



End Backward_Dataflow_Solver.



Module Type ORDERED_TYPE_WITH_TOP.



  Parameter t: Type.

  Parameter ge: t -> t -> Prop.

  Parameter top: t.

  Axiom top_ge: forall x, ge top x.

  Axiom refl_ge: forall x, ge x x.



End ORDERED_TYPE_WITH_TOP.



Module Type BBLOCK_SOLVER.



  Declare Module L: ORDERED_TYPE_WITH_TOP.



  Parameter fixpoint:

    forall {A: Type} (code: PTree.t A) (successors: A -> list positive)

           (transf: positive -> L.t -> L.t)

           (entrypoint: positive),

    option (PMap.t L.t).



  Axiom fixpoint_solution:

    forall A (code: PTree.t A) successors transf entrypoint res n instr s,

    fixpoint code successors transf entrypoint = Some res ->

    code!n = Some instr -> In s (successors instr) ->

    L.ge res!!s (transf n res!!n).



  Axiom fixpoint_entry:

    forall A (code: PTree.t A) successors transf entrypoint res,

    fixpoint code successors transf entrypoint = Some res ->

    res!!entrypoint = L.top.



  Axiom fixpoint_invariant:

    forall A (code: PTree.t A) successors transf entrypoint

           (P: L.t -> Prop),

    P L.top ->

    (forall pc instr x, code!pc = Some instr -> P x -> P (transf pc x)) ->

    forall res pc,

    fixpoint code successors transf entrypoint = Some res ->

    P res!!pc.



End BBLOCK_SOLVER.



Module BBlock_solver(LAT: ORDERED_TYPE_WITH_TOP):

                        BBLOCK_SOLVER with Module L := LAT.



Module L := LAT.



Section Solver.



Context {A: Type}.

Variable code: PTree.t A.

Variable successors: A -> list positive.

Variable transf: positive -> L.t -> L.t.

Variable entrypoint: positive.

Variable P: L.t -> Prop.

Hypothesis Ptop: P L.top.

Hypothesis Ptransf: forall pc instr x, code!pc = Some instr -> P x -> P (transf pc x).



Definition bbmap := positive -> bool.

Definition result := PMap.t L.t.



Record state : Type := mkstate

  { aval: result; worklist: list positive }.



Fixpoint propagate_successors

    (bb: bbmap) (succs: list positive) (l: L.t) (st: state)

    {struct succs} : state :=

  match succs with

  | nil => st

  | s1 :: sl =>

      if bb s1 then

        propagate_successors bb sl l st

      else

        propagate_successors bb sl l

          (mkstate (PMap.set s1 l st.(aval))

                   (s1 :: st.(worklist)))

  end.



Definition step (bb: bbmap) (st: state) : result + state :=

  match st.(worklist) with

  | nil => inl _ st.(aval)

  | pc :: rem =>

      match code!pc with

      | None =>

          inr _ (mkstate st.(aval) rem)

      | Some instr =>

          inr _ (propagate_successors

                   bb (successors instr)

                   (transf pc st.(aval)!!pc)

                   (mkstate st.(aval) rem))

      end

  end.



Definition is_basic_block_head

    (preds: PTree.t (list positive)) (pc: positive) : bool :=

  if peq pc entrypoint then true else

    match preds!!!pc with

    | nil => false

    | s :: nil => peq s pc

    | _ :: _ :: _ => true

    end.



Definition basic_block_map : bbmap :=

  is_basic_block_head (make_predecessors code successors).



Definition basic_block_list (bb: bbmap) : list positive :=

  PTree.fold (fun l pc instr => if bb pc then pc :: l else l)

             code nil.



Definition fixpoint : option result :=

  let bb := basic_block_map in

  PrimIter.iterate _ _ (step bb) (mkstate (PMap.init L.top) (basic_block_list bb)).



Definition predecessors := make_predecessors code successors.



Lemma predecessors_correct:

  forall n instr s,

  code!n = Some instr -> In s (successors instr) -> In n predecessors!!!s.

Proof.

  intros. unfold predecessors. eapply make_predecessors_correct_1; eauto.

Qed.



Lemma multiple_predecessors:

  forall s n1 instr1 n2 instr2,

  code!n1 = Some instr1 -> In s (successors instr1) ->

  code!n2 = Some instr2 -> In s (successors instr2) ->

  n1 <> n2 ->

  basic_block_map s = true.

Proof.

  intros.

  assert (In n1 predecessors!!!s). eapply predecessors_correct; eauto.

  assert (In n2 predecessors!!!s). eapply predecessors_correct; eauto.

  unfold basic_block_map, is_basic_block_head.

  destruct (peq s entrypoint). auto.

  fold predecessors.

  destruct (predecessors!!!s).

  auto.

  destruct l.

  apply proj_sumbool_is_true. simpl in *. intuition congruence.

  auto.

Qed.



Lemma no_self_loop:

  forall n instr,

  code!n = Some instr -> In n (successors instr) -> basic_block_map n = true.

Proof.

  intros. unfold basic_block_map, is_basic_block_head.

  destruct (peq n entrypoint). auto.

  fold predecessors.

  exploit predecessors_correct; eauto. intros.

  destruct (predecessors!!!n).

  contradiction.

  destruct l. apply proj_sumbool_is_true. simpl in H1. tauto.

  auto.

Qed.



Definition state_invariant (st: state) : Prop :=

  (forall n, basic_block_map n = true -> st.(aval)!!n = L.top)

/\

  (forall n,

   In n st.(worklist) \/

   (forall instr s, code!n = Some instr -> In s (successors instr) ->

               L.ge st.(aval)!!s (transf n st.(aval)!!n))).



Lemma propagate_successors_charact1:

  forall bb succs l st,

  incl st.(worklist)

       (propagate_successors bb succs l st).(worklist).

Proof.

  induction succs; simpl; intros.

  apply incl_refl.

  case (bb a).

  auto.

  apply incl_tran with (a :: worklist st).

  apply incl_tl. apply incl_refl.

  set (st1 := (mkstate (PMap.set a l (aval st)) (a :: worklist st))).

  change (a :: worklist st) with (worklist st1).

  auto.

Qed.



Lemma propagate_successors_charact2:

  forall bb succs l st n,

  let st' := propagate_successors bb succs l st in

  (In n succs -> bb n = false -> In n st'.(worklist) /\ st'.(aval)!!n = l)

/\ (~In n succs \/ bb n = true -> st'.(aval)!!n = st.(aval)!!n).

Proof.

  induction succs; simpl; intros.

  

  split. tauto. auto.

  

  caseEq (bb a); intro.

  elim (IHsuccs l st n); intros U V.

  split; intros. apply U; auto.

  elim H0; intro. subst a. congruence. auto.

  apply V. tauto.

  set (st1 := mkstate (PMap.set a l (aval st)) (a :: worklist st)).

  elim (IHsuccs l st1 n); intros U V.

  split; intros.

  elim H0; intros.

  subst n. split.

  apply propagate_successors_charact1. simpl. tauto.

  case (In_dec peq a succs); intro.

  elim (U i H1); auto.

  rewrite V. unfold st1; simpl. apply PMap.gss. tauto.

  apply U; auto.

  rewrite V. unfold st1; simpl. apply PMap.gso.

  red; intro; subst n. elim H0; intro. tauto. congruence.

  tauto.

Qed.



Lemma propagate_successors_invariant:

  forall pc instr res rem,

  code!pc = Some instr ->

  state_invariant (mkstate res (pc :: rem)) ->

  state_invariant

    (propagate_successors basic_block_map (successors instr)

                          (transf pc res!!pc)

                          (mkstate res rem)).

Proof.

  intros until rem. intros CODE [INV1 INV2]. simpl in INV1. simpl in INV2.

  set (l := transf pc res!!pc).

  generalize (propagate_successors_charact1 basic_block_map

                (successors instr) l (mkstate res rem)).

  generalize (propagate_successors_charact2 basic_block_map

                (successors instr) l (mkstate res rem)).

  set (st1 := propagate_successors basic_block_map

                 (successors instr) l (mkstate res rem)).

  intros U V. simpl in U.

  

  split; intros.

  elim (U n); intros C D. rewrite D. simpl. apply INV1. auto. tauto.

  

  destruct (peq pc n). subst n.

  right; intros.

  assert (instr0 = instr) by congruence. subst instr0.

  elim (U s); intros C D.

  replace (st1.(aval)!!pc) with res!!pc. fold l.

  destruct (basic_block_map s) eqn:BB.

  rewrite D. simpl. rewrite INV1. apply L.top_ge. auto. tauto.

  elim (C H0 (eq_refl _)). intros X Y. rewrite Y. apply L.refl_ge.

  elim (U pc); intros E F. rewrite F. reflexivity.

  destruct (In_dec peq pc (successors instr)).

  right. eapply no_self_loop; eauto.

  left; auto.

  

  elim (INV2 n); intro.

  

  left. apply V. simpl. tauto.

  

  assert (INV3: forall s instr', code!n = Some instr' -> In s (successors instr') -> st1.(aval)!!s = res!!s).

    
    intros. elim (U s); intros C D. rewrite D. reflexivity.

    destruct (In_dec peq s (successors instr)).

    right. eapply multiple_predecessors with (n1 := pc) (n2 := n); eauto.

    left; auto.

  destruct (In_dec peq n (successors instr)).

  
  destruct (basic_block_map n) eqn:BB.

  right; intros.

  elim (U n); intros C D. rewrite D. erewrite INV3; eauto.

  tauto.

  left. elim (U n); intros C D. elim (C i BB); intros. auto.

  

  right; intros.

  elim (U n); intros C D. rewrite D.

  erewrite INV3; eauto.

  tauto.

Qed.



Lemma propagate_successors_invariant_2:

  forall pc res rem,

  code!pc = None ->

  state_invariant (mkstate res (pc :: rem)) ->

  state_invariant (mkstate res rem).

Proof.

  intros until rem. intros CODE [INV1 INV2]. simpl in INV1. simpl in INV2.

  split; simpl; intros.

  apply INV1; auto.

  destruct (INV2 n) as [[U | U] | U].

  subst n. right; intros; congruence.

  auto.

  auto.

Qed.



Lemma initial_state_invariant:

  state_invariant (mkstate (PMap.init L.top) (basic_block_list basic_block_map)).

Proof.

  split; simpl; intros.

  apply PMap.gi.

  right. intros. repeat rewrite PMap.gi. apply L.top_ge.

Qed.



Lemma analyze_invariant:

  forall res,

  fixpoint = Some res ->

  state_invariant (mkstate res nil).

Proof.

  unfold fixpoint; intros. pattern res.

  eapply (PrimIter.iterate_prop _ _ (step basic_block_map)

           state_invariant).



  intros st INV. destruct st as [stin stwrk].

  unfold step. simpl. destruct stwrk as [ | pc rem ] eqn:WRK.

  auto.

  destruct (code!pc) as [instr|] eqn:CODE.

  eapply propagate_successors_invariant; eauto.

  eapply propagate_successors_invariant_2; eauto.



  eauto. apply initial_state_invariant.

Qed.



Theorem fixpoint_solution:

  forall res n instr s,

  fixpoint = Some res ->

  code!n = Some instr -> In s (successors instr) ->

  L.ge res!!s (transf n res!!n).

Proof.

  intros.

  assert (state_invariant (mkstate res nil)).

  eapply analyze_invariant; eauto.

  elim H2; simpl; intros.

  elim (H4 n); intros.

  contradiction.

  eauto.

Qed.



Theorem fixpoint_entry:

  forall res,

  fixpoint = Some res ->

  res!!entrypoint = L.top.

Proof.

  intros.

  assert (state_invariant (mkstate res nil)).

  eapply analyze_invariant; eauto.

  elim H0; simpl; intros.

  apply H1. unfold basic_block_map, is_basic_block_head.

  fold predecessors. apply peq_true.

Qed.



Definition Pstate (st: state) : Prop :=

  forall pc, P st.(aval)!!pc.



Lemma propagate_successors_P:

  forall bb l,

  P l ->

  forall succs st,

  Pstate st ->

  Pstate (propagate_successors bb succs l st).

Proof.

  induction succs; simpl; intros.

  auto.

  case (bb a). auto.

  apply IHsuccs. red; simpl; intros.

  rewrite PMap.gsspec. case (peq pc a); intro.

  auto. apply H0.

Qed.



Theorem fixpoint_invariant:

  forall res pc, fixpoint = Some res -> P res!!pc.

Proof.

  unfold fixpoint; intros. pattern res.

  eapply (PrimIter.iterate_prop _ _ (step basic_block_map) Pstate).



  intros st PS. unfold step. destruct (st.(worklist)).

  apply PS.

  assert (PS2: Pstate (mkstate st.(aval) l)).

    red; intro; simpl. apply PS.

  destruct (code!p) as [instr|] eqn:CODE.

  apply propagate_successors_P. eauto. auto.

  auto.



  eauto.

  red; intro; simpl. rewrite PMap.gi. apply Ptop.

Qed.



End Solver.



End BBlock_solver.



Require Import Heaps.
(* Heaps:
Require Import FunInd.
Require Import Coqlib.
Require Import FSets.
Require Import Ordered.

Local Unset Elimination Schemes.
Local Unset Case Analysis Schemes.

Module SplayHeapSet(E: OrderedType).

Module R.

Inductive heap: Type :=
  | Empty
  | Node (l: heap) (x: E.t) (r: heap).

Fixpoint partition (pivot: E.t) (h: heap) { struct h } : heap * heap :=
  match h with
  | Empty => (Empty, Empty)
  | Node a x b =>
      match E.compare x pivot with
      | EQ _ => (a, b)
      | LT _ =>
        match b with
        | Empty => (h, Empty)
        | Node b1 y b2 =>
            match E.compare y pivot with
            | EQ _ => (Node a x b1, b2)
            | LT _ =>
              let (small, big) := partition pivot b2
              in (Node (Node a x b1) y small, big)
            | GT _ =>
              let (small, big) := partition pivot b1
              in (Node a x small, Node big y b2)
            end
        end
     | GT _ =>
        match a with
        | Empty => (Empty, h)
        | Node a1 y a2 =>
            match E.compare y pivot with
            | EQ _ => (a1, Node a2 x b)
            | LT _ =>
              let (small, big) := partition pivot a2
              in (Node a1 y small, Node big x b)
            | GT _ =>
              let (small, big) := partition pivot a1
              in (small, Node big y (Node a2 x b))
            end
        end
    end
  end.

Definition insert (x: E.t) (h: heap) : heap :=
  let (a, b) := partition x h in Node a x b.

Fixpoint findMin (h: heap) : option E.t :=
  match h with
  | Empty => None
  | Node Empty x b => Some x
  | Node a x b => findMin a
  end.

Fixpoint deleteMin (h: heap) : heap :=
  match h with
  | Empty => Empty
  | Node Empty x b => b
  | Node (Node Empty x b) y c => Node b y c
  | Node (Node a x b) y c => Node (deleteMin a) x (Node b y c)
  end.

Fixpoint findMax (h: heap) : option E.t :=
  match h with
  | Empty => None
  | Node a x Empty => Some x
  | Node a x b => findMax b
  end.

Fixpoint deleteMax (h: heap) : heap :=
  match h with
  | Empty => Empty
  | Node b x Empty => b
  | Node b x (Node c y Empty) => Node b x c
  | Node a x (Node b y c) => Node (Node a x b) y (deleteMax c)
  end.

Scheme heap_ind := Induction for heap Sort Prop.
Functional Scheme partition_ind := Induction for partition Sort Prop.
Functional Scheme deleteMin_ind := Induction for deleteMin Sort Prop.
Functional Scheme deleteMax_ind := Induction for deleteMax Sort Prop.

Fixpoint In (x: E.t) (h: heap) : Prop :=
  match h with
  | Empty => False
  | Node a y b => In x a \/ E.eq x y \/ In x b
  end.

Fixpoint lt_heap (h: heap) (x: E.t) : Prop :=
  match h with
  | Empty => True
  | Node a y b => lt_heap a x /\ E.lt y x /\ lt_heap b x
  end.

Fixpoint gt_heap (h: heap) (x: E.t) : Prop :=
  match h with
  | Empty => True
  | Node a y b => gt_heap a x /\ E.lt x y /\ gt_heap b x
  end.

Fixpoint bst (h: heap) : Prop :=
  match h with
  | Empty => True
  | Node a x b => bst a /\ bst b /\ lt_heap a x /\ gt_heap b x
  end.

Definition le (x y: E.t) := E.eq x y \/ E.lt x y.

Lemma le_lt_trans:
  forall x1 x2 x3, le x1 x2 -> E.lt x2 x3 -> E.lt x1 x3.

Lemma lt_le_trans:
  forall x1 x2 x3, E.lt x1 x2 -> le x2 x3 -> E.lt x1 x3.

Lemma le_trans:
  forall x1 x2 x3, le x1 x2 -> le x2 x3 -> le x1 x3.

Lemma lt_heap_trans:
  forall x y, le x y ->
  forall h, lt_heap h x -> lt_heap h y.

Lemma gt_heap_trans:
  forall x y, le y x ->
  forall h, gt_heap h x -> gt_heap h y.

Lemma In_partition:
  forall x pivot, ~E.eq x pivot ->

Lemma partition_lt:
  forall x pivot h,
  lt_heap h x -> lt_heap (fst (partition pivot h)) x /\ lt_heap (snd (partition pivot h)) x.

Lemma partition_gt:
  forall x pivot h,
  gt_heap h x -> gt_heap (fst (partition pivot h)) x /\ gt_heap (snd (partition pivot h)) x.

Lemma partition_split:
  forall pivot h,
  bst h -> lt_heap (fst (partition pivot h)) pivot /\ gt_heap (snd (partition pivot h)) pivot.

Lemma partition_bst:
  forall pivot h,
  bst h ->
  bst (fst (partition pivot h)) /\ bst (snd (partition pivot h)).

Lemma insert_bst:
  forall x h, bst h -> bst (insert x h).

Lemma In_insert:
  forall x h y, bst h -> (In y (insert x h) <-> E.eq y x \/ In y h).

Lemma deleteMin_lt:
  forall x h, lt_heap h x -> lt_heap (deleteMin h) x.

Lemma deleteMin_bst:
  forall h, bst h -> bst (deleteMin h).

Lemma In_deleteMin:
  forall y x h,
  findMin h = Some x ->
  (In y h <-> E.eq y x \/ In y (deleteMin h)).

Lemma gt_heap_In:
  forall x y h, gt_heap h x -> In y h -> E.lt x y.

Lemma findMin_min:
  forall x h, findMin h = Some x -> bst h -> forall y, In y h -> le x y.

Lemma findMin_empty:
  forall h, h <> Empty -> findMin h <> None.

Lemma deleteMax_gt:
  forall x h, gt_heap h x -> gt_heap (deleteMax h) x.

Lemma deleteMax_bst:
  forall h, bst h -> bst (deleteMax h).

Lemma In_deleteMax:
  forall y x h,
  findMax h = Some x ->
  (In y h <-> E.eq y x \/ In y (deleteMax h)).

Lemma lt_heap_In:
  forall x y h, lt_heap h x -> In y h -> E.lt y x.

Lemma findMax_max:
  forall x h, findMax h = Some x -> bst h -> forall y, In y h -> le y x.

Lemma findMax_empty:
  forall h, h <> Empty -> findMax h <> None.

End R.

Definition t := { h: R.heap | R.bst h }.

Program Definition empty : t := R.Empty.

Program Definition insert (x: E.t) (h: t) : t := R.insert x h.

Program Definition findMin (h: t) : option E.t := R.findMin h.

Program Definition deleteMin (h: t) : t := R.deleteMin h.

Program Definition findMax (h: t) : option E.t := R.findMax h.

Program Definition deleteMax (h: t) : t := R.deleteMax h.

Program Definition In (x: E.t) (h: t) : Prop := R.In x h.

Lemma In_empty: forall x, ~In x empty.

Lemma In_insert:
  forall x h y,
  In y (insert x h) <-> E.eq y x \/ In y h.

Lemma findMin_empty:
  forall h y, findMin h = None -> ~In y h.

Lemma findMin_min:
  forall h x y, findMin h = Some x -> In y h -> E.eq x y \/ E.lt x y.

Lemma In_deleteMin:
  forall h x y,
  findMin h = Some x ->
  (In y h <-> E.eq y x \/ In y (deleteMin h)).

Lemma findMax_empty:
  forall h y, findMax h = None -> ~In y h.

Lemma findMax_max:
  forall h x y, findMax h = Some x -> In y h -> E.eq y x \/ E.lt y x.

Lemma In_deleteMax:
  forall h x y,
  findMax h = Some x ->
  (In y h <-> E.eq y x \/ In y (deleteMax h)).

End SplayHeapSet.

Module PHeap := SplayHeapSet(OrderedPositive). *)



Module NodeSetForward <: NODE_SET.

  Definition t := PHeap.t.

  Definition empty := PHeap.empty.

  Definition add (n: positive) (s: t) : t := PHeap.insert n s.

  Definition pick (s: t) :=

    match PHeap.findMax s with

    | Some n => Some(n, PHeap.deleteMax s)

    | None => None

    end.

  Definition all_nodes {A: Type} (code: PTree.t A) :=

    PTree.fold (fun s pc instr => PHeap.insert pc s) code PHeap.empty.

  Definition In := PHeap.In.



  Lemma empty_spec:

    forall n, ~In n empty.

  Proof.

    intros. apply PHeap.In_empty.

  Qed.



  Lemma add_spec:

    forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.

  Proof.

    intros. rewrite PHeap.In_insert. unfold In. intuition.

  Qed.



  Lemma pick_none:

    forall s n, pick s = None -> ~In n s.

  Proof.

    intros until n; unfold pick. caseEq (PHeap.findMax s); intros.

    congruence.

    apply PHeap.findMax_empty. auto.

  Qed.



  Lemma pick_some:

    forall s n s', pick s = Some(n, s') ->

    forall n', In n' s <-> n = n' \/ In n' s'.

  Proof.

    intros until s'; unfold pick. caseEq (PHeap.findMax s); intros.

    inv H0.

    generalize (PHeap.In_deleteMax s n n' H). unfold In. intuition.

    congruence.

  Qed.



  Lemma all_nodes_spec:

    forall A (code: PTree.t A) n instr,

    code!n = Some instr -> In n (all_nodes code).

  Proof.

    intros A code n instr.

    apply PTree_Properties.fold_rec with

      (P := fun m set => m!n = Some instr -> In n set).

    

    intros. apply H0. rewrite H. auto.

    

    rewrite PTree.gempty. congruence.

    

    intros. rewrite PTree.gsspec in H2. rewrite add_spec.

    destruct (peq n k). auto. eauto.

  Qed.

End NodeSetForward.



Module NodeSetBackward <: NODE_SET.

  Definition t := PHeap.t.

  Definition empty := PHeap.empty.

  Definition add (n: positive) (s: t) : t := PHeap.insert n s.

  Definition pick (s: t) :=

    match PHeap.findMin s with

    | Some n => Some(n, PHeap.deleteMin s)

    | None => None

    end.

  Definition all_nodes {A: Type} (code: PTree.t A) :=

    PTree.fold (fun s pc instr => PHeap.insert pc s) code PHeap.empty.

  Definition In := PHeap.In.



  Lemma empty_spec:

    forall n, ~In n empty.

  Proof NodeSetForward.empty_spec.



  Lemma add_spec:

    forall n n' s, In n' (add n s) <-> n = n' \/ In n' s.

  Proof NodeSetForward.add_spec.



  Lemma pick_none:

    forall s n, pick s = None -> ~In n s.

  Proof.

    intros until n; unfold pick. caseEq (PHeap.findMin s); intros.

    congruence.

    apply PHeap.findMin_empty. auto.

  Qed.



  Lemma pick_some:

    forall s n s', pick s = Some(n, s') ->

    forall n', In n' s <-> n = n' \/ In n' s'.

  Proof.

    intros until s'; unfold pick. caseEq (PHeap.findMin s); intros.

    inv H0.

    generalize (PHeap.In_deleteMin s n n' H). unfold In. intuition.

    congruence.

  Qed.



  Lemma all_nodes_spec:

    forall A (code: PTree.t A) n instr,

    code!n = Some instr -> In n (all_nodes code).

  Proof NodeSetForward.all_nodes_spec.

End NodeSetBackward.



