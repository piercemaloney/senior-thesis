

Require Import Reals Psatz.

Require Import Fcore_Raux.
(* Fcore_Raux:
Require Export Reals.
Require Export ZArith.
Require Export Fcore_Zaux.

Section Rmissing.

Theorem Rle_0_minus :
  forall x y, (x <= y)%R -> (0 <= y - x)%R.

Theorem Rabs_eq_Rabs :
  forall x y : R,
  Rabs x = Rabs y -> x = y \/ x = Ropp y.

Theorem Rabs_minus_le:
  forall x y : R,
  (0 <= y)%R -> (y <= 2*x)%R ->
  (Rabs (x-y) <= x)%R.

Theorem Rplus_eq_reg_r :
  forall r r1 r2 : R,
  (r1 + r = r2 + r)%R -> (r1 = r2)%R.

Theorem Rplus_lt_reg_l :
  forall r r1 r2 : R,
  (r + r1 < r + r2)%R -> (r1 < r2)%R.

Theorem Rplus_lt_reg_r :
  forall r r1 r2 : R,
  (r1 + r < r2 + r)%R -> (r1 < r2)%R.

Theorem Rplus_le_reg_r :
  forall r r1 r2 : R,
  (r1 + r <= r2 + r)%R -> (r1 <= r2)%R.

Theorem Rmult_lt_reg_r :
  forall r r1 r2 : R, (0 < r)%R ->
  (r1 * r < r2 * r)%R -> (r1 < r2)%R.

Theorem Rmult_le_reg_r :
  forall r r1 r2 : R, (0 < r)%R ->
  (r1 * r <= r2 * r)%R -> (r1 <= r2)%R.

Theorem Rmult_lt_compat :
  forall r1 r2 r3 r4,
  (0 <= r1)%R -> (0 <= r3)%R -> (r1 < r2)%R -> (r3 < r4)%R ->
  (r1 * r3 < r2 * r4)%R.

Theorem Rmult_eq_reg_r :
  forall r r1 r2 : R, (r1 * r)%R = (r2 * r)%R ->
  r <> 0%R -> r1 = r2.

Theorem Rmult_minus_distr_r :
  forall r r1 r2 : R,
  ((r1 - r2) * r = r1 * r - r2 * r)%R.

Lemma Rmult_neq_reg_r: forall  r1 r2 r3:R, (r2 * r1 <> r3 * r1)%R -> r2 <> r3.

Lemma Rmult_neq_compat_r: forall  r1 r2 r3:R, (r1 <> 0)%R -> (r2 <> r3)%R
   -> (r2 *r1 <> r3*r1)%R.

Theorem Rmult_min_distr_r :
  forall r r1 r2 : R,
  (0 <= r)%R ->
  (Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r).

Theorem Rmult_min_distr_l :
  forall r r1 r2 : R,
  (0 <= r)%R ->
  (r * Rmin r1 r2)%R = Rmin (r * r1) (r * r2).

Lemma Rmin_opp: forall x y, (Rmin (-x) (-y) = - Rmax x y)%R.

Lemma Rmax_opp: forall x y, (Rmax (-x) (-y) = - Rmin x y)%R.

Theorem exp_le :
  forall x y : R,
  (x <= y)%R -> (exp x <= exp y)%R.

Theorem Rinv_lt :
  forall x y,
  (0 < x)%R -> (x < y)%R -> (/y < /x)%R.

Theorem Rinv_le :
  forall x y,
  (0 < x)%R -> (x <= y)%R -> (/y <= /x)%R.

Theorem sqrt_ge_0 :
  forall x : R,
  (0 <= sqrt x)%R.

Lemma sqrt_neg : forall x, (x <= 0)%R -> (sqrt x = 0)%R.

Theorem Rabs_le :
  forall x y,
  (-y <= x <= y)%R -> (Rabs x <= y)%R.

Theorem Rabs_le_inv :
  forall x y,
  (Rabs x <= y)%R -> (-y <= x <= y)%R.

Theorem Rabs_ge :
  forall x y,
  (y <= -x \/ x <= y)%R -> (x <= Rabs y)%R.

Theorem Rabs_ge_inv :
  forall x y,
  (x <= Rabs y)%R -> (y <= -x \/ x <= y)%R.

Theorem Rabs_lt :
  forall x y,
  (-y < x < y)%R -> (Rabs x < y)%R.

Theorem Rabs_lt_inv :
  forall x y,
  (Rabs x < y)%R -> (-y < x < y)%R.

Theorem Rabs_gt :
  forall x y,
  (y < -x \/ x < y)%R -> (x < Rabs y)%R.

Theorem Rabs_gt_inv :
  forall x y,
  (x < Rabs y)%R -> (y < -x \/ x < y)%R.

End Rmissing.

Section Z2R.

Fixpoint P2R (p : positive) :=
  match p with
  | xH => 1%R
  | xO xH => 2%R
  | xO t => (2 * P2R t)%R
  | xI xH => 3%R
  | xI t => (1 + 2 * P2R t)%R
  end.

Definition Z2R n :=
  match n with
  | Zpos p => P2R p
  | Zneg p => Ropp (P2R p)
  | Z0 => 0%R
  end.

Theorem P2R_INR :
  forall n, P2R n = INR (nat_of_P n).

Theorem Z2R_IZR :
  forall n, Z2R n = IZR n.

Theorem Z2R_opp :
  forall n, Z2R (-n) = (- Z2R n)%R.

Theorem Z2R_plus :
  forall m n, (Z2R (m + n) = Z2R m + Z2R n)%R.

Theorem minus_IZR :
  forall n m : Z,
  IZR (n - m) = (IZR n - IZR m)%R.

Theorem Z2R_minus :
  forall m n, (Z2R (m - n) = Z2R m - Z2R n)%R.

Theorem Z2R_mult :
  forall m n, (Z2R (m * n) = Z2R m * Z2R n)%R.

Theorem le_Z2R :
  forall m n, (Z2R m <= Z2R n)%R -> (m <= n)%Z.

Theorem Z2R_le :
  forall m n, (m <= n)%Z -> (Z2R m <= Z2R n)%R.

Theorem lt_Z2R :
  forall m n, (Z2R m < Z2R n)%R -> (m < n)%Z.

Theorem Z2R_lt :
  forall m n, (m < n)%Z -> (Z2R m < Z2R n)%R.

Theorem Z2R_le_lt :
  forall m n p, (m <= n < p)%Z -> (Z2R m <= Z2R n < Z2R p)%R.

Theorem le_lt_Z2R :
  forall m n p, (Z2R m <= Z2R n < Z2R p)%R -> (m <= n < p)%Z.

Theorem eq_Z2R :
  forall m n, (Z2R m = Z2R n)%R -> (m = n)%Z.

Theorem neq_Z2R :
  forall m n, (Z2R m <> Z2R n)%R -> (m <> n)%Z.

Theorem Z2R_neq :
  forall m n, (m <> n)%Z -> (Z2R m <> Z2R n)%R.

Theorem Z2R_abs :
  forall z, Z2R (Zabs z) = Rabs (Z2R z).

End Z2R.

Section Rcompare.

Definition Rcompare x y :=
  match total_order_T x y with
  | inleft (left _) => Lt
  | inleft (right _) => Eq
  | inright _ => Gt
  end.

Inductive Rcompare_prop (x y : R) : comparison -> Prop :=
  | Rcompare_Lt_ : (x < y)%R -> Rcompare_prop x y Lt
  | Rcompare_Eq_ : x = y -> Rcompare_prop x y Eq
  | Rcompare_Gt_ : (y < x)%R -> Rcompare_prop x y Gt.

Theorem Rcompare_spec :
  forall x y, Rcompare_prop x y (Rcompare x y).

Global Opaque Rcompare.

Theorem Rcompare_Lt :
  forall x y,
  (x < y)%R -> Rcompare x y = Lt.

Theorem Rcompare_Lt_inv :
  forall x y,
  Rcompare x y = Lt -> (x < y)%R.

Theorem Rcompare_not_Lt :
  forall x y,
  (y <= x)%R -> Rcompare x y <> Lt.

Theorem Rcompare_not_Lt_inv :
  forall x y,
  Rcompare x y <> Lt -> (y <= x)%R.

Theorem Rcompare_Eq :
  forall x y,
  x = y -> Rcompare x y = Eq.

Theorem Rcompare_Eq_inv :
  forall x y,
  Rcompare x y = Eq -> x = y.

Theorem Rcompare_Gt :
  forall x y,
  (y < x)%R -> Rcompare x y = Gt.

Theorem Rcompare_Gt_inv :
  forall x y,
  Rcompare x y = Gt -> (y < x)%R.

Theorem Rcompare_not_Gt :
  forall x y,
  (x <= y)%R -> Rcompare x y <> Gt.

Theorem Rcompare_not_Gt_inv :
  forall x y,
  Rcompare x y <> Gt -> (x <= y)%R.

Theorem Rcompare_Z2R :
  forall x y, Rcompare (Z2R x) (Z2R y) = Zcompare x y.

Theorem Rcompare_sym :
  forall x y,
  Rcompare x y = CompOpp (Rcompare y x).

Theorem Rcompare_plus_r :
  forall z x y,
  Rcompare (x + z) (y + z) = Rcompare x y.

Theorem Rcompare_plus_l :
  forall z x y,
  Rcompare (z + x) (z + y) = Rcompare x y.

Theorem Rcompare_mult_r :
  forall z x y,
  (0 < z)%R ->
  Rcompare (x * z) (y * z) = Rcompare x y.

Theorem Rcompare_mult_l :
  forall z x y,
  (0 < z)%R ->
  Rcompare (z * x) (z * y) = Rcompare x y.

Theorem Rcompare_middle :
  forall x d u,
  Rcompare (x - d) (u - x) = Rcompare x ((d + u) / 2).

Theorem Rcompare_half_l :
  forall x y, Rcompare (x / 2) y = Rcompare x (2 * y).

Theorem Rcompare_half_r :
  forall x y, Rcompare x (y / 2) = Rcompare (2 * x) y.

Theorem Rcompare_sqr :
  forall x y,
  (0 <= x)%R -> (0 <= y)%R ->
  Rcompare (x * x) (y * y) = Rcompare x y.

Theorem Rmin_compare :
  forall x y,
  Rmin x y = match Rcompare x y with Lt => x | Eq => x | Gt => y end.

End Rcompare.

Section Rle_bool.

Definition Rle_bool x y :=
  match Rcompare x y with
  | Gt => false
  | _ => true
  end.

Inductive Rle_bool_prop (x y : R) : bool -> Prop :=
  | Rle_bool_true_ : (x <= y)%R -> Rle_bool_prop x y true
  | Rle_bool_false_ : (y < x)%R -> Rle_bool_prop x y false.

Theorem Rle_bool_spec :
  forall x y, Rle_bool_prop x y (Rle_bool x y).

Theorem Rle_bool_true :
  forall x y,
  (x <= y)%R -> Rle_bool x y = true.

Theorem Rle_bool_false :
  forall x y,
  (y < x)%R -> Rle_bool x y = false.

End Rle_bool.

Section Rlt_bool.

Definition Rlt_bool x y :=
  match Rcompare x y with
  | Lt => true
  | _ => false
  end.

Inductive Rlt_bool_prop (x y : R) : bool -> Prop :=
  | Rlt_bool_true_ : (x < y)%R -> Rlt_bool_prop x y true
  | Rlt_bool_false_ : (y <= x)%R -> Rlt_bool_prop x y false.

Theorem Rlt_bool_spec :
  forall x y, Rlt_bool_prop x y (Rlt_bool x y).

Theorem negb_Rlt_bool :
  forall x y,
  negb (Rle_bool x y) = Rlt_bool y x.

Theorem negb_Rle_bool :
  forall x y,
  negb (Rlt_bool x y) = Rle_bool y x.

Theorem Rlt_bool_true :
  forall x y,
  (x < y)%R -> Rlt_bool x y = true.

Theorem Rlt_bool_false :
  forall x y,
  (y <= x)%R -> Rlt_bool x y = false.

End Rlt_bool.

Section Req_bool.

Definition Req_bool x y :=
  match Rcompare x y with
  | Eq => true
  | _ => false
  end.

Inductive Req_bool_prop (x y : R) : bool -> Prop :=
  | Req_bool_true_ : (x = y)%R -> Req_bool_prop x y true
  | Req_bool_false_ : (x <> y)%R -> Req_bool_prop x y false.

Theorem Req_bool_spec :
  forall x y, Req_bool_prop x y (Req_bool x y).

Theorem Req_bool_true :
  forall x y,
  (x = y)%R -> Req_bool x y = true.

Theorem Req_bool_false :
  forall x y,
  (x <> y)%R -> Req_bool x y = false.

End Req_bool.

Section Floor_Ceil.

Definition Zfloor (x : R) := (up x - 1)%Z.

Theorem Zfloor_lb :
  forall x : R,
  (Z2R (Zfloor x) <= x)%R.

Theorem Zfloor_ub :
  forall x : R,
  (x < Z2R (Zfloor x) + 1)%R.

Theorem Zfloor_lub :
  forall n x,
  (Z2R n <= x)%R ->
  (n <= Zfloor x)%Z.

Theorem Zfloor_imp :
  forall n x,
  (Z2R n <= x < Z2R (n + 1))%R ->
  Zfloor x = n.

Theorem Zfloor_Z2R :
  forall n,
  Zfloor (Z2R n) = n.

Theorem Zfloor_le :
  forall x y, (x <= y)%R ->
  (Zfloor x <= Zfloor y)%Z.

Definition Zceil (x : R) := (- Zfloor (- x))%Z.

Theorem Zceil_ub :
  forall x : R,
  (x <= Z2R (Zceil x))%R.

Theorem Zceil_glb :
  forall n x,
  (x <= Z2R n)%R ->
  (Zceil x <= n)%Z.

Theorem Zceil_imp :
  forall n x,
  (Z2R (n - 1) < x <= Z2R n)%R ->
  Zceil x = n.

Theorem Zceil_Z2R :
  forall n,
  Zceil (Z2R n) = n.

Theorem Zceil_le :
  forall x y, (x <= y)%R ->
  (Zceil x <= Zceil y)%Z.

Theorem Zceil_floor_neq :
  forall x : R,
  (Z2R (Zfloor x) <> x)%R ->
  (Zceil x = Zfloor x + 1)%Z.

Definition Ztrunc x := if Rlt_bool x 0 then Zceil x else Zfloor x.

Theorem Ztrunc_Z2R :
  forall n,
  Ztrunc (Z2R n) = n.

Theorem Ztrunc_floor :
  forall x,
  (0 <= x)%R ->
  Ztrunc x = Zfloor x.

Theorem Ztrunc_ceil :
  forall x,
  (x <= 0)%R ->
  Ztrunc x = Zceil x.

Theorem Ztrunc_le :
  forall x y, (x <= y)%R ->
  (Ztrunc x <= Ztrunc y)%Z.

Theorem Ztrunc_opp :
  forall x,
  Ztrunc (- x) = Zopp (Ztrunc x).

Theorem Ztrunc_abs :
  forall x,
  Ztrunc (Rabs x) = Zabs (Ztrunc x).

Theorem Ztrunc_lub :
  forall n x,
  (Z2R n <= Rabs x)%R ->
  (n <= Zabs (Ztrunc x))%Z.

Definition Zaway x := if Rlt_bool x 0 then Zfloor x else Zceil x.

Theorem Zaway_Z2R :
  forall n,
  Zaway (Z2R n) = n.

Theorem Zaway_ceil :
  forall x,
  (0 <= x)%R ->
  Zaway x = Zceil x.

Theorem Zaway_floor :
  forall x,
  (x <= 0)%R ->
  Zaway x = Zfloor x.

Theorem Zaway_le :
  forall x y, (x <= y)%R ->
  (Zaway x <= Zaway y)%Z.

Theorem Zaway_opp :
  forall x,
  Zaway (- x) = Zopp (Zaway x).

Theorem Zaway_abs :
  forall x,
  Zaway (Rabs x) = Zabs (Zaway x).

End Floor_Ceil.

Section Zdiv_Rdiv.

Theorem Zfloor_div :
  forall x y,
  y <> Z0 ->
  Zfloor (Z2R x / Z2R y) = (x / y)%Z.

End Zdiv_Rdiv.

Section pow.

Variable r : radix.

Theorem radix_pos : (0 < Z2R r)%R.

Definition bpow e :=
  match e with
  | Zpos p => Z2R (Zpower_pos r p)
  | Zneg p => Rinv (Z2R (Zpower_pos r p))
  | Z0 => 1%R
  end.

Theorem Z2R_Zpower_pos :
  forall n m,
  Z2R (Zpower_pos n m) = powerRZ (Z2R n) (Zpos m).

Theorem bpow_powerRZ :
  forall e,
  bpow e = powerRZ (Z2R r) e.

Theorem  bpow_ge_0 :
  forall e : Z, (0 <= bpow e)%R.

Theorem bpow_gt_0 :
  forall e : Z, (0 < bpow e)%R.

Theorem bpow_plus :
  forall e1 e2 : Z, (bpow (e1 + e2) = bpow e1 * bpow e2)%R.

Theorem bpow_1 :
  bpow 1 = Z2R r.

Theorem bpow_plus1 :
  forall e : Z, (bpow (e + 1) = Z2R r * bpow e)%R.

Theorem bpow_opp :
  forall e : Z, (bpow (-e) = /bpow e)%R.

Theorem Z2R_Zpower_nat :
  forall e : nat,
  Z2R (Zpower_nat r e) = bpow (Z_of_nat e).

Theorem Z2R_Zpower :
  forall e : Z,
  (0 <= e)%Z ->
  Z2R (Zpower r e) = bpow e.

Theorem bpow_lt :
  forall e1 e2 : Z,
  (e1 < e2)%Z -> (bpow e1 < bpow e2)%R.

Theorem lt_bpow :
  forall e1 e2 : Z,
  (bpow e1 < bpow e2)%R -> (e1 < e2)%Z.

Theorem bpow_le :
  forall e1 e2 : Z,
  (e1 <= e2)%Z -> (bpow e1 <= bpow e2)%R.

Theorem le_bpow :
  forall e1 e2 : Z,
  (bpow e1 <= bpow e2)%R -> (e1 <= e2)%Z.

Theorem bpow_inj :
  forall e1 e2 : Z,
  bpow e1 = bpow e2 -> e1 = e2.

Theorem bpow_exp :
  forall e : Z,
  bpow e = exp (Z2R e * ln (Z2R r)).

Record ln_beta_prop x := {
  ln_beta_val :> Z ;
  _ : (x <> 0)%R -> (bpow (ln_beta_val - 1)%Z <= Rabs x < bpow ln_beta_val)%R
}.

Definition ln_beta :
  forall x : R, ln_beta_prop x.

Theorem bpow_lt_bpow :
  forall e1 e2,
  (bpow (e1 - 1) < bpow e2)%R ->
  (e1 <= e2)%Z.

Theorem bpow_unique :
  forall x e1 e2,
  (bpow (e1 - 1) <= x < bpow e1)%R ->
  (bpow (e2 - 1) <= x < bpow e2)%R ->
  e1 = e2.

Theorem ln_beta_unique :
  forall (x : R) (e : Z),
  (bpow (e - 1) <= Rabs x < bpow e)%R ->
  ln_beta x = e :> Z.

Theorem ln_beta_opp :
  forall x,
  ln_beta (-x) = ln_beta x :> Z.

Theorem ln_beta_abs :
  forall x,
  ln_beta (Rabs x) = ln_beta x :> Z.

Theorem ln_beta_unique_pos :
  forall (x : R) (e : Z),
  (bpow (e - 1) <= x < bpow e)%R ->
  ln_beta x = e :> Z.

Theorem ln_beta_le_abs :
  forall x y,
  (x <> 0)%R -> (Rabs x <= Rabs y)%R ->
  (ln_beta x <= ln_beta y)%Z.

Theorem ln_beta_le :
  forall x y,
  (0 < x)%R -> (x <= y)%R ->
  (ln_beta x <= ln_beta y)%Z.

Lemma ln_beta_lt_pos :
  forall x y,
  (0 < y)%R ->
  (ln_beta x < ln_beta y)%Z -> (x < y)%R.

Theorem ln_beta_bpow :
  forall e, (ln_beta (bpow e) = e + 1 :> Z)%Z.

Theorem ln_beta_mult_bpow :
  forall x e, x <> 0%R ->
  (ln_beta (x * bpow e) = ln_beta x + e :>Z)%Z.

Theorem ln_beta_le_bpow :
  forall x e,
  x <> 0%R ->
  (Rabs x < bpow e)%R ->
  (ln_beta x <= e)%Z.

Theorem ln_beta_gt_bpow :
  forall x e,
  (bpow e <= Rabs x)%R ->
  (e < ln_beta x)%Z.

Theorem ln_beta_ge_bpow :
  forall x e,
  (bpow (e - 1) <= Rabs x)%R ->
  (e <= ln_beta x)%Z.

Theorem bpow_ln_beta_gt :
  forall x,
  (Rabs x < bpow (ln_beta x))%R.

Theorem bpow_ln_beta_le :
  forall x, (x <> 0)%R ->
    (bpow (ln_beta x-1) <= Rabs x)%R.

Theorem ln_beta_le_Zpower :
  forall m e,
  m <> Z0 ->
  (Zabs m < Zpower r e)%Z->
  (ln_beta (Z2R m) <= e)%Z.

Theorem ln_beta_gt_Zpower :
  forall m e,
  m <> Z0 ->
  (Zpower r e <= Zabs m)%Z ->
  (e < ln_beta (Z2R m))%Z.

Lemma ln_beta_mult :
  forall x y,
  (x <> 0)%R -> (y <> 0)%R ->
  (ln_beta x + ln_beta y - 1 <= ln_beta (x * y) <= ln_beta x + ln_beta y)%Z.

Lemma ln_beta_plus :
  forall x y,
  (0 < y)%R -> (y <= x)%R ->
  (ln_beta x <= ln_beta (x + y) <= ln_beta x + 1)%Z.

Lemma ln_beta_minus :
  forall x y,
  (0 < y)%R -> (y < x)%R ->
  (ln_beta (x - y) <= ln_beta x)%Z.

Lemma ln_beta_minus_lb :
  forall x y,
  (0 < x)%R -> (0 < y)%R ->
  (ln_beta y <= ln_beta x - 2)%Z ->
  (ln_beta x - 1 <= ln_beta (x - y))%Z.

Lemma ln_beta_div :
  forall x y : R,
  (0 < x)%R -> (0 < y)%R ->
  (ln_beta x - ln_beta y <= ln_beta (x / y) <= ln_beta x - ln_beta y + 1)%Z.

Lemma ln_beta_sqrt :
  forall x,
  (0 < x)%R ->
  (2 * ln_beta (sqrt x) - 1 <= ln_beta x <= 2 * ln_beta (sqrt x))%Z.

End pow.

Section Bool.

Theorem eqb_sym :
  forall x y, Bool.eqb x y = Bool.eqb y x.

Theorem eqb_false :
  forall x y, x = negb y -> Bool.eqb x y = false.

Theorem eqb_true :
  forall x y, x = y -> Bool.eqb x y = true.

End Bool.

Section cond_Ropp.

Definition cond_Ropp (b : bool) m := if b then Ropp m else m.

Theorem Z2R_cond_Zopp :
  forall b m,
  Z2R (cond_Zopp b m) = cond_Ropp b (Z2R m).

Theorem abs_cond_Ropp :
  forall b m,
  Rabs (cond_Ropp b m) = Rabs m.

Theorem cond_Ropp_Rlt_bool :
  forall m,
  cond_Ropp (Rlt_bool m 0) m = Rabs m.

Theorem cond_Ropp_involutive :
  forall b x,
  cond_Ropp b (cond_Ropp b x) = x.

Theorem cond_Ropp_even_function :
  forall {A : Type} (f : R -> A),
  (forall x, f (Ropp x) = f x) ->
  forall b x, f (cond_Ropp b x) = f x.

Theorem cond_Ropp_odd_function :
  forall (f : R -> R),
  (forall x, f (Ropp x) = Ropp (f x)) ->
  forall b x, f (cond_Ropp b x) = cond_Ropp b (f x).

Theorem cond_Ropp_inj :
  forall b x y,
  cond_Ropp b x = cond_Ropp b y -> x = y.

Theorem cond_Ropp_mult_l :
  forall b x y,
  cond_Ropp b (x * y) = (cond_Ropp b x * y)%R.

Theorem cond_Ropp_mult_r :
  forall b x y,
  cond_Ropp b (x * y) = (x * cond_Ropp b y)%R.

Theorem cond_Ropp_plus :
  forall b x y,
  cond_Ropp b (x + y) = (cond_Ropp b x + cond_Ropp b y)%R.

End cond_Ropp.

Theorem LPO_min :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n /\ forall i, (i < n)%nat -> ~ P i} + {forall n, ~ P n}.

Theorem LPO :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n} + {forall n, ~ P n}.

Lemma LPO_Z : forall P : Z -> Prop, (forall n, P n \/ ~P n) ->
  {n : Z| P n} + {forall n, ~ P n}.

Ltac bpow_simplify :=
  
  repeat
    match goal with
      | |- context [(bpow _ _ * bpow _ _)] =>
        rewrite <- bpow_plus
      | |- context [(?X1 * bpow _ _ * bpow _ _)] =>
        rewrite (Rmult_assoc X1); rewrite <- bpow_plus
      | |- context [(?X1 * (?X2 * bpow _ _) * bpow _ _)] =>
        rewrite <- (Rmult_assoc X1 X2); rewrite (Rmult_assoc (X1 * X2));
        rewrite <- bpow_plus
    end;
  
  repeat
    match goal with
      | |- context [(bpow _ ?X)] =>
        progress ring_simplify X
    end;
  
  change (bpow _ 0) with 1;
  repeat
    match goal with
      | |- context [(_ * 1)] =>
        rewrite Rmult_1_r
    end. *)

Require Import Fcore_defs.
(* Fcore_defs:
Require Import Fcore_Raux.

Section Def.

Record float (beta : radix) := Float { Fnum : Z ; Fexp : Z }.

Arguments Fnum {beta} f.
Arguments Fexp {beta} f.

Variable beta : radix.

Definition F2R (f : float beta) :=
  (Z2R (Fnum f) * bpow beta (Fexp f))%R.

Definition round_pred_total (P : R -> R -> Prop) :=
  forall x, exists f, P x f.

Definition round_pred_monotone (P : R -> R -> Prop) :=
  forall x y f g, P x f -> P y g -> (x <= y)%R -> (f <= g)%R.

Definition round_pred (P : R -> R -> Prop) :=
  round_pred_total P /\
  round_pred_monotone P.

End Def.

Arguments Fnum {beta} f.
Arguments Fexp {beta} f.
Arguments F2R {beta} f.

Section RND.

Definition Rnd_DN_pt (F : R -> Prop) (x f : R) :=
  F f /\ (f <= x)%R /\
  forall g : R, F g -> (g <= x)%R -> (g <= f)%R.

Definition Rnd_DN (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_DN_pt F x (rnd x).

Definition Rnd_UP_pt (F : R -> Prop) (x f : R) :=
  F f /\ (x <= f)%R /\
  forall g : R, F g -> (x <= g)%R -> (f <= g)%R.

Definition Rnd_UP (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_UP_pt F x (rnd x).

Definition Rnd_ZR_pt (F : R -> Prop) (x f : R) :=
  ( (0 <= x)%R -> Rnd_DN_pt F x f ) /\
  ( (x <= 0)%R -> Rnd_UP_pt F x f ).

Definition Rnd_ZR (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_ZR_pt F x (rnd x).

Definition Rnd_N_pt (F : R -> Prop) (x f : R) :=
  F f /\
  forall g : R, F g -> (Rabs (f - x) <= Rabs (g - x))%R.

Definition Rnd_N (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_N_pt F x (rnd x).

Definition Rnd_NG_pt (F : R -> Prop) (P : R -> R -> Prop) (x f : R) :=
  Rnd_N_pt F x f /\
  ( P x f \/ forall f2 : R, Rnd_N_pt F x f2 -> f2 = f ).

Definition Rnd_NG (F : R -> Prop) (P : R -> R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_NG_pt F P x (rnd x).

Definition Rnd_NA_pt (F : R -> Prop) (x f : R) :=
  Rnd_N_pt F x f /\
  forall f2 : R, Rnd_N_pt F x f2 -> (Rabs f2 <= Rabs f)%R.

Definition Rnd_NA (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_NA_pt F x (rnd x).

End RND. *)

Require Import Fcore_rnd.
(* Fcore_rnd:
Require Import Fcore_Raux.
Require Import Fcore_defs.

Section RND_prop.

Open Scope R_scope.

Theorem round_val_of_pred :
  forall rnd : R -> R -> Prop,
  round_pred rnd ->
  forall x, { f : R | rnd x f }.

Theorem round_fun_of_pred :
  forall rnd : R -> R -> Prop,
  round_pred rnd ->
  { f : R -> R | forall x, rnd x (f x) }.

Theorem round_unicity :
  forall rnd : R -> R -> Prop,
  round_pred_monotone rnd ->
  forall x f1 f2,
  rnd x f1 ->
  rnd x f2 ->
  f1 = f2.

Theorem Rnd_DN_pt_monotone :
  forall F : R -> Prop,
  round_pred_monotone (Rnd_DN_pt F).

Theorem Rnd_DN_pt_unicity :
  forall F : R -> Prop,
  forall x f1 f2 : R,
  Rnd_DN_pt F x f1 -> Rnd_DN_pt F x f2 ->
  f1 = f2.

Theorem Rnd_DN_unicity :
  forall F : R -> Prop,
  forall rnd1 rnd2 : R -> R,
  Rnd_DN F rnd1 -> Rnd_DN F rnd2 ->
  forall x, rnd1 x = rnd2 x.

Theorem Rnd_UP_pt_monotone :
  forall F : R -> Prop,
  round_pred_monotone (Rnd_UP_pt F).

Theorem Rnd_UP_pt_unicity :
  forall F : R -> Prop,
  forall x f1 f2 : R,
  Rnd_UP_pt F x f1 -> Rnd_UP_pt F x f2 ->
  f1 = f2.

Theorem Rnd_UP_unicity :
  forall F : R -> Prop,
  forall rnd1 rnd2 : R -> R,
  Rnd_UP F rnd1 -> Rnd_UP F rnd2 ->
  forall x, rnd1 x = rnd2 x.

Theorem Rnd_DN_UP_pt_sym :
  forall F : R -> Prop,
  ( forall x, F x -> F (- x) ) ->
  forall x f : R,
  Rnd_DN_pt F x f -> Rnd_UP_pt F (-x) (-f).

Theorem Rnd_UP_DN_pt_sym :
  forall F : R -> Prop,
  ( forall x, F x -> F (- x) ) ->
  forall x f : R,
  Rnd_UP_pt F x f -> Rnd_DN_pt F (-x) (-f).

Theorem Rnd_DN_UP_sym :
  forall F : R -> Prop,
  ( forall x, F x -> F (- x) ) ->
  forall rnd1 rnd2 : R -> R,
  Rnd_DN F rnd1 -> Rnd_UP F rnd2 ->
  forall x, rnd1 (- x) = - rnd2 x.

Theorem Rnd_DN_UP_pt_split :
  forall F : R -> Prop,
  forall x d u,
  Rnd_DN_pt F x d ->
  Rnd_UP_pt F x u ->
  forall f, F f ->
  (f <= d) \/ (u <= f).

Theorem Rnd_DN_pt_refl :
  forall F : R -> Prop,
  forall x : R, F x ->
  Rnd_DN_pt F x x.

Theorem Rnd_DN_pt_idempotent :
  forall F : R -> Prop,
  forall x f : R,
  Rnd_DN_pt F x f -> F x ->
  f = x.

Theorem Rnd_UP_pt_refl :
  forall F : R -> Prop,
  forall x : R, F x ->
  Rnd_UP_pt F x x.

Theorem Rnd_UP_pt_idempotent :
  forall F : R -> Prop,
  forall x f : R,
  Rnd_UP_pt F x f -> F x ->
  f = x.

Theorem Only_DN_or_UP :
  forall F : R -> Prop,
  forall x fd fu f : R,
  Rnd_DN_pt F x fd -> Rnd_UP_pt F x fu ->
  F f -> (fd <= f <= fu)%R ->
  f = fd \/ f = fu.

Theorem Rnd_ZR_abs :
  forall (F : R -> Prop) (rnd: R-> R),
  Rnd_ZR F rnd ->
  forall x : R,  (Rabs (rnd x) <= Rabs x)%R.

Theorem Rnd_ZR_pt_monotone :
  forall F : R -> Prop, F 0 ->
  round_pred_monotone (Rnd_ZR_pt F).

Theorem Rnd_N_pt_DN_or_UP :
  forall F : R -> Prop,
  forall x f : R,
  Rnd_N_pt F x f ->
  Rnd_DN_pt F x f \/ Rnd_UP_pt F x f.

Theorem Rnd_N_pt_DN_or_UP_eq :
  forall F : R -> Prop,
  forall x fd fu f : R,
  Rnd_DN_pt F x fd -> Rnd_UP_pt F x fu ->
  Rnd_N_pt F x f ->
  f = fd \/ f = fu.

Theorem Rnd_N_pt_sym :
  forall F : R -> Prop,
  ( forall x, F x -> F (- x) ) ->
  forall x f : R,
  Rnd_N_pt F (-x) (-f) -> Rnd_N_pt F x f.

Theorem Rnd_N_pt_monotone :
  forall F : R -> Prop,
  forall x y f g : R,
  Rnd_N_pt F x f -> Rnd_N_pt F y g ->
  x < y -> f <= g.

Theorem Rnd_N_pt_unicity :
  forall F : R -> Prop,
  forall x d u f1 f2 : R,
  Rnd_DN_pt F x d ->
  Rnd_UP_pt F x u ->
  x - d <> u - x ->
  Rnd_N_pt F x f1 ->
  Rnd_N_pt F x f2 ->
  f1 = f2.

Theorem Rnd_N_pt_refl :
  forall F : R -> Prop,
  forall x : R, F x ->
  Rnd_N_pt F x x.

Theorem Rnd_N_pt_idempotent :
  forall F : R -> Prop,
  forall x f : R,
  Rnd_N_pt F x f -> F x ->
  f = x.

Theorem Rnd_N_pt_0 :
  forall F : R -> Prop,
  F 0 ->
  Rnd_N_pt F 0 0.

Theorem Rnd_N_pt_pos :
  forall F : R -> Prop, F 0 ->
  forall x f, 0 <= x ->
  Rnd_N_pt F x f ->
  0 <= f.

Theorem Rnd_N_pt_neg :
  forall F : R -> Prop, F 0 ->
  forall x f, x <= 0 ->
  Rnd_N_pt F x f ->
  f <= 0.

Theorem Rnd_N_pt_abs :
  forall F : R -> Prop,
  F 0 ->
  ( forall x, F x -> F (- x) ) ->
  forall x f : R,
  Rnd_N_pt F x f -> Rnd_N_pt F (Rabs x) (Rabs f).

Theorem Rnd_DN_UP_pt_N :
  forall F : R -> Prop,
  forall x d u f : R,
  F f ->
  Rnd_DN_pt F x d ->
  Rnd_UP_pt F x u ->
  (Rabs (f - x) <= x - d)%R ->
  (Rabs (f - x) <= u - x)%R ->
  Rnd_N_pt F x f.

Theorem Rnd_DN_pt_N :
  forall F : R -> Prop,
  forall x d u : R,
  Rnd_DN_pt F x d ->
  Rnd_UP_pt F x u ->
  (x - d <= u - x)%R ->
  Rnd_N_pt F x d.

Theorem Rnd_UP_pt_N :
  forall F : R -> Prop,
  forall x d u : R,
  Rnd_DN_pt F x d ->
  Rnd_UP_pt F x u ->
  (u - x <= x - d)%R ->
  Rnd_N_pt F x u.

Definition Rnd_NG_pt_unicity_prop F P :=
  forall x d u,
  Rnd_DN_pt F x d -> Rnd_N_pt F x d ->
  Rnd_UP_pt F x u -> Rnd_N_pt F x u ->
  P x d -> P x u -> d = u.

Theorem Rnd_NG_pt_unicity :
  forall (F : R -> Prop) (P : R -> R -> Prop),
  Rnd_NG_pt_unicity_prop F P ->
  forall x f1 f2 : R,
  Rnd_NG_pt F P x f1 -> Rnd_NG_pt F P x f2 ->
  f1 = f2.

Theorem Rnd_NG_pt_monotone :
  forall (F : R -> Prop) (P : R -> R -> Prop),
  Rnd_NG_pt_unicity_prop F P ->
  round_pred_monotone (Rnd_NG_pt F P).

Theorem Rnd_NG_pt_refl :
  forall (F : R -> Prop) (P : R -> R -> Prop),
  forall x, F x -> Rnd_NG_pt F P x x.

Theorem Rnd_NG_pt_sym :
  forall (F : R -> Prop) (P : R -> R -> Prop),
  ( forall x, F x -> F (-x) ) ->
  ( forall x f, P x f -> P (-x) (-f) ) ->
  forall x f : R,
  Rnd_NG_pt F P (-x) (-f) -> Rnd_NG_pt F P x f.

Theorem Rnd_NG_unicity :
  forall (F : R -> Prop) (P : R -> R -> Prop),
  Rnd_NG_pt_unicity_prop F P ->
  forall rnd1 rnd2 : R -> R,
  Rnd_NG F P rnd1 -> Rnd_NG F P rnd2 ->
  forall x, rnd1 x = rnd2 x.

Theorem Rnd_NA_NG_pt :
  forall F : R -> Prop,
  F 0 ->
  forall x f,
  Rnd_NA_pt F x f <-> Rnd_NG_pt F (fun x f => Rabs x <= Rabs f) x f.

Theorem Rnd_NA_pt_unicity_prop :
  forall F : R -> Prop,
  F 0 ->
  Rnd_NG_pt_unicity_prop F (fun a b => (Rabs a <= Rabs b)%R).

Theorem Rnd_NA_pt_unicity :
  forall F : R -> Prop,
  F 0 ->
  forall x f1 f2 : R,
  Rnd_NA_pt F x f1 -> Rnd_NA_pt F x f2 ->
  f1 = f2.

Theorem Rnd_NA_N_pt :
  forall F : R -> Prop,
  F 0 ->
  forall x f : R,
  Rnd_N_pt F x f ->
  (Rabs x <= Rabs f)%R ->
  Rnd_NA_pt F x f.

Theorem Rnd_NA_unicity :
  forall (F : R -> Prop),
  F 0 ->
  forall rnd1 rnd2 : R -> R,
  Rnd_NA F rnd1 -> Rnd_NA F rnd2 ->
  forall x, rnd1 x = rnd2 x.

Theorem Rnd_NA_pt_monotone :
  forall F : R -> Prop,
  F 0 ->
  round_pred_monotone (Rnd_NA_pt F).

Theorem Rnd_NA_pt_refl :
  forall F : R -> Prop,
  forall x : R, F x ->
  Rnd_NA_pt F x x.

Theorem Rnd_NA_pt_idempotent :
  forall F : R -> Prop,
  forall x f : R,
  Rnd_NA_pt F x f -> F x ->
  f = x.

Theorem round_pred_ge_0 :
  forall P : R -> R -> Prop,
  round_pred_monotone P ->
  P 0 0 ->
  forall x f, P x f -> 0 <= x -> 0 <= f.

Theorem round_pred_gt_0 :
  forall P : R -> R -> Prop,
  round_pred_monotone P ->
  P 0 0 ->
  forall x f, P x f -> 0 < f -> 0 < x.

Theorem round_pred_le_0 :
  forall P : R -> R -> Prop,
  round_pred_monotone P ->
  P 0 0 ->
  forall x f, P x f -> x <= 0 -> f <= 0.

Theorem round_pred_lt_0 :
  forall P : R -> R -> Prop,
  round_pred_monotone P ->
  P 0 0 ->
  forall x f, P x f -> f < 0 -> x < 0.

Theorem Rnd_DN_pt_equiv_format :
  forall F1 F2 : R -> Prop,
  forall a b : R,
  F1 a ->
  ( forall x, a <= x <= b -> (F1 x <-> F2 x) ) ->
  forall x f, a <= x <= b -> Rnd_DN_pt F1 x f -> Rnd_DN_pt F2 x f.

Theorem Rnd_UP_pt_equiv_format :
  forall F1 F2 : R -> Prop,
  forall a b : R,
  F1 b ->
  ( forall x, a <= x <= b -> (F1 x <-> F2 x) ) ->
  forall x f, a <= x <= b -> Rnd_UP_pt F1 x f -> Rnd_UP_pt F2 x f.

Inductive satisfies_any (F : R -> Prop) :=
  Satisfies_any :
    F 0 -> ( forall x : R, F x -> F (-x) ) ->
    round_pred_total (Rnd_DN_pt F) -> satisfies_any F.

Theorem satisfies_any_eq :
  forall F1 F2 : R -> Prop,
  ( forall x, F1 x <-> F2 x ) ->
  satisfies_any F1 ->
  satisfies_any F2.

Theorem satisfies_any_imp_DN :
  forall F : R -> Prop,
  satisfies_any F ->
  round_pred (Rnd_DN_pt F).

Theorem satisfies_any_imp_UP :
  forall F : R -> Prop,
  satisfies_any F ->
  round_pred (Rnd_UP_pt F).

Theorem satisfies_any_imp_ZR :
  forall F : R -> Prop,
  satisfies_any F ->
  round_pred (Rnd_ZR_pt F).

Definition NG_existence_prop (F : R -> Prop) (P : R -> R -> Prop) :=
  forall x d u, ~F x -> Rnd_DN_pt F x d -> Rnd_UP_pt F x u -> P x u \/ P x d.

Theorem satisfies_any_imp_NG :
  forall (F : R -> Prop) (P : R -> R -> Prop),
  satisfies_any F ->
  NG_existence_prop F P ->
  round_pred_total (Rnd_NG_pt F P).

Theorem satisfies_any_imp_NA :
  forall F : R -> Prop,
  satisfies_any F ->
  round_pred (Rnd_NA_pt F).

End RND_prop. *)

Require Import Fcore_generic_fmt.
(* Fcore_generic_fmt:
Require Import Fcore_Raux.
Require Import Fcore_defs.
Require Import Fcore_rnd.
Require Import Fcore_float_prop.

Section Generic.

Variable beta : radix.

Notation bpow e := (bpow beta e).

Section Format.

Variable fexp : Z -> Z.

Class Valid_exp :=
  valid_exp :
  forall k : Z,
  ( (fexp k < k)%Z -> (fexp (k + 1) <= k)%Z ) /\
  ( (k <= fexp k)%Z ->
    (fexp (fexp k + 1) <= fexp k)%Z /\
    forall l : Z, (l <= fexp k)%Z -> fexp l = fexp k ).

Context { valid_exp_ : Valid_exp }.

Theorem valid_exp_large :
  forall k l,
  (fexp k < k)%Z -> (k <= l)%Z ->
  (fexp l < l)%Z.

Theorem valid_exp_large' :
  forall k l,
  (fexp k < k)%Z -> (l <= k)%Z ->
  (fexp l < k)%Z.

Definition canonic_exp x :=
  fexp (ln_beta beta x).

Definition canonic (f : float beta) :=
  Fexp f = canonic_exp (F2R f).

Definition scaled_mantissa x :=
  (x * bpow (- canonic_exp x))%R.

Definition generic_format (x : R) :=
  x = F2R (Float beta (Ztrunc (scaled_mantissa x)) (canonic_exp x)).

Theorem generic_format_0 :
  generic_format 0.

Theorem canonic_exp_opp :
  forall x,
  canonic_exp (-x) = canonic_exp x.

Theorem canonic_exp_abs :
  forall x,
  canonic_exp (Rabs x) = canonic_exp x.

Theorem generic_format_bpow :
  forall e, (fexp (e + 1) <= e)%Z ->
  generic_format (bpow e).

Theorem generic_format_bpow' :
  forall e, (fexp e <= e)%Z ->
  generic_format (bpow e).

Theorem generic_format_F2R :
  forall m e,
  ( m <> 0 -> canonic_exp (F2R (Float beta m e)) <= e )%Z ->
  generic_format (F2R (Float beta m e)).

Lemma generic_format_F2R': forall (x:R) (f:float beta),
       F2R f = x -> ((x <> 0)%R ->
       (canonic_exp x <= Fexp f)%Z) ->
       generic_format x.

Theorem canonic_opp :
  forall m e,
  canonic (Float beta m e) ->
  canonic (Float beta (-m) e).

Theorem canonic_abs :
  forall m e,
  canonic (Float beta m e) ->
  canonic (Float beta (Zabs m) e).

Theorem canonic_0: canonic (Float beta 0 (fexp (ln_beta beta 0%R))).

Theorem canonic_unicity :
  forall f1 f2,
  canonic f1 ->
  canonic f2 ->
  F2R f1 = F2R f2 ->
  f1 = f2.

Theorem scaled_mantissa_generic :
  forall x,
  generic_format x ->
  scaled_mantissa x = Z2R (Ztrunc (scaled_mantissa x)).

Theorem scaled_mantissa_mult_bpow :
  forall x,
  (scaled_mantissa x * bpow (canonic_exp x))%R = x.

Theorem scaled_mantissa_0 :
  scaled_mantissa 0 = 0%R.

Theorem scaled_mantissa_opp :
  forall x,
  scaled_mantissa (-x) = (-scaled_mantissa x)%R.

Theorem scaled_mantissa_abs :
  forall x,
  scaled_mantissa (Rabs x) = Rabs (scaled_mantissa x).

Theorem generic_format_opp :
  forall x, generic_format x -> generic_format (-x).

Theorem generic_format_abs :
  forall x, generic_format x -> generic_format (Rabs x).

Theorem generic_format_abs_inv :
  forall x, generic_format (Rabs x) -> generic_format x.

Theorem canonic_exp_fexp :
  forall x ex,
  (bpow (ex - 1) <= Rabs x < bpow ex)%R ->
  canonic_exp x = fexp ex.

Theorem canonic_exp_fexp_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  canonic_exp x = fexp ex.

Theorem mantissa_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  (0 < x * bpow (- fexp ex) < 1)%R.

Theorem scaled_mantissa_small :
  forall x ex,
  (Rabs x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  (Rabs (scaled_mantissa x) < 1)%R.

Theorem abs_scaled_mantissa_lt_bpow :
  forall x,
  (Rabs (scaled_mantissa x) < bpow (ln_beta beta x - canonic_exp x))%R.

Theorem ln_beta_generic_gt :
  forall x, (x <> 0)%R ->
  generic_format x ->
  (canonic_exp x < ln_beta beta x)%Z.

Theorem mantissa_DN_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  Zfloor (x * bpow (- fexp ex)) = Z0.

Theorem mantissa_UP_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  Zceil (x * bpow (- fexp ex)) = 1%Z.

Theorem generic_format_discrete :
  forall x m,
  let e := canonic_exp x in
  (F2R (Float beta m e) < x < F2R (Float beta (m + 1) e))%R ->
  ~ generic_format x.

Theorem generic_format_canonic :
  forall f, canonic f ->
  generic_format (F2R f).

Theorem generic_format_ge_bpow :
  forall emin,
  ( forall e, (emin <= fexp e)%Z ) ->
  forall x,
  (0 < x)%R ->
  generic_format x ->
  (bpow emin <= x)%R.

Theorem abs_lt_bpow_prec:
  forall prec,
  (forall e, (e - prec <= fexp e)%Z) ->
  
  forall x,
  (Rabs x < bpow (prec + canonic_exp x))%R.

Theorem generic_format_bpow_inv' :
  forall e,
  generic_format (bpow e) ->
  (fexp (e + 1) <= e)%Z.

Theorem generic_format_bpow_inv :
  forall e,
  generic_format (bpow e) ->
  (fexp e <= e)%Z.

Section Fcore_generic_round_pos.

Variable rnd : R -> Z.

Class Valid_rnd := {
  Zrnd_le : forall x y, (x <= y)%R -> (rnd x <= rnd y)%Z ;
  Zrnd_Z2R : forall n, rnd (Z2R n) = n
}.

Context { valid_rnd : Valid_rnd }.

Theorem Zrnd_DN_or_UP :
  forall x, rnd x = Zfloor x \/ rnd x = Zceil x.

Theorem Zrnd_ZR_or_AW :
  forall x, rnd x = Ztrunc x \/ rnd x = Zaway x.

Definition round x :=
  F2R (Float beta (rnd (scaled_mantissa x)) (canonic_exp x)).

Theorem round_bounded_large_pos :
  forall x ex,
  (fexp ex < ex)%Z ->
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (bpow (ex - 1) <= round x <= bpow ex)%R.

Theorem round_bounded_small_pos :
  forall x ex,
  (ex <= fexp ex)%Z ->
  (bpow (ex - 1) <= x < bpow ex)%R ->
  round x = 0%R \/ round x = bpow (fexp ex).

Theorem round_le_pos :
  forall x y, (0 < x)%R -> (x <= y)%R -> (round x <= round y)%R.

Theorem round_generic :
  forall x,
  generic_format x ->
  round x = x.

Theorem round_0 :
  round 0 = 0%R.

Theorem exp_small_round_0_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  round x = 0%R -> (ex <= fexp ex)%Z .

Theorem generic_format_round_pos :
  forall x,
  (0 < x)%R ->
  generic_format (round x).

End Fcore_generic_round_pos.

Theorem round_ext :
  forall rnd1 rnd2,
  ( forall x, rnd1 x = rnd2 x ) ->
  forall x,
  round rnd1 x = round rnd2 x.

Section Zround_opp.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Definition Zrnd_opp x := Zopp (rnd (-x)).

Global Instance valid_rnd_opp : Valid_rnd Zrnd_opp.

Theorem round_opp :
  forall x,
  round rnd (- x) = Ropp (round Zrnd_opp x).

End Zround_opp.

Global Instance valid_rnd_DN : Valid_rnd Zfloor.

Global Instance valid_rnd_UP : Valid_rnd Zceil.

Global Instance valid_rnd_ZR : Valid_rnd Ztrunc.

Global Instance valid_rnd_AW : Valid_rnd Zaway.

Section monotone.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem round_DN_or_UP :
  forall x,
  round rnd x = round Zfloor x \/ round rnd x = round Zceil x.

Theorem round_ZR_or_AW :
  forall x,
  round rnd x = round Ztrunc x \/ round rnd x = round Zaway x.

Theorem round_le :
  forall x y, (x <= y)%R -> (round rnd x <= round rnd y)%R.

Theorem round_ge_generic :
  forall x y, generic_format x -> (x <= y)%R -> (x <= round rnd y)%R.

Theorem round_le_generic :
  forall x y, generic_format y -> (x <= y)%R -> (round rnd x <= y)%R.

End monotone.

Theorem round_abs_abs :
  forall P : R -> R -> Prop,
  ( forall rnd (Hr : Valid_rnd rnd) x, (0 <= x)%R -> P x (round rnd x) ) ->
  forall rnd {Hr : Valid_rnd rnd} x, P (Rabs x) (Rabs (round rnd x)).

Theorem round_bounded_large :
  forall rnd {Hr : Valid_rnd rnd} x ex,
  (fexp ex < ex)%Z ->
  (bpow (ex - 1) <= Rabs x < bpow ex)%R ->
  (bpow (ex - 1) <= Rabs (round rnd x) <= bpow ex)%R.

Theorem exp_small_round_0 :
  forall rnd {Hr : Valid_rnd rnd} x ex,
  (bpow (ex - 1) <= Rabs x < bpow ex)%R ->
   round rnd x = 0%R -> (ex <= fexp ex)%Z .

Section monotone_abs.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem abs_round_ge_generic :
  forall x y, generic_format x -> (x <= Rabs y)%R -> (x <= Rabs (round rnd y))%R.

Theorem abs_round_le_generic :
  forall x y, generic_format y -> (Rabs x <= y)%R -> (Rabs (round rnd x) <= y)%R.

End monotone_abs.

Theorem round_DN_opp :
  forall x,
  round Zfloor (-x) = (- round Zceil x)%R.

Theorem round_UP_opp :
  forall x,
  round Zceil (-x) = (- round Zfloor x)%R.

Theorem round_ZR_opp :
  forall x,
  round Ztrunc (- x) = Ropp (round Ztrunc x).

Theorem round_ZR_abs :
  forall x,
  round Ztrunc (Rabs x) = Rabs (round Ztrunc x).

Theorem round_AW_opp :
  forall x,
  round Zaway (- x) = Ropp (round Zaway x).

Theorem round_AW_abs :
  forall x,
  round Zaway (Rabs x) = Rabs (round Zaway x).

Theorem round_ZR_pos :
  forall x,
  (0 <= x)%R ->
  round Ztrunc x = round Zfloor x.

Theorem round_ZR_neg :
  forall x,
  (x <= 0)%R ->
  round Ztrunc x = round Zceil x.

Theorem round_AW_pos :
  forall x,
  (0 <= x)%R ->
  round Zaway x = round Zceil x.

Theorem round_AW_neg :
  forall x,
  (x <= 0)%R ->
  round Zaway x = round Zfloor x.

Theorem generic_format_round :
  forall rnd { Hr : Valid_rnd rnd } x,
  generic_format (round rnd x).

Theorem round_DN_pt :
  forall x,
  Rnd_DN_pt generic_format x (round Zfloor x).

Theorem generic_format_satisfies_any :
  satisfies_any generic_format.

Theorem round_UP_pt :
  forall x,
  Rnd_UP_pt generic_format x (round Zceil x).

Theorem round_ZR_pt :
  forall x,
  Rnd_ZR_pt generic_format x (round Ztrunc x).

Theorem round_DN_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  round Zfloor x = 0%R.

Theorem round_DN_UP_lt :
  forall x, ~ generic_format x ->
  (round Zfloor x < x < round Zceil x)%R.

Theorem round_UP_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  round Zceil x = (bpow (fexp ex)).

Theorem generic_format_EM :
  forall x,
  generic_format x \/ ~generic_format x.

Section round_large.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem round_large_pos_ge_pow :
  forall x e,
  (0 < round rnd x)%R ->
  (bpow e <= x)%R ->
  (bpow e <= round rnd x)%R.

End round_large.

Theorem ln_beta_round_ZR :
  forall x,
  (round Ztrunc x <> 0)%R ->
  (ln_beta beta (round Ztrunc x) = ln_beta beta x :> Z).

Theorem ln_beta_round :
  forall rnd {Hrnd : Valid_rnd rnd} x,
  (round rnd x <> 0)%R ->
  (ln_beta beta (round rnd x) = ln_beta beta x :> Z) \/
  Rabs (round rnd x) = bpow (Zmax (ln_beta beta x) (fexp (ln_beta beta x))).

Theorem ln_beta_DN :
  forall x,
  (0 < round Zfloor x)%R ->
  (ln_beta beta (round Zfloor x) = ln_beta beta x :> Z).

Theorem canonic_exp_DN :
  forall x,
  (0 < round Zfloor x)%R ->
  canonic_exp (round Zfloor x) = canonic_exp x.

Theorem scaled_mantissa_DN :
  forall x,
  (0 < round Zfloor x)%R ->
  scaled_mantissa (round Zfloor x) = Z2R (Zfloor (scaled_mantissa x)).

Theorem generic_N_pt_DN_or_UP :
  forall x f,
  Rnd_N_pt generic_format x f ->
  f = round Zfloor x \/ f = round Zceil x.

Section not_FTZ.

Class Exp_not_FTZ :=
  exp_not_FTZ : forall e, (fexp (fexp e + 1) <= fexp e)%Z.

Context { exp_not_FTZ_ : Exp_not_FTZ }.

Theorem subnormal_exponent :
  forall e x,
  (e <= fexp e)%Z ->
  generic_format x ->
  x = F2R (Float beta (Ztrunc (x * bpow (- fexp e))) (fexp e)).

End not_FTZ.

Section monotone_exp.

Class Monotone_exp :=
  monotone_exp : forall ex ey, (ex <= ey)%Z -> (fexp ex <= fexp ey)%Z.

Context { monotone_exp_ : Monotone_exp }.

Global Instance monotone_exp_not_FTZ : Exp_not_FTZ.

Lemma canonic_exp_le_bpow :
  forall (x : R) (e : Z),
  x <> 0%R ->
  (Rabs x < bpow e)%R ->
  (canonic_exp x <= fexp e)%Z.

Lemma canonic_exp_ge_bpow :
  forall (x : R) (e : Z),
  (bpow (e - 1) <= Rabs x)%R ->
  (fexp e <= canonic_exp x)%Z.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem ln_beta_round_ge :
  forall x,
  round rnd x <> 0%R ->
  (ln_beta beta x <= ln_beta beta (round rnd x))%Z.

Theorem canonic_exp_round_ge :
  forall x,
  round rnd x <> 0%R ->
  (canonic_exp x <= canonic_exp (round rnd x))%Z.

End monotone_exp.

Section Znearest.

Variable choice : Z -> bool.

Definition Znearest x :=
  match Rcompare (x - Z2R (Zfloor x)) (/2) with
  | Lt => Zfloor x
  | Eq => if choice (Zfloor x) then Zceil x else Zfloor x
  | Gt => Zceil x
  end.

Theorem Znearest_DN_or_UP :
  forall x,
  Znearest x = Zfloor x \/ Znearest x = Zceil x.

Theorem Znearest_ge_floor :
  forall x,
  (Zfloor x <= Znearest x)%Z.

Theorem Znearest_le_ceil :
  forall x,
  (Znearest x <= Zceil x)%Z.

Global Instance valid_rnd_N : Valid_rnd Znearest.

Theorem Rcompare_floor_ceil_mid :
  forall x,
  Z2R (Zfloor x) <> x ->
  Rcompare (x - Z2R (Zfloor x)) (/ 2) = Rcompare (x - Z2R (Zfloor x)) (Z2R (Zceil x) - x).

Theorem Rcompare_ceil_floor_mid :
  forall x,
  Z2R (Zfloor x) <> x ->
  Rcompare (Z2R (Zceil x) - x) (/ 2) = Rcompare (Z2R (Zceil x) - x) (x - Z2R (Zfloor x)).

Theorem Znearest_N_strict :
  forall x,
  (x - Z2R (Zfloor x) <> /2)%R ->
  (Rabs (x - Z2R (Znearest x)) < /2)%R.

Theorem Znearest_N :
  forall x,
  (Rabs (x - Z2R (Znearest x)) <= /2)%R.

Theorem Znearest_imp :
  forall x n,
  (Rabs (x - Z2R n) < /2)%R ->
  Znearest x = n.

Theorem round_N_pt :
  forall x,
  Rnd_N_pt generic_format x (round Znearest x).

Theorem round_N_middle :
  forall x,
  (x - round Zfloor x = round Zceil x - x)%R ->
  round Znearest x = if choice (Zfloor (scaled_mantissa x)) then round Zceil x else round Zfloor x.

Lemma round_N_really_small_pos :
  forall x,
  forall ex,
  (Fcore_Raux.bpow beta (ex - 1) <= x < Fcore_Raux.bpow beta ex)%R ->

End Znearest.

Section rndNA.

Global Instance valid_rnd_NA : Valid_rnd (Znearest (Zle_bool 0)) := valid_rnd_N _.

Theorem round_NA_pt :
  forall x,
  Rnd_NA_pt generic_format x (round (Znearest (Zle_bool 0)) x).

End rndNA.

Section rndN_opp.

Theorem Znearest_opp :
  forall choice x,
  Znearest choice (- x) = (- Znearest (fun t => negb (choice (- (t + 1))%Z)) x)%Z.

Theorem round_N_opp :
  forall choice,
  forall x,
  round (Znearest choice) (-x) = (- round (Znearest (fun t => negb (choice (- (t + 1))%Z))) x)%R.

End rndN_opp.

End Format.

Section Inclusion.

Variables fexp1 fexp2 : Z -> Z.

Context { valid_exp1 : Valid_exp fexp1 }.
Context { valid_exp2 : Valid_exp fexp2 }.

Theorem generic_inclusion_ln_beta :
  forall x,
  ( x <> R0 -> (fexp2 (ln_beta beta x) <= fexp1 (ln_beta beta x))%Z ) ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_lt_ge :
  forall e1 e2,
  ( forall e, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (bpow e1 <= Rabs x < bpow e2)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion :
  forall e,
  (fexp2 e <= fexp1 e)%Z ->
  forall x,
  (bpow (e - 1) <= Rabs x <= bpow e)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_le_ge :
  forall e1 e2,
  (e1 < e2)%Z ->
  ( forall e, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (bpow e1 <= Rabs x <= bpow e2)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_le :
  forall e2,
  ( forall e, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (Rabs x <= bpow e2)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_ge :
  forall e1,
  ( forall e, (e1 < e)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (bpow e1 <= Rabs x)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem generic_round_generic :
  forall x,
  generic_format fexp1 x ->
  generic_format fexp1 (round fexp2 rnd x).

End Inclusion.

End Generic.

Notation ZnearestA := (Znearest (Zle_bool 0)).

Section rndNA_opp.

Lemma round_NA_opp :
  forall beta : radix,
  forall (fexp : Z -> Z),
  forall x,
  (round beta fexp ZnearestA (- x) = - round beta fexp ZnearestA x)%R.

End rndNA_opp.

Notation rndDN := Zfloor (only parsing).
Notation rndUP := Zceil (only parsing).
Notation rndZR := Ztrunc (only parsing).
Notation rndNA := ZnearestA (only parsing). *)

Require Import Fcore_float_prop.
(* Fcore_float_prop:
Require Import Fcore_Raux.
Require Import Fcore_defs.

Section Float_prop.

Variable beta : radix.

Notation bpow e := (bpow beta e).

Theorem Rcompare_F2R :
  forall e m1 m2 : Z,
  Rcompare (F2R (Float beta m1 e)) (F2R (Float beta m2 e)) = Zcompare m1 m2.

Theorem F2R_le_reg :
  forall e m1 m2 : Z,
  (F2R (Float beta m1 e) <= F2R (Float beta m2 e))%R ->
  (m1 <= m2)%Z.

Theorem F2R_le_compat :
  forall m1 m2 e : Z,
  (m1 <= m2)%Z ->
  (F2R (Float beta m1 e) <= F2R (Float beta m2 e))%R.

Theorem F2R_lt_reg :
  forall e m1 m2 : Z,
  (F2R (Float beta m1 e) < F2R (Float beta m2 e))%R ->
  (m1 < m2)%Z.

Theorem F2R_lt_compat :
  forall e m1 m2 : Z,
  (m1 < m2)%Z ->
  (F2R (Float beta m1 e) < F2R (Float beta m2 e))%R.

Theorem F2R_eq_compat :
  forall e m1 m2 : Z,
  (m1 = m2)%Z ->
  (F2R (Float beta m1 e) = F2R (Float beta m2 e))%R.

Theorem F2R_eq_reg :
  forall e m1 m2 : Z,
  F2R (Float beta m1 e) = F2R (Float beta m2 e) ->
  m1 = m2.

Theorem F2R_Zabs:
  forall m e : Z,
   F2R (Float beta (Zabs m) e) = Rabs (F2R (Float beta m e)).

Theorem F2R_Zopp :
  forall m e : Z,
  F2R (Float beta (Zopp m) e) = Ropp (F2R (Float beta m e)).

Theorem F2R_0 :
  forall e : Z,
  F2R (Float beta 0 e) = 0%R.

Theorem F2R_eq_0_reg :
  forall m e : Z,
  F2R (Float beta m e) = 0%R ->
  m = Z0.

Theorem F2R_ge_0_reg :
  forall m e : Z,
  (0 <= F2R (Float beta m e))%R ->
  (0 <= m)%Z.

Theorem F2R_le_0_reg :
  forall m e : Z,
  (F2R (Float beta m e) <= 0)%R ->
  (m <= 0)%Z.

Theorem F2R_gt_0_reg :
  forall m e : Z,
  (0 < F2R (Float beta m e))%R ->
  (0 < m)%Z.

Theorem F2R_lt_0_reg :
  forall m e : Z,
  (F2R (Float beta m e) < 0)%R ->
  (m < 0)%Z.

Theorem F2R_ge_0_compat :
  forall f : float beta,
  (0 <= Fnum f)%Z ->
  (0 <= F2R f)%R.

Theorem F2R_le_0_compat :
  forall f : float beta,
  (Fnum f <= 0)%Z ->
  (F2R f <= 0)%R.

Theorem F2R_gt_0_compat :
  forall f : float beta,
  (0 < Fnum f)%Z ->
  (0 < F2R f)%R.

Theorem F2R_lt_0_compat :
  forall f : float beta,
  (Fnum f < 0)%Z ->
  (F2R f < 0)%R.

Theorem F2R_neq_0_compat :
 forall f : float beta,
  (Fnum f <> 0)%Z ->
  (F2R f <> 0)%R.

Lemma Fnum_ge_0_compat: forall (f : float beta),
  (0 <= F2R f)%R -> (0 <= Fnum f)%Z.

Lemma Fnum_le_0_compat: forall (f : float beta),
  (F2R f <= 0)%R -> (Fnum f <= 0)%Z.

Theorem F2R_bpow :
  forall e : Z,
  F2R (Float beta 1 e) = bpow e.

Theorem bpow_le_F2R :
  forall m e : Z,
  (0 < m)%Z ->
  (bpow e <= F2R (Float beta m e))%R.

Theorem F2R_p1_le_bpow :
  forall m e1 e2 : Z,
  (0 < m)%Z ->
  (F2R (Float beta m e1) < bpow e2)%R ->
  (F2R (Float beta (m + 1) e1) <= bpow e2)%R.

Theorem bpow_le_F2R_m1 :
  forall m e1 e2 : Z,
  (1 < m)%Z ->
  (bpow e2 < F2R (Float beta m e1))%R ->
  (bpow e2 <= F2R (Float beta (m - 1) e1))%R.

Theorem F2R_lt_bpow :
  forall f : float beta, forall e',
  (Zabs (Fnum f) < Zpower beta (e' - Fexp f))%Z ->
  (Rabs (F2R f) < bpow e')%R.

Theorem F2R_change_exp :
  forall e' m e : Z,
  (e' <= e)%Z ->
  F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e')) e').

Theorem F2R_prec_normalize :
  forall m e e' p : Z,
  (Zabs m < Zpower beta p)%Z ->
  (bpow (e' - 1)%Z <= Rabs (F2R (Float beta m e)))%R ->
  F2R (Float beta m e) = F2R (Float beta (m * Zpower beta (e - e' + p)) (e' - p)).

Theorem ln_beta_F2R_bounds :
  forall x m e, (0 < m)%Z ->
  (F2R (Float beta m e) <= x < F2R (Float beta (m + 1) e))%R ->
  ln_beta beta x = ln_beta beta (F2R (Float beta m e)) :> Z.

Theorem ln_beta_F2R :
  forall m e : Z,
  m <> Z0 ->
  (ln_beta beta (F2R (Float beta m e)) = ln_beta beta (Z2R m) + e :> Z)%Z.

Theorem float_distribution_pos :
  forall m1 e1 m2 e2 : Z,
  (0 < m1)%Z ->
  (F2R (Float beta m1 e1) < F2R (Float beta m2 e2) < F2R (Float beta (m1 + 1) e1))%R ->
  (e2 < e1)%Z /\ (e1 + ln_beta beta (Z2R m1) = e2 + ln_beta beta (Z2R m2))%Z.

Theorem F2R_cond_Zopp :
  forall b m e,
  F2R (Float beta (cond_Zopp b m) e) = cond_Ropp b (F2R (Float beta m e)).

End Float_prop. *)



Section Fcore_ulp.



Variable beta : radix.



Notation bpow e := (bpow beta e).



Variable fexp : Z -> Z.



Lemma Z_le_dec_aux: forall x y : Z, (x <= y)%Z \/ ~ (x <= y)%Z.

Proof.

intros.

destruct (Z_le_dec x y).

now left.

now right.

Qed.



Definition negligible_exp: option Z :=

  match (LPO_Z _ (fun z => Z_le_dec_aux z (fexp z))) with

   | inleft N => Some (proj1_sig N)

   | inright _ => None

 end.



Inductive negligible_exp_prop: option Z -> Prop :=

  | negligible_None: (forall n, (fexp n < n)%Z) -> negligible_exp_prop None

  | negligible_Some: forall n, (n <= fexp n)%Z -> negligible_exp_prop (Some n).



Lemma negligible_exp_spec: negligible_exp_prop negligible_exp.

Proof.

unfold negligible_exp; destruct LPO_Z as [(n,Hn)|Hn].

now apply negligible_Some.

apply negligible_None.

intros n; specialize (Hn n); omega.

Qed.



Lemma negligible_exp_spec': (negligible_exp = None /\ forall n, (fexp n < n)%Z)

           \/ exists n, (negligible_exp = Some n /\ (n <= fexp n)%Z).

Proof.

unfold negligible_exp; destruct LPO_Z as [(n,Hn)|Hn].

right; simpl; exists n; now split.

left; split; trivial.

intros n; specialize (Hn n); omega.

Qed.



Context { valid_exp : Valid_exp fexp }.



Lemma fexp_negligible_exp_eq: forall n m, (n <= fexp n)%Z -> (m <= fexp m)%Z -> fexp n = fexp m.

Proof.

intros n m Hn Hm.

case (Zle_or_lt n m); intros H.

apply valid_exp; omega.

apply sym_eq, valid_exp; omega.

Qed.



Definition ulp x := match Req_bool x 0 with

  | true   => match negligible_exp with

            | Some n => bpow (fexp n)

            | None => 0%R

            end

  | false  => bpow (canonic_exp beta fexp x)

 end.



Lemma ulp_neq_0 : forall x:R, (x <> 0)%R -> ulp x = bpow (canonic_exp beta fexp x).

Proof.

intros  x Hx.

unfold ulp; case (Req_bool_spec x); trivial.

intros H; now contradict H.

Qed.



Notation F := (generic_format beta fexp).



Theorem ulp_opp :

  forall x, ulp (- x) = ulp x.

Proof.

intros x.

unfold ulp.

case Req_bool_spec; intros H1.

rewrite Req_bool_true; trivial.

rewrite <- (Ropp_involutive x), H1; ring.

rewrite Req_bool_false.

now rewrite canonic_exp_opp.

intros H2; apply H1; rewrite H2; ring.

Qed.



Theorem ulp_abs :

  forall x, ulp (Rabs x) = ulp x.

Proof.

intros x.

unfold ulp; case (Req_bool_spec x 0); intros H1.

rewrite Req_bool_true; trivial.

now rewrite H1, Rabs_R0.

rewrite Req_bool_false.

now rewrite canonic_exp_abs.

now apply Rabs_no_R0.

Qed.



Theorem ulp_ge_0:

  forall x, (0 <= ulp x)%R.

Proof.

intros x; unfold ulp; case Req_bool_spec; intros.

case negligible_exp; intros.

apply bpow_ge_0.

apply Rle_refl.

apply bpow_ge_0.

Qed.



Theorem ulp_le_id:

  forall x,

    (0 < x)%R ->

    F x ->

    (ulp x <= x)%R.

Proof.

intros x Zx Fx.

rewrite <- (Rmult_1_l (ulp x)).

pattern x at 2; rewrite Fx.

rewrite ulp_neq_0.

2: now apply Rgt_not_eq.

unfold F2R; simpl.

apply Rmult_le_compat_r.

apply bpow_ge_0.

apply (Z2R_le (Zsucc 0)).

apply Zlt_le_succ.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

now rewrite <- Fx.

Qed.



Theorem ulp_le_abs:

  forall x,

    (x <> 0)%R ->

    F x ->

    (ulp x <= Rabs x)%R.

Proof.

intros x Zx Fx.

rewrite <- ulp_abs.

apply ulp_le_id.

now apply Rabs_pos_lt.

now apply generic_format_abs.

Qed.



Theorem round_UP_DN_ulp :

  forall x, ~ F x ->

  round beta fexp Zceil x = (round beta fexp Zfloor x + ulp x)%R.

Proof.

intros x Fx.

rewrite ulp_neq_0.

unfold round. simpl.

unfold F2R. simpl.

rewrite Zceil_floor_neq.

rewrite Z2R_plus. simpl.

ring.

intros H.

apply Fx.

unfold generic_format, F2R. simpl.

rewrite <- H.

rewrite Ztrunc_Z2R.

rewrite H.

now rewrite scaled_mantissa_mult_bpow.

intros V; apply Fx.

rewrite V.

apply generic_format_0.

Qed.



Theorem ulp_bpow :

  forall e, ulp (bpow e) = bpow (fexp (e + 1)).

Proof.

intros e.

rewrite ulp_neq_0.

apply f_equal.

apply canonic_exp_fexp.

rewrite Rabs_pos_eq.

split.

ring_simplify (e + 1 - 1)%Z.

apply Rle_refl.

apply bpow_lt.

apply Zlt_succ.

apply bpow_ge_0.

apply Rgt_not_eq, Rlt_gt, bpow_gt_0.

Qed.



Lemma generic_format_ulp_0:

  F (ulp 0).

Proof.

unfold ulp.

rewrite Req_bool_true; trivial.

case negligible_exp_spec.

intros _; apply generic_format_0.

intros n H1.

apply generic_format_bpow.

now apply valid_exp.

Qed.



Lemma generic_format_bpow_ge_ulp_0:  forall e,

    (ulp 0 <= bpow e)%R -> F (bpow e).

Proof.

intros e; unfold ulp.

rewrite Req_bool_true; trivial.

case negligible_exp_spec.

intros H1 _.

apply generic_format_bpow.

specialize (H1 (e+1)%Z); omega.

intros n H1 H2.

apply generic_format_bpow.

case (Zle_or_lt (e+1) (fexp (e+1))); intros H4.

absurd (e+1 <= e)%Z.

omega.

apply Zle_trans with (1:=H4).

replace (fexp (e+1)) with (fexp n).

now apply le_bpow with beta.

now apply fexp_negligible_exp_eq.

omega.

Qed.



Lemma generic_format_ulp: Exp_not_FTZ fexp ->

  forall x,  F (ulp x).

Proof.

unfold Exp_not_FTZ; intros H x.

case (Req_dec x 0); intros Hx.

rewrite Hx; apply generic_format_ulp_0.

rewrite (ulp_neq_0 _ Hx).

apply generic_format_bpow; unfold canonic_exp.

apply H.

Qed.



Lemma not_FTZ_generic_format_ulp:

   (forall x,  F (ulp x)) -> Exp_not_FTZ fexp.

Proof.

intros H e.

specialize (H (bpow (e-1))).

rewrite ulp_neq_0 in H.

2: apply Rgt_not_eq, bpow_gt_0.

unfold canonic_exp in H.

rewrite ln_beta_bpow in H.

apply generic_format_bpow_inv' in H...

now replace (e-1+1)%Z with e in H by ring.

Qed.



Lemma ulp_ge_ulp_0: Exp_not_FTZ fexp ->

  forall x,  (ulp 0 <= ulp x)%R.

Proof.

unfold Exp_not_FTZ; intros H x.

case (Req_dec x 0); intros Hx.

rewrite Hx; now right.

unfold ulp at 1.

rewrite Req_bool_true; trivial.

case negligible_exp_spec'.

intros (H1,H2); rewrite H1; apply ulp_ge_0.

intros (n,(H1,H2)); rewrite H1.

rewrite ulp_neq_0; trivial.

apply bpow_le; unfold canonic_exp.

generalize (ln_beta beta x); intros l.

case (Zle_or_lt l (fexp l)); intros Hl.

rewrite (fexp_negligible_exp_eq n l); trivial; apply Zle_refl.

case (Zle_or_lt (fexp n) (fexp l)); trivial; intros K.

absurd (fexp n <= fexp l)%Z.

omega.

apply Zle_trans with (2:= H _).

apply Zeq_le, sym_eq, valid_exp; trivial.

omega.

Qed.



Lemma not_FTZ_ulp_ge_ulp_0:

   (forall x,  (ulp 0 <= ulp x)%R) -> Exp_not_FTZ fexp.

Proof.

intros H e.

apply generic_format_bpow_inv' with beta.

apply generic_format_bpow_ge_ulp_0.

replace e with ((e-1)+1)%Z by ring.

rewrite <- ulp_bpow.

apply H.

Qed.



Theorem ulp_le_pos :

  forall { Hm : Monotone_exp fexp },

  forall x y: R,

  (0 <= x)%R -> (x <= y)%R ->

  (ulp x <= ulp y)%R.

Proof with auto with typeclass_instances.

intros Hm x y Hx Hxy.

destruct Hx as [Hx|Hx].

rewrite ulp_neq_0.

rewrite ulp_neq_0.

apply bpow_le.

apply Hm.

now apply ln_beta_le.

apply Rgt_not_eq, Rlt_gt.

now apply Rlt_le_trans with (1:=Hx).

now apply Rgt_not_eq.

rewrite <- Hx.

apply ulp_ge_ulp_0.

apply monotone_exp_not_FTZ...

Qed.



Theorem ulp_le :

  forall { Hm : Monotone_exp fexp },

  forall x y: R,

  (Rabs x <= Rabs y)%R ->

  (ulp x <= ulp y)%R.

Proof.

intros Hm x y Hxy.

rewrite <- ulp_abs.

rewrite <- (ulp_abs y).

apply ulp_le_pos; trivial.

apply Rabs_pos.

Qed.



Definition pred_pos x :=

  if Req_bool x (bpow (ln_beta beta x - 1)) then

    (x - bpow (fexp (ln_beta beta x - 1)))%R

  else

    (x - ulp x)%R.



Definition succ x :=

   if (Rle_bool 0 x) then

          (x+ulp x)%R

   else

     (- pred_pos (-x))%R.



Definition pred x := (- succ (-x))%R.



Theorem pred_eq_pos:

  forall x, (0 <= x)%R -> (pred x = pred_pos x)%R.

Proof.

intros x Hx; unfold pred, succ.

case Rle_bool_spec; intros Hx'.

assert (K:(x = 0)%R).

apply Rle_antisym; try assumption.

apply Ropp_le_cancel.

now rewrite Ropp_0.

rewrite K; unfold pred_pos.

rewrite Req_bool_false.

2: apply Rlt_not_eq, bpow_gt_0.

rewrite Ropp_0; ring.

now rewrite 2!Ropp_involutive.

Qed.



Theorem succ_eq_pos:

  forall x, (0 <= x)%R -> (succ x = x + ulp x)%R.

Proof.

intros x Hx; unfold succ.

now rewrite Rle_bool_true.

Qed.



Lemma pred_eq_opp_succ_opp: forall x, pred x = (- succ (-x))%R.

Proof.

reflexivity.

Qed.



Lemma succ_eq_opp_pred_opp: forall x, succ x = (- pred (-x))%R.

Proof.

intros x; unfold pred.

now rewrite 2!Ropp_involutive.

Qed.



Lemma succ_opp: forall x, (succ (-x) = - pred x)%R.

Proof.

intros x; rewrite succ_eq_opp_pred_opp.

now rewrite Ropp_involutive.

Qed.



Lemma pred_opp: forall x, (pred (-x) = - succ x)%R.

Proof.

intros x; rewrite pred_eq_opp_succ_opp.

now rewrite Ropp_involutive.

Qed.



Theorem id_m_ulp_ge_bpow :

  forall x e,  F x ->

  x <> ulp x ->

  (bpow e < x)%R ->

  (bpow e <= x - ulp x)%R.

Proof.

intros x e Fx Hx' Hx.



assert (1 <= Ztrunc (scaled_mantissa beta fexp x))%Z.

assert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

rewrite <- Fx.

apply Rle_lt_trans with (2:=Hx).

apply bpow_ge_0.

omega.

case (Zle_lt_or_eq _ _ H); intros Hm.



pattern x at 1 ; rewrite Fx.

rewrite ulp_neq_0.

unfold F2R. simpl.

pattern (bpow (canonic_exp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.

rewrite <- Rmult_minus_distr_r.

change 1%R with (Z2R 1).

rewrite <- Z2R_minus.

change (bpow e <= F2R (Float beta (Ztrunc (scaled_mantissa beta fexp x) - 1) (canonic_exp beta fexp x)))%R.

apply bpow_le_F2R_m1; trivial.

now rewrite <- Fx.

apply Rgt_not_eq, Rlt_gt.

apply Rlt_trans with (2:=Hx), bpow_gt_0.



contradict Hx'.

pattern x at 1; rewrite Fx.

rewrite  <- Hm.

rewrite ulp_neq_0.

unfold F2R; simpl.

now rewrite Rmult_1_l.

apply Rgt_not_eq, Rlt_gt.

apply Rlt_trans with (2:=Hx), bpow_gt_0.

Qed.



Theorem id_p_ulp_le_bpow :

  forall x e, (0 < x)%R -> F x ->

  (x < bpow e)%R ->

  (x + ulp x <= bpow e)%R.

Proof.

intros x e Zx Fx Hx.

pattern x at 1 ; rewrite Fx.

rewrite ulp_neq_0.

unfold F2R. simpl.

pattern (bpow (canonic_exp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.

rewrite <- Rmult_plus_distr_r.

change 1%R with (Z2R 1).

rewrite <- Z2R_plus.

change (F2R (Float beta (Ztrunc (scaled_mantissa beta fexp x) + 1) (canonic_exp beta fexp x)) <= bpow e)%R.

apply F2R_p1_le_bpow.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

now rewrite <- Fx.

now rewrite <- Fx.

now apply Rgt_not_eq.

Qed.



Lemma generic_format_pred_aux1:

  forall x, (0 < x)%R -> F x ->

  x <> bpow (ln_beta beta x - 1) ->

  F (x - ulp x).

Proof.

intros x Zx Fx Hx.

destruct (ln_beta beta x) as (ex, Ex).

simpl in Hx.

specialize (Ex (Rgt_not_eq _ _ Zx)).

assert (Ex' : (bpow (ex - 1) < x < bpow ex)%R).

rewrite Rabs_pos_eq in Ex.

destruct Ex as (H,H'); destruct H; split; trivial.

contradict Hx; easy.

now apply Rlt_le.

unfold generic_format, scaled_mantissa, canonic_exp.

rewrite ln_beta_unique with beta (x - ulp x)%R ex.

pattern x at 1 3 ; rewrite Fx.

rewrite ulp_neq_0.

unfold scaled_mantissa.

rewrite canonic_exp_fexp with (1 := Ex).

unfold F2R. simpl.

rewrite Rmult_minus_distr_r.

rewrite Rmult_assoc.

rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.

change (bpow 0) with (Z2R 1).

rewrite <- Z2R_minus.

rewrite Ztrunc_Z2R.

rewrite Z2R_minus.

rewrite Rmult_minus_distr_r.

now rewrite Rmult_1_l.

now apply Rgt_not_eq.

rewrite Rabs_pos_eq.

split.

apply id_m_ulp_ge_bpow; trivial.

rewrite ulp_neq_0.

intro H.

assert (ex-1 < canonic_exp beta fexp x  < ex)%Z.

split ; apply (lt_bpow beta) ; rewrite <- H ; easy.

clear -H0. omega.

now apply Rgt_not_eq.

apply Ex'.

apply Rle_lt_trans with (2 := proj2 Ex').

pattern x at 3 ; rewrite <- Rplus_0_r.

apply Rplus_le_compat_l.

rewrite <-Ropp_0.

apply Ropp_le_contravar.

apply ulp_ge_0.

apply Rle_0_minus.

pattern x at 2; rewrite Fx.

rewrite ulp_neq_0.

unfold F2R; simpl.

pattern (bpow (canonic_exp beta fexp x)) at 1; rewrite <- Rmult_1_l.

apply Rmult_le_compat_r.

apply bpow_ge_0.

replace 1%R with (Z2R 1) by reflexivity.

apply Z2R_le.

assert (0 <  Ztrunc (scaled_mantissa beta fexp x))%Z.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

rewrite <- Fx.

apply Rle_lt_trans with (2:=proj1 Ex').

apply bpow_ge_0.

omega.

now apply Rgt_not_eq.

Qed.



Lemma generic_format_pred_aux2 :

  forall x, (0 < x)%R -> F x ->

  let e := ln_beta_val beta x (ln_beta beta x) in

  x =  bpow (e - 1) ->

  F (x - bpow (fexp (e - 1))).

Proof.

intros x Zx Fx e Hx.

pose (f:=(x - bpow (fexp (e - 1)))%R).

fold f.

assert (He:(fexp (e-1) <= e-1)%Z).

apply generic_format_bpow_inv with beta; trivial.

rewrite <- Hx; assumption.

case (Zle_lt_or_eq _ _ He); clear He; intros He.

assert (f = F2R (Float beta (Zpower beta (e-1-(fexp (e-1))) -1) (fexp (e-1))))%R.

unfold f; rewrite Hx.

unfold F2R; simpl.

rewrite Z2R_minus, Z2R_Zpower.

rewrite Rmult_minus_distr_r, Rmult_1_l.

rewrite <- bpow_plus.

now replace (e - 1 - fexp (e - 1) + fexp (e - 1))%Z with (e-1)%Z by ring.

omega.

rewrite H.

apply generic_format_F2R.

intros _.

apply Zeq_le.

apply canonic_exp_fexp.

rewrite <- H.

unfold f; rewrite Hx.

rewrite Rabs_right.

split.

apply Rplus_le_reg_l with (bpow (fexp (e-1))).

ring_simplify.

apply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.

apply Rplus_le_compat ; apply bpow_le ; omega.

apply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].

apply Rle_trans with (bpow 1*bpow (e - 2))%R.

apply Rmult_le_compat_r.

apply bpow_ge_0.

replace 2%R with (Z2R 2) by reflexivity.

replace (bpow 1) with (Z2R beta).

apply Z2R_le.

apply <- Zle_is_le_bool.

now destruct beta.

simpl.

unfold Zpower_pos; simpl.

now rewrite Zmult_1_r.

rewrite <- bpow_plus.

replace (1+(e-2))%Z with (e-1)%Z by ring.

now right.

rewrite <- Rplus_0_r.

apply Rplus_lt_compat_l.

rewrite <- Ropp_0.

apply Ropp_lt_contravar.

apply bpow_gt_0.

apply Rle_ge; apply Rle_0_minus.

apply bpow_le.

omega.

replace f with 0%R.

apply generic_format_0.

unfold f.

rewrite Hx, He.

ring.

Qed.



Theorem generic_format_succ_aux1 :

  forall x, (0 < x)%R -> F x ->

  F (x + ulp x).

Proof.

intros x Zx Fx.

destruct (ln_beta beta x) as (ex, Ex).

specialize (Ex (Rgt_not_eq _ _ Zx)).

assert (Ex' := Ex).

rewrite Rabs_pos_eq in Ex'.

destruct (id_p_ulp_le_bpow x ex) ; try easy.

unfold generic_format, scaled_mantissa, canonic_exp.

rewrite ln_beta_unique with beta (x + ulp x)%R ex.

pattern x at 1 3 ; rewrite Fx.

rewrite ulp_neq_0.

unfold scaled_mantissa.

rewrite canonic_exp_fexp with (1 := Ex).

unfold F2R. simpl.

rewrite Rmult_plus_distr_r.

rewrite Rmult_assoc.

rewrite <- bpow_plus, Zplus_opp_r, Rmult_1_r.

change (bpow 0) with (Z2R 1).

rewrite <- Z2R_plus.

rewrite Ztrunc_Z2R.

rewrite Z2R_plus.

rewrite Rmult_plus_distr_r.

now rewrite Rmult_1_l.

now apply Rgt_not_eq.

rewrite Rabs_pos_eq.

split.

apply Rle_trans with (1 := proj1 Ex').

pattern x at 1 ; rewrite <- Rplus_0_r.

apply Rplus_le_compat_l.

apply ulp_ge_0.

exact H.

apply Rplus_le_le_0_compat.

now apply Rlt_le.

apply ulp_ge_0.

rewrite H.

apply generic_format_bpow.

apply valid_exp.

destruct (Zle_or_lt ex (fexp ex)) ; trivial.

elim Rlt_not_le with (1 := Zx).

rewrite Fx.

replace (Ztrunc (scaled_mantissa beta fexp x)) with Z0.

rewrite F2R_0.

apply Rle_refl.

unfold scaled_mantissa.

rewrite canonic_exp_fexp with (1 := Ex).

destruct (mantissa_small_pos beta fexp x ex) ; trivial.

rewrite Ztrunc_floor.

apply sym_eq.

apply Zfloor_imp.

split.

now apply Rlt_le.

exact H2.

now apply Rlt_le.

now apply Rlt_le.

Qed.



Theorem generic_format_pred_pos :

  forall x, F x -> (0 < x)%R ->

  F (pred_pos x).

Proof.

intros x Fx Zx.

unfold pred_pos; case Req_bool_spec; intros H.

now apply generic_format_pred_aux2.

now apply generic_format_pred_aux1.

Qed.



Theorem generic_format_succ :

  forall x, F x ->

  F (succ x).

Proof.

intros x Fx.

unfold succ; case Rle_bool_spec; intros Zx.

destruct Zx as [Zx|Zx].

now apply generic_format_succ_aux1.

rewrite <- Zx, Rplus_0_l.

apply generic_format_ulp_0.

apply generic_format_opp.

apply generic_format_pred_pos.

now apply generic_format_opp.

now apply Ropp_0_gt_lt_contravar.

Qed.



Theorem generic_format_pred :

  forall x, F x ->

  F (pred x).

Proof.

intros x Fx.

unfold pred.

apply generic_format_opp.

apply generic_format_succ.

now apply generic_format_opp.

Qed.



Theorem pred_pos_lt_id :

  forall x, (x <> 0)%R ->

  (pred_pos x < x)%R.

Proof.

intros x Zx.

unfold pred_pos.

case Req_bool_spec; intros H.



rewrite <- Rplus_0_r.

apply Rplus_lt_compat_l.

rewrite <- Ropp_0.

apply Ropp_lt_contravar.

apply bpow_gt_0.



rewrite <- Rplus_0_r.

apply Rplus_lt_compat_l.

rewrite <- Ropp_0.

apply Ropp_lt_contravar.

rewrite ulp_neq_0; trivial.

apply bpow_gt_0.

Qed.



Theorem succ_gt_id :

  forall x, (x <> 0)%R ->

  (x < succ x)%R.

Proof.

intros x Zx; unfold succ.

case Rle_bool_spec; intros Hx.

pattern x at 1; rewrite <- (Rplus_0_r x).

apply Rplus_lt_compat_l.

rewrite ulp_neq_0; trivial.

apply bpow_gt_0.

pattern x at 1; rewrite <- (Ropp_involutive x).

apply Ropp_lt_contravar.

apply pred_pos_lt_id.

now auto with real.

Qed.



Theorem pred_lt_id :

  forall x,  (x <> 0)%R ->

  (pred x < x)%R.

Proof.

intros x Zx; unfold pred.

pattern x at 2; rewrite <- (Ropp_involutive x).

apply Ropp_lt_contravar.

apply succ_gt_id.

now auto with real.

Qed.



Theorem succ_ge_id :

  forall x, (x <= succ x)%R.

Proof.

intros x; case (Req_dec x 0).

intros V; rewrite V.

unfold succ; rewrite Rle_bool_true;[idtac|now right].

rewrite Rplus_0_l; apply ulp_ge_0.

intros; left; now apply succ_gt_id.

Qed.



Theorem pred_le_id :

  forall x,  (pred x <= x)%R.

Proof.

intros x; unfold pred.

pattern x at 2; rewrite <- (Ropp_involutive x).

apply Ropp_le_contravar.

apply succ_ge_id.

Qed.



Theorem pred_pos_ge_0 :

  forall x,

  (0 < x)%R -> F x -> (0 <= pred_pos x)%R.

Proof.

intros x Zx Fx.

unfold pred_pos.

case Req_bool_spec; intros H.



apply Rle_0_minus.

rewrite H.

apply bpow_le.

destruct (ln_beta beta x) as (ex,Ex) ; simpl.

rewrite ln_beta_bpow.

ring_simplify (ex - 1 + 1 - 1)%Z.

apply generic_format_bpow_inv with beta; trivial.

simpl in H.

rewrite <- H; assumption.

apply Rle_0_minus.

now apply ulp_le_id.

Qed.



Theorem pred_ge_0 :

  forall x,

  (0 < x)%R -> F x -> (0 <= pred x)%R.

Proof.

intros x Zx Fx.

rewrite pred_eq_pos.

now apply pred_pos_ge_0.

now left.

Qed.



Lemma pred_pos_plus_ulp_aux1 :

  forall x, (0 < x)%R -> F x ->

  x <> bpow (ln_beta beta x - 1) ->

  ((x - ulp x) + ulp (x-ulp x) = x)%R.

Proof.

intros x Zx Fx Hx.

replace (ulp (x - ulp x)) with (ulp x).

ring.

assert (H:(x <> 0)%R) by auto with real.

assert (H':(x <> bpow (canonic_exp beta fexp x))%R).

unfold canonic_exp; intros M.

case_eq (ln_beta beta x); intros ex Hex T.

assert (Lex:(ln_beta_val beta x (ln_beta beta x) = ex)%Z).

rewrite T; reflexivity.

rewrite Lex in *.

clear T; simpl in *; specialize (Hex H).

rewrite Rabs_right in Hex.

2: apply Rle_ge; apply Rlt_le; easy.

assert (ex-1 < fexp ex  < ex)%Z.

split ; apply (lt_bpow beta); rewrite <- M;[idtac|easy].

destruct (proj1 Hex);[trivial|idtac].

contradict Hx; auto with real.

omega.

rewrite 2!ulp_neq_0; try auto with real.

apply f_equal.

unfold canonic_exp; apply f_equal.

case_eq (ln_beta beta x); intros ex Hex T.

assert (Lex:(ln_beta_val beta x (ln_beta beta x) = ex)%Z).

rewrite T; reflexivity.

rewrite Lex in *; simpl in *; clear T.

specialize (Hex H).

apply sym_eq, ln_beta_unique.

rewrite Rabs_right.

rewrite Rabs_right in Hex.

2: apply Rle_ge; apply Rlt_le; easy.

split.

destruct Hex as ([H1|H1],H2).

apply Rle_trans with (x-ulp x)%R.

apply id_m_ulp_ge_bpow; trivial.

rewrite ulp_neq_0; trivial.

rewrite ulp_neq_0; trivial.

right; unfold canonic_exp; now rewrite Lex.

contradict Hx; auto with real.

apply Rle_lt_trans with (2:=proj2 Hex).

rewrite <- Rplus_0_r.

apply Rplus_le_compat_l.

rewrite <- Ropp_0.

apply Ropp_le_contravar.

apply bpow_ge_0.

apply Rle_ge.

apply Rle_0_minus.

rewrite Fx.

unfold F2R, canonic_exp; simpl.

rewrite Lex.

pattern (bpow (fexp ex)) at 1; rewrite <- Rmult_1_l.

apply Rmult_le_compat_r.

apply bpow_ge_0.

replace 1%R with (Z2R (Zsucc 0)) by reflexivity.

apply Z2R_le.

apply Zlt_le_succ.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

now rewrite <- Fx.

Qed.



Lemma pred_pos_plus_ulp_aux2 :

  forall x, (0 < x)%R -> F x ->

  let e := ln_beta_val beta x (ln_beta beta x) in

  x =  bpow (e - 1) ->

  (x - bpow (fexp (e-1)) <> 0)%R ->

  ((x - bpow (fexp (e-1))) + ulp (x - bpow (fexp (e-1))) = x)%R.

Proof.

intros x Zx Fx e Hxe Zp.

replace (ulp (x - bpow (fexp (e - 1)))) with (bpow (fexp (e - 1))).

ring.

assert (He:(fexp (e-1) <= e-1)%Z).

apply generic_format_bpow_inv with beta; trivial.

rewrite <- Hxe; assumption.

case (Zle_lt_or_eq _ _ He); clear He; intros He.



rewrite ulp_neq_0; trivial.

apply f_equal.

unfold canonic_exp; apply f_equal.

apply sym_eq.

apply ln_beta_unique.

rewrite Rabs_right.

split.

apply Rplus_le_reg_l with (bpow (fexp (e-1))).

ring_simplify.

apply Rle_trans with (bpow (e - 2) + bpow (e - 2))%R.

apply Rplus_le_compat; apply bpow_le; omega.

apply Rle_trans with (2*bpow (e - 2))%R;[right; ring|idtac].

apply Rle_trans with (bpow 1*bpow (e - 2))%R.

apply Rmult_le_compat_r.

apply bpow_ge_0.

replace 2%R with (Z2R 2) by reflexivity.

replace (bpow 1) with (Z2R beta).

apply Z2R_le.

apply <- Zle_is_le_bool.

now destruct beta.

simpl.

unfold Zpower_pos; simpl.

now rewrite Zmult_1_r.

rewrite <- bpow_plus.

replace (1+(e-2))%Z with (e-1)%Z by ring.

now right.

rewrite <- Rplus_0_r, Hxe.

apply Rplus_lt_compat_l.

rewrite <- Ropp_0.

apply Ropp_lt_contravar.

apply bpow_gt_0.

apply Rle_ge; apply Rle_0_minus.

rewrite Hxe.

apply bpow_le.

omega.



contradict Zp.

rewrite Hxe, He; ring.

Qed.



Lemma pred_pos_plus_ulp_aux3 :

  forall x, (0 < x)%R -> F x ->

  let e := ln_beta_val beta x (ln_beta beta x) in

  x =  bpow (e - 1) ->

  (x - bpow (fexp (e-1)) = 0)%R ->

  (ulp 0 = x)%R.

Proof.

intros x Hx Fx e H1 H2.

assert (H3:(x = bpow (fexp (e - 1)))).

now apply Rminus_diag_uniq.

assert (H4: (fexp (e-1) = e-1)%Z).

apply bpow_inj with beta.

now rewrite <- H1.

unfold ulp; rewrite Req_bool_true; trivial.

case negligible_exp_spec.

intros K.

specialize (K (e-1)%Z).

contradict K; omega.

intros n Hn.

rewrite H3; apply f_equal.

case (Zle_or_lt n (e-1)); intros H6.

apply valid_exp; omega.

apply sym_eq, valid_exp; omega.

Qed.



Theorem pred_pos_plus_ulp :

  forall x, (0 < x)%R -> F x ->

  (pred_pos x + ulp (pred_pos x) = x)%R.

Proof.

intros x Zx Fx.

unfold pred_pos.

case Req_bool_spec; intros H.

case (Req_EM_T (x - bpow (fexp (ln_beta_val beta x (ln_beta beta x) -1))) 0); intros H1.

rewrite H1, Rplus_0_l.

now apply pred_pos_plus_ulp_aux3.

now apply pred_pos_plus_ulp_aux2.

now apply pred_pos_plus_ulp_aux1.

Qed.



Theorem ln_beta_plus_eps:

  forall x, (0 < x)%R -> F x ->

  forall eps, (0 <= eps < ulp x)%R ->

  ln_beta beta (x + eps) = ln_beta beta x :> Z.

Proof.

intros x Zx Fx eps Heps.

destruct (ln_beta beta x) as (ex, He).

simpl.

specialize (He (Rgt_not_eq _ _ Zx)).

apply ln_beta_unique.

rewrite Rabs_pos_eq.

rewrite Rabs_pos_eq in He.

split.

apply Rle_trans with (1 := proj1 He).

pattern x at 1 ; rewrite <- Rplus_0_r.

now apply Rplus_le_compat_l.

apply Rlt_le_trans with (x + ulp x)%R.

now apply Rplus_lt_compat_l.

pattern x at 1 ; rewrite Fx.

rewrite ulp_neq_0.

unfold F2R. simpl.

pattern (bpow (canonic_exp beta fexp x)) at 2 ; rewrite <- Rmult_1_l.

rewrite <- Rmult_plus_distr_r.

change 1%R with (Z2R 1).

rewrite <- Z2R_plus.

change (F2R (Float beta (Ztrunc (scaled_mantissa beta fexp x) + 1) (canonic_exp beta fexp x)) <= bpow ex)%R.

apply F2R_p1_le_bpow.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

now rewrite <- Fx.

now rewrite <- Fx.

now apply Rgt_not_eq.

now apply Rlt_le.

apply Rplus_le_le_0_compat.

now apply Rlt_le.

apply Heps.

Qed.



Theorem round_DN_plus_eps_pos:

  forall x, (0 <= x)%R -> F x ->

  forall eps, (0 <= eps < ulp x)%R ->

  round beta fexp Zfloor (x + eps) = x.

Proof.

intros x Zx Fx eps Heps.

destruct Zx as [Zx|Zx].



pattern x at 2 ; rewrite Fx.

unfold round.

unfold scaled_mantissa. simpl.

unfold canonic_exp at 1 2.

rewrite ln_beta_plus_eps ; trivial.

apply (f_equal (fun m => F2R (Float beta m _))).

rewrite Ztrunc_floor.

apply Zfloor_imp.

split.

apply (Rle_trans _ _ _ (Zfloor_lb _)).

apply Rmult_le_compat_r.

apply bpow_ge_0.

pattern x at 1 ; rewrite <- Rplus_0_r.

now apply Rplus_le_compat_l.

apply Rlt_le_trans with ((x + ulp x) * bpow (- canonic_exp beta fexp x))%R.

apply Rmult_lt_compat_r.

apply bpow_gt_0.

now apply Rplus_lt_compat_l.

rewrite Rmult_plus_distr_r.

rewrite Z2R_plus.

apply Rplus_le_compat.

pattern x at 1 3 ; rewrite Fx.

unfold F2R. simpl.

rewrite Rmult_assoc.

rewrite <- bpow_plus.

rewrite Zplus_opp_r.

rewrite Rmult_1_r.

rewrite Zfloor_Z2R.

apply Rle_refl.

rewrite ulp_neq_0.

2: now apply Rgt_not_eq.

rewrite <- bpow_plus.

rewrite Zplus_opp_r.

apply Rle_refl.

apply Rmult_le_pos.

now apply Rlt_le.

apply bpow_ge_0.



rewrite <- Zx, Rplus_0_l; rewrite <- Zx in Heps.

case (proj1 Heps); intros P.

unfold round, scaled_mantissa, canonic_exp.

revert Heps; unfold ulp.

rewrite Req_bool_true; trivial.

case negligible_exp_spec.

intros _ (H1,H2).

absurd (0 < 0)%R; auto with real.

now apply Rle_lt_trans with (1:=H1).

intros n Hn H.

assert (fexp (ln_beta beta eps) = fexp n).

apply valid_exp; try assumption.

assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega].

apply lt_bpow with beta.

apply Rle_lt_trans with (2:=proj2 H).

destruct (ln_beta beta eps) as (e,He).

simpl; rewrite Rabs_pos_eq in He.

now apply He, Rgt_not_eq.

now left.

replace (Zfloor (eps * bpow (- fexp (ln_beta beta eps)))) with 0%Z.

unfold F2R; simpl; ring.

apply sym_eq, Zfloor_imp.

split.

apply Rmult_le_pos.

now left.

apply bpow_ge_0.

apply Rmult_lt_reg_r with (bpow (fexp n)).

apply bpow_gt_0.

rewrite Rmult_assoc, <- bpow_plus.

rewrite H0; ring_simplify (-fexp n + fexp n)%Z.

simpl; rewrite Rmult_1_l, Rmult_1_r.

apply H.

rewrite <- P, round_0; trivial.

apply valid_rnd_DN.

Qed.



Theorem round_UP_plus_eps_pos :

  forall x, (0 <= x)%R -> F x ->

  forall eps, (0 < eps <= ulp x)%R ->

  round beta fexp Zceil (x + eps) = (x + ulp x)%R.

Proof with auto with typeclass_instances.

intros x Zx Fx eps.

case Zx; intros Zx1.



intros (Heps1,[Heps2|Heps2]).

assert (Heps: (0 <= eps < ulp x)%R).

split.

now apply Rlt_le.

exact Heps2.

assert (Hd := round_DN_plus_eps_pos x Zx Fx eps Heps).

rewrite round_UP_DN_ulp.

rewrite Hd.

rewrite 2!ulp_neq_0.

unfold canonic_exp.

now rewrite ln_beta_plus_eps.

now apply Rgt_not_eq.

now apply Rgt_not_eq, Rplus_lt_0_compat.

intros Fs.

rewrite round_generic in Hd...

apply Rgt_not_eq with (2 := Hd).

pattern x at 2 ; rewrite <- Rplus_0_r.

now apply Rplus_lt_compat_l.

rewrite Heps2.

apply round_generic...

now apply generic_format_succ_aux1.



rewrite <- Zx1, 2!Rplus_0_l.

intros Heps.

case (proj2 Heps).

unfold round, scaled_mantissa, canonic_exp.

unfold ulp.

rewrite Req_bool_true; trivial.

case negligible_exp_spec.

intros H2.

intros J; absurd (0 < 0)%R; auto with real.

apply Rlt_trans with eps; try assumption; apply Heps.

intros n Hn H.

assert (fexp (ln_beta beta eps) = fexp n).

apply valid_exp; try assumption.

assert(ln_beta beta eps-1 < fexp n)%Z;[idtac|omega].

apply lt_bpow with beta.

apply Rle_lt_trans with (2:=H).

destruct (ln_beta beta eps) as (e,He).

simpl; rewrite Rabs_pos_eq in He.

now apply He, Rgt_not_eq.

now left.

replace (Zceil (eps * bpow (- fexp (ln_beta beta eps)))) with 1%Z.

unfold F2R; simpl; rewrite H0; ring.

apply sym_eq, Zceil_imp.

split.

simpl; apply Rmult_lt_0_compat.

apply Heps.

apply bpow_gt_0.

apply Rmult_le_reg_r with (bpow (fexp n)).

apply bpow_gt_0.

rewrite Rmult_assoc, <- bpow_plus.

rewrite H0; ring_simplify (-fexp n + fexp n)%Z.

simpl; rewrite Rmult_1_l, Rmult_1_r.

now left.

intros P; rewrite P.

apply round_generic...

apply generic_format_ulp_0.

Qed.



Theorem round_UP_pred_plus_eps_pos :

  forall x, (0 < x)%R -> F x ->

  forall eps, (0 < eps <= ulp (pred x) )%R ->

  round beta fexp Zceil (pred x + eps) = x.

Proof.

intros x Hx Fx eps Heps.

rewrite round_UP_plus_eps_pos; trivial.

rewrite pred_eq_pos.

apply pred_pos_plus_ulp; trivial.

now left.

now apply pred_ge_0.

apply generic_format_pred; trivial.

Qed.



Theorem round_DN_minus_eps_pos :

  forall x,  (0 < x)%R -> F x ->

  forall eps, (0 < eps <= ulp (pred x))%R ->

  round beta fexp Zfloor (x - eps) = pred x.

Proof.

intros x Hpx Fx eps.

rewrite pred_eq_pos;[intros Heps|now left].

replace (x-eps)%R with (pred_pos x + (ulp (pred_pos x)-eps))%R.

2: pattern x at 3; rewrite <- (pred_pos_plus_ulp x); trivial.

2: ring.

rewrite round_DN_plus_eps_pos; trivial.

now apply pred_pos_ge_0.

now apply generic_format_pred_pos.

split.

apply Rle_0_minus.

now apply Heps.

rewrite <- Rplus_0_r.

apply Rplus_lt_compat_l.

rewrite <- Ropp_0.

apply Ropp_lt_contravar.

now apply Heps.

Qed.



Theorem round_DN_plus_eps:

  forall x, F x ->

  forall eps, (0 <= eps < if (Rle_bool 0 x) then (ulp x)

                                     else (ulp (pred (-x))))%R ->

  round beta fexp Zfloor (x + eps) = x.

Proof.

intros x Fx eps Heps.

case (Rle_or_lt 0 x); intros Zx.

apply round_DN_plus_eps_pos; try assumption.

split; try apply Heps.

rewrite Rle_bool_true in Heps; trivial.

now apply Heps.



rewrite Rle_bool_false in Heps; trivial.

rewrite <- (Ropp_involutive (x+eps)).

pattern x at 2; rewrite <- (Ropp_involutive x).

rewrite round_DN_opp.

apply f_equal.

replace (-(x+eps))%R with (pred (-x) + (ulp (pred (-x)) - eps))%R.

rewrite round_UP_pred_plus_eps_pos; try reflexivity.

now apply Ropp_0_gt_lt_contravar.

now apply generic_format_opp.

split.

apply Rplus_lt_reg_l with eps; ring_simplify.

apply Heps.

apply Rplus_le_reg_l with (eps-ulp (pred (- x)))%R; ring_simplify.

apply Heps.

unfold pred.

rewrite Ropp_involutive.

unfold succ; rewrite Rle_bool_false; try assumption.

rewrite Ropp_involutive; unfold Rminus.

rewrite <- Rplus_assoc, pred_pos_plus_ulp.

ring.

now apply Ropp_0_gt_lt_contravar.

now apply generic_format_opp.

Qed.



Theorem round_UP_plus_eps :

  forall x, F x ->

  forall eps, (0 < eps <= if (Rle_bool 0 x) then (ulp x)

                                     else (ulp (pred (-x))))%R ->

  round beta fexp Zceil (x + eps) = (succ x)%R.

Proof with auto with typeclass_instances.

intros x Fx eps Heps.

case (Rle_or_lt 0 x); intros Zx.

rewrite succ_eq_pos; try assumption.

rewrite Rle_bool_true in Heps; trivial.

apply round_UP_plus_eps_pos; assumption.



rewrite Rle_bool_false in Heps; trivial.

rewrite <- (Ropp_involutive (x+eps)).

rewrite <- (Ropp_involutive (succ x)).

rewrite round_UP_opp.

apply f_equal.

replace (-(x+eps))%R with (-succ x + (-eps + ulp (pred (-x))))%R.

apply round_DN_plus_eps_pos.

rewrite <- pred_opp.

apply pred_ge_0.

now apply Ropp_0_gt_lt_contravar.

now apply generic_format_opp.

now apply generic_format_opp, generic_format_succ.

split.

apply Rplus_le_reg_l with eps; ring_simplify.

apply Heps.

unfold pred; rewrite Ropp_involutive.

apply Rplus_lt_reg_l with (eps-ulp (- succ x))%R; ring_simplify.

apply Heps.

unfold succ; rewrite Rle_bool_false; try assumption.

apply trans_eq with (-x +-eps)%R;[idtac|ring].

pattern (-x)%R at 3; rewrite <- (pred_pos_plus_ulp (-x)).

rewrite pred_eq_pos.

ring.

left; now apply Ropp_0_gt_lt_contravar.

now apply Ropp_0_gt_lt_contravar.

now apply generic_format_opp.

Qed.



Lemma le_pred_pos_lt :

  forall x y,

  F x -> F y ->

  (0 <= x < y)%R ->

  (x <= pred_pos y)%R.

Proof with auto with typeclass_instances.

intros x y Fx Fy H.

case (proj1 H); intros V.

assert (Zy:(0 < y)%R).

apply Rle_lt_trans with (1:=proj1 H).

apply H.



assert (Zp: (0 < pred y)%R).

assert (Zp:(0 <= pred y)%R).

apply pred_ge_0 ; trivial.

destruct Zp; trivial.

generalize H0.

rewrite pred_eq_pos;[idtac|now left].

unfold pred_pos.

destruct (ln_beta beta y) as (ey,Hey); simpl.

case Req_bool_spec; intros Hy2.



intros Hy3.

assert (ey-1 = fexp (ey -1))%Z.

apply bpow_inj with beta.

rewrite <- Hy2, <- Rplus_0_l, Hy3.

ring.

assert (Zx: (x <> 0)%R).

now apply Rgt_not_eq.

destruct (ln_beta beta x) as (ex,Hex).

specialize (Hex Zx).

assert (ex <= ey)%Z.

apply bpow_lt_bpow with beta.

apply Rle_lt_trans with (1:=proj1 Hex).

apply Rlt_trans with (Rabs y).

rewrite 2!Rabs_right.

apply H.

now apply Rgt_ge.

now apply Rgt_ge.

apply Hey.

now apply Rgt_not_eq.

case (Zle_lt_or_eq _ _ H2); intros Hexy.

assert (fexp ex = fexp (ey-1))%Z.

apply valid_exp.

omega.

rewrite <- H1.

omega.

absurd (0 < Ztrunc (scaled_mantissa beta fexp x) < 1)%Z.

omega.

split.

apply F2R_gt_0_reg with beta (canonic_exp beta fexp x).

now rewrite <- Fx.

apply lt_Z2R.

apply Rmult_lt_reg_r with (bpow (canonic_exp beta fexp x)).

apply bpow_gt_0.

replace (Z2R (Ztrunc (scaled_mantissa beta fexp x)) *

 bpow (canonic_exp beta fexp x))%R with x.

rewrite Rmult_1_l.

unfold canonic_exp.

rewrite ln_beta_unique with beta x ex.

rewrite H3,<-H1, <- Hy2.

apply H.

exact Hex.

absurd (y <= x)%R.

now apply Rlt_not_le.

rewrite Rabs_right in Hex.

apply Rle_trans with (2:=proj1 Hex).

rewrite Hexy, Hy2.

now apply Rle_refl.

now apply Rgt_ge.



intros Hy3.

assert (y = bpow (fexp ey))%R.

apply Rminus_diag_uniq.

rewrite Hy3.

rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].

unfold canonic_exp.

rewrite (ln_beta_unique beta y ey); trivial.

apply Hey.

now apply Rgt_not_eq.

contradict Hy2.

rewrite H1.

apply f_equal.

apply Zplus_reg_l with 1%Z.

ring_simplify.

apply trans_eq with (ln_beta beta y).

apply sym_eq; apply ln_beta_unique.

rewrite H1, Rabs_right.

split.

apply bpow_le.

omega.

apply bpow_lt.

omega.

apply Rle_ge; apply bpow_ge_0.

apply ln_beta_unique.

apply Hey.

now apply Rgt_not_eq.



case (Rle_or_lt (ulp (pred_pos y)) (y-x)); intros H1.



apply Rplus_le_reg_r with (-x + ulp (pred_pos y))%R.

ring_simplify (x+(-x+ulp (pred_pos y)))%R.

apply Rle_trans with (1:=H1).

rewrite <- (pred_pos_plus_ulp y) at 1; trivial.

apply Req_le; ring.



replace x with (y-(y-x))%R by ring.

rewrite <- pred_eq_pos;[idtac|now left].

rewrite <- round_DN_minus_eps_pos with (eps:=(y-x)%R); try easy.

ring_simplify (y-(y-x))%R.

apply Req_le.

apply sym_eq.

apply round_generic...

split; trivial.

now apply Rlt_Rminus.

rewrite pred_eq_pos;[idtac|now left].

now apply Rlt_le.

rewrite <- V; apply pred_pos_ge_0; trivial.

apply Rle_lt_trans with (1:=proj1 H); apply H.

Qed.



Theorem succ_le_lt_aux:

  forall x y,

  F x -> F y ->

  (0 <= x)%R -> (x < y)%R ->

  (succ x <= y)%R.

Proof with auto with typeclass_instances.

intros x y Hx Hy Zx H.

rewrite succ_eq_pos; trivial.

case (Rle_or_lt (ulp x) (y-x)); intros H1.

apply Rplus_le_reg_r with (-x)%R.

now ring_simplify (x+ulp x + -x)%R.

replace y with (x+(y-x))%R by ring.

absurd (x < y)%R.

2: apply H.

apply Rle_not_lt; apply Req_le.

rewrite <- round_DN_plus_eps_pos with (eps:=(y-x)%R); try easy.

ring_simplify (x+(y-x))%R.

apply sym_eq.

apply round_generic...

split; trivial.

apply Rlt_le; now apply Rlt_Rminus.

Qed.



Theorem succ_le_lt:

  forall x y,

  F x -> F y ->

  (x < y)%R ->

  (succ x <= y)%R.

Proof with auto with typeclass_instances.

intros x y Fx Fy H.

destruct (Rle_or_lt 0 x) as [Hx|Hx].

now apply succ_le_lt_aux.

unfold succ; rewrite Rle_bool_false; try assumption.

case (Rle_or_lt y 0); intros Hy.

rewrite <- (Ropp_involutive y).

apply Ropp_le_contravar.

apply le_pred_pos_lt.

now apply generic_format_opp.

now apply generic_format_opp.

split.

rewrite <- Ropp_0; now apply Ropp_le_contravar.

now apply Ropp_lt_contravar.

apply Rle_trans with (-0)%R.

apply Ropp_le_contravar.

apply pred_pos_ge_0.

rewrite <- Ropp_0; now apply Ropp_lt_contravar.

now apply generic_format_opp.

rewrite Ropp_0; now left.

Qed.



Theorem le_pred_lt :

  forall x y,

  F x -> F y ->

  (x < y)%R ->

  (x <= pred y)%R.

Proof.

intros x y Fx Fy Hxy.

rewrite <- (Ropp_involutive x).

unfold pred; apply Ropp_le_contravar.

apply succ_le_lt.

now apply generic_format_opp.

now apply generic_format_opp.

now apply Ropp_lt_contravar.

Qed.



Theorem lt_succ_le :

  forall x y,

  (y <> 0)%R ->

  (x <= y)%R ->

  (x < succ y)%R.

Proof.

intros x y Zy Hxy.

apply Rle_lt_trans with (1 := Hxy).

now apply succ_gt_id.

Qed.



Theorem pred_lt_le :

  forall x y,

  (x <> 0)%R ->

  (x <= y)%R ->

  (pred x < y)%R.

Proof.

intros x y Zy Hxy.

apply Rlt_le_trans with (2 := Hxy).

now apply pred_lt_id.

Qed.



Theorem succ_pred_aux : forall x, F x -> (0 < x)%R -> succ (pred x)=x.

Proof.

intros x Fx Hx.

rewrite pred_eq_pos;[idtac|now left].

rewrite succ_eq_pos.

2: now apply pred_pos_ge_0.

now apply pred_pos_plus_ulp.

Qed.



Theorem pred_ulp_0 :

  pred (ulp 0) = 0%R.

Proof.

rewrite pred_eq_pos.

2: apply ulp_ge_0.

unfold ulp; rewrite Req_bool_true; trivial.

case negligible_exp_spec'.



intros [H1 _]; rewrite H1.

unfold pred_pos; rewrite Req_bool_false.

2: apply Rlt_not_eq, bpow_gt_0.

unfold ulp; rewrite Req_bool_true; trivial.

rewrite H1; ring.



intros (n,(H1,H2)); rewrite H1.

unfold pred_pos.

rewrite ln_beta_bpow.

replace (fexp n + 1 - 1)%Z with (fexp n) by ring.

rewrite Req_bool_true; trivial.

apply Rminus_diag_eq, f_equal.

apply sym_eq, valid_exp; omega.

Qed.



Theorem succ_0 :

  succ 0 = ulp 0.

Proof.

unfold succ.

rewrite Rle_bool_true.

apply Rplus_0_l.

apply Rle_refl.

Qed.



Theorem pred_0 :

  pred 0 = Ropp (ulp 0).

Proof.

rewrite <- succ_0.

rewrite <- Ropp_0 at 1.

apply pred_opp.

Qed.



Theorem pred_succ_aux :

  forall x, F x -> (0 < x)%R ->

  pred (succ x) = x.

Proof.

intros x Fx Hx.

apply Rle_antisym.

- apply Rnot_lt_le.

  intros H.

  apply succ_le_lt with (1 := Fx) in H.

  revert H.

  apply Rlt_not_le.

  apply pred_lt_id.

  apply Rgt_not_eq.

  apply Rlt_le_trans with (1 := Hx).

  apply succ_ge_id.

  now apply generic_format_pred, generic_format_succ.

- apply le_pred_lt with (1 := Fx).

  now apply generic_format_succ.

  apply succ_gt_id.

  now apply Rgt_not_eq.

Qed.



Theorem succ_pred :

  forall x, F x ->

  succ (pred x) = x.

Proof.

intros x Fx.

destruct (Rle_or_lt 0 x) as [[Hx|Hx]|Hx].

now apply succ_pred_aux.

rewrite <- Hx.

rewrite pred_0, succ_opp, pred_ulp_0.

apply Ropp_0.

rewrite pred_eq_opp_succ_opp, succ_opp.

rewrite pred_succ_aux.

apply Ropp_involutive.

now apply generic_format_opp.

now apply Ropp_0_gt_lt_contravar.

Qed.



Theorem pred_succ :

  forall x, F x ->

  pred (succ x) = x.

Proof.

intros x Fx.

rewrite <- (Ropp_involutive x).

rewrite succ_opp, pred_opp.

apply f_equal, succ_pred.

now apply generic_format_opp.

Qed.



Theorem round_UP_pred_plus_eps :

  forall x, F x ->

  forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x)

                                     else (ulp (pred x)))%R ->

  round beta fexp Zceil (pred x + eps) = x.

Proof.

intros x Fx eps Heps.

rewrite round_UP_plus_eps.

now apply succ_pred.

now apply generic_format_pred.

unfold pred at 4.

rewrite Ropp_involutive, pred_succ.

rewrite ulp_opp.

generalize Heps; case (Rle_bool_spec x 0); intros H1 H2.

rewrite Rle_bool_false; trivial.

case H1; intros H1'.

apply Rlt_le_trans with (2:=H1).

apply pred_lt_id.

now apply Rlt_not_eq.

rewrite H1'; unfold pred, succ.

rewrite Ropp_0; rewrite Rle_bool_true;[idtac|now right].

rewrite Rplus_0_l.

rewrite <- Ropp_0; apply Ropp_lt_contravar.

apply Rlt_le_trans with (1:=proj1 H2).

apply Rle_trans with (1:=proj2 H2).

rewrite Ropp_0, H1'.

now right.

rewrite Rle_bool_true; trivial.

now apply pred_ge_0.

now apply generic_format_opp.

Qed.



Theorem round_DN_minus_eps:

  forall x,  F x ->

  forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x)

                                     else (ulp (pred x)))%R ->

  round beta fexp Zfloor (x - eps) = pred x.

Proof.

intros x Fx eps Heps.

replace (x-eps)%R with (-(-x+eps))%R by ring.

rewrite round_DN_opp.

unfold pred; apply f_equal.

pattern (-x)%R at 1; rewrite <- (pred_succ (-x)).

apply round_UP_pred_plus_eps.

now apply generic_format_succ, generic_format_opp.

rewrite pred_succ.

rewrite ulp_opp.

generalize Heps; case (Rle_bool_spec x 0); intros H1 H2.

rewrite Rle_bool_false; trivial.

case H1; intros H1'.

apply Rlt_le_trans with (-x)%R.

now apply Ropp_0_gt_lt_contravar.

apply succ_ge_id.

rewrite H1', Ropp_0, succ_eq_pos;[idtac|now right].

rewrite Rplus_0_l.

apply Rlt_le_trans with (1:=proj1 H2).

rewrite H1' in H2; apply H2.

rewrite Rle_bool_true.

now rewrite succ_opp, ulp_opp.

rewrite succ_opp.

rewrite <- Ropp_0; apply Ropp_le_contravar.

now apply pred_ge_0.

now apply generic_format_opp.

now apply generic_format_opp.

Qed.



Theorem error_lt_ulp :

  forall rnd { Zrnd : Valid_rnd rnd } x,

   (x <> 0)%R ->

  (Rabs (round beta fexp rnd x - x) < ulp x)%R.

Proof with auto with typeclass_instances.

intros rnd Zrnd x Zx.

destruct (generic_format_EM beta fexp x) as [Hx|Hx].



rewrite round_generic...

unfold Rminus.

rewrite Rplus_opp_r, Rabs_R0.

rewrite ulp_neq_0; trivial.

apply bpow_gt_0.



destruct (round_DN_or_UP beta fexp rnd x) as [H|H] ; rewrite H ; clear H.



rewrite Rabs_left1.

rewrite Ropp_minus_distr.

apply Rplus_lt_reg_l with (round beta fexp Zfloor x).

rewrite <- round_UP_DN_ulp with (1 := Hx).

ring_simplify.

assert (Hu: (x <= round beta fexp Zceil x)%R).

apply round_UP_pt...

destruct Hu as [Hu|Hu].

exact Hu.

elim Hx.

rewrite Hu.

apply generic_format_round...

apply Rle_minus.

apply round_DN_pt...



rewrite Rabs_pos_eq.

rewrite round_UP_DN_ulp with (1 := Hx).

apply Rplus_lt_reg_r with (x - ulp x)%R.

ring_simplify.

assert (Hd: (round beta fexp Zfloor x <= x)%R).

apply round_DN_pt...

destruct Hd as [Hd|Hd].

exact Hd.

elim Hx.

rewrite <- Hd.

apply generic_format_round...

apply Rle_0_minus.

apply round_UP_pt...

Qed.



Theorem error_le_ulp :

  forall rnd { Zrnd : Valid_rnd rnd } x,

  (Rabs (round beta fexp rnd x - x) <= ulp x)%R.

Proof with auto with typeclass_instances.

intros  rnd Zrnd x.

case (Req_dec x 0).

intros Zx; rewrite Zx, round_0...

unfold Rminus; rewrite Rplus_0_l, Ropp_0, Rabs_R0.

apply ulp_ge_0.

intros Zx; left.

now apply error_lt_ulp.

Qed.



Theorem error_le_half_ulp :

  forall choice x,

  (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp x)%R.

Proof with auto with typeclass_instances.

intros choice x.

destruct (generic_format_EM beta fexp x) as [Hx|Hx].



rewrite round_generic...

unfold Rminus.

rewrite Rplus_opp_r, Rabs_R0.

apply Rmult_le_pos.

apply Rlt_le.

apply Rinv_0_lt_compat.

now apply (Z2R_lt 0 2).

apply ulp_ge_0.



set (d := round beta fexp Zfloor x).

destruct (round_N_pt beta fexp choice x) as (Hr1, Hr2).

destruct (Rle_or_lt (x - d) (d + ulp x - x)) as [H|H].



apply Rle_trans with (Rabs (d - x)).

apply Hr2.

apply (round_DN_pt beta fexp x).

rewrite Rabs_left1.

rewrite Ropp_minus_distr.

apply Rmult_le_reg_r with 2%R.

now apply (Z2R_lt 0 2).

apply Rplus_le_reg_r with (d - x)%R.

ring_simplify.

apply Rle_trans with (1 := H).

right. field.

apply Rle_minus.

apply (round_DN_pt beta fexp x).



assert (Hu: (d + ulp x)%R = round beta fexp Zceil x).

unfold d.

now rewrite <- round_UP_DN_ulp.

apply Rle_trans with (Rabs (d + ulp x - x)).

apply Hr2.

rewrite Hu.

apply (round_UP_pt beta fexp x).

rewrite Rabs_pos_eq.

apply Rmult_le_reg_r with 2%R.

now apply (Z2R_lt 0 2).

apply Rplus_le_reg_r with (- (d + ulp x - x))%R.

ring_simplify.

apply Rlt_le.

apply Rlt_le_trans with (1 := H).

right. field.

apply Rle_0_minus.

rewrite Hu.

apply (round_UP_pt beta fexp x).

Qed.



Theorem ulp_DN :

  forall x,

  (0 < round beta fexp Zfloor x)%R ->

  ulp (round beta fexp Zfloor x) = ulp x.

Proof with auto with typeclass_instances.

intros x Hd.

rewrite 2!ulp_neq_0.

now rewrite canonic_exp_DN with (2 := Hd).

intros T; contradict Hd; rewrite T, round_0...

apply Rlt_irrefl.

now apply Rgt_not_eq.

Qed.



Theorem round_neq_0_negligible_exp:

    negligible_exp=None -> forall rnd { Zrnd : Valid_rnd rnd } x,

   (x <> 0)%R ->  (round beta fexp rnd x <> 0)%R.

Proof with auto with typeclass_instances.

intros H rndn Hrnd x Hx K.

case negligible_exp_spec'.

intros (_,Hn).

destruct (ln_beta beta x) as (e,He).

absurd (fexp e < e)%Z.

apply Zle_not_lt.

apply exp_small_round_0 with beta rndn x...

apply (Hn e).

intros (n,(H1,_)).

rewrite H in H1; discriminate.

Qed.



Theorem error_lt_ulp_round :

  forall { Hm : Monotone_exp fexp } rnd { Zrnd : Valid_rnd rnd } x,

  ( x <> 0)%R ->

  (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.

Proof with auto with typeclass_instances.

intros Hm.



cut (forall rnd : R -> Z, Valid_rnd rnd -> forall x : R, (0 < x)%R  ->

    (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R).

intros M rnd Hrnd x Zx.

case (Rle_or_lt 0 x).

intros H; destruct H.

now apply M.

contradict H; now apply sym_not_eq.

intros H.

rewrite <- (Ropp_involutive x).

rewrite round_opp, ulp_opp.

replace (- round beta fexp (Zrnd_opp rnd) (- x) - - - x)%R with

    (-(round beta fexp (Zrnd_opp rnd) (- x) - (-x)))%R by ring.

rewrite Rabs_Ropp.

apply M.

now apply valid_rnd_opp.

now apply Ropp_0_gt_lt_contravar.



intros rnd Hrnd x Hx.

case (Rle_lt_or_eq_dec 0 (round beta fexp Zfloor x)).

apply round_ge_generic...

apply generic_format_0.

now left.



intros Hx2.

apply Rlt_le_trans with (ulp x).

apply error_lt_ulp...

now apply Rgt_not_eq.

rewrite <- ulp_DN; trivial.

apply ulp_le_pos.

now left.

case (round_DN_or_UP beta fexp rnd x); intros V; rewrite V.

apply Rle_refl.

apply Rle_trans with x.

apply round_DN_pt...

apply round_UP_pt...



intros Hx2.

case (round_DN_or_UP beta fexp rnd x); intros V; rewrite V; clear V.



rewrite <- Hx2.

unfold Rminus; rewrite Rplus_0_l, Rabs_Ropp.

unfold ulp; rewrite Req_bool_true; trivial.

case negligible_exp_spec.



intros K; contradict Hx2.

apply Rlt_not_eq.

apply F2R_gt_0_compat; simpl.

apply Zlt_le_trans with 1%Z.

apply Pos2Z.is_pos.

apply Zfloor_lub.

simpl; unfold scaled_mantissa, canonic_exp.

destruct (ln_beta beta x) as (e,He); simpl.

apply Rle_trans with (bpow (e-1) * bpow (- fexp e))%R.

rewrite <- bpow_plus.

replace 1%R with (bpow 0) by reflexivity.

apply bpow_le.

specialize (K e); omega.

apply Rmult_le_compat_r.

apply bpow_ge_0.

rewrite <- (Rabs_pos_eq x).

now apply He, Rgt_not_eq.

now left.



intros n Hn.

rewrite Rabs_pos_eq;[idtac|now left].

case (Rle_or_lt (bpow (fexp n)) x); trivial.

intros K; contradict Hx2.

apply Rlt_not_eq.

apply Rlt_le_trans with (bpow (fexp n)).

apply bpow_gt_0.

apply round_ge_generic...

apply generic_format_bpow.

now apply valid_exp.



apply Rlt_le_trans with (ulp x).

apply error_lt_ulp...

now apply Rgt_not_eq.

apply ulp_le_pos.

now left.

apply round_UP_pt...

Qed.



Theorem error_le_half_ulp_round :

  forall { Hm : Monotone_exp fexp },

  forall choice x,

  (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp (round beta fexp (Znearest choice) x))%R.

Proof with auto with typeclass_instances.

intros Hm choice x.

case (Req_dec (round beta fexp (Znearest choice) x) 0); intros Hfx.



case (Req_dec x 0); intros Hx.

apply Rle_trans with (1:=error_le_half_ulp _ _).

rewrite Hx, round_0...

right; ring.

generalize (error_le_half_ulp choice x).

rewrite Hfx.

unfold Rminus; rewrite Rplus_0_l, Rabs_Ropp.

intros N.

unfold ulp; rewrite Req_bool_true; trivial.

case negligible_exp_spec'.

intros (H1,H2).

contradict Hfx.

apply round_neq_0_negligible_exp...

intros (n,(H1,Hn)); rewrite H1.

apply Rle_trans with (1:=N).

right; apply f_equal.

rewrite ulp_neq_0; trivial.

apply f_equal.

unfold canonic_exp.

apply valid_exp; trivial.

assert (ln_beta beta x -1 < fexp n)%Z;[idtac|omega].

apply lt_bpow with beta.

destruct (ln_beta beta x) as (e,He).

simpl.

apply Rle_lt_trans with (Rabs x).

now apply He.

apply Rle_lt_trans with (Rabs (round beta fexp (Znearest choice) x - x)).

right; rewrite Hfx; unfold Rminus; rewrite Rplus_0_l.

apply sym_eq, Rabs_Ropp.

apply Rlt_le_trans with (ulp 0).

rewrite <- Hfx.

apply error_lt_ulp_round...

unfold ulp; rewrite Req_bool_true, H1; trivial.

now right.



case (round_DN_or_UP beta fexp (Znearest choice) x); intros Hx.



case (Rle_or_lt 0 (round beta fexp Zfloor x)).

intros H; destruct H.

rewrite Hx at 2.

rewrite ulp_DN; trivial.

apply error_le_half_ulp.

rewrite Hx in Hfx; contradict Hfx; auto with real.

intros H.

apply Rle_trans with (1:=error_le_half_ulp _ _).

apply Rmult_le_compat_l.

apply Rlt_le, pos_half_prf.

apply ulp_le.

rewrite Hx; rewrite (Rabs_left1 x), Rabs_left; try assumption.

apply Ropp_le_contravar.

apply (round_DN_pt beta fexp x).

case (Rle_or_lt x 0); trivial.

intros H1; contradict H.

apply Rle_not_lt.

apply round_ge_generic...

apply generic_format_0.

now left.



case (Rle_or_lt 0 (round beta fexp Zceil x)).

intros H; destruct H.

apply Rle_trans with (1:=error_le_half_ulp _ _).

apply Rmult_le_compat_l.

apply Rlt_le, pos_half_prf.

apply ulp_le_pos; trivial.

case (Rle_or_lt 0 x); trivial.

intros H1; contradict H.

apply Rle_not_lt.

apply round_le_generic...

apply generic_format_0.

now left.

rewrite Hx; apply (round_UP_pt beta fexp x).

rewrite Hx in Hfx; contradict Hfx; auto with real.

intros H.

rewrite Hx at 2; rewrite <- (ulp_opp (round beta fexp Zceil x)).

rewrite <- round_DN_opp.

rewrite ulp_DN; trivial.

pattern x at 1 2; rewrite <- Ropp_involutive.

rewrite round_N_opp.

unfold Rminus.

rewrite <- Ropp_plus_distr, Rabs_Ropp.

apply error_le_half_ulp.

rewrite round_DN_opp; apply Ropp_0_gt_lt_contravar; apply Rlt_gt; assumption.

Qed.



Theorem pred_le :

  forall x y, F x -> F y -> (x <= y)%R ->

  (pred x <= pred y)%R.

Proof.

intros x y Fx Fy [Hxy| ->].

2: apply Rle_refl.

apply le_pred_lt with (2 := Fy).

now apply generic_format_pred.

apply Rle_lt_trans with (2 := Hxy).

apply pred_le_id.

Qed.



Theorem succ_le: forall x y,

   F x -> F y -> (x <= y)%R -> (succ x <= succ y)%R.

Proof.

intros x y Fx Fy Hxy.

rewrite 2!succ_eq_opp_pred_opp.

apply Ropp_le_contravar, pred_le; try apply generic_format_opp; try assumption.

now apply Ropp_le_contravar.

Qed.



Theorem pred_le_inv: forall x y, F x -> F y

   -> (pred x <= pred y)%R -> (x <= y)%R.

Proof.

intros x y Fx Fy Hxy.

rewrite <- (succ_pred x), <- (succ_pred y); try assumption.

apply succ_le; trivial; now apply generic_format_pred.

Qed.



Theorem succ_le_inv: forall x y, F x -> F y

   -> (succ x <= succ y)%R -> (x <= y)%R.

Proof.

intros x y Fx Fy Hxy.

rewrite <- (pred_succ x), <- (pred_succ y); try assumption.

apply pred_le; trivial; now apply generic_format_succ.

Qed.



Theorem pred_lt :

  forall x y, F x -> F y -> (x < y)%R ->

  (pred x < pred y)%R.

Proof.

intros x y Fx Fy Hxy.

apply Rnot_le_lt.

intros H.

apply Rgt_not_le with (1 := Hxy).

now apply pred_le_inv.

Qed.



Theorem succ_lt :

  forall x y, F x -> F y -> (x < y)%R ->

  (succ x < succ y)%R.

Proof.

intros x y Fx Fy Hxy.

apply Rnot_le_lt.

intros H.

apply Rgt_not_le with (1 := Hxy).

now apply succ_le_inv.

Qed.



Theorem le_round_DN_lt_UP :

  forall x y, F y ->

  (y < round beta fexp Zceil x -> y <= round beta fexp Zfloor x)%R.

Proof with auto with typeclass_instances.

intros x y Fy Hlt.

apply round_DN_pt...

apply Rnot_lt_le.

contradict Hlt.

apply RIneq.Rle_not_lt.

apply round_UP_pt...

now apply Rlt_le.

Qed.



Theorem round_UP_le_gt_DN :

  forall x y, F y ->

   (round beta fexp Zfloor x < y -> round beta fexp Zceil x <= y)%R.

Proof with auto with typeclass_instances.

intros x y Fy Hlt.

apply round_UP_pt...

apply Rnot_lt_le.

contradict Hlt.

apply RIneq.Rle_not_lt.

apply round_DN_pt...

now apply Rlt_le.

Qed.



Theorem pred_UP_le_DN :

  forall x, (pred (round beta fexp Zceil x) <= round beta fexp Zfloor x)%R.

Proof with auto with typeclass_instances.

intros x.

destruct (generic_format_EM beta fexp x) as [Fx|Fx].

rewrite !round_generic...

apply pred_le_id.

case (Req_dec (round beta fexp Zceil x) 0); intros Zx.

rewrite Zx; unfold pred; rewrite Ropp_0.

unfold succ; rewrite Rle_bool_true;[idtac|now right].

rewrite Rplus_0_l; unfold ulp; rewrite Req_bool_true; trivial.

case negligible_exp_spec'.

intros (H1,H2).

contradict Zx; apply round_neq_0_negligible_exp...

intros L; apply Fx; rewrite L; apply generic_format_0.

intros (n,(H1,Hn)); rewrite H1.

case (Rle_or_lt (- bpow (fexp n)) (round beta fexp Zfloor x)); trivial; intros K.

absurd (round beta fexp Zceil x <= - bpow (fexp n))%R.

apply Rlt_not_le.

rewrite Zx, <- Ropp_0.

apply Ropp_lt_contravar, bpow_gt_0.

apply round_UP_le_gt_DN; try assumption.

apply generic_format_opp, generic_format_bpow.

now apply valid_exp.

assert (let u := round beta fexp Zceil x in pred u < u)%R as Hup.

now apply pred_lt_id.

apply le_round_DN_lt_UP...

apply generic_format_pred...

now apply round_UP_pt.

Qed.



Theorem pred_UP_eq_DN :

  forall x,  ~ F x ->

  (pred (round beta fexp Zceil x) = round beta fexp Zfloor x)%R.

Proof with auto with typeclass_instances.

intros x Fx.

apply Rle_antisym.

now apply pred_UP_le_DN.

apply le_pred_lt; try apply generic_format_round...

pose proof round_DN_UP_lt _ _ _ Fx as HE.

now apply Rlt_trans with (1 := proj1 HE) (2 := proj2 HE).

Qed.



Theorem succ_DN_eq_UP :

  forall x,  ~ F x ->

  (succ (round beta fexp Zfloor x) = round beta fexp Zceil x)%R.

Proof with auto with typeclass_instances.

intros x Fx.

rewrite <- pred_UP_eq_DN; trivial.

rewrite succ_pred; trivial.

apply generic_format_round...

Qed.



Theorem round_DN_eq_betw: forall x d, F d

     -> (d <= x < succ d)%R

        -> round beta fexp Zfloor x = d.

Proof with auto with typeclass_instances.

intros x d Fd (Hxd1,Hxd2).

generalize (round_DN_pt beta fexp x); intros (T1,(T2,T3)).

apply sym_eq, Rle_antisym.

now apply T3.

destruct (generic_format_EM beta fexp x) as [Fx|NFx].

rewrite round_generic...

apply succ_le_inv; try assumption.

apply succ_le_lt; try assumption.

apply generic_format_succ...

apply succ_le_inv; try assumption.

rewrite succ_DN_eq_UP; trivial.

apply round_UP_pt...

apply generic_format_succ...

now left.

Qed.



Theorem round_UP_eq_betw: forall x u, F u

    -> (pred u < x <= u)%R

    -> round beta fexp Zceil x = u.

Proof with auto with typeclass_instances.

intros x u Fu Hux.

rewrite <- (Ropp_involutive (round beta fexp Zceil x)).

rewrite <- round_DN_opp.

rewrite <- (Ropp_involutive u).

apply f_equal.

apply round_DN_eq_betw; try assumption.

now apply generic_format_opp.

split;[now apply Ropp_le_contravar|idtac].

rewrite succ_opp.

now apply Ropp_lt_contravar.

Qed.



Theorem round_N_le_midp: forall choice u v,

  F u -> (v < (u + succ u)/2)%R

      -> (round beta fexp (Znearest choice)  v <= u)%R.

Proof with auto with typeclass_instances.

intros choice u v Fu H.



assert (V: ((succ u = 0 /\ u = 0) \/ u < succ u)%R).

specialize (succ_ge_id u); intros P; destruct P as [P|P].

now right.

case (Req_dec u 0); intros Zu.

left; split; trivial.

now rewrite <- P.

right; now apply succ_gt_id.



destruct V as [(V1,V2)|V].

rewrite V2; apply round_le_generic...

apply generic_format_0.

left; apply Rlt_le_trans with (1:=H).

rewrite V1,V2; right; field.



assert (T: (u < (u + succ u) / 2 < succ u)%R) by lra.

destruct T as (T1,T2).

apply Rnd_N_pt_monotone with F v ((u + succ u) / 2)%R...

apply round_N_pt...

apply Rnd_DN_pt_N with (succ u)%R.

pattern u at 3; replace u with (round beta fexp Zfloor ((u + succ u) / 2)).

apply round_DN_pt...

apply round_DN_eq_betw; trivial.

split; try left; assumption.

pattern (succ u) at 2; replace (succ u) with (round beta fexp Zceil ((u + succ u) / 2)).

apply round_UP_pt...

apply round_UP_eq_betw; trivial.

apply generic_format_succ...

rewrite pred_succ; trivial.

split; try left; assumption.

right; field.

Qed.



Theorem round_N_ge_midp: forall choice u v,

 F u ->  ((u + pred u)/2 < v)%R

      -> (u <= round beta fexp (Znearest choice)  v)%R.

Proof with auto with typeclass_instances.

intros choice u v Fu H.

rewrite <- (Ropp_involutive v).

rewrite round_N_opp.

rewrite <- (Ropp_involutive u).

apply Ropp_le_contravar.

apply round_N_le_midp.

now apply generic_format_opp.

apply Ropp_lt_cancel.

rewrite Ropp_involutive.

apply Rle_lt_trans with (2:=H).

unfold pred.

right; field.

Qed.



Lemma round_N_eq_DN: forall choice x,

       let d:=round beta fexp Zfloor x in

       let u:=round beta fexp Zceil x in

      (x<(d+u)/2)%R ->

     round beta fexp (Znearest choice) x = d.

Proof with auto with typeclass_instances.

intros choice x d u H.

apply Rle_antisym.

destruct (generic_format_EM beta fexp x) as [Fx|Fx].

rewrite round_generic...

apply round_DN_pt; trivial; now right.

apply round_N_le_midp.

apply round_DN_pt...

apply Rlt_le_trans with (1:=H).

right; apply f_equal2; trivial; apply f_equal.

now apply sym_eq, succ_DN_eq_UP.

apply round_ge_generic; try apply round_DN_pt...

Qed.



Lemma round_N_eq_DN_pt: forall choice x d u,

      Rnd_DN_pt F x d -> Rnd_UP_pt F x u ->

      (x<(d+u)/2)%R ->

     round beta fexp (Znearest choice) x = d.

Proof with auto with typeclass_instances.

intros choice x d u Hd Hu H.

assert (H0:(d = round beta fexp Zfloor x)%R).

apply Rnd_DN_pt_unicity with (1:=Hd).

apply round_DN_pt...

rewrite H0.

apply round_N_eq_DN.

rewrite <- H0.

rewrite Rnd_UP_pt_unicity with F x (round beta fexp Zceil x) u; try assumption.

apply round_UP_pt...

Qed.



Lemma round_N_eq_UP: forall choice x,

      let d:=round beta fexp Zfloor x in

      let u:=round beta fexp Zceil x in

     ((d+u)/2 < x)%R ->

     round beta fexp (Znearest choice) x = u.

Proof with auto with typeclass_instances.

intros choice x d u H.

apply Rle_antisym.

apply round_le_generic; try apply round_UP_pt...

destruct (generic_format_EM beta fexp x) as [Fx|Fx].

rewrite round_generic...

apply round_UP_pt; trivial; now right.

apply round_N_ge_midp.

apply round_UP_pt...

apply Rle_lt_trans with (2:=H).

right; apply f_equal2; trivial; rewrite Rplus_comm; apply f_equal2; trivial.

now apply pred_UP_eq_DN.

Qed.



Lemma round_N_eq_UP_pt: forall choice x d u,

      Rnd_DN_pt F x d -> Rnd_UP_pt F x u ->

      ((d+u)/2 < x)%R ->

     round beta fexp (Znearest choice) x = u.

Proof with auto with typeclass_instances.

intros choice x d u Hd Hu H.

assert (H0:(u = round beta fexp Zceil x)%R).

apply Rnd_UP_pt_unicity with (1:=Hu).

apply round_UP_pt...

rewrite H0.

apply round_N_eq_UP.

rewrite <- H0.

rewrite Rnd_DN_pt_unicity with F x (round beta fexp Zfloor x) d; try assumption.

apply round_DN_pt...

Qed.



End Fcore_ulp.

