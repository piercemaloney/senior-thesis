

Require Import Fcore_Raux.
(* Fcore_Raux:
Require Export Reals.
Require Export ZArith.
Require Export Fcore_Zaux.

Section Rmissing.

Theorem Rle_0_minus :
  forall x y, (x <= y)%R -> (0 <= y - x)%R.

Theorem Rabs_eq_Rabs :
  forall x y : R,
  Rabs x = Rabs y -> x = y \/ x = Ropp y.

Theorem Rabs_minus_le:
  forall x y : R,
  (0 <= y)%R -> (y <= 2*x)%R ->
  (Rabs (x-y) <= x)%R.

Theorem Rplus_eq_reg_r :
  forall r r1 r2 : R,
  (r1 + r = r2 + r)%R -> (r1 = r2)%R.

Theorem Rplus_lt_reg_l :
  forall r r1 r2 : R,
  (r + r1 < r + r2)%R -> (r1 < r2)%R.

Theorem Rplus_lt_reg_r :
  forall r r1 r2 : R,
  (r1 + r < r2 + r)%R -> (r1 < r2)%R.

Theorem Rplus_le_reg_r :
  forall r r1 r2 : R,
  (r1 + r <= r2 + r)%R -> (r1 <= r2)%R.

Theorem Rmult_lt_reg_r :
  forall r r1 r2 : R, (0 < r)%R ->
  (r1 * r < r2 * r)%R -> (r1 < r2)%R.

Theorem Rmult_le_reg_r :
  forall r r1 r2 : R, (0 < r)%R ->
  (r1 * r <= r2 * r)%R -> (r1 <= r2)%R.

Theorem Rmult_lt_compat :
  forall r1 r2 r3 r4,
  (0 <= r1)%R -> (0 <= r3)%R -> (r1 < r2)%R -> (r3 < r4)%R ->
  (r1 * r3 < r2 * r4)%R.

Theorem Rmult_eq_reg_r :
  forall r r1 r2 : R, (r1 * r)%R = (r2 * r)%R ->
  r <> 0%R -> r1 = r2.

Theorem Rmult_minus_distr_r :
  forall r r1 r2 : R,
  ((r1 - r2) * r = r1 * r - r2 * r)%R.

Lemma Rmult_neq_reg_r: forall  r1 r2 r3:R, (r2 * r1 <> r3 * r1)%R -> r2 <> r3.

Lemma Rmult_neq_compat_r: forall  r1 r2 r3:R, (r1 <> 0)%R -> (r2 <> r3)%R
   -> (r2 *r1 <> r3*r1)%R.

Theorem Rmult_min_distr_r :
  forall r r1 r2 : R,
  (0 <= r)%R ->
  (Rmin r1 r2 * r)%R = Rmin (r1 * r) (r2 * r).

Theorem Rmult_min_distr_l :
  forall r r1 r2 : R,
  (0 <= r)%R ->
  (r * Rmin r1 r2)%R = Rmin (r * r1) (r * r2).

Lemma Rmin_opp: forall x y, (Rmin (-x) (-y) = - Rmax x y)%R.

Lemma Rmax_opp: forall x y, (Rmax (-x) (-y) = - Rmin x y)%R.

Theorem exp_le :
  forall x y : R,
  (x <= y)%R -> (exp x <= exp y)%R.

Theorem Rinv_lt :
  forall x y,
  (0 < x)%R -> (x < y)%R -> (/y < /x)%R.

Theorem Rinv_le :
  forall x y,
  (0 < x)%R -> (x <= y)%R -> (/y <= /x)%R.

Theorem sqrt_ge_0 :
  forall x : R,
  (0 <= sqrt x)%R.

Lemma sqrt_neg : forall x, (x <= 0)%R -> (sqrt x = 0)%R.

Theorem Rabs_le :
  forall x y,
  (-y <= x <= y)%R -> (Rabs x <= y)%R.

Theorem Rabs_le_inv :
  forall x y,
  (Rabs x <= y)%R -> (-y <= x <= y)%R.

Theorem Rabs_ge :
  forall x y,
  (y <= -x \/ x <= y)%R -> (x <= Rabs y)%R.

Theorem Rabs_ge_inv :
  forall x y,
  (x <= Rabs y)%R -> (y <= -x \/ x <= y)%R.

Theorem Rabs_lt :
  forall x y,
  (-y < x < y)%R -> (Rabs x < y)%R.

Theorem Rabs_lt_inv :
  forall x y,
  (Rabs x < y)%R -> (-y < x < y)%R.

Theorem Rabs_gt :
  forall x y,
  (y < -x \/ x < y)%R -> (x < Rabs y)%R.

Theorem Rabs_gt_inv :
  forall x y,
  (x < Rabs y)%R -> (y < -x \/ x < y)%R.

End Rmissing.

Section Z2R.

Fixpoint P2R (p : positive) :=
  match p with
  | xH => 1%R
  | xO xH => 2%R
  | xO t => (2 * P2R t)%R
  | xI xH => 3%R
  | xI t => (1 + 2 * P2R t)%R
  end.

Definition Z2R n :=
  match n with
  | Zpos p => P2R p
  | Zneg p => Ropp (P2R p)
  | Z0 => 0%R
  end.

Theorem P2R_INR :
  forall n, P2R n = INR (nat_of_P n).

Theorem Z2R_IZR :
  forall n, Z2R n = IZR n.

Theorem Z2R_opp :
  forall n, Z2R (-n) = (- Z2R n)%R.

Theorem Z2R_plus :
  forall m n, (Z2R (m + n) = Z2R m + Z2R n)%R.

Theorem minus_IZR :
  forall n m : Z,
  IZR (n - m) = (IZR n - IZR m)%R.

Theorem Z2R_minus :
  forall m n, (Z2R (m - n) = Z2R m - Z2R n)%R.

Theorem Z2R_mult :
  forall m n, (Z2R (m * n) = Z2R m * Z2R n)%R.

Theorem le_Z2R :
  forall m n, (Z2R m <= Z2R n)%R -> (m <= n)%Z.

Theorem Z2R_le :
  forall m n, (m <= n)%Z -> (Z2R m <= Z2R n)%R.

Theorem lt_Z2R :
  forall m n, (Z2R m < Z2R n)%R -> (m < n)%Z.

Theorem Z2R_lt :
  forall m n, (m < n)%Z -> (Z2R m < Z2R n)%R.

Theorem Z2R_le_lt :
  forall m n p, (m <= n < p)%Z -> (Z2R m <= Z2R n < Z2R p)%R.

Theorem le_lt_Z2R :
  forall m n p, (Z2R m <= Z2R n < Z2R p)%R -> (m <= n < p)%Z.

Theorem eq_Z2R :
  forall m n, (Z2R m = Z2R n)%R -> (m = n)%Z.

Theorem neq_Z2R :
  forall m n, (Z2R m <> Z2R n)%R -> (m <> n)%Z.

Theorem Z2R_neq :
  forall m n, (m <> n)%Z -> (Z2R m <> Z2R n)%R.

Theorem Z2R_abs :
  forall z, Z2R (Zabs z) = Rabs (Z2R z).

End Z2R.

Section Rcompare.

Definition Rcompare x y :=
  match total_order_T x y with
  | inleft (left _) => Lt
  | inleft (right _) => Eq
  | inright _ => Gt
  end.

Inductive Rcompare_prop (x y : R) : comparison -> Prop :=
  | Rcompare_Lt_ : (x < y)%R -> Rcompare_prop x y Lt
  | Rcompare_Eq_ : x = y -> Rcompare_prop x y Eq
  | Rcompare_Gt_ : (y < x)%R -> Rcompare_prop x y Gt.

Theorem Rcompare_spec :
  forall x y, Rcompare_prop x y (Rcompare x y).

Global Opaque Rcompare.

Theorem Rcompare_Lt :
  forall x y,
  (x < y)%R -> Rcompare x y = Lt.

Theorem Rcompare_Lt_inv :
  forall x y,
  Rcompare x y = Lt -> (x < y)%R.

Theorem Rcompare_not_Lt :
  forall x y,
  (y <= x)%R -> Rcompare x y <> Lt.

Theorem Rcompare_not_Lt_inv :
  forall x y,
  Rcompare x y <> Lt -> (y <= x)%R.

Theorem Rcompare_Eq :
  forall x y,
  x = y -> Rcompare x y = Eq.

Theorem Rcompare_Eq_inv :
  forall x y,
  Rcompare x y = Eq -> x = y.

Theorem Rcompare_Gt :
  forall x y,
  (y < x)%R -> Rcompare x y = Gt.

Theorem Rcompare_Gt_inv :
  forall x y,
  Rcompare x y = Gt -> (y < x)%R.

Theorem Rcompare_not_Gt :
  forall x y,
  (x <= y)%R -> Rcompare x y <> Gt.

Theorem Rcompare_not_Gt_inv :
  forall x y,
  Rcompare x y <> Gt -> (x <= y)%R.

Theorem Rcompare_Z2R :
  forall x y, Rcompare (Z2R x) (Z2R y) = Zcompare x y.

Theorem Rcompare_sym :
  forall x y,
  Rcompare x y = CompOpp (Rcompare y x).

Theorem Rcompare_plus_r :
  forall z x y,
  Rcompare (x + z) (y + z) = Rcompare x y.

Theorem Rcompare_plus_l :
  forall z x y,
  Rcompare (z + x) (z + y) = Rcompare x y.

Theorem Rcompare_mult_r :
  forall z x y,
  (0 < z)%R ->
  Rcompare (x * z) (y * z) = Rcompare x y.

Theorem Rcompare_mult_l :
  forall z x y,
  (0 < z)%R ->
  Rcompare (z * x) (z * y) = Rcompare x y.

Theorem Rcompare_middle :
  forall x d u,
  Rcompare (x - d) (u - x) = Rcompare x ((d + u) / 2).

Theorem Rcompare_half_l :
  forall x y, Rcompare (x / 2) y = Rcompare x (2 * y).

Theorem Rcompare_half_r :
  forall x y, Rcompare x (y / 2) = Rcompare (2 * x) y.

Theorem Rcompare_sqr :
  forall x y,
  (0 <= x)%R -> (0 <= y)%R ->
  Rcompare (x * x) (y * y) = Rcompare x y.

Theorem Rmin_compare :
  forall x y,
  Rmin x y = match Rcompare x y with Lt => x | Eq => x | Gt => y end.

End Rcompare.

Section Rle_bool.

Definition Rle_bool x y :=
  match Rcompare x y with
  | Gt => false
  | _ => true
  end.

Inductive Rle_bool_prop (x y : R) : bool -> Prop :=
  | Rle_bool_true_ : (x <= y)%R -> Rle_bool_prop x y true
  | Rle_bool_false_ : (y < x)%R -> Rle_bool_prop x y false.

Theorem Rle_bool_spec :
  forall x y, Rle_bool_prop x y (Rle_bool x y).

Theorem Rle_bool_true :
  forall x y,
  (x <= y)%R -> Rle_bool x y = true.

Theorem Rle_bool_false :
  forall x y,
  (y < x)%R -> Rle_bool x y = false.

End Rle_bool.

Section Rlt_bool.

Definition Rlt_bool x y :=
  match Rcompare x y with
  | Lt => true
  | _ => false
  end.

Inductive Rlt_bool_prop (x y : R) : bool -> Prop :=
  | Rlt_bool_true_ : (x < y)%R -> Rlt_bool_prop x y true
  | Rlt_bool_false_ : (y <= x)%R -> Rlt_bool_prop x y false.

Theorem Rlt_bool_spec :
  forall x y, Rlt_bool_prop x y (Rlt_bool x y).

Theorem negb_Rlt_bool :
  forall x y,
  negb (Rle_bool x y) = Rlt_bool y x.

Theorem negb_Rle_bool :
  forall x y,
  negb (Rlt_bool x y) = Rle_bool y x.

Theorem Rlt_bool_true :
  forall x y,
  (x < y)%R -> Rlt_bool x y = true.

Theorem Rlt_bool_false :
  forall x y,
  (y <= x)%R -> Rlt_bool x y = false.

End Rlt_bool.

Section Req_bool.

Definition Req_bool x y :=
  match Rcompare x y with
  | Eq => true
  | _ => false
  end.

Inductive Req_bool_prop (x y : R) : bool -> Prop :=
  | Req_bool_true_ : (x = y)%R -> Req_bool_prop x y true
  | Req_bool_false_ : (x <> y)%R -> Req_bool_prop x y false.

Theorem Req_bool_spec :
  forall x y, Req_bool_prop x y (Req_bool x y).

Theorem Req_bool_true :
  forall x y,
  (x = y)%R -> Req_bool x y = true.

Theorem Req_bool_false :
  forall x y,
  (x <> y)%R -> Req_bool x y = false.

End Req_bool.

Section Floor_Ceil.

Definition Zfloor (x : R) := (up x - 1)%Z.

Theorem Zfloor_lb :
  forall x : R,
  (Z2R (Zfloor x) <= x)%R.

Theorem Zfloor_ub :
  forall x : R,
  (x < Z2R (Zfloor x) + 1)%R.

Theorem Zfloor_lub :
  forall n x,
  (Z2R n <= x)%R ->
  (n <= Zfloor x)%Z.

Theorem Zfloor_imp :
  forall n x,
  (Z2R n <= x < Z2R (n + 1))%R ->
  Zfloor x = n.

Theorem Zfloor_Z2R :
  forall n,
  Zfloor (Z2R n) = n.

Theorem Zfloor_le :
  forall x y, (x <= y)%R ->
  (Zfloor x <= Zfloor y)%Z.

Definition Zceil (x : R) := (- Zfloor (- x))%Z.

Theorem Zceil_ub :
  forall x : R,
  (x <= Z2R (Zceil x))%R.

Theorem Zceil_glb :
  forall n x,
  (x <= Z2R n)%R ->
  (Zceil x <= n)%Z.

Theorem Zceil_imp :
  forall n x,
  (Z2R (n - 1) < x <= Z2R n)%R ->
  Zceil x = n.

Theorem Zceil_Z2R :
  forall n,
  Zceil (Z2R n) = n.

Theorem Zceil_le :
  forall x y, (x <= y)%R ->
  (Zceil x <= Zceil y)%Z.

Theorem Zceil_floor_neq :
  forall x : R,
  (Z2R (Zfloor x) <> x)%R ->
  (Zceil x = Zfloor x + 1)%Z.

Definition Ztrunc x := if Rlt_bool x 0 then Zceil x else Zfloor x.

Theorem Ztrunc_Z2R :
  forall n,
  Ztrunc (Z2R n) = n.

Theorem Ztrunc_floor :
  forall x,
  (0 <= x)%R ->
  Ztrunc x = Zfloor x.

Theorem Ztrunc_ceil :
  forall x,
  (x <= 0)%R ->
  Ztrunc x = Zceil x.

Theorem Ztrunc_le :
  forall x y, (x <= y)%R ->
  (Ztrunc x <= Ztrunc y)%Z.

Theorem Ztrunc_opp :
  forall x,
  Ztrunc (- x) = Zopp (Ztrunc x).

Theorem Ztrunc_abs :
  forall x,
  Ztrunc (Rabs x) = Zabs (Ztrunc x).

Theorem Ztrunc_lub :
  forall n x,
  (Z2R n <= Rabs x)%R ->
  (n <= Zabs (Ztrunc x))%Z.

Definition Zaway x := if Rlt_bool x 0 then Zfloor x else Zceil x.

Theorem Zaway_Z2R :
  forall n,
  Zaway (Z2R n) = n.

Theorem Zaway_ceil :
  forall x,
  (0 <= x)%R ->
  Zaway x = Zceil x.

Theorem Zaway_floor :
  forall x,
  (x <= 0)%R ->
  Zaway x = Zfloor x.

Theorem Zaway_le :
  forall x y, (x <= y)%R ->
  (Zaway x <= Zaway y)%Z.

Theorem Zaway_opp :
  forall x,
  Zaway (- x) = Zopp (Zaway x).

Theorem Zaway_abs :
  forall x,
  Zaway (Rabs x) = Zabs (Zaway x).

End Floor_Ceil.

Section Zdiv_Rdiv.

Theorem Zfloor_div :
  forall x y,
  y <> Z0 ->
  Zfloor (Z2R x / Z2R y) = (x / y)%Z.

End Zdiv_Rdiv.

Section pow.

Variable r : radix.

Theorem radix_pos : (0 < Z2R r)%R.

Definition bpow e :=
  match e with
  | Zpos p => Z2R (Zpower_pos r p)
  | Zneg p => Rinv (Z2R (Zpower_pos r p))
  | Z0 => 1%R
  end.

Theorem Z2R_Zpower_pos :
  forall n m,
  Z2R (Zpower_pos n m) = powerRZ (Z2R n) (Zpos m).

Theorem bpow_powerRZ :
  forall e,
  bpow e = powerRZ (Z2R r) e.

Theorem  bpow_ge_0 :
  forall e : Z, (0 <= bpow e)%R.

Theorem bpow_gt_0 :
  forall e : Z, (0 < bpow e)%R.

Theorem bpow_plus :
  forall e1 e2 : Z, (bpow (e1 + e2) = bpow e1 * bpow e2)%R.

Theorem bpow_1 :
  bpow 1 = Z2R r.

Theorem bpow_plus1 :
  forall e : Z, (bpow (e + 1) = Z2R r * bpow e)%R.

Theorem bpow_opp :
  forall e : Z, (bpow (-e) = /bpow e)%R.

Theorem Z2R_Zpower_nat :
  forall e : nat,
  Z2R (Zpower_nat r e) = bpow (Z_of_nat e).

Theorem Z2R_Zpower :
  forall e : Z,
  (0 <= e)%Z ->
  Z2R (Zpower r e) = bpow e.

Theorem bpow_lt :
  forall e1 e2 : Z,
  (e1 < e2)%Z -> (bpow e1 < bpow e2)%R.

Theorem lt_bpow :
  forall e1 e2 : Z,
  (bpow e1 < bpow e2)%R -> (e1 < e2)%Z.

Theorem bpow_le :
  forall e1 e2 : Z,
  (e1 <= e2)%Z -> (bpow e1 <= bpow e2)%R.

Theorem le_bpow :
  forall e1 e2 : Z,
  (bpow e1 <= bpow e2)%R -> (e1 <= e2)%Z.

Theorem bpow_inj :
  forall e1 e2 : Z,
  bpow e1 = bpow e2 -> e1 = e2.

Theorem bpow_exp :
  forall e : Z,
  bpow e = exp (Z2R e * ln (Z2R r)).

Record ln_beta_prop x := {
  ln_beta_val :> Z ;
  _ : (x <> 0)%R -> (bpow (ln_beta_val - 1)%Z <= Rabs x < bpow ln_beta_val)%R
}.

Definition ln_beta :
  forall x : R, ln_beta_prop x.

Theorem bpow_lt_bpow :
  forall e1 e2,
  (bpow (e1 - 1) < bpow e2)%R ->
  (e1 <= e2)%Z.

Theorem bpow_unique :
  forall x e1 e2,
  (bpow (e1 - 1) <= x < bpow e1)%R ->
  (bpow (e2 - 1) <= x < bpow e2)%R ->
  e1 = e2.

Theorem ln_beta_unique :
  forall (x : R) (e : Z),
  (bpow (e - 1) <= Rabs x < bpow e)%R ->
  ln_beta x = e :> Z.

Theorem ln_beta_opp :
  forall x,
  ln_beta (-x) = ln_beta x :> Z.

Theorem ln_beta_abs :
  forall x,
  ln_beta (Rabs x) = ln_beta x :> Z.

Theorem ln_beta_unique_pos :
  forall (x : R) (e : Z),
  (bpow (e - 1) <= x < bpow e)%R ->
  ln_beta x = e :> Z.

Theorem ln_beta_le_abs :
  forall x y,
  (x <> 0)%R -> (Rabs x <= Rabs y)%R ->
  (ln_beta x <= ln_beta y)%Z.

Theorem ln_beta_le :
  forall x y,
  (0 < x)%R -> (x <= y)%R ->
  (ln_beta x <= ln_beta y)%Z.

Lemma ln_beta_lt_pos :
  forall x y,
  (0 < y)%R ->
  (ln_beta x < ln_beta y)%Z -> (x < y)%R.

Theorem ln_beta_bpow :
  forall e, (ln_beta (bpow e) = e + 1 :> Z)%Z.

Theorem ln_beta_mult_bpow :
  forall x e, x <> 0%R ->
  (ln_beta (x * bpow e) = ln_beta x + e :>Z)%Z.

Theorem ln_beta_le_bpow :
  forall x e,
  x <> 0%R ->
  (Rabs x < bpow e)%R ->
  (ln_beta x <= e)%Z.

Theorem ln_beta_gt_bpow :
  forall x e,
  (bpow e <= Rabs x)%R ->
  (e < ln_beta x)%Z.

Theorem ln_beta_ge_bpow :
  forall x e,
  (bpow (e - 1) <= Rabs x)%R ->
  (e <= ln_beta x)%Z.

Theorem bpow_ln_beta_gt :
  forall x,
  (Rabs x < bpow (ln_beta x))%R.

Theorem bpow_ln_beta_le :
  forall x, (x <> 0)%R ->
    (bpow (ln_beta x-1) <= Rabs x)%R.

Theorem ln_beta_le_Zpower :
  forall m e,
  m <> Z0 ->
  (Zabs m < Zpower r e)%Z->
  (ln_beta (Z2R m) <= e)%Z.

Theorem ln_beta_gt_Zpower :
  forall m e,
  m <> Z0 ->
  (Zpower r e <= Zabs m)%Z ->
  (e < ln_beta (Z2R m))%Z.

Lemma ln_beta_mult :
  forall x y,
  (x <> 0)%R -> (y <> 0)%R ->
  (ln_beta x + ln_beta y - 1 <= ln_beta (x * y) <= ln_beta x + ln_beta y)%Z.

Lemma ln_beta_plus :
  forall x y,
  (0 < y)%R -> (y <= x)%R ->
  (ln_beta x <= ln_beta (x + y) <= ln_beta x + 1)%Z.

Lemma ln_beta_minus :
  forall x y,
  (0 < y)%R -> (y < x)%R ->
  (ln_beta (x - y) <= ln_beta x)%Z.

Lemma ln_beta_minus_lb :
  forall x y,
  (0 < x)%R -> (0 < y)%R ->
  (ln_beta y <= ln_beta x - 2)%Z ->
  (ln_beta x - 1 <= ln_beta (x - y))%Z.

Lemma ln_beta_div :
  forall x y : R,
  (0 < x)%R -> (0 < y)%R ->
  (ln_beta x - ln_beta y <= ln_beta (x / y) <= ln_beta x - ln_beta y + 1)%Z.

Lemma ln_beta_sqrt :
  forall x,
  (0 < x)%R ->
  (2 * ln_beta (sqrt x) - 1 <= ln_beta x <= 2 * ln_beta (sqrt x))%Z.

End pow.

Section Bool.

Theorem eqb_sym :
  forall x y, Bool.eqb x y = Bool.eqb y x.

Theorem eqb_false :
  forall x y, x = negb y -> Bool.eqb x y = false.

Theorem eqb_true :
  forall x y, x = y -> Bool.eqb x y = true.

End Bool.

Section cond_Ropp.

Definition cond_Ropp (b : bool) m := if b then Ropp m else m.

Theorem Z2R_cond_Zopp :
  forall b m,
  Z2R (cond_Zopp b m) = cond_Ropp b (Z2R m).

Theorem abs_cond_Ropp :
  forall b m,
  Rabs (cond_Ropp b m) = Rabs m.

Theorem cond_Ropp_Rlt_bool :
  forall m,
  cond_Ropp (Rlt_bool m 0) m = Rabs m.

Theorem cond_Ropp_involutive :
  forall b x,
  cond_Ropp b (cond_Ropp b x) = x.

Theorem cond_Ropp_even_function :
  forall {A : Type} (f : R -> A),
  (forall x, f (Ropp x) = f x) ->
  forall b x, f (cond_Ropp b x) = f x.

Theorem cond_Ropp_odd_function :
  forall (f : R -> R),
  (forall x, f (Ropp x) = Ropp (f x)) ->
  forall b x, f (cond_Ropp b x) = cond_Ropp b (f x).

Theorem cond_Ropp_inj :
  forall b x y,
  cond_Ropp b x = cond_Ropp b y -> x = y.

Theorem cond_Ropp_mult_l :
  forall b x y,
  cond_Ropp b (x * y) = (cond_Ropp b x * y)%R.

Theorem cond_Ropp_mult_r :
  forall b x y,
  cond_Ropp b (x * y) = (x * cond_Ropp b y)%R.

Theorem cond_Ropp_plus :
  forall b x y,
  cond_Ropp b (x + y) = (cond_Ropp b x + cond_Ropp b y)%R.

End cond_Ropp.

Theorem LPO_min :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n /\ forall i, (i < n)%nat -> ~ P i} + {forall n, ~ P n}.

Theorem LPO :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n} + {forall n, ~ P n}.

Lemma LPO_Z : forall P : Z -> Prop, (forall n, P n \/ ~P n) ->
  {n : Z| P n} + {forall n, ~ P n}.

Ltac bpow_simplify :=
  
  repeat
    match goal with
      | |- context [(bpow _ _ * bpow _ _)] =>
        rewrite <- bpow_plus
      | |- context [(?X1 * bpow _ _ * bpow _ _)] =>
        rewrite (Rmult_assoc X1); rewrite <- bpow_plus
      | |- context [(?X1 * (?X2 * bpow _ _) * bpow _ _)] =>
        rewrite <- (Rmult_assoc X1 X2); rewrite (Rmult_assoc (X1 * X2));
        rewrite <- bpow_plus
    end;
  
  repeat
    match goal with
      | |- context [(bpow _ ?X)] =>
        progress ring_simplify X
    end;
  
  change (bpow _ 0) with 1;
  repeat
    match goal with
      | |- context [(_ * 1)] =>
        rewrite Rmult_1_r
    end. *)

Require Import Fcore_defs.
(* Fcore_defs:
Require Import Fcore_Raux.

Section Def.

Record float (beta : radix) := Float { Fnum : Z ; Fexp : Z }.

Arguments Fnum {beta} f.
Arguments Fexp {beta} f.

Variable beta : radix.

Definition F2R (f : float beta) :=
  (Z2R (Fnum f) * bpow beta (Fexp f))%R.

Definition round_pred_total (P : R -> R -> Prop) :=
  forall x, exists f, P x f.

Definition round_pred_monotone (P : R -> R -> Prop) :=
  forall x y f g, P x f -> P y g -> (x <= y)%R -> (f <= g)%R.

Definition round_pred (P : R -> R -> Prop) :=
  round_pred_total P /\
  round_pred_monotone P.

End Def.

Arguments Fnum {beta} f.
Arguments Fexp {beta} f.
Arguments F2R {beta} f.

Section RND.

Definition Rnd_DN_pt (F : R -> Prop) (x f : R) :=
  F f /\ (f <= x)%R /\
  forall g : R, F g -> (g <= x)%R -> (g <= f)%R.

Definition Rnd_DN (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_DN_pt F x (rnd x).

Definition Rnd_UP_pt (F : R -> Prop) (x f : R) :=
  F f /\ (x <= f)%R /\
  forall g : R, F g -> (x <= g)%R -> (f <= g)%R.

Definition Rnd_UP (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_UP_pt F x (rnd x).

Definition Rnd_ZR_pt (F : R -> Prop) (x f : R) :=
  ( (0 <= x)%R -> Rnd_DN_pt F x f ) /\
  ( (x <= 0)%R -> Rnd_UP_pt F x f ).

Definition Rnd_ZR (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_ZR_pt F x (rnd x).

Definition Rnd_N_pt (F : R -> Prop) (x f : R) :=
  F f /\
  forall g : R, F g -> (Rabs (f - x) <= Rabs (g - x))%R.

Definition Rnd_N (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_N_pt F x (rnd x).

Definition Rnd_NG_pt (F : R -> Prop) (P : R -> R -> Prop) (x f : R) :=
  Rnd_N_pt F x f /\
  ( P x f \/ forall f2 : R, Rnd_N_pt F x f2 -> f2 = f ).

Definition Rnd_NG (F : R -> Prop) (P : R -> R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_NG_pt F P x (rnd x).

Definition Rnd_NA_pt (F : R -> Prop) (x f : R) :=
  Rnd_N_pt F x f /\
  forall f2 : R, Rnd_N_pt F x f2 -> (Rabs f2 <= Rabs f)%R.

Definition Rnd_NA (F : R -> Prop) (rnd : R -> R) :=
  forall x : R, Rnd_NA_pt F x (rnd x).

End RND. *)

Require Import Fcore_generic_fmt.
(* Fcore_generic_fmt:
Require Import Fcore_Raux.
Require Import Fcore_defs.
Require Import Fcore_rnd.
Require Import Fcore_float_prop.

Section Generic.

Variable beta : radix.

Notation bpow e := (bpow beta e).

Section Format.

Variable fexp : Z -> Z.

Class Valid_exp :=
  valid_exp :
  forall k : Z,
  ( (fexp k < k)%Z -> (fexp (k + 1) <= k)%Z ) /\
  ( (k <= fexp k)%Z ->
    (fexp (fexp k + 1) <= fexp k)%Z /\
    forall l : Z, (l <= fexp k)%Z -> fexp l = fexp k ).

Context { valid_exp_ : Valid_exp }.

Theorem valid_exp_large :
  forall k l,
  (fexp k < k)%Z -> (k <= l)%Z ->
  (fexp l < l)%Z.

Theorem valid_exp_large' :
  forall k l,
  (fexp k < k)%Z -> (l <= k)%Z ->
  (fexp l < k)%Z.

Definition canonic_exp x :=
  fexp (ln_beta beta x).

Definition canonic (f : float beta) :=
  Fexp f = canonic_exp (F2R f).

Definition scaled_mantissa x :=
  (x * bpow (- canonic_exp x))%R.

Definition generic_format (x : R) :=
  x = F2R (Float beta (Ztrunc (scaled_mantissa x)) (canonic_exp x)).

Theorem generic_format_0 :
  generic_format 0.

Theorem canonic_exp_opp :
  forall x,
  canonic_exp (-x) = canonic_exp x.

Theorem canonic_exp_abs :
  forall x,
  canonic_exp (Rabs x) = canonic_exp x.

Theorem generic_format_bpow :
  forall e, (fexp (e + 1) <= e)%Z ->
  generic_format (bpow e).

Theorem generic_format_bpow' :
  forall e, (fexp e <= e)%Z ->
  generic_format (bpow e).

Theorem generic_format_F2R :
  forall m e,
  ( m <> 0 -> canonic_exp (F2R (Float beta m e)) <= e )%Z ->
  generic_format (F2R (Float beta m e)).

Lemma generic_format_F2R': forall (x:R) (f:float beta),
       F2R f = x -> ((x <> 0)%R ->
       (canonic_exp x <= Fexp f)%Z) ->
       generic_format x.

Theorem canonic_opp :
  forall m e,
  canonic (Float beta m e) ->
  canonic (Float beta (-m) e).

Theorem canonic_abs :
  forall m e,
  canonic (Float beta m e) ->
  canonic (Float beta (Zabs m) e).

Theorem canonic_0: canonic (Float beta 0 (fexp (ln_beta beta 0%R))).

Theorem canonic_unicity :
  forall f1 f2,
  canonic f1 ->
  canonic f2 ->
  F2R f1 = F2R f2 ->
  f1 = f2.

Theorem scaled_mantissa_generic :
  forall x,
  generic_format x ->
  scaled_mantissa x = Z2R (Ztrunc (scaled_mantissa x)).

Theorem scaled_mantissa_mult_bpow :
  forall x,
  (scaled_mantissa x * bpow (canonic_exp x))%R = x.

Theorem scaled_mantissa_0 :
  scaled_mantissa 0 = 0%R.

Theorem scaled_mantissa_opp :
  forall x,
  scaled_mantissa (-x) = (-scaled_mantissa x)%R.

Theorem scaled_mantissa_abs :
  forall x,
  scaled_mantissa (Rabs x) = Rabs (scaled_mantissa x).

Theorem generic_format_opp :
  forall x, generic_format x -> generic_format (-x).

Theorem generic_format_abs :
  forall x, generic_format x -> generic_format (Rabs x).

Theorem generic_format_abs_inv :
  forall x, generic_format (Rabs x) -> generic_format x.

Theorem canonic_exp_fexp :
  forall x ex,
  (bpow (ex - 1) <= Rabs x < bpow ex)%R ->
  canonic_exp x = fexp ex.

Theorem canonic_exp_fexp_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  canonic_exp x = fexp ex.

Theorem mantissa_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  (0 < x * bpow (- fexp ex) < 1)%R.

Theorem scaled_mantissa_small :
  forall x ex,
  (Rabs x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  (Rabs (scaled_mantissa x) < 1)%R.

Theorem abs_scaled_mantissa_lt_bpow :
  forall x,
  (Rabs (scaled_mantissa x) < bpow (ln_beta beta x - canonic_exp x))%R.

Theorem ln_beta_generic_gt :
  forall x, (x <> 0)%R ->
  generic_format x ->
  (canonic_exp x < ln_beta beta x)%Z.

Theorem mantissa_DN_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  Zfloor (x * bpow (- fexp ex)) = Z0.

Theorem mantissa_UP_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  Zceil (x * bpow (- fexp ex)) = 1%Z.

Theorem generic_format_discrete :
  forall x m,
  let e := canonic_exp x in
  (F2R (Float beta m e) < x < F2R (Float beta (m + 1) e))%R ->
  ~ generic_format x.

Theorem generic_format_canonic :
  forall f, canonic f ->
  generic_format (F2R f).

Theorem generic_format_ge_bpow :
  forall emin,
  ( forall e, (emin <= fexp e)%Z ) ->
  forall x,
  (0 < x)%R ->
  generic_format x ->
  (bpow emin <= x)%R.

Theorem abs_lt_bpow_prec:
  forall prec,
  (forall e, (e - prec <= fexp e)%Z) ->
  
  forall x,
  (Rabs x < bpow (prec + canonic_exp x))%R.

Theorem generic_format_bpow_inv' :
  forall e,
  generic_format (bpow e) ->
  (fexp (e + 1) <= e)%Z.

Theorem generic_format_bpow_inv :
  forall e,
  generic_format (bpow e) ->
  (fexp e <= e)%Z.

Section Fcore_generic_round_pos.

Variable rnd : R -> Z.

Class Valid_rnd := {
  Zrnd_le : forall x y, (x <= y)%R -> (rnd x <= rnd y)%Z ;
  Zrnd_Z2R : forall n, rnd (Z2R n) = n
}.

Context { valid_rnd : Valid_rnd }.

Theorem Zrnd_DN_or_UP :
  forall x, rnd x = Zfloor x \/ rnd x = Zceil x.

Theorem Zrnd_ZR_or_AW :
  forall x, rnd x = Ztrunc x \/ rnd x = Zaway x.

Definition round x :=
  F2R (Float beta (rnd (scaled_mantissa x)) (canonic_exp x)).

Theorem round_bounded_large_pos :
  forall x ex,
  (fexp ex < ex)%Z ->
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (bpow (ex - 1) <= round x <= bpow ex)%R.

Theorem round_bounded_small_pos :
  forall x ex,
  (ex <= fexp ex)%Z ->
  (bpow (ex - 1) <= x < bpow ex)%R ->
  round x = 0%R \/ round x = bpow (fexp ex).

Theorem round_le_pos :
  forall x y, (0 < x)%R -> (x <= y)%R -> (round x <= round y)%R.

Theorem round_generic :
  forall x,
  generic_format x ->
  round x = x.

Theorem round_0 :
  round 0 = 0%R.

Theorem exp_small_round_0_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  round x = 0%R -> (ex <= fexp ex)%Z .

Theorem generic_format_round_pos :
  forall x,
  (0 < x)%R ->
  generic_format (round x).

End Fcore_generic_round_pos.

Theorem round_ext :
  forall rnd1 rnd2,
  ( forall x, rnd1 x = rnd2 x ) ->
  forall x,
  round rnd1 x = round rnd2 x.

Section Zround_opp.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Definition Zrnd_opp x := Zopp (rnd (-x)).

Global Instance valid_rnd_opp : Valid_rnd Zrnd_opp.

Theorem round_opp :
  forall x,
  round rnd (- x) = Ropp (round Zrnd_opp x).

End Zround_opp.

Global Instance valid_rnd_DN : Valid_rnd Zfloor.

Global Instance valid_rnd_UP : Valid_rnd Zceil.

Global Instance valid_rnd_ZR : Valid_rnd Ztrunc.

Global Instance valid_rnd_AW : Valid_rnd Zaway.

Section monotone.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem round_DN_or_UP :
  forall x,
  round rnd x = round Zfloor x \/ round rnd x = round Zceil x.

Theorem round_ZR_or_AW :
  forall x,
  round rnd x = round Ztrunc x \/ round rnd x = round Zaway x.

Theorem round_le :
  forall x y, (x <= y)%R -> (round rnd x <= round rnd y)%R.

Theorem round_ge_generic :
  forall x y, generic_format x -> (x <= y)%R -> (x <= round rnd y)%R.

Theorem round_le_generic :
  forall x y, generic_format y -> (x <= y)%R -> (round rnd x <= y)%R.

End monotone.

Theorem round_abs_abs :
  forall P : R -> R -> Prop,
  ( forall rnd (Hr : Valid_rnd rnd) x, (0 <= x)%R -> P x (round rnd x) ) ->
  forall rnd {Hr : Valid_rnd rnd} x, P (Rabs x) (Rabs (round rnd x)).

Theorem round_bounded_large :
  forall rnd {Hr : Valid_rnd rnd} x ex,
  (fexp ex < ex)%Z ->
  (bpow (ex - 1) <= Rabs x < bpow ex)%R ->
  (bpow (ex - 1) <= Rabs (round rnd x) <= bpow ex)%R.

Theorem exp_small_round_0 :
  forall rnd {Hr : Valid_rnd rnd} x ex,
  (bpow (ex - 1) <= Rabs x < bpow ex)%R ->
   round rnd x = 0%R -> (ex <= fexp ex)%Z .

Section monotone_abs.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem abs_round_ge_generic :
  forall x y, generic_format x -> (x <= Rabs y)%R -> (x <= Rabs (round rnd y))%R.

Theorem abs_round_le_generic :
  forall x y, generic_format y -> (Rabs x <= y)%R -> (Rabs (round rnd x) <= y)%R.

End monotone_abs.

Theorem round_DN_opp :
  forall x,
  round Zfloor (-x) = (- round Zceil x)%R.

Theorem round_UP_opp :
  forall x,
  round Zceil (-x) = (- round Zfloor x)%R.

Theorem round_ZR_opp :
  forall x,
  round Ztrunc (- x) = Ropp (round Ztrunc x).

Theorem round_ZR_abs :
  forall x,
  round Ztrunc (Rabs x) = Rabs (round Ztrunc x).

Theorem round_AW_opp :
  forall x,
  round Zaway (- x) = Ropp (round Zaway x).

Theorem round_AW_abs :
  forall x,
  round Zaway (Rabs x) = Rabs (round Zaway x).

Theorem round_ZR_pos :
  forall x,
  (0 <= x)%R ->
  round Ztrunc x = round Zfloor x.

Theorem round_ZR_neg :
  forall x,
  (x <= 0)%R ->
  round Ztrunc x = round Zceil x.

Theorem round_AW_pos :
  forall x,
  (0 <= x)%R ->
  round Zaway x = round Zceil x.

Theorem round_AW_neg :
  forall x,
  (x <= 0)%R ->
  round Zaway x = round Zfloor x.

Theorem generic_format_round :
  forall rnd { Hr : Valid_rnd rnd } x,
  generic_format (round rnd x).

Theorem round_DN_pt :
  forall x,
  Rnd_DN_pt generic_format x (round Zfloor x).

Theorem generic_format_satisfies_any :
  satisfies_any generic_format.

Theorem round_UP_pt :
  forall x,
  Rnd_UP_pt generic_format x (round Zceil x).

Theorem round_ZR_pt :
  forall x,
  Rnd_ZR_pt generic_format x (round Ztrunc x).

Theorem round_DN_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  round Zfloor x = 0%R.

Theorem round_DN_UP_lt :
  forall x, ~ generic_format x ->
  (round Zfloor x < x < round Zceil x)%R.

Theorem round_UP_small_pos :
  forall x ex,
  (bpow (ex - 1) <= x < bpow ex)%R ->
  (ex <= fexp ex)%Z ->
  round Zceil x = (bpow (fexp ex)).

Theorem generic_format_EM :
  forall x,
  generic_format x \/ ~generic_format x.

Section round_large.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem round_large_pos_ge_pow :
  forall x e,
  (0 < round rnd x)%R ->
  (bpow e <= x)%R ->
  (bpow e <= round rnd x)%R.

End round_large.

Theorem ln_beta_round_ZR :
  forall x,
  (round Ztrunc x <> 0)%R ->
  (ln_beta beta (round Ztrunc x) = ln_beta beta x :> Z).

Theorem ln_beta_round :
  forall rnd {Hrnd : Valid_rnd rnd} x,
  (round rnd x <> 0)%R ->
  (ln_beta beta (round rnd x) = ln_beta beta x :> Z) \/
  Rabs (round rnd x) = bpow (Zmax (ln_beta beta x) (fexp (ln_beta beta x))).

Theorem ln_beta_DN :
  forall x,
  (0 < round Zfloor x)%R ->
  (ln_beta beta (round Zfloor x) = ln_beta beta x :> Z).

Theorem canonic_exp_DN :
  forall x,
  (0 < round Zfloor x)%R ->
  canonic_exp (round Zfloor x) = canonic_exp x.

Theorem scaled_mantissa_DN :
  forall x,
  (0 < round Zfloor x)%R ->
  scaled_mantissa (round Zfloor x) = Z2R (Zfloor (scaled_mantissa x)).

Theorem generic_N_pt_DN_or_UP :
  forall x f,
  Rnd_N_pt generic_format x f ->
  f = round Zfloor x \/ f = round Zceil x.

Section not_FTZ.

Class Exp_not_FTZ :=
  exp_not_FTZ : forall e, (fexp (fexp e + 1) <= fexp e)%Z.

Context { exp_not_FTZ_ : Exp_not_FTZ }.

Theorem subnormal_exponent :
  forall e x,
  (e <= fexp e)%Z ->
  generic_format x ->
  x = F2R (Float beta (Ztrunc (x * bpow (- fexp e))) (fexp e)).

End not_FTZ.

Section monotone_exp.

Class Monotone_exp :=
  monotone_exp : forall ex ey, (ex <= ey)%Z -> (fexp ex <= fexp ey)%Z.

Context { monotone_exp_ : Monotone_exp }.

Global Instance monotone_exp_not_FTZ : Exp_not_FTZ.

Lemma canonic_exp_le_bpow :
  forall (x : R) (e : Z),
  x <> 0%R ->
  (Rabs x < bpow e)%R ->
  (canonic_exp x <= fexp e)%Z.

Lemma canonic_exp_ge_bpow :
  forall (x : R) (e : Z),
  (bpow (e - 1) <= Rabs x)%R ->
  (fexp e <= canonic_exp x)%Z.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem ln_beta_round_ge :
  forall x,
  round rnd x <> 0%R ->
  (ln_beta beta x <= ln_beta beta (round rnd x))%Z.

Theorem canonic_exp_round_ge :
  forall x,
  round rnd x <> 0%R ->
  (canonic_exp x <= canonic_exp (round rnd x))%Z.

End monotone_exp.

Section Znearest.

Variable choice : Z -> bool.

Definition Znearest x :=
  match Rcompare (x - Z2R (Zfloor x)) (/2) with
  | Lt => Zfloor x
  | Eq => if choice (Zfloor x) then Zceil x else Zfloor x
  | Gt => Zceil x
  end.

Theorem Znearest_DN_or_UP :
  forall x,
  Znearest x = Zfloor x \/ Znearest x = Zceil x.

Theorem Znearest_ge_floor :
  forall x,
  (Zfloor x <= Znearest x)%Z.

Theorem Znearest_le_ceil :
  forall x,
  (Znearest x <= Zceil x)%Z.

Global Instance valid_rnd_N : Valid_rnd Znearest.

Theorem Rcompare_floor_ceil_mid :
  forall x,
  Z2R (Zfloor x) <> x ->
  Rcompare (x - Z2R (Zfloor x)) (/ 2) = Rcompare (x - Z2R (Zfloor x)) (Z2R (Zceil x) - x).

Theorem Rcompare_ceil_floor_mid :
  forall x,
  Z2R (Zfloor x) <> x ->
  Rcompare (Z2R (Zceil x) - x) (/ 2) = Rcompare (Z2R (Zceil x) - x) (x - Z2R (Zfloor x)).

Theorem Znearest_N_strict :
  forall x,
  (x - Z2R (Zfloor x) <> /2)%R ->
  (Rabs (x - Z2R (Znearest x)) < /2)%R.

Theorem Znearest_N :
  forall x,
  (Rabs (x - Z2R (Znearest x)) <= /2)%R.

Theorem Znearest_imp :
  forall x n,
  (Rabs (x - Z2R n) < /2)%R ->
  Znearest x = n.

Theorem round_N_pt :
  forall x,
  Rnd_N_pt generic_format x (round Znearest x).

Theorem round_N_middle :
  forall x,
  (x - round Zfloor x = round Zceil x - x)%R ->
  round Znearest x = if choice (Zfloor (scaled_mantissa x)) then round Zceil x else round Zfloor x.

Lemma round_N_really_small_pos :
  forall x,
  forall ex,
  (Fcore_Raux.bpow beta (ex - 1) <= x < Fcore_Raux.bpow beta ex)%R ->

End Znearest.

Section rndNA.

Global Instance valid_rnd_NA : Valid_rnd (Znearest (Zle_bool 0)) := valid_rnd_N _.

Theorem round_NA_pt :
  forall x,
  Rnd_NA_pt generic_format x (round (Znearest (Zle_bool 0)) x).

End rndNA.

Section rndN_opp.

Theorem Znearest_opp :
  forall choice x,
  Znearest choice (- x) = (- Znearest (fun t => negb (choice (- (t + 1))%Z)) x)%Z.

Theorem round_N_opp :
  forall choice,
  forall x,
  round (Znearest choice) (-x) = (- round (Znearest (fun t => negb (choice (- (t + 1))%Z))) x)%R.

End rndN_opp.

End Format.

Section Inclusion.

Variables fexp1 fexp2 : Z -> Z.

Context { valid_exp1 : Valid_exp fexp1 }.
Context { valid_exp2 : Valid_exp fexp2 }.

Theorem generic_inclusion_ln_beta :
  forall x,
  ( x <> R0 -> (fexp2 (ln_beta beta x) <= fexp1 (ln_beta beta x))%Z ) ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_lt_ge :
  forall e1 e2,
  ( forall e, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (bpow e1 <= Rabs x < bpow e2)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion :
  forall e,
  (fexp2 e <= fexp1 e)%Z ->
  forall x,
  (bpow (e - 1) <= Rabs x <= bpow e)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_le_ge :
  forall e1 e2,
  (e1 < e2)%Z ->
  ( forall e, (e1 < e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (bpow e1 <= Rabs x <= bpow e2)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_le :
  forall e2,
  ( forall e, (e <= e2)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (Rabs x <= bpow e2)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Theorem generic_inclusion_ge :
  forall e1,
  ( forall e, (e1 < e)%Z -> (fexp2 e <= fexp1 e)%Z ) ->
  forall x,
  (bpow e1 <= Rabs x)%R ->
  generic_format fexp1 x ->
  generic_format fexp2 x.

Variable rnd : R -> Z.
Context { valid_rnd : Valid_rnd rnd }.

Theorem generic_round_generic :
  forall x,
  generic_format fexp1 x ->
  generic_format fexp1 (round fexp2 rnd x).

End Inclusion.

End Generic.

Notation ZnearestA := (Znearest (Zle_bool 0)).

Section rndNA_opp.

Lemma round_NA_opp :
  forall beta : radix,
  forall (fexp : Z -> Z),
  forall x,
  (round beta fexp ZnearestA (- x) = - round beta fexp ZnearestA x)%R.

End rndNA_opp.

Notation rndDN := Zfloor (only parsing).
Notation rndUP := Zceil (only parsing).
Notation rndZR := Ztrunc (only parsing).
Notation rndNA := ZnearestA (only parsing). *)

Require Import Fcalc_ops.
(* Fcalc_ops:
Require Import Fcore_Raux.
Require Import Fcore_defs.
Require Import Fcore_float_prop.

Section Float_ops.

Variable beta : radix.

Notation bpow e := (bpow beta e).

Arguments Float {beta} Fnum Fexp.

Definition Falign (f1 f2 : float beta) :=
  let '(Float m1 e1) := f1 in
  let '(Float m2 e2) := f2 in
  if Zle_bool e1 e2
  then (m1, (m2 * Zpower beta (e2 - e1))%Z, e1)
  else ((m1 * Zpower beta (e1 - e2))%Z, m2, e2).

Theorem Falign_spec :
  forall f1 f2 : float beta,
  let '(m1, m2, e) := Falign f1 f2 in
  F2R f1 = @F2R beta (Float m1 e) /\ F2R f2 = @F2R beta (Float m2 e).

Theorem Falign_spec_exp:
  forall f1 f2 : float beta,
  snd (Falign f1 f2) = Zmin (Fexp f1) (Fexp f2).

Definition Fopp (f1 : float beta) : float beta :=
  let '(Float m1 e1) := f1 in
  Float (-m1)%Z e1.

Theorem F2R_opp :
  forall f1 : float beta,
  (F2R (Fopp f1) = -F2R f1)%R.

Definition Fabs (f1 : float beta) : float beta :=
  let '(Float m1 e1) := f1 in
  Float (Zabs m1)%Z e1.

Theorem F2R_abs :
  forall f1 : float beta,
  (F2R (Fabs f1) = Rabs (F2R f1))%R.

Definition Fplus (f1 f2 : float beta) : float beta :=
  let '(m1, m2 ,e) := Falign f1 f2 in
  Float (m1 + m2) e.

Theorem F2R_plus :
  forall f1 f2 : float beta,
  F2R (Fplus f1 f2) = (F2R f1 + F2R f2)%R.

Theorem Fplus_same_exp :
  forall m1 m2 e,
  Fplus (Float m1 e) (Float m2 e) = Float (m1 + m2) e.

Theorem Fexp_Fplus :
  forall f1 f2 : float beta,
  Fexp (Fplus f1 f2) = Zmin (Fexp f1) (Fexp f2).

Definition Fminus (f1 f2 : float beta) :=
  Fplus f1 (Fopp f2).

Theorem F2R_minus :
  forall f1 f2 : float beta,
  F2R (Fminus f1 f2) = (F2R f1 - F2R f2)%R.

Theorem Fminus_same_exp :
  forall m1 m2 e,
  Fminus (Float m1 e) (Float m2 e) = Float (m1 - m2) e.

Definition Fmult (f1 f2 : float beta) : float beta :=
  let '(Float m1 e1) := f1 in
  let '(Float m2 e2) := f2 in
  Float (m1 * m2) (e1 + e2).

Theorem F2R_mult :
  forall f1 f2 : float beta,
  F2R (Fmult f1 f2) = (F2R f1 * F2R f2)%R.

End Float_ops. *)

Require Import Fcore_ulp.
(* Fcore_ulp:
Require Import Reals Psatz.
Require Import Fcore_Raux.
Require Import Fcore_defs.
Require Import Fcore_rnd.
Require Import Fcore_generic_fmt.
Require Import Fcore_float_prop.

Section Fcore_ulp.

Variable beta : radix.

Notation bpow e := (bpow beta e).

Variable fexp : Z -> Z.

Lemma Z_le_dec_aux: forall x y : Z, (x <= y)%Z \/ ~ (x <= y)%Z.

Definition negligible_exp: option Z :=
  match (LPO_Z _ (fun z => Z_le_dec_aux z (fexp z))) with
   | inleft N => Some (proj1_sig N)
   | inright _ => None
 end.

Inductive negligible_exp_prop: option Z -> Prop :=
  | negligible_None: (forall n, (fexp n < n)%Z) -> negligible_exp_prop None
  | negligible_Some: forall n, (n <= fexp n)%Z -> negligible_exp_prop (Some n).

Lemma negligible_exp_spec: negligible_exp_prop negligible_exp.

Lemma negligible_exp_spec': (negligible_exp = None /\ forall n, (fexp n < n)%Z)
           \/ exists n, (negligible_exp = Some n /\ (n <= fexp n)%Z).

Context { valid_exp : Valid_exp fexp }.

Lemma fexp_negligible_exp_eq: forall n m, (n <= fexp n)%Z -> (m <= fexp m)%Z -> fexp n = fexp m.

Definition ulp x := match Req_bool x 0 with
  | true   => match negligible_exp with
            | Some n => bpow (fexp n)
            | None => 0%R
            end
  | false  => bpow (canonic_exp beta fexp x)
 end.

Lemma ulp_neq_0 : forall x:R, (x <> 0)%R -> ulp x = bpow (canonic_exp beta fexp x).

Notation F := (generic_format beta fexp).

Theorem ulp_opp :
  forall x, ulp (- x) = ulp x.

Theorem ulp_abs :
  forall x, ulp (Rabs x) = ulp x.

Theorem ulp_ge_0:
  forall x, (0 <= ulp x)%R.

Theorem ulp_le_id:
  forall x,
    (0 < x)%R ->
    F x ->
    (ulp x <= x)%R.

Theorem ulp_le_abs:
  forall x,
    (x <> 0)%R ->
    F x ->
    (ulp x <= Rabs x)%R.

Theorem round_UP_DN_ulp :
  forall x, ~ F x ->
  round beta fexp Zceil x = (round beta fexp Zfloor x + ulp x)%R.

Theorem ulp_bpow :
  forall e, ulp (bpow e) = bpow (fexp (e + 1)).

Lemma generic_format_ulp_0:
  F (ulp 0).

Lemma generic_format_bpow_ge_ulp_0:  forall e,
    (ulp 0 <= bpow e)%R -> F (bpow e).

Lemma generic_format_ulp: Exp_not_FTZ fexp ->
  forall x,  F (ulp x).

Lemma not_FTZ_generic_format_ulp:
   (forall x,  F (ulp x)) -> Exp_not_FTZ fexp.

Lemma ulp_ge_ulp_0: Exp_not_FTZ fexp ->
  forall x,  (ulp 0 <= ulp x)%R.

Lemma not_FTZ_ulp_ge_ulp_0:
   (forall x,  (ulp 0 <= ulp x)%R) -> Exp_not_FTZ fexp.

Theorem ulp_le_pos :
  forall { Hm : Monotone_exp fexp },
  forall x y: R,
  (0 <= x)%R -> (x <= y)%R ->
  (ulp x <= ulp y)%R.

Theorem ulp_le :
  forall { Hm : Monotone_exp fexp },
  forall x y: R,
  (Rabs x <= Rabs y)%R ->
  (ulp x <= ulp y)%R.

Definition pred_pos x :=
  if Req_bool x (bpow (ln_beta beta x - 1)) then
    (x - bpow (fexp (ln_beta beta x - 1)))%R
  else
    (x - ulp x)%R.

Definition succ x :=
   if (Rle_bool 0 x) then
          (x+ulp x)%R
   else
     (- pred_pos (-x))%R.

Definition pred x := (- succ (-x))%R.

Theorem pred_eq_pos:
  forall x, (0 <= x)%R -> (pred x = pred_pos x)%R.

Theorem succ_eq_pos:
  forall x, (0 <= x)%R -> (succ x = x + ulp x)%R.

Lemma pred_eq_opp_succ_opp: forall x, pred x = (- succ (-x))%R.

Lemma succ_eq_opp_pred_opp: forall x, succ x = (- pred (-x))%R.

Lemma succ_opp: forall x, (succ (-x) = - pred x)%R.

Lemma pred_opp: forall x, (pred (-x) = - succ x)%R.

Theorem id_m_ulp_ge_bpow :
  forall x e,  F x ->
  x <> ulp x ->
  (bpow e < x)%R ->
  (bpow e <= x - ulp x)%R.

Theorem id_p_ulp_le_bpow :
  forall x e, (0 < x)%R -> F x ->
  (x < bpow e)%R ->
  (x + ulp x <= bpow e)%R.

Lemma generic_format_pred_aux1:
  forall x, (0 < x)%R -> F x ->
  x <> bpow (ln_beta beta x - 1) ->
  F (x - ulp x).

Lemma generic_format_pred_aux2 :
  forall x, (0 < x)%R -> F x ->
  let e := ln_beta_val beta x (ln_beta beta x) in
  x =  bpow (e - 1) ->
  F (x - bpow (fexp (e - 1))).

Theorem generic_format_succ_aux1 :
  forall x, (0 < x)%R -> F x ->
  F (x + ulp x).

Theorem generic_format_pred_pos :
  forall x, F x -> (0 < x)%R ->
  F (pred_pos x).

Theorem generic_format_succ :
  forall x, F x ->
  F (succ x).

Theorem generic_format_pred :
  forall x, F x ->
  F (pred x).

Theorem pred_pos_lt_id :
  forall x, (x <> 0)%R ->
  (pred_pos x < x)%R.

Theorem succ_gt_id :
  forall x, (x <> 0)%R ->
  (x < succ x)%R.

Theorem pred_lt_id :
  forall x,  (x <> 0)%R ->
  (pred x < x)%R.

Theorem succ_ge_id :
  forall x, (x <= succ x)%R.

Theorem pred_le_id :
  forall x,  (pred x <= x)%R.

Theorem pred_pos_ge_0 :
  forall x,
  (0 < x)%R -> F x -> (0 <= pred_pos x)%R.

Theorem pred_ge_0 :
  forall x,
  (0 < x)%R -> F x -> (0 <= pred x)%R.

Lemma pred_pos_plus_ulp_aux1 :
  forall x, (0 < x)%R -> F x ->
  x <> bpow (ln_beta beta x - 1) ->
  ((x - ulp x) + ulp (x-ulp x) = x)%R.

Lemma pred_pos_plus_ulp_aux2 :
  forall x, (0 < x)%R -> F x ->
  let e := ln_beta_val beta x (ln_beta beta x) in
  x =  bpow (e - 1) ->
  (x - bpow (fexp (e-1)) <> 0)%R ->
  ((x - bpow (fexp (e-1))) + ulp (x - bpow (fexp (e-1))) = x)%R.

Lemma pred_pos_plus_ulp_aux3 :
  forall x, (0 < x)%R -> F x ->
  let e := ln_beta_val beta x (ln_beta beta x) in
  x =  bpow (e - 1) ->
  (x - bpow (fexp (e-1)) = 0)%R ->
  (ulp 0 = x)%R.

Theorem pred_pos_plus_ulp :
  forall x, (0 < x)%R -> F x ->
  (pred_pos x + ulp (pred_pos x) = x)%R.

Theorem ln_beta_plus_eps:
  forall x, (0 < x)%R -> F x ->
  forall eps, (0 <= eps < ulp x)%R ->
  ln_beta beta (x + eps) = ln_beta beta x :> Z.

Theorem round_DN_plus_eps_pos:
  forall x, (0 <= x)%R -> F x ->
  forall eps, (0 <= eps < ulp x)%R ->
  round beta fexp Zfloor (x + eps) = x.

Theorem round_UP_plus_eps_pos :
  forall x, (0 <= x)%R -> F x ->
  forall eps, (0 < eps <= ulp x)%R ->
  round beta fexp Zceil (x + eps) = (x + ulp x)%R.

Theorem round_UP_pred_plus_eps_pos :
  forall x, (0 < x)%R -> F x ->
  forall eps, (0 < eps <= ulp (pred x) )%R ->
  round beta fexp Zceil (pred x + eps) = x.

Theorem round_DN_minus_eps_pos :
  forall x,  (0 < x)%R -> F x ->
  forall eps, (0 < eps <= ulp (pred x))%R ->
  round beta fexp Zfloor (x - eps) = pred x.

Theorem round_DN_plus_eps:
  forall x, F x ->
  forall eps, (0 <= eps < if (Rle_bool 0 x) then (ulp x)
                                     else (ulp (pred (-x))))%R ->
  round beta fexp Zfloor (x + eps) = x.

Theorem round_UP_plus_eps :
  forall x, F x ->
  forall eps, (0 < eps <= if (Rle_bool 0 x) then (ulp x)
                                     else (ulp (pred (-x))))%R ->
  round beta fexp Zceil (x + eps) = (succ x)%R.

Lemma le_pred_pos_lt :
  forall x y,
  F x -> F y ->
  (0 <= x < y)%R ->
  (x <= pred_pos y)%R.

Theorem succ_le_lt_aux:
  forall x y,
  F x -> F y ->
  (0 <= x)%R -> (x < y)%R ->
  (succ x <= y)%R.

Theorem succ_le_lt:
  forall x y,
  F x -> F y ->
  (x < y)%R ->
  (succ x <= y)%R.

Theorem le_pred_lt :
  forall x y,
  F x -> F y ->
  (x < y)%R ->
  (x <= pred y)%R.

Theorem lt_succ_le :
  forall x y,
  (y <> 0)%R ->
  (x <= y)%R ->
  (x < succ y)%R.

Theorem pred_lt_le :
  forall x y,
  (x <> 0)%R ->
  (x <= y)%R ->
  (pred x < y)%R.

Theorem succ_pred_aux : forall x, F x -> (0 < x)%R -> succ (pred x)=x.

Theorem pred_ulp_0 :
  pred (ulp 0) = 0%R.

Theorem succ_0 :
  succ 0 = ulp 0.

Theorem pred_0 :
  pred 0 = Ropp (ulp 0).

Theorem pred_succ_aux :
  forall x, F x -> (0 < x)%R ->
  pred (succ x) = x.

Theorem succ_pred :
  forall x, F x ->
  succ (pred x) = x.

Theorem pred_succ :
  forall x, F x ->
  pred (succ x) = x.

Theorem round_UP_pred_plus_eps :
  forall x, F x ->
  forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x)
                                     else (ulp (pred x)))%R ->
  round beta fexp Zceil (pred x + eps) = x.

Theorem round_DN_minus_eps:
  forall x,  F x ->
  forall eps, (0 < eps <= if (Rle_bool x 0) then (ulp x)
                                     else (ulp (pred x)))%R ->
  round beta fexp Zfloor (x - eps) = pred x.

Theorem error_lt_ulp :
  forall rnd { Zrnd : Valid_rnd rnd } x,
   (x <> 0)%R ->
  (Rabs (round beta fexp rnd x - x) < ulp x)%R.

Theorem error_le_ulp :
  forall rnd { Zrnd : Valid_rnd rnd } x,
  (Rabs (round beta fexp rnd x - x) <= ulp x)%R.

Theorem error_le_half_ulp :
  forall choice x,
  (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp x)%R.

Theorem ulp_DN :
  forall x,
  (0 < round beta fexp Zfloor x)%R ->
  ulp (round beta fexp Zfloor x) = ulp x.

Theorem round_neq_0_negligible_exp:
    negligible_exp=None -> forall rnd { Zrnd : Valid_rnd rnd } x,
   (x <> 0)%R ->  (round beta fexp rnd x <> 0)%R.

Theorem error_lt_ulp_round :
  forall { Hm : Monotone_exp fexp } rnd { Zrnd : Valid_rnd rnd } x,
  ( x <> 0)%R ->
  (Rabs (round beta fexp rnd x - x) < ulp (round beta fexp rnd x))%R.

Theorem error_le_half_ulp_round :
  forall { Hm : Monotone_exp fexp },
  forall choice x,
  (Rabs (round beta fexp (Znearest choice) x - x) <= /2 * ulp (round beta fexp (Znearest choice) x))%R.

Theorem pred_le :
  forall x y, F x -> F y -> (x <= y)%R ->
  (pred x <= pred y)%R.

Theorem succ_le: forall x y,
   F x -> F y -> (x <= y)%R -> (succ x <= succ y)%R.

Theorem pred_le_inv: forall x y, F x -> F y
   -> (pred x <= pred y)%R -> (x <= y)%R.

Theorem succ_le_inv: forall x y, F x -> F y
   -> (succ x <= succ y)%R -> (x <= y)%R.

Theorem pred_lt :
  forall x y, F x -> F y -> (x < y)%R ->
  (pred x < pred y)%R.

Theorem succ_lt :
  forall x y, F x -> F y -> (x < y)%R ->
  (succ x < succ y)%R.

Theorem le_round_DN_lt_UP :
  forall x y, F y ->
  (y < round beta fexp Zceil x -> y <= round beta fexp Zfloor x)%R.

Theorem round_UP_le_gt_DN :
  forall x y, F y ->
   (round beta fexp Zfloor x < y -> round beta fexp Zceil x <= y)%R.

Theorem pred_UP_le_DN :
  forall x, (pred (round beta fexp Zceil x) <= round beta fexp Zfloor x)%R.

Theorem pred_UP_eq_DN :
  forall x,  ~ F x ->
  (pred (round beta fexp Zceil x) = round beta fexp Zfloor x)%R.

Theorem succ_DN_eq_UP :
  forall x,  ~ F x ->
  (succ (round beta fexp Zfloor x) = round beta fexp Zceil x)%R.

Theorem round_DN_eq_betw: forall x d, F d
     -> (d <= x < succ d)%R
        -> round beta fexp Zfloor x = d.

Theorem round_UP_eq_betw: forall x u, F u
    -> (pred u < x <= u)%R
    -> round beta fexp Zceil x = u.

Theorem round_N_le_midp: forall choice u v,
  F u -> (v < (u + succ u)/2)%R
      -> (round beta fexp (Znearest choice)  v <= u)%R.

Theorem round_N_ge_midp: forall choice u v,
 F u ->  ((u + pred u)/2 < v)%R
      -> (u <= round beta fexp (Znearest choice)  v)%R.

Lemma round_N_eq_DN: forall choice x,
       let d:=round beta fexp Zfloor x in
       let u:=round beta fexp Zceil x in
      (x<(d+u)/2)%R ->
     round beta fexp (Znearest choice) x = d.

Lemma round_N_eq_DN_pt: forall choice x d u,
      Rnd_DN_pt F x d -> Rnd_UP_pt F x u ->
      (x<(d+u)/2)%R ->
     round beta fexp (Znearest choice) x = d.

Lemma round_N_eq_UP: forall choice x,
      let d:=round beta fexp Zfloor x in
      let u:=round beta fexp Zceil x in
     ((d+u)/2 < x)%R ->
     round beta fexp (Znearest choice) x = u.

Lemma round_N_eq_UP_pt: forall choice x d u,
      Rnd_DN_pt F x d -> Rnd_UP_pt F x u ->
      ((d+u)/2 < x)%R ->
     round beta fexp (Znearest choice) x = u.

End Fcore_ulp. *)

Require Fcore_FLX Fcore_FLT Fcore_FTZ.



Require Import Psatz.



Open Scope R_scope.



Section Double_round.



Variable beta : radix.

Notation bpow e := (bpow beta e).

Notation ln_beta x := (ln_beta beta x).



Definition double_round_eq fexp1 fexp2 choice1 choice2 x :=

  round beta fexp1 (Znearest choice1) (round beta fexp2 (Znearest choice2) x)

  = round beta fexp1 (Znearest choice1) x.



Ltac bpow_simplify :=

  

  repeat

    match goal with

      | |- context [(Fcore_Raux.bpow _ _ * Fcore_Raux.bpow _ _)] =>

        rewrite <- bpow_plus

      | |- context [(?X1 * Fcore_Raux.bpow _ _ * Fcore_Raux.bpow _ _)] =>

        rewrite (Rmult_assoc X1); rewrite <- bpow_plus

      | |- context [(?X1 * (?X2 * Fcore_Raux.bpow _ _) * Fcore_Raux.bpow _ _)] =>

        rewrite <- (Rmult_assoc X1 X2); rewrite (Rmult_assoc (X1 * X2));

        rewrite <- bpow_plus

    end;

  

  repeat

    match goal with

      | |- context [(Fcore_Raux.bpow _ ?X)] =>

        progress ring_simplify X

    end;

  

  change (Fcore_Raux.bpow _ 0) with 1;

  repeat

    match goal with

      | |- context [(_ * 1)] =>

        rewrite Rmult_1_r

    end.



Definition midp (fexp : Z -> Z) (x : R) :=

  round beta fexp Zfloor x + / 2 * ulp beta fexp x.



Definition midp' (fexp : Z -> Z) (x : R) :=

  round beta fexp Zceil x - / 2 * ulp beta fexp x.



Lemma double_round_lt_mid_further_place' :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  x < bpow (ln_beta x) - / 2 * ulp beta fexp2 x ->

  x < midp fexp1 x - / 2 * ulp beta fexp2 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1 Hx1.

unfold double_round_eq.

set (x' := round beta fexp1 Zfloor x).

intro Hx2'.

assert (Hx2 : x - round beta fexp1 Zfloor x

              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).

{ now apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify. }

set (x'' := round beta fexp2 (Znearest choice2) x).

assert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (ln_beta x))).

apply Rle_trans with (/ 2 * ulp beta fexp2 x).

now unfold x''; apply error_le_half_ulp...

rewrite ulp_neq_0;[now right|now apply Rgt_not_eq].

assert (Pxx' : 0 <= x - x').

{ apply Rle_0_minus.

  apply round_DN_pt.

  exact Vfexp1. }

rewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).

assert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (ln_beta x))).

{ replace (x'' - x') with (x'' - x + (x - x')) by ring.

  apply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).

  replace (/ 2 * _) with (/ 2 * bpow (fexp2 (ln_beta x))

                          + (/ 2 * (bpow (fexp1 (ln_beta x))

                                    - bpow (fexp2 (ln_beta x))))) by ring.

  apply Rplus_le_lt_compat.

  - exact Hr1.

  - now rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2. }

destruct (Req_dec x'' 0) as [Zx''|Nzx''].

- 

  rewrite Zx'' in Hr1 |- *.

  rewrite round_0; [|now apply valid_rnd_N].

  unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

  rewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].

  apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

    [|now apply Rle_ge; apply bpow_ge_0].

  rewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.

  rewrite Rmult_0_l.

  bpow_simplify.

  rewrite Rabs_minus_sym.

  apply (Rle_lt_trans _ _ _ Hr1).

  apply Rmult_lt_compat_l; [lra|].

  apply bpow_lt.

  omega.

- 

  assert (Lx'' : ln_beta x'' = ln_beta x :> Z).

  { apply Zle_antisym.

    - apply ln_beta_le_bpow; [exact Nzx''|].

      replace x'' with (x'' - x + x) by ring.

      apply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).

      replace (bpow _) with (/ 2 * bpow (fexp2 (ln_beta x))

                             + (bpow (ln_beta x)

                                - / 2 * bpow (fexp2 (ln_beta x)))) by ring.

      apply Rplus_le_lt_compat; [exact Hr1|].

      rewrite ulp_neq_0 in Hx1;[idtac| now apply Rgt_not_eq].

      now rewrite Rabs_right; [|apply Rle_ge; apply Rlt_le].

    - unfold x'' in Nzx'' |- *.

      now apply ln_beta_round_ge; [|apply valid_rnd_N|]. }

  unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

  rewrite Lx''.

  rewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x))).

  + rewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x)));

    [reflexivity|].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

      [|now apply Rle_ge; apply bpow_ge_0].

    rewrite <- Rabs_mult.

    rewrite Rmult_minus_distr_r.

    fold x'.

    bpow_simplify.

    rewrite Rabs_right; [|now apply Rle_ge].

    apply (Rlt_le_trans _ _ _ Hx2).

    apply Rmult_le_compat_l; [lra|].

    generalize (bpow_ge_0 beta (fexp2 (ln_beta x))).

    unfold ulp, canonic_exp; lra.

  + apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

      [|now apply Rle_ge; apply bpow_ge_0].

    rewrite <- Rabs_mult.

    rewrite Rmult_minus_distr_r.

    fold x'.

    now bpow_simplify.

Qed.



Lemma double_round_lt_mid_further_place :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  (fexp1 (ln_beta x) <= ln_beta x)%Z ->

  x < midp fexp1 x - / 2 * ulp beta fexp2 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1 Hf1.

intro Hx2'.

assert (Hx2 : x - round beta fexp1 Zfloor x

              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).

{ now apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify. }

revert Hx2.

unfold double_round_eq.

set (x' := round beta fexp1 Zfloor x).

intro Hx2.

assert (Pxx' : 0 <= x - x').

{ apply Rle_0_minus.

  apply round_DN_pt.

  exact Vfexp1. }

assert (x < bpow (ln_beta x) - / 2 * bpow (fexp2 (ln_beta x)));

  [|apply double_round_lt_mid_further_place'; try assumption]...

2: rewrite ulp_neq_0;[assumption|now apply Rgt_not_eq].

destruct (Req_dec x' 0) as [Zx'|Nzx'].

- 

  rewrite Zx' in Hx2; rewrite Rminus_0_r in Hx2.

  apply (Rlt_le_trans _ _ _ Hx2).

  rewrite Rmult_minus_distr_l.

  rewrite 2!ulp_neq_0;[idtac|now apply Rgt_not_eq|now apply Rgt_not_eq].

  apply Rplus_le_compat_r.

  apply (Rmult_le_reg_r (bpow (- ln_beta x))); [now apply bpow_gt_0|].

  unfold ulp, canonic_exp; bpow_simplify.

  apply Rmult_le_reg_l with (1 := Rlt_0_2).

  replace (2 * (/ 2 * _)) with (bpow (fexp1 (ln_beta x) - ln_beta x)) by field.

  apply Rle_trans with 1; [|lra].

  change 1 with (bpow 0); apply bpow_le.

  omega.

- 

  assert (Px' : 0 < x').

  { assert (0 <= x'); [|lra].

    unfold x'.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite Rmult_0_l.

    unfold round, F2R, canonic_exp; simpl; bpow_simplify.

    change 0 with (Z2R 0); apply Z2R_le.

    apply Zfloor_lub.

    rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].

    rewrite scaled_mantissa_abs.

    apply Rabs_pos. }

  assert (Hx' : x' <= bpow (ln_beta x) - ulp beta fexp1 x).

  { apply (Rplus_le_reg_r (ulp beta fexp1 x)); ring_simplify.

    rewrite <- ulp_DN.

    - change (round _ _ _ _) with x'.

      apply id_p_ulp_le_bpow.

      + exact Px'.

      + change x' with (round beta fexp1 Zfloor x).

        now apply generic_format_round; [|apply valid_rnd_DN].

      + apply Rle_lt_trans with x.

        * now apply round_DN_pt.

        * rewrite <- (Rabs_right x) at 1; [|now apply Rle_ge; apply Rlt_le].

          apply bpow_ln_beta_gt.

    - exact Vfexp1.

    - exact Px'. }

  fold (canonic_exp beta fexp2 x); fold (ulp beta fexp2 x).

  assert (/ 2 * ulp beta fexp1 x <= ulp beta fexp1 x).

  rewrite <- (Rmult_1_l (ulp _ _ _)) at 2.

  apply Rmult_le_compat_r; [|lra].

  apply ulp_ge_0.

  rewrite 2!ulp_neq_0 in Hx2;[|now apply Rgt_not_eq|now apply Rgt_not_eq].

  rewrite ulp_neq_0 in Hx';[|now apply Rgt_not_eq].

  rewrite ulp_neq_0 in H;[|now apply Rgt_not_eq].

  lra.

Qed.



Lemma double_round_lt_mid_same_place :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) = fexp1 (ln_beta x))%Z ->

  x < midp fexp1 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 choice1 choice2 x Px Hf2f1.

intro Hx'.

assert (Hx : x - round beta fexp1 Zfloor x < / 2 * ulp beta fexp1 x).

{ now apply (Rplus_lt_reg_r (round beta fexp1 Zfloor x)); ring_simplify. }

revert Hx.

unfold double_round_eq.

set (x' := round beta fexp1 Zfloor x).

intro Hx.

assert (Pxx' : 0 <= x - x').

{ apply Rle_0_minus.

  apply round_DN_pt.

  exact Vfexp1. }

assert (H : Rabs (x * bpow (- fexp1 (ln_beta x)) -

                  Z2R (Zfloor (x * bpow (- fexp1 (ln_beta x))))) < / 2).

{ apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  unfold scaled_mantissa, canonic_exp in Hx.

  rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

    [|now apply Rle_ge; apply bpow_ge_0].

  rewrite <- Rabs_mult.

  rewrite Rmult_minus_distr_r.

  bpow_simplify.

  apply Rabs_lt.

  change (Z2R _ * _) with x'.

  split.

  - apply Rlt_le_trans with 0; [|exact Pxx'].

    rewrite <- Ropp_0.

    apply Ropp_lt_contravar.

    rewrite <- (Rmult_0_r (/ 2)).

    apply Rmult_lt_compat_l; [lra|].

    apply bpow_gt_0.

  - rewrite ulp_neq_0 in Hx;try apply Rgt_not_eq; assumption. }

unfold round at 2.

unfold F2R, scaled_mantissa, canonic_exp; simpl.

rewrite Hf2f1.

rewrite (Znearest_imp _ _ (Zfloor (scaled_mantissa beta fexp1 x))).

- rewrite round_generic.

  + unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

    now rewrite (Znearest_imp _ _ (Zfloor (x * bpow (- fexp1 (ln_beta x))))).

  + now apply valid_rnd_N.

  + fold (canonic_exp beta fexp1 x).

    change (Z2R _ * bpow _) with (round beta fexp1 Zfloor x).

    apply generic_format_round.

    exact Vfexp1.

    now apply valid_rnd_DN.

- now unfold scaled_mantissa, canonic_exp.

Qed.



Lemma double_round_lt_mid :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x))%Z ->

  (fexp1 (ln_beta x) <= ln_beta x)%Z ->

  x < midp fexp1 x ->

  ((fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

   x < midp fexp1 x - / 2 * ulp beta fexp2 x) ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1 Hf1 Hx Hx'.

destruct (Zle_or_lt (fexp1 (ln_beta x)) (fexp2 (ln_beta x))) as [Hf2'|Hf2'].

- 

  assert (Hf2'' : (fexp2 (ln_beta x) = fexp1 (ln_beta x) :> Z)%Z); [omega|].

  now apply double_round_lt_mid_same_place.

- 

  assert (Hf2'' : (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z); [omega|].

  generalize (Hx' Hf2''); intro Hx''.

  now apply double_round_lt_mid_further_place.

Qed.



Lemma double_round_gt_mid_further_place' :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  round beta fexp2 (Znearest choice2) x < bpow (ln_beta x) ->

  midp' fexp1 x + / 2 * ulp beta fexp2 x < x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1.

intros Hx1 Hx2'.

assert (Hx2 : round beta fexp1 Zceil x - x

              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).

{ apply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x

                         + / 2 * ulp beta fexp2 x)); ring_simplify.

  now unfold midp' in Hx2'. }

revert Hx1 Hx2.

unfold double_round_eq.

set (x' := round beta fexp1 Zceil x).

set (x'' := round beta fexp2 (Znearest choice2) x).

intros Hx1 Hx2.

assert (Hr1 : Rabs (x'' - x) <= / 2 * bpow (fexp2 (ln_beta x))).

  apply Rle_trans with (/2* ulp beta fexp2 x).

  now unfold x''; apply error_le_half_ulp...

  rewrite ulp_neq_0;[now right|now apply Rgt_not_eq].

assert (Px'x : 0 <= x' - x).

{ apply Rle_0_minus.

  apply round_UP_pt.

  exact Vfexp1. }

assert (Hr2 : Rabs (x'' - x') < / 2 * bpow (fexp1 (ln_beta x))).

{ replace (x'' - x') with (x'' - x + (x - x')) by ring.

  apply (Rle_lt_trans _ _ _ (Rabs_triang _ _)).

  replace (/ 2 * _) with (/ 2 * bpow (fexp2 (ln_beta x))

                          + (/ 2 * (bpow (fexp1 (ln_beta x))

                                    - bpow (fexp2 (ln_beta x))))) by ring.

  apply Rplus_le_lt_compat.

  - exact Hr1.

  - rewrite Rabs_minus_sym.

   rewrite 2!ulp_neq_0 in Hx2; try (apply Rgt_not_eq; assumption).

    now rewrite Rabs_right; [|now apply Rle_ge]; apply Hx2. }

destruct (Req_dec x'' 0) as [Zx''|Nzx''].

- 

  rewrite Zx'' in Hr1 |- *.

  rewrite round_0; [|now apply valid_rnd_N].

  unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

  rewrite (Znearest_imp _ _ 0); [now simpl; rewrite Rmult_0_l|].

  apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

    [|now apply Rle_ge; apply bpow_ge_0].

  rewrite <- Rabs_mult; rewrite Rmult_minus_distr_r.

  rewrite Rmult_0_l.

  bpow_simplify.

  rewrite Rabs_minus_sym.

  apply (Rle_lt_trans _ _ _ Hr1).

  apply Rmult_lt_compat_l; [lra|].

  apply bpow_lt.

  omega.

- 

  assert (Lx'' : ln_beta x'' = ln_beta x :> Z).

  { apply Zle_antisym.

    - apply ln_beta_le_bpow; [exact Nzx''|].

      rewrite Rabs_right; [exact Hx1|apply Rle_ge].

      apply round_ge_generic.

      + exact Vfexp2.

      + now apply valid_rnd_N.

      + apply generic_format_0.

      + now apply Rlt_le.

    - unfold x'' in Nzx'' |- *.

      now apply ln_beta_round_ge; [|apply valid_rnd_N|]. }

  unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

  rewrite Lx''.

  rewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).

  + rewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x)));

    [reflexivity|].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

      [|now apply Rle_ge; apply bpow_ge_0].

    rewrite <- Rabs_mult.

    rewrite Rmult_minus_distr_r.

    fold x'.

    bpow_simplify.

    rewrite Rabs_minus_sym.

    rewrite Rabs_right; [|now apply Rle_ge].

    apply (Rlt_le_trans _ _ _ Hx2).

    apply Rmult_le_compat_l; [lra|].

    generalize (bpow_ge_0 beta (fexp2 (ln_beta x))).

    rewrite 2!ulp_neq_0; try (apply Rgt_not_eq; assumption).

    unfold canonic_exp; lra.

  + apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

      [|now apply Rle_ge; apply bpow_ge_0].

    rewrite <- Rabs_mult.

    rewrite Rmult_minus_distr_r.

    fold x'.

    now bpow_simplify.

Qed.



Lemma double_round_gt_mid_further_place :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  (fexp1 (ln_beta x) <= ln_beta x)%Z ->

  midp' fexp1 x + / 2 * ulp beta fexp2 x < x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1 Hf1 Hx2'.

assert (Hx2 : round beta fexp1 Zceil x - x

              < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).

{ apply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x

                         + / 2 * ulp beta fexp2 x)); ring_simplify.

  now unfold midp' in Hx2'. }

revert Hx2.

unfold double_round_eq.

set (x' := round beta fexp1 Zfloor x).

intro Hx2.

set (x'' := round beta fexp2 (Znearest choice2) x).

destruct (Rlt_or_le x'' (bpow (ln_beta x))) as [Hx''|Hx''];

  [now apply double_round_gt_mid_further_place'|].



assert (Hx''pow : x'' = bpow (ln_beta x)).

{ assert (H'x'' : x'' < bpow (ln_beta x) + / 2 * ulp beta fexp2 x).

  { apply Rle_lt_trans with (x + / 2 * ulp beta fexp2 x).

    - apply (Rplus_le_reg_r (- x)); ring_simplify.

      apply Rabs_le_inv.

      apply error_le_half_ulp.

      exact Vfexp2.

    - apply Rplus_lt_compat_r.

      rewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].

      apply bpow_ln_beta_gt. }

  apply Rle_antisym; [|exact Hx''].

  unfold x'', round, F2R, scaled_mantissa, canonic_exp; simpl.

  apply (Rmult_le_reg_r (bpow (- fexp2 (ln_beta x)))); [now apply bpow_gt_0|].

  bpow_simplify.

  rewrite <- (Z2R_Zpower _ (_ - _)); [|omega].

  apply Z2R_le.

  apply Zlt_succ_le; unfold Z.succ.

  apply lt_Z2R.

  rewrite Z2R_plus; rewrite Z2R_Zpower; [|omega].

  apply (Rmult_lt_reg_r (bpow (fexp2 (ln_beta x)))); [now apply bpow_gt_0|].

  rewrite Rmult_plus_distr_r; rewrite Rmult_1_l.

  bpow_simplify.

  apply (Rlt_le_trans _ _ _ H'x'').

  apply Rplus_le_compat_l.

  rewrite <- (Rmult_1_l (Fcore_Raux.bpow _ _)).

  rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].

  apply Rmult_le_compat_r; [now apply bpow_ge_0|].

  lra. }

assert (Hr : Rabs (x - x'') < / 2 * ulp beta fexp1 x).

{ apply Rle_lt_trans with (/ 2 * ulp beta fexp2 x).

  - rewrite Rabs_minus_sym.

    apply error_le_half_ulp.

    exact Vfexp2.

  - apply Rmult_lt_compat_l; [lra|].

    rewrite 2!ulp_neq_0; try now apply Rgt_not_eq.

    unfold canonic_exp; apply bpow_lt.

    omega. }

unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

assert (Hf : (0 <= ln_beta x - fexp1 (ln_beta x''))%Z).

{ rewrite Hx''pow.

  rewrite ln_beta_bpow.

  assert (fexp1 (ln_beta x + 1) <= ln_beta x)%Z; [|omega].

  destruct (Zle_or_lt (ln_beta x) (fexp1 (ln_beta x))) as [Hle|Hlt];

    [|now apply Vfexp1].

  assert (H : (ln_beta x = fexp1 (ln_beta x) :> Z)%Z);

    [now apply Zle_antisym|].

  rewrite H.

  now apply Vfexp1. }

rewrite (Znearest_imp _ _ (beta ^ (ln_beta x - fexp1 (ln_beta x'')))%Z).

- rewrite (Znearest_imp _ _ (beta ^ (ln_beta x - fexp1 (ln_beta x)))%Z).

  + rewrite Z2R_Zpower; [|exact Hf].

    rewrite Z2R_Zpower; [|omega].

    now bpow_simplify.

  + rewrite Z2R_Zpower; [|omega].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

      [|now apply Rle_ge; apply bpow_ge_0].

    rewrite <- Rabs_mult.

    rewrite Rmult_minus_distr_r.

    bpow_simplify.

   rewrite ulp_neq_0 in Hr;[idtac|now apply Rgt_not_eq].

    rewrite <- Hx''pow; exact Hr.

- rewrite Z2R_Zpower; [|exact Hf].

  apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x'')))); [now apply bpow_gt_0|].

  rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

    [|now apply Rle_ge; apply bpow_ge_0].

  rewrite <- Rabs_mult.

  rewrite Rmult_minus_distr_r.

  bpow_simplify.

  rewrite Rminus_diag_eq; [|exact Hx''pow].

  rewrite Rabs_R0.

  rewrite <- (Rmult_0_r (/ 2)).

  apply Rmult_lt_compat_l; [lra|apply bpow_gt_0].

Qed.



Lemma double_round_gt_mid_same_place :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) = fexp1 (ln_beta x))%Z ->

  midp' fexp1 x < x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 choice1 choice2 x Px Hf2f1 Hx'.

assert (Hx : round beta fexp1 Zceil x - x < / 2 * ulp beta fexp1 x).

{ apply (Rplus_lt_reg_r (- / 2 * ulp beta fexp1 x + x)); ring_simplify.

  now unfold midp' in Hx'. }

assert (H : Rabs (Z2R (Zceil (x * bpow (- fexp1 (ln_beta x))))

                  - x * bpow (- fexp1 (ln_beta x))) < / 2).

{ apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  unfold scaled_mantissa, canonic_exp in Hx.

  rewrite <- (Rabs_right (bpow (fexp1 _))) at 1;

    [|now apply Rle_ge; apply bpow_ge_0].

  rewrite <- Rabs_mult.

  rewrite Rmult_minus_distr_r.

  bpow_simplify.

  apply Rabs_lt.

  split.

  - apply Rlt_le_trans with 0.

    + rewrite <- Ropp_0; apply Ropp_lt_contravar.

      rewrite <- (Rmult_0_r (/ 2)).

      apply Rmult_lt_compat_l; [lra|].

      apply bpow_gt_0.

    + apply Rle_0_minus.

      apply round_UP_pt.

      exact Vfexp1.

  -  rewrite ulp_neq_0 in Hx;[exact Hx|now apply Rgt_not_eq]. }

unfold double_round_eq, round at 2.

unfold F2R, scaled_mantissa, canonic_exp; simpl.

rewrite Hf2f1.

rewrite (Znearest_imp _ _ (Zceil (scaled_mantissa beta fexp1 x))).

- rewrite round_generic.

  + unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

    now rewrite (Znearest_imp _ _ (Zceil (x * bpow (- fexp1 (ln_beta x)))));

      [|rewrite Rabs_minus_sym].

  + now apply valid_rnd_N.

  + fold (canonic_exp beta fexp1 x).

    change (Z2R _ * bpow _) with (round beta fexp1 Zceil x).

    apply generic_format_round.

    exact Vfexp1.

    now apply valid_rnd_UP.

- now rewrite Rabs_minus_sym.

Qed.



Lemma double_round_gt_mid :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x))%Z ->

  (fexp1 (ln_beta x) <= ln_beta x)%Z ->

  midp' fexp1 x < x ->

  ((fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

   midp' fexp1 x + / 2 * ulp beta fexp2 x < x) ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1 Hf1 Hx Hx'.

destruct (Zle_or_lt (fexp1 (ln_beta x)) (fexp2 (ln_beta x))) as [Hf2'|Hf2'].

- 

  assert (Hf2'' : (fexp2 (ln_beta x) = fexp1 (ln_beta x) :> Z)%Z); [omega|].

  now apply double_round_gt_mid_same_place.

- 

  assert (Hf2'' : (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z); [omega|].

  generalize (Hx' Hf2''); intro Hx''.

  now apply double_round_gt_mid_further_place.

Qed.



Section Double_round_mult.



Lemma ln_beta_mult_disj :

  forall x y,

  x <> 0 -> y <> 0 ->

  ((ln_beta (x * y) = (ln_beta x + ln_beta y - 1)%Z :> Z)

   \/ (ln_beta (x * y) = (ln_beta x + ln_beta y)%Z :> Z)).

Proof.

intros x y Zx Zy.

destruct (ln_beta_mult beta x y Zx Zy).

omega.

Qed.



Definition double_round_mult_hyp fexp1 fexp2 :=

  (forall ex ey, (fexp2 (ex + ey) <= fexp1 ex + fexp1 ey)%Z)

  /\ (forall ex ey, (fexp2 (ex + ey - 1) <= fexp1 ex + fexp1 ey)%Z).



Lemma double_round_mult_aux :

  forall (fexp1 fexp2 : Z -> Z),

  double_round_mult_hyp fexp1 fexp2 ->

  forall x y,

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x * y).

Proof.

intros fexp1 fexp2 Hfexp x y Fx Fy.

destruct (Req_dec x 0) as [Zx|Zx].

- 

  rewrite Zx.

  rewrite Rmult_0_l.

  now apply generic_format_0.

- 

  destruct (Req_dec y 0) as [Zy|Zy].

  + 

    rewrite Zy.

    rewrite Rmult_0_r.

    now apply generic_format_0.

  + 

    revert Fx Fy.

    unfold generic_format.

    unfold canonic_exp.

    set (mx := Ztrunc (scaled_mantissa beta fexp1 x)).

    set (my := Ztrunc (scaled_mantissa beta fexp1 y)).

    unfold F2R; simpl.

    intros Fx Fy.

    set (fxy := Float beta (mx * my) (fexp1 (ln_beta x) + fexp1 (ln_beta y))).

    assert (Hxy : x * y = F2R fxy).

    { unfold fxy, F2R; simpl.

      rewrite bpow_plus.

      rewrite Z2R_mult.

      rewrite Fx, Fy at 1.

      ring. }

    apply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].

    intros _.

    unfold canonic_exp, fxy; simpl.

    destruct Hfexp as (Hfexp1, Hfexp2).

    now destruct (ln_beta_mult_disj x y Zx Zy) as [Lxy|Lxy]; rewrite Lxy.

Qed.



Variable rnd : R -> Z.

Context { valid_rnd : Valid_rnd rnd }.



Theorem double_round_mult :

  forall (fexp1 fexp2 : Z -> Z),

  double_round_mult_hyp fexp1 fexp2 ->

  forall x y,

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  round beta fexp1 rnd (round beta fexp2 rnd (x * y))

  = round beta fexp1 rnd (x * y).

Proof.

intros fexp1 fexp2 Hfexp x y Fx Fy.

assert (Hxy : round beta fexp2 rnd (x * y) = x * y).

{ apply round_generic; [assumption|].

  now apply (double_round_mult_aux fexp1 fexp2). }

now rewrite Hxy at 1.

Qed.



Section Double_round_mult_FLX.



Import Fcore_FLX.



Variable prec : Z.

Variable prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Theorem double_round_mult_FLX :

  (2 * prec <= prec')%Z ->

  forall x y,

  FLX_format beta prec x -> FLX_format beta prec y ->

  round beta (FLX_exp prec) rnd (round beta (FLX_exp prec') rnd (x * y))

  = round beta (FLX_exp prec) rnd (x * y).

Proof.

intros Hprec x y Fx Fy.

apply double_round_mult;

  [|now apply generic_format_FLX|now apply generic_format_FLX].

unfold double_round_mult_hyp; split; intros ex ey; unfold FLX_exp;

omega.

Qed.



End Double_round_mult_FLX.



Section Double_round_mult_FLT.



Import Fcore_FLX.

Import Fcore_FLT.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Theorem double_round_mult_FLT :

  (emin' <= 2 * emin)%Z -> (2 * prec <= prec')%Z ->

  forall x y,

  FLT_format beta emin prec x -> FLT_format beta emin prec y ->

  round beta (FLT_exp emin prec) rnd

        (round beta (FLT_exp emin' prec') rnd (x * y))

  = round beta (FLT_exp emin prec) rnd (x * y).

Proof.

intros Hemin Hprec x y Fx Fy.

apply double_round_mult;

  [|now apply generic_format_FLT|now apply generic_format_FLT].

unfold double_round_mult_hyp; split; intros ex ey;

unfold FLT_exp;

generalize (Zmax_spec (ex + ey - prec') emin');

generalize (Zmax_spec (ex + ey - 1 - prec') emin');

generalize (Zmax_spec (ex - prec) emin);

generalize (Zmax_spec (ey - prec) emin);

omega.

Qed.



End Double_round_mult_FLT.



Section Double_round_mult_FTZ.



Import Fcore_FLX.

Import Fcore_FTZ.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Theorem double_round_mult_FTZ :

  (emin' + prec' <= 2 * emin + prec)%Z ->

  (2 * prec <= prec')%Z ->

  forall x y,

  FTZ_format beta emin prec x -> FTZ_format beta emin prec y ->

  round beta (FTZ_exp emin prec) rnd

        (round beta (FTZ_exp emin' prec') rnd (x * y))

  = round beta (FTZ_exp emin prec) rnd (x * y).

Proof.

intros Hemin Hprec x y Fx Fy.

apply double_round_mult;

  [|now apply generic_format_FTZ|now apply generic_format_FTZ].

unfold double_round_mult_hyp; split; intros ex ey;

unfold FTZ_exp;

unfold Prec_gt_0 in *;

destruct (Z.ltb_spec (ex + ey - prec') emin');

destruct (Z.ltb_spec (ex - prec) emin);

destruct (Z.ltb_spec (ey - prec) emin);

destruct (Z.ltb_spec (ex + ey - 1 - prec') emin');

omega.

Qed.



End Double_round_mult_FTZ.



End Double_round_mult.



Section Double_round_plus.



Lemma ln_beta_plus_disj :

  forall x y,

  0 < y -> y <= x ->

  ((ln_beta (x + y) = ln_beta x :> Z)

   \/ (ln_beta (x + y) = (ln_beta x + 1)%Z :> Z)).

Proof.

intros x y Py Hxy.

destruct (ln_beta_plus beta x y Py Hxy).

omega.

Qed.



Lemma ln_beta_plus_separated :

  forall fexp : Z -> Z,

  forall x y,

  0 < x -> 0 <= y ->

  generic_format beta fexp x ->

  (ln_beta y <= fexp (ln_beta x))%Z ->

  (ln_beta (x + y) = ln_beta x :> Z).

Proof.

intros fexp x y Px Nny Fx Hsep.

destruct (Req_dec y 0) as [Zy|Nzy].

- 

  now rewrite Zy; rewrite Rplus_0_r.

- 

  apply (ln_beta_plus_eps beta fexp); [assumption|assumption|].

  split; [assumption|].

  rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq].

  unfold canonic_exp.

  destruct (ln_beta y) as (ey, Hey); simpl in *.

  apply Rlt_le_trans with (bpow ey).

  + now rewrite <- (Rabs_right y); [apply Hey|apply Rle_ge].

  + now apply bpow_le.

Qed.



Lemma ln_beta_minus_disj :

  forall x y,

  0 < x -> 0 < y ->

  (ln_beta y <= ln_beta x - 2)%Z ->

  ((ln_beta (x - y) = ln_beta x :> Z)

   \/ (ln_beta (x - y) = (ln_beta x - 1)%Z :> Z)).

Proof.

intros x y Px Py Hln.

assert (Hxy : y < x); [now apply (ln_beta_lt_pos beta); [ |omega]|].

generalize (ln_beta_minus beta x y Py Hxy); intro Hln2.

generalize (ln_beta_minus_lb beta x y Px Py Hln); intro Hln3.

omega.

Qed.



Lemma ln_beta_minus_separated :

  forall fexp : Z -> Z, Valid_exp fexp ->

  forall x y,

  0 < x -> 0 < y -> y < x ->

  bpow (ln_beta x - 1) < x ->

  generic_format beta fexp x -> (ln_beta y <= fexp (ln_beta x))%Z ->

  (ln_beta (x - y) = ln_beta x :> Z).

Proof.

intros fexp Vfexp x y Px Py Yltx Xgtpow Fx Ly.

apply ln_beta_unique.

split.

- apply Rabs_ge; right.

  assert (Hy : y < ulp beta fexp (bpow (ln_beta x - 1))).

  { rewrite ulp_bpow.

    replace (_ + _)%Z with (ln_beta x : Z) by ring.

    rewrite <- (Rabs_right y); [|now apply Rle_ge; apply Rlt_le].

    apply Rlt_le_trans with (bpow (ln_beta y)).

    - apply bpow_ln_beta_gt.

    - now apply bpow_le. }

  apply (Rplus_le_reg_r y); ring_simplify.

  apply Rle_trans with (bpow (ln_beta x - 1)

                        + ulp beta fexp (bpow (ln_beta x - 1))).

  + now apply Rplus_le_compat_l; apply Rlt_le.

  + rewrite <- succ_eq_pos;[idtac|apply bpow_ge_0].

    apply succ_le_lt; [apply Vfexp|idtac|exact Fx|assumption].

    apply (generic_format_bpow beta fexp (ln_beta x - 1)).

    replace (_ + _)%Z with (ln_beta x : Z) by ring.

    assert (fexp (ln_beta x) < ln_beta x)%Z; [|omega].

    now apply ln_beta_generic_gt; [|now apply Rgt_not_eq|].

- rewrite Rabs_right.

  + apply Rlt_trans with x.

    * rewrite <- (Rplus_0_r x) at 2.

      apply Rplus_lt_compat_l.

      rewrite <- Ropp_0.

      now apply Ropp_lt_contravar.

    * apply Rabs_lt_inv.

      apply bpow_ln_beta_gt.

  + lra.

Qed.



Definition double_round_plus_hyp fexp1 fexp2 :=

  (forall ex ey, (fexp1 (ex + 1) - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z)

  /\ (forall ex ey, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z)

  /\ (forall ex ey, (fexp1 ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z)

  /\ (forall ex ey, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z).



Lemma double_round_plus_aux0_aux_aux :

  forall (fexp1 fexp2 : Z -> Z),

  forall x y,

  (fexp1 (ln_beta x) <= fexp1 (ln_beta y))%Z ->

  (fexp2 (ln_beta (x + y))%Z <= fexp1 (ln_beta x))%Z ->

  (fexp2 (ln_beta (x + y))%Z <= fexp1 (ln_beta y))%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x + y).

Proof.

intros fexp1 fexp2 x y Oxy Hlnx Hlny Fx Fy.

destruct (Req_dec x 0) as [Zx|Nzx].

- 

  rewrite Zx, Rplus_0_l in Hlny |- *.

  now apply (generic_inclusion_ln_beta beta fexp1).

- 

  destruct (Req_dec y 0) as [Zy|Nzy].

  + 

    rewrite Zy, Rplus_0_r in Hlnx |- *.

    now apply (generic_inclusion_ln_beta beta fexp1).

  + 

    revert Fx Fy.

    unfold generic_format at -3, canonic_exp, F2R; simpl.

    set (mx := Ztrunc (scaled_mantissa beta fexp1 x)).

    set (my := Ztrunc (scaled_mantissa beta fexp1 y)).

    intros Fx Fy.

    set (fxy := Float beta (mx + my * (beta ^ (fexp1 (ln_beta y)

                                               - fexp1 (ln_beta x))))

                      (fexp1 (ln_beta x))).

    assert (Hxy : x + y = F2R fxy).

    { unfold fxy, F2R; simpl.

      rewrite Z2R_plus.

      rewrite Rmult_plus_distr_r.

      rewrite <- Fx.

      rewrite Z2R_mult.

      rewrite Z2R_Zpower; [|omega].

      bpow_simplify.

      now rewrite <- Fy. }

    apply generic_format_F2R' with (f := fxy); [now rewrite Hxy|].

    intros _.

    now unfold canonic_exp, fxy; simpl.

Qed.



Lemma double_round_plus_aux0_aux :

  forall (fexp1 fexp2 : Z -> Z),

  forall x y,

  (fexp2 (ln_beta (x + y))%Z <= fexp1 (ln_beta x))%Z ->

  (fexp2 (ln_beta (x + y))%Z <= fexp1 (ln_beta y))%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x + y).

Proof.

intros fexp1 fexp2 x y Hlnx Hlny Fx Fy.

destruct (Z.le_gt_cases (fexp1 (ln_beta x)) (fexp1 (ln_beta y))) as [Hle|Hgt].

- now apply (double_round_plus_aux0_aux_aux fexp1).

- rewrite Rplus_comm in Hlnx, Hlny |- *.

  now apply (double_round_plus_aux0_aux_aux fexp1); [omega| | | |].

Qed.



Lemma double_round_plus_aux0 :

  forall (fexp1 fexp2 : Z -> Z), Valid_exp fexp1 ->

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  (0 < x)%R -> (0 < y)%R -> (y <= x)%R ->

  (fexp1 (ln_beta x) - 1 <= ln_beta y)%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x + y).

Proof.

intros fexp1 fexp2 Vfexp1 Hexp x y Px Py Hyx Hln Fx Fy.

assert (Nny : (0 <= y)%R); [now apply Rlt_le|].

destruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).

destruct (Z.le_gt_cases (ln_beta y) (fexp1 (ln_beta x))) as [Hle|Hgt].

- 

  assert (Lxy : ln_beta (x + y) = ln_beta x :> Z);

  [now apply (ln_beta_plus_separated fexp1)|].

  apply (double_round_plus_aux0_aux fexp1);

    [| |assumption|assumption]; rewrite Lxy.

  + now apply Hexp4; omega.

  + now apply Hexp3; omega.

- 

  apply (double_round_plus_aux0_aux fexp1); [| |assumption|assumption].

  destruct (ln_beta_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.

  + now apply Hexp4; omega.

  + apply Hexp2; apply (ln_beta_le beta y x Py) in Hyx.

    replace (_ - _)%Z with (ln_beta x : Z) by ring.

    omega.

  + destruct (ln_beta_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.

    * now apply Hexp3; omega.

    * apply Hexp2.

      replace (_ - _)%Z with (ln_beta x : Z) by ring.

      omega.

Qed.



Lemma double_round_plus_aux1_aux :

  forall k, (0 < k)%Z ->

  forall (fexp : Z -> Z),

  forall x y,

  0 < x -> 0 < y ->

  (ln_beta y <= fexp (ln_beta x) - k)%Z ->

  (ln_beta (x + y) = ln_beta x :> Z) ->

  generic_format beta fexp x ->

  0 < (x + y) - round beta fexp Zfloor (x + y) < bpow (fexp (ln_beta x) - k).

Proof.

assert (Hbeta : (2 <= beta)%Z).

{ destruct beta as (beta_val,beta_prop).

  now apply Zle_bool_imp_le. }

intros k Hk fexp x y Px Py Hln Hlxy Fx.

revert Fx.

unfold round, generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

rewrite Hlxy.

set (mx := Ztrunc (x * bpow (- fexp (ln_beta x)))).

intros Fx.

assert (R : (x + y) * bpow (- fexp (ln_beta x))

            = Z2R mx + y * bpow (- fexp (ln_beta x))).

{ rewrite Fx at 1.

  rewrite Rmult_plus_distr_r.

  now bpow_simplify. }

rewrite R.

assert (LB : 0 < y * bpow (- fexp (ln_beta x))).

{ rewrite <- (Rmult_0_r y).

  now apply Rmult_lt_compat_l; [|apply bpow_gt_0]. }

assert (UB : y * bpow (- fexp (ln_beta x)) < / Z2R (beta ^ k)).

{ apply Rlt_le_trans with (bpow (ln_beta y) * bpow (- fexp (ln_beta x))).

  - apply Rmult_lt_compat_r; [now apply bpow_gt_0|].

    rewrite <- (Rabs_right y) at 1; [|now apply Rle_ge; apply Rlt_le].

    apply bpow_ln_beta_gt.

  - apply Rle_trans with (bpow (fexp (ln_beta x) - k)

                          * bpow (- fexp (ln_beta x)))%R.

    + apply Rmult_le_compat_r; [now apply bpow_ge_0|].

      now apply bpow_le.

    + bpow_simplify.

      rewrite bpow_opp.

      destruct k.

      * omega.

      * simpl; unfold Fcore_Raux.bpow, Z.pow_pos.

        now apply Rle_refl.

      * casetype False; apply (Zlt_irrefl 0).

        apply (Zlt_trans _ _ _ Hk).

        apply Zlt_neg_0. }

rewrite (Zfloor_imp mx).

{ split; ring_simplify.

  - apply (Rmult_lt_reg_r (bpow (- fexp (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite Rmult_minus_distr_r, Rmult_0_l.

    bpow_simplify.

    rewrite R; ring_simplify.

    now apply Rmult_lt_0_compat; [|apply bpow_gt_0].

  - apply (Rmult_lt_reg_r (bpow (- fexp (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite Rmult_minus_distr_r.

    bpow_simplify.

    rewrite R; ring_simplify.

    apply (Rlt_le_trans _ _ _ UB).

    rewrite bpow_opp.

    apply Rinv_le; [now apply bpow_gt_0|].

    now rewrite Z2R_Zpower; [right|omega]. }

split.

- rewrite <- Rplus_0_r at 1; apply Rplus_le_compat_l.

  now apply Rlt_le.

- rewrite Z2R_plus; apply Rplus_lt_compat_l.

  apply (Rmult_lt_reg_r (bpow (fexp (ln_beta x)))); [now apply bpow_gt_0|].

  rewrite Rmult_1_l.

  bpow_simplify.

  apply Rlt_trans with (bpow (ln_beta y)).

  + rewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].

    apply bpow_ln_beta_gt.

  + apply bpow_lt; omega.

Qed.



Lemma double_round_plus_aux1 :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y ->

  (ln_beta y <= fexp1 (ln_beta x) - 2)%Z ->

  generic_format beta fexp1 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

assert (Hbeta : (2 <= beta)%Z).

{ destruct beta as (beta_val,beta_prop).

  now apply Zle_bool_imp_le. }

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Hly Fx.

assert (Lxy : ln_beta (x + y) = ln_beta x :> Z);

  [now apply (ln_beta_plus_separated fexp1); [|apply Rlt_le| |omega]|].

destruct Hexp as (_,(_,(_,Hexp4))).

assert (Hf2 : (fexp2 (ln_beta x) <= fexp1 (ln_beta x))%Z);

  [now apply Hexp4; omega|].

assert (Bpow2 : bpow (- 2) <= / 2 * / 2).

{ replace (/2 * /2) with (/4) by field.

  rewrite (bpow_opp _ 2).

  apply Rinv_le; [lra|].

  apply (Z2R_le (2 * 2) (beta * (beta * 1))).

  rewrite Zmult_1_r.

  now apply Zmult_le_compat; omega. }

assert (P2 : (0 < 2)%Z) by omega.

unfold double_round_eq.

apply double_round_lt_mid.

- exact Vfexp1.

- exact Vfexp2.

- lra.

- now rewrite Lxy.

- rewrite Lxy.

  assert (fexp1 (ln_beta x) < ln_beta x)%Z; [|omega].

  now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

- unfold midp.

  apply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).

  apply (Rlt_le_trans _ _ _ (proj2 (double_round_plus_aux1_aux 2 P2 fexp1 x y Px

                                                               Py Hly Lxy Fx))).

  ring_simplify.

  rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].

  unfold canonic_exp; rewrite Lxy.

  apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  bpow_simplify.

  apply (Rle_trans _ _ _ Bpow2).

  rewrite <- (Rmult_1_r (/ 2)) at 3.

  apply Rmult_le_compat_l; lra.

- rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].

  unfold round, F2R, scaled_mantissa, canonic_exp; simpl; rewrite Lxy.

  intro Hf2'.

  apply (Rmult_lt_reg_r (bpow (- fexp1 (ln_beta x))));

    [now apply bpow_gt_0|].

  apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  bpow_simplify.

  apply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).

  unfold midp; ring_simplify.

  apply (Rlt_le_trans _ _ _ (proj2 (double_round_plus_aux1_aux 2 P2 fexp1 x y Px

                                                               Py Hly Lxy Fx))).

  apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

  rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].

  unfold canonic_exp; rewrite Lxy, Rmult_minus_distr_r; bpow_simplify.

  apply (Rle_trans _ _ _ Bpow2).

  rewrite <- (Rmult_1_r (/ 2)) at 3; rewrite <- Rmult_minus_distr_l.

  apply Rmult_le_compat_l; [lra|].

  apply (Rplus_le_reg_r (- 1)); ring_simplify.

  replace (_ - _) with (- (/ 2)) by lra.

  apply Ropp_le_contravar.

  { apply Rle_trans with (bpow (- 1)).

    - apply bpow_le; omega.

    - unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

      apply Rinv_le; [lra|].

      change 2 with (Z2R 2); apply Z2R_le; omega. }

Qed.



Lemma double_round_plus_aux2 :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y -> y <= x ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Hyx Fx Fy.

unfold double_round_eq.

destruct (Zle_or_lt (ln_beta y) (fexp1 (ln_beta x) - 2)) as [Hly|Hly].

- 

  now apply double_round_plus_aux1.

- 

  rewrite (round_generic beta fexp2).

  + reflexivity.

  + now apply valid_rnd_N.

  + assert (Hf1 : (fexp1 (ln_beta x) - 1 <= ln_beta y)%Z); [omega|].

    now apply (double_round_plus_aux0 fexp1).

Qed.



Lemma double_round_plus_aux :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 <= x -> 0 <= y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Nnx Nny Fx Fy.

unfold double_round_eq.

destruct (Req_dec x 0) as [Zx|Nzx].

- 

  destruct Hexp as (_,(_,(_,Hexp4))).

  rewrite Zx; rewrite Rplus_0_l.

  rewrite (round_generic beta fexp2).

  + reflexivity.

  + now apply valid_rnd_N.

  + apply (generic_inclusion_ln_beta beta fexp1).

    now intros _; apply Hexp4; omega.

    exact Fy.

- 

  destruct (Req_dec y 0) as [Zy|Nzy].

  + 

    destruct Hexp as (_,(_,(_,Hexp4))).

    rewrite Zy; rewrite Rplus_0_r.

    rewrite (round_generic beta fexp2).

    * reflexivity.

    * now apply valid_rnd_N.

    * apply (generic_inclusion_ln_beta beta fexp1).

      now intros _; apply Hexp4; omega.

      exact Fx.

  + 

    assert (Px : 0 < x); [lra|].

    assert (Py : 0 < y); [lra|].

    destruct (Rlt_or_le x y) as [H|H].

    * 

      apply Rlt_le in H.

      rewrite Rplus_comm.

      now apply double_round_plus_aux2.

    * now apply double_round_plus_aux2.

Qed.



Lemma double_round_minus_aux0_aux :

  forall (fexp1 fexp2 : Z -> Z),

  forall x y,

  (fexp2 (ln_beta (x - y))%Z <= fexp1 (ln_beta x))%Z ->

  (fexp2 (ln_beta (x - y))%Z <= fexp1 (ln_beta y))%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x - y).

Proof.

intros fexp1 fexp2 x y.

replace (x - y)%R with (x + (- y))%R; [|ring].

intros Hlnx Hlny Fx Fy.

rewrite <- (ln_beta_opp beta y) in Hlny.

apply generic_format_opp in Fy.

now apply (double_round_plus_aux0_aux fexp1).

Qed.



Lemma double_round_minus_aux0 :

  forall (fexp1 fexp2 : Z -> Z),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y < x ->

  (fexp1 (ln_beta x) - 1 <= ln_beta y)%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x - y).

Proof.

intros fexp1 fexp2 Hexp x y Py Hyx Hln Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hyx).

destruct Hexp as (Hexp1,(_,(Hexp3,Hexp4))).

assert (Lyx : (ln_beta y <= ln_beta x)%Z);

  [now apply ln_beta_le; [|apply Rlt_le]|].

destruct (Z.lt_ge_cases (ln_beta x - 2) (ln_beta y)) as [Hlt|Hge].

- 

  assert (Hor : (ln_beta y = ln_beta x :> Z)

                \/ (ln_beta y = ln_beta x - 1 :> Z)%Z); [omega|].

  destruct Hor as [Heq|Heqm1].

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

    * apply Hexp4.

      apply Zle_trans with (ln_beta (x - y)); [omega|].

      now apply ln_beta_minus.

    * rewrite Heq.

      apply Hexp4.

      apply Zle_trans with (ln_beta (x - y)); [omega|].

      now apply ln_beta_minus.

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

    * apply Hexp4.

      apply Zle_trans with (ln_beta (x - y)); [omega|].

      now apply ln_beta_minus.

    * rewrite Heqm1.

      apply Hexp4.

      apply Zplus_le_compat_r.

      now apply ln_beta_minus.

- 

  destruct (ln_beta_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

    * apply Hexp4.

      omega.

    * now rewrite Lxmy; apply Hexp3.

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];

    rewrite Lxmy.

    * apply Hexp1.

      replace (_ + _)%Z with (ln_beta x : Z); [|ring].

      now apply Zle_trans with (ln_beta y).

    * apply Hexp1.

      now replace (_ + _)%Z with (ln_beta x : Z); [|ring].

Qed.



Lemma double_round_minus_aux1 :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y < x ->

  (ln_beta y <= fexp1 (ln_beta x) - 2)%Z ->

  (fexp1 (ln_beta (x - y)) - 1 <= ln_beta y)%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x - y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2  Hexp x y Py Hyx Hln Hln' Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hyx).

destruct Hexp as (Hexp1,(Hexp2,(Hexp3,Hexp4))).

assert (Lyx : (ln_beta y <= ln_beta x)%Z);

  [now apply ln_beta_le; [|apply Rlt_le]|].

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Hfy : (fexp1 (ln_beta y) < ln_beta y)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

- apply Zle_trans with (fexp1 (ln_beta (x - y))).

  + apply Hexp4; omega.

  + omega.

- now apply Hexp3.

Qed.



Lemma double_round_minus_aux2_aux :

  forall (fexp : Z -> Z),

  Valid_exp fexp ->

  forall x y,

  0 < y -> y < x ->

  (ln_beta y <= fexp (ln_beta x) - 1)%Z ->

  generic_format beta fexp x ->

  generic_format beta fexp y ->

  round beta fexp Zceil (x - y) - (x - y) <= y.

Proof.

intros fexp Vfexp x y Py Hxy Hly Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hxy).

revert Fx.

unfold generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

set (mx := Ztrunc (x * bpow (- fexp (ln_beta x)))).

intro Fx.

assert (Hfx : (fexp (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Hfy : (fexp (ln_beta y) < ln_beta y)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

destruct (Rlt_or_le (bpow (ln_beta x - 1)) x) as [Hx|Hx].

- 

  assert (Lxy : ln_beta (x - y) = ln_beta x :> Z);

    [now apply (ln_beta_minus_separated fexp); [| | | | | |omega]|].

  assert (Rxy : round beta fexp Zceil (x - y) = x).

  { unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

    rewrite Lxy.

    apply eq_sym; rewrite Fx at 1; apply eq_sym.

    apply Rmult_eq_compat_r.

    apply f_equal.

    rewrite Fx at 1.

    rewrite Rmult_minus_distr_r.

    bpow_simplify.

    apply Zceil_imp.

    split.

    - unfold Zminus; rewrite Z2R_plus.

      apply Rplus_lt_compat_l.

      apply Ropp_lt_contravar; simpl.

      apply (Rmult_lt_reg_r (bpow (fexp (ln_beta x))));

        [now apply bpow_gt_0|].

      rewrite Rmult_1_l; bpow_simplify.

      apply Rlt_le_trans with (bpow (ln_beta y)).

      + rewrite <- Rabs_right at 1; [|now apply Rle_ge; apply Rlt_le].

        apply bpow_ln_beta_gt.

      + apply bpow_le.

        omega.

    - rewrite <- (Rplus_0_r (Z2R _)) at 2.

      apply Rplus_le_compat_l.

      rewrite <- Ropp_0; apply Ropp_le_contravar.

      rewrite <- (Rmult_0_r y).

      apply Rmult_le_compat_l; [now apply Rlt_le|].

      now apply bpow_ge_0. }

  rewrite Rxy; ring_simplify.

  apply Rle_refl.

- 

  assert (Xpow : x = bpow (ln_beta x - 1)).

  { apply Rle_antisym; [exact Hx|].

    destruct (ln_beta x) as (ex, Hex); simpl.

    rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].

    apply Hex.

    now apply Rgt_not_eq. }

  assert (Lxy : (ln_beta (x - y) = ln_beta x - 1 :> Z)%Z).

  { apply Zle_antisym.

    - apply ln_beta_le_bpow.

      + apply Rminus_eq_contra.

        now intro Hx'; rewrite Hx' in Hxy; apply (Rlt_irrefl y).

      + rewrite Rabs_right; lra.

    - apply (ln_beta_minus_lb beta x y Px Py).

      omega. }

  assert (Hfx1 : (fexp (ln_beta x - 1) < ln_beta x - 1)%Z);

    [now apply (valid_exp_large fexp (ln_beta y)); [|omega]|].

  assert (Rxy : round beta fexp Zceil (x - y) <= x).

  { rewrite Xpow at 2.

    unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

    rewrite Lxy.

    apply (Rmult_le_reg_r (bpow (- fexp (ln_beta x - 1)%Z)));

      [now apply bpow_gt_0|].

    bpow_simplify.

    rewrite <- (Z2R_Zpower beta (_ - _ - _)); [|omega].

    apply Z2R_le.

    apply Zceil_glb.

    rewrite Z2R_Zpower; [|omega].

    rewrite Xpow at 1.

    rewrite Rmult_minus_distr_r.

    bpow_simplify.

    rewrite <- (Rplus_0_r (bpow _)) at 2.

    apply Rplus_le_compat_l.

    rewrite <- Ropp_0; apply Ropp_le_contravar.

    rewrite <- (Rmult_0_r y).

    apply Rmult_le_compat_l; [now apply Rlt_le|].

    now apply bpow_ge_0. }

  lra.

Qed.



Lemma double_round_minus_aux2 :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y < x ->

  (ln_beta y <= fexp1 (ln_beta x) - 2)%Z ->

  (ln_beta y <= fexp1 (ln_beta (x - y)) - 2)%Z ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

assert (Hbeta : (2 <= beta)%Z).

{ destruct beta as (beta_val,beta_prop).

  now apply Zle_bool_imp_le. }

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Py Hxy Hly Hly' Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hxy).

destruct Hexp as (_,(_,(_,Hexp4))).

assert (Hf2 : (fexp2 (ln_beta x) <= fexp1 (ln_beta x))%Z);

  [now apply Hexp4; omega|].

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Bpow2 : bpow (- 2) <= / 2 * / 2).

{ replace (/2 * /2) with (/4) by field.

  rewrite (bpow_opp _ 2).

  apply Rinv_le; [lra|].

  apply (Z2R_le (2 * 2) (beta * (beta * 1))).

  rewrite Zmult_1_r.

  now apply Zmult_le_compat; omega. }

assert (Ly : y < bpow (ln_beta y)).

{ apply Rabs_lt_inv.

  apply bpow_ln_beta_gt. }

unfold double_round_eq.

apply double_round_gt_mid.

- exact Vfexp1.

- exact Vfexp2.

- lra.

- apply Hexp4; omega.

- assert (fexp1 (ln_beta (x - y)) < ln_beta (x - y))%Z; [|omega].

  apply (valid_exp_large fexp1 (ln_beta x - 1)).

  + apply (valid_exp_large fexp1 (ln_beta y)); [|omega].

    now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

  + now apply ln_beta_minus_lb; [| |omega].

- unfold midp'.

  apply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).

  ring_simplify.

  replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.

  apply Rlt_le_trans with (bpow (fexp1 (ln_beta (x - y)) - 2)).

  + apply Rle_lt_trans with y;

    [now apply double_round_minus_aux2_aux; try assumption; omega|].

    apply (Rlt_le_trans _ _ _ Ly).

    now apply bpow_le.

  + rewrite ulp_neq_0;[idtac|now apply sym_not_eq, Rlt_not_eq, Rgt_minus].

    unfold canonic_exp.

    replace (_ - 2)%Z with (fexp1 (ln_beta (x - y)) - 1 - 1)%Z by ring.

    unfold Zminus at 1; rewrite bpow_plus.

    rewrite Rmult_comm.

    apply Rmult_le_compat.

    * now apply bpow_ge_0.

    * now apply bpow_ge_0.

    * unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

      rewrite Zmult_1_r; apply Rinv_le.

      lra.

      now change 2 with (Z2R 2); apply Z2R_le.

    * apply bpow_le; omega.

- intro Hf2'.

  unfold midp'.

  apply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y)

                         - / 2 * ulp beta fexp2 (x - y))).

  ring_simplify.

  replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.

  apply Rle_lt_trans with y;

    [now apply double_round_minus_aux2_aux; try assumption; omega|].

  apply (Rlt_le_trans _ _ _ Ly).

  apply Rle_trans with (bpow (fexp1 (ln_beta (x - y)) - 2));

    [now apply bpow_le|].

  replace (_ - 2)%Z with (fexp1 (ln_beta (x - y)) - 1 - 1)%Z by ring.

  unfold Zminus at 1; rewrite bpow_plus.

  rewrite <- Rmult_minus_distr_l.

  rewrite Rmult_comm; apply Rmult_le_compat.

  + apply bpow_ge_0.

  + apply bpow_ge_0.

  + unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

    rewrite Zmult_1_r; apply Rinv_le; [lra|].

    now change 2 with (Z2R 2); apply Z2R_le.

  + rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.

    unfold canonic_exp.

    apply (Rplus_le_reg_r (bpow (fexp2 (ln_beta (x - y))))); ring_simplify.

    apply Rle_trans with (2 * bpow (fexp1 (ln_beta (x - y)) - 1)).

    * replace (2 * bpow (fexp1 (ln_beta (x - y)) - 1)) with (bpow (fexp1 (ln_beta (x - y)) - 1) + bpow (fexp1 (ln_beta (x - y)) - 1)) by ring.

      apply Rplus_le_compat_l.

      now apply bpow_le.

    * unfold Zminus; rewrite bpow_plus.

      rewrite Rmult_comm; rewrite Rmult_assoc.

      rewrite <- Rmult_1_r.

      apply Rmult_le_compat_l; [now apply bpow_ge_0|].

      unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

      rewrite Zmult_1_r.

      apply Z2R_le, Rinv_le in Hbeta.

      simpl in Hbeta.

      lra.

      apply Rlt_0_2.

Qed.



Lemma double_round_minus_aux3 :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y <= x ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Py Hyx Fx Fy.

assert (Px := Rlt_le_trans 0 y x Py Hyx).

unfold double_round_eq.

destruct (Req_dec y x) as [Hy|Hy].

- 

  rewrite Hy; replace (x - x) with 0 by ring.

  rewrite round_0.

  + reflexivity.

  + now apply valid_rnd_N.

- 

  assert (Hyx' : y < x); [lra|].

  destruct (Zle_or_lt (ln_beta y) (fexp1 (ln_beta x) - 2)) as [Hly|Hly].

  + 

    destruct (Zle_or_lt (ln_beta y) (fexp1 (ln_beta (x - y)) - 2))

      as [Hly'|Hly'].

    * 

      now apply double_round_minus_aux2.

    * 

      { rewrite (round_generic beta fexp2).

        - reflexivity.

        - now apply valid_rnd_N.

        - assert (Hf1 : (fexp1 (ln_beta (x - y)) - 1 <= ln_beta y)%Z); [omega|].

          now apply (double_round_minus_aux1 fexp1). }

  + rewrite (round_generic beta fexp2).

    * reflexivity.

    * now apply valid_rnd_N.

    * assert (Hf1 : (fexp1 (ln_beta x) - 1 <= ln_beta y)%Z); [omega|].

      now apply (double_round_minus_aux0 fexp1).

Qed.



Lemma double_round_minus_aux :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  0 <= x -> 0 <= y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Nnx Nny Fx Fy.

unfold double_round_eq.

destruct (Req_dec x 0) as [Zx|Nzx].

- 

  rewrite Zx; unfold Rminus; rewrite Rplus_0_l.

  do 3 rewrite round_N_opp.

  rewrite (round_generic beta fexp2).

  * reflexivity.

  * now apply valid_rnd_N.

  * apply (generic_inclusion_ln_beta beta fexp1).

    destruct Hexp as (_,(_,(_,Hexp4))).

    now intros _; apply Hexp4; omega.

    exact Fy.

- 

  destruct (Req_dec y 0) as [Zy|Nzy].

  + 

    rewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.

    rewrite (round_generic beta fexp2).

    * reflexivity.

    * now apply valid_rnd_N.

    * apply (generic_inclusion_ln_beta beta fexp1).

      destruct Hexp as (_,(_,(_,Hexp4))).

      now intros _; apply Hexp4; omega.

      exact Fx.

  + 

    assert (Px : 0 < x); [lra|].

    assert (Py : 0 < y); [lra|].

    destruct (Rlt_or_le x y) as [H|H].

    * 

      apply Rlt_le in H.

      replace (x - y) with (- (y - x)) by ring.

      do 3 rewrite round_N_opp.

      apply Ropp_eq_compat.

      now apply double_round_minus_aux3.

    * 

      now apply double_round_minus_aux3.

Qed.



Lemma double_round_plus :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Fx Fy.

unfold double_round_eq.

destruct (Rlt_or_le x 0) as [Sx|Sx]; destruct (Rlt_or_le y 0) as [Sy|Sy].

- 

  replace (x + y) with (- (- x - y)); [|ring].

  do 3 rewrite round_N_opp.

  apply Ropp_eq_compat.

  assert (Px : 0 <= - x); [lra|].

  assert (Py : 0 <= - y); [lra|].

  apply generic_format_opp in Fx.

  apply generic_format_opp in Fy.

  now apply double_round_plus_aux.

- 

  replace (x + y) with (y - (- x)); [|ring].

  assert (Px : 0 <= - x); [lra|].

  apply generic_format_opp in Fx.

  now apply double_round_minus_aux.

- 

  replace (x + y) with (x - (- y)); [|ring].

  assert (Py : 0 <= - y); [lra|].

  apply generic_format_opp in Fy.

  now apply double_round_minus_aux.

- 

  now apply double_round_plus_aux.

Qed.



Lemma double_round_minus :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_hyp fexp1 fexp2 ->

  forall x y,

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Fx Fy.

unfold Rminus.

apply generic_format_opp in Fy.

now apply double_round_plus.

Qed.



Section Double_round_plus_FLX.



Import Fcore_FLX.



Variable prec : Z.

Variable prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLX_double_round_plus_hyp :

  (2 * prec + 1 <= prec')%Z ->

  double_round_plus_hyp (FLX_exp prec) (FLX_exp prec').

Proof.

intros Hprec.

unfold FLX_exp.

unfold double_round_plus_hyp; split; [|split; [|split]];

intros ex ey; try omega.

unfold Prec_gt_0 in prec_gt_0_.

omega.

Qed.



Theorem double_round_plus_FLX :

  forall choice1 choice2,

  (2 * prec + 1 <= prec')%Z ->

  forall x y,

  FLX_format beta prec x -> FLX_format beta prec y ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x + y).

Proof.

intros choice1 choice2 Hprec x y Fx Fy.

apply double_round_plus.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- now apply FLX_double_round_plus_hyp.

- now apply generic_format_FLX.

- now apply generic_format_FLX.

Qed.



Theorem double_round_minus_FLX :

  forall choice1 choice2,

  (2 * prec + 1 <= prec')%Z ->

  forall x y,

  FLX_format beta prec x -> FLX_format beta prec y ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x - y).

Proof.

intros choice1 choice2 Hprec x y Fx Fy.

apply double_round_minus.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- now apply FLX_double_round_plus_hyp.

- now apply generic_format_FLX.

- now apply generic_format_FLX.

Qed.



End Double_round_plus_FLX.



Section Double_round_plus_FLT.



Import Fcore_FLX.

Import Fcore_FLT.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLT_double_round_plus_hyp :

  (emin' <= emin)%Z -> (2 * prec + 1 <= prec')%Z ->

  double_round_plus_hyp (FLT_exp emin prec) (FLT_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FLT_exp.

unfold double_round_plus_hyp; split; [|split; [|split]]; intros ex ey.

- generalize (Zmax_spec (ex + 1 - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

- generalize (Zmax_spec (ex - 1 - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

- unfold Prec_gt_0 in prec_gt_0_.

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

Qed.



Theorem double_round_plus_FLT :

  forall choice1 choice2,

  (emin' <= emin)%Z -> (2 * prec + 1 <= prec')%Z ->

  forall x y,

  FLT_format beta emin prec x -> FLT_format beta emin prec y ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (x + y).

Proof.

intros choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_plus.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- now apply FLT_double_round_plus_hyp.

- now apply generic_format_FLT.

- now apply generic_format_FLT.

Qed.



Theorem double_round_minus_FLT :

  forall choice1 choice2,

  (emin' <= emin)%Z -> (2 * prec + 1 <= prec')%Z ->

  forall x y,

  FLT_format beta emin prec x -> FLT_format beta emin prec y ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (x - y).

Proof.

intros choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_minus.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- now apply FLT_double_round_plus_hyp.

- now apply generic_format_FLT.

- now apply generic_format_FLT.

Qed.



End Double_round_plus_FLT.



Section Double_round_plus_FTZ.



Import Fcore_FLX.

Import Fcore_FTZ.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FTZ_double_round_plus_hyp :

  (emin' + prec' <= emin + 1)%Z -> (2 * prec + 1 <= prec')%Z ->

  double_round_plus_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FTZ_exp.

unfold Prec_gt_0 in *.

unfold double_round_plus_hyp; split; [|split; [|split]]; intros ex ey.

- destruct (Z.ltb_spec (ex + 1 - prec) emin);

  destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - 1 - prec) emin);

  destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

Qed.



Theorem double_round_plus_FTZ :

  forall choice1 choice2,

  (emin' + prec' <= emin + 1)%Z -> (2 * prec + 1 <= prec')%Z ->

  forall x y,

  FTZ_format beta emin prec x -> FTZ_format beta emin prec y ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (x + y).

Proof.

intros choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_plus.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- now apply FTZ_double_round_plus_hyp.

- now apply generic_format_FTZ.

- now apply generic_format_FTZ.

Qed.



Theorem double_round_minus_FTZ :

  forall choice1 choice2,

  (emin' + prec' <= emin + 1)%Z -> (2 * prec + 1 <= prec')%Z ->

  forall x y,

  FTZ_format beta emin prec x -> FTZ_format beta emin prec y ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (x - y).

Proof.

intros choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_minus.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- now apply FTZ_double_round_plus_hyp.

- now apply generic_format_FTZ.

- now apply generic_format_FTZ.

Qed.



End Double_round_plus_FTZ.



Section Double_round_plus_beta_ge_3.



Definition double_round_plus_beta_ge_3_hyp fexp1 fexp2 :=

  (forall ex ey, (fexp1 (ex + 1) <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z)

  /\ (forall ex ey, (fexp1 (ex - 1) + 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z)

  /\ (forall ex ey, (fexp1 ex <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z)

  /\ (forall ex ey, (ex - 1 <= ey)%Z -> (fexp2 ex <= fexp1 ey)%Z).



Lemma double_round_plus_beta_ge_3_aux0 :

  forall (fexp1 fexp2 : Z -> Z), Valid_exp fexp1 ->

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  (0 < y)%R -> (y <= x)%R ->

  (fexp1 (ln_beta x) <= ln_beta y)%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x + y).

Proof.

intros fexp1 fexp2 Vfexp1 Hexp x y Py Hyx Hln Fx Fy.

assert (Px := Rlt_le_trans 0 y x Py Hyx).

assert (Nny : (0 <= y)%R); [now apply Rlt_le|].

destruct Hexp as (_,(Hexp2,(Hexp3,Hexp4))).

destruct (Z.le_gt_cases (ln_beta y) (fexp1 (ln_beta x))) as [Hle|Hgt].

- 

  assert (Lxy : ln_beta (x + y) = ln_beta x :> Z);

  [now apply (ln_beta_plus_separated fexp1)|].

  apply (double_round_plus_aux0_aux fexp1);

    [| |assumption|assumption]; rewrite Lxy.

  + now apply Hexp4; omega.

  + now apply Hexp3; omega.

- 

  apply (double_round_plus_aux0_aux fexp1); [| |assumption|assumption].

  destruct (ln_beta_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.

  + now apply Hexp4; omega.

  + apply Hexp2; apply (ln_beta_le beta y x Py) in Hyx.

    replace (_ - _)%Z with (ln_beta x : Z) by ring.

    omega.

  + destruct (ln_beta_plus_disj x y Py Hyx) as [Lxy|Lxy]; rewrite Lxy.

    * now apply Hexp3; omega.

    * apply Hexp2.

      replace (_ - _)%Z with (ln_beta x : Z) by ring.

      omega.

Qed.



Lemma double_round_plus_beta_ge_3_aux1 :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y ->

  (ln_beta y <= fexp1 (ln_beta x) - 1)%Z ->

  generic_format beta fexp1 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Hly Fx.

assert (Lxy : ln_beta (x + y) = ln_beta x :> Z);

  [now apply (ln_beta_plus_separated fexp1); [|apply Rlt_le| |omega]|].

destruct Hexp as (_,(_,(_,Hexp4))).

assert (Hf2 : (fexp2 (ln_beta x) <= fexp1 (ln_beta x))%Z);

  [now apply Hexp4; omega|].

assert (Bpow3 : bpow (- 1) <= / 3).

{ unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

  rewrite Zmult_1_r.

  apply Rinv_le; [lra|].

  now change 3 with (Z2R 3); apply Z2R_le. }

assert (P1 : (0 < 1)%Z) by omega.

unfold double_round_eq.

apply double_round_lt_mid.

- exact Vfexp1.

- exact Vfexp2.

- lra.

- now rewrite Lxy.

- rewrite Lxy.

  assert (fexp1 (ln_beta x) < ln_beta x)%Z; [|omega].

  now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

- unfold midp.

  apply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))).

  apply (Rlt_le_trans _ _ _ (proj2 (double_round_plus_aux1_aux 1 P1 fexp1 x y Px

                                                               Py Hly Lxy Fx))).

  ring_simplify.

  rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].

  unfold canonic_exp; rewrite Lxy.

  apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

    [now apply bpow_gt_0|].

  bpow_simplify.

  apply (Rle_trans _ _ _ Bpow3); lra.

- rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].

  unfold round, F2R, scaled_mantissa, canonic_exp; simpl; rewrite Lxy.

  intro Hf2'.

  unfold midp.

  apply (Rplus_lt_reg_r (- round beta fexp1 Zfloor (x + y))); ring_simplify.

  rewrite <- Rmult_minus_distr_l.

  apply (Rlt_le_trans _ _ _ (proj2 (double_round_plus_aux1_aux 1 P1 fexp1 x y Px

                                                               Py Hly Lxy Fx))).

  rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rplus_lt_0_compat].

  unfold canonic_exp; rewrite Lxy.

  apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

    [now apply bpow_gt_0|].

  rewrite (Rmult_assoc (/ 2)).

  rewrite Rmult_minus_distr_r.

  bpow_simplify.

  apply (Rle_trans _ _ _ Bpow3).

  apply Rle_trans with (/ 2 * (2 / 3)); [lra|].

  apply Rmult_le_compat_l; [lra|].

  apply (Rplus_le_reg_r (- 1)); ring_simplify.

  replace (_ - _) with (- (/ 3)) by lra.

  apply Ropp_le_contravar.

  now apply Rle_trans with (bpow (- 1)); [apply bpow_le; omega|].

Qed.



Lemma double_round_plus_beta_ge_3_aux2 :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y <= x ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Py Hyx Fx Fy.

assert (Px := Rlt_le_trans 0 y x Py Hyx).

unfold double_round_eq.

destruct (Zle_or_lt (ln_beta y) (fexp1 (ln_beta x) - 1)) as [Hly|Hly].

- 

  now apply double_round_plus_beta_ge_3_aux1.

- 

  rewrite (round_generic beta fexp2).

  + reflexivity.

  + now apply valid_rnd_N.

  + assert (Hf1 : (fexp1 (ln_beta x) <= ln_beta y)%Z); [omega|].

    now apply (double_round_plus_beta_ge_3_aux0 fexp1).

Qed.



Lemma double_round_plus_beta_ge_3_aux :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 <= x -> 0 <= y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Nnx Nny Fx Fy.

unfold double_round_eq.

destruct (Req_dec x 0) as [Zx|Nzx].

- 

  destruct Hexp as (_,(_,(_,Hexp4))).

  rewrite Zx; rewrite Rplus_0_l.

  rewrite (round_generic beta fexp2).

  + reflexivity.

  + now apply valid_rnd_N.

  + apply (generic_inclusion_ln_beta beta fexp1).

    now intros _; apply Hexp4; omega.

    exact Fy.

- 

  destruct (Req_dec y 0) as [Zy|Nzy].

  + 

    destruct Hexp as (_,(_,(_,Hexp4))).

    rewrite Zy; rewrite Rplus_0_r.

    rewrite (round_generic beta fexp2).

    * reflexivity.

    * now apply valid_rnd_N.

    * apply (generic_inclusion_ln_beta beta fexp1).

      now intros _; apply Hexp4; omega.

      exact Fx.

  + 

    assert (Px : 0 < x); [lra|].

    assert (Py : 0 < y); [lra|].

    destruct (Rlt_or_le x y) as [H|H].

    * 

      apply Rlt_le in H.

      rewrite Rplus_comm.

      now apply double_round_plus_beta_ge_3_aux2.

    * now apply double_round_plus_beta_ge_3_aux2.

Qed.



Lemma double_round_minus_beta_ge_3_aux0 :

  forall (fexp1 fexp2 : Z -> Z),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y < x ->

  (fexp1 (ln_beta x) <= ln_beta y)%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x - y).

Proof.

intros fexp1 fexp2 Hexp x y Py Hyx Hln Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hyx).

destruct Hexp as (Hexp1,(_,(Hexp3,Hexp4))).

assert (Lyx : (ln_beta y <= ln_beta x)%Z);

  [now apply ln_beta_le; [|apply Rlt_le]|].

destruct (Z.lt_ge_cases (ln_beta x - 2) (ln_beta y)) as [Hlt|Hge].

- 

  assert (Hor : (ln_beta y = ln_beta x :> Z)

                \/ (ln_beta y = ln_beta x - 1 :> Z)%Z); [omega|].

  destruct Hor as [Heq|Heqm1].

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

    * apply Hexp4.

      apply Zle_trans with (ln_beta (x - y)); [omega|].

      now apply ln_beta_minus.

    * rewrite Heq.

      apply Hexp4.

      apply Zle_trans with (ln_beta (x - y)); [omega|].

      now apply ln_beta_minus.

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

    * apply Hexp4.

      apply Zle_trans with (ln_beta (x - y)); [omega|].

      now apply ln_beta_minus.

    * rewrite Heqm1.

      apply Hexp4.

      apply Zplus_le_compat_r.

      now apply ln_beta_minus.

- 

  destruct (ln_beta_minus_disj x y Px Py Hge) as [Lxmy|Lxmy].

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

    * apply Hexp4.

      omega.

    * now rewrite Lxmy; apply Hexp3.

  + 

    apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy];

    rewrite Lxmy.

    * apply Hexp1.

      replace (_ + _)%Z with (ln_beta x : Z); [|ring].

      now apply Zle_trans with (ln_beta y).

    * apply Hexp1.

      now replace (_ + _)%Z with (ln_beta x : Z); [|ring].

Qed.



Lemma double_round_minus_beta_ge_3_aux1 :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y < x ->

  (ln_beta y <= fexp1 (ln_beta x) - 1)%Z ->

  (fexp1 (ln_beta (x - y)) <= ln_beta y)%Z ->

  generic_format beta fexp1 x -> generic_format beta fexp1 y ->

  generic_format beta fexp2 (x - y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2  Hexp x y Py Hyx Hln Hln' Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hyx).

destruct Hexp as (Hexp1,(Hexp2,(Hexp3,Hexp4))).

assert (Lyx : (ln_beta y <= ln_beta x)%Z);

  [now apply ln_beta_le; [|apply Rlt_le]|].

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Hfy : (fexp1 (ln_beta y) < ln_beta y)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

apply (double_round_minus_aux0_aux fexp1); [| |exact Fx|exact Fy].

- apply Zle_trans with (fexp1 (ln_beta (x - y))).

  + apply Hexp4; omega.

  + omega.

- now apply Hexp3.

Qed.



Lemma double_round_minus_beta_ge_3_aux2 :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y < x ->

  (ln_beta y <= fexp1 (ln_beta x) - 1)%Z ->

  (ln_beta y <= fexp1 (ln_beta (x - y)) - 1)%Z ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Py Hxy Hly Hly' Fx Fy.

assert (Px := Rlt_trans 0 y x Py Hxy).

destruct Hexp as (_,(_,(_,Hexp4))).

assert (Hf2 : (fexp2 (ln_beta x) <= fexp1 (ln_beta x))%Z);

  [now apply Hexp4; omega|].

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Bpow3 : bpow (- 1) <= / 3).

{ unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

  rewrite Zmult_1_r.

  apply Rinv_le; [lra|].

  now change 3 with (Z2R 3); apply Z2R_le. }

assert (Ly : y < bpow (ln_beta y)).

{ apply Rabs_lt_inv.

  apply bpow_ln_beta_gt. }

unfold double_round_eq.

apply double_round_gt_mid.

- exact Vfexp1.

- exact Vfexp2.

- lra.

- apply Hexp4; omega.

- assert (fexp1 (ln_beta (x - y)) < ln_beta (x - y))%Z; [|omega].

  apply (valid_exp_large fexp1 (ln_beta x - 1)).

  + apply (valid_exp_large fexp1 (ln_beta y)); [|omega].

    now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

  + now apply ln_beta_minus_lb; [| |omega].

- unfold midp'.

  apply (Rplus_lt_reg_r (/ 2 * ulp beta fexp1 (x - y) - (x - y))).

  ring_simplify.

  replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.

  apply Rlt_le_trans with (bpow (fexp1 (ln_beta (x - y)) - 1)).

  + apply Rle_lt_trans with y;

    [now apply double_round_minus_aux2_aux|].

    apply (Rlt_le_trans _ _ _ Ly).

    now apply bpow_le.

  + rewrite ulp_neq_0;[idtac|now apply Rgt_not_eq, Rgt_minus].

    unfold canonic_exp.

    unfold Zminus at 1; rewrite bpow_plus.

    rewrite Rmult_comm.

    apply Rmult_le_compat_r; [now apply bpow_ge_0|].

    unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

    rewrite Zmult_1_r; apply Rinv_le; [lra|].

    now change 2 with (Z2R 2); apply Z2R_le; omega.

- intro Hf2'.

  unfold midp'.

  apply (Rplus_lt_reg_r (/ 2 * (ulp beta fexp1 (x - y)

                                - ulp beta fexp2 (x - y)) - (x - y))).

  ring_simplify; rewrite <- Rmult_minus_distr_l.

  replace (_ + _) with (round beta fexp1 Zceil (x - y) - (x - y)) by ring.

  apply Rle_lt_trans with y;

    [now apply double_round_minus_aux2_aux|].

  apply (Rlt_le_trans _ _ _ Ly).

  apply Rle_trans with (bpow (fexp1 (ln_beta (x - y)) - 1));

    [now apply bpow_le|].

  rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, Rgt_minus.

  unfold canonic_exp.

  apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta (x - y)))));

    [now apply bpow_gt_0|].

  rewrite Rmult_assoc.

  rewrite Rmult_minus_distr_r.

  bpow_simplify.

  apply Rle_trans with (/ 3).

  + unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

    rewrite Zmult_1_r; apply Rinv_le; [lra|].

    now change 3 with (Z2R 3); apply Z2R_le.

  + replace (/ 3) with (/ 2 * (2 / 3)) by field.

    apply Rmult_le_compat_l; [lra|].

    apply (Rplus_le_reg_r (- 1)); ring_simplify.

    replace (_ - _) with (- / 3) by field.

    apply Ropp_le_contravar.

    apply Rle_trans with (bpow (- 1)).

    * apply bpow_le; omega.

    * unfold Fcore_Raux.bpow, Z.pow_pos; simpl.

      rewrite Zmult_1_r; apply Rinv_le; [lra|].

      now change 3 with (Z2R 3); apply Z2R_le.

Qed.



Lemma double_round_minus_beta_ge_3_aux3 :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 < y -> y <= x ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Py Hyx Fx Fy.

assert (Px := Rlt_le_trans 0 y x Py Hyx).

unfold double_round_eq.

destruct (Req_dec y x) as [Hy|Hy].

- 

  rewrite Hy; replace (x - x) with 0 by ring.

  rewrite round_0.

  + reflexivity.

  + now apply valid_rnd_N.

- 

  assert (Hyx' : y < x); [lra|].

  destruct (Zle_or_lt (ln_beta y) (fexp1 (ln_beta x) - 1)) as [Hly|Hly].

  + 

    destruct (Zle_or_lt (ln_beta y) (fexp1 (ln_beta (x - y)) - 1))

      as [Hly'|Hly'].

    * 

      now apply double_round_minus_beta_ge_3_aux2.

    * 

      { rewrite (round_generic beta fexp2).

        - reflexivity.

        - now apply valid_rnd_N.

        - assert (Hf1 : (fexp1 (ln_beta (x - y)) <= ln_beta y)%Z); [omega|].

          now apply (double_round_minus_beta_ge_3_aux1 fexp1). }

  + rewrite (round_generic beta fexp2).

    * reflexivity.

    * now apply valid_rnd_N.

    * assert (Hf1 : (fexp1 (ln_beta x) <= ln_beta y)%Z); [omega|].

      now apply (double_round_minus_beta_ge_3_aux0 fexp1).

Qed.



Lemma double_round_minus_beta_ge_3_aux :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  0 <= x -> 0 <= y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Nnx Nny Fx Fy.

unfold double_round_eq.

destruct (Req_dec x 0) as [Zx|Nzx].

- 

  rewrite Zx; unfold Rminus; rewrite Rplus_0_l.

  do 3 rewrite round_N_opp.

  rewrite (round_generic beta fexp2).

  * reflexivity.

  * now apply valid_rnd_N.

  * apply (generic_inclusion_ln_beta beta fexp1).

    destruct Hexp as (_,(_,(_,Hexp4))).

    now intros _; apply Hexp4; omega.

    exact Fy.

- 

  destruct (Req_dec y 0) as [Zy|Nzy].

  + 

    rewrite Zy; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.

    rewrite (round_generic beta fexp2).

    * reflexivity.

    * now apply valid_rnd_N.

    * apply (generic_inclusion_ln_beta beta fexp1).

      destruct Hexp as (_,(_,(_,Hexp4))).

      now intros _; apply Hexp4; omega.

      exact Fx.

  + 

    assert (Px : 0 < x); [lra|].

    assert (Py : 0 < y); [lra|].

    destruct (Rlt_or_le x y) as [H|H].

    * 

      apply Rlt_le in H.

      replace (x - y) with (- (y - x)) by ring.

      do 3 rewrite round_N_opp.

      apply Ropp_eq_compat.

      now apply double_round_minus_beta_ge_3_aux3.

    * 

      now apply double_round_minus_beta_ge_3_aux3.

Qed.



Lemma double_round_plus_beta_ge_3 :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x + y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Fx Fy.

unfold double_round_eq.

destruct (Rlt_or_le x 0) as [Sx|Sx]; destruct (Rlt_or_le y 0) as [Sy|Sy].

- 

  replace (x + y) with (- (- x - y)); [|ring].

  do 3 rewrite round_N_opp.

  apply Ropp_eq_compat.

  assert (Px : 0 <= - x); [lra|].

  assert (Py : 0 <= - y); [lra|].

  apply generic_format_opp in Fx.

  apply generic_format_opp in Fy.

  now apply double_round_plus_beta_ge_3_aux.

- 

  replace (x + y) with (y - (- x)); [|ring].

  assert (Px : 0 <= - x); [lra|].

  apply generic_format_opp in Fx.

  now apply double_round_minus_beta_ge_3_aux.

- 

  replace (x + y) with (x - (- y)); [|ring].

  assert (Py : 0 <= - y); [lra|].

  apply generic_format_opp in Fy.

  now apply double_round_minus_beta_ge_3_aux.

- 

  now apply double_round_plus_beta_ge_3_aux.

Qed.



Lemma double_round_minus_beta_ge_3 :

  (3 <= beta)%Z ->

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_plus_beta_ge_3_hyp fexp1 fexp2 ->

  forall x y,

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x - y).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Fx Fy.

unfold Rminus.

apply generic_format_opp in Fy.

now apply double_round_plus_beta_ge_3.

Qed.



Section Double_round_plus_beta_ge_3_FLX.



Import Fcore_FLX.



Variable prec : Z.

Variable prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLX_double_round_plus_beta_ge_3_hyp :

  (2 * prec <= prec')%Z ->

  double_round_plus_beta_ge_3_hyp (FLX_exp prec) (FLX_exp prec').

Proof.

intros Hprec.

unfold FLX_exp.

unfold double_round_plus_beta_ge_3_hyp; split; [|split; [|split]];

intros ex ey; try omega.

unfold Prec_gt_0 in prec_gt_0_.

omega.

Qed.



Theorem double_round_plus_beta_ge_3_FLX :

  (3 <= beta)%Z ->

  forall choice1 choice2,

  (2 * prec <= prec')%Z ->

  forall x y,

  FLX_format beta prec x -> FLX_format beta prec y ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x + y).

Proof.

intros Hbeta choice1 choice2 Hprec x y Fx Fy.

apply double_round_plus_beta_ge_3.

- exact Hbeta.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- now apply FLX_double_round_plus_beta_ge_3_hyp.

- now apply generic_format_FLX.

- now apply generic_format_FLX.

Qed.



Theorem double_round_minus_beta_ge_3_FLX :

  (3 <= beta)%Z ->

  forall choice1 choice2,

  (2 * prec <= prec')%Z ->

  forall x y,

  FLX_format beta prec x -> FLX_format beta prec y ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x - y).

Proof.

intros Hbeta choice1 choice2 Hprec x y Fx Fy.

apply double_round_minus_beta_ge_3.

- exact Hbeta.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- now apply FLX_double_round_plus_beta_ge_3_hyp.

- now apply generic_format_FLX.

- now apply generic_format_FLX.

Qed.



End Double_round_plus_beta_ge_3_FLX.



Section Double_round_plus_beta_ge_3_FLT.



Import Fcore_FLX.

Import Fcore_FLT.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLT_double_round_plus_beta_ge_3_hyp :

  (emin' <= emin)%Z -> (2 * prec <= prec')%Z ->

  double_round_plus_beta_ge_3_hyp (FLT_exp emin prec) (FLT_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FLT_exp.

unfold double_round_plus_beta_ge_3_hyp; split; [|split; [|split]]; intros ex ey.

- generalize (Zmax_spec (ex + 1 - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

- generalize (Zmax_spec (ex - 1 - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

- unfold Prec_gt_0 in prec_gt_0_.

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ey - prec) emin).

  omega.

Qed.



Theorem double_round_plus_beta_ge_3_FLT :

  (3 <= beta)%Z ->

  forall choice1 choice2,

  (emin' <= emin)%Z -> (2 * prec <= prec')%Z ->

  forall x y,

  FLT_format beta emin prec x -> FLT_format beta emin prec y ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (x + y).

Proof.

intros Hbeta choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_plus_beta_ge_3.

- exact Hbeta.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- now apply FLT_double_round_plus_beta_ge_3_hyp.

- now apply generic_format_FLT.

- now apply generic_format_FLT.

Qed.



Theorem double_round_minus_beta_ge_3_FLT :

  (3 <= beta)%Z ->

  forall choice1 choice2,

  (emin' <= emin)%Z -> (2 * prec <= prec')%Z ->

  forall x y,

  FLT_format beta emin prec x -> FLT_format beta emin prec y ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (x - y).

Proof.

intros Hbeta choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_minus_beta_ge_3.

- exact Hbeta.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- now apply FLT_double_round_plus_beta_ge_3_hyp.

- now apply generic_format_FLT.

- now apply generic_format_FLT.

Qed.



End Double_round_plus_beta_ge_3_FLT.



Section Double_round_plus_beta_ge_3_FTZ.



Import Fcore_FLX.

Import Fcore_FTZ.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FTZ_double_round_plus_beta_ge_3_hyp :

  (emin' + prec' <= emin + 1)%Z -> (2 * prec <= prec')%Z ->

  double_round_plus_beta_ge_3_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FTZ_exp.

unfold Prec_gt_0 in *.

unfold double_round_plus_beta_ge_3_hyp; split; [|split; [|split]]; intros ex ey.

- destruct (Z.ltb_spec (ex + 1 - prec) emin);

  destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - 1 - prec) emin);

  destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ey - prec) emin);

  omega.

Qed.



Theorem double_round_plus_beta_ge_3_FTZ :

  (3 <= beta)%Z ->

  forall choice1 choice2,

  (emin' + prec' <= emin + 1)%Z -> (2 * prec <= prec')%Z ->

  forall x y,

  FTZ_format beta emin prec x -> FTZ_format beta emin prec y ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (x + y).

Proof.

intros Hbeta choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_plus_beta_ge_3.

- exact Hbeta.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- now apply FTZ_double_round_plus_beta_ge_3_hyp.

- now apply generic_format_FTZ.

- now apply generic_format_FTZ.

Qed.



Theorem double_round_minus_beta_ge_3_FTZ :

  (3 <= beta)%Z ->

  forall choice1 choice2,

  (emin' + prec' <= emin + 1)%Z -> (2 * prec <= prec')%Z ->

  forall x y,

  FTZ_format beta emin prec x -> FTZ_format beta emin prec y ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (x - y).

Proof.

intros Hbeta choice1 choice2 Hemin Hprec x y Fx Fy.

apply double_round_minus_beta_ge_3.

- exact Hbeta.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- now apply FTZ_double_round_plus_beta_ge_3_hyp.

- now apply generic_format_FTZ.

- now apply generic_format_FTZ.

Qed.



End Double_round_plus_beta_ge_3_FTZ.



End Double_round_plus_beta_ge_3.



End Double_round_plus.



Lemma double_round_mid_cases :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  (fexp1 (ln_beta x) <= ln_beta x)%Z ->

  (Rabs (x - midp fexp1 x) <= / 2 * (ulp beta fexp2 x) ->

   double_round_eq fexp1 fexp2 choice1 choice2 x) ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2f1 Hf1.

unfold double_round_eq, midp.

set (rd := round beta fexp1 Zfloor x).

set (u1 := ulp beta fexp1 x).

set (u2 := ulp beta fexp2 x).

intros Cmid.

destruct (generic_format_EM beta fexp1 x) as [Fx|Nfx].

- 

  rewrite (round_generic beta fexp2); [reflexivity|now apply valid_rnd_N|].

  now apply (generic_inclusion_ln_beta beta fexp1); [omega|].

- 

  assert (Hceil : round beta fexp1 Zceil x = rd + u1);

  [now apply round_UP_DN_ulp|].

  assert (Hf2' : (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z); [omega|].

  destruct (Rlt_or_le (x - rd) (/ 2 * (u1 - u2))).

  + 

    apply double_round_lt_mid_further_place; try assumption.

    unfold midp. fold rd; fold u1; fold u2.

    apply (Rplus_lt_reg_r (- rd)); ring_simplify.

    now rewrite <- Rmult_minus_distr_l.

  + 

    { destruct (Rlt_or_le (/ 2 * (u1 + u2)) (x - rd)).

      - 

        assert (round beta fexp1 Zceil x - x

                < / 2 * (ulp beta fexp1 x - ulp beta fexp2 x)).

        { rewrite Hceil; fold u1; fold u2.

          lra. }

        apply double_round_gt_mid_further_place; try assumption.

        unfold midp'; lra.

      - 

        apply Cmid, Rabs_le; split; lra. }

Qed.



Section Double_round_sqrt.



Definition double_round_sqrt_hyp fexp1 fexp2 :=

  (forall ex, (2 * fexp1 ex <= fexp1 (2 * ex))%Z)

  /\ (forall ex, (2 * fexp1 ex <= fexp1 (2 * ex - 1))%Z)

  /\ (forall ex, (fexp1 (2 * ex) < 2 * ex)%Z ->

                 (fexp2 ex + ex <= 2 * fexp1 ex - 2)%Z).



Lemma ln_beta_sqrt_disj :

  forall x,

  0 < x ->

  (ln_beta x = 2 * ln_beta (sqrt x) - 1 :> Z)%Z

  \/ (ln_beta x = 2 * ln_beta (sqrt x) :> Z)%Z.

Proof.

intros x Px.

generalize (ln_beta_sqrt beta x Px).

intro H.

omega.

Qed.



Lemma double_round_sqrt_aux :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  double_round_sqrt_hyp fexp1 fexp2 ->

  forall x,

  0 < x ->

  (fexp2 (ln_beta (sqrt x)) <= fexp1 (ln_beta (sqrt x)) - 1)%Z ->

  generic_format beta fexp1 x ->

  / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx.

assert (Hbeta : (2 <= beta)%Z).

{ destruct beta as (beta_val,beta_prop).

  now apply Zle_bool_imp_le. }

set (a := round beta fexp1 Zfloor (sqrt x)).

set (u1 := bpow (fexp1 (ln_beta (sqrt x)))).

set (u2 := bpow (fexp2 (ln_beta (sqrt x)))).

set (b := / 2 * (u1 - u2)).

set (b' := / 2 * (u1 + u2)).

unfold midp; rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, sqrt_lt_R0.

apply Rnot_ge_lt; intro H; apply Rge_le in H.

assert (Fa : generic_format beta fexp1 a).

{ unfold a.

  apply generic_format_round.

  - exact Vfexp1.

  - now apply valid_rnd_DN. }

revert Fa; revert Fx.

unfold generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

set (mx := Ztrunc (x * bpow (- fexp1 (ln_beta x)))).

set (ma := Ztrunc (a * bpow (- fexp1 (ln_beta a)))).

intros Fx Fa.

assert (Nna : 0 <= a).

{ rewrite <- (round_0 beta fexp1 Zfloor).

  unfold a; apply round_le.

  - exact Vfexp1.

  - now apply valid_rnd_DN.

  - apply sqrt_pos. }

assert (Phu1 : 0 < / 2 * u1).

{ apply Rmult_lt_0_compat; [lra|apply bpow_gt_0]. }

assert (Phu2 : 0 < / 2 * u2).

{ apply Rmult_lt_0_compat; [lra|apply bpow_gt_0]. }

assert (Pb : 0 < b).

{ unfold b.

  rewrite <- (Rmult_0_r (/ 2)).

  apply Rmult_lt_compat_l; [lra|].

  apply Rlt_Rminus.

  unfold u2, u1.

  apply bpow_lt.

  omega. }

assert (Pb' : 0 < b').

{ now unfold b'; rewrite Rmult_plus_distr_l; apply Rplus_lt_0_compat. }

assert (Hr : sqrt x <= a + b').

{ unfold b'; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.

  replace (_ - _) with (sqrt x - (a + / 2 * u1)) by ring.

  now apply Rabs_le_inv. }

assert (Hl : a + b <= sqrt x).

{ unfold b; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.

  replace (_ + sqrt _) with (sqrt x - (a + / 2 * u1)) by ring.

  rewrite Ropp_mult_distr_l_reverse.

  now apply Rabs_le_inv in H; destruct H. }

assert (Hf1 : (2 * fexp1 (ln_beta (sqrt x)) <= fexp1 (ln_beta (x)))%Z);

  [destruct (ln_beta_sqrt_disj x Px) as [H'|H']; rewrite H'; apply Hexp|].

assert (Hlx : (fexp1 (2 * ln_beta (sqrt x)) < 2 * ln_beta (sqrt x))%Z).

{ destruct (ln_beta_sqrt_disj x Px) as [Hlx|Hlx].

  - apply (valid_exp_large fexp1 (ln_beta x)); [|omega].

    now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

  - rewrite <- Hlx.

    now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]. }

assert (Hsl : a * a + u1 * a - u2 * a + b * b <= x).

{ replace (_ + _) with ((a + b) * (a + b)); [|now unfold b; field].

  rewrite <- sqrt_def; [|now apply Rlt_le].

  assert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].

  now apply Rmult_le_compat. }

assert (Hsr : x <= a * a + u1 * a + u2 * a + b' * b').

{ replace (_ + _) with ((a + b') * (a + b')); [|now unfold b'; field].

  rewrite <- (sqrt_def x); [|now apply Rlt_le].

  assert (H' : 0 <= sqrt x); [now apply sqrt_pos|].

  now apply Rmult_le_compat. }

destruct (Req_dec a 0) as [Za|Nza].

- 

  apply (Rlt_irrefl 0).

  apply Rlt_le_trans with (b * b); [now apply Rmult_lt_0_compat|].

  apply Rle_trans with x.

  + revert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.

    now rewrite Ropp_0; do 3 rewrite Rplus_0_l.

  + rewrite Fx.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite Rmult_0_l; bpow_simplify.

    unfold mx.

    rewrite Ztrunc_floor;

      [|now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]].

    apply Req_le.

    change 0 with (Z2R 0); apply f_equal.

    apply Zfloor_imp.

    split; [now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]|simpl].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite Rmult_1_l; bpow_simplify.

    apply Rlt_le_trans with (bpow (2 * fexp1 (ln_beta (sqrt x))));

      [|now apply bpow_le].

    change 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.

    rewrite bpow_plus.

    rewrite <- (sqrt_def x) at 1; [|now apply Rlt_le].

    assert (sqrt x < bpow (fexp1 (ln_beta (sqrt x))));

      [|now apply Rmult_lt_compat; [apply sqrt_pos|apply sqrt_pos| |]].

    apply (Rle_lt_trans _ _ _ Hr); rewrite Za; rewrite Rplus_0_l.

    unfold b'; change (bpow _) with u1.

    apply Rlt_le_trans with (/ 2 * (u1 + u1)); [|lra].

    apply Rmult_lt_compat_l; [lra|]; apply Rplus_lt_compat_l.

    unfold u2, u1, ulp, canonic_exp; apply bpow_lt; omega.

- 

  assert (Pa : 0 < a); [lra|].

  assert (Hla : (ln_beta a = ln_beta (sqrt x) :> Z)).

  { unfold a; apply ln_beta_DN.

    - exact Vfexp1.

    - now fold a. }

  assert (Hl' : 0 < - (u2 * a) + b * b).

  { apply (Rplus_lt_reg_r (u2 * a)); ring_simplify.

    unfold b; ring_simplify.

    apply (Rplus_lt_reg_r (/ 2 * u2 * u1)); field_simplify.

    replace (_ / 2) with (u2 * (a + / 2 * u1)) by field.

    replace (_ / 8) with (/ 4 * (u2 ^ 2 + u1 ^ 2)) by field.

    apply Rlt_le_trans with (u2 * bpow (ln_beta (sqrt x))).

    - apply Rmult_lt_compat_l; [now unfold u2, ulp; apply bpow_gt_0|].

      unfold u1; rewrite <- Hla.

      apply Rlt_le_trans with (a + bpow (fexp1 (ln_beta a))).

      + apply Rplus_lt_compat_l.

        rewrite <- (Rmult_1_l (bpow _)) at 2.

        apply Rmult_lt_compat_r; [apply bpow_gt_0|lra].

      + apply Rle_trans with (a+ ulp beta fexp1 a).

        right; now rewrite ulp_neq_0.

        apply (id_p_ulp_le_bpow _ _ _ _ Pa Fa).

        apply Rabs_lt_inv, bpow_ln_beta_gt.

    - apply Rle_trans with (bpow (- 2) * u1 ^ 2).

      + unfold pow; rewrite Rmult_1_r.

        unfold u1, u2, ulp, canonic_exp; bpow_simplify; apply bpow_le.

        now apply Hexp.

      + apply Rmult_le_compat.

        * apply bpow_ge_0.

        * apply pow2_ge_0.

        * unfold Fcore_Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.

          apply Rinv_le; [lra|].

          change 4 with (Z2R (2 * 2)%Z); apply Z2R_le, Zmult_le_compat; omega.

        * rewrite <- (Rplus_0_l (u1 ^ 2)) at 1; apply Rplus_le_compat_r.

          apply pow2_ge_0. }

  assert (Hr' : x <= a * a + u1 * a).

  { rewrite Hla in Fa.

    rewrite <- Rmult_plus_distr_r.

    unfold u1, ulp, canonic_exp.

    rewrite <- (Rmult_1_l (bpow _)); rewrite Fa; rewrite <- Rmult_plus_distr_r.

    rewrite <- Rmult_assoc; rewrite (Rmult_comm _ (Z2R ma)).

    rewrite <- (Rmult_assoc (Z2R ma)); bpow_simplify.

    apply (Rmult_le_reg_r (bpow (- 2 * fexp1 (ln_beta (sqrt x)))));

      [now apply bpow_gt_0|bpow_simplify].

    rewrite Fx at 1; bpow_simplify.

    rewrite <- Z2R_Zpower; [|omega].

    change 1 with (Z2R 1); rewrite <- Z2R_plus; do 2 rewrite <- Z2R_mult.

    apply Z2R_le, Zlt_succ_le, lt_Z2R.

    unfold Z.succ; rewrite Z2R_plus; do 2 rewrite Z2R_mult; rewrite Z2R_plus.

    rewrite Z2R_Zpower; [|omega].

    apply (Rmult_lt_reg_r (bpow (2 * fexp1 (ln_beta (sqrt x)))));

      [now apply bpow_gt_0|bpow_simplify].

    rewrite <- Fx.

    change 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.

    rewrite bpow_plus; simpl.

    replace (_ * _) with (a * a + u1 * a + u1 * u1);

      [|unfold u1, ulp, canonic_exp; rewrite Fa; ring].

    apply (Rle_lt_trans _ _ _ Hsr).

    rewrite Rplus_assoc; apply Rplus_lt_compat_l.

    apply (Rplus_lt_reg_r (- b' * b' + / 2 * u1 * u2)); ring_simplify.

    replace (_ + _) with ((a + / 2 * u1) * u2) by ring.

    apply Rlt_le_trans with (bpow (ln_beta (sqrt x)) * u2).

    - apply Rmult_lt_compat_r; [now unfold u2, ulp; apply bpow_gt_0|].

      apply Rlt_le_trans with (a + u1); [lra|].

      unfold u1; fold (canonic_exp beta fexp1 (sqrt x)).

      rewrite <- canonic_exp_DN; [|exact Vfexp1|exact Pa]; fold a.

      rewrite <- ulp_neq_0; trivial.

      apply id_p_ulp_le_bpow.

      + exact Pa.

      + now apply round_DN_pt.

      + apply Rle_lt_trans with (sqrt x).

        * now apply round_DN_pt.

        * apply Rabs_lt_inv.

          apply bpow_ln_beta_gt.

    - apply Rle_trans with (/ 2 * u1 ^ 2).

      + apply Rle_trans with (bpow (- 2) * u1 ^ 2).

        * unfold pow; rewrite Rmult_1_r.

          unfold u2, u1, ulp, canonic_exp.

          bpow_simplify.

          apply bpow_le.

          rewrite Zplus_comm.

          now apply Hexp.

        * apply Rmult_le_compat_r; [now apply pow2_ge_0|].

          unfold Fcore_Raux.bpow; simpl; unfold Z.pow_pos; simpl.

          rewrite Zmult_1_r.

          apply Rinv_le; [lra|].

          change 2 with (Z2R 2); apply Z2R_le.

          rewrite <- (Zmult_1_l 2).

          apply Zmult_le_compat; omega.

      + assert (u2 ^ 2 < u1 ^ 2); [|unfold b'; lra].

        unfold pow; do 2 rewrite Rmult_1_r.

        assert (H' : 0 <= u2); [unfold u2, ulp; apply bpow_ge_0|].

        assert (u2 < u1); [|now apply Rmult_lt_compat].

        unfold u1, u2, ulp, canonic_exp; apply bpow_lt; omega. }

  apply (Rlt_irrefl (a * a + u1 * a)).

  apply Rlt_le_trans with (a * a + u1 * a - u2 * a + b * b).

  + rewrite <- (Rplus_0_r (a * a + _)) at 1.

    unfold Rminus; rewrite (Rplus_assoc _ _ (b * b)).

    now apply Rplus_lt_compat_l.

  + now apply Rle_trans with x.

Qed.



Lemma double_round_sqrt :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_sqrt_hyp fexp1 fexp2 ->

  forall x,

  generic_format beta fexp1 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 (sqrt x).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x Fx.

unfold double_round_eq.

destruct (Rle_or_lt x 0) as [Npx|Px].

- 

  rewrite (sqrt_neg _ Npx).

  now rewrite round_0; [|apply valid_rnd_N].

- 

  assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; try assumption; lra|].

  assert (Hfsx : (fexp1 (ln_beta (sqrt x)) < ln_beta (sqrt x))%Z).

  { destruct (Rle_or_lt x 1) as [Hx|Hx].

    - 

      apply (valid_exp_large fexp1 (ln_beta x)); [exact Hfx|].

      apply ln_beta_le; [exact Px|].

      rewrite <- (sqrt_def x) at 1; [|lra].

      rewrite <- Rmult_1_r.

      apply Rmult_le_compat_l.

      + apply sqrt_pos.

      + rewrite <- sqrt_1.

        now apply sqrt_le_1_alt.

    - 

      generalize ((proj1 (proj2 Hexp)) 1%Z).

      replace (_ - 1)%Z with 1%Z by ring.

      intro Hexp10.

      assert (Hf0 : (fexp1 1 < 1)%Z); [omega|clear Hexp10].

      apply (valid_exp_large fexp1 1); [exact Hf0|].

      apply ln_beta_ge_bpow.

      rewrite Zeq_minus; [|reflexivity].

      unfold Fcore_Raux.bpow; simpl.

      apply Rabs_ge; right.

      rewrite <- sqrt_1.

      apply sqrt_le_1_alt.

      now apply Rlt_le. }

  assert (Hf2 : (fexp2 (ln_beta (sqrt x)) <= fexp1 (ln_beta (sqrt x)) - 1)%Z).

  { assert (H : (fexp1 (2 * ln_beta (sqrt x)) < 2 * ln_beta (sqrt x))%Z).

    { destruct (ln_beta_sqrt_disj x Px) as [Hlx|Hlx].

      - apply (valid_exp_large fexp1 (ln_beta x)); [|omega].

        now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

      - rewrite <- Hlx.

        now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]. }

    generalize ((proj2 (proj2 Hexp)) (ln_beta (sqrt x)) H).

    omega. }

  apply double_round_mid_cases.

  + exact Vfexp1.

  + exact Vfexp2.

  + now apply sqrt_lt_R0.

  + omega.

  + omega.

  + intros Hmid; casetype False; apply (Rle_not_lt _ _ Hmid).

    apply (double_round_sqrt_aux fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx).

Qed.



Section Double_round_sqrt_FLX.



Import Fcore_FLX.



Variable prec : Z.

Variable prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLX_double_round_sqrt_hyp :

  (2 * prec + 2 <= prec')%Z ->

  double_round_sqrt_hyp (FLX_exp prec) (FLX_exp prec').

Proof.

intros Hprec.

unfold FLX_exp.

unfold Prec_gt_0 in prec_gt_0_.

unfold double_round_sqrt_hyp; split; [|split]; intro ex; omega.

Qed.



Theorem double_round_sqrt_FLX :

  forall choice1 choice2,

  (2 * prec + 2 <= prec')%Z ->

  forall x,

  FLX_format beta prec x ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (sqrt x).

Proof.

intros choice1 choice2 Hprec x Fx.

apply double_round_sqrt.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- now apply FLX_double_round_sqrt_hyp.

- now apply generic_format_FLX.

Qed.



End Double_round_sqrt_FLX.



Section Double_round_sqrt_FLT.



Import Fcore_FLX.

Import Fcore_FLT.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLT_double_round_sqrt_hyp :

  (emin <= 0)%Z ->

  ((emin' <= emin - prec - 2)%Z

   \/ (2 * emin' <= emin - 4 * prec - 2)%Z) ->

  (2 * prec + 2 <= prec')%Z ->

  double_round_sqrt_hyp (FLT_exp emin prec) (FLT_exp emin' prec').

Proof.

intros Hemin Heminprec Hprec.

unfold FLT_exp.

unfold Prec_gt_0 in prec_gt_0_.

unfold double_round_sqrt_hyp; split; [|split]; intros ex.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (2 * ex - prec) emin).

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (2 * ex - 1 - prec) emin).

  omega.

- generalize (Zmax_spec (2 * ex - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ex - prec) emin).

  omega.

Qed.



Theorem double_round_sqrt_FLT :

  forall choice1 choice2,

  (emin <= 0)%Z ->

  ((emin' <= emin - prec - 2)%Z

   \/ (2 * emin' <= emin - 4 * prec - 2)%Z) ->

  (2 * prec + 2 <= prec')%Z ->

  forall x,

  FLT_format beta emin prec x ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (sqrt x).

Proof.

intros choice1 choice2 Hemin Heminprec Hprec x Fx.

apply double_round_sqrt.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- now apply FLT_double_round_sqrt_hyp.

- now apply generic_format_FLT.

Qed.



End Double_round_sqrt_FLT.



Section Double_round_sqrt_FTZ.



Import Fcore_FLX.

Import Fcore_FTZ.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FTZ_double_round_sqrt_hyp :

  (2 * (emin' + prec') <= emin + prec <= 1)%Z ->

  (2 * prec + 2 <= prec')%Z ->

  double_round_sqrt_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FTZ_exp.

unfold Prec_gt_0 in *.

unfold double_round_sqrt_hyp; split; [|split]; intros ex.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (2 * ex - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (2 * ex - 1 - prec) emin);

  omega.

- intro H.

  destruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].

  + destruct (Z.ltb_spec (ex - prec') emin');

    destruct (Z.ltb_spec (ex - prec) emin);

    omega.

  + casetype False.

    rewrite (Zlt_bool_true _ _ H') in H.

    omega.

Qed.



Theorem double_round_sqrt_FTZ :

  (4 <= beta)%Z ->

  forall choice1 choice2,

  (2 * (emin' + prec') <= emin + prec <= 1)%Z ->

  (2 * prec + 2 <= prec')%Z ->

  forall x,

  FTZ_format beta emin prec x ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (sqrt x).

Proof.

intros Hbeta choice1 choice2 Hemin Hprec x Fx.

apply double_round_sqrt.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- now apply FTZ_double_round_sqrt_hyp.

- now apply generic_format_FTZ.

Qed.



End Double_round_sqrt_FTZ.



Section Double_round_sqrt_beta_ge_4.



Definition double_round_sqrt_beta_ge_4_hyp fexp1 fexp2 :=

  (forall ex, (2 * fexp1 ex <= fexp1 (2 * ex))%Z)

  /\ (forall ex, (2 * fexp1 ex <= fexp1 (2 * ex - 1))%Z)

  /\ (forall ex, (fexp1 (2 * ex) < 2 * ex)%Z ->

                 (fexp2 ex + ex <= 2 * fexp1 ex - 1)%Z).



Lemma double_round_sqrt_beta_ge_4_aux :

  (4 <= beta)%Z ->

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  double_round_sqrt_beta_ge_4_hyp fexp1 fexp2 ->

  forall x,

  0 < x ->

  (fexp2 (ln_beta (sqrt x)) <= fexp1 (ln_beta (sqrt x)) - 1)%Z ->

  generic_format beta fexp1 x ->

  / 2 * ulp beta fexp2 (sqrt x) < Rabs (sqrt x - midp fexp1 (sqrt x)).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 Hexp x Px Hf2 Fx.

set (a := round beta fexp1 Zfloor (sqrt x)).

set (u1 := bpow (fexp1 (ln_beta (sqrt x)))).

set (u2 := bpow (fexp2 (ln_beta (sqrt x)))).

set (b := / 2 * (u1 - u2)).

set (b' := / 2 * (u1 + u2)).

unfold midp; rewrite 2!ulp_neq_0; try now apply Rgt_not_eq, sqrt_lt_R0.

apply Rnot_ge_lt; intro H; apply Rge_le in H.

assert (Fa : generic_format beta fexp1 a).

{ unfold a.

  apply generic_format_round.

  - exact Vfexp1.

  - now apply valid_rnd_DN. }

revert Fa; revert Fx.

unfold generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

set (mx := Ztrunc (x * bpow (- fexp1 (ln_beta x)))).

set (ma := Ztrunc (a * bpow (- fexp1 (ln_beta a)))).

intros Fx Fa.

assert (Nna : 0 <= a).

{ rewrite <- (round_0 beta fexp1 Zfloor).

  unfold a; apply round_le.

  - exact Vfexp1.

  - now apply valid_rnd_DN.

  - apply sqrt_pos. }

assert (Phu1 : 0 < / 2 * u1).

{ apply Rmult_lt_0_compat; [lra|apply bpow_gt_0]. }

assert (Phu2 : 0 < / 2 * u2).

{ apply Rmult_lt_0_compat; [lra|apply bpow_gt_0]. }

assert (Pb : 0 < b).

{ unfold b.

  rewrite <- (Rmult_0_r (/ 2)).

  apply Rmult_lt_compat_l; [lra|].

  apply Rlt_Rminus.

  unfold u2, u1, ulp, canonic_exp.

  apply bpow_lt.

  omega. }

assert (Pb' : 0 < b').

{ now unfold b'; rewrite Rmult_plus_distr_l; apply Rplus_lt_0_compat. }

assert (Hr : sqrt x <= a + b').

{ unfold b'; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.

  replace (_ - _) with (sqrt x - (a + / 2 * u1)) by ring.

  now apply Rabs_le_inv. }

assert (Hl : a + b <= sqrt x).

{ unfold b; apply (Rplus_le_reg_r (- / 2 * u1 - a)); ring_simplify.

  replace (_ + sqrt _) with (sqrt x - (a + / 2 * u1)) by ring.

  rewrite Ropp_mult_distr_l_reverse.

  now apply Rabs_le_inv in H; destruct H. }

assert (Hf1 : (2 * fexp1 (ln_beta (sqrt x)) <= fexp1 (ln_beta (x)))%Z);

  [destruct (ln_beta_sqrt_disj x Px) as [H'|H']; rewrite H'; apply Hexp|].

assert (Hlx : (fexp1 (2 * ln_beta (sqrt x)) < 2 * ln_beta (sqrt x))%Z).

{ destruct (ln_beta_sqrt_disj x Px) as [Hlx|Hlx].

  - apply (valid_exp_large fexp1 (ln_beta x)); [|omega].

    now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

  - rewrite <- Hlx.

    now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]. }

assert (Hsl : a * a + u1 * a - u2 * a + b * b <= x).

{ replace (_ + _) with ((a + b) * (a + b)); [|now unfold b; field].

  rewrite <- sqrt_def; [|now apply Rlt_le].

  assert (H' : 0 <= a + b); [now apply Rlt_le, Rplus_le_lt_0_compat|].

  now apply Rmult_le_compat. }

assert (Hsr : x <= a * a + u1 * a + u2 * a + b' * b').

{ replace (_ + _) with ((a + b') * (a + b')); [|now unfold b'; field].

  rewrite <- (sqrt_def x); [|now apply Rlt_le].

  assert (H' : 0 <= sqrt x); [now apply sqrt_pos|].

  now apply Rmult_le_compat. }

destruct (Req_dec a 0) as [Za|Nza].

- 

  apply (Rlt_irrefl 0).

  apply Rlt_le_trans with (b * b); [now apply Rmult_lt_0_compat|].

  apply Rle_trans with x.

  + revert Hsl; unfold Rminus; rewrite Za; do 3 rewrite Rmult_0_r.

    now rewrite Ropp_0; do 3 rewrite Rplus_0_l.

  + rewrite Fx.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite Rmult_0_l; bpow_simplify.

    unfold mx.

    rewrite Ztrunc_floor;

      [|now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]].

    apply Req_le.

    change 0 with (Z2R 0); apply f_equal.

    apply Zfloor_imp.

    split; [now apply Rmult_le_pos; [apply Rlt_le|apply bpow_ge_0]|simpl].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x)))); [now apply bpow_gt_0|].

    rewrite Rmult_1_l; bpow_simplify.

    apply Rlt_le_trans with (bpow (2 * fexp1 (ln_beta (sqrt x))));

      [|now apply bpow_le].

    change 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.

    rewrite bpow_plus.

    rewrite <- (sqrt_def x) at 1; [|now apply Rlt_le].

    assert (sqrt x < bpow (fexp1 (ln_beta (sqrt x))));

      [|now apply Rmult_lt_compat; [apply sqrt_pos|apply sqrt_pos| |]].

    apply (Rle_lt_trans _ _ _ Hr); rewrite Za; rewrite Rplus_0_l.

    unfold b'; change (bpow _) with u1.

    apply Rlt_le_trans with (/ 2 * (u1 + u1)); [|lra].

    apply Rmult_lt_compat_l; [lra|]; apply Rplus_lt_compat_l.

    unfold u2, u1, ulp, canonic_exp; apply bpow_lt; omega.

- 

  assert (Pa : 0 < a); [lra|].

  assert (Hla : (ln_beta a = ln_beta (sqrt x) :> Z)).

  { unfold a; apply ln_beta_DN.

    - exact Vfexp1.

    - now fold a. }

  assert (Hl' : 0 < - (u2 * a) + b * b).

  { apply (Rplus_lt_reg_r (u2 * a)); ring_simplify.

    unfold b; ring_simplify.

    apply (Rplus_lt_reg_r (/ 2 * u2 * u1)); field_simplify.

    replace (_ / 2) with (u2 * (a + / 2 * u1)) by field.

    replace (_ / 8) with (/ 4 * (u2 ^ 2 + u1 ^ 2)) by field.

    apply Rlt_le_trans with (u2 * bpow (ln_beta (sqrt x))).

    - apply Rmult_lt_compat_l; [now unfold u2, ulp; apply bpow_gt_0|].

      unfold u1; rewrite <- Hla.

      apply Rlt_le_trans with (a + ulp beta fexp1 a).

      + apply Rplus_lt_compat_l.

        rewrite <- (Rmult_1_l (ulp _ _ _)).

        rewrite ulp_neq_0; trivial.

        apply Rmult_lt_compat_r; [apply bpow_gt_0|lra].

      + apply (id_p_ulp_le_bpow _ _ _ _ Pa Fa).

        apply Rabs_lt_inv, bpow_ln_beta_gt.

    - apply Rle_trans with (bpow (- 1) * u1 ^ 2).

      + unfold pow; rewrite Rmult_1_r.

        unfold u1, u2, ulp, canonic_exp; bpow_simplify; apply bpow_le.

        now apply Hexp.

      + apply Rmult_le_compat.

        * apply bpow_ge_0.

        * apply pow2_ge_0.

        * unfold Fcore_Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.

          apply Rinv_le; [lra|].

          now change 4 with (Z2R 4); apply Z2R_le.

        * rewrite <- (Rplus_0_l (u1 ^ 2)) at 1; apply Rplus_le_compat_r.

          apply pow2_ge_0. }

  assert (Hr' : x <= a * a + u1 * a).

  { rewrite Hla in Fa.

    rewrite <- Rmult_plus_distr_r.

    unfold u1, ulp, canonic_exp.

    rewrite <- (Rmult_1_l (bpow _)); rewrite Fa; rewrite <- Rmult_plus_distr_r.

    rewrite <- Rmult_assoc; rewrite (Rmult_comm _ (Z2R ma)).

    rewrite <- (Rmult_assoc (Z2R ma)); bpow_simplify.

    apply (Rmult_le_reg_r (bpow (- 2 * fexp1 (ln_beta (sqrt x)))));

      [now apply bpow_gt_0|bpow_simplify].

    rewrite Fx at 1; bpow_simplify.

    rewrite <- Z2R_Zpower; [|omega].

    change 1 with (Z2R 1); rewrite <- Z2R_plus; do 2 rewrite <- Z2R_mult.

    apply Z2R_le, Zlt_succ_le, lt_Z2R.

    unfold Z.succ; rewrite Z2R_plus; do 2 rewrite Z2R_mult; rewrite Z2R_plus.

    rewrite Z2R_Zpower; [|omega].

    apply (Rmult_lt_reg_r (bpow (2 * fexp1 (ln_beta (sqrt x)))));

      [now apply bpow_gt_0|bpow_simplify].

    rewrite <- Fx.

    change 2%Z with (1 + 1)%Z; rewrite Zmult_plus_distr_l; rewrite Zmult_1_l.

    rewrite bpow_plus; simpl.

    replace (_ * _) with (a * a + u1 * a + u1 * u1);

      [|unfold u1, ulp, canonic_exp; rewrite Fa; ring].

    apply (Rle_lt_trans _ _ _ Hsr).

    rewrite Rplus_assoc; apply Rplus_lt_compat_l.

    apply (Rplus_lt_reg_r (- b' * b' + / 2 * u1 * u2)); ring_simplify.

    replace (_ + _) with ((a + / 2 * u1) * u2) by ring.

    apply Rlt_le_trans with (bpow (ln_beta (sqrt x)) * u2).

    - apply Rmult_lt_compat_r; [now unfold u2, ulp; apply bpow_gt_0|].

      apply Rlt_le_trans with (a + u1); [lra|].

      unfold u1; fold (canonic_exp beta fexp1 (sqrt x)).

      rewrite <- canonic_exp_DN; [|exact Vfexp1|exact Pa]; fold a.

      rewrite <- ulp_neq_0; trivial.

      apply id_p_ulp_le_bpow.

      + exact Pa.

      + now apply round_DN_pt.

      + apply Rle_lt_trans with (sqrt x).

        * now apply round_DN_pt.

        * apply Rabs_lt_inv.

          apply bpow_ln_beta_gt.

    - apply Rle_trans with (/ 2 * u1 ^ 2).

      + apply Rle_trans with (bpow (- 1) * u1 ^ 2).

        * unfold pow; rewrite Rmult_1_r.

          unfold u2, u1, ulp, canonic_exp.

          bpow_simplify.

          apply bpow_le.

          rewrite Zplus_comm.

          now apply Hexp.

        * apply Rmult_le_compat_r; [now apply pow2_ge_0|].

          unfold Fcore_Raux.bpow; simpl; unfold Z.pow_pos; simpl.

          rewrite Zmult_1_r.

          apply Rinv_le; [lra|].

          change 2 with (Z2R 2); apply Z2R_le; omega.

      + assert (u2 ^ 2 < u1 ^ 2); [|unfold b'; lra].

        unfold pow; do 2 rewrite Rmult_1_r.

        assert (H' : 0 <= u2); [unfold u2, ulp; apply bpow_ge_0|].

        assert (u2 < u1); [|now apply Rmult_lt_compat].

        unfold u1, u2, ulp, canonic_exp; apply bpow_lt; omega. }

  apply (Rlt_irrefl (a * a + u1 * a)).

  apply Rlt_le_trans with (a * a + u1 * a - u2 * a + b * b).

  + rewrite <- (Rplus_0_r (a * a + _)) at 1.

    unfold Rminus; rewrite (Rplus_assoc _ _ (b * b)).

    now apply Rplus_lt_compat_l.

  + now apply Rle_trans with x.

Qed.



Lemma double_round_sqrt_beta_ge_4 :

  (4 <= beta)%Z ->

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_sqrt_beta_ge_4_hyp fexp1 fexp2 ->

  forall x,

  generic_format beta fexp1 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 (sqrt x).

Proof.

intros Hbeta fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x Fx.

unfold double_round_eq.

destruct (Rle_or_lt x 0) as [Npx|Px].

- 

  assert (Hs : sqrt x = 0).

  { destruct (Req_dec x 0) as [Zx|Nzx].

    - 

      rewrite Zx.

      exact sqrt_0.

    - 

      unfold sqrt.

      destruct Rcase_abs.

      + reflexivity.

      + casetype False; lra. }

  rewrite Hs.

  rewrite round_0.

  + reflexivity.

  + now apply valid_rnd_N.

- 

  assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

    [now apply ln_beta_generic_gt; try assumption; lra|].

  assert (Hfsx : (fexp1 (ln_beta (sqrt x)) < ln_beta (sqrt x))%Z).

  { destruct (Rle_or_lt x 1) as [Hx|Hx].

    - 

      apply (valid_exp_large fexp1 (ln_beta x)); [exact Hfx|].

      apply ln_beta_le; [exact Px|].

      rewrite <- (sqrt_def x) at 1; [|lra].

      rewrite <- Rmult_1_r.

      apply Rmult_le_compat_l.

      + apply sqrt_pos.

      + rewrite <- sqrt_1.

        now apply sqrt_le_1_alt.

    - 

      generalize ((proj1 (proj2 Hexp)) 1%Z).

      replace (_ - 1)%Z with 1%Z by ring.

      intro Hexp10.

      assert (Hf0 : (fexp1 1 < 1)%Z); [omega|clear Hexp10].

      apply (valid_exp_large fexp1 1); [exact Hf0|].

      apply ln_beta_ge_bpow.

      rewrite Zeq_minus; [|reflexivity].

      unfold Fcore_Raux.bpow; simpl.

      apply Rabs_ge; right.

      rewrite <- sqrt_1.

      apply sqrt_le_1_alt.

      now apply Rlt_le. }

  assert (Hf2 : (fexp2 (ln_beta (sqrt x)) <= fexp1 (ln_beta (sqrt x)) - 1)%Z).

  { assert (H : (fexp1 (2 * ln_beta (sqrt x)) < 2 * ln_beta (sqrt x))%Z).

    { destruct (ln_beta_sqrt_disj x Px) as [Hlx|Hlx].

      - apply (valid_exp_large fexp1 (ln_beta x)); [|omega].

        now apply ln_beta_generic_gt; [|apply Rgt_not_eq|].

      - rewrite <- Hlx.

        now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]. }

    generalize ((proj2 (proj2 Hexp)) (ln_beta (sqrt x)) H).

    omega. }

  apply double_round_mid_cases.

  + exact Vfexp1.

  + exact Vfexp2.

  + now apply sqrt_lt_R0.

  + omega.

  + omega.

  + intros Hmid; casetype False; apply (Rle_not_lt _ _ Hmid).

    apply (double_round_sqrt_beta_ge_4_aux Hbeta fexp1 fexp2 Vfexp1 Vfexp2

                                           Hexp x Px Hf2 Fx).

Qed.



Section Double_round_sqrt_beta_ge_4_FLX.



Import Fcore_FLX.



Variable prec : Z.

Variable prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLX_double_round_sqrt_beta_ge_4_hyp :

  (2 * prec + 1 <= prec')%Z ->

  double_round_sqrt_beta_ge_4_hyp (FLX_exp prec) (FLX_exp prec').

Proof.

intros Hprec.

unfold FLX_exp.

unfold Prec_gt_0 in prec_gt_0_.

unfold double_round_sqrt_beta_ge_4_hyp; split; [|split]; intro ex; omega.

Qed.



Theorem double_round_sqrt_beta_ge_4_FLX :

  (4 <= beta)%Z ->

  forall choice1 choice2,

  (2 * prec + 1 <= prec')%Z ->

  forall x,

  FLX_format beta prec x ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (sqrt x).

Proof.

intros Hbeta choice1 choice2 Hprec x Fx.

apply double_round_sqrt_beta_ge_4.

- exact Hbeta.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- now apply FLX_double_round_sqrt_beta_ge_4_hyp.

- now apply generic_format_FLX.

Qed.



End Double_round_sqrt_beta_ge_4_FLX.



Section Double_round_sqrt_beta_ge_4_FLT.



Import Fcore_FLX.

Import Fcore_FLT.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLT_double_round_sqrt_beta_ge_4_hyp :

  (emin <= 0)%Z ->

  ((emin' <= emin - prec - 1)%Z

   \/ (2 * emin' <= emin - 4 * prec)%Z) ->

  (2 * prec + 1 <= prec')%Z ->

  double_round_sqrt_beta_ge_4_hyp (FLT_exp emin prec) (FLT_exp emin' prec').

Proof.

intros Hemin Heminprec Hprec.

unfold FLT_exp.

unfold Prec_gt_0 in prec_gt_0_.

unfold double_round_sqrt_beta_ge_4_hyp; split; [|split]; intros ex.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (2 * ex - prec) emin).

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (2 * ex - 1 - prec) emin).

  omega.

- generalize (Zmax_spec (2 * ex - prec) emin).

  generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ex - prec) emin).

  omega.

Qed.



Theorem double_round_sqrt_beta_ge_4_FLT :

  (4 <= beta)%Z ->

  forall choice1 choice2,

  (emin <= 0)%Z ->

  ((emin' <= emin - prec - 1)%Z

   \/ (2 * emin' <= emin - 4 * prec)%Z) ->

  (2 * prec + 1 <= prec')%Z ->

  forall x,

  FLT_format beta emin prec x ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (sqrt x).

Proof.

intros Hbeta choice1 choice2 Hemin Heminprec Hprec x Fx.

apply double_round_sqrt_beta_ge_4.

- exact Hbeta.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- now apply FLT_double_round_sqrt_beta_ge_4_hyp.

- now apply generic_format_FLT.

Qed.



End Double_round_sqrt_beta_ge_4_FLT.



Section Double_round_sqrt_beta_ge_4_FTZ.



Import Fcore_FLX.

Import Fcore_FTZ.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FTZ_double_round_sqrt_beta_ge_4_hyp :

  (2 * (emin' + prec') <= emin + prec <= 1)%Z ->

  (2 * prec + 1 <= prec')%Z ->

  double_round_sqrt_beta_ge_4_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FTZ_exp.

unfold Prec_gt_0 in *.

unfold double_round_sqrt_beta_ge_4_hyp; split; [|split]; intros ex.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (2 * ex - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (2 * ex - 1 - prec) emin);

  omega.

- intro H.

  destruct (Zle_or_lt emin (2 * ex - prec)) as [H'|H'].

  + destruct (Z.ltb_spec (ex - prec') emin');

    destruct (Z.ltb_spec (ex - prec) emin);

    omega.

  + casetype False.

    rewrite (Zlt_bool_true _ _ H') in H.

    omega.

Qed.



Theorem double_round_sqrt_beta_ge_4_FTZ :

  (4 <= beta)%Z ->

  forall choice1 choice2,

  (2 * (emin' + prec') <= emin + prec <= 1)%Z ->

  (2 * prec + 1 <= prec')%Z ->

  forall x,

  FTZ_format beta emin prec x ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (sqrt x).

Proof.

intros Hbeta choice1 choice2 Hemin Hprec x Fx.

apply double_round_sqrt_beta_ge_4.

- exact Hbeta.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- now apply FTZ_double_round_sqrt_beta_ge_4_hyp.

- now apply generic_format_FTZ.

Qed.



End Double_round_sqrt_beta_ge_4_FTZ.



End Double_round_sqrt_beta_ge_4.



End Double_round_sqrt.



Section Double_round_div.



Lemma double_round_eq_mid_beta_even :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  (exists n, (beta = 2 * n :> Z)%Z) ->

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  (fexp1 (ln_beta x) <= ln_beta x)%Z ->

  x = midp fexp1 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Ebeta x Px Hf2 Hf1.

unfold double_round_eq.

unfold midp.

set (rd := round beta fexp1 Zfloor x).

set (u := ulp beta fexp1 x).

intro H; apply (Rplus_eq_compat_l (- rd)) in H.

ring_simplify in H; revert H.

rewrite Rplus_comm; fold (Rminus x rd).

intro Xmid.

destruct Ebeta as (n,Ebeta).

assert (Hbeta : (2 <= beta)%Z).

{ destruct beta as (beta_val,beta_prop).

  now apply Zle_bool_imp_le. }

apply (Rplus_eq_compat_l rd) in Xmid; ring_simplify in Xmid.

rewrite (round_generic beta fexp2); [reflexivity|now apply valid_rnd_N|].

set (f := Float beta (Zfloor (scaled_mantissa beta fexp2 rd)

                      + n * beta ^ (fexp1 (ln_beta x) - 1

                                    - fexp2 (ln_beta x)))

                (canonic_exp beta fexp2 x)).

assert (Hf : F2R f = x).

{ unfold f, F2R; simpl.

  rewrite Z2R_plus.

  rewrite Rmult_plus_distr_r.

  rewrite Z2R_mult.

  rewrite Z2R_Zpower; [|omega].

  unfold canonic_exp at 2; bpow_simplify.

  unfold Zminus; rewrite bpow_plus.

  rewrite (Rmult_comm _ (bpow (- 1))).

  rewrite <- (Rmult_assoc (Z2R n)).

  change (bpow (- 1)) with (/ Z2R (beta * 1)).

  rewrite Zmult_1_r.

  rewrite Ebeta.

  rewrite (Z2R_mult 2).

  rewrite Rinv_mult_distr;

    [|simpl; lra|change 0 with (Z2R 0); apply Z2R_neq; omega].

  rewrite <- Rmult_assoc; rewrite (Rmult_comm (Z2R n));

  rewrite (Rmult_assoc _ (Z2R n)).

  rewrite Rinv_r;

    [rewrite Rmult_1_r|change 0 with (Z2R 0); apply Z2R_neq; omega].

  simpl; fold (canonic_exp beta fexp1 x).

  rewrite <- 2!ulp_neq_0; try now apply Rgt_not_eq.

  fold u; rewrite Xmid at 2.

  apply f_equal2; [|reflexivity].

  rewrite ulp_neq_0; try now apply Rgt_not_eq.

  destruct (Req_dec rd 0) as [Zrd|Nzrd].

  - 

    rewrite Zrd.

    rewrite scaled_mantissa_0.

    change 0 with (Z2R 0) at 1; rewrite Zfloor_Z2R.

    now rewrite Rmult_0_l.

  - 

    assert (Nnrd : 0 <= rd).

    { apply round_DN_pt.

      - exact Vfexp1.

      - apply generic_format_0.

      - now apply Rlt_le. }

    assert (Prd : 0 < rd); [lra|].

    assert (Lrd : (ln_beta rd = ln_beta x :> Z)).

    { apply Zle_antisym.

      - apply ln_beta_le; [exact Prd|].

        now apply round_DN_pt.

      - apply ln_beta_round_ge.

        + exact Vfexp1.

        + now apply valid_rnd_DN.

        + exact Nzrd. }

    unfold scaled_mantissa.

    unfold rd at 1.

    unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

    bpow_simplify.

    rewrite Lrd.

    rewrite <- (Z2R_Zpower _ (_ - _)); [|omega].

    rewrite <- Z2R_mult.

    rewrite (Zfloor_imp (Zfloor (x * bpow (- fexp1 (ln_beta x))) *

                         beta ^ (fexp1 (ln_beta x) - fexp2 (ln_beta x)))).

    + rewrite Z2R_mult.

      rewrite Z2R_Zpower; [|omega].

      bpow_simplify.

      now unfold rd.

    + split; [now apply Rle_refl|].

      rewrite Z2R_plus.

      simpl; lra. }

apply (generic_format_F2R' _ _ x f Hf).

intros _.

apply Zle_refl.

Qed.



Lemma double_round_really_zero :

  forall (fexp1 fexp2 : Z -> Z),

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (ln_beta x <= fexp1 (ln_beta x) - 2)%Z ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf1.

assert (Hlx : bpow (ln_beta x - 1) <= x < bpow (ln_beta x)).

{ destruct (ln_beta x) as (ex,Hex); simpl.

  rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].

  apply Hex.

  now apply Rgt_not_eq. }

unfold double_round_eq.

rewrite (round_N_really_small_pos beta fexp1 _ x (ln_beta x)); [|exact Hlx|omega].

set (x'' := round beta fexp2 (Znearest choice2) x).

destruct (Req_dec x'' 0) as [Zx''|Nzx''];

  [now rewrite Zx''; rewrite round_0; [|apply valid_rnd_N]|].

destruct (Zle_or_lt (fexp2 (ln_beta x)) (ln_beta x)).

- 

  destruct (Rlt_or_le x'' (bpow (ln_beta x))).

  + 

    rewrite (round_N_really_small_pos beta fexp1 _ _ (ln_beta x));

    [reflexivity|split; [|exact H0]|omega].

    apply round_large_pos_ge_pow; [now apply valid_rnd_N| |now apply Hlx].

    fold x''; assert (0 <= x''); [|lra]; unfold x''.

    rewrite <- (round_0 beta fexp2 (Znearest choice2)).

    now apply round_le; [|apply valid_rnd_N|apply Rlt_le].

  + 

    assert (Hx'' : x'' = bpow (ln_beta x)).

    { apply Rle_antisym; [|exact H0].

      rewrite <- (round_generic beta fexp2 (Znearest choice2) (bpow _)).

      - now apply round_le; [|apply valid_rnd_N|apply Rlt_le].

      - now apply generic_format_bpow'. }

    rewrite Hx''.

    unfold round, F2R, scaled_mantissa, canonic_exp; simpl.

    rewrite ln_beta_bpow.

    assert (Hf11 : (fexp1 (ln_beta x + 1) = fexp1 (ln_beta x) :> Z)%Z);

      [apply Vfexp1; omega|].

    rewrite Hf11.

    apply (Rmult_eq_reg_r (bpow (- fexp1 (ln_beta x))));

      [|now apply Rgt_not_eq; apply bpow_gt_0].

    rewrite Rmult_0_l; bpow_simplify.

    change 0 with (Z2R 0); apply f_equal.

    apply Znearest_imp.

    simpl; unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r.

    rewrite Rabs_right; [|now apply Rle_ge; apply bpow_ge_0].

    apply Rle_lt_trans with (bpow (- 2)); [now apply bpow_le; omega|].

    unfold Fcore_Raux.bpow, Z.pow_pos; simpl; rewrite Zmult_1_r.

    assert (Hbeta : (2 <= beta)%Z).

    { destruct beta as (beta_val,beta_prop); simpl.

      now apply Zle_bool_imp_le. }

    apply Rinv_lt_contravar.

    * apply Rmult_lt_0_compat; [lra|].

      rewrite Z2R_mult; apply Rmult_lt_0_compat; change 0 with (Z2R 0);

      apply Z2R_lt; omega.

    * change 2 with (Z2R 2); apply Z2R_lt.

      apply (Zle_lt_trans _ _ _ Hbeta).

      rewrite <- (Zmult_1_r beta) at 1.

      apply Zmult_lt_compat_l; omega.

- 

  casetype False; apply Nzx''.

  now apply (round_N_really_small_pos beta _ _ _ (ln_beta x)).

Qed.



Lemma double_round_zero :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp1 (ln_beta x) = ln_beta x + 1 :> Z)%Z ->

  x < bpow (ln_beta x) - / 2 * ulp beta fexp2 x ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf1.

unfold double_round_eq.

set (x'' := round beta fexp2 (Znearest choice2) x).

set (u1 := ulp beta fexp1 x).

set (u2 := ulp beta fexp2 x).

intro Hx.

assert (Hlx : bpow (ln_beta x - 1) <= x < bpow (ln_beta x)).

{ destruct (ln_beta x) as (ex,Hex); simpl.

  rewrite <- (Rabs_right x); [|now apply Rle_ge; apply Rlt_le].

  apply Hex.

  now apply Rgt_not_eq. }

rewrite (round_N_really_small_pos beta fexp1 choice1 x (ln_beta x));

  [|exact Hlx|omega].

destruct (Req_dec x'' 0) as [Zx''|Nzx''];

  [now rewrite Zx''; rewrite round_0; [reflexivity|apply valid_rnd_N]|].

rewrite (round_N_really_small_pos beta _ _ x'' (ln_beta x));

  [reflexivity| |omega].

split.

- apply round_large_pos_ge_pow.

  + now apply valid_rnd_N.

  + assert (0 <= x''); [|now fold x''; lra].

    rewrite <- (round_0 beta fexp2 (Znearest choice2)).

    now apply round_le; [|apply valid_rnd_N|apply Rlt_le].

  + apply Rle_trans with (Rabs x);

    [|now rewrite Rabs_right; [apply Rle_refl|apply Rle_ge; apply Rlt_le]].

    destruct (ln_beta x) as (ex,Hex); simpl; apply Hex.

    now apply Rgt_not_eq.

- replace x'' with (x + (x'' - x)) by ring.

  replace (bpow _) with (bpow (ln_beta x) - / 2 * u2 + / 2 * u2) by ring.

  apply Rplus_lt_le_compat; [exact Hx|].

  apply Rabs_le_inv.

  now apply error_le_half_ulp.

Qed.



Lemma double_round_all_mid_cases :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  forall x,

  0 < x ->

  (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z ->

  ((fexp1 (ln_beta x) = ln_beta x + 1 :> Z)%Z ->

   bpow (ln_beta x) - / 2 * ulp beta fexp2 x <= x ->

   double_round_eq fexp1 fexp2 choice1 choice2 x) ->

  ((fexp1 (ln_beta x) <= ln_beta x)%Z ->

   midp fexp1 x - / 2 * ulp beta fexp2 x <= x < midp fexp1 x ->

   double_round_eq fexp1 fexp2 choice1 choice2 x) ->

  ((fexp1 (ln_beta x) <= ln_beta x)%Z ->

   x = midp fexp1 x ->

   double_round_eq fexp1 fexp2 choice1 choice2 x) ->

  ((fexp1 (ln_beta x) <= ln_beta x)%Z ->

   midp fexp1 x < x <= midp fexp1 x + / 2 * ulp beta fexp2 x ->

   double_round_eq fexp1 fexp2 choice1 choice2 x) ->

  double_round_eq fexp1 fexp2 choice1 choice2 x.

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 x Px Hf2.

set (x' := round beta fexp1 Zfloor x).

set (u1 := ulp beta fexp1 x).

set (u2 := ulp beta fexp2 x).

intros Cz Clt Ceq Cgt.

destruct (Ztrichotomy (ln_beta x) (fexp1 (ln_beta x) - 1)) as [Hlt|[Heq|Hgt]].

- 

  assert (H : (ln_beta x <= fexp1 (ln_beta x) - 2)%Z) by omega.

  now apply double_round_really_zero.

- 

  assert (H : (fexp1 (ln_beta x) = (ln_beta x + 1))%Z) by omega.

  destruct (Rlt_or_le x (bpow (ln_beta x) - / 2 * u2)) as [Hlt'|Hge'].

  + now apply double_round_zero.

  + now apply Cz.

- 

  assert (H : (fexp1 (ln_beta x) <= ln_beta x)%Z) by omega.

  destruct (Rtotal_order x (midp fexp1 x)) as [Hlt'|[Heq'|Hgt']].

  + 

    destruct (Rlt_or_le x (midp fexp1 x - / 2 * u2)) as [Hlt''|Hle''].

    * now apply double_round_lt_mid_further_place; [| | |omega| |].

    * now apply Clt; [|split].

  + 

    now apply Ceq.

  + 

    destruct (Rle_or_lt x (midp fexp1 x + / 2 * u2)) as [Hlt''|Hle''].

    * now apply Cgt; [|split].

    * { destruct (generic_format_EM beta fexp1 x) as [Fx|Nfx].

        - 

          unfold double_round_eq; rewrite (round_generic beta fexp2);

          [reflexivity|now apply valid_rnd_N|].

          now apply (generic_inclusion_ln_beta beta fexp1); [omega|].

        - 

          assert (Hceil : round beta fexp1 Zceil x = x' + u1);

          [now apply round_UP_DN_ulp|].

          assert (Hf2' : (fexp2 (ln_beta x) <= fexp1 (ln_beta x) - 1)%Z);

            [omega|].

          assert (midp' fexp1 x + / 2 * ulp beta fexp2 x < x);

            [|now apply double_round_gt_mid_further_place].

          revert Hle''; unfold midp, midp'; fold x'.

          rewrite Hceil; fold u1; fold u2.

          lra. }

Qed.



Lemma ln_beta_div_disj :

  forall x y : R,

  0 < x -> 0 < y ->

  ((ln_beta (x / y) = ln_beta x - ln_beta y :> Z)%Z

   \/ (ln_beta (x / y) = ln_beta x - ln_beta y + 1 :> Z)%Z).

Proof.

intros x y Px Py.

generalize (ln_beta_div beta x y Px Py).

omega.

Qed.



Definition double_round_div_hyp fexp1 fexp2 :=

  (forall ex, (fexp2 ex <= fexp1 ex - 1)%Z)

  /\ (forall ex ey, (fexp1 ex < ex)%Z -> (fexp1 ey < ey)%Z ->

                    (fexp1 (ex - ey) <= ex - ey + 1)%Z ->

                    (fexp2 (ex - ey) <= fexp1 ex - ey)%Z)

  /\ (forall ex ey, (fexp1 ex < ex)%Z -> (fexp1 ey < ey)%Z ->

                    (fexp1 (ex - ey + 1) <= ex - ey + 1 + 1)%Z ->

                    (fexp2 (ex - ey + 1) <= fexp1 ex - ey)%Z)

  /\ (forall ex ey, (fexp1 ex < ex)%Z -> (fexp1 ey < ey)%Z ->

                    (fexp1 (ex - ey) <= ex - ey)%Z ->

                    (fexp2 (ex - ey) <= fexp1 (ex - ey)

                                        + fexp1 ey - ey)%Z)

  /\ (forall ex ey, (fexp1 ex < ex)%Z -> (fexp1 ey < ey)%Z ->

                    (fexp1 (ex - ey) = ex - ey + 1)%Z ->

                    (fexp2 (ex - ey) <= ex - ey - ey + fexp1 ey)%Z).



Lemma double_round_div_aux0 :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_div_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  fexp1 (ln_beta (x / y)) = (ln_beta (x / y) + 1)%Z ->

  ~ (bpow (ln_beta (x / y)) - / 2 * ulp beta fexp2 (x / y) <= x / y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Fx Fy Hf1.

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Hfy : (fexp1 (ln_beta y) < ln_beta y)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

set (p := bpow (ln_beta (x / y))).

set (u2 := bpow (fexp2 (ln_beta (x / y)))).

revert Fx Fy.

unfold generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

set (mx := Ztrunc (x * bpow (- fexp1 (ln_beta x)))).

set (my := Ztrunc (y * bpow (- fexp1 (ln_beta y)))).

intros Fx Fy.

rewrite ulp_neq_0.

2: apply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].

2: now apply Rinv_neq_0_compat, Rgt_not_eq.

intro Hl.

assert (Hr : x / y < p);

  [now apply Rabs_lt_inv; apply bpow_ln_beta_gt|].

apply (Rlt_irrefl (p - / 2 * u2)).

apply (Rle_lt_trans _ _ _ Hl).

apply (Rmult_lt_reg_r y _ _ Py).

unfold Rdiv; rewrite Rmult_assoc.

rewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.

destruct (Zle_or_lt Z0 (fexp1 (ln_beta x) - ln_beta (x / y)

                        - fexp1 (ln_beta y))%Z) as [He|He].

- 

  apply Rle_lt_trans with (p * y - p * bpow (fexp1 (ln_beta y))).

  + rewrite Fx; rewrite Fy at 1.

    rewrite <- Rmult_assoc.

    rewrite (Rmult_comm p).

    unfold p; bpow_simplify.

    apply (Rmult_le_reg_r (bpow (- ln_beta (x / y) - fexp1 (ln_beta y))));

      [now apply bpow_gt_0|].

    rewrite Rmult_minus_distr_r.

    bpow_simplify.

    rewrite <- Z2R_Zpower; [|exact He].

    rewrite <- Z2R_mult.

    change 1 with (Z2R 1); rewrite <- Z2R_minus.

    apply Z2R_le.

    apply (Zplus_le_reg_r _ _ 1); ring_simplify.

    apply Zlt_le_succ.

    apply lt_Z2R.

    rewrite Z2R_mult.

    rewrite Z2R_Zpower; [|exact He].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta y) + ln_beta (x / y))));

      [now apply bpow_gt_0|].

    bpow_simplify.

    rewrite <- Fx.

    rewrite bpow_plus.

    rewrite <- Rmult_assoc; rewrite <- Fy.

    fold p.

    apply (Rmult_lt_reg_r (/ y)); [now apply Rinv_0_lt_compat|].

    field_simplify; lra.

  + rewrite Rmult_minus_distr_r.

    unfold Rminus; apply Rplus_lt_compat_l.

    apply Ropp_lt_contravar.

    apply Rlt_le_trans with (u2 * bpow (ln_beta y)).

    * rewrite <- (Rmult_1_l (u2 * _)).

      rewrite Rmult_assoc.

      { apply Rmult_lt_compat.

        - lra.

        - now apply Rmult_le_pos; [apply bpow_ge_0|apply Rlt_le].

        - lra.

        - apply Rmult_lt_compat_l; [now apply bpow_gt_0|].

          apply Rabs_lt_inv.

          apply bpow_ln_beta_gt. }

    * unfold u2, p, ulp, canonic_exp; bpow_simplify; apply bpow_le.

      apply (Zplus_le_reg_r _ _ (- ln_beta y)); ring_simplify.

      rewrite (Zplus_comm (- _)); fold (Zminus (ln_beta (x / y)) (ln_beta y)).

      destruct (ln_beta_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;

      [now apply Hexp; [| |rewrite <- Hxy]|].

      replace (_ - _ + 1)%Z with ((ln_beta x + 1) - ln_beta y)%Z by ring.

      apply Hexp.

      { now assert (fexp1 (ln_beta x + 1) <= ln_beta x)%Z;

        [apply valid_exp|omega]. }

      { assumption. }

      replace (_ + 1 - _)%Z with (ln_beta x - ln_beta y + 1)%Z by ring.

      now rewrite <- Hxy.

- 

  apply Rle_lt_trans with (p * y - bpow (fexp1 (ln_beta x))).

  + rewrite Fx at 1; rewrite Fy at 1.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite Rmult_minus_distr_r.

    bpow_simplify.

    rewrite (Rmult_comm p).

    unfold p; bpow_simplify.

    rewrite <- Z2R_Zpower; [|omega].

    rewrite <- Z2R_mult.

    change 1 with (Z2R 1); rewrite <- Z2R_minus.

    apply Z2R_le.

    apply (Zplus_le_reg_r _ _ 1); ring_simplify.

    apply Zlt_le_succ.

    apply lt_Z2R.

    rewrite Z2R_mult.

    rewrite Z2R_Zpower; [|omega].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x))));

      [now apply bpow_gt_0|bpow_simplify].

    rewrite <- Fx.

    rewrite Zplus_comm; rewrite bpow_plus.

    rewrite <- Rmult_assoc; rewrite <- Fy.

    fold p.

    apply (Rmult_lt_reg_r (/ y)); [now apply Rinv_0_lt_compat|].

    field_simplify; lra.

  + rewrite Rmult_minus_distr_r.

    unfold Rminus; apply Rplus_lt_compat_l.

    apply Ropp_lt_contravar.

    apply Rlt_le_trans with (u2 * bpow (ln_beta y)).

    * rewrite <- (Rmult_1_l (u2 * _)).

      rewrite Rmult_assoc.

      { apply Rmult_lt_compat.

        - lra.

        - now apply Rmult_le_pos; [apply bpow_ge_0|apply Rlt_le].

        - lra.

        - apply Rmult_lt_compat_l; [now apply bpow_gt_0|].

          apply Rabs_lt_inv.

          apply bpow_ln_beta_gt. }

    * unfold u2, p, ulp, canonic_exp; bpow_simplify; apply bpow_le.

      apply (Zplus_le_reg_r _ _ (- ln_beta y)); ring_simplify.

      rewrite (Zplus_comm (- _)); fold (Zminus (ln_beta (x / y)) (ln_beta y)).

      destruct (ln_beta_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;

      apply Hexp; try assumption; rewrite <- Hxy; rewrite Hf1; apply Zle_refl.

Qed.



Lemma double_round_div_aux1 :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_div_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  (fexp1 (ln_beta (x / y)) <= ln_beta (x / y))%Z ->

  ~ (midp fexp1 (x / y) - / 2 * ulp beta fexp2 (x / y)

     <= x / y

     < midp fexp1 (x / y)).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Fx Fy Hf1.

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Hfy : (fexp1 (ln_beta y) < ln_beta y)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (S : (x / y <> 0)%R).

apply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].

now apply Rinv_neq_0_compat, Rgt_not_eq.

cut (~ (/ 2 * (ulp beta fexp1 (x / y) - ulp beta fexp2 (x / y))

        <= x / y - round beta fexp1 Zfloor (x / y)

        < / 2 * ulp beta fexp1 (x / y))).

{ intro H; intro H'; apply H; split.

  - apply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).

    ring_simplify.

    apply H'.

  - apply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).

    ring_simplify.

    apply H'. }

set (u1 := bpow (fexp1 (ln_beta (x / y)))).

set (u2 := bpow (fexp2 (ln_beta (x / y)))).

set (x' := round beta fexp1 Zfloor (x / y)).

rewrite 2!ulp_neq_0; trivial.

revert Fx Fy.

unfold generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

set (mx := Ztrunc (x * bpow (- fexp1 (ln_beta x)))).

set (my := Ztrunc (y * bpow (- fexp1 (ln_beta y)))).

intros Fx Fy.

intro Hlr.

apply (Rlt_irrefl (/ 2 * (u1 - u2))).

apply (Rle_lt_trans _ _ _ (proj1 Hlr)).

apply (Rplus_lt_reg_r x'); ring_simplify.

apply (Rmult_lt_reg_r y _ _ Py).

unfold Rdiv; rewrite Rmult_assoc.

rewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.

rewrite Rmult_minus_distr_r; rewrite Rmult_plus_distr_r.

apply (Rmult_lt_reg_l 2); [lra|].

rewrite Rmult_minus_distr_l; rewrite Rmult_plus_distr_l.

do 5 rewrite <- Rmult_assoc.

rewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.

destruct (Zle_or_lt Z0 (fexp1 (ln_beta x) - fexp1 (ln_beta (x / y))

                     - fexp1 (ln_beta y))%Z) as [He|He].

- 

  apply Rle_lt_trans with (2 * x' * y + u1 * y

                                        - bpow (fexp1 (ln_beta (x / y))

                                                + fexp1 (ln_beta y))).

  + rewrite Fx at 1; rewrite Fy at 1 2.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta (x / y))

                                 - fexp1 (ln_beta y))));

      [now apply bpow_gt_0|].

    rewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).

    bpow_simplify.

    replace (2 * x' * _ * _)

    with (2 * Z2R my * x' * bpow (- fexp1 (ln_beta (x / y)))) by ring.

    rewrite (Rmult_comm u1).

    unfold x', u1, round, F2R, ulp, scaled_mantissa, canonic_exp; simpl.

    bpow_simplify.

    rewrite <- Z2R_Zpower; [|exact He].

    change 2 with (Z2R 2).

    do 4 rewrite <- Z2R_mult.

    rewrite <- Z2R_plus.

    change 1 with (Z2R 1); rewrite <- Z2R_minus.

    apply Z2R_le.

    apply (Zplus_le_reg_r _ _ 1); ring_simplify.

    apply Zlt_le_succ.

    apply lt_Z2R.

    rewrite Z2R_plus.

    do 4 rewrite Z2R_mult; simpl.

    rewrite Z2R_Zpower; [|exact He].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta (x / y))

                                 + fexp1 (ln_beta y))));

      [now apply bpow_gt_0|bpow_simplify].

    rewrite Rmult_assoc.

    rewrite <- Fx.

    rewrite (Rmult_plus_distr_r _ _ (Fcore_Raux.bpow _ _)).

    rewrite Rmult_assoc.

    rewrite bpow_plus.

    rewrite <- (Rmult_assoc (Z2R (Zfloor _))).

    change (Z2R (Zfloor _) * _) with x'.

    do 2 rewrite (Rmult_comm _ (bpow (fexp1 (ln_beta y)))).

    rewrite Rmult_assoc.

    do 2 rewrite <- (Rmult_assoc (Z2R my)).

    rewrite <- Fy.

    change (bpow _) with u1.

    apply (Rmult_lt_reg_l (/ 2)); [lra|].

    rewrite Rmult_plus_distr_l.

    do 4 rewrite <- Rmult_assoc.

    rewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.

    apply (Rplus_lt_reg_r (- y * x')); ring_simplify.

    apply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].

    rewrite Rmult_minus_distr_l.

    do 3 rewrite <- Rmult_assoc.

    rewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.

    now rewrite Rmult_comm.

  + apply Rplus_lt_compat_l.

    apply Ropp_lt_contravar.

    apply Rlt_le_trans with (u2 * bpow (ln_beta y)).

    * { apply Rmult_lt_compat_l.

        - apply bpow_gt_0.

        - apply Rabs_lt_inv.

          apply bpow_ln_beta_gt. }

    * unfold u2, ulp, canonic_exp; bpow_simplify; apply bpow_le.

      apply (Zplus_le_reg_r _ _ (- ln_beta y)); ring_simplify.

      rewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).

      destruct (ln_beta_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;

      [now apply Hexp; [| |rewrite <- Hxy]|].

      replace (_ - _ + 1)%Z with ((ln_beta x + 1) - ln_beta y)%Z by ring.

      apply Hexp.

      { now assert (fexp1 (ln_beta x + 1) <= ln_beta x)%Z;

        [apply valid_exp|omega]. }

      { assumption. }

      replace (_ + 1 - _)%Z with (ln_beta x - ln_beta y + 1)%Z by ring.

      now rewrite <- Hxy.

- 

  apply Rle_lt_trans with (2 * x' * y + u1 * y - bpow (fexp1 (ln_beta x))).

  + rewrite Fx at 1; rewrite Fy at 1 2.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite Rmult_minus_distr_r; rewrite (Rmult_plus_distr_r (_ * _ * _)).

    bpow_simplify.

    replace (2 * x' * _ * _)

    with (2 * Z2R my * x' * bpow (fexp1 (ln_beta y) - fexp1 (ln_beta x))) by ring.

    rewrite (Rmult_comm u1).

    unfold x', u1, round, F2R, ulp, scaled_mantissa, canonic_exp; simpl.

    bpow_simplify.

    rewrite <- (Z2R_Zpower _ (_ - _)%Z); [|omega].

    change 2 with (Z2R 2).

    do 5 rewrite <- Z2R_mult.

    rewrite <- Z2R_plus.

    change 1 with (Z2R 1); rewrite <- Z2R_minus.

    apply Z2R_le.

    apply (Zplus_le_reg_r _ _ 1); ring_simplify.

    apply Zlt_le_succ.

    apply lt_Z2R.

    rewrite Z2R_plus.

    do 5 rewrite Z2R_mult; simpl.

    rewrite Z2R_Zpower; [|omega].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite Rmult_assoc.

    rewrite <- Fx.

    rewrite (Rmult_plus_distr_r _ _ (Fcore_Raux.bpow _ _)).

    bpow_simplify.

    rewrite Rmult_assoc.

    rewrite bpow_plus.

    rewrite <- (Rmult_assoc (Z2R (Zfloor _))).

    change (Z2R (Zfloor _) * _) with x'.

    do 2 rewrite (Rmult_comm _ (bpow (fexp1 (ln_beta y)))).

    rewrite Rmult_assoc.

    do 2 rewrite <- (Rmult_assoc (Z2R my)).

    rewrite <- Fy.

    change (bpow _) with u1.

    apply (Rmult_lt_reg_l (/ 2)); [lra|].

    rewrite Rmult_plus_distr_l.

    do 4 rewrite <- Rmult_assoc.

    rewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.

    apply (Rplus_lt_reg_r (- y * x')); ring_simplify.

    apply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].

    rewrite Rmult_minus_distr_l.

    do 3 rewrite <- Rmult_assoc.

    rewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.

    now rewrite Rmult_comm.

  + apply Rplus_lt_compat_l.

    apply Ropp_lt_contravar.

    apply Rlt_le_trans with (u2 * bpow (ln_beta y)).

    * { apply Rmult_lt_compat_l.

        - apply bpow_gt_0.

        - apply Rabs_lt_inv.

          apply bpow_ln_beta_gt. }

    * unfold u2, ulp, canonic_exp; bpow_simplify; apply bpow_le.

      apply (Zplus_le_reg_r _ _ (- ln_beta y)); ring_simplify.

      rewrite (Zplus_comm (- _)).

      destruct (ln_beta_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;

      apply Hexp; try assumption; rewrite <- Hxy; omega.

Qed.



Lemma double_round_div_aux2 :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  double_round_div_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  (fexp1 (ln_beta (x / y)) <= ln_beta (x / y))%Z ->

  ~ (midp fexp1 (x / y)

     < x / y

     <= midp fexp1 (x / y) + / 2 * ulp beta fexp2 (x / y)).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Hexp x y Px Py Fx Fy Hf1.

assert (Hfx : (fexp1 (ln_beta x) < ln_beta x)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

assert (Hfy : (fexp1 (ln_beta y) < ln_beta y)%Z);

  [now apply ln_beta_generic_gt; [|apply Rgt_not_eq|]|].

cut (~ (/ 2 * ulp beta fexp1 (x / y)

        < x / y - round beta fexp1 Zfloor (x / y)

        <= / 2 * (ulp beta fexp1 (x / y) + ulp beta fexp2 (x / y)))).

{ intro H; intro H'; apply H; split.

  - apply (Rplus_lt_reg_l (round beta fexp1 Zfloor (x / y))).

    ring_simplify.

    apply H'.

  - apply (Rplus_le_reg_l (round beta fexp1 Zfloor (x / y))).

    ring_simplify.

    apply H'. }

set (u1 := bpow (fexp1 (ln_beta (x / y)))).

set (u2 := bpow (fexp2 (ln_beta (x / y)))).

set (x' := round beta fexp1 Zfloor (x / y)).

assert (S : (x / y <> 0)%R).

apply Rmult_integral_contrapositive_currified; [now apply Rgt_not_eq|idtac].

now apply Rinv_neq_0_compat, Rgt_not_eq.

rewrite 2!ulp_neq_0; trivial.

revert Fx Fy.

unfold generic_format, F2R, scaled_mantissa, canonic_exp; simpl.

set (mx := Ztrunc (x * bpow (- fexp1 (ln_beta x)))).

set (my := Ztrunc (y * bpow (- fexp1 (ln_beta y)))).

intros Fx Fy.

intro Hlr.

apply (Rlt_irrefl (/ 2 * (u1 + u2))).

apply Rlt_le_trans with (x / y - x'); [|now apply Hlr].

apply (Rplus_lt_reg_r x'); ring_simplify.

apply (Rmult_lt_reg_r y _ _ Py).

unfold Rdiv; rewrite Rmult_assoc.

rewrite Rinv_l; [|now apply Rgt_not_eq]; rewrite Rmult_1_r.

do 2 rewrite Rmult_plus_distr_r.

apply (Rmult_lt_reg_l 2); [lra|].

do 2 rewrite Rmult_plus_distr_l.

do 5 rewrite <- Rmult_assoc.

rewrite Rinv_r; [|lra]; do 2 rewrite Rmult_1_l.

destruct (Zle_or_lt Z0 (fexp1 (ln_beta x) - fexp1 (ln_beta (x / y))

                     - fexp1 (ln_beta y))%Z) as [He|He].

- 

  apply Rlt_le_trans with (u1 * y + bpow (fexp1 (ln_beta (x / y))

                                          + fexp1 (ln_beta y))

                           + 2 * x' * y).

  + apply Rplus_lt_compat_r, Rplus_lt_compat_l.

    apply Rlt_le_trans with (u2 * bpow (ln_beta y)).

    * { apply Rmult_lt_compat_l.

        - apply bpow_gt_0.

        - apply Rabs_lt_inv.

          apply bpow_ln_beta_gt. }

    * unfold u2, ulp, canonic_exp; bpow_simplify; apply bpow_le.

      apply (Zplus_le_reg_r _ _ (- ln_beta y)); ring_simplify.

      rewrite <- Zplus_assoc; rewrite (Zplus_comm (- _)).

      destruct (ln_beta_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;

      [now apply Hexp; [| |rewrite <- Hxy]|].

      replace (_ - _ + 1)%Z with ((ln_beta x + 1) - ln_beta y)%Z by ring.

      apply Hexp.

      { now assert (fexp1 (ln_beta x + 1) <= ln_beta x)%Z;

        [apply valid_exp|omega]. }

      { assumption. }

      replace (_ + 1 - _)%Z with (ln_beta x - ln_beta y + 1)%Z by ring.

      now rewrite <- Hxy.

  + apply Rge_le; rewrite Fx at 1; apply Rle_ge.

    replace (u1 * y) with (u1 * (Z2R my * bpow (fexp1 (ln_beta y))));

      [|now apply eq_sym; rewrite Fy at 1].

    replace (2 * x' * y) with (2 * x' * (Z2R my * bpow (fexp1 (ln_beta y))));

      [|now apply eq_sym; rewrite Fy at 1].

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta (x / y))

                                 - fexp1 (ln_beta y))));

      [now apply bpow_gt_0|].

    do 2 rewrite Rmult_plus_distr_r.

    bpow_simplify.

    rewrite (Rmult_comm u1).

    unfold u1, ulp, canonic_exp; bpow_simplify.

    rewrite (Rmult_assoc 2).

    rewrite (Rmult_comm x').

    rewrite (Rmult_assoc 2).

    unfold x', round, F2R, scaled_mantissa, canonic_exp; simpl.

    bpow_simplify.

    rewrite <- (Z2R_Zpower _ (_ - _)%Z); [|exact He].

    change 2 with (Z2R 2).

    do 4 rewrite <- Z2R_mult.

    change 1 with (Z2R 1); do 2 rewrite <- Z2R_plus.

    apply Z2R_le.

    rewrite Zplus_comm, Zplus_assoc.

    apply Zlt_le_succ.

    apply lt_Z2R.

    rewrite Z2R_plus.

    do 4 rewrite Z2R_mult; simpl.

    rewrite Z2R_Zpower; [|exact He].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta y))));

      [now apply bpow_gt_0|].

    rewrite Rmult_plus_distr_r.

    rewrite (Rmult_comm _ (Z2R _)).

    do 2 rewrite Rmult_assoc.

    rewrite <- Fy.

    bpow_simplify.

    unfold Zminus; rewrite bpow_plus.

    rewrite (Rmult_assoc _ (Z2R mx)).

    rewrite <- (Rmult_assoc (Z2R mx)).

    rewrite <- Fx.

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta (x / y)))));

      [now apply bpow_gt_0|].

    rewrite Rmult_plus_distr_r.

    bpow_simplify.

    rewrite (Rmult_comm _ y).

    do 2 rewrite Rmult_assoc.

    change (Z2R (Zfloor _) * _) with x'.

    change (bpow _) with u1.

    apply (Rmult_lt_reg_l (/ 2)); [lra|].

    rewrite Rmult_plus_distr_l.

    do 4 rewrite <- Rmult_assoc.

    rewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.

    apply (Rplus_lt_reg_r (- y * x')); ring_simplify.

    apply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].

    rewrite Rmult_plus_distr_l.

    do 3 rewrite <- Rmult_assoc.

    rewrite Ropp_mult_distr_r_reverse.

    rewrite Ropp_mult_distr_l_reverse.

    rewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.

    rewrite (Rmult_comm (/ y)).

    now rewrite (Rplus_comm (- x')).

- 

  apply Rlt_le_trans with (2 * x' * y + u1 * y + bpow (fexp1 (ln_beta x))).

  + rewrite Rplus_comm, Rplus_assoc; do 2 apply Rplus_lt_compat_l.

    apply Rlt_le_trans with (u2 * bpow (ln_beta y)).

    * apply Rmult_lt_compat_l.

      now apply bpow_gt_0.

      now apply Rabs_lt_inv; apply bpow_ln_beta_gt.

    * unfold u2, ulp, canonic_exp; bpow_simplify; apply bpow_le.

      apply (Zplus_le_reg_r _ _ (- ln_beta y)); ring_simplify.

      rewrite (Zplus_comm (- _)).

      destruct (ln_beta_div_disj x y Px Py) as [Hxy|Hxy]; rewrite Hxy;

      apply Hexp; try assumption; rewrite <- Hxy; omega.

  + apply Rge_le; rewrite Fx at 1; apply Rle_ge.

    rewrite Fy at 1 2.

    apply (Rmult_le_reg_r (bpow (- fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    do 2 rewrite Rmult_plus_distr_r.

    bpow_simplify.

    replace (2 * x' * _ * _)

    with (2 * Z2R my * x' * bpow (fexp1 (ln_beta y) - fexp1 (ln_beta x))) by ring.

    rewrite (Rmult_comm u1).

    unfold x', u1, round, F2R, ulp, scaled_mantissa, canonic_exp; simpl.

    bpow_simplify.

    rewrite <- (Z2R_Zpower _ (_ - _)%Z); [|omega].

    change 2 with (Z2R 2).

    do 5 rewrite <- Z2R_mult.

    change 1 with (Z2R 1); do 2 rewrite <- Z2R_plus.

    apply Z2R_le.

    apply Zlt_le_succ.

    apply lt_Z2R.

    rewrite Z2R_plus.

    do 5 rewrite Z2R_mult; simpl.

    rewrite Z2R_Zpower; [|omega].

    apply (Rmult_lt_reg_r (bpow (fexp1 (ln_beta x))));

      [now apply bpow_gt_0|].

    rewrite (Rmult_assoc _ (Z2R mx)).

    rewrite <- Fx.

    rewrite Rmult_plus_distr_r.

    bpow_simplify.

    rewrite bpow_plus.

    rewrite Rmult_assoc.

    rewrite <- (Rmult_assoc (Z2R _)).

    change (Z2R _ * bpow _) with x'.

    do 2 rewrite (Rmult_comm _ (bpow (fexp1 (ln_beta y)))).

    rewrite Rmult_assoc.

    do 2 rewrite <- (Rmult_assoc (Z2R my)).

    rewrite <- Fy.

    change (bpow _) with u1.

    apply (Rmult_lt_reg_l (/ 2)); [lra|].

    rewrite Rmult_plus_distr_l.

    do 4 rewrite <- Rmult_assoc.

    rewrite Rinv_l; [|lra]; do 2 rewrite Rmult_1_l.

    apply (Rplus_lt_reg_r (- y * x')); ring_simplify.

    apply (Rmult_lt_reg_l (/ y)); [now apply Rinv_0_lt_compat|].

    rewrite Rmult_plus_distr_l.

    do 3 rewrite <- Rmult_assoc.

    rewrite Ropp_mult_distr_r_reverse.

    rewrite Ropp_mult_distr_l_reverse.

    rewrite Rinv_l; [|now apply Rgt_not_eq]; do 2 rewrite Rmult_1_l.

    rewrite (Rmult_comm (/ y)).

    now rewrite (Rplus_comm (- x')).

Qed.



Lemma double_round_div_aux :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  (exists n, (beta = 2 * n :> Z)%Z) ->

  double_round_div_hyp fexp1 fexp2 ->

  forall x y,

  0 < x -> 0 < y ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x / y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Ebeta Hexp x y Px Py Fx Fy.

assert (Pxy : 0 < x / y).

{ apply Rmult_lt_0_compat; [exact Px|].

  now apply Rinv_0_lt_compat. }

apply double_round_all_mid_cases.

- exact Vfexp1.

- exact Vfexp2.

- exact Pxy.

- apply Hexp.

- intros Hf1 Hlxy.

  casetype False.

  now apply (double_round_div_aux0 fexp1 fexp2 _ _ choice1 choice2 Hexp x y).

- intros Hf1 Hlxy.

  casetype False.

  now apply (double_round_div_aux1 fexp1 fexp2 _ _ choice1 choice2 Hexp x y).

- intro H.

  apply double_round_eq_mid_beta_even; try assumption.

  apply Hexp.

- intros Hf1 Hlxy.

  casetype False.

  now apply (double_round_div_aux2 fexp1 fexp2 _ _ choice1 choice2 Hexp x y).

Qed.



Lemma double_round_div :

  forall fexp1 fexp2 : Z -> Z,

  Valid_exp fexp1 -> Valid_exp fexp2 ->

  forall (choice1 choice2 : Z -> bool),

  (exists n, (beta = 2 * n :> Z)%Z) ->

  double_round_div_hyp fexp1 fexp2 ->

  forall x y,

  y <> 0 ->

  generic_format beta fexp1 x ->

  generic_format beta fexp1 y ->

  double_round_eq fexp1 fexp2 choice1 choice2 (x / y).

Proof.

intros fexp1 fexp2 Vfexp1 Vfexp2 choice1 choice2 Ebeta Hexp x y Nzy Fx Fy.

unfold double_round_eq.

destruct (Rtotal_order x 0) as [Nx|[Zx|Px]].

- 

  destruct (Rtotal_order y 0) as [Ny|[Zy|Py]].

  + 

    rewrite <- (Ropp_involutive x).

    rewrite <- (Ropp_involutive y).

    rewrite Ropp_div.

    unfold Rdiv; rewrite <- Ropp_inv_permute; [|lra].

    rewrite Ropp_mult_distr_r_reverse.

    rewrite Ropp_involutive.

    fold ((- x) / (- y)).

    apply Ropp_lt_contravar in Nx.

    apply Ropp_lt_contravar in Ny.

    rewrite Ropp_0 in Nx, Ny.

    apply generic_format_opp in Fx.

    apply generic_format_opp in Fy.

    now apply double_round_div_aux.

  + 

    now casetype False; apply Nzy.

  + 

    rewrite <- (Ropp_involutive x).

    rewrite Ropp_div.

    do 3 rewrite round_N_opp.

    apply Ropp_eq_compat.

    apply Ropp_lt_contravar in Nx.

    rewrite Ropp_0 in Nx.

    apply generic_format_opp in Fx.

    now apply double_round_div_aux.

- 

  rewrite Zx.

  unfold Rdiv; rewrite Rmult_0_l.

  now rewrite round_0; [|apply valid_rnd_N].

- 

  destruct (Rtotal_order y 0) as [Ny|[Zy|Py]].

  + 

    rewrite <- (Ropp_involutive y).

    unfold Rdiv; rewrite <- Ropp_inv_permute; [|lra].

    rewrite Ropp_mult_distr_r_reverse.

    do 3 rewrite round_N_opp.

    apply Ropp_eq_compat.

    apply Ropp_lt_contravar in Ny.

    rewrite Ropp_0 in Ny.

    apply generic_format_opp in Fy.

    now apply double_round_div_aux.

  + 

    now casetype False; apply Nzy.

  + 

    now apply double_round_div_aux.

Qed.



Section Double_round_div_FLX.



Import Fcore_FLX.



Variable prec : Z.

Variable prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLX_double_round_div_hyp :

  (2 * prec <= prec')%Z ->

  double_round_div_hyp (FLX_exp prec) (FLX_exp prec').

Proof.

intros Hprec.

unfold Prec_gt_0 in prec_gt_0_.

unfold FLX_exp.

unfold double_round_div_hyp.

split; [now intro ex; omega|].

split; [|split; [|split]]; intros ex ey; omega.

Qed.



Theorem double_round_div_FLX :

  forall choice1 choice2,

  (exists n, (beta = 2 * n :> Z)%Z) ->

  (2 * prec <= prec')%Z ->

  forall x y,

  y <> 0 ->

  FLX_format beta prec x -> FLX_format beta prec y ->

  double_round_eq (FLX_exp prec) (FLX_exp prec') choice1 choice2 (x / y).

Proof.

intros choice1 choice2 Ebeta Hprec x y Nzy Fx Fy.

apply double_round_div.

- now apply FLX_exp_valid.

- now apply FLX_exp_valid.

- exact Ebeta.

- now apply FLX_double_round_div_hyp.

- exact Nzy.

- now apply generic_format_FLX.

- now apply generic_format_FLX.

Qed.



End Double_round_div_FLX.



Section Double_round_div_FLT.



Import Fcore_FLX.

Import Fcore_FLT.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FLT_double_round_div_hyp :

  (emin' <= emin - prec - 2)%Z ->

  (2 * prec <= prec')%Z ->

  double_round_div_hyp (FLT_exp emin prec) (FLT_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FLT_exp.

unfold Prec_gt_0 in prec_gt_0_.

unfold double_round_div_hyp.

split; [intro ex|split; [|split; [|split]]; intros ex ey].

- generalize (Zmax_spec (ex - prec') emin').

  generalize (Zmax_spec (ex - prec) emin).

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (ey - prec) emin).

  generalize (Zmax_spec (ex - ey - prec) emin).

  generalize (Zmax_spec (ex - ey - prec') emin').

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (ey - prec) emin).

  generalize (Zmax_spec (ex - ey + 1 - prec) emin).

  generalize (Zmax_spec (ex - ey + 1 - prec') emin').

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (ey - prec) emin).

  generalize (Zmax_spec (ex - ey - prec) emin).

  generalize (Zmax_spec (ex - ey - prec') emin').

  omega.

- generalize (Zmax_spec (ex - prec) emin).

  generalize (Zmax_spec (ey - prec) emin).

  generalize (Zmax_spec (ex - ey - prec) emin).

  generalize (Zmax_spec (ex - ey - prec') emin').

  omega.

Qed.



Theorem double_round_div_FLT :

  forall choice1 choice2,

  (exists n, (beta = 2 * n :> Z)%Z) ->

  (emin' <= emin - prec - 2)%Z ->

  (2 * prec <= prec')%Z ->

  forall x y,

  y <> 0 ->

  FLT_format beta emin prec x -> FLT_format beta emin prec y ->

  double_round_eq (FLT_exp emin prec) (FLT_exp emin' prec')

                  choice1 choice2 (x / y).

Proof.

intros choice1 choice2 Ebeta Hemin Hprec x y Nzy Fx Fy.

apply double_round_div.

- now apply FLT_exp_valid.

- now apply FLT_exp_valid.

- exact Ebeta.

- now apply FLT_double_round_div_hyp.

- exact Nzy.

- now apply generic_format_FLT.

- now apply generic_format_FLT.

Qed.



End Double_round_div_FLT.



Section Double_round_div_FTZ.



Import Fcore_FLX.

Import Fcore_FTZ.



Variable emin prec : Z.

Variable emin' prec' : Z.



Context { prec_gt_0_ : Prec_gt_0 prec }.

Context { prec_gt_0_' : Prec_gt_0 prec' }.



Lemma FTZ_double_round_div_hyp :

  (emin' + prec' <= emin - 1)%Z ->

  (2 * prec <= prec')%Z ->

  double_round_div_hyp (FTZ_exp emin prec) (FTZ_exp emin' prec').

Proof.

intros Hemin Hprec.

unfold FTZ_exp.

unfold Prec_gt_0 in prec_gt_0_.

unfold Prec_gt_0 in prec_gt_0_.

unfold double_round_div_hyp.

split; [intro ex|split; [|split; [|split]]; intros ex ey].

- destruct (Z.ltb_spec (ex - prec') emin');

  destruct (Z.ltb_spec (ex - prec) emin);

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey - prec') emin');

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey + 1 - prec) emin);

  destruct (Z.ltb_spec (ex - ey + 1 - prec') emin');

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey - prec') emin');

  omega.

- destruct (Z.ltb_spec (ex - prec) emin);

  destruct (Z.ltb_spec (ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey - prec) emin);

  destruct (Z.ltb_spec (ex - ey - prec') emin');

  omega.

Qed.



Theorem double_round_div_FTZ :

  forall choice1 choice2,

  (exists n, (beta = 2 * n :> Z)%Z) ->

  (emin' + prec' <= emin - 1)%Z ->

  (2 * prec <= prec')%Z ->

  forall x y,

  y <> 0 ->

  FTZ_format beta emin prec x -> FTZ_format beta emin prec y ->

  double_round_eq (FTZ_exp emin prec) (FTZ_exp emin' prec')

                  choice1 choice2 (x / y).

Proof.

intros choice1 choice2 Ebeta Hemin Hprec x y Nzy Fx Fy.

apply double_round_div.

- now apply FTZ_exp_valid.

- now apply FTZ_exp_valid.

- exact Ebeta.

- now apply FTZ_double_round_div_hyp.

- exact Nzy.

- now apply generic_format_FTZ.

- now apply generic_format_FTZ.

Qed.



End Double_round_div_FTZ.



End Double_round_div.



End Double_round.

