

Require Import TS.

Require Import sur_les_relations.
(* sur_les_relations:
Section Rels.

Variable A : Set.

Inductive explicit_star (R : A -> A -> Prop) : A -> A -> Prop :=
  | star_refl : forall x : A, explicit_star R x x
  | star_trans1 :
      forall x y z : A, R x y -> explicit_star R y z -> explicit_star R x z.

Inductive explicit_comp_rel (R1 R2 : A -> A -> Prop) : A -> A -> Prop :=
    comp_2rel :
      forall x y z : A, R1 x y -> R2 y z -> explicit_comp_rel R1 R2 x z.

Inductive explicit_rel_plus (R : A -> A -> Prop) : A -> A -> Prop :=
  | relplus_1step : forall x y : A, R x y -> explicit_rel_plus R x y
  | relplus_trans1 :
      forall x y z : A,
      R x y -> explicit_rel_plus R y z -> explicit_rel_plus R x z. 

End Rels.

Hint Resolve star_refl.
Hint Resolve relplus_1step.

Notation star := (explicit_star _) (only parsing).

Notation comp_rel := (explicit_comp_rel _) (only parsing).

Notation rel_plus := (explicit_rel_plus _) (only parsing).

Section rels_prop.

Variable A : Set.
Variable R : A -> A -> Prop.

Definition confluence_en (x : A) :=
  forall y z : A,
  explicit_star _ R x y ->
  explicit_star _ R x z ->
  exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_confluence := forall x : A, confluence_en x.

Definition local_confluence_en (x : A) :=
  forall y z : A,
  R x y ->
  R x z -> exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_local_confluence := forall x : A, local_confluence_en x.

Definition strong_confluence_en (x : A) :=
  forall y z : A, R x y -> R x z -> exists u : A, R y u /\ R z u.

Definition explicit_strong_confluence := forall x : A, strong_confluence_en x.

End rels_prop.

Notation confluence := (explicit_confluence _) (only parsing).

Notation local_confluence := (explicit_local_confluence _) (only parsing).

Notation strong_confluence := (explicit_strong_confluence _) (only parsing).

Definition explicit_inclus (A : Set) (R1 R2 : A -> A -> Prop) :=
  forall x y : A, R1 x y -> R2 x y.

Notation inclus := (explicit_inclus _) (only parsing).

Section relations_noetherian.

Variable U : Set.

Variable R : U -> U -> Prop.

Definition a_set := U -> Prop.

Definition sub (A B : a_set) := forall x : U, A x -> B x.

Definition universal (A : a_set) := forall x : U, A x.

Definition adjoint (A : a_set) : a_set := fun x : U => sub (R x) A.

Definition hereditary (A : a_set) := sub (adjoint A) A.

Definition explicit_noetherian :=
  forall A : a_set, hereditary A -> universal A.

End relations_noetherian.

Notation noetherian := (explicit_noetherian _) (only parsing).

Goal
forall (A : Set) (P Q : A -> Prop),
(exists u : A, P u /\ Q u) -> exists u : A, Q u /\ P u.
simple induction 1; intros u1 H1.
elim H1; intros H2 H3.
exists u1; split; assumption.
Save Ex_PQ.
Hint Resolve Ex_PQ.
 
Lemma star_trans :
 forall (A : Set) (R : A -> A -> Prop) (x y z : A),
 explicit_star _ R x y -> explicit_star _ R y z -> explicit_star _ R x z.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
R x y -> explicit_star _ R x y.
intros; apply star_trans1 with y.
assumption.
apply star_refl.
Save star_step1.

Hint Resolve star_step1.

Goal
forall (A : Set) (R1 R2 : A -> A -> Prop) (M N : A),
explicit_comp_rel _ R1 R2 M N -> exists u : A, R1 M u /\ R2 u N.  
intros A R1 R2 M N H; elim H.
intros x y z H1 H2; exists y; split; assumption.
Save comp_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_comp_rel _ R (explicit_star _ R) x y -> explicit_rel_plus _ R x y.
intros A R x y H; elim H.
intros a b c H1 H2; generalize H1; generalize a.
elim H2.
intros; apply relplus_1step; assumption.
intros x0 y0 z H3 H4 H5 a0 H6; apply relplus_trans1 with x0.
assumption.
apply H5; assumption.
Save comp_relplus.

Goal
forall (A : Set) (R : A -> A -> Prop) (M N : A),
explicit_star _ R M N ->
M = N \/ (exists u : A, R M u /\ explicit_star _ R u N).
intros A R M N H; elim H.
intros x; left; trivial.
intros x y z H1 H2 H3; right; exists y; split; trivial.
Save star_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_rel_plus _ R x y ->
explicit_rel_plus _ R y z -> explicit_rel_plus _ R x z.
simple induction 1.
intros; apply relplus_trans1 with y0; trivial.
intros; apply relplus_trans1 with y0; auto.
Save Rplus_transitive.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_rel_plus _ R x y -> explicit_star _ R x y.
simple induction 1; intros.
auto.
apply star_trans1 with y0; auto.
Save Rplus_Rstar.

Hint Resolve Rplus_Rstar.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_star _ R x y ->
explicit_rel_plus _ R y z -> exists u : A, R x u /\ explicit_star _ R u z.
simple induction 1; intros.
elim H0; intros.
exists y0; auto.
exists y0; auto.
exists y0; split; trivial.
apply star_trans with z0; auto.
Save Rstar_Rplus_R.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_noetherian _ R ->
forall A1 : a_set A,
hereditary A (explicit_rel_plus _ R) A1 ->
universal A (adjoint A (explicit_star _ R) A1).
unfold explicit_noetherian in |- *; unfold hereditary in |- *;
 unfold universal in |- *; unfold sub in |- *; intros A R N A1 H x.
apply (N (adjoint A (explicit_star _ R) A1)).
unfold adjoint in |- *; unfold sub in |- *; intros.
apply H; unfold adjoint in |- *; unfold sub in |- *; intros.
elim Rstar_Rplus_R with A R x0 x1 x2; trivial.
intro z; simple induction 1; intros C1 C2; apply H0 with z; trivial.
Save noetherian_course_of_values.

Lemma plus_preserves_noetherian :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R -> explicit_noetherian _ (explicit_rel_plus _ R).

Lemma noetherian_induction1 :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, R y z -> P z) -> P y) -> P x.

Lemma noetherian_induction :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, explicit_rel_plus _ R y z -> P z) -> P y) ->
 P x.

Lemma noether_inclus :
 forall (A : Set) (R R' : A -> A -> Prop),
 explicit_noetherian _ R ->
 (forall x y : A, R' x y -> R x y) -> explicit_noetherian _ R'.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R (explicit_star _ S) ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
intros A R S H; red in |- *; simple induction 1.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans with y0; auto.
Save inclus_star.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
unfold explicit_inclus in |- *; simple induction 2.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans1 with y0.
apply (H x0 y0 H1).
assumption.
Save inclus_reg_star.
Hint Resolve inclus_reg_star.

Goal
forall (A : Set) (R1 R2 S : A -> A -> Prop),
explicit_inclus _ R1 S ->
explicit_inclus _ R2 S ->

(forall x y z : A, S x y -> S y z -> S x z) ->
explicit_inclus _ (explicit_comp_rel _ R1 R2) S.   
intros A R1 R2 S H H0 H1; red in |- *; simple induction 1.
intros x0 y0 z H3 H4; apply H1 with y0; auto.
Save inclus_comp.
Hint Resolve inclus_comp.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_strong_confluence _ R -> explicit_confluence _ R.
intros A R H; red in |- *; red in |- *.
intros x y z H1; generalize z; elim H1.
intros x0 z0 H2; exists z0; split; auto.
intros x0 y0 y1 H2 H3 H4 z0 H5.
cut (exists u : A, explicit_star _ R y0 u /\ R z0 u).
intro H6; elim H6; intros z1 H7; elim H7; intros H8 H9.
elim (H4 z1 H8); intros u H10; elim H10; intros H11 H12.
exists u; split.
assumption.
apply star_trans1 with z1; assumption.
generalize H2; generalize y0; elim H5.
intros x1 y2 H6; exists y2; split; auto.
intros x1 y2 z1 H6 H7 H8 y3 H9; elim (H x1 y3 y2).
intros x2 H10; elim H10; intros H11 H12.
elim (H8 x2 H12); intros u H13; elim H13; intros H14 H15.
exists u; split; [ apply star_trans1 with x2; assumption | assumption ];
 trivial.
assumption.
assumption.
Save strong_conf_conf.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ S (explicit_star _ R) ->
explicit_confluence _ S -> explicit_confluence _ R.
red in |- *; red in |- *; intros A R S H H0 H1 x y z H2 H3.
cut (explicit_inclus _ (explicit_star _ R) (explicit_star _ S)).
2: auto.
intro H4; elim (H1 x y z (H4 x y H2) (H4 x z H3)).
intros x' H5; elim H5; intros H6 H7.
exists x'; split.
exact (inclus_star A S R H0 y x' H6).
exact (inclus_star A S R H0 z x' H7).
Save inclus_conf. *)

Require Import sigma_lift.

Require Import lambda_sigma_lift.
(* lambda_sigma_lift:
Require Import TS.
Require Import sur_les_relations.
Require Import sigma_lift.

Inductive reg_beta : terms -> terms -> Prop :=
    reg1_beta :
      forall a b : terms, reg_beta (app (lambda a) b) (env a (cons b id)).
Hint Resolve reg1_beta.

Inductive e_systemLSL : forall b : wsort, TS b -> TS b -> Prop :=
  | beta1 : forall M N : terms, reg_beta M N -> e_systemLSL wt M N
  | SL1 :
      forall (b : wsort) (M N : TS b), e_systemSL _ M N -> e_systemLSL b M N. 
Hint Resolve beta1 SL1.

Notation systemLSL := (e_systemLSL _) (only parsing).

Inductive e_relLSL : forall b : wsort, TS b -> TS b -> Prop :=
  | LSL_one_regle :
      forall (b : wsort) (M N : TS b), e_systemLSL _ M N -> e_relLSL b M N
  | LSL_context_app_l :
      forall a a' b : terms,
      e_relLSL wt a a' -> e_relLSL wt (app a b) (app a' b)
  | LSL_context_app_r :
      forall a b b' : terms,
      e_relLSL wt b b' -> e_relLSL wt (app a b) (app a b')
  | LSL_context_lambda :
      forall a a' : terms,
      e_relLSL wt a a' -> e_relLSL wt (lambda a) (lambda a')
  | LSL_context_env_t :
      forall (a a' : terms) (s : sub_explicits),
      e_relLSL wt a a' -> e_relLSL wt (env a s) (env a' s)
  | LSL_context_env_s :
      forall (a : terms) (s s' : sub_explicits),
      e_relLSL ws s s' -> e_relLSL wt (env a s) (env a s')
  | LSL_context_cons_t :
      forall (a a' : terms) (s : sub_explicits),
      e_relLSL wt a a' -> e_relLSL ws (cons a s) (cons a' s)
  | LSL_context_cons_s :
      forall (a : terms) (s s' : sub_explicits),
      e_relLSL ws s s' -> e_relLSL ws (cons a s) (cons a s')
  | LSL_context_comp_l :
      forall s s' t : sub_explicits,
      e_relLSL ws s s' -> e_relLSL ws (comp s t) (comp s' t)
  | LSL_context_comp_r :
      forall s t t' : sub_explicits,
      e_relLSL ws t t' -> e_relLSL ws (comp s t) (comp s t')
  | LSL_context_lift :
      forall s s' : sub_explicits,
      e_relLSL ws s s' -> e_relLSL ws (lift s) (lift s').

Notation relLSL := (e_relLSL _) (only parsing).

Hint Resolve LSL_one_regle LSL_context_app_l LSL_context_app_r
  LSL_context_lambda LSL_context_env_t LSL_context_env_s LSL_context_cons_t
  LSL_context_cons_s LSL_context_comp_l LSL_context_comp_r LSL_context_lift.

Definition e_relLSLstar (b : wsort) := explicit_star _ (e_relLSL b).

Notation relLSLstar := (e_relLSLstar _) (only parsing).

Hint Unfold e_relLSLstar.

Goal
e_relLSLstar _
  (lambda (app (lambda (app (var 0) (var 0))) (lambda (app (var 0) (var 1)))))
  (lambda (app (var 0) (var 0))).
red in |- *;
 apply
  star_trans1
   with
     (lambda
        (env (app (var 0) (var 0)) (cons (lambda (app (var 0) (var 1))) id))).
auto.
apply
 star_trans1
  with
    (lambda
       (app (env (var 0) (cons (lambda (app (var 0) (var 1))) id))
          (env (var 0) (cons (lambda (app (var 0) (var 1))) id)))).
auto.
apply
 star_trans1
  with
    (lambda
       (app (lambda (app (var 0) (var 1)))
          (env (var 0) (cons (lambda (app (var 0) (var 1))) id)))).
auto 6.
apply
 star_trans1
  with
    (lambda
       (app (lambda (app (var 0) (var 1))) (lambda (app (var 0) (var 1))))).
auto 6.
apply
 star_trans1
  with
    (lambda
       (env (app (var 0) (var 1)) (cons (lambda (app (var 0) (var 1))) id))).
auto.
apply
 star_trans1
  with
    (lambda
       (app (env (var 0) (cons (lambda (app (var 0) (var 1))) id))
          (env (var 1) (cons (lambda (app (var 0) (var 1))) id)))).
auto.
apply
 star_trans1
  with
    (lambda
       (app (lambda (app (var 0) (var 1)))
          (env (var 1) (cons (lambda (app (var 0) (var 1))) id)))).
auto 6.

apply
 star_trans1
  with (lambda (app (lambda (app (var 0) (var 1))) (env (var 0) id))).
auto 6.
apply
 star_trans1
  with (lambda (env (app (var 0) (var 1)) (cons (env (var 0) id) id))). 
auto.
apply
 star_trans1
  with
    (lambda
       (app (env (var 0) (cons (env (var 0) id) id))
          (env (var 1) (cons (env (var 0) id) id)))).
auto 6.
apply
 star_trans1
  with
    (lambda (app (env (var 0) id) (env (var 1) (cons (env (var 0) id) id)))). 
auto 6.
apply star_trans1 with (lambda (app (env (var 0) id) (env (var 0) id))).
auto 6.
apply star_trans1 with (lambda (app (var 0) (env (var 0) id))).
auto 6.
apply star_trans1 with (lambda (app (var 0) (var 0))); auto 6.
Save exemple.

Goal
forall a a' b : terms,
e_relLSLstar _ a a' -> e_relLSLstar _ (app a b) (app a' b).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (app y b); auto.
Save LSLstar_context_app_l.
Hint Resolve LSLstar_context_app_l.

Goal
forall a b b' : terms,
e_relLSLstar _ b b' -> e_relLSLstar _ (app a b) (app a b').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (app a y); auto.
Save LSLstar_context_app_r.
Hint Resolve LSLstar_context_app_r.

Goal
forall a a' b b' : terms,
e_relLSLstar _ a a' ->
e_relLSLstar _ b b' -> e_relLSLstar _ (app a b) (app a' b').
intros; red in |- *.
apply star_trans with (app a' b).
change (e_relLSLstar _ (app a b) (app a' b)) in |- *; auto.
change (e_relLSLstar _ (app a' b) (app a' b')) in |- *; auto.
Save LSLstar_context_app.
Hint Resolve LSLstar_context_app.

Goal
forall a a' : terms,
e_relLSLstar _ a a' -> e_relLSLstar _ (lambda a) (lambda a').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (lambda y); auto.
Save LSLstar_context_lambda.
Hint Resolve LSLstar_context_lambda.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relLSLstar _ a a' -> e_relLSLstar _ (env a s) (env a' s).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (env y s); auto.
Save LSLstar_context_env_t.
Hint Resolve LSLstar_context_env_t.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relLSLstar _ s s' -> e_relLSLstar _ (env a s) (env a s').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (env a y); auto.
Save LSLstar_context_env_s.
Hint Resolve LSLstar_context_env_s.

Goal
forall (a a' : terms) (s s' : sub_explicits),
e_relLSLstar _ a a' ->
e_relLSLstar _ s s' -> e_relLSLstar _ (env a s) (env a' s').
intros; red in |- *.
apply star_trans with (env a' s).
change (e_relLSLstar _ (env a s) (env a' s)) in |- *; auto.
change (e_relLSLstar _ (env a' s) (env a' s')) in |- *; auto.
Save LSLstar_context_env.
Hint Resolve LSLstar_context_env.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relLSLstar _ a a' -> e_relLSLstar _ (cons a s) (cons a' s). 
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (cons y s); auto.
Save LSLstar_context_cons_t.
Hint Resolve LSLstar_context_cons_t.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relLSLstar _ s s' -> e_relLSLstar _ (cons a s) (cons a s'). 
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (cons a y); auto.
Save LSLstar_context_cons_s.
Hint Resolve LSLstar_context_cons_s.

Goal
forall (a a' : terms) (s s' : sub_explicits),
e_relLSLstar _ a a' ->
e_relLSLstar _ s s' -> e_relLSLstar _ (cons a s) (cons a' s').
intros; red in |- *.
apply star_trans with (cons a' s).
change (e_relLSLstar _ (cons a s) (cons a' s)) in |- *; auto.
change (e_relLSLstar _ (cons a' s) (cons a' s')) in |- *; auto.
Save LSLstar_context_cons.
Hint Resolve LSLstar_context_cons.

Goal
forall s s' t : sub_explicits,
e_relLSLstar _ s s' -> e_relLSLstar _ (comp s t) (comp s' t).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (comp y t); auto.
Save LSLstar_context_comp_l.
Hint Resolve LSLstar_context_comp_l.

Goal
forall s t t' : sub_explicits,
e_relLSLstar _ t t' -> e_relLSLstar _ (comp s t) (comp s t').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (comp s y); auto.
Save LSLstar_context_comp_r.
Hint Resolve LSLstar_context_comp_r.

Goal
forall s s' t t' : sub_explicits,
e_relLSLstar _ t t' ->
e_relLSLstar _ s s' -> e_relLSLstar _ (comp s t) (comp s' t').
intros; red in |- *.
apply star_trans with (comp s' t).
change (e_relLSLstar _ (comp s t) (comp s' t)) in |- *; auto.
change (e_relLSLstar _ (comp s' t) (comp s' t')) in |- *; auto.
Save LSLstar_context_comp.
Hint Resolve LSLstar_context_comp.

Goal
forall s s' : sub_explicits,
e_relLSLstar _ s s' -> e_relLSLstar _ (lift s) (lift s').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (lift y); auto.
Save LSLstar_context_lift.
Hint Resolve LSLstar_context_lift. *)

Require Import terminaison_SL.
(* terminaison_SL:
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Gt.
Require Import Minus.
Require Import Mult.
Require Import sur_les_relations.
Require Import TS. 
Require Import sigma_lift.  
Require Import comparith.
Require Import Pol1.
Require Import Pol2.

Section ordre.

Variable A : Set.
Variable f g : A -> nat.

Definition e_lexfg (a b : A) := f a > f b \/ f a = f b /\ g a > g b.

Lemma lexfg_notherian : explicit_noetherian _ e_lexfg. 

End ordre.

Notation lexfg := (e_lexfg _) (only parsing).

Theorem lexfg_systemSL :
 forall (b : wsort) (M N : TS b),
 e_systemSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.
Hint Resolve lexfg_systemSL.
 
Theorem lexfg_app_l :
 forall a a' b : terms,
 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->
 e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a' b).
Hint Resolve lexfg_app_l.

Theorem lexfg_app_r :
 forall a b b' : terms,
 e_lexfg _ (e_P1 wt) (e_P2 wt) b b' ->
 e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a b').
Hint Resolve lexfg_app_r.

Theorem lexfg_lambda :
 forall a a' : terms,
 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->
 e_lexfg _ (e_P1 wt) (e_P2 wt) (lambda a) (lambda a').
Hint Resolve lexfg_lambda.

Theorem lexfg_env_t :
 forall (a a' : terms) (s : sub_explicits),
 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->
 e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a' s).
Hint Resolve lexfg_env_t.

Theorem lexfg_env_s :
 forall (a : terms) (s s' : sub_explicits),
 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->
 e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a s').
Hint Resolve lexfg_env_s.

Theorem lexfg_cons_t :
 forall (a a' : terms) (s : sub_explicits),
 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->
 e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a' s).
Hint Resolve lexfg_cons_t.

Theorem lexfg_cons_s :
 forall (a : terms) (s s' : sub_explicits),
 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->
 e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a s').
Hint Resolve lexfg_cons_s.

Theorem lexfg_comp_l :
 forall s s' t : sub_explicits,
 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->
 e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s' t).
Hint Resolve lexfg_comp_l.

Theorem lexfg_comp_r :
 forall s t t' : sub_explicits,
 e_lexfg _ (e_P1 ws) (e_P2 ws) t t' ->
 e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s t').
Hint Resolve lexfg_comp_r.

Theorem lexfg_lift :
 forall s s' : sub_explicits,
 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->
 e_lexfg _ (e_P1 ws) (e_P2 ws) (lift s) (lift s').
Hint Resolve lexfg_lift.

Theorem lexfg_relSL :
 forall (b : wsort) (M N : TS b),
 e_relSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.

Theorem relSL_noetherian :
 forall b : wsort, explicit_noetherian _ (e_relSL b). *)

Require Import conf_local_SL.
(* conf_local_SL:
Require Import TS.
Require Import sur_les_relations.
Require Import sigma_lift.
Require Import determinePC_SL.
Require Import resoudPC_SL.

Definition e_local1 (b : wsort) (x y : TS b) :=
  forall z : TS b,
  e_relSL _ x z -> exists u : TS b, e_relSLstar _ y u /\ e_relSLstar _ z u.

Notation local1 := (e_local1 _) (only parsing).

Goal forall x y : terms, reg_app x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a b0 s z H0.
pattern s, z in |- *; apply case_SL_reg_app with a b0; auto.
exists (app (env a s) (env b0 s)); auto.
Save local_app.
Hint Resolve local_app.

Goal forall x y : terms, reg_lambda x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a s z H0.
pattern s, z in |- *; apply case_SL_reg_lambda with a; auto.
exists (lambda (env a (lift s))); auto.
Save local_lambda.
Hint Resolve local_lambda.

Goal forall x y : terms, reg_clos x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a s t z H0.
pattern t, z in |- *; apply case_SL_clos with a s; auto.
exists (env a (comp s t)); auto.
Save local_clos.
Hint Resolve local_clos.

Goal forall x y : terms, reg_varshift1 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros n z H0.
pattern z in |- *; apply case_SL_varshift1 with n; auto.
exists (var (S n)); auto.
Save local_varshift1.
Hint Resolve local_varshift1.

Goal forall x y : terms, reg_varshift2 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros n s z H0.
pattern z in |- *; apply case_SL_varshift2 with n s; auto.
exists (env (var (S n)) s); auto.
Save local_varshift2.
Hint Resolve local_varshift2.

Goal forall x y : terms, reg_fvarcons x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a s z H0.
pattern z in |- *; apply case_SL_fvarcons with a s; intros.
3: assumption.
exists a; auto.
apply PC_fvarcons_ctxt_r with s; assumption.
Save local_fvarcons.
Hint Resolve local_fvarcons.

Goal forall x y : terms, reg_fvarlift1 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern z in |- *; apply case_SL_fvarlift1 with s; intros.
3: assumption.
exists (var 0); auto.
apply PC_fvarlift1_ctxt_r' with s; assumption.
Save local_fvarlift1.
Hint Resolve local_fvarlift1.

Goal forall x y : terms, reg_fvarlift2 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s t z H0.
pattern z in |- *; apply case_SL_fvarlift2 with s t; intros.
3: assumption.
exists (env (var 0) t); auto.
apply PC_fvarlift2_ctxt_r with s; assumption.
Save local_fvarlift2.
Hint Resolve local_fvarlift2.

Goal forall x y : terms, reg_rvarcons x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros n a s z H0.
pattern z in |- *; apply case_SL_rvarcons with n a s; intros.
3: assumption.
exists (env (var n) s); auto.
apply PC_rvarcons_ctxt_r with a; assumption.
Save local_rvarcons.
Hint Resolve local_rvarcons.

Goal forall x y : terms, reg_rvarlift1 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros n s z H0.
pattern z in |- *; apply case_SL_rvarlift1 with n s; auto.
exists (env (var n) (comp s shift)); auto.
Save local_rvarlift1.
Hint Resolve local_rvarlift1.

Goal forall x y : terms, reg_rvarlift2 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros n s t z H0.
pattern z in |- *; apply case_SL_rvarlift2 with n s t; auto.
exists (env (var n) (comp s (comp shift t))); auto.
Save local_rvarlift2.
Hint Resolve local_rvarlift2.

Goal forall x y : sub_explicits, reg_assenv x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s t u z H0.
pattern u, z in |- *; apply case_SL_assenv with s t; auto.
exists (comp s (comp t u)); auto.
Save local_assenv.
Hint Resolve local_assenv.

Goal forall x y : sub_explicits, reg_mapenv x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a s t z H0.
pattern t, z in |- *; apply case_SL_mapenv with a s; auto.
exists (cons (env a t) (comp s t)); auto.
Save local_mapenv.
Hint Resolve local_mapenv.

Goal forall x y : sub_explicits, reg_shiftcons x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a s z H0.
pattern z in |- *; apply case_SL_shiftcons with a s; intros.
3: assumption.
exists s; auto.
apply PC_shiftcons_ctxt_r with a; assumption.
Save local_shiftcons.
Hint Resolve local_shiftcons.

Goal forall x y : sub_explicits, reg_shiftlift1 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern z in |- *; apply case_SL_shiflift1 with s; auto.
exists (comp s shift); auto.
Save local_shiftlift1.
Hint Resolve local_shiftlift1.

Goal forall x y : sub_explicits, reg_shiftlift2 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s t z H0.
pattern z in |- *; apply case_SL_shiflift2 with s t; auto.
exists (comp s (comp shift t)); auto.
Save local_shiftlift2.
Hint Resolve local_shiftlift2.

Goal forall x y : sub_explicits, reg_lift1 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s t z H0.
pattern z in |- *; apply case_SL_lift1 with s t; auto.
exists (lift (comp s t)); auto.
Save local_lift1.
Hint Resolve local_lift1.

Goal forall x y : sub_explicits, reg_lift2 x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s t u z H0.
pattern z in |- *; apply case_SL_lift2 with s t u; auto.
exists (comp (lift (comp s t)) u); auto.
Save local_lift2.
Hint Resolve local_lift2.

Goal forall x y : sub_explicits, reg_liftenv x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a s t z H0.
pattern z in |- *; apply case_SL_liftenv with a s t; auto.
exists (cons a (comp s t)); auto.
Save local_liftenv.
Hint Resolve local_liftenv.

Goal forall x y : sub_explicits, reg_idl x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern s, z in |- *; apply case_SL_idl; auto.
exists s; auto.
Save local_idl.
Hint Resolve local_idl.

Goal forall x y : sub_explicits, reg_idr x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros s z H0.
apply Ex_PQ; pattern s, z in |- *; apply case_SL_idr; auto.
exists s; auto.
Save local_idr.
Hint Resolve local_idr.

Goal forall x y : sub_explicits, reg_liftid x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros z H0.
pattern z in |- *; apply case_SL_liftid; auto.
Save local_liftid.
Hint Resolve local_liftid.

Goal forall x y : terms, reg_id x y -> e_local1 _ x y.
simple induction 1; red in |- *; intros a z H0.
apply Ex_PQ; pattern a, z in |- *; apply case_SL_reg_id; auto.
exists a; auto 6.
Save local_id.
Hint Resolve local_id.

Goal forall (b : wsort) (x y : TS b), e_systemSL _ x y -> e_local1 _ x y.
simple induction 1; auto.
Save local_systemSL.

Goal forall (b : wsort) (x y : TS b), e_relSL _ x y -> e_local1 _ x y.
simple induction 1.

intros; apply local_systemSL; assumption.

red in |- *; intros a a' b0 H0 H1 z H2.
pattern z in |- *; apply case_SLapp with a b0.
3: assumption.
intros a'' H3; elim (H1 a'' H3); intros a_ H4.
elim H4; intros H5 H6.
exists (app a_ b0); auto.
intros b0' H3; exists (app a' b0'); auto.

red in |- *; intros a b0 b0' H0 H1 z H2.
pattern z in |- *; apply case_SLapp with a b0.
3: assumption.
intros a' H3; exists (app a' b0'); auto.
intros b0'' H3; elim (H1 b0'' H3); intros b0_ H4.
elim H4; intros H5 H6.
exists (app a b0_); auto.

red in |- *; intros a a' H0 H1 z H2.
pattern z in |- *; apply case_SLlambda with a.
2: assumption.
intros a'' H3; elim (H1 a'' H3); intros a_ H4; elim H4; intros H5 H6.
exists (lambda a_); auto.

red in |- *; intros a a' s H0 H1 z H2.
apply Ex_PQ; generalize H0; pattern a, s, z in |- *; apply case_SLenv; auto.
intros n H3; elim (case_SLvar n a' H3).
intros n s1 H3; elim (case_SLvar n a' H3).
intros a1 s1 H3; elim (case_SLvar 0 a' H3).
intros s1 H3; elim (case_SLvar 0 a' H3).
intros s1 s2 H3; elim (case_SLvar 0 a' H3).
intros n a1 s1 H3; elim (case_SLvar (S n) a' H3).
intros n s1 H3; elim (case_SLvar (S n) a' H3).
intros n s1 s2 H3; elim (case_SLvar (S n) a' H3).
intros a'' H3 H4; elim (H1 a'' H3); intros a_ H5; elim H5; intros H6 H7.
exists (env a_ s); auto.
intros s' H3 H4; exists (env a' s'); auto.

red in |- *; intros a s s' H0 H1 z H2.
apply Ex_PQ; generalize H0; pattern a, s, z in |- *; apply case_SLenv; auto.
intros n H3; elim (case_SLshift s' H3).
intros; apply PC_fvarcons_ctxt_r with s1; assumption.
intros; apply PC_fvarlift1_ctxt_r' with s1; assumption.
intros; apply PC_fvarlift2_ctxt_r with s1; assumption.
intros; apply PC_rvarcons_ctxt_r with a1; assumption.
intro H3; elim (case_SLid s' H3).
intros a' H3 H4; exists (env a' s'); auto.
intros s'' H3 H4; elim (H1 s'' H3); intros s_ H5; elim H5; intros H6 H7.
exists (env a s_); auto.

red in |- *; intros a a' s H0 H1 z H2.
pattern z in |- *; apply case_SLcons with a s; auto.
intros a'' H3; elim (H1 a'' H3); intros a_ H4; elim H4; intros H5 H6.
exists (cons a_ s); auto.
intros s' H3; exists (cons a' s'); auto.

red in |- *; intros a s s' H0 H1 z H2.
pattern z in |- *; apply case_SLcons with a s; auto.
intros a' H3; exists (cons a' s'); auto.
intros s'' H3; elim (H1 s'' H3); intros s_ H4; elim H4; intros H5 H6.
exists (cons a s_); auto.

red in |- *; intros s s' t H0 H1 z H2.
apply Ex_PQ; generalize H0; pattern s, t, z in |- *; apply case_SLcomp; auto.
intros a t1 H3; elim (case_SLshift s' H3).
intros t1 H3; elim (case_SLshift s' H3).
intros t1 t2 H3; elim (case_SLshift s' H3).
intro H3; elim (case_SLid s' H3).
intros s'' H3; elim (H1 s'' H3); intros s_ H4; elim H4; intros H5 H6.
exists (comp s_ t); auto.
intros t' H3; exists (comp s' t'); auto.

red in |- *; intros s t t' H0 H1 z H2.
apply Ex_PQ; generalize H0; pattern s, t, z in |- *; apply case_SLcomp; auto.
intros; apply PC_shiftcons_ctxt_r with a; assumption.
intro H3; elim (case_SLid t' H3).
intros s' H3; exists (comp s' t'); auto.
intros t'' H3; elim (H1 t'' H3); intros t_ H4; elim H4; intros H5 H6.
exists (comp s t_); auto.

red in |- *; intros s s' H0 H1 z H2.
generalize H0; pattern s, z in |- *; apply case_SLlift.
3: assumption.
intro H3; elim (case_SLid s' H3).
intros s'' H3; elim (H1 s'' H3); intros s_ H4; elim H4; intros H5 H6.
exists (lift s_); auto.
Save local_relSL.

Theorem conf_local_SL :
 forall b : wsort, explicit_local_confluence _ (e_relSL b). *)

Require Import betapar.

Require Import SLstar_bpar_SLstar.
(* SLstar_bpar_SLstar:
Require Import TS.
Require Import sur_les_relations.
Require Import sigma_lift.
Require Import lambda_sigma_lift.
Require Import betapar.

Definition e_slstar_bp_slstar (b : wsort) :=
  explicit_comp_rel _ (e_relSLstar b)
    (explicit_comp_rel _ (e_beta_par b) (e_relSLstar b)).

Notation slstar_bp_slstar := (e_slstar_bp_slstar _) (only parsing).

Hint Unfold e_slstar_bp_slstar.

Goal
forall a a' b b' : terms,
e_beta_par _ b b' ->
e_slstar_bp_slstar _ a a' -> e_slstar_bp_slstar _ (app a b) (app a' b').
simple induction 2; intros.
red in |- *; apply comp_2rel with (app y b).
auto.
elim H2; intros.
apply comp_2rel with (app y0 b'); auto.
Save slbpsl_context_app_l.
Hint Resolve slbpsl_context_app_l.

Goal
forall a a' b b' : terms,
e_beta_par _ a a' ->
e_slstar_bp_slstar _ b b' -> e_slstar_bp_slstar _ (app a b) (app a' b').
simple induction 2; intros.
red in |- *; apply comp_2rel with (app a y).
auto.
elim H2; intros.
apply comp_2rel with (app a' y0); auto.
Save slbpsl_context_app_r.
Hint Resolve slbpsl_context_app_r.

Goal
forall a b a' b' : terms,
e_beta_par _ b b' ->
e_slstar_bp_slstar _ a a' ->
e_slstar_bp_slstar _ (app (lambda a) b) (env a' (cons b' id)).
simple induction 2; intros.
red in |- *; apply comp_2rel with (app (lambda y) b).
auto.
elim H2; intros.
apply comp_2rel with (env y0 (cons b' id)); auto.
Save slbpsl_context_beta_l.
Hint Resolve slbpsl_context_beta_l.

Goal
forall a b a' b' : terms,
e_beta_par _ a a' ->
e_slstar_bp_slstar _ b b' ->
e_slstar_bp_slstar _ (app (lambda a) b) (env a' (cons b' id)).
simple induction 2; intros.
red in |- *; apply comp_2rel with (app (lambda a) y).
auto.
elim H2; intros.
apply comp_2rel with (env a' (cons y0 id)); auto.
Save slbpsl_context_beta_r.
Hint Resolve slbpsl_context_beta_r.

Goal
forall a a' : terms,
e_slstar_bp_slstar _ a a' -> e_slstar_bp_slstar _ (lambda a) (lambda a').
simple induction 1; intros.
red in |- *; apply comp_2rel with (lambda y).
auto.
elim H1; intros.
apply comp_2rel with (lambda y0); auto.
Save slbpsl_context_lambda.
Hint Resolve slbpsl_context_lambda.

Goal
forall (a a' : terms) (s s' : sub_explicits),
e_beta_par _ s s' ->
e_slstar_bp_slstar _ a a' -> e_slstar_bp_slstar _ (env a s) (env a' s').
simple induction 2; intros.
red in |- *; apply comp_2rel with (env y s).
auto.
elim H2; intros.
apply comp_2rel with (env y0 s'); auto.
Save slbpsl_context_env_t.
Hint Resolve slbpsl_context_env_t.

Goal
forall (a a' : terms) (s s' : sub_explicits),
e_beta_par _ a a' ->
e_slstar_bp_slstar _ s s' -> e_slstar_bp_slstar _ (env a s) (env a' s').
simple induction 2; intros.
red in |- *; apply comp_2rel with (env a y).
auto.
elim H2; intros.
apply comp_2rel with (env a' y0); auto.
Save slbpsl_context_env_s.
Hint Resolve slbpsl_context_env_s.

Goal
forall (a a' : terms) (s s' : sub_explicits),
e_beta_par _ s s' ->
e_slstar_bp_slstar _ a a' -> e_slstar_bp_slstar _ (cons a s) (cons a' s').
simple induction 2; intros.
red in |- *; apply comp_2rel with (cons y s).
auto.
elim H2; intros.
apply comp_2rel with (cons y0 s'); auto.
Save slbpsl_context_cons_t.
Hint Resolve slbpsl_context_cons_t.

Goal
forall (a a' : terms) (s s' : sub_explicits),
e_beta_par _ a a' ->
e_slstar_bp_slstar _ s s' -> e_slstar_bp_slstar _ (cons a s) (cons a' s').
simple induction 2; intros.
red in |- *; apply comp_2rel with (cons a y).
auto.
elim H2; intros.
apply comp_2rel with (cons a' y0); auto.
Save slbpsl_context_cons_s.
Hint Resolve slbpsl_context_cons_s.

Goal
forall s s' t t' : sub_explicits,
e_beta_par _ t t' ->
e_slstar_bp_slstar _ s s' -> e_slstar_bp_slstar _ (comp s t) (comp s' t').
simple induction 2; intros.
red in |- *; apply comp_2rel with (comp y t).
auto.
elim H2; intros.
apply comp_2rel with (comp y0 t'); auto.
Save slbpsl_context_comp_l.
Hint Resolve slbpsl_context_comp_l.

Goal
forall s s' t t' : sub_explicits,
e_beta_par _ s s' ->
e_slstar_bp_slstar _ t t' -> e_slstar_bp_slstar _ (comp s t) (comp s' t').
simple induction 2; intros.
red in |- *; apply comp_2rel with (comp s y).
auto.
elim H2; intros.
apply comp_2rel with (comp s' y0); auto.
Save slbpsl_context_comp_r.
Hint Resolve slbpsl_context_comp_r.

Goal
forall s s' : sub_explicits,
e_slstar_bp_slstar _ s s' -> e_slstar_bp_slstar _ (lift s) (lift s').
simple induction 1; intros.
red in |- *; apply comp_2rel with (lift y).
auto.
elim H1; intros.
apply comp_2rel with (lift y0); auto.
Save slbpsl_context_lift.
Hint Resolve slbpsl_context_lift.

Goal
forall (b : wsort) (M N : TS b), e_beta_par _ M N -> e_slstar_bp_slstar _ M N.
intros; red in |- *; apply comp_2rel with M.
red in |- *; auto.
apply comp_2rel with N; auto.
Save betapar_slbpsl.
Hint Resolve betapar_slbpsl.

Goal forall (b : wsort) (M : TS b), e_slstar_bp_slstar _ M M.
auto.
Save refl_slbpsl.
Hint Resolve refl_slbpsl.

Goal forall b : wsort, explicit_inclus _ (e_relLSL b) (e_slstar_bp_slstar b).
red in |- *; simple induction 1; auto.
simple induction 1; auto.
 
simple induction 1; auto.
intros b1 M0 N0 H1; red in |- *; apply comp_2rel with N0.
auto. 
apply comp_2rel with N0; auto.
Save relLSL_inclus_slbpsl.
Hint Resolve relLSL_inclus_slbpsl.

Goal forall b : wsort, explicit_inclus _ (e_beta_par b) (e_relLSLstar b).
red in |- *; simple induction 1; intros; auto.

red in |- *; apply star_trans1 with (env M (cons N id)).
auto.
change (e_relLSLstar _ (env M (cons N id)) (env M' (cons N' id))) in |- *;
 auto.
Save betapar_inclus_relSLstar.
Hint Resolve betapar_inclus_relSLstar.

Goal forall b : wsort, explicit_inclus _ (e_relSL b) (e_relLSL b).
red in |- *; simple induction 1; auto.
Save relSL_inclus_relLSL.
Hint Resolve relSL_inclus_relLSL.

Goal
forall b : wsort, explicit_inclus _ (e_slstar_bp_slstar b) (e_relLSLstar b).

unfold e_slstar_bp_slstar in |- *; intro b.
apply inclus_comp.

change
  (explicit_inclus _ (explicit_star _ (e_relSL b))
     (explicit_star _ (e_relLSL b))) in |- *; auto.
apply inclus_comp.

auto.

change
  (explicit_inclus _ (explicit_star _ (e_relSL b))
     (explicit_star _ (e_relLSL b))) in |- *; auto.
intros; red in |- *; apply star_trans with y; assumption.
intros; red in |- *; apply star_trans with y; assumption.
Save slbpsl_inclus_relLSLstar.
Hint Resolve slbpsl_inclus_relLSLstar. *)

Require Import conf_strong_betapar.
(* conf_strong_betapar:
Require Import TS.
Require Import sur_les_relations.
Require Import betapar.
Require Import egaliteTS.

Definition sconf (b : wsort) (N N' : TS b) :=
  forall z : TS b,
  e_beta_par _ N z -> exists u : TS b, e_beta_par _ N' u /\ e_beta_par _ z u.

Goal forall M M' : terms, sconf wt (lambda M) (lambda M') -> sconf wt M M'.
unfold sconf in |- *; intros M M' H z H0.
elim (H (lambda z)).
2: auto.
intros M_ H1; elim H1; intros H2 H3.
cut (M_ = M_).
2: trivial.
pattern M_ at 1 in |- *; apply case_blambda with M'.
2: assumption.
intros u1 H4.
pattern M_ in |- *; apply case_blambda with z.
2: assumption.
intros u2 H5 H6.
exists u1; split.
assumption.
rewrite (proj_lambda u1 u2 H6); assumption.
Save sconf_lambda_bpar.

Theorem sconf_betapar :
 forall b : wsort, explicit_strong_confluence _ (e_beta_par b). *)

Require Import commutation.
(* commutation:
Require Import sur_les_relations.
Require Import TS.
Require Import egaliteTS.
Require Import sigma_lift.
Require Import betapar.
Require Import SLstar_bpar_SLstar.
Require Import determinePC_SL.

Definition e_diag1 (b : wsort) (x y : TS b) :=
  forall z : TS b,
  e_beta_par _ x z ->
  exists u : TS b, e_slstar_bp_slstar _ y u /\ e_relSLstar _ z u.

Notation diag1 := (e_diag1 _) (only parsing).

Goal forall x y : terms, reg_app x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a b0 s z H0.
pattern z in |- *; apply case_benv with (app a b0) s.
2: assumption.
intros x' s' H1 H2; pattern x' in |- *; apply case_bapp with a b0.
3: assumption.

intros a' b0' H3 H4; exists (app (env a' s') (env b0' s')); auto 6.
 
intros a1 a1' b0' H3 H4 H5; rewrite H3.
exists (env a1' (cons (env b0' s') s')); split.
 
red in |- *; apply comp_2rel with (app (lambda (env a1 (lift s))) (env b0 s)).
    
auto 6.
   
apply comp_2rel with (env (env a1' (lift s')) (cons (env b0' s') id)).
auto.
   
red in |- *;
 apply star_trans1 with (env a1' (comp (lift s') (cons (env b0' s') id))).
auto.
apply star_trans1 with (env a1' (cons (env b0' s') (comp s' id))); auto 6.
 
red in |- *; apply star_trans1 with (env a1' (comp (cons b0' id) s')).
auto.
apply star_trans1 with (env a1' (cons (env b0' s') (comp id s'))); auto 6.
Save commut_app.
Hint Resolve commut_app.

Goal forall x y : terms, reg_lambda x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a s z H0.
pattern z in |- *; apply case_benv with (lambda a) s.
2: assumption.
intros x' s' H1 H2; pattern x' in |- *; apply case_blambda with a.
2: assumption.
intros a' H3; exists (lambda (env a' (lift s'))); auto 6.

Save commut_lambda.
Hint Resolve commut_lambda.

Goal forall x y : terms, reg_clos x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a s t z H0.
pattern z in |- *; apply case_benv with (env a s) t.
2: assumption.
intros x' t' H1 H2; pattern x' in |- *; apply case_benv with a s.
2: assumption.
intros a' s' H3 H4; exists (env a' (comp s' t')); auto 6.

Save commut_clos.
Hint Resolve commut_clos.

Goal forall x y : terms, reg_varshift1 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros n z H0.
pattern z in |- *; apply case_benv with (var n) shift.
2: assumption.
intros x' s' H1 H2; pattern x' in |- *; apply case_bvar with n.
2: assumption.
pattern s' in |- *; apply case_bshift.
2: assumption.
exists (var (S n)); auto 6.

Save commut_varshift1.
Hint Resolve commut_varshift1.

Goal forall x y : terms, reg_varshift2 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros n s z H0.
pattern z in |- *; apply case_benv with (var n) (comp shift s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with n.
2: assumption.
pattern y' in |- *; apply case_bcomp with shift s.
2: assumption.
intros t' s' H3 H4; pattern t' in |- *; apply case_bshift.
2: assumption.
exists (env (var (S n)) s'); auto 6.

Save commut_varshift2.
Hint Resolve commut_varshift2.

Goal forall x y : terms, reg_fvarcons x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a s z H0.
pattern z in |- *; apply case_benv with (var 0) (cons a s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with 0.
2: assumption.
pattern y' in |- *; apply case_bcons with a s.
2: assumption.
intros a' s' H3 H4; exists a'; auto 6.

Save commut_fvarcons.
Hint Resolve commut_fvarcons.

Goal forall x y : terms, reg_fvarlift1 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern z in |- *; apply case_benv with (var 0) (lift s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with 0.
2: assumption.
pattern y' in |- *; apply case_blift with s.
2: assumption.
intros s' H3; exists (var 0); auto 6.

Save commut_fvarlift1.
Hint Resolve commut_fvarlift1.

Goal forall x y : terms, reg_fvarlift2 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s t z H0.
pattern z in |- *; apply case_benv with (var 0) (comp (lift s) t).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with 0.
2: assumption.
pattern y' in |- *; apply case_bcomp with (lift s) t.
2: assumption.
intros z' t' H3 H4; pattern z' in |- *; apply case_blift with s.
2: assumption.
intros s' H5; exists (env (var 0) t'); auto 6.

Save commut_fvarlift2.
Hint Resolve commut_fvarlift2.

Goal forall x y : terms, reg_rvarcons x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros n a s z H0.
pattern z in |- *; apply case_benv with (var (S n)) (cons a s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with (S n).
2: assumption.
pattern y' in |- *; apply case_bcons with a s.
2: assumption.
intros a' s' H3 H4; exists (env (var n) s'); auto 6.

Save commut_rvarcons.
Hint Resolve commut_rvarcons.

Goal forall x y : terms, reg_rvarlift1 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros n s z H0.
pattern z in |- *; apply case_benv with (var (S n)) (lift s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with (S n).
2: assumption.
pattern y' in |- *; apply case_blift with s.
2: assumption.
intros s' H3; exists (env (var n) (comp s' shift)); auto 6.

Save commut_rvarlift1.
Hint Resolve commut_rvarlift1.

Goal forall x y : terms, reg_rvarlift2 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros n s t z H0.
pattern z in |- *; apply case_benv with (var (S n)) (comp (lift s) t).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bvar with (S n).
2: assumption.
pattern y' in |- *; apply case_bcomp with (lift s) t.
2: assumption.
intros z' t' H3 H4; pattern z' in |- *; apply case_blift with s.
2: assumption.
intros s' H5; exists (env (var n) (comp s' (comp shift t'))); auto 6.

Save commut_rvarlift2.
Hint Resolve commut_rvarlift2.

Goal forall x y : sub_explicits, reg_assenv x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s t u z H0.
pattern z in |- *; apply case_bcomp with (comp s t) u.
2: assumption.
intros x' u' H1 H2; pattern x' in |- *; apply case_bcomp with s t.
2: assumption.
intros s' t' H3 H4; exists (comp s' (comp t' u')); auto 6.

Save commut_assenv.
Hint Resolve commut_assenv.

Goal forall x y : sub_explicits, reg_mapenv x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a s t z H0.
pattern z in |- *; apply case_bcomp with (cons a s) t.
2: assumption.
intros x' t' H1 H2; pattern x' in |- *; apply case_bcons with a s.
2: assumption.
intros a' s' H3 H4; exists (cons (env a' t') (comp s' t')); auto 6.

Save commut_mapenv.
Hint Resolve commut_mapenv.

Goal forall x y : sub_explicits, reg_shiftcons x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a s z H0.
pattern z in |- *; apply case_bcomp with shift (cons a s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bshift.
2: assumption.
pattern y' in |- *; apply case_bcons with a s.
2: assumption.
intros a' s' H3 H4; exists s'; auto 6.

Save commut_shiftcons.
Hint Resolve commut_shiftcons.

Goal forall x y : sub_explicits, reg_shiftlift1 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern z in |- *; apply case_bcomp with shift (lift s).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bshift.
2: assumption.
pattern y' in |- *; apply case_blift with s.
2: assumption.
intros s' H3; exists (comp s' shift); auto 6.

Save commut_shiftlift1.
Hint Resolve commut_shiftlift1.

Goal forall x y : sub_explicits, reg_shiftlift2 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s t z H0.
pattern z in |- *; apply case_bcomp with shift (comp (lift s) t).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_bshift.
2: assumption.
pattern y' in |- *; apply case_bcomp with (lift s) t.
2: assumption.
intros z' t' H3 H4; pattern z' in |- *; apply case_blift with s.
2: assumption.
intros s' H5; exists (comp s' (comp shift t')); auto 6.

Save commut_shiftlift2.
Hint Resolve commut_shiftlift2.

Goal forall x y : sub_explicits, reg_lift1 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s t z H0.
pattern z in |- *; apply case_bcomp with (lift s) (lift t).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_blift with s.
2: assumption.
intros s' H3; pattern y' in |- *; apply case_blift with t.
2: assumption.
intros t' H4; exists (lift (comp s' t')); auto 6.

Save commut_lift1.
Hint Resolve commut_lift1.

Goal forall x y : sub_explicits, reg_lift2 x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s t u z H0.
pattern z in |- *; apply case_bcomp with (lift s) (comp (lift t) u).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_blift with s.
2: assumption.
intros s' H3; pattern y' in |- *; apply case_bcomp with (lift t) u.
2: assumption.
intros z' u' H4 H5; pattern z' in |- *; apply case_blift with t.
2: assumption.
intros t' H6; exists (comp (lift (comp s' t')) u'); auto 6.
 
Save commut_lift2.
Hint Resolve commut_lift2.

Goal forall x y : sub_explicits, reg_liftenv x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a s t z H0.
pattern z in |- *; apply case_bcomp with (lift s) (cons a t).
2: assumption.
intros x' y' H1 H2; pattern x' in |- *; apply case_blift with s.
2: assumption.
intros s' H3; pattern y' in |- *; apply case_bcons with a t.
2: assumption.
intros a' t' H4 H5; exists (cons a' (comp s' t')); auto 6.

Save commut_liftenv.
Hint Resolve commut_liftenv.

Goal forall x y : sub_explicits, reg_idl x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern z in |- *; apply case_bcomp with id s.
2: assumption.
intros x' s' H1 H2; pattern x' in |- *; apply case_bid.
2: assumption.
exists s'; auto 6.

Save commut_idl.
Hint Resolve commut_idl.

Goal forall x y : sub_explicits, reg_idr x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros s z H0.
pattern z in |- *; apply case_bcomp with s id.
2: assumption.
intros s' x' H1 H2; pattern x' in |- *; apply case_bid.
2: assumption.
exists s'; auto 6.

Save commut_idr.
Hint Resolve commut_idr.

Goal forall x y : sub_explicits, reg_liftid x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros z H0.
pattern z in |- *; apply case_blift with id.
2: assumption.
intros x' H1; pattern x' in |- *; apply case_bid.
2: assumption.
exists id; auto 6.

Save commut_liftid.
Hint Resolve commut_liftid.

Goal forall x y : terms, reg_id x y -> e_diag1 _ x y.
simple induction 1; red in |- *; intros a z H0.
pattern z in |- *; apply case_benv with a id.
2: assumption.
intros a' x' H1 H2; pattern x' in |- *; apply case_bid.
2: assumption.
exists a'; auto 6.

Save commut_id.
Hint Resolve commut_id.
 
Goal forall (b : wsort) (x y : TS b), e_systemSL _ x y -> e_diag1 _ x y.
simple induction 1; intros; auto.
Save commut_systemSL.

Goal
forall (P : terms -> Prop) (a : terms),
(forall a' : terms, e_relSLstar _ a a' -> P (lambda a')) ->
forall M N : terms, e_relSLstar _ N M -> N = lambda a -> P M.
intros P a H M N H0; generalize a H; elim H0.
intros x a0 H1 H2; rewrite H2; apply (H1 a0); red in |- *; apply star_refl.
intros x y z H1 H2 H3 a0 H4 H5; generalize H1; rewrite H5; intro H6.
cut (y = y).
2: trivial.
pattern y at 2 in |- *; apply case_SLlambda with a0.
2: assumption.
intros a0' H7 H8; apply (H3 a0').
intros a' H9; apply H4; red in |- *; apply star_trans1 with a0'; assumption.
assumption.
Save case_SLstar_lambda'.

Goal
forall (P : terms -> Prop) (a : terms),
(forall a' : terms, e_relSLstar _ a a' -> P (lambda a')) ->
forall M : terms, e_relSLstar _ (lambda a) M -> P M.
intros; pattern M in |- *; apply case_SLstar_lambda' with a (lambda a);
 auto 6.
Save case_SLstar_lambda.

Goal
forall (P : terms -> Prop) (a : terms),
(forall a' : terms, e_slstar_bp_slstar _ a a' -> P (lambda a')) ->
forall M : terms, e_slstar_bp_slstar _ (lambda a) M -> P M.
intros P a H M H0.
elim
 (comp_case terms (e_relSLstar wt)
    (explicit_comp_rel _ (e_beta_par wt) (e_relSLstar wt)) 
    (lambda a) M H0).
intros x H1; elim H1; intros H2.
pattern x in |- *; apply case_SLstar_lambda with a.
2: assumption.
intros a' H3 H4.
elim (comp_case terms (e_beta_par wt) (e_relSLstar wt) (lambda a') M H4).
intros y H5; elim H5; intros H6.
pattern y in |- *; apply case_blambda with a'.
2: assumption.
intros a'' H7 H8.
pattern M in |- *; apply case_SLstar_lambda with a''.
2: assumption.
intros a_ H9; apply H.
red in |- *; apply comp_2rel with a'.
assumption.
apply comp_2rel with a''; assumption.
Save case_slbpsl_lambda.

Goal forall a a' : terms, e_diag1 _ (lambda a) (lambda a') -> e_diag1 _ a a'.
red in |- *; intros a a' H z H0.
elim (H (lambda z)).
2: apply lambda_bpar; assumption.
intros u1 H1; elim H1; intros H2 H3.
cut (u1 = u1).
2: trivial.
pattern u1 at 1 in |- *; apply case_SLstar_lambda with z.
2: assumption.
intros z' H4; pattern u1 in |- *; apply case_slbpsl_lambda with a'.
2: assumption.
intros a'' H5 H6; exists a''; split.
assumption.
elim (proj_lambda z' a'' H6); assumption.
Save diag1_lambda.

Theorem commut :
 forall (b : wsort) (x y : TS b), e_relSL _ x y -> e_diag1 _ x y.

Theorem commutation :
 forall (b : wsort) (x y z : TS b),
 e_relSL _ x y ->
 e_beta_par _ x z ->
 exists u : TS b, e_relSLstar _ z u /\ e_slstar_bp_slstar _ y u. *)

Require Import Newman.
(* Newman:
Require Import sur_les_relations.

Section NewmanS.
 Variable A : Set.
 Variable R : A -> A -> Prop.
 Hypothesis N : explicit_noetherian _ R.
 Hypothesis C : explicit_local_confluence _ R.

   Theorem Newman : explicit_confluence _ R.
End NewmanS. *)

Require Import Yokouchi.
(* Yokouchi:
Require Import sur_les_relations.

Section YokouchiS.
 Variable A : Set.
 Variable R S : A -> A -> Prop.
 Hypothesis C : explicit_confluence _ R.
 Hypothesis N : explicit_noetherian _ R.
 Hypothesis SC : explicit_strong_confluence _ S.
 Definition Rstar_S_Rstar :=
   explicit_comp_rel _ (explicit_star _ R)
     (explicit_comp_rel _ S (explicit_star _ R)).
 Hypothesis
   commut1 :
     forall f g h : A,
     R f h ->
     S f g -> exists k : A, explicit_star _ R g k /\ Rstar_S_Rstar h k.

   Goal
forall f g h : A,
explicit_star _ R f g -> Rstar_S_Rstar g h -> Rstar_S_Rstar f h.
   intros f g h H1 H2.
   elim
    (comp_case A (explicit_star _ R)
       (explicit_comp_rel _ S (explicit_star _ R)) g h H2).
   intros f' H3; elim H3; intros H4 H5.
   red in |- *; apply comp_2rel with f'.
   apply star_trans with g; assumption.
   assumption.
   Save comp_l.

   Goal
forall f g h : A,
Rstar_S_Rstar f g -> explicit_star _ R g h -> Rstar_S_Rstar f h.
   intros f g h H1 H2.
   elim
    (comp_case A (explicit_star _ R)
       (explicit_comp_rel _ S (explicit_star _ R)) f g H1).
   intros f' H3; elim H3; intros H4 H5.
   elim (comp_case A S (explicit_star _ R) f' g H5).
   intros f'' H6; elim H6; intros H7 H8.
   red in |- *; apply comp_2rel with f'.
   assumption.
   apply comp_2rel with f''.
   assumption.
   apply star_trans with g; assumption.
   Save comp_r.

   Goal
forall f g h : A,
explicit_star _ R f h ->
S f g -> exists k : A, explicit_star _ R g k /\ Rstar_S_Rstar h k.
   intro f; pattern f in |- *; apply (noetherian_induction A R N);
    intros f0 H g h H1 H2.
   elim (star_case A R f0 h H1); intro H3.
   
   exists g; split. 
   apply star_refl.
   elim H3; red in |- *; apply comp_2rel with f0.
   apply star_refl.
   apply comp_2rel with g; [ assumption | apply star_refl ].
   
   elim H3; intros f1 H4; elim H4; intros H5 H6. 
   cut (exists k : A, explicit_star _ R g k /\ Rstar_S_Rstar f1 k).
   intro H7; elim H7; intros g1 H8; elim H8; intros H9 H10.
   2: apply commut1 with f0; assumption.
   cut
    (exists f2 : A,
       explicit_star _ R f1 f2 /\
       explicit_comp_rel _ S (explicit_star _ R) f2 g1).
   2: apply comp_case; assumption.
   intro H11; elim H11; intros f2 H12; elim H12; intros H13 H14.
   cut (exists f3 : A, S f2 f3 /\ explicit_star _ R f3 g1).
   2: apply comp_case; assumption.
   intro H15; elim H15; intros f3 H16; elim H16; intros H17 H18.
   elim (C f1 h f2 H6 H13); intros h1 H19; elim H19; intros H20 H21.
   elim (H f2) with f3 h1.
   2: apply comp_relplus; apply comp_2rel with f1; assumption.
   2: assumption.
   2: assumption.
   intros h2 H22; elim H22; intros H23 H24.
   elim (C f3 h2 g1 H23 H18); intros k H25; elim H25; intros H26 H27.
   exists k; split.
   apply star_trans with g1; assumption.
   apply comp_l with h1.
   assumption.
   apply comp_r with h2; assumption.
   Save commut2.

   Theorem Yokouchi : explicit_strong_confluence _ Rstar_S_Rstar.

End YokouchiS. *)



Goal forall b : wsort, explicit_confluence _ (e_relSL b).

intros b.

apply Newman.

apply relSL_noetherian.

apply conf_local_SL.

Save confluence_SL.



Goal forall b : wsort, explicit_strong_confluence _ (e_slstar_bp_slstar b).

intro b; unfold e_slstar_bp_slstar in |- *.

change

  (explicit_strong_confluence _

     (Rstar_S_Rstar (TS b) (e_relSL b) (e_beta_par b))) 

 in |- *.

apply Yokouchi.

apply confluence_SL.

apply relSL_noetherian.

apply sconf_betapar.

intros f g h H H0.

unfold Rstar_S_Rstar in |- *.

change (exists k : TS b, e_relSLstar _ g k /\ e_slstar_bp_slstar _ h k)

 in |- *.

apply commutation with f; assumption.

Save strong_confluence_slbpsl.



Goal forall b : wsort, explicit_confluence _ (e_slstar_bp_slstar b).

intro b; apply strong_conf_conf; apply strong_confluence_slbpsl.

Save confluence_slbpsl.



Theorem confluence_LSL : forall b : wsort, explicit_confluence _ (e_relLSL b).

Proof.

intro b; apply inclus_conf with (e_slstar_bp_slstar b).

apply relLSL_inclus_slbpsl.

change (explicit_inclus _ (e_slstar_bp_slstar b) (e_relLSLstar b)) in |- *.

apply slbpsl_inclus_relLSLstar.

apply confluence_slbpsl.

Qed.



