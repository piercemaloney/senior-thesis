

Require Import Le.

Require Import Lt.

Require Import Plus.

Require Import Gt.

Require Import Minus.

Require Import Mult.

Require Import sur_les_relations.
(* sur_les_relations:
Section Rels.

Variable A : Set.

Inductive explicit_star (R : A -> A -> Prop) : A -> A -> Prop :=
  | star_refl : forall x : A, explicit_star R x x
  | star_trans1 :
      forall x y z : A, R x y -> explicit_star R y z -> explicit_star R x z.

Inductive explicit_comp_rel (R1 R2 : A -> A -> Prop) : A -> A -> Prop :=
    comp_2rel :
      forall x y z : A, R1 x y -> R2 y z -> explicit_comp_rel R1 R2 x z.

Inductive explicit_rel_plus (R : A -> A -> Prop) : A -> A -> Prop :=
  | relplus_1step : forall x y : A, R x y -> explicit_rel_plus R x y
  | relplus_trans1 :
      forall x y z : A,
      R x y -> explicit_rel_plus R y z -> explicit_rel_plus R x z. 

End Rels.

Hint Resolve star_refl.
Hint Resolve relplus_1step.

Notation star := (explicit_star _) (only parsing).

Notation comp_rel := (explicit_comp_rel _) (only parsing).

Notation rel_plus := (explicit_rel_plus _) (only parsing).

Section rels_prop.

Variable A : Set.
Variable R : A -> A -> Prop.

Definition confluence_en (x : A) :=
  forall y z : A,
  explicit_star _ R x y ->
  explicit_star _ R x z ->
  exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_confluence := forall x : A, confluence_en x.

Definition local_confluence_en (x : A) :=
  forall y z : A,
  R x y ->
  R x z -> exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_local_confluence := forall x : A, local_confluence_en x.

Definition strong_confluence_en (x : A) :=
  forall y z : A, R x y -> R x z -> exists u : A, R y u /\ R z u.

Definition explicit_strong_confluence := forall x : A, strong_confluence_en x.

End rels_prop.

Notation confluence := (explicit_confluence _) (only parsing).

Notation local_confluence := (explicit_local_confluence _) (only parsing).

Notation strong_confluence := (explicit_strong_confluence _) (only parsing).

Definition explicit_inclus (A : Set) (R1 R2 : A -> A -> Prop) :=
  forall x y : A, R1 x y -> R2 x y.

Notation inclus := (explicit_inclus _) (only parsing).

Section relations_noetherian.

Variable U : Set.

Variable R : U -> U -> Prop.

Definition a_set := U -> Prop.

Definition sub (A B : a_set) := forall x : U, A x -> B x.

Definition universal (A : a_set) := forall x : U, A x.

Definition adjoint (A : a_set) : a_set := fun x : U => sub (R x) A.

Definition hereditary (A : a_set) := sub (adjoint A) A.

Definition explicit_noetherian :=
  forall A : a_set, hereditary A -> universal A.

End relations_noetherian.

Notation noetherian := (explicit_noetherian _) (only parsing).

Goal
forall (A : Set) (P Q : A -> Prop),
(exists u : A, P u /\ Q u) -> exists u : A, Q u /\ P u.
simple induction 1; intros u1 H1.
elim H1; intros H2 H3.
exists u1; split; assumption.
Save Ex_PQ.
Hint Resolve Ex_PQ.
 
Lemma star_trans :
 forall (A : Set) (R : A -> A -> Prop) (x y z : A),
 explicit_star _ R x y -> explicit_star _ R y z -> explicit_star _ R x z.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
R x y -> explicit_star _ R x y.
intros; apply star_trans1 with y.
assumption.
apply star_refl.
Save star_step1.

Hint Resolve star_step1.

Goal
forall (A : Set) (R1 R2 : A -> A -> Prop) (M N : A),
explicit_comp_rel _ R1 R2 M N -> exists u : A, R1 M u /\ R2 u N.  
intros A R1 R2 M N H; elim H.
intros x y z H1 H2; exists y; split; assumption.
Save comp_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_comp_rel _ R (explicit_star _ R) x y -> explicit_rel_plus _ R x y.
intros A R x y H; elim H.
intros a b c H1 H2; generalize H1; generalize a.
elim H2.
intros; apply relplus_1step; assumption.
intros x0 y0 z H3 H4 H5 a0 H6; apply relplus_trans1 with x0.
assumption.
apply H5; assumption.
Save comp_relplus.

Goal
forall (A : Set) (R : A -> A -> Prop) (M N : A),
explicit_star _ R M N ->
M = N \/ (exists u : A, R M u /\ explicit_star _ R u N).
intros A R M N H; elim H.
intros x; left; trivial.
intros x y z H1 H2 H3; right; exists y; split; trivial.
Save star_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_rel_plus _ R x y ->
explicit_rel_plus _ R y z -> explicit_rel_plus _ R x z.
simple induction 1.
intros; apply relplus_trans1 with y0; trivial.
intros; apply relplus_trans1 with y0; auto.
Save Rplus_transitive.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_rel_plus _ R x y -> explicit_star _ R x y.
simple induction 1; intros.
auto.
apply star_trans1 with y0; auto.
Save Rplus_Rstar.

Hint Resolve Rplus_Rstar.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_star _ R x y ->
explicit_rel_plus _ R y z -> exists u : A, R x u /\ explicit_star _ R u z.
simple induction 1; intros.
elim H0; intros.
exists y0; auto.
exists y0; auto.
exists y0; split; trivial.
apply star_trans with z0; auto.
Save Rstar_Rplus_R.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_noetherian _ R ->
forall A1 : a_set A,
hereditary A (explicit_rel_plus _ R) A1 ->
universal A (adjoint A (explicit_star _ R) A1).
unfold explicit_noetherian in |- *; unfold hereditary in |- *;
 unfold universal in |- *; unfold sub in |- *; intros A R N A1 H x.
apply (N (adjoint A (explicit_star _ R) A1)).
unfold adjoint in |- *; unfold sub in |- *; intros.
apply H; unfold adjoint in |- *; unfold sub in |- *; intros.
elim Rstar_Rplus_R with A R x0 x1 x2; trivial.
intro z; simple induction 1; intros C1 C2; apply H0 with z; trivial.
Save noetherian_course_of_values.

Lemma plus_preserves_noetherian :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R -> explicit_noetherian _ (explicit_rel_plus _ R).

Lemma noetherian_induction1 :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, R y z -> P z) -> P y) -> P x.

Lemma noetherian_induction :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, explicit_rel_plus _ R y z -> P z) -> P y) ->
 P x.

Lemma noether_inclus :
 forall (A : Set) (R R' : A -> A -> Prop),
 explicit_noetherian _ R ->
 (forall x y : A, R' x y -> R x y) -> explicit_noetherian _ R'.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R (explicit_star _ S) ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
intros A R S H; red in |- *; simple induction 1.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans with y0; auto.
Save inclus_star.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
unfold explicit_inclus in |- *; simple induction 2.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans1 with y0.
apply (H x0 y0 H1).
assumption.
Save inclus_reg_star.
Hint Resolve inclus_reg_star.

Goal
forall (A : Set) (R1 R2 S : A -> A -> Prop),
explicit_inclus _ R1 S ->
explicit_inclus _ R2 S ->

(forall x y z : A, S x y -> S y z -> S x z) ->
explicit_inclus _ (explicit_comp_rel _ R1 R2) S.   
intros A R1 R2 S H H0 H1; red in |- *; simple induction 1.
intros x0 y0 z H3 H4; apply H1 with y0; auto.
Save inclus_comp.
Hint Resolve inclus_comp.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_strong_confluence _ R -> explicit_confluence _ R.
intros A R H; red in |- *; red in |- *.
intros x y z H1; generalize z; elim H1.
intros x0 z0 H2; exists z0; split; auto.
intros x0 y0 y1 H2 H3 H4 z0 H5.
cut (exists u : A, explicit_star _ R y0 u /\ R z0 u).
intro H6; elim H6; intros z1 H7; elim H7; intros H8 H9.
elim (H4 z1 H8); intros u H10; elim H10; intros H11 H12.
exists u; split.
assumption.
apply star_trans1 with z1; assumption.
generalize H2; generalize y0; elim H5.
intros x1 y2 H6; exists y2; split; auto.
intros x1 y2 z1 H6 H7 H8 y3 H9; elim (H x1 y3 y2).
intros x2 H10; elim H10; intros H11 H12.
elim (H8 x2 H12); intros u H13; elim H13; intros H14 H15.
exists u; split; [ apply star_trans1 with x2; assumption | assumption ];
 trivial.
assumption.
assumption.
Save strong_conf_conf.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ S (explicit_star _ R) ->
explicit_confluence _ S -> explicit_confluence _ R.
red in |- *; red in |- *; intros A R S H H0 H1 x y z H2 H3.
cut (explicit_inclus _ (explicit_star _ R) (explicit_star _ S)).
2: auto.
intro H4; elim (H1 x y z (H4 x y H2) (H4 x z H3)).
intros x' H5; elim H5; intros H6 H7.
exists x'; split.
exact (inclus_star A S R H0 y x' H6).
exact (inclus_star A S R H0 z x' H7).
Save inclus_conf. *)

Require Import TS. 

Require Import sigma_lift.  

Require Import comparith.
(* comparith:
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Gt.
Require Import Minus.
Require Import Mult.

Hint Resolve mult_n_O mult_n_Sm plus_le_compat. 

Goal forall n m : nat, n > m -> S n > m.
auto with arith.
Save gt_S_l.
Hint Resolve gt_S_l.

Goal forall n m : nat, n > S m -> n > m.
auto with arith.
Save gt_S_r.
Hint Resolve gt_S_r.
 
Goal forall n m p : nat, n = m -> p + n = p + m.
intros; elim p; elim H; auto with arith.
Save eq_plus_reg_r.
Hint Resolve eq_plus_reg_r.

Goal forall n m p : nat, n = m -> n + p = m + p.
intros; elim p; elim H; auto with arith.
Save eq_plus_reg_l.
Hint Resolve eq_plus_reg_l.

Goal forall n m p : nat, n > m -> n + p > m + p.
intros; elim (plus_comm p m); elim (plus_comm p n); auto with arith.
Save gt_reg_r.
Hint Resolve gt_reg_r.

Goal forall n m p q : nat, n > m -> p > q -> n + p > m + q.
simple induction 1; intros; simpl in |- *; auto with arith.
Save gt_plus_plus.
Hint Resolve gt_plus_plus.

Goal forall p : nat, p > 0 -> forall n : nat, p + n > n.
simple induction 1; intros.
auto with arith.
simpl in |- *; auto with arith.
Save gt_plus_l.
Hint Resolve gt_plus_l.

Goal forall p : nat, p > 0 -> forall n : nat, n + p > n.
intros; elim (plus_comm p n); auto with arith.
Save gt_plus_r.
Hint Resolve gt_plus_r.

Goal forall n m p : nat, n > m -> n + p > m.
auto with arith.
Save gt_plus_trans_r.
Hint Resolve gt_plus_trans_r.

Goal forall n m p : nat, n > m -> p + n > m.
intros; elim (plus_comm n p); auto with arith.
Save gt_plus_trans_l.
Hint Resolve gt_plus_trans_l.

Goal forall n : nat, S n = n + 1.
simple induction n.
auto with arith.
simpl in |- *; auto with arith.
Save S_plus.
Hint Resolve S_plus.
 
Goal forall n m : nat, n * m = m * n.
simple induction n; intros.
auto with arith.
simpl in |- *; elim mult_n_Sm; elim H; auto with arith.
Save mult_sym.
Hint Resolve mult_sym.

Goal forall n m p : nat, n * (m * p) = n * m * p.
intros n m p; elim n; simpl in |- *.
auto with arith.
intros y H; rewrite mult_plus_distr_r; elim H; auto with arith.
Save mult_assoc_l.
Hint Resolve mult_assoc_l.

Goal forall n m p : nat, n * (m * p) = m * (n * p).
intros; rewrite (mult_assoc_l m n p); rewrite (mult_sym m n); auto with arith.
Save mult_permut.
Hint Resolve mult_permut. 

Goal forall n m p : nat, p * (n + m) = p * n + p * m.
intros n m p; elim p.
auto with arith.
simpl in |- *; intros y H; rewrite H; elim plus_assoc; elim plus_assoc.
pattern (y * n + (m + y * m)) in |- *; elim plus_permute; trivial with arith.
Save mult_plus_distr_r.
Hint Resolve comparith.mult_plus_distr_r.

Goal forall n : nat, n * 2 = n + n.
simple induction n.
auto with arith.
intros; simpl in |- *; rewrite H; auto with arith.
Save mult_n_2. 
Hint Resolve mult_n_2.
 
Goal forall n : nat, n = n * 1.  
simple induction n.
auto with arith.
simpl in |- *; auto with arith.
Save mult_n_1. 
Hint Resolve mult_n_1.

Goal forall n m p : nat, n = m -> p * n = p * m.
intros; elim p; elim H; auto with arith.
Save eq_mult_reg_r.
Hint Resolve eq_mult_reg_r.

Goal forall n m p : nat, n = m -> n * p = m * p.
intros; elim p; elim H; auto with arith.
Save eq_mult_reg_l.
Hint Resolve eq_mult_reg_l.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> p * n > p * m.
simple induction p.
intros H n m H0; absurd (0 > 0); auto with arith.
intros y H H0 n m H1; elim (gt_O_eq y); intros.
simpl in |- *; auto with arith.
elim H2; simpl in |- *; elim (plus_n_O n); elim (plus_n_O m);
 trivial with arith.
Save gt_mult_reg_l.
Hint Resolve gt_mult_reg_l.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> n * p > m * p.
intros; elim (mult_sym p n); elim (mult_sym p m); auto with arith.
Save gt_mult_reg_r.
Hint Resolve gt_mult_reg_r.

Goal forall p : nat, p > 1 -> forall n : nat, n > 0 -> p * n > n.
simple induction p.
intros H n H0; absurd (0 > 1); auto with arith.
intros y H H0 n H1; simpl in |- *; apply gt_plus_r; replace 0 with (y * 0);
 auto with arith.
Save gt_mult_l.
Hint Resolve gt_mult_l.

Goal forall p : nat, p > 1 -> forall n : nat, n > 0 -> n * p > n.
intros; elim (mult_sym p n); auto with arith.
Save gt_mult_r.
Hint Resolve gt_mult_r.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> p * n > m.
simple induction p.
intros H n m H0; simpl in |- *; absurd (0 > 0); auto with arith.
intros y H H0 n m H1; simpl in |- *; elim (gt_O_eq y); intro H2.
auto with arith.
elim H2; simpl in |- *; elim plus_n_O; assumption.
Save gt_mult_trans_r.
Hint Resolve gt_mult_trans_r.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> n * p > m.
intros; elim (mult_sym p n); auto with arith.
Save gt_mult_trans_l.
Hint Resolve gt_mult_trans_l.

Fixpoint power2 (n : nat) : nat :=
  match n with
  | O => 1
  | S p => 2 * power2 p
  end.

Goal forall n : nat, power2 n > 0.
simple induction n; simpl in |- *; intros.
auto with arith.
elim plus_n_O; auto with arith.
Save gt_power2_O.
Hint Resolve gt_power2_O. *)

Require Import Pol1.
(* Pol1:
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Gt.
Require Import Minus.
Require Import Mult.
Require Import TS. 
Require Import sigma_lift.  
Require Import comparith.

Definition e_P1 (b : wsort) (U : TS b) : nat :=
  (fix F (w : wsort) (t : TS w) {struct t} : nat :=
     match t with
     | var n => power2 (S n)
     | app t0 t1 => F wt t0 + F wt t1
     | lambda t0 => F wt t0 + 2
     | env t0 t1 => F wt t0 * F ws t1
     | id => 2
     | shift => 2
     | cons t0 t1 => F wt t0 + F ws t1
     | comp t0 t1 => F ws t0 * F ws t1
     | lift t0 => F ws t0
     | meta_X _ => 2
     | meta_x _ => 2
     end) b U.
 
Notation P1 := (e_P1 _) (only parsing).

Theorem gt_P1_1 : forall (b : wsort) (M : TS b), e_P1 _ M > 1.
Hint Resolve gt_P1_1.

Theorem P1_app : forall M N : terms, reg_app M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_app.

Theorem P1_lambda : forall M N : terms, reg_lambda M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_lambda.

Theorem P1_clos : forall M N : terms, reg_clos M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_clos.
 
Theorem P1_varshift1 :
 forall M N : terms, reg_varshift1 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_varshift1.

Theorem P1_varshift2 :
 forall M N : terms, reg_varshift2 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_varshift2.

Theorem P1_fvarcons :
 forall M N : terms, reg_fvarcons M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_fvarcons.

Theorem P1_fvarlift1 :
 forall M N : terms, reg_fvarlift1 M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_fvarlift1.

Theorem P1_fvarlift2 :
 forall M N : terms, reg_fvarlift2 M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_fvarlift2.

Theorem P1_rvarcons :
 forall M N : terms, reg_rvarcons M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_rvarcons.

Theorem P1_rvarlift1 :
 forall M N : terms, reg_rvarlift1 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_rvarlift1.

Theorem P1_rvarlift2 :
 forall M N : terms, reg_rvarlift2 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_rvarlift2.

Theorem P1_assenv :
 forall M N : sub_explicits, reg_assenv M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_assenv.

Theorem P1_mapenv :
 forall M N : sub_explicits, reg_mapenv M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_mapenv.

Theorem P1_shiftcons :
 forall M N : sub_explicits, reg_shiftcons M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_shiftcons.

Theorem P1_shiftlift1 :
 forall M N : sub_explicits, reg_shiftlift1 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_shiftlift1.

Theorem P1_shiftlift2 :
 forall M N : sub_explicits, reg_shiftlift2 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_shiftlift2.

Theorem P1_lift1 :
 forall M N : sub_explicits, reg_lift1 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_lift1.

Theorem P1_lift2 :
 forall M N : sub_explicits, reg_lift2 M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_lift2.

Theorem P1_liftenv :
 forall M N : sub_explicits, reg_liftenv M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_liftenv.

Theorem P1_idl :
 forall M N : sub_explicits, reg_idl M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_idl.

Theorem P1_idr :
 forall M N : sub_explicits, reg_idr M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_idr.

Theorem P1_liftid :
 forall M N : sub_explicits, reg_liftid M N -> e_P1 _ M = e_P1 _ N.
Hint Resolve P1_liftid.

Theorem P1_id : forall M N : terms, reg_id M N -> e_P1 _ M > e_P1 _ N.
Hint Resolve P1_id. *)

Require Import Pol2.
(* Pol2:
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Gt.
Require Import Minus.
Require Import Mult.
Require Import TS.  
Require Import sigma_lift.
Require Import comparith.

Definition e_P2 (b : wsort) (U : TS b) : nat :=
  (fix F (w : wsort) (t : TS w) {struct t} : nat :=
     match t with
     | var _ => 1
     | app t0 t1 => S (F wt t0 + F wt t1)
     | lambda t0 => 2 * F wt t0
     | env t0 t1 => F wt t0 * S (F ws t1)
     | id => 1
     | shift => 1
     | cons t0 t1 => S (F wt t0 + F ws t1)
     | comp t0 t1 => F ws t0 * S (F ws t1)
     | lift t0 => 4 * F ws t0
     | meta_X _ => 1
     | meta_x _ => 1
     end) b U.
 
Notation P2 := (e_P2 _) (only parsing).

Theorem P2_pos : forall (b : wsort) (M : TS b), e_P2 _ M > 0.
Hint Resolve P2_pos.

Theorem P2_app : forall M N : terms, reg_app M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_app.

Theorem P2_lambda : forall M N : terms, reg_lambda M N -> e_P2 _ M < e_P2 _ N.
Hint Resolve P2_lambda.

Theorem P2_clos : forall M N : terms, reg_clos M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_clos.

Theorem P2_varshift1 :
 forall M N : terms, reg_varshift1 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_varshift1.

Theorem P2_varshift2 :
 forall M N : terms, reg_varshift2 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_varshift2.

Theorem P2_fvarcons :
 forall M N : terms, reg_fvarcons M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_fvarcons.

Theorem P2_fvarlift1 :
 forall M N : terms, reg_fvarlift1 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_fvarlift1.

Theorem P2_fvarlift2 :
 forall M N : terms, reg_fvarlift2 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_fvarlift2.

Theorem P2_rvarcons :
 forall M N : terms, reg_rvarcons M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_rvarcons.

Theorem P2_rvarlift1 :
 forall M N : terms, reg_rvarlift1 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_rvarlift1.

Theorem P2_rvarlift2 :
 forall M N : terms, reg_rvarlift2 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_rvarlift2.

Theorem P2_assenv :
 forall M N : sub_explicits, reg_assenv M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_assenv.

Theorem P2_mapenv :
 forall M N : sub_explicits, reg_mapenv M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_mapenv.

Theorem P2_shiftcons :
 forall M N : sub_explicits, reg_shiftcons M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_shiftcons.

Theorem P2_shiftlift1 :
 forall M N : sub_explicits, reg_shiftlift1 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_shiftlift1.

Theorem P2_shiftlift2 :
 forall M N : sub_explicits, reg_shiftlift2 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_shiftlift2.

Theorem P2_lift1 :
 forall M N : sub_explicits, reg_lift1 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_lift1.

Theorem P2_lift2 :
 forall M N : sub_explicits, reg_lift2 M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_lift2.

Theorem P2_liftenv :
 forall M N : sub_explicits, reg_liftenv M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_liftenv.

Theorem P2_idl :
 forall M N : sub_explicits, reg_idl M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_idl.

Theorem P2_idr :
 forall M N : sub_explicits, reg_idr M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_idr.

Theorem P2_liftid :
 forall M N : sub_explicits, reg_liftid M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_liftid.

Theorem P2_id : forall M N : terms, reg_id M N -> e_P2 _ M > e_P2 _ N.
Hint Resolve P2_id. *)



Section ordre.



Variable A : Set.

Variable f g : A -> nat.



Definition e_lexfg (a b : A) := f a > f b \/ f a = f b /\ g a > g b.



Lemma lexfg_notherian : explicit_noetherian _ e_lexfg. 

Proof.

unfold explicit_noetherian in |- *; unfold universal in |- *;

 unfold hereditary in |- *; unfold adjoint in |- *; 

 unfold sub in |- *; unfold a_set in |- *.

intros P H.

cut (forall (n m : nat) (a : A), n > f a \/ n = f a /\ m > g a -> P a).

intros H0 x; apply (H0 (S (f x)) 0).

auto with arith.

simple induction n; simple induction m.



simple induction 1; intro H1.

absurd (0 > f a); auto with arith.

elim H1; intros.

absurd (0 > g a); auto with arith.



intros y H' a H0.

apply H; intros b lexfgab. 

apply H'; right.

elim H0; intro H1.

absurd (0 > f a); auto with arith.

elim H1; intros H2 H3; elim lexfgab; intro H4.

absurd (0 > f b).

auto with arith.

rewrite H2; assumption.

elim H4; intros.

split.

rewrite H2; assumption.

apply le_gt_trans with (g a); auto with arith.



intros a H0'; apply H; intros b lexfgab.

apply (H0 (g a) b); elim H0'; intro H1.

elim lexfgab; intro H2.

left; apply le_gt_trans with (f a); auto with arith.

elim H2; intros H3 H4; elim (gt_S n0 (f a) H1); intro H5.

left; elim H3; assumption.

right; split.

elim H3; auto with arith.

assumption.

elim H1; intros H2 H3.

absurd (0 > g a); auto with arith.



intros y0 H0' a H1; apply H; intros b lexfgab.

apply H0'; elim H1; elim lexfgab; intros H2 H3.

left; apply le_gt_trans with (f a); auto with arith.

elim H2; intros H4 H5; left; elim H4; assumption.

elim H3; intros H4 H5; left; rewrite H4; assumption.

elim H2; intros H4 H5; elim H3; intros H6 H7.

right; split.

apply trans_equal with (f a); assumption.

apply le_gt_trans with (g a); auto with arith.

Qed.



End ordre.



Notation lexfg := (e_lexfg _) (only parsing).



Theorem lexfg_systemSL :

 forall (b : wsort) (M N : TS b),

 e_systemSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.

Proof.

red in |- *; simple induction 1; auto with arith.

Qed.

Hint Resolve lexfg_systemSL.

 

Theorem lexfg_app_l :

 forall a a' b : terms,

 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->

 e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a' b).

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_app_l.



Theorem lexfg_app_r :

 forall a b b' : terms,

 e_lexfg _ (e_P1 wt) (e_P2 wt) b b' ->

 e_lexfg _ (e_P1 wt) (e_P2 wt) (app a b) (app a b').

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_app_r.



Theorem lexfg_lambda :

 forall a a' : terms,

 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->

 e_lexfg _ (e_P1 wt) (e_P2 wt) (lambda a) (lambda a').

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_lambda.



Theorem lexfg_env_t :

 forall (a a' : terms) (s : sub_explicits),

 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->

 e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a' s).

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_env_t.



Theorem lexfg_env_s :

 forall (a : terms) (s s' : sub_explicits),

 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->

 e_lexfg _ (e_P1 wt) (e_P2 wt) (env a s) (env a s').

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_env_s.



Theorem lexfg_cons_t :

 forall (a a' : terms) (s : sub_explicits),

 e_lexfg _ (e_P1 wt) (e_P2 wt) a a' ->

 e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a' s).

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_cons_t.



Theorem lexfg_cons_s :

 forall (a : terms) (s s' : sub_explicits),

 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->

 e_lexfg _ (e_P1 ws) (e_P2 ws) (cons a s) (cons a s').

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_cons_s.



Theorem lexfg_comp_l :

 forall s s' t : sub_explicits,

 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->

 e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s' t).

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_comp_l.



Theorem lexfg_comp_r :

 forall s t t' : sub_explicits,

 e_lexfg _ (e_P1 ws) (e_P2 ws) t t' ->

 e_lexfg _ (e_P1 ws) (e_P2 ws) (comp s t) (comp s t').

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; auto with arith.

intros; elim H0; auto with arith.

Qed.

Hint Resolve lexfg_comp_r.



Theorem lexfg_lift :

 forall s s' : sub_explicits,

 e_lexfg _ (e_P1 ws) (e_P2 ws) s s' ->

 e_lexfg _ (e_P1 ws) (e_P2 ws) (lift s) (lift s').

Proof.

unfold e_lexfg in |- *; simple induction 1; simpl in |- *; intros.

auto with arith.

elim H0; intros; right; split.

assumption.

change (4 * e_P2 _ s > 4 * e_P2 _ s') in |- *.

auto with arith.

Qed.

Hint Resolve lexfg_lift.



Theorem lexfg_relSL :

 forall (b : wsort) (M N : TS b),

 e_relSL _ M N -> e_lexfg _ (e_P1 b) (e_P2 b) M N.

Proof.

simple induction 1; auto with arith.

Qed.



Theorem relSL_noetherian :

 forall b : wsort, explicit_noetherian _ (e_relSL b).

Proof.

intro b; apply noether_inclus with (e_lexfg _ (e_P1 b) (e_P2 b)).

apply lexfg_notherian.

exact (lexfg_relSL b).

Qed.



