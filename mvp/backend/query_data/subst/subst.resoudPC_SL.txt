
Require Import TS.
(* TS:
Inductive wsort : Set :=
  | ws : wsort
  | wt : wsort.

Inductive TS : wsort -> Set :=
  | var : nat -> TS wt
  | app : TS wt -> TS wt -> TS wt
  | lambda : TS wt -> TS wt
  | env : TS wt -> TS ws -> TS wt
  | id : TS ws
  | shift : TS ws
  | cons : TS wt -> TS ws -> TS ws
  | comp : TS ws -> TS ws -> TS ws
  | lift : TS ws -> TS ws
  | meta_X : nat -> TS wt
  | meta_x : nat -> TS ws.

Definition terms := TS wt.

Definition sub_explicits := TS ws.
 
Goal (terms -> Prop) -> forall b : wsort, TS b -> Prop.
intros P b; elim b.
exact (fun x : TS ws => True).
exact P.
Defined Pterms.

Lemma terms_ind :
 forall P : terms -> Prop,
 (forall n : nat, P (var n)) ->
 (forall a b : terms, P a -> P b -> P (app a b)) ->
 (forall a : terms, P a -> P (lambda a)) ->
 (forall a : terms, P a -> forall s : sub_explicits, P (env a s)) ->
 (forall n : nat, P (meta_X n)) -> forall a : terms, P a.

Goal (sub_explicits -> Prop) -> forall b : wsort, TS b -> Prop.
intros P b; elim b.
exact P.
exact (fun x : TS wt => True).
Defined Psubst.

Lemma sub_explicits_ind :
 forall P : sub_explicits -> Prop,
 P id ->
 P shift ->
 (forall s : sub_explicits, P s -> forall a : terms, P (cons a s)) ->
 (forall s t : sub_explicits, P s -> P t -> P (comp s t)) ->
 (forall s : sub_explicits, P s -> P (lift s)) ->
 (forall n : nat, P (meta_x n)) -> forall s : sub_explicits, P s. *)
Require Import sur_les_relations.
(* sur_les_relations:
Section Rels.

Variable A : Set.

Inductive explicit_star (R : A -> A -> Prop) : A -> A -> Prop :=
  | star_refl : forall x : A, explicit_star R x x
  | star_trans1 :
      forall x y z : A, R x y -> explicit_star R y z -> explicit_star R x z.

Inductive explicit_comp_rel (R1 R2 : A -> A -> Prop) : A -> A -> Prop :=
    comp_2rel :
      forall x y z : A, R1 x y -> R2 y z -> explicit_comp_rel R1 R2 x z.

Inductive explicit_rel_plus (R : A -> A -> Prop) : A -> A -> Prop :=
  | relplus_1step : forall x y : A, R x y -> explicit_rel_plus R x y
  | relplus_trans1 :
      forall x y z : A,
      R x y -> explicit_rel_plus R y z -> explicit_rel_plus R x z. 

End Rels.

Hint Resolve star_refl.
Hint Resolve relplus_1step.

Notation star := (explicit_star _) (only parsing).

Notation comp_rel := (explicit_comp_rel _) (only parsing).

Notation rel_plus := (explicit_rel_plus _) (only parsing).

Section rels_prop.

Variable A : Set.
Variable R : A -> A -> Prop.

Definition confluence_en (x : A) :=
  forall y z : A,
  explicit_star _ R x y ->
  explicit_star _ R x z ->
  exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_confluence := forall x : A, confluence_en x.

Definition local_confluence_en (x : A) :=
  forall y z : A,
  R x y ->
  R x z -> exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_local_confluence := forall x : A, local_confluence_en x.

Definition strong_confluence_en (x : A) :=
  forall y z : A, R x y -> R x z -> exists u : A, R y u /\ R z u.

Definition explicit_strong_confluence := forall x : A, strong_confluence_en x.

End rels_prop.

Notation confluence := (explicit_confluence _) (only parsing).

Notation local_confluence := (explicit_local_confluence _) (only parsing).

Notation strong_confluence := (explicit_strong_confluence _) (only parsing).

Definition explicit_inclus (A : Set) (R1 R2 : A -> A -> Prop) :=
  forall x y : A, R1 x y -> R2 x y.

Notation inclus := (explicit_inclus _) (only parsing).

Section relations_noetherian.

Variable U : Set.

Variable R : U -> U -> Prop.

Definition a_set := U -> Prop.

Definition sub (A B : a_set) := forall x : U, A x -> B x.

Definition universal (A : a_set) := forall x : U, A x.

Definition adjoint (A : a_set) : a_set := fun x : U => sub (R x) A.

Definition hereditary (A : a_set) := sub (adjoint A) A.

Definition explicit_noetherian :=
  forall A : a_set, hereditary A -> universal A.

End relations_noetherian.

Notation noetherian := (explicit_noetherian _) (only parsing).

Goal
forall (A : Set) (P Q : A -> Prop),
(exists u : A, P u /\ Q u) -> exists u : A, Q u /\ P u.
simple induction 1; intros u1 H1.
elim H1; intros H2 H3.
exists u1; split; assumption.
Save Ex_PQ.
Hint Resolve Ex_PQ.
 
Lemma star_trans :
 forall (A : Set) (R : A -> A -> Prop) (x y z : A),
 explicit_star _ R x y -> explicit_star _ R y z -> explicit_star _ R x z.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
R x y -> explicit_star _ R x y.
intros; apply star_trans1 with y.
assumption.
apply star_refl.
Save star_step1.

Hint Resolve star_step1.

Goal
forall (A : Set) (R1 R2 : A -> A -> Prop) (M N : A),
explicit_comp_rel _ R1 R2 M N -> exists u : A, R1 M u /\ R2 u N.  
intros A R1 R2 M N H; elim H.
intros x y z H1 H2; exists y; split; assumption.
Save comp_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_comp_rel _ R (explicit_star _ R) x y -> explicit_rel_plus _ R x y.
intros A R x y H; elim H.
intros a b c H1 H2; generalize H1; generalize a.
elim H2.
intros; apply relplus_1step; assumption.
intros x0 y0 z H3 H4 H5 a0 H6; apply relplus_trans1 with x0.
assumption.
apply H5; assumption.
Save comp_relplus.

Goal
forall (A : Set) (R : A -> A -> Prop) (M N : A),
explicit_star _ R M N ->
M = N \/ (exists u : A, R M u /\ explicit_star _ R u N).
intros A R M N H; elim H.
intros x; left; trivial.
intros x y z H1 H2 H3; right; exists y; split; trivial.
Save star_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_rel_plus _ R x y ->
explicit_rel_plus _ R y z -> explicit_rel_plus _ R x z.
simple induction 1.
intros; apply relplus_trans1 with y0; trivial.
intros; apply relplus_trans1 with y0; auto.
Save Rplus_transitive.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_rel_plus _ R x y -> explicit_star _ R x y.
simple induction 1; intros.
auto.
apply star_trans1 with y0; auto.
Save Rplus_Rstar.

Hint Resolve Rplus_Rstar.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_star _ R x y ->
explicit_rel_plus _ R y z -> exists u : A, R x u /\ explicit_star _ R u z.
simple induction 1; intros.
elim H0; intros.
exists y0; auto.
exists y0; auto.
exists y0; split; trivial.
apply star_trans with z0; auto.
Save Rstar_Rplus_R.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_noetherian _ R ->
forall A1 : a_set A,
hereditary A (explicit_rel_plus _ R) A1 ->
universal A (adjoint A (explicit_star _ R) A1).
unfold explicit_noetherian in |- *; unfold hereditary in |- *;
 unfold universal in |- *; unfold sub in |- *; intros A R N A1 H x.
apply (N (adjoint A (explicit_star _ R) A1)).
unfold adjoint in |- *; unfold sub in |- *; intros.
apply H; unfold adjoint in |- *; unfold sub in |- *; intros.
elim Rstar_Rplus_R with A R x0 x1 x2; trivial.
intro z; simple induction 1; intros C1 C2; apply H0 with z; trivial.
Save noetherian_course_of_values.

Lemma plus_preserves_noetherian :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R -> explicit_noetherian _ (explicit_rel_plus _ R).

Lemma noetherian_induction1 :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, R y z -> P z) -> P y) -> P x.

Lemma noetherian_induction :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, explicit_rel_plus _ R y z -> P z) -> P y) ->
 P x.

Lemma noether_inclus :
 forall (A : Set) (R R' : A -> A -> Prop),
 explicit_noetherian _ R ->
 (forall x y : A, R' x y -> R x y) -> explicit_noetherian _ R'.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R (explicit_star _ S) ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
intros A R S H; red in |- *; simple induction 1.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans with y0; auto.
Save inclus_star.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
unfold explicit_inclus in |- *; simple induction 2.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans1 with y0.
apply (H x0 y0 H1).
assumption.
Save inclus_reg_star.
Hint Resolve inclus_reg_star.

Goal
forall (A : Set) (R1 R2 S : A -> A -> Prop),
explicit_inclus _ R1 S ->
explicit_inclus _ R2 S ->

(forall x y z : A, S x y -> S y z -> S x z) ->
explicit_inclus _ (explicit_comp_rel _ R1 R2) S.   
intros A R1 R2 S H H0 H1; red in |- *; simple induction 1.
intros x0 y0 z H3 H4; apply H1 with y0; auto.
Save inclus_comp.
Hint Resolve inclus_comp.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_strong_confluence _ R -> explicit_confluence _ R.
intros A R H; red in |- *; red in |- *.
intros x y z H1; generalize z; elim H1.
intros x0 z0 H2; exists z0; split; auto.
intros x0 y0 y1 H2 H3 H4 z0 H5.
cut (exists u : A, explicit_star _ R y0 u /\ R z0 u).
intro H6; elim H6; intros z1 H7; elim H7; intros H8 H9.
elim (H4 z1 H8); intros u H10; elim H10; intros H11 H12.
exists u; split.
assumption.
apply star_trans1 with z1; assumption.
generalize H2; generalize y0; elim H5.
intros x1 y2 H6; exists y2; split; auto.
intros x1 y2 z1 H6 H7 H8 y3 H9; elim (H x1 y3 y2).
intros x2 H10; elim H10; intros H11 H12.
elim (H8 x2 H12); intros u H13; elim H13; intros H14 H15.
exists u; split; [ apply star_trans1 with x2; assumption | assumption ];
 trivial.
assumption.
assumption.
Save strong_conf_conf.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ S (explicit_star _ R) ->
explicit_confluence _ S -> explicit_confluence _ R.
red in |- *; red in |- *; intros A R S H H0 H1 x y z H2 H3.
cut (explicit_inclus _ (explicit_star _ R) (explicit_star _ S)).
2: auto.
intro H4; elim (H1 x y z (H4 x y H2) (H4 x z H3)).
intros x' H5; elim H5; intros H6 H7.
exists x'; split.
exact (inclus_star A S R H0 y x' H6).
exact (inclus_star A S R H0 z x' H7).
Save inclus_conf. *)
Require Import sigma_lift.
(* sigma_lift:
Require Import TS.
Require Import sur_les_relations.

Inductive reg_app : terms -> terms -> Prop :=
    reg1_app :
      forall (a b : terms) (s : sub_explicits),
      reg_app (env (app a b) s) (app (env a s) (env b s)). 
Hint Resolve reg1_app.

Inductive reg_lambda : terms -> terms -> Prop :=
    reg1_lambda :
      forall (a : terms) (s : sub_explicits),
      reg_lambda (env (lambda a) s) (lambda (env a (lift s))). 
Hint Resolve reg1_lambda.

Inductive reg_clos : terms -> terms -> Prop :=
    reg1_clos :
      forall (a : terms) (s t : sub_explicits),
      reg_clos (env (env a s) t) (env a (comp s t)). 
Hint Resolve reg1_clos.

Inductive reg_varshift1 : terms -> terms -> Prop :=
    reg1_varshift1 :
      forall n : nat, reg_varshift1 (env (var n) shift) (var (S n)). 
Hint Resolve reg1_varshift1.

Inductive reg_varshift2 : terms -> terms -> Prop :=
    reg1_varshift2 :
      forall (n : nat) (s : sub_explicits),
      reg_varshift2 (env (var n) (comp shift s)) (env (var (S n)) s). 
Hint Resolve reg1_varshift2.

Inductive reg_fvarcons : terms -> terms -> Prop :=
    reg1_fvarcons :
      forall (a : terms) (s : sub_explicits),
      reg_fvarcons (env (var 0) (cons a s)) a. 
Hint Resolve reg1_fvarcons.

Inductive reg_fvarlift1 : terms -> terms -> Prop :=
    reg1_fvarlift1 :
      forall s : sub_explicits, reg_fvarlift1 (env (var 0) (lift s)) (var 0). 
Hint Resolve reg1_fvarlift1.

Inductive reg_fvarlift2 : terms -> terms -> Prop :=
    reg1_fvarlift2 :
      forall s t : sub_explicits,
      reg_fvarlift2 (env (var 0) (comp (lift s) t)) (env (var 0) t). 
Hint Resolve reg1_fvarlift2.

Inductive reg_rvarcons : terms -> terms -> Prop :=
    reg1_rvarcons :
      forall (n : nat) (a : terms) (s : sub_explicits),
      reg_rvarcons (env (var (S n)) (cons a s)) (env (var n) s). 
Hint Resolve reg1_rvarcons.

Inductive reg_rvarlift1 : terms -> terms -> Prop :=
    reg1_rvarlift1 :
      forall (n : nat) (s : sub_explicits),
      reg_rvarlift1 (env (var (S n)) (lift s)) (env (var n) (comp s shift)). 
Hint Resolve reg1_rvarlift1.

Inductive reg_rvarlift2 : terms -> terms -> Prop :=
    reg1_rvarlift2 :
      forall (n : nat) (s t : sub_explicits),
      reg_rvarlift2 (env (var (S n)) (comp (lift s) t))
        (env (var n) (comp s (comp shift t))). 
Hint Resolve reg1_rvarlift2.

Inductive reg_assenv : sub_explicits -> sub_explicits -> Prop :=
    reg1_assenv :
      forall s t u : sub_explicits,
      reg_assenv (comp (comp s t) u) (comp s (comp t u)). 
Hint Resolve reg1_assenv.

Inductive reg_mapenv : sub_explicits -> sub_explicits -> Prop :=
    reg1_mapenv :
      forall (a : terms) (s t : sub_explicits),
      reg_mapenv (comp (cons a s) t) (cons (env a t) (comp s t)). 
Hint Resolve reg1_mapenv.

Inductive reg_shiftcons : sub_explicits -> sub_explicits -> Prop :=
    reg1_shiftcons :
      forall (a : terms) (s : sub_explicits),
      reg_shiftcons (comp shift (cons a s)) s. 
Hint Resolve reg1_shiftcons.

Inductive reg_shiftlift1 : sub_explicits -> sub_explicits -> Prop :=
    reg1_shiftlift1 :
      forall s : sub_explicits,
      reg_shiftlift1 (comp shift (lift s)) (comp s shift). 
Hint Resolve reg1_shiftlift1.

Inductive reg_shiftlift2 : sub_explicits -> sub_explicits -> Prop :=
    reg1_shiftlift2 :
      forall s t : sub_explicits,
      reg_shiftlift2 (comp shift (comp (lift s) t)) (comp s (comp shift t)). 
Hint Resolve reg1_shiftlift2. 

Inductive reg_lift1 : sub_explicits -> sub_explicits -> Prop :=
    reg1_lift1 :
      forall s t : sub_explicits,
      reg_lift1 (comp (lift s) (lift t)) (lift (comp s t)). 
Hint Resolve reg1_lift1.

Inductive reg_lift2 : sub_explicits -> sub_explicits -> Prop :=
    reg1_lift2 :
      forall s t u : sub_explicits,
      reg_lift2 (comp (lift s) (comp (lift t) u)) (comp (lift (comp s t)) u). 
Hint Resolve reg1_lift2.

Inductive reg_liftenv : sub_explicits -> sub_explicits -> Prop :=
    reg1_liftenv :
      forall (a : terms) (s t : sub_explicits),
      reg_liftenv (comp (lift s) (cons a t)) (cons a (comp s t)). 
Hint Resolve reg1_liftenv.

Inductive reg_idl : sub_explicits -> sub_explicits -> Prop :=
    reg1_idl : forall s : sub_explicits, reg_idl (comp id s) s. 
Hint Resolve reg1_idl.

Inductive reg_idr : sub_explicits -> sub_explicits -> Prop :=
    reg1_idr : forall s : sub_explicits, reg_idr (comp s id) s. 
Hint Resolve reg1_idr.

Inductive reg_liftid : sub_explicits -> sub_explicits -> Prop :=
    reg1_liftid : reg_liftid (lift id) id. 
Hint Resolve reg1_liftid.

Inductive reg_id : terms -> terms -> Prop :=
    reg1_id : forall a : terms, reg_id (env a id) a. 
Hint Resolve reg1_id.

Inductive e_systemSL : forall b : wsort, TS b -> TS b -> Prop :=
  | regle_app : forall a b : terms, reg_app a b -> e_systemSL wt a b
  | regle_lambda : forall a b : terms, reg_lambda a b -> e_systemSL wt a b
  | regle_clos : forall a b : terms, reg_clos a b -> e_systemSL wt a b
  | regle_varshift1 :
      forall a b : terms, reg_varshift1 a b -> e_systemSL wt a b
  | regle_varshift2 :
      forall a b : terms, reg_varshift2 a b -> e_systemSL wt a b
  | regle_fvarcons :
      forall a b : terms, reg_fvarcons a b -> e_systemSL wt a b
  | regle_fvarlift1 :
      forall a b : terms, reg_fvarlift1 a b -> e_systemSL wt a b
  | regle_fvarlift2 :
      forall a b : terms, reg_fvarlift2 a b -> e_systemSL wt a b
  | regle_rvarcons :
      forall a b : terms, reg_rvarcons a b -> e_systemSL wt a b
  | regle_rvarlift1 :
      forall a b : terms, reg_rvarlift1 a b -> e_systemSL wt a b
  | regle_rvarlift2 :
      forall a b : terms, reg_rvarlift2 a b -> e_systemSL wt a b
  | regle_assenv :
      forall s t : sub_explicits, reg_assenv s t -> e_systemSL ws s t
  | regle_mapenv :
      forall s t : sub_explicits, reg_mapenv s t -> e_systemSL ws s t
  | regle_shiftcons :
      forall s t : sub_explicits, reg_shiftcons s t -> e_systemSL ws s t
  | regle_shiftlift1 :
      forall s t : sub_explicits, reg_shiftlift1 s t -> e_systemSL ws s t
  | regle_shiftlift2 :
      forall s t : sub_explicits, reg_shiftlift2 s t -> e_systemSL ws s t
  | regle_lift1 :
      forall s t : sub_explicits, reg_lift1 s t -> e_systemSL ws s t
  | regle_lift2 :
      forall s t : sub_explicits, reg_lift2 s t -> e_systemSL ws s t
  | regle_liftenv :
      forall s t : sub_explicits, reg_liftenv s t -> e_systemSL ws s t
  | regle_idl : forall s t : sub_explicits, reg_idl s t -> e_systemSL ws s t
  | regle_idr : forall s t : sub_explicits, reg_idr s t -> e_systemSL ws s t
  | regle_liftid :
      forall s t : sub_explicits, reg_liftid s t -> e_systemSL ws s t
  | regle_id : forall a b : terms, reg_id a b -> e_systemSL wt a b.

Notation systemSL := (e_systemSL _) (only parsing).

Hint Resolve regle_app regle_lambda regle_clos regle_varshift1
  regle_varshift2 regle_fvarcons regle_fvarlift1 regle_fvarlift2
  regle_rvarcons regle_rvarlift1 regle_rvarlift2 regle_assenv regle_mapenv
  regle_shiftcons regle_shiftlift1 regle_shiftlift2 regle_lift1 regle_lift2
  regle_liftenv regle_idl regle_idr regle_liftid regle_id.

Inductive e_relSL : forall b : wsort, TS b -> TS b -> Prop :=
  | SL_one_regle :
      forall (b : wsort) (M N : TS b), e_systemSL _ M N -> e_relSL b M N
  | SL_context_app_l :
      forall a a' b : terms,
      e_relSL wt a a' -> e_relSL wt (app a b) (app a' b)
  | SL_context_app_r :
      forall a b b' : terms,
      e_relSL wt b b' -> e_relSL wt (app a b) (app a b')
  | SL_context_lambda :
      forall a a' : terms,
      e_relSL wt a a' -> e_relSL wt (lambda a) (lambda a')
  | SL_context_env_t :
      forall (a a' : terms) (s : sub_explicits),
      e_relSL wt a a' -> e_relSL wt (env a s) (env a' s)
  | SL_context_env_s :
      forall (a : terms) (s s' : sub_explicits),
      e_relSL ws s s' -> e_relSL wt (env a s) (env a s')
  | SL_context_cons_t :
      forall (a a' : terms) (s : sub_explicits),
      e_relSL wt a a' -> e_relSL ws (cons a s) (cons a' s)
  | SL_context_cons_s :
      forall (a : terms) (s s' : sub_explicits),
      e_relSL ws s s' -> e_relSL ws (cons a s) (cons a s')
  | SL_context_comp_l :
      forall s s' t : sub_explicits,
      e_relSL ws s s' -> e_relSL ws (comp s t) (comp s' t)
  | SL_context_comp_r :
      forall s t t' : sub_explicits,
      e_relSL ws t t' -> e_relSL ws (comp s t) (comp s t')
  | SL_context_lift :
      forall s s' : sub_explicits,
      e_relSL ws s s' -> e_relSL ws (lift s) (lift s').

Notation relSL := (e_relSL _) (only parsing).

Hint Resolve SL_one_regle SL_context_app_l SL_context_app_r SL_context_lambda
  SL_context_env_t SL_context_env_s SL_context_cons_t SL_context_cons_s
  SL_context_comp_l SL_context_comp_r SL_context_lift.

Definition e_relSLstar (b : wsort) := explicit_star _ (e_relSL b).

Notation relSLstar := (e_relSLstar _) (only parsing).

Hint Unfold e_relSLstar.

Goal
forall a a' b : terms,
e_relSLstar _ a a' -> e_relSLstar _ (app a b) (app a' b).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (app y b); auto.
Save SLstar_context_app_l.
Hint Resolve SLstar_context_app_l.

Goal
forall a b b' : terms,
e_relSLstar _ b b' -> e_relSLstar _ (app a b) (app a b').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (app a y); auto.
Save SLstar_context_app_r.
Hint Resolve SLstar_context_app_r.

Goal
forall a a' : terms,
e_relSLstar _ a a' -> e_relSLstar _ (lambda a) (lambda a').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (lambda y); auto.
Save SLstar_context_lambda.
Hint Resolve SLstar_context_lambda.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relSLstar _ a a' -> e_relSLstar _ (env a s) (env a' s).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (env y s); auto.
Save SLstar_context_env_t.
Hint Resolve SLstar_context_env_t.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relSLstar _ s s' -> e_relSLstar _ (env a s) (env a s').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (env a y); auto.
Save SLstar_context_env_s.
Hint Resolve SLstar_context_env_s.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relSLstar _ a a' -> e_relSLstar _ (cons a s) (cons a' s). 
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (cons y s); auto.
Save SLstar_context_cons_t.
Hint Resolve SLstar_context_cons_t.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relSLstar _ s s' -> e_relSLstar _ (cons a s) (cons a s'). 
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (cons a y); auto.
Save SLstar_context_cons_s.
Hint Resolve SLstar_context_cons_s.

Goal
forall s s' t : sub_explicits,
e_relSLstar _ s s' -> e_relSLstar _ (comp s t) (comp s' t).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (comp y t); auto.
Save SLstar_context_comp_l.
Hint Resolve SLstar_context_comp_l.

Goal
forall s t t' : sub_explicits,
e_relSLstar _ t t' -> e_relSLstar _ (comp s t) (comp s t').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (comp s y); auto.
Save SLstar_context_comp_r.
Hint Resolve SLstar_context_comp_r.

Goal
forall s s' : sub_explicits,
e_relSLstar _ s s' -> e_relSLstar _ (lift s) (lift s').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (lift y); auto.
Save SLstar_context_lift.
Hint Resolve SLstar_context_lift. *)
Require Import determinePC_SL.
(* determinePC_SL:
Require Import TS.
Require Import sur_les_relations.
Require Import egaliteTS.
Require Import sigma_lift.
Require Import inversionSL.

Goal forall (n : nat) (M : terms), ~ e_relSL _ (var n) M.
red in |- *; intros n M H; cut (e_invSL _ (var n) M).
2: auto.
simple induction 1.
Save case_SLvar.

Goal
forall (P : terms -> Prop) (a b : terms),
(forall a' : terms, e_relSL _ a a' -> P (app a' b)) ->
(forall b' : terms, e_relSL _ b b' -> P (app a b')) ->
forall M : terms, e_relSL _ (app a b) M -> P M.
intros P a b H H0 M H1; cut (e_invSL _ (app a b) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.

simple induction 3; simple induction 1; intros.
elim H7; apply H; assumption.
elim H6; apply H0; assumption.

simple induction 2.

simple induction 2.

simple induction 1.
Save case_SLapp.

Goal
forall (P : terms -> Prop) (a : terms),
(forall a' : terms, e_relSL _ a a' -> P (lambda a')) ->
forall M : terms, e_relSL _ (lambda a) M -> P M.
intros P a H M H0; cut (e_invSL _ (lambda a) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.

simple induction 3.

unfold e_invSL at 2 in |- *; intros; apply H; assumption.

simple induction 2.

simple induction 1.
Save case_SLlambda.

Goal
forall (P : terms -> sub_explicits -> terms -> Prop) 
  (a : terms) (s : sub_explicits),
(forall a1 b1 : terms, P (app a1 b1) s (app (env a1 s) (env b1 s))) ->
(forall a1 : terms, P (lambda a1) s (lambda (env a1 (lift s)))) ->
(forall (a1 : terms) (s1 : sub_explicits),
 P (env a1 s1) s (env a1 (comp s1 s))) ->
(forall n : nat, P (var n) shift (var (S n))) ->
(forall (n : nat) (s1 : sub_explicits),
 P (var n) (comp shift s1) (env (var (S n)) s1)) ->
(forall (a1 : terms) (s1 : sub_explicits), P (var 0) (cons a1 s1) a1) ->
(forall s1 : sub_explicits, P (var 0) (lift s1) (var 0)) ->
(forall s1 s2 : sub_explicits, P (var 0) (comp (lift s1) s2) (env (var 0) s2)) ->
(forall (n : nat) (a1 : terms) (s1 : sub_explicits),
 P (var (S n)) (cons a1 s1) (env (var n) s1)) ->
(forall (n : nat) (s1 : sub_explicits),
 P (var (S n)) (lift s1) (env (var n) (comp s1 shift))) ->
(forall (n : nat) (s1 s2 : sub_explicits),
 P (var (S n)) (comp (lift s1) s2) (env (var n) (comp s1 (comp shift s2)))) ->
P a id a ->
(forall a' : terms, e_relSL _ a a' -> P a s (env a' s)) ->
(forall s' : sub_explicits, e_relSL _ s s' -> P a s (env a s')) ->
forall M : terms, e_relSL _ (env a s) M -> P a s M.
intros P a s; intros; cut (e_invSL _ (env a s) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.
 
do 2 simple induction 1; simple induction 2; intros.
rewrite H20; rewrite H19; rewrite H17; apply H2.
 
simple induction 1.
do 2 simple induction 1; simple induction 2; intros.
rewrite H21; rewrite H20; rewrite H18; apply H5.
 
simple induction 1.
do 2 simple induction 1; intros.
rewrite H20; rewrite H19; apply H4.
 
simple induction 1; intros.
elim H18; rewrite H19; apply H10.

simple induction 3.
do 3 simple induction 1; simple induction 2; intros.
rewrite H23; rewrite H22; rewrite H20; apply H.
 
simple induction 1.
do 2 simple induction 1; intros.
rewrite H21; rewrite H20; apply H4.
 
simple induction 1; intros.
rewrite H20; elim H19; apply H10.

simple induction 2.
do 2 simple induction 1; intros.
rewrite H19; rewrite H18; apply H0.
 
simple induction 1.
do 2 simple induction 1; intros.
rewrite H20; rewrite H19; apply H4.
 
simple induction 1; intros.
rewrite H19; elim H18; apply H10.

simple induction 2.
do 2 simple induction 1; intros.
rewrite H19; rewrite H18; apply H1.
 
simple induction 1.
do 2 simple induction 1; simple induction 2; intros.
rewrite H22; rewrite H21; rewrite H19; apply H3.
  
simple induction 1.
do 2 simple induction 1; intros.
rewrite H21; rewrite H20; apply H4.
 
simple induction 1.
do 2 simple induction 1; simple induction 2; intros.
rewrite H24; rewrite H23; rewrite H21; apply H6.
 
simple induction 1.
do 3 simple induction 1; simple induction 2; intros.
rewrite H26; rewrite H25; rewrite H23; apply H7.
 
simple induction 1.
do 3 simple induction 1; do 2 simple induction 2; intros.
rewrite H29; rewrite H28; rewrite H26; rewrite H24; apply H8.
 
simple induction 1.
do 4 simple induction 1; do 2 simple induction 2; intros.
rewrite H31; rewrite H30; rewrite H28; rewrite H26; apply H9.
 
simple induction 1.
simple induction 1; intros.
rewrite H25; elim H24; apply H10.
 
simple induction 1.
simple induction 1; intros.
elim H26; apply H11; assumption.
 
simple induction 1.
simple induction 1; intros.
elim H25; apply H12; assumption.

simple induction 1.
 
do 2 simple induction 1; intros.
rewrite H18; rewrite H17; apply H4.
 
simple induction 1; intros.
elim H16; rewrite H17; assumption.
Save case_SLenv.

Goal forall M : sub_explicits, ~ e_relSL _ id M.
red in |- *; intros M H; cut (e_invSL _ id M).
2: auto.
simple induction 1.
Save case_SLid.

Goal forall M : sub_explicits, ~ e_relSL _ shift M.
red in |- *; intros M H; cut (e_invSL _ shift M).
2: auto.
simple induction 1.
Save case_SLshift.

Goal
forall (P : sub_explicits -> Prop) (a : terms) (s : sub_explicits),
(forall a' : terms, e_relSL _ a a' -> P (cons a' s)) ->
(forall s' : sub_explicits, e_relSL _ s s' -> P (cons a s')) ->
forall M : sub_explicits, e_relSL _ (cons a s) M -> P M.
intros P a s H H0 M H1; cut (e_invSL _ (cons a s) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.

simple induction 1.

simple induction 2; simple induction 1; intros.
elim H6; apply H; assumption.
elim H5; apply H0; assumption.

simple induction 3.

simple induction 2.

simple induction 1.
Save case_SLcons.

Goal
forall (P : sub_explicits -> sub_explicits -> sub_explicits -> Prop)
  (s t : sub_explicits),
(forall s1 s2 : sub_explicits, P (comp s1 s2) t (comp s1 (comp s2 t))) ->
(forall (a : terms) (s1 : sub_explicits),
 P (cons a s1) t (cons (env a t) (comp s1 t))) ->
(forall (a : terms) (t1 : sub_explicits), P shift (cons a t1) t1) ->
(forall t1 : sub_explicits, P shift (lift t1) (comp t1 shift)) ->
(forall t1 t2 : sub_explicits,
 P shift (comp (lift t1) t2) (comp t1 (comp shift t2))) ->
(forall s1 t1 : sub_explicits, P (lift s1) (lift t1) (lift (comp s1 t1))) ->
(forall s1 t1 t2 : sub_explicits,
 P (lift s1) (comp (lift t1) t2) (comp (lift (comp s1 t1)) t2)) ->
(forall (a : terms) (s1 t1 : sub_explicits),
 P (lift s1) (cons a t1) (cons a (comp s1 t1))) ->
P id t t ->
P s id s ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s t (comp s' t)) ->
(forall t' : sub_explicits, e_relSL _ t t' -> P s t (comp s t')) ->
forall M : sub_explicits, e_relSL _ (comp s t) M -> P s t M.
intros P s t; intros; cut (e_invSL _ (comp s t) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.
do 2 simple induction 1; intros.
rewrite H15; rewrite H16; apply H1.
 
simple induction 1; intros.
rewrite H14; pattern id at 2 in |- *; elim H15; apply H7.

simple induction 1.
do 2 simple induction 1; intros.
rewrite H15; rewrite H16; apply H1.
 
simple induction 1.
simple induction 1; intros.
rewrite H15; elim H16; apply H7.
 
simple induction 1; intros.
rewrite H16; elim H15; apply H8.

simple induction 2.
do 3 simple induction 1; simple induction 2; intros.
rewrite H17; rewrite H20; rewrite H19; apply H0.
 
simple induction 1.
do 2 simple induction 1; intros.
rewrite H17; rewrite H18; apply H1.
 
simple induction 1.
do 3 simple induction 1; simple induction 2; intros.
rewrite H22; rewrite H21; rewrite H19; apply H6.
 
simple induction 1.
simple induction 1; intros.
rewrite H18; elim H19; apply H7.
 
simple induction 1; intros.
rewrite H19; elim H18; apply H8.

simple induction 3.
 
do 2 simple induction 1; intros.
rewrite H18; rewrite H17; apply H.
 
simple induction 1.
do 2 simple induction 1; intros.
rewrite H18; rewrite H19; apply H1.
 
simple induction 1.
simple induction 1; simple induction 2; intros.
rewrite H21; rewrite H20; rewrite H18; apply H2.
 
simple induction 1.
do 2 simple induction 1; simple induction 2; intros.
rewrite H23; rewrite H22; rewrite H20; apply H3.
 
simple induction 1.
do 3 simple induction 1; simple induction 2; intros.
rewrite H25; rewrite H24; rewrite H22; apply H5.
 
simple induction 1.
simple induction 1; intros.
rewrite H21; elim H22; apply H7.
 
simple induction 1.
simple induction 1; intros.
rewrite H23; elim H22; apply H8.
 
simple induction 1.
simple induction 1; intros.
elim H24; apply H9; assumption.
 
simple induction 1; intros.
elim H23; apply H10; assumption.

simple induction 2.
 
do 2 simple induction 1; intros.
rewrite H17; rewrite H16; apply H1.
 
simple induction 1.
do 3 simple induction 1; simple induction 2; intros.
rewrite H21; rewrite H20; rewrite H18; apply H4.
 
simple induction 1.
simple induction 1; intros.
rewrite H17; elim H18; apply H7.
 
simple induction 1; intros.
rewrite H18; elim H17; apply H8.

simple induction 1.
do 2 simple induction 1; intros.
rewrite H15; rewrite H16; apply H1.
 
simple induction 1.
simple induction 1; intros.
rewrite H15; elim H16; apply H7.
 
simple induction 1; intros.
rewrite H16; elim H15; apply H8.
Save case_SLcomp.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) (s : sub_explicits),
P id id ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s (lift s')) ->
forall M : sub_explicits, e_relSL _ (lift s) M -> P s M.
intros P s H H0 M H1; cut (e_invSL _ (lift s) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simpl in |- *; intro H2; rewrite H2; assumption.

simple induction 1.

simple induction 2.

simple induction 3.

unfold e_invSL at 2 in |- *; intros; apply H0; assumption.

simple induction 1.
Save case_SLlift.

Goal
forall (P : sub_explicits -> terms -> Prop) (a : terms) (s : sub_explicits),
P s (lambda (env a (lift s))) ->
P id (lambda a) ->
(forall x' : terms, e_relSL _ (lambda a) x' -> P s (env x' s)) ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s (env (lambda a) s')) ->
forall M : terms, e_relSL _ (env (lambda a) s) M -> P s M.
intros.
cut (lambda a = lambda a).
2: auto.
pattern (lambda a) at 1, s, M in |- *; apply case_SLenv; intros.
15: assumption.
elim (diff_app_lambda a1 b1 a H4).

rewrite (proj_lambda a1 a H4); assumption.
elim (diff_lambda_env a a1 s1 (sym_equal H4)).
elim (diff_var_lambda n a H4).
elim (diff_var_lambda n a H4).
elim (diff_var_lambda 0 a H4).
elim (diff_var_lambda 0 a H4).
elim (diff_var_lambda 0 a H4).
elim (diff_var_lambda (S n) a H4).
elim (diff_var_lambda (S n) a H4).
elim (diff_var_lambda (S n) a H4).

assumption.

apply H1; assumption.

apply H2; assumption.
Save case_SL_reg_lambda.

Goal
forall (P : sub_explicits -> terms -> Prop) (a b : terms) (s : sub_explicits),
P s (app (env a s) (env b s)) ->
P id (app a b) ->
(forall x' : terms, e_relSL _ (app a b) x' -> P s (env x' s)) ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s (env (app a b) s')) ->
forall M : terms, e_relSL _ (env (app a b) s) M -> P s M.
intros.
cut (app a b = app a b).
2: auto.
pattern (app a b) at 1, s, M in |- *; apply case_SLenv; intros.
15: assumption.

rewrite (proj_app1 a1 b1 a b H4); rewrite (proj_app2 a1 b1 a b H4);
 assumption.
elim (diff_app_lambda a b a1 (sym_equal H4)).
elim (diff_app_env a b a1 s1 (sym_equal H4)).
elim (diff_var_app n a b H4).
elim (diff_var_app n a b H4).
elim (diff_var_app 0 a b H4).
elim (diff_var_app 0 a b H4).
elim (diff_var_app 0 a b H4).
elim (diff_var_app (S n) a b H4).
elim (diff_var_app (S n) a b H4).
elim (diff_var_app (S n) a b H4).

assumption.

apply H1; assumption.

apply H2; assumption.
Save case_SL_reg_app.

Goal
forall (P : sub_explicits -> terms -> Prop) (a : terms) (s t : sub_explicits),
P t (env a (comp s t)) ->
P id (env a s) ->
(forall x' : terms, e_relSL _ (env a s) x' -> P t (env x' t)) ->
(forall t' : sub_explicits, e_relSL _ t t' -> P t (env (env a s) t')) ->
forall M : terms, e_relSL _ (env (env a s) t) M -> P t M.
intros.
cut (env a s = env a s).
2: auto.
pattern (env a s) at 1, t, M in |- *; apply case_SLenv; intros.
15: assumption.
elim (diff_app_env a1 b1 a s H4).
elim (diff_lambda_env a1 a s H4).

rewrite (proj_env1 a1 a s1 s H4); rewrite (proj_env2 a1 a s1 s H4).
assumption.
elim (diff_var_env n a s H4).
elim (diff_var_env n a s H4).
elim (diff_var_env 0 a s H4).
elim (diff_var_env 0 a s H4).
elim (diff_var_env 0 a s H4).
elim (diff_var_env (S n) a s H4).
elim (diff_var_env (S n) a s H4).
elim (diff_var_env (S n) a s H4).

assumption.

apply H1; assumption.

apply H2; assumption.
Save case_SL_clos.

Goal
forall (P : terms -> Prop) (n : nat),
P (var (S n)) -> forall M : terms, e_relSL _ (env (var n) shift) M -> P M.
intros.
cut (var n = var n).
2: auto.
cut (shift = shift).
2: auto.
pattern (var n) at 1, shift at 1, M in |- *; apply case_SLenv; intros.
15: assumption.
elim (diff_var_app n a1 b1 (sym_equal H2)).
elim (diff_var_lambda n a1 (sym_equal H2)).
elim (diff_var_env n a1 s1 (sym_equal H2)).

rewrite (proj_var n0 n H2); assumption.
elim (diff_shift_comp shift s1 (sym_equal H1)).
elim (diff_shift_cons a1 s1 (sym_equal H1)).
elim (diff_shift_lift s1 (sym_equal H1)).
elim (diff_shift_comp (lift s1) s2 (sym_equal H1)).
elim (diff_shift_cons a1 s1 (sym_equal H1)).
elim (diff_shift_lift s1 (sym_equal H1)).
elim (diff_shift_comp (lift s1) s2 (sym_equal H1)).
elim (diff_id_shift H1).
elim (case_SLvar n a' H1).
elim (case_SLshift s' H1).
Save case_SL_varshift1.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) (s : sub_explicits),
(forall (a : terms) (s1 : sub_explicits), P (cons a s1) s1) ->
(forall s1 : sub_explicits, P (lift s1) (comp s1 shift)) ->
(forall s1 t : sub_explicits, P (comp (lift s1) t) (comp s1 (comp shift t))) ->
P id shift ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s (comp shift s')) ->
forall M : sub_explicits, e_relSL _ (comp shift s) M -> P s M.
intros.
cut (shift = shift).
2: auto.
pattern shift at 1, s, M in |- *; apply case_SLcomp; intros.
13: assumption.
elim (diff_shift_comp s1 s2 (sym_equal H5)).
elim (diff_shift_cons a s1 (sym_equal H5)).

apply H.

apply H0.

apply H1.
elim (diff_shift_lift s1 (sym_equal H5)).
elim (diff_shift_lift s1 (sym_equal H5)).
elim (diff_shift_lift s1 (sym_equal H5)).
elim (diff_id_shift H5).

assumption.
elim (case_SLshift s' H5).

apply H3; assumption.
Save case_SLcomp1.

Goal
forall (P : terms -> Prop) (n : nat) (s : sub_explicits),
P (env (var (S n)) s) ->
(forall x' : sub_explicits, e_relSL _ (comp shift s) x' -> P (env (var n) x')) ->
forall M : terms, e_relSL _ (env (var n) (comp shift s)) M -> P M.
intros.
cut (var n = var n).
2: auto.
cut (comp shift s = comp shift s).
2: auto.
pattern (var n) at 1, (comp shift s) at 1, M in |- *; apply case_SLenv;
 intros.
15: assumption.
elim (diff_var_app n a1 b1 (sym_equal H3)).
elim (diff_var_lambda n a1 (sym_equal H3)).
elim (diff_var_env n a1 s1 (sym_equal H3)).
elim (diff_shift_comp shift s H2).

rewrite (proj_var n0 n H3); rewrite (proj_comp2 shift shift s1 s H2);
 assumption.
elim (diff_cons_comp a1 s1 shift s H2).
elim (diff_comp_lift shift s s1 (sym_equal H2)).
elim
                (diff_shift_lift s1
                   (sym_equal (proj_comp1 (lift s1) shift s2 s H2))).
elim (diff_cons_comp a1 s1 shift s H2).
elim (diff_comp_lift shift s s1 (sym_equal H2)).
elim
                (diff_shift_lift s1
                   (sym_equal (proj_comp1 (lift s1) shift s2 s H2))).
elim (diff_id_comp shift s H2).
elim (case_SLvar n a' H2).
apply H0; assumption.
Save case_SL_varshift2.

Goal
forall (P : terms -> Prop) (a : terms) (s : sub_explicits),
P a ->
(forall x' : sub_explicits, e_relSL _ (cons a s) x' -> P (env (var 0) x')) ->
forall M : terms, e_relSL _ (env (var 0) (cons a s)) M -> P M.
intros.
cut (var 0 = var 0).
2: auto.
cut (cons a s = cons a s).
2: auto.
pattern (var 0) at 1, (cons a s) at 1, M in |- *; apply case_SLenv; intros.
15: assumption.
elim (diff_var_app 0 a1 b1 (sym_equal H3)).
elim (diff_var_lambda 0 a1 (sym_equal H3)).
elim (diff_var_env 0 a1 s1 (sym_equal H3)).
elim (diff_shift_cons a s H2).
elim (diff_cons_comp a s shift s1 (sym_equal H2)).
rewrite (proj_cons1 a1 a s1 s H2); assumption.
elim (diff_cons_lift a s s1 (sym_equal H2)).
elim (diff_cons_comp a s (lift s1) s2 (sym_equal H2)).
elim (O_S n (sym_equal (proj_var (S n) 0 H3))).
elim (diff_cons_lift a s s1 (sym_equal H2)).
elim (O_S n (sym_equal (proj_var (S n) 0 H3))).
elim (diff_id_cons a s H2).
elim (case_SLvar 0 a' H2).
apply H0; assumption.
Save case_SL_fvarcons.

Goal
forall (P : terms -> Prop) (s : sub_explicits),
P (var 0) ->
(forall x' : sub_explicits, e_relSL _ (lift s) x' -> P (env (var 0) x')) ->
forall M : terms, e_relSL _ (env (var 0) (lift s)) M -> P M.
intros.
cut (var 0 = var 0).
2: auto.
cut (lift s = lift s).
2: auto.
pattern (var 0) at 1, (lift s) at 1, M in |- *; apply case_SLenv; intros.
15: assumption.
elim (diff_var_app 0 a1 b1 (sym_equal H3)).
elim (diff_var_lambda 0 a1 (sym_equal H3)).
elim (diff_var_env 0 a1 s1 (sym_equal H3)).
elim (diff_shift_lift s H2).
elim (diff_comp_lift shift s1 s H2).
elim (diff_cons_lift a1 s1 s H2).
assumption.
elim (diff_comp_lift (lift s1) s2 s H2).
elim (diff_cons_lift a1 s1 s H2).
elim (O_S n (sym_equal (proj_var (S n) 0 H3))).
elim (diff_comp_lift (lift s1) s2 s H2).
elim (diff_id_lift s H2).
elim (case_SLvar 0 a' H2).
apply H0; assumption.
Save case_SL_fvarlift1.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) (s t : sub_explicits),
(forall t1 : sub_explicits, P (lift t1) (lift (comp s t1))) ->
(forall t1 t2 : sub_explicits,
 P (comp (lift t1) t2) (comp (lift (comp s t1)) t2)) ->
(forall (a : terms) (t1 : sub_explicits), P (cons a t1) (cons a (comp s t1))) ->
P id (lift s) ->
(forall x' : sub_explicits, e_relSL _ (lift s) x' -> P t (comp x' t)) ->
(forall t' : sub_explicits, e_relSL _ t t' -> P t (comp (lift s) t')) ->
forall M : sub_explicits, e_relSL _ (comp (lift s) t) M -> P t M.
intros.
cut (lift s = lift s).
2: auto.
pattern (lift s) at 1, t, M in |- *; apply case_SLcomp; intros.
13: assumption.
elim (diff_comp_lift s1 s2 s H6).
elim (diff_cons_lift a s1 s H6).
elim (diff_shift_lift s H6).
elim (diff_shift_lift s H6).
elim (diff_shift_lift s H6).

rewrite (proj_lift s1 s H6); apply H.

rewrite (proj_lift s1 s H6); apply H0.

rewrite (proj_lift s1 s H6); apply H1.
elim (diff_id_lift s H6).

assumption.

apply H3; assumption.

apply H4; assumption.
Save case_SLcomp2.

Goal
forall (P : terms -> Prop) (s t : sub_explicits),
P (env (var 0) t) ->
(forall x' : sub_explicits,
 e_relSL _ (comp (lift s) t) x' -> P (env (var 0) x')) ->
forall M : terms, e_relSL _ (env (var 0) (comp (lift s) t)) M -> P M.
intros.
cut (var 0 = var 0).
2: auto.
cut (comp (lift s) t = comp (lift s) t).
2: auto.
pattern (var 0) at 1, (comp (lift s) t) at 1, M in |- *; apply case_SLenv;
 intros.
15: assumption.
elim (diff_var_app 0 a1 b1 (sym_equal H3)).
elim (diff_var_lambda 0 a1 (sym_equal H3)).
elim (diff_var_env 0 a1 s1 (sym_equal H3)).
elim (diff_shift_comp (lift s) t H2).
elim (diff_shift_lift s (proj_comp1 shift (lift s) s1 t H2)).
elim (diff_cons_comp a1 s1 (lift s) t H2).
elim (diff_comp_lift (lift s) t s1 (sym_equal H2)).

rewrite (proj_comp2 (lift s1) (lift s) s2 t H2); assumption.
elim (diff_cons_comp a1 s1 (lift s) t H2).
elim (diff_comp_lift (lift s) t s1 (sym_equal H2)).
elim (O_S n (sym_equal (proj_var (S n) 0 H3))).
elim (diff_id_comp (lift s) t H2).
elim (case_SLvar 0 a' H2).
apply H0; assumption.
Save case_SL_fvarlift2.

Goal
forall (P : terms -> Prop) (n : nat) (a : terms) (s : sub_explicits),
P (env (var n) s) ->
(forall x' : sub_explicits, e_relSL _ (cons a s) x' -> P (env (var (S n)) x')) ->
forall M : terms, e_relSL _ (env (var (S n)) (cons a s)) M -> P M.
intros P n a s H H0 M H1.
cut (var (S n) = var (S n)).
2: auto.
cut (cons a s = cons a s).
2: auto.
pattern (var (S n)) at 1, (cons a s) at 1, M in |- *; apply case_SLenv;
 intros.
15: assumption.
elim (diff_var_app (S n) a1 b1 (sym_equal H3)).
elim (diff_var_lambda (S n) a1 (sym_equal H3)).
elim (diff_var_env (S n) a1 s1 (sym_equal H3)).
elim (diff_shift_cons a s H2).
elim (diff_cons_comp a s shift s1 (sym_equal H2)).
elim (O_S n (proj_var 0 (S n) H3)).
elim (diff_cons_lift a s s1 (sym_equal H2)).
elim (diff_cons_comp a s (lift s1) s2 (sym_equal H2)).

rewrite (eq_add_S n0 n (proj_var (S n0) (S n) H3)).
rewrite (proj_cons2 a1 a s1 s H2); assumption.
elim (diff_cons_lift a s s1 (sym_equal H2)).
elim (diff_cons_comp a s (lift s1) s2 (sym_equal H2)).
elim (diff_id_cons a s H2).
elim (case_SLvar (S n) a' H2).
apply H0; assumption.
Save case_SL_rvarcons.

Goal
forall (P : terms -> Prop) (n : nat) (s : sub_explicits),
P (env (var n) (comp s shift)) ->
(forall x' : sub_explicits, e_relSL _ (lift s) x' -> P (env (var (S n)) x')) ->
forall M : terms, e_relSL _ (env (var (S n)) (lift s)) M -> P M.
intros P n s H H0 M H1.
cut (var (S n) = var (S n)).
2: auto.
cut (lift s = lift s).
2: auto.
pattern (var (S n)) at 1, (lift s) at 1, M in |- *; apply case_SLenv; intros.
15: assumption.
elim (diff_var_app (S n) a1 b1 (sym_equal H3)).
elim (diff_var_lambda (S n) a1 (sym_equal H3)).
elim (diff_var_env (S n) a1 s1 (sym_equal H3)).
elim (diff_shift_lift s H2).
elim (diff_comp_lift shift s1 s H2).
elim (O_S n (proj_var 0 (S n) H3)).
elim (O_S n (proj_var 0 (S n) H3)).
elim (O_S n (proj_var 0 (S n) H3)).
elim (diff_cons_lift a1 s1 s H2).

rewrite (eq_add_S n0 n (proj_var (S n0) (S n) H3)).
rewrite (proj_lift s1 s H2); assumption.
elim (diff_comp_lift (lift s1) s2 s H2).                   
elim (diff_id_lift s H2).
elim (case_SLvar (S n) a' H2).
apply H0; assumption.
Save case_SL_rvarlift1.

Goal
forall (P : terms -> Prop) (n : nat) (s t : sub_explicits),
P (env (var n) (comp s (comp shift t))) ->
(forall x' : sub_explicits,
 e_relSL _ (comp (lift s) t) x' -> P (env (var (S n)) x')) ->
forall M : terms, e_relSL _ (env (var (S n)) (comp (lift s) t)) M -> P M.
intros P n s t H H0 M H1.
cut (var (S n) = var (S n)).
2: auto.
cut (comp (lift s) t = comp (lift s) t).
2: auto.
pattern (var (S n)) at 1, (comp (lift s) t) at 1, M in |- *; apply case_SLenv;
 intros.
15: assumption.
elim (diff_var_app (S n) a1 b1 (sym_equal H3)).
elim (diff_var_lambda (S n) a1 (sym_equal H3)).
elim (diff_var_env (S n) a1 s1 (sym_equal H3)).
elim (diff_shift_comp (lift s) t H2).
elim (diff_shift_lift s (proj_comp1 shift (lift s) s1 t H2)).
elim (diff_cons_comp a1 s1 (lift s) t H2).
elim (diff_comp_lift (lift s) t s1 (sym_equal H2)).
elim (O_S n (proj_var 0 (S n) H3)).
elim (diff_cons_comp a1 s1 (lift s) t H2).
elim (diff_comp_lift (lift s) t s1 (sym_equal H2)).

rewrite (eq_add_S n0 n (proj_var (S n0) (S n) H3)).
rewrite (proj_lift s1 s (proj_comp1 (lift s1) (lift s) s2 t H2)).
rewrite (proj_comp2 (lift s1) (lift s) s2 t H2); assumption.
elim (diff_id_comp (lift s) t H2).
elim (case_SLvar (S n) a' H2).
apply H0; assumption.
Save case_SL_rvarlift2.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) (s t u : sub_explicits),
P u (comp s (comp t u)) ->
P id (comp s t) ->
(forall x' : sub_explicits, e_relSL _ (comp s t) x' -> P u (comp x' u)) ->
(forall u' : sub_explicits, e_relSL _ u u' -> P u (comp (comp s t) u')) ->
forall M : sub_explicits, e_relSL _ (comp (comp s t) u) M -> P u M. 
intros P s t u H H0 H1 H2 M H3.
cut (comp s t = comp s t).
2: auto.
pattern (comp s t) at 1, u, M in |- *; apply case_SLcomp; intros.
13: assumption.

rewrite (proj_comp1 s1 s s2 t H4).
rewrite (proj_comp2 s1 s s2 t H4); assumption.
elim (diff_cons_comp a s1 s t H4).
elim (diff_shift_comp s t H4).
elim (diff_shift_comp s t H4).
elim (diff_shift_comp s t H4).
elim (diff_comp_lift s t s1 (sym_equal H4)).
elim (diff_comp_lift s t s1 (sym_equal H4)).
elim (diff_comp_lift s t s1 (sym_equal H4)).
elim (diff_id_comp s t H4).

assumption.

apply H1; assumption.

apply H2; assumption.
Save case_SL_assenv.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) 
  (a : terms) (s t : sub_explicits),
P t (cons (env a t) (comp s t)) ->
P id (cons a s) ->
(forall x' : sub_explicits, e_relSL _ (cons a s) x' -> P t (comp x' t)) ->
(forall t' : sub_explicits, e_relSL _ t t' -> P t (comp (cons a s) t')) ->
forall M : sub_explicits, e_relSL _ (comp (cons a s) t) M -> P t M. 
intros P a s t H H0 H1 H2 M H3.
cut (cons a s = cons a s).
2: auto.
pattern (cons a s) at 1, t, M in |- *; apply case_SLcomp; intros.
13: assumption.
elim (diff_cons_comp a s s1 s2 (sym_equal H4)).

rewrite (proj_cons1 a0 a s1 s H4).
rewrite (proj_cons2 a0 a s1 s H4); assumption.
elim (diff_shift_cons a s H4).
elim (diff_shift_cons a s H4).
elim (diff_shift_cons a s H4).
elim (diff_cons_lift a s s1 (sym_equal H4)).
elim (diff_cons_lift a s s1 (sym_equal H4)).
elim (diff_cons_lift a s s1 (sym_equal H4)).
elim (diff_id_cons a s H4).

assumption.

apply H1; assumption.

apply H2; assumption.
Save case_SL_mapenv.

Goal
forall (P : sub_explicits -> Prop) (a : terms) (s : sub_explicits),
P s ->
(forall x' : sub_explicits, e_relSL _ (cons a s) x' -> P (comp shift x')) ->
forall M : sub_explicits, e_relSL _ (comp shift (cons a s)) M -> P M. 
intros P a s H H0 M H1.
cut (cons a s = cons a s).
2: auto.
pattern (cons a s) at 1, M in |- *; apply case_SLcomp1; intros.
6: assumption.

rewrite (proj_cons2 a0 a s1 s H2); assumption.
elim (diff_cons_lift a s s1 (sym_equal H2)).
elim (diff_cons_comp a s (lift s1) t (sym_equal H2)).
elim (diff_id_cons a s H2).

apply H0; assumption.
Save case_SL_shiftcons.
 
Goal
forall (P : sub_explicits -> Prop) (s : sub_explicits),
P (comp s shift) ->
(forall x' : sub_explicits, e_relSL _ (lift s) x' -> P (comp shift x')) ->
forall M : sub_explicits, e_relSL _ (comp shift (lift s)) M -> P M. 
intros P s H H0 M H1.
cut (lift s = lift s).
2: auto.
pattern (lift s) at 1, M in |- *; apply case_SLcomp1; intros.
6: assumption.
elim (diff_cons_lift a s1 s H2).

rewrite (proj_lift s1 s H2); assumption.
elim (diff_comp_lift (lift s1) t s H2).
elim (diff_id_lift s H2).

apply H0; assumption.
Save case_SL_shiflift1.

Goal
forall (P : sub_explicits -> Prop) (s t : sub_explicits),
P (comp s (comp shift t)) ->
(forall x' : sub_explicits,
 e_relSL _ (comp (lift s) t) x' -> P (comp shift x')) ->
forall M : sub_explicits, e_relSL _ (comp shift (comp (lift s) t)) M -> P M. 
intros P s t H H0 M H1.
cut (comp (lift s) t = comp (lift s) t).
2: auto.
pattern (comp (lift s) t) at 1, M in |- *; apply case_SLcomp1; intros.
6: assumption.
elim (diff_cons_comp a s1 (lift s) t H2).
elim (diff_comp_lift (lift s) t s1 (sym_equal H2)).

rewrite (proj_lift s1 s (proj_comp1 (lift s1) (lift s) t0 t H2)).
rewrite (proj_comp2 (lift s1) (lift s) t0 t H2); assumption.
elim (diff_id_comp (lift s) t H2).

apply H0; assumption.
Save case_SL_shiflift2.

Goal
forall (P : sub_explicits -> Prop) (s t : sub_explicits),
P (lift (comp s t)) ->
(forall x' : sub_explicits, e_relSL _ (lift s) x' -> P (comp x' (lift t))) ->
(forall x' : sub_explicits, e_relSL _ (lift t) x' -> P (comp (lift s) x')) ->
forall M : sub_explicits, e_relSL _ (comp (lift s) (lift t)) M -> P M.
intros P s t H H0 H1 M H2.
cut (lift t = lift t).
2: auto.
pattern (lift t) at 1, M in |- *; apply case_SLcomp2 with s; intros.
7: assumption.

rewrite (proj_lift t1 t H3); assumption.
elim (diff_comp_lift (lift t1) t2 t H3).
elim (diff_cons_lift a t1 t H3).
elim (diff_id_lift t H3).

apply H0; assumption.

apply H1; assumption.
Save case_SL_lift1.

Goal
forall (P : sub_explicits -> Prop) (s t u : sub_explicits),
P (comp (lift (comp s t)) u) ->
(forall x' : sub_explicits,
 e_relSL _ (lift s) x' -> P (comp x' (comp (lift t) u))) ->
(forall x' : sub_explicits,
 e_relSL _ (comp (lift t) u) x' -> P (comp (lift s) x')) ->
forall M : sub_explicits,
e_relSL _ (comp (lift s) (comp (lift t) u)) M -> P M.
intros P s t u H H0 H1 M H2.
cut (comp (lift t) u = comp (lift t) u).
2: auto.
pattern (comp (lift t) u) at 1, M in |- *; apply case_SLcomp2 with s; intros.
7: assumption.
elim (diff_comp_lift (lift t) u t1 (sym_equal H3)).

rewrite (proj_lift t1 t (proj_comp1 (lift t1) (lift t) t2 u H3)).
rewrite (proj_comp2 (lift t1) (lift t) t2 u H3); assumption.
elim (diff_cons_comp a t1 (lift t) u H3).
elim (diff_id_comp (lift t) u H3).

apply H0; assumption.

apply H1; assumption.
Save case_SL_lift2.

Goal
forall (P : sub_explicits -> Prop) (a : terms) (s t : sub_explicits),
P (cons a (comp s t)) ->
(forall x' : sub_explicits, e_relSL _ (lift s) x' -> P (comp x' (cons a t))) ->
(forall x' : sub_explicits, e_relSL _ (cons a t) x' -> P (comp (lift s) x')) ->
forall M : sub_explicits, e_relSL _ (comp (lift s) (cons a t)) M -> P M.
intros P a s t H H0 H1 M H2.
cut (cons a t = cons a t).
2: auto.
pattern (cons a t) at 1, M in |- *; apply case_SLcomp2 with s; intros.
7: assumption.
elim (diff_cons_lift a t t1 (sym_equal H3)).
elim (diff_cons_comp a t (lift t1) t2 (sym_equal H3)).

rewrite (proj_cons1 a0 a t1 t H3).
rewrite (proj_cons2 a0 a t1 t H3); assumption.
elim (diff_id_cons a t H3).

apply H0; assumption.

apply H1; assumption.
Save case_SL_liftenv.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) (s : sub_explicits),
P s s ->
P id id ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s (comp id s')) ->
forall M : sub_explicits, e_relSL _ (comp id s) M -> P s M.
intros P s H H0 H1 M H2.
cut (id = id).
2: auto.
cut (s = s).
2: auto.
pattern id at 1, s at 1, M in |- *; apply case_SLcomp; intros.
13: assumption.
elim (diff_id_comp s1 s2 (sym_equal H4)).
elim (diff_id_cons a s1 (sym_equal H4)).
elim (diff_id_shift (sym_equal H4)).
elim (diff_id_shift (sym_equal H4)).
elim (diff_id_shift (sym_equal H4)).
elim (diff_id_lift s1 (sym_equal H4)).
elim (diff_id_lift s1 (sym_equal H4)).
elim (diff_id_lift s1 (sym_equal H4)).

assumption.

elim H3; assumption.

elim (case_SLid s' H3).

apply H1; assumption.
Save case_SL_idl.

Goal
forall (P : sub_explicits -> sub_explicits -> Prop) (s : sub_explicits),
P s s ->
(forall s1 s2 : sub_explicits, P (comp s1 s2) (comp s1 (comp s2 id))) ->
(forall (a : terms) (s1 : sub_explicits),
 P (cons a s1) (cons (env a id) (comp s1 id))) ->
P id id ->
(forall s' : sub_explicits, e_relSL _ s s' -> P s (comp s' id)) ->
forall M : sub_explicits, e_relSL _ (comp s id) M -> P s M.
intros P s H H0 H1 H2 H3 M H4.
cut (id = id).
2: auto.
cut (s = s).
2: auto.
pattern s at 1, id at 1, M in |- *; apply case_SLcomp; intros.
13: assumption.

elim H5; apply H0.

elim H5; apply H1.
elim (diff_id_cons a t1 (sym_equal H6)).
elim (diff_id_lift t1 (sym_equal H6)).
elim (diff_id_comp (lift t1) t2 (sym_equal H6)).
elim (diff_id_lift t1 (sym_equal H6)).
elim (diff_id_comp (lift t1) t2 (sym_equal H6)).
elim (diff_id_cons a t1 (sym_equal H6)).

elim H5; assumption.

assumption.

apply H3; assumption.

elim (case_SLid t' H5).
Save case_SL_idr.

Goal
forall P : sub_explicits -> Prop,
P id -> forall M : sub_explicits, e_relSL _ (lift id) M -> P M.
intros P H M H0.
cut (id = id).
2: auto.
pattern id at 1, M in |- *; apply case_SLlift; intros.
3: assumption.

assumption.
elim (case_SLid s' H1).
Save case_SL_liftid.

Goal
forall (P : terms -> terms -> Prop) (a : terms),
P a a ->
(forall a1 b1 : terms, P (app a1 b1) (app (env a1 id) (env b1 id))) ->
(forall a1 : terms, P (lambda a1) (lambda (env a1 (lift id)))) ->
(forall (a1 : terms) (s : sub_explicits), P (env a1 s) (env a1 (comp s id))) ->
(forall a' : terms, e_relSL _ a a' -> P a (env a' id)) ->
forall M : terms, e_relSL _ (env a id) M -> P a M.
intros P a H H0 H1 H2 H3 M H4.
cut (id = id).
2: auto.
pattern a, id at 2, M in |- *; apply case_SLenv; intros.
15: assumption.

apply H0.

apply H1.

apply H2.
elim (diff_id_shift H5).
elim (diff_id_comp shift s1 H5).
elim (diff_id_cons a1 s1 H5).
elim (diff_id_lift s1 H5).
elim (diff_id_comp (lift s1) s2 H5).
elim (diff_id_cons a1 s1 H5).
elim (diff_id_lift s1 H5).
elim (diff_id_comp (lift s1) s2 H5).

assumption.

apply H3; assumption.

elim (case_SLid s' H5).
Save case_SL_reg_id. *)

Goal
forall a b : terms,
exists u : terms,
  e_relSLstar _ (app (env a id) (env b id)) u /\ e_relSLstar _ (app a b) u.
intros; exists (app a b); split; red in |- *.
apply star_trans1 with (app a (env b id)); auto.
auto.
Save PC_app_id.
Hint Resolve PC_app_id.

Goal
forall (a a' b : terms) (s : sub_explicits),
e_relSL _ a a' ->
exists u : terms,
  e_relSLstar _ (app (env a s) (env b s)) u /\
  e_relSLstar _ (env (app a' b) s) u.
intros; exists (app (env a' s) (env b s)); auto 6.
Save PC1_app_ctxt_l.
Hint Resolve PC1_app_ctxt_l.

Goal
forall (a b b' : terms) (s : sub_explicits),
e_relSL _ b b' ->
exists u : terms,
  e_relSLstar _ (app (env a s) (env b s)) u /\
  e_relSLstar _ (env (app a b') s) u.
intros; exists (app (env a s) (env b' s)); auto 6.
Save PC2_app_ctxt_l.
Hint Resolve PC2_app_ctxt_l.

Goal
forall (a b : terms) (s s' : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (app (env a s) (env b s)) u /\
  e_relSLstar _ (env (app a b) s') u.
intros; exists (app (env a s') (env b s')); split; red in |- *.
apply star_trans1 with (app (env a s') (env b s)); auto.
auto.
Save PC_app_ctxt_r.
Hint Resolve PC_app_ctxt_r.

Goal
forall (a b x' : terms) (s : sub_explicits),
e_relSL _ (app a b) x' ->
exists u : terms,
  e_relSLstar _ (app (env a s) (env b s)) u /\ e_relSLstar _ (env x' s) u.
intros a b x' s H; pattern x' in |- *; apply case_SLapp with a b; auto.
Save PC_app_ctxt_l.
Hint Resolve PC_app_ctxt_l.

Goal
forall a : terms,
exists u : terms,
  e_relSLstar _ (lambda (env a (lift id))) u /\ e_relSLstar _ (lambda a) u.
intro; exists (lambda a); split; red in |- *.
apply star_trans1 with (lambda (env a id)); auto.
auto.
Save PC_lambda_id.
Hint Resolve PC_lambda_id.

Goal
forall (a x' : terms) (s : sub_explicits),
e_relSL _ (lambda a) x' ->
exists u : terms,
  e_relSLstar _ (lambda (env a (lift s))) u /\ e_relSLstar _ (env x' s) u.
intros a x' s H; pattern x' in |- *; apply case_SLlambda with a; intros.
2: assumption.
exists (lambda (env a' (lift s))); auto 6.
Save PC_lambda_ctxt_l.
Hint Resolve PC_lambda_ctxt_l.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (lambda (env a (lift s))) u /\
  e_relSLstar _ (env (lambda a) s') u.
intros; exists (lambda (env a (lift s'))); auto 8.
Save PC_lambda_ctxt_r.
Hint Resolve PC_lambda_ctxt_r.

Goal
forall (a : terms) (s : sub_explicits),
exists u : terms,
  e_relSLstar _ (env a (comp s id)) u /\ e_relSLstar _ (env a s) u.
intros; exists (env a s); split; red in |- *; auto.
Save PC1_clos_id.
Hint Resolve PC1_clos_id.

Goal
forall (a b : terms) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (app a b) (comp s t)) u /\
  e_relSLstar _ (env (app (env a s) (env b s)) t) u.
intros; exists (app (env a (comp s t)) (env b (comp s t))); split;
 red in |- *.
auto.
apply star_trans1 with (app (env (env a s) t) (env (env b s) t)).
auto.
apply star_trans1 with (app (env a (comp s t)) (env (env b s) t)); auto.
Save PC_clos_app.
Hint Resolve PC_clos_app.

Goal
forall (a : terms) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (lambda a) (comp s t)) u /\
  e_relSLstar _ (env (lambda (env a (lift s))) t) u.
intros; exists (lambda (env a (lift (comp s t)))); split; red in |- *.
auto.
apply star_trans1 with (lambda (env (env a (lift s)) (lift t))).
auto.
apply star_trans1 with (lambda (env a (comp (lift s) (lift t)))); auto 6.
Save PC_clos_lambda.
Hint Resolve PC_clos_lambda.

Goal
forall (a : terms) (s s1 t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (env a s1) (comp s t)) u /\
  e_relSLstar _ (env (env a (comp s1 s)) t) u.
intros; exists (env a (comp s1 (comp s t))); split; red in |- *.
auto.
apply star_trans1 with (env a (comp (comp s1 s) t)); auto.
Save PC_clos_clos.
Hint Resolve PC_clos_clos.

Goal
forall (n : nat) (t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp shift t)) u /\
  e_relSLstar _ (env (var (S n)) t) u.
intros; exists (env (var (S n)) t); auto 6.
Save PC_clos_varshift1.
Hint Resolve PC_clos_varshift1.

Goal
forall (n : nat) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp (comp shift s) t)) u /\
  e_relSLstar _ (env (env (var (S n)) s) t) u.
intros; exists (env (var (S n)) (comp s t)); split; red in |- *.
apply star_trans1 with (env (var n) (comp shift (comp s t))); auto.
auto.
Save PC_clos_varshift2.
Hint Resolve PC_clos_varshift2.

Goal
forall (a : terms) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var 0) (comp (cons a s) t)) u /\
  e_relSLstar _ (env a t) u.
intros; exists (env a t); split; red in |- *.
apply star_trans1 with (env (var 0) (cons (env a t) (comp s t))); auto.
auto.
Save PC_clos_fvarcons.
Hint Resolve PC_clos_fvarcons.

Goal
forall s t : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) (comp (lift s) t)) u /\
  e_relSLstar _ (env (var 0) t) u.
intros; exists (env (var 0) t); auto 6.
Save PC_clos_fvarlift1.
Hint Resolve PC_clos_fvarlift1.

Goal
forall s1 s2 t : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) (comp (comp (lift s1) s2) t)) u /\
  e_relSLstar _ (env (env (var 0) s2) t) u.
intros; exists (env (var 0) (comp s2 t)); split; red in |- *.
apply star_trans1 with (env (var 0) (comp (lift s1) (comp s2 t))); auto.
auto.
Save PC_clos_fvarlift2.
Hint Resolve PC_clos_fvarlift2.

Goal
forall (n : nat) (a : terms) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var (S n)) (comp (cons a s) t)) u /\
  e_relSLstar _ (env (env (var n) s) t) u.
intros; exists (env (var n) (comp s t)); split; red in |- *.
apply star_trans1 with (env (var (S n)) (cons (env a t) (comp s t))); auto.
auto.
Save PC_clos_rvarcons.
Hint Resolve PC_clos_rvarcons.

Goal
forall (n : nat) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var (S n)) (comp (lift s) t)) u /\
  e_relSLstar _ (env (env (var n) (comp s shift)) t) u.
intros; exists (env (var n) (comp s (comp shift t))); split; red in |- *.
auto.
apply star_trans1 with (env (var n) (comp (comp s shift) t)); auto.
Save PC_clos_rvarlift1.
Hint Resolve PC_clos_rvarlift1.

Goal
forall (n : nat) (s1 s2 t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var (S n)) (comp (comp (lift s1) s2) t)) u /\
  e_relSLstar _ (env (env (var n) (comp s1 (comp shift s2))) t) u.
intros; exists (env (var n) (comp s1 (comp shift (comp s2 t)))); split;
 red in |- *.
apply star_trans1 with (env (var (S n)) (comp (lift s1) (comp s2 t))); auto.
apply star_trans1 with (env (var n) (comp (comp s1 (comp shift s2)) t)).
auto.
apply star_trans1 with (env (var n) (comp s1 (comp (comp shift s2) t)));
 auto 6.
Save PC_clos_rvarlift2.
Hint Resolve PC_clos_rvarlift2.

Goal
forall (a : terms) (t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env a (comp id t)) u /\ e_relSLstar _ (env a t) u.
intros; exists (env a t); auto 8.
Save PC2_clos_id.
Hint Resolve PC2_clos_id.

Goal
forall (a a' : terms) (s t : sub_explicits),
e_relSL _ a a' ->
exists u : terms,
  e_relSLstar _ (env a (comp s t)) u /\ e_relSLstar _ (env (env a' s) t) u.
intros; exists (env a' (comp s t)); auto 8.
Save PC1_clos_ctxt_l.
Hint Resolve PC1_clos_ctxt_l.

Goal
forall (a : terms) (s s' t : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (env a (comp s t)) u /\ e_relSLstar _ (env (env a s') t) u.
intros; exists (env a (comp s' t)); auto 6.
Save PC2_clos_ctxt_l.
Hint Resolve PC2_clos_ctxt_l.

Goal
forall (a : terms) (s t t' : sub_explicits),
e_relSL _ t t' ->
exists u : terms,
  e_relSLstar _ (env a (comp s t)) u /\ e_relSLstar _ (env (env a s) t') u.
intros; exists (env a (comp s t')); auto 6.
Save PC_clos_ctxt_r.
Hint Resolve PC_clos_ctxt_r.

Goal
forall (a x' : terms) (s t : sub_explicits),
e_relSL _ (env a s) x' ->
exists u : terms,
  e_relSLstar _ (env a (comp s t)) u /\ e_relSLstar _ (env x' t) u.
intros a x' s t H; pattern a, s, x' in |- *; apply case_SLenv; auto.
Save PC_clos_ctxt_l.
Hint Resolve PC_clos_ctxt_l.

Goal
forall (n : nat) (a : terms) (s : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var (S n)) (cons a s)) u /\
  e_relSLstar _ (env (var n) s) u.
intros; exists (env (var n) s); auto 6.
Save PC_varshift2_shiftcons.
Hint Resolve PC_varshift2_shiftcons.

Goal
forall (n : nat) (s : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var (S n)) (lift s)) u /\
  e_relSLstar _ (env (var n) (comp s shift)) u.
intros; exists (env (var n) (comp s shift)); auto 6.
Save PC_varshift2_shiftlift1.
Hint Resolve PC_varshift2_shiftlift1.

Goal
forall (n : nat) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var (S n)) (comp (lift s) t)) u /\
  e_relSLstar _ (env (var n) (comp s (comp shift t))) u.
intros; exists (env (var n) (comp s (comp shift t))); auto 6.
Save PC_varshift2_shiftlift2.
Hint Resolve PC_varshift2_shiftlift2.

Goal
forall n : nat,
exists u : terms,
  e_relSLstar _ (env (var (S n)) id) u /\ e_relSLstar _ (env (var n) shift) u.
intros; exists (var (S n)); auto 6.
Save PC_varshift2_idr.
Hint Resolve PC_varshift2_idr.

Goal
forall (n : nat) (s s' : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (env (var (S n)) s) u /\
  e_relSLstar _ (env (var n) (comp shift s')) u.
intros; exists (env (var (S n)) s'); auto 6.
Save PC_varshift2_ctxt_r.
Hint Resolve PC_varshift2_ctxt_r.

Goal
forall (n : nat) (s x' : sub_explicits),
e_relSL _ (comp shift s) x' ->
exists u : terms,
  e_relSLstar _ (env (var (S n)) s) u /\ e_relSLstar _ (env (var n) x') u.
intros n s x' H; pattern s, x' in |- *; apply case_SLcomp1; auto.
Save PC_varshift2_ctxt_r'.
Hint Resolve PC_varshift2_ctxt_r'.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relSL _ a a' ->
exists u : terms,
  e_relSLstar _ a u /\ e_relSLstar _ (env (var 0) (cons a' s)) u.
intros; exists a'; auto 6.
Save PC1_fvarcons_ctxt_r.
Hint Resolve PC1_fvarcons_ctxt_r.

Goal
forall (a : terms) (s' : sub_explicits),
exists u : terms,
  e_relSLstar _ a u /\ e_relSLstar _ (env (var 0) (cons a s')) u.
intros; exists a; auto 6.
Save PC2_fvarcons_ctxt_r.
Hint Resolve PC2_fvarcons_ctxt_r.

Goal
forall (a : terms) (s x' : sub_explicits),
e_relSL _ (cons a s) x' ->
exists u : terms, e_relSLstar _ a u /\ e_relSLstar _ (env (var 0) x') u.
intros a s x' H; pattern x' in |- *; apply case_SLcons with a s; auto.
Save PC_fvarcons_ctxt_r. 

Goal
exists u : terms, e_relSLstar _ (var 0) u /\ e_relSLstar _ (env (var 0) id) u.
intros; exists (var 0); auto 6.
Save PC_fvarlift1_liftid.
Hint Resolve PC_fvarlift1_liftid.

Goal
forall s' : sub_explicits,
exists u : terms,
  e_relSLstar _ (var 0) u /\ e_relSLstar _ (env (var 0) (lift s')) u.
intros; exists (var 0); auto 6.
Save PC_fvarlift1_ctxt_r.
Hint Resolve PC_fvarlift1_ctxt_r.

Goal
forall s x' : sub_explicits,
e_relSL _ (lift s) x' ->
exists u : terms, e_relSLstar _ (var 0) u /\ e_relSLstar _ (env (var 0) x') u.
intros s x' H; pattern s, x' in |- *; apply case_SLlift; auto.
Save PC_fvarlift1_ctxt_r'.

Goal
forall s t : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) (lift t)) u /\
  e_relSLstar _ (env (var 0) (lift (comp s t))) u.
intros; exists (var 0); auto 6.
Save PC_fvarlift2_lift1.
Hint Resolve PC_fvarlift2_lift1.

Goal
forall s t v : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) (comp (lift t) v)) u /\
  e_relSLstar _ (env (var 0) (comp (lift (comp s t)) v)) u.
intros; exists (env (var 0) v); auto 6.
Save PC_fvarlift2_lift2.
Hint Resolve PC_fvarlift2_lift2.

Goal
forall (a : terms) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var 0) (cons a t)) u /\
  e_relSLstar _ (env (var 0) (cons a (comp s t))) u.
intros; exists a; auto 6.
Save PC_fvarlift2_liftenv.
Hint Resolve PC_fvarlift2_liftenv.

Goal
forall s : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) id) u /\ e_relSLstar _ (env (var 0) (lift s)) u.
exists (var 0); auto 6.
Save PC_fvarlift2_idr.
Hint Resolve PC_fvarlift2_idr.

Goal
forall t : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) t) u /\
  e_relSLstar _ (env (var 0) (comp id t)) u.
intros; exists (env (var 0) t); auto 7.
Save PC_fvarlift2_liftid.
Hint Resolve PC_fvarlift2_liftid.

Goal
forall s' t : sub_explicits,
exists u : terms,
  e_relSLstar _ (env (var 0) t) u /\
  e_relSLstar _ (env (var 0) (comp (lift s') t)) u.
intros; exists (env (var 0) t); auto 6.
Save PC1_fvarlift2_ctxt_r.
Hint Resolve PC1_fvarlift2_ctxt_r.

Goal
forall s t t' : sub_explicits,
e_relSL _ t t' ->
exists u : terms,
  e_relSLstar _ (env (var 0) t) u /\
  e_relSLstar _ (env (var 0) (comp (lift s) t')) u.
intros; exists (env (var 0) t'); auto 6.
Save PC2_fvarlift2_ctxt_r.
Hint Resolve PC2_fvarlift2_ctxt_r.

Goal
forall s t x' : sub_explicits,
e_relSL _ (comp (lift s) t) x' ->
exists u : terms,
  e_relSLstar _ (env (var 0) t) u /\ e_relSLstar _ (env (var 0) x') u.
intros s t x' H; pattern t, x' in |- *; apply case_SLcomp2 with s; auto.
intros; pattern s, x'0 in |- *; apply case_SLlift; auto.
Save PC_fvarlift2_ctxt_r.

Goal
forall (n : nat) (a' : terms) (s : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) s) u /\
  e_relSLstar _ (env (var (S n)) (cons a' s)) u.
intros; exists (env (var n) s); auto 6.
Save PC1_rvarcons_ctxt_r.
Hint Resolve PC1_rvarcons_ctxt_r.

Goal
forall (n : nat) (a : terms) (s s' : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (env (var n) s) u /\
  e_relSLstar _ (env (var (S n)) (cons a s')) u.
intros; exists (env (var n) s'); auto 6.
Save PC2_rvarcons_ctxt_r.
Hint Resolve PC2_rvarcons_ctxt_r.

Goal
forall (n : nat) (a : terms) (s x' : sub_explicits),
e_relSL _ (cons a s) x' ->
exists u : terms,
  e_relSLstar _ (env (var n) s) u /\ e_relSLstar _ (env (var (S n)) x') u.
intros n a s x' H; pattern x' in |- *; apply case_SLcons with a s; auto.
Save PC_rvarcons_ctxt_r.

Goal
forall n : nat,
exists u : terms,
  e_relSLstar _ (env (var n) (comp id shift)) u /\
  e_relSLstar _ (env (var (S n)) id) u.
intros; exists (var (S n)); split; red in |- *.
apply star_trans1 with (env (var n) shift); auto.
auto.
Save PC_rvarlift1_id.
Hint Resolve PC_rvarlift1_id.

Goal
forall (n : nat) (s s' : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (env (var n) (comp s shift)) u /\
  e_relSLstar _ (env (var (S n)) (lift s')) u.
intros; exists (env (var n) (comp s' shift)); auto 6.
Save PC_rvarlift1_ctxt_r.
Hint Resolve PC_rvarlift1_ctxt_r.

Goal
forall (n : nat) (s x' : sub_explicits),
e_relSL _ (lift s) x' ->
exists u : terms,
  e_relSLstar _ (env (var n) (comp s shift)) u /\
  e_relSLstar _ (env (var (S n)) x') u.
intros n s x' H; pattern s, x' in |- *; apply case_SLlift; auto.
Save PC_rvarlift1_ctxt_r'.
Hint Resolve PC_rvarlift1_ctxt_r'.

Goal
forall (n : nat) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift (lift t)))) u /\
  e_relSLstar _ (env (var (S n)) (lift (comp s t))) u.
intros; exists (env (var n) (comp s (comp t shift))); split; red in |- *.
auto 6.
apply star_trans1 with (env (var n) (comp (comp s t) shift)); auto.
Save PC_rvarlift2_lift1.
Hint Resolve PC_rvarlift2_lift1.

Goal
forall (n : nat) (s t v : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift (comp (lift t) v)))) u /\
  e_relSLstar _ (env (var (S n)) (comp (lift (comp s t)) v)) u.
intros; exists (env (var n) (comp s (comp t (comp shift v)))); split;
 red in |- *.
auto 6.
apply star_trans1 with (env (var n) (comp (comp s t) (comp shift v))); auto.
Save PC_rvarlift2_lift2.
Hint Resolve PC_rvarlift2_lift2.

Goal
forall (n : nat) (a : terms) (s t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift (cons a t)))) u /\
  e_relSLstar _ (env (var (S n)) (cons a (comp s t))) u.
intros; exists (env (var n) (comp s t)); auto 8.
Save PC_rvarlift2_liftenv.
Hint Resolve PC_rvarlift2_liftenv.

Goal
forall (n : nat) (s : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift id))) u /\
  e_relSLstar _ (env (var (S n)) (lift s)) u.
intros; exists (env (var n) (comp s shift)); auto 8.
Save PC_rvarlift2_idr.
Hint Resolve PC_rvarlift2_idr.

Goal
forall (n : nat) (t : sub_explicits),
exists u : terms,
  e_relSLstar _ (env (var n) (comp id (comp shift t))) u /\
  e_relSLstar _ (env (var (S n)) (comp id t)) u.
intros; exists (env (var (S n)) t); split; red in |- *.
apply star_trans1 with (env (var n) (comp shift t)); auto.
auto.
Save PC_rvarlift2_liftid.
Hint Resolve PC_rvarlift2_liftid.

Goal
forall (n : nat) (s s' t : sub_explicits),
e_relSL _ s s' ->
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift t))) u /\
  e_relSLstar _ (env (var (S n)) (comp (lift s') t)) u.
intros; exists (env (var n) (comp s' (comp shift t))); auto 6.
Save PC1_rvarlift2_ctxt_r.
Hint Resolve PC1_rvarlift2_ctxt_r.

Goal
forall (n : nat) (s t t' : sub_explicits),
e_relSL _ t t' ->
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift t))) u /\
  e_relSLstar _ (env (var (S n)) (comp (lift s) t')) u.
intros; exists (env (var n) (comp s (comp shift t'))); auto 7.
Save PC2_rvarlift2_ctxt_r.
Hint Resolve PC2_rvarlift2_ctxt_r.

Goal
forall (n : nat) (s t x' : sub_explicits),
e_relSL _ (comp (lift s) t) x' ->
exists u : terms,
  e_relSLstar _ (env (var n) (comp s (comp shift t))) u /\
  e_relSLstar _ (env (var (S n)) x') u.
intros n s t x' H; pattern t, x' in |- *; apply case_SLcomp2 with s; auto.
intros; pattern s, x'0 in |- *; apply case_SLlift; auto.
Save PC_rvarlift2_ctxt_r.
Hint Resolve PC_rvarlift2_ctxt_r.

Goal
forall s1 s2 t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (comp s1 s2) (comp t v)) u /\
  e_relSLstar _ (comp (comp s1 (comp s2 t)) v) u.
intros; exists (comp s1 (comp s2 (comp t v))); split; red in |- *.
auto.
apply star_trans1 with (comp s1 (comp (comp s2 t) v)); auto.
Save PC_assenv_assenv.
Hint Resolve PC_assenv_assenv.

Goal
forall (a : terms) (s t v : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (comp (cons a s) (comp t v)) u /\
  e_relSLstar _ (comp (cons (env a t) (comp s t)) v) u.
intros; exists (cons (env a (comp t v)) (comp s (comp t v))); split;
 red in |- *.
auto.
apply star_trans1 with (cons (env (env a t) v) (comp (comp s t) v)).
auto.
apply star_trans1 with (cons (env a (comp t v)) (comp (comp s t) v)); auto.
Save PC_assenv_mapenv.
Hint Resolve PC_assenv_mapenv.

Goal
forall (a : terms) (s v : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (comp shift (comp (cons a s) v)) u /\
  e_relSLstar _ (comp s v) u.
intros; exists (comp s v); split; red in |- *.
apply star_trans1 with (comp shift (cons (env a v) (comp s v))); auto.
auto.
Save PC_assenv_shiftcons.
Hint Resolve PC_assenv_shiftcons.

Goal
forall s v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp shift (comp (lift s) v)) u /\
  e_relSLstar _ (comp (comp s shift) v) u.
intros; exists (comp s (comp shift v)); auto 6.
Save PC_assenv_shiftlift1.
Hint Resolve PC_assenv_shiftlift1.

Goal
forall s t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp shift (comp (comp (lift s) t) v)) u /\
  e_relSLstar _ (comp (comp s (comp shift t)) v) u.
intros; exists (comp s (comp shift (comp t v))); split; red in |- *.
apply star_trans1 with (comp shift (comp (lift s) (comp t v))); auto.
apply star_trans1 with (comp s (comp (comp shift t) v)); auto.
Save PC_assenv_shiftlift2.
Hint Resolve PC_assenv_shiftlift2.

Goal
forall s t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift s) (comp (lift t) v)) u /\
  e_relSLstar _ (comp (lift (comp s t)) v) u.
intros; exists (comp (lift (comp s t)) v); auto 6.
Save PC_assenv_lift1.
Hint Resolve PC_assenv_lift1.

Goal
forall s t1 t2 v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift s) (comp (comp (lift t1) t2) v)) u /\
  e_relSLstar _ (comp (comp (lift (comp s t1)) t2) v) u.
intros; exists (comp (lift (comp s t1)) (comp t2 v)); split; red in |- *.
apply star_trans1 with (comp (lift s) (comp (lift t1) (comp t2 v))); auto.
auto.
Save PC_assenv_lift2.
Hint Resolve PC_assenv_lift2.

Goal
forall (a : terms) (s t v : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (comp (lift s) (comp (cons a t) v)) u /\
  e_relSLstar _ (comp (cons a (comp s t)) v) u.
intros; exists (cons (env a v) (comp s (comp t v))); split; red in |- *.
apply star_trans1 with (comp (lift s) (cons (env a v) (comp t v))); auto.
apply star_trans1 with (cons (env a v) (comp (comp s t) v)); auto.
Save PC_assenv_liftenv.
Hint Resolve PC_assenv_liftenv.

Goal
forall t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp id (comp t v)) u /\ e_relSLstar _ (comp t v) u.
intros; exists (comp t v); auto 6.
Save PC_assenv_idl.
Hint Resolve PC_assenv_idl.

Goal
forall s v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp id v)) u /\ e_relSLstar _ (comp s v) u.
intros; exists (comp s v); auto 7.
Save PC1_assenv_idr.
Hint Resolve PC1_assenv_idr.

Goal
forall s t : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp t id)) u /\ e_relSLstar _ (comp s t) u.
intros; exists (comp s t); auto 7.
Save PC2_assenv_idr.
Hint Resolve PC2_assenv_idr.

Goal
forall s s' t v : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp t v)) u /\ e_relSLstar _ (comp (comp s' t) v) u.
intros; exists (comp s' (comp t v)); auto 6.
Save PC_assenv_ctxt_l.
Hint Resolve PC_assenv_ctxt_l.

Goal
forall s t t' v : sub_explicits,
e_relSL _ t t' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp t v)) u /\ e_relSLstar _ (comp (comp s t') v) u. 
intros; exists (comp s (comp t' v)); auto 6.
Save PC1_assenv_ctxt_r.
Hint Resolve PC1_assenv_ctxt_r.

Goal
forall s t v v' : sub_explicits,
e_relSL _ v v' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp t v)) u /\ e_relSLstar _ (comp (comp s t) v') u. 
intros; exists (comp s (comp t v')); auto 6.
Save PC2_assenv_ctxt_r.
Hint Resolve PC2_assenv_ctxt_r.

Goal
forall s t v x' : sub_explicits,
e_relSL _ (comp s t) x' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp t v)) u /\ e_relSLstar _ (comp x' v) u.
intros s t v x' H; pattern s, t, x' in |- *; apply case_SLcomp; auto.
Save PC_assenv_ctxt_r.
Hint Resolve PC_assenv_ctxt_r.

Goal
forall (a : terms) (s : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (cons (env a id) (comp s id)) u /\ e_relSLstar _ (cons a s) u. 
intros; exists (cons a s); split; red in |- *.
apply star_trans1 with (cons a (comp s id)); auto.
auto.
Save PC_mapenv_idr.
Hint Resolve PC_mapenv_idr.

Goal
forall (a a' : terms) (s t : sub_explicits),
e_relSL _ a a' ->
exists u : sub_explicits,
  e_relSLstar _ (cons (env a t) (comp s t)) u /\
  e_relSLstar _ (comp (cons a' s) t) u. 
intros; exists (cons (env a' t) (comp s t)); auto 6.
Save PC1_mapenv_ctxt_l.
Hint Resolve PC1_mapenv_ctxt_l.

Goal
forall (a : terms) (s s' t : sub_explicits),
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (cons (env a t) (comp s t)) u /\
  e_relSLstar _ (comp (cons a s') t) u. 
intros; exists (cons (env a t) (comp s' t)); auto 6.
Save PC2_mapenv_ctxt_l.
Hint Resolve PC2_mapenv_ctxt_l.

Goal
forall (a : terms) (s t t' : sub_explicits),
e_relSL _ t t' ->
exists u : sub_explicits,
  e_relSLstar _ (cons (env a t) (comp s t)) u /\
  e_relSLstar _ (comp (cons a s) t') u. 
intros; exists (cons (env a t') (comp s t')); split; red in |- *.
apply star_trans1 with (cons (env a t') (comp s t)); auto.
auto.
Save PC_mapenv_ctxt_r.
Hint Resolve PC_mapenv_ctxt_r.

Goal
forall (a : terms) (s t x' : sub_explicits),
e_relSL _ (cons a s) x' ->
exists u : sub_explicits,
  e_relSLstar _ (cons (env a t) (comp s t)) u /\ e_relSLstar _ (comp x' t) u. 
intros a s t x' H; pattern x' in |- *; apply case_SLcons with a s; auto.
Save PC_mapenv_ctxt_l.
Hint Resolve PC_mapenv_ctxt_l.

Goal
forall (a' : terms) (s : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ s u /\ e_relSLstar _ (comp shift (cons a' s)) u. 
intros; exists s; auto 6.
Save PC1_shiftcons_ctxt_r.
Hint Resolve PC1_shiftcons_ctxt_r.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ s u /\ e_relSLstar _ (comp shift (cons a s')) u.
intros; exists s'; auto 6.
Save PC2_shiftcons_ctxt_r.
Hint Resolve PC2_shiftcons_ctxt_r.

Goal
forall (a : terms) (s x' : sub_explicits),
e_relSL _ (cons a s) x' ->
exists u : sub_explicits,
  e_relSLstar _ s u /\ e_relSLstar _ (comp shift x') u.
intros a s x' H; pattern x' in |- *; apply case_SLcons with a s; auto.
Save PC_shiftcons_ctxt_r.

Goal
exists u : sub_explicits,
  e_relSLstar _ (comp id shift) u /\ e_relSLstar _ (comp shift id) u.
intros; exists shift; auto 6.
Save PC_shiftlift1_liftid.
Hint Resolve PC_shiftlift1_liftid.

Goal
forall s s' : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s shift) u /\ e_relSLstar _ (comp shift (lift s')) u.
intros; exists (comp s' shift); auto 6.
Save PC_shiftlift1_ctxt_r.
Hint Resolve PC_shiftlift1_ctxt_r.

Goal
forall s x' : sub_explicits,
e_relSL _ (lift s) x' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s shift) u /\ e_relSLstar _ (comp shift x') u.
intros s x' H; pattern s, x' in |- *; apply case_SLlift; auto.
Save PC_shiftlift1_ctxt_r'.
Hint Resolve PC_shiftlift1_ctxt_r'.

Goal
forall s t : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift (lift t))) u /\
  e_relSLstar _ (comp shift (lift (comp s t))) u.
intros; exists (comp s (comp t shift)); split; red in |- *.
auto.
apply star_trans1 with (comp (comp s t) shift); auto.
Save PC_shiftlift2_lift1.
Hint Resolve PC_shiftlift2_lift1.

Goal
forall s t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift (comp (lift t) v))) u /\
  e_relSLstar _ (comp shift (comp (lift (comp s t)) v)) u.
intros; exists (comp s (comp t (comp shift v))); split; red in |- *.
auto.
apply star_trans1 with (comp (comp s t) (comp shift v)); auto.
Save PC_shiftlift2_lift2.
Hint Resolve PC_shiftlift2_lift2.

Goal
forall (a : terms) (s t : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift (cons a t))) u /\
  e_relSLstar _ (comp shift (cons a (comp s t))) u.
intros; exists (comp s t); auto 7.
Save PC_shiftlift2_liftenv.
Hint Resolve PC_shiftlift2_liftenv.

Goal
forall t : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp id (comp shift t)) u /\
  e_relSLstar _ (comp shift (comp id t)) u.
intros; exists (comp shift t); auto 7.
Save PC_shiftlift2_liftid.
Hint Resolve PC_shiftlift2_liftid.

Goal
forall s : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift id)) u /\
  e_relSLstar _ (comp shift (lift s)) u.
intros; exists (comp s shift); auto 7.
Save PC_shiftlift2_idr.
Hint Resolve PC_shiftlift2_idr.

Goal
forall s s' t : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift t)) u /\
  e_relSLstar _ (comp shift (comp (lift s') t)) u.
intros; exists (comp s' (comp shift t)); auto 6.
Save PC1_shiftlift2_ctxt_r.
Hint Resolve PC1_shiftlift2_ctxt_r.

Goal
forall s t t' : sub_explicits,
e_relSL _ t t' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift t)) u /\
  e_relSLstar _ (comp shift (comp (lift s) t')) u.
intros; exists (comp s (comp shift t')); auto 6.
Save PC2_shiftlift2_ctxt_r.
Hint Resolve PC2_shiftlift2_ctxt_r.

Goal
forall s t x' : sub_explicits,
e_relSL _ (comp (lift s) t) x' ->
exists u : sub_explicits,
  e_relSLstar _ (comp s (comp shift t)) u /\ e_relSLstar _ (comp shift x') u.
intros s t x' H; pattern t, x' in |- *; apply case_SLcomp2 with s; auto.
intros; pattern s, x'0 in |- *; apply case_SLlift; auto.
Save PC_shiftlift2_ctxt_r.
Hint Resolve PC_shiftlift2_ctxt_r.
  
Goal
forall t : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (lift (comp id t)) u /\ e_relSLstar _ (comp id (lift t)) u.
intros; exists (lift t); auto 7.
Save PC1_lift1_liftid.
Hint Resolve PC1_lift1_liftid.

Goal
forall s : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (lift (comp s id)) u /\ e_relSLstar _ (comp (lift s) id) u.
intros; exists (lift s); auto 7.
Save PC2_lift1_liftid.
Hint Resolve PC2_lift1_liftid.

Goal
forall s s' t : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (lift (comp s t)) u /\
  e_relSLstar _ (comp (lift s') (lift t)) u.
intros; exists (lift (comp s' t)); auto 6.
Save PC_lift1_ctxt_l.
Hint Resolve PC_lift1_ctxt_l.

Goal
forall s t t' : sub_explicits,
e_relSL _ t t' ->
exists u : sub_explicits,
  e_relSLstar _ (lift (comp s t)) u /\
  e_relSLstar _ (comp (lift s) (lift t')) u.
intros; exists (lift (comp s t')); auto 6.
Save PC_lift1_ctxt_r.
Hint Resolve PC_lift1_ctxt_r.

Goal
forall s t x' : sub_explicits,
e_relSL _ (lift s) x' ->
exists u : sub_explicits,
  e_relSLstar _ (lift (comp s t)) u /\ e_relSLstar _ (comp x' (lift t)) u.
intros s t x' H; pattern s, x' in |- *; apply case_SLlift; auto.
Save PC_lift1_ctxt_l'.
Hint Resolve PC_lift1_ctxt_l'.

Goal
forall s t x' : sub_explicits,
e_relSL _ (lift t) x' ->
exists u : sub_explicits,
  e_relSLstar _ (lift (comp s t)) u /\ e_relSLstar _ (comp (lift s) x') u.
intros a t x' H; pattern t, x' in |- *; apply case_SLlift; auto.
Save PC_lift1_ctxt_r'.
Hint Resolve PC_lift1_ctxt_r'.

Goal
forall s t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) (lift v)) u /\
  e_relSLstar _ (comp (lift s) (lift (comp t v))) u.
intros; exists (lift (comp s (comp t v))); split; red in |- *.
apply star_trans1 with (lift (comp (comp s t) v)); auto.
auto.
Save PC_lift2_lift1.
Hint Resolve PC_lift2_lift1.

Goal
forall s t1 t2 v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t1)) (comp (lift t2) v)) u /\
  e_relSLstar _ (comp (lift s) (comp (lift (comp t1 t2)) v)) u.
intros; exists (comp (lift (comp s (comp t1 t2))) v); split; red in |- *.
apply star_trans1 with (comp (lift (comp (comp s t1) t2)) v); auto 6.
auto.
Save PC_lift2_lift2.
Hint Resolve PC_lift2_lift2.

Goal
forall (a : terms) (s t v : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) (cons a v)) u /\
  e_relSLstar _ (comp (lift s) (cons a (comp t v))) u.
intros; exists (cons a (comp s (comp t v))); split; red in |- *.
apply star_trans1 with (cons a (comp (comp s t) v)); auto.
auto.
Save PC_lift2_liftenv.
Hint Resolve PC_lift2_liftenv.

Goal
forall t v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp id t)) v) u /\
  e_relSLstar _ (comp id (comp (lift t) v)) u.
intros; exists (comp (lift t) v); auto 8.
Save PC1_lift2_liftid.
Hint Resolve PC1_lift2_liftid.

Goal
forall s v : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s id)) v) u /\
  e_relSLstar _ (comp (lift s) (comp id v)) u.
intros; exists (comp (lift s) v); auto 8.
Save PC2_lift2_liftid.
Hint Resolve PC2_lift2_liftid.

Goal
forall s t : sub_explicits,
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) id) u /\
  e_relSLstar _ (comp (lift s) (lift t)) u.
intros; exists (lift (comp s t)); auto 6.
Save PC_lift2_idr.
Hint Resolve PC_lift2_idr.

Goal
forall s s' t v : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) v) u /\
  e_relSLstar _ (comp (lift s') (comp (lift t) v)) u.
intros; exists (comp (lift (comp s' t)) v); auto 7.
Save PC_lift2_ctxt_l.
Hint Resolve PC_lift2_ctxt_l.

Goal
forall s t t' v : sub_explicits,
e_relSL _ t t' ->
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) v) u /\
  e_relSLstar _ (comp (lift s) (comp (lift t') v)) u.
intros; exists (comp (lift (comp s t')) v); auto 7.
Save PC1_lift2_ctxt_r.
Hint Resolve PC1_lift2_ctxt_r.

Goal
forall s t v v' : sub_explicits,
e_relSL _ v v' ->
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) v) u /\
  e_relSLstar _ (comp (lift s) (comp (lift t) v')) u.
intros; exists (comp (lift (comp s t)) v'); auto 6.
Save PC2_lift2_ctxt_r.
Hint Resolve PC2_lift2_ctxt_r.

Goal
forall s t v x' : sub_explicits,
e_relSL _ (lift s) x' ->
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) v) u /\
  e_relSLstar _ (comp x' (comp (lift t) v)) u.
intros s t v x' H; pattern s, x' in |- *; apply case_SLlift; auto.
Save PC_lift2_ctxt_l'. 
Hint Resolve PC_lift2_ctxt_l'. 

Goal
forall s t v x' : sub_explicits,
e_relSL _ (comp (lift t) v) x' ->
exists u : sub_explicits,
  e_relSLstar _ (comp (lift (comp s t)) v) u /\
  e_relSLstar _ (comp (lift s) x') u.
intros s t v x' H; pattern v, x' in |- *; apply case_SLcomp2 with t; auto.
intros; pattern t, x'0 in |- *; apply case_SLlift; auto.
Save PC_lift2_ctxt_r.
Hint Resolve PC_lift2_ctxt_r.

Goal
forall (a : terms) (t : sub_explicits),
exists u : sub_explicits,
  e_relSLstar _ (cons a (comp id t)) u /\
  e_relSLstar _ (comp id (cons a t)) u.
intros; exists (cons a t); auto 7.
Save PC_liftenv_liftid.
Hint Resolve PC_liftenv_liftid.

Goal
forall (a : terms) (s s' t : sub_explicits),
e_relSL _ s s' ->
exists u : sub_explicits,
  e_relSLstar _ (cons a (comp s t)) u /\
  e_relSLstar _ (comp (lift s') (cons a t)) u.
intros; exists (cons a (comp s' t)); auto 6.
Save PC_liftenv_ctxt_l.
Hint Resolve PC_liftenv_ctxt_l.

Goal
forall (a a' : terms) (s t : sub_explicits),
e_relSL _ a a' ->
exists u : sub_explicits,
  e_relSLstar _ (cons a (comp s t)) u /\
  e_relSLstar _ (comp (lift s) (cons a' t)) u.
intros; exists (cons a' (comp s t)); auto 6.
Save PC1_liftenv_ctxt_r.
Hint Resolve PC1_liftenv_ctxt_r.

Goal
forall (a : terms) (s t t' : sub_explicits),
e_relSL _ t t' ->
exists u : sub_explicits,
  e_relSLstar _ (cons a (comp s t)) u /\
  e_relSLstar _ (comp (lift s) (cons a t')) u.
intros; exists (cons a (comp s t')); auto 6.
Save PC2_liftenv_ctxt_r.
Hint Resolve PC2_liftenv_ctxt_r.

Goal
forall (a : terms) (s t x' : sub_explicits),
e_relSL _ (lift s) x' ->
exists u : sub_explicits,
  e_relSLstar _ (cons a (comp s t)) u /\ e_relSLstar _ (comp x' (cons a t)) u.
intros a s t x' H; pattern s, x' in |- *; apply case_SLlift; auto.
Save PC_liftenv_ctxt_l'.
Hint Resolve PC_liftenv_ctxt_l'.

Goal
forall (a : terms) (s t x' : sub_explicits),
e_relSL _ (cons a t) x' ->
exists u : sub_explicits,
  e_relSLstar _ (cons a (comp s t)) u /\ e_relSLstar _ (comp (lift s) x') u.
intros a s t x' H; pattern x' in |- *; apply case_SLcons with a t; auto.
Save PC_liftenv_ctxt_r.
Hint Resolve PC_liftenv_ctxt_r.

Goal exists u : sub_explicits, e_relSLstar _ id u /\ e_relSLstar _ id u.
intros; exists id; auto.
Save PC_idl_idr.
Hint Resolve PC_idl_idr.

Goal
forall s s' : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits, e_relSLstar _ s u /\ e_relSLstar _ (comp id s') u.
intros; exists s'; auto 6.
Save PC_idl_ctxt_r.
Hint Resolve PC_idl_ctxt_r.

Goal
forall s s' : sub_explicits,
e_relSL _ s s' ->
exists u : sub_explicits, e_relSLstar _ s u /\ e_relSLstar _ (comp s' id) u.
intros; exists s'; auto 6.
Save PC_idr_ctxt_l.
Hint Resolve PC_idr_ctxt_l.

Goal
forall a a' : terms,
e_relSL _ a a' ->
exists u : terms, e_relSLstar _ a u /\ e_relSLstar _ (env a' id) u.
intros; exists a'; auto 6.
Save PC_id_ctxt_l.
Hint Resolve PC_id_ctxt_l.

