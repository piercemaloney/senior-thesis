
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Gt.
Require Import Minus.
Require Import Mult.
Require Import TS.  
(* TS:
Inductive wsort : Set :=
  | ws : wsort
  | wt : wsort.

Inductive TS : wsort -> Set :=
  | var : nat -> TS wt
  | app : TS wt -> TS wt -> TS wt
  | lambda : TS wt -> TS wt
  | env : TS wt -> TS ws -> TS wt
  | id : TS ws
  | shift : TS ws
  | cons : TS wt -> TS ws -> TS ws
  | comp : TS ws -> TS ws -> TS ws
  | lift : TS ws -> TS ws
  | meta_X : nat -> TS wt
  | meta_x : nat -> TS ws.

Definition terms := TS wt.

Definition sub_explicits := TS ws.
 
Goal (terms -> Prop) -> forall b : wsort, TS b -> Prop.
intros P b; elim b.
exact (fun x : TS ws => True).
exact P.
Defined Pterms.

Lemma terms_ind :
 forall P : terms -> Prop,
 (forall n : nat, P (var n)) ->
 (forall a b : terms, P a -> P b -> P (app a b)) ->
 (forall a : terms, P a -> P (lambda a)) ->
 (forall a : terms, P a -> forall s : sub_explicits, P (env a s)) ->
 (forall n : nat, P (meta_X n)) -> forall a : terms, P a.

Goal (sub_explicits -> Prop) -> forall b : wsort, TS b -> Prop.
intros P b; elim b.
exact P.
exact (fun x : TS wt => True).
Defined Psubst.

Lemma sub_explicits_ind :
 forall P : sub_explicits -> Prop,
 P id ->
 P shift ->
 (forall s : sub_explicits, P s -> forall a : terms, P (cons a s)) ->
 (forall s t : sub_explicits, P s -> P t -> P (comp s t)) ->
 (forall s : sub_explicits, P s -> P (lift s)) ->
 (forall n : nat, P (meta_x n)) -> forall s : sub_explicits, P s. *)
Require Import sigma_lift.
(* sigma_lift:
Require Import TS.
Require Import sur_les_relations.

Inductive reg_app : terms -> terms -> Prop :=
    reg1_app :
      forall (a b : terms) (s : sub_explicits),
      reg_app (env (app a b) s) (app (env a s) (env b s)). 
Hint Resolve reg1_app.

Inductive reg_lambda : terms -> terms -> Prop :=
    reg1_lambda :
      forall (a : terms) (s : sub_explicits),
      reg_lambda (env (lambda a) s) (lambda (env a (lift s))). 
Hint Resolve reg1_lambda.

Inductive reg_clos : terms -> terms -> Prop :=
    reg1_clos :
      forall (a : terms) (s t : sub_explicits),
      reg_clos (env (env a s) t) (env a (comp s t)). 
Hint Resolve reg1_clos.

Inductive reg_varshift1 : terms -> terms -> Prop :=
    reg1_varshift1 :
      forall n : nat, reg_varshift1 (env (var n) shift) (var (S n)). 
Hint Resolve reg1_varshift1.

Inductive reg_varshift2 : terms -> terms -> Prop :=
    reg1_varshift2 :
      forall (n : nat) (s : sub_explicits),
      reg_varshift2 (env (var n) (comp shift s)) (env (var (S n)) s). 
Hint Resolve reg1_varshift2.

Inductive reg_fvarcons : terms -> terms -> Prop :=
    reg1_fvarcons :
      forall (a : terms) (s : sub_explicits),
      reg_fvarcons (env (var 0) (cons a s)) a. 
Hint Resolve reg1_fvarcons.

Inductive reg_fvarlift1 : terms -> terms -> Prop :=
    reg1_fvarlift1 :
      forall s : sub_explicits, reg_fvarlift1 (env (var 0) (lift s)) (var 0). 
Hint Resolve reg1_fvarlift1.

Inductive reg_fvarlift2 : terms -> terms -> Prop :=
    reg1_fvarlift2 :
      forall s t : sub_explicits,
      reg_fvarlift2 (env (var 0) (comp (lift s) t)) (env (var 0) t). 
Hint Resolve reg1_fvarlift2.

Inductive reg_rvarcons : terms -> terms -> Prop :=
    reg1_rvarcons :
      forall (n : nat) (a : terms) (s : sub_explicits),
      reg_rvarcons (env (var (S n)) (cons a s)) (env (var n) s). 
Hint Resolve reg1_rvarcons.

Inductive reg_rvarlift1 : terms -> terms -> Prop :=
    reg1_rvarlift1 :
      forall (n : nat) (s : sub_explicits),
      reg_rvarlift1 (env (var (S n)) (lift s)) (env (var n) (comp s shift)). 
Hint Resolve reg1_rvarlift1.

Inductive reg_rvarlift2 : terms -> terms -> Prop :=
    reg1_rvarlift2 :
      forall (n : nat) (s t : sub_explicits),
      reg_rvarlift2 (env (var (S n)) (comp (lift s) t))
        (env (var n) (comp s (comp shift t))). 
Hint Resolve reg1_rvarlift2.

Inductive reg_assenv : sub_explicits -> sub_explicits -> Prop :=
    reg1_assenv :
      forall s t u : sub_explicits,
      reg_assenv (comp (comp s t) u) (comp s (comp t u)). 
Hint Resolve reg1_assenv.

Inductive reg_mapenv : sub_explicits -> sub_explicits -> Prop :=
    reg1_mapenv :
      forall (a : terms) (s t : sub_explicits),
      reg_mapenv (comp (cons a s) t) (cons (env a t) (comp s t)). 
Hint Resolve reg1_mapenv.

Inductive reg_shiftcons : sub_explicits -> sub_explicits -> Prop :=
    reg1_shiftcons :
      forall (a : terms) (s : sub_explicits),
      reg_shiftcons (comp shift (cons a s)) s. 
Hint Resolve reg1_shiftcons.

Inductive reg_shiftlift1 : sub_explicits -> sub_explicits -> Prop :=
    reg1_shiftlift1 :
      forall s : sub_explicits,
      reg_shiftlift1 (comp shift (lift s)) (comp s shift). 
Hint Resolve reg1_shiftlift1.

Inductive reg_shiftlift2 : sub_explicits -> sub_explicits -> Prop :=
    reg1_shiftlift2 :
      forall s t : sub_explicits,
      reg_shiftlift2 (comp shift (comp (lift s) t)) (comp s (comp shift t)). 
Hint Resolve reg1_shiftlift2. 

Inductive reg_lift1 : sub_explicits -> sub_explicits -> Prop :=
    reg1_lift1 :
      forall s t : sub_explicits,
      reg_lift1 (comp (lift s) (lift t)) (lift (comp s t)). 
Hint Resolve reg1_lift1.

Inductive reg_lift2 : sub_explicits -> sub_explicits -> Prop :=
    reg1_lift2 :
      forall s t u : sub_explicits,
      reg_lift2 (comp (lift s) (comp (lift t) u)) (comp (lift (comp s t)) u). 
Hint Resolve reg1_lift2.

Inductive reg_liftenv : sub_explicits -> sub_explicits -> Prop :=
    reg1_liftenv :
      forall (a : terms) (s t : sub_explicits),
      reg_liftenv (comp (lift s) (cons a t)) (cons a (comp s t)). 
Hint Resolve reg1_liftenv.

Inductive reg_idl : sub_explicits -> sub_explicits -> Prop :=
    reg1_idl : forall s : sub_explicits, reg_idl (comp id s) s. 
Hint Resolve reg1_idl.

Inductive reg_idr : sub_explicits -> sub_explicits -> Prop :=
    reg1_idr : forall s : sub_explicits, reg_idr (comp s id) s. 
Hint Resolve reg1_idr.

Inductive reg_liftid : sub_explicits -> sub_explicits -> Prop :=
    reg1_liftid : reg_liftid (lift id) id. 
Hint Resolve reg1_liftid.

Inductive reg_id : terms -> terms -> Prop :=
    reg1_id : forall a : terms, reg_id (env a id) a. 
Hint Resolve reg1_id.

Inductive e_systemSL : forall b : wsort, TS b -> TS b -> Prop :=
  | regle_app : forall a b : terms, reg_app a b -> e_systemSL wt a b
  | regle_lambda : forall a b : terms, reg_lambda a b -> e_systemSL wt a b
  | regle_clos : forall a b : terms, reg_clos a b -> e_systemSL wt a b
  | regle_varshift1 :
      forall a b : terms, reg_varshift1 a b -> e_systemSL wt a b
  | regle_varshift2 :
      forall a b : terms, reg_varshift2 a b -> e_systemSL wt a b
  | regle_fvarcons :
      forall a b : terms, reg_fvarcons a b -> e_systemSL wt a b
  | regle_fvarlift1 :
      forall a b : terms, reg_fvarlift1 a b -> e_systemSL wt a b
  | regle_fvarlift2 :
      forall a b : terms, reg_fvarlift2 a b -> e_systemSL wt a b
  | regle_rvarcons :
      forall a b : terms, reg_rvarcons a b -> e_systemSL wt a b
  | regle_rvarlift1 :
      forall a b : terms, reg_rvarlift1 a b -> e_systemSL wt a b
  | regle_rvarlift2 :
      forall a b : terms, reg_rvarlift2 a b -> e_systemSL wt a b
  | regle_assenv :
      forall s t : sub_explicits, reg_assenv s t -> e_systemSL ws s t
  | regle_mapenv :
      forall s t : sub_explicits, reg_mapenv s t -> e_systemSL ws s t
  | regle_shiftcons :
      forall s t : sub_explicits, reg_shiftcons s t -> e_systemSL ws s t
  | regle_shiftlift1 :
      forall s t : sub_explicits, reg_shiftlift1 s t -> e_systemSL ws s t
  | regle_shiftlift2 :
      forall s t : sub_explicits, reg_shiftlift2 s t -> e_systemSL ws s t
  | regle_lift1 :
      forall s t : sub_explicits, reg_lift1 s t -> e_systemSL ws s t
  | regle_lift2 :
      forall s t : sub_explicits, reg_lift2 s t -> e_systemSL ws s t
  | regle_liftenv :
      forall s t : sub_explicits, reg_liftenv s t -> e_systemSL ws s t
  | regle_idl : forall s t : sub_explicits, reg_idl s t -> e_systemSL ws s t
  | regle_idr : forall s t : sub_explicits, reg_idr s t -> e_systemSL ws s t
  | regle_liftid :
      forall s t : sub_explicits, reg_liftid s t -> e_systemSL ws s t
  | regle_id : forall a b : terms, reg_id a b -> e_systemSL wt a b.

Notation systemSL := (e_systemSL _) (only parsing).

Hint Resolve regle_app regle_lambda regle_clos regle_varshift1
  regle_varshift2 regle_fvarcons regle_fvarlift1 regle_fvarlift2
  regle_rvarcons regle_rvarlift1 regle_rvarlift2 regle_assenv regle_mapenv
  regle_shiftcons regle_shiftlift1 regle_shiftlift2 regle_lift1 regle_lift2
  regle_liftenv regle_idl regle_idr regle_liftid regle_id.

Inductive e_relSL : forall b : wsort, TS b -> TS b -> Prop :=
  | SL_one_regle :
      forall (b : wsort) (M N : TS b), e_systemSL _ M N -> e_relSL b M N
  | SL_context_app_l :
      forall a a' b : terms,
      e_relSL wt a a' -> e_relSL wt (app a b) (app a' b)
  | SL_context_app_r :
      forall a b b' : terms,
      e_relSL wt b b' -> e_relSL wt (app a b) (app a b')
  | SL_context_lambda :
      forall a a' : terms,
      e_relSL wt a a' -> e_relSL wt (lambda a) (lambda a')
  | SL_context_env_t :
      forall (a a' : terms) (s : sub_explicits),
      e_relSL wt a a' -> e_relSL wt (env a s) (env a' s)
  | SL_context_env_s :
      forall (a : terms) (s s' : sub_explicits),
      e_relSL ws s s' -> e_relSL wt (env a s) (env a s')
  | SL_context_cons_t :
      forall (a a' : terms) (s : sub_explicits),
      e_relSL wt a a' -> e_relSL ws (cons a s) (cons a' s)
  | SL_context_cons_s :
      forall (a : terms) (s s' : sub_explicits),
      e_relSL ws s s' -> e_relSL ws (cons a s) (cons a s')
  | SL_context_comp_l :
      forall s s' t : sub_explicits,
      e_relSL ws s s' -> e_relSL ws (comp s t) (comp s' t)
  | SL_context_comp_r :
      forall s t t' : sub_explicits,
      e_relSL ws t t' -> e_relSL ws (comp s t) (comp s t')
  | SL_context_lift :
      forall s s' : sub_explicits,
      e_relSL ws s s' -> e_relSL ws (lift s) (lift s').

Notation relSL := (e_relSL _) (only parsing).

Hint Resolve SL_one_regle SL_context_app_l SL_context_app_r SL_context_lambda
  SL_context_env_t SL_context_env_s SL_context_cons_t SL_context_cons_s
  SL_context_comp_l SL_context_comp_r SL_context_lift.

Definition e_relSLstar (b : wsort) := explicit_star _ (e_relSL b).

Notation relSLstar := (e_relSLstar _) (only parsing).

Hint Unfold e_relSLstar.

Goal
forall a a' b : terms,
e_relSLstar _ a a' -> e_relSLstar _ (app a b) (app a' b).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (app y b); auto.
Save SLstar_context_app_l.
Hint Resolve SLstar_context_app_l.

Goal
forall a b b' : terms,
e_relSLstar _ b b' -> e_relSLstar _ (app a b) (app a b').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (app a y); auto.
Save SLstar_context_app_r.
Hint Resolve SLstar_context_app_r.

Goal
forall a a' : terms,
e_relSLstar _ a a' -> e_relSLstar _ (lambda a) (lambda a').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (lambda y); auto.
Save SLstar_context_lambda.
Hint Resolve SLstar_context_lambda.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relSLstar _ a a' -> e_relSLstar _ (env a s) (env a' s).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (env y s); auto.
Save SLstar_context_env_t.
Hint Resolve SLstar_context_env_t.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relSLstar _ s s' -> e_relSLstar _ (env a s) (env a s').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (env a y); auto.
Save SLstar_context_env_s.
Hint Resolve SLstar_context_env_s.

Goal
forall (a a' : terms) (s : sub_explicits),
e_relSLstar _ a a' -> e_relSLstar _ (cons a s) (cons a' s). 
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (cons y s); auto.
Save SLstar_context_cons_t.
Hint Resolve SLstar_context_cons_t.

Goal
forall (a : terms) (s s' : sub_explicits),
e_relSLstar _ s s' -> e_relSLstar _ (cons a s) (cons a s'). 
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (cons a y); auto.
Save SLstar_context_cons_s.
Hint Resolve SLstar_context_cons_s.

Goal
forall s s' t : sub_explicits,
e_relSLstar _ s s' -> e_relSLstar _ (comp s t) (comp s' t).
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (comp y t); auto.
Save SLstar_context_comp_l.
Hint Resolve SLstar_context_comp_l.

Goal
forall s t t' : sub_explicits,
e_relSLstar _ t t' -> e_relSLstar _ (comp s t) (comp s t').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (comp s y); auto.
Save SLstar_context_comp_r.
Hint Resolve SLstar_context_comp_r.

Goal
forall s s' : sub_explicits,
e_relSLstar _ s s' -> e_relSLstar _ (lift s) (lift s').
red in |- *; simple induction 1; intros.
auto.
apply star_trans1 with (lift y); auto.
Save SLstar_context_lift.
Hint Resolve SLstar_context_lift. *)
Require Import comparith.
(* comparith:
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Gt.
Require Import Minus.
Require Import Mult.

Hint Resolve mult_n_O mult_n_Sm plus_le_compat. 

Goal forall n m : nat, n > m -> S n > m.
auto with arith.
Save gt_S_l.
Hint Resolve gt_S_l.

Goal forall n m : nat, n > S m -> n > m.
auto with arith.
Save gt_S_r.
Hint Resolve gt_S_r.
 
Goal forall n m p : nat, n = m -> p + n = p + m.
intros; elim p; elim H; auto with arith.
Save eq_plus_reg_r.
Hint Resolve eq_plus_reg_r.

Goal forall n m p : nat, n = m -> n + p = m + p.
intros; elim p; elim H; auto with arith.
Save eq_plus_reg_l.
Hint Resolve eq_plus_reg_l.

Goal forall n m p : nat, n > m -> n + p > m + p.
intros; elim (plus_comm p m); elim (plus_comm p n); auto with arith.
Save gt_reg_r.
Hint Resolve gt_reg_r.

Goal forall n m p q : nat, n > m -> p > q -> n + p > m + q.
simple induction 1; intros; simpl in |- *; auto with arith.
Save gt_plus_plus.
Hint Resolve gt_plus_plus.

Goal forall p : nat, p > 0 -> forall n : nat, p + n > n.
simple induction 1; intros.
auto with arith.
simpl in |- *; auto with arith.
Save gt_plus_l.
Hint Resolve gt_plus_l.

Goal forall p : nat, p > 0 -> forall n : nat, n + p > n.
intros; elim (plus_comm p n); auto with arith.
Save gt_plus_r.
Hint Resolve gt_plus_r.

Goal forall n m p : nat, n > m -> n + p > m.
auto with arith.
Save gt_plus_trans_r.
Hint Resolve gt_plus_trans_r.

Goal forall n m p : nat, n > m -> p + n > m.
intros; elim (plus_comm n p); auto with arith.
Save gt_plus_trans_l.
Hint Resolve gt_plus_trans_l.

Goal forall n : nat, S n = n + 1.
simple induction n.
auto with arith.
simpl in |- *; auto with arith.
Save S_plus.
Hint Resolve S_plus.
 
Goal forall n m : nat, n * m = m * n.
simple induction n; intros.
auto with arith.
simpl in |- *; elim mult_n_Sm; elim H; auto with arith.
Save mult_sym.
Hint Resolve mult_sym.

Goal forall n m p : nat, n * (m * p) = n * m * p.
intros n m p; elim n; simpl in |- *.
auto with arith.
intros y H; rewrite mult_plus_distr_r; elim H; auto with arith.
Save mult_assoc_l.
Hint Resolve mult_assoc_l.

Goal forall n m p : nat, n * (m * p) = m * (n * p).
intros; rewrite (mult_assoc_l m n p); rewrite (mult_sym m n); auto with arith.
Save mult_permut.
Hint Resolve mult_permut. 

Goal forall n m p : nat, p * (n + m) = p * n + p * m.
intros n m p; elim p.
auto with arith.
simpl in |- *; intros y H; rewrite H; elim plus_assoc; elim plus_assoc.
pattern (y * n + (m + y * m)) in |- *; elim plus_permute; trivial with arith.
Save mult_plus_distr_r.
Hint Resolve comparith.mult_plus_distr_r.

Goal forall n : nat, n * 2 = n + n.
simple induction n.
auto with arith.
intros; simpl in |- *; rewrite H; auto with arith.
Save mult_n_2. 
Hint Resolve mult_n_2.
 
Goal forall n : nat, n = n * 1.  
simple induction n.
auto with arith.
simpl in |- *; auto with arith.
Save mult_n_1. 
Hint Resolve mult_n_1.

Goal forall n m p : nat, n = m -> p * n = p * m.
intros; elim p; elim H; auto with arith.
Save eq_mult_reg_r.
Hint Resolve eq_mult_reg_r.

Goal forall n m p : nat, n = m -> n * p = m * p.
intros; elim p; elim H; auto with arith.
Save eq_mult_reg_l.
Hint Resolve eq_mult_reg_l.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> p * n > p * m.
simple induction p.
intros H n m H0; absurd (0 > 0); auto with arith.
intros y H H0 n m H1; elim (gt_O_eq y); intros.
simpl in |- *; auto with arith.
elim H2; simpl in |- *; elim (plus_n_O n); elim (plus_n_O m);
 trivial with arith.
Save gt_mult_reg_l.
Hint Resolve gt_mult_reg_l.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> n * p > m * p.
intros; elim (mult_sym p n); elim (mult_sym p m); auto with arith.
Save gt_mult_reg_r.
Hint Resolve gt_mult_reg_r.

Goal forall p : nat, p > 1 -> forall n : nat, n > 0 -> p * n > n.
simple induction p.
intros H n H0; absurd (0 > 1); auto with arith.
intros y H H0 n H1; simpl in |- *; apply gt_plus_r; replace 0 with (y * 0);
 auto with arith.
Save gt_mult_l.
Hint Resolve gt_mult_l.

Goal forall p : nat, p > 1 -> forall n : nat, n > 0 -> n * p > n.
intros; elim (mult_sym p n); auto with arith.
Save gt_mult_r.
Hint Resolve gt_mult_r.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> p * n > m.
simple induction p.
intros H n m H0; simpl in |- *; absurd (0 > 0); auto with arith.
intros y H H0 n m H1; simpl in |- *; elim (gt_O_eq y); intro H2.
auto with arith.
elim H2; simpl in |- *; elim plus_n_O; assumption.
Save gt_mult_trans_r.
Hint Resolve gt_mult_trans_r.

Goal forall p : nat, p > 0 -> forall n m : nat, n > m -> n * p > m.
intros; elim (mult_sym p n); auto with arith.
Save gt_mult_trans_l.
Hint Resolve gt_mult_trans_l.

Fixpoint power2 (n : nat) : nat :=
  match n with
  | O => 1
  | S p => 2 * power2 p
  end.

Goal forall n : nat, power2 n > 0.
simple induction n; simpl in |- *; intros.
auto with arith.
elim plus_n_O; auto with arith.
Save gt_power2_O.
Hint Resolve gt_power2_O. *)

Definition e_P2 (b : wsort) (U : TS b) : nat :=
  (fix F (w : wsort) (t : TS w) {struct t} : nat :=
     match t with
     | var _ => 1
     | app t0 t1 => S (F wt t0 + F wt t1)
     | lambda t0 => 2 * F wt t0
     | env t0 t1 => F wt t0 * S (F ws t1)
     | id => 1
     | shift => 1
     | cons t0 t1 => S (F wt t0 + F ws t1)
     | comp t0 t1 => F ws t0 * S (F ws t1)
     | lift t0 => 4 * F ws t0
     | meta_X _ => 1
     | meta_x _ => 1
     end) b U.
 
Notation P2 := (e_P2 _) (only parsing).

Theorem P2_pos : forall (b : wsort) (M : TS b), e_P2 _ M > 0.
Proof.
simple induction M; simpl in |- *; intros; auto with arith.
Qed.
Hint Resolve P2_pos.

Theorem P2_app : forall M N : terms, reg_app M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; elim Mult.mult_plus_distr_r;
 auto with arith.
Qed.
Hint Resolve P2_app.

Theorem P2_lambda : forall M N : terms, reg_lambda M N -> e_P2 _ M < e_P2 _ N.
Proof.
simple induction 1; intros.
change (2 * (e_P2 _ a * S (4 * e_P2 _ s)) > 2 * e_P2 _ a * S (e_P2 _ s))
 in |- *.
elim mult_assoc_reverse; auto with arith.
Qed.
Hint Resolve P2_lambda.

Theorem P2_clos : forall M N : terms, reg_clos M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *.
elim mult_assoc_l; apply gt_mult_reg_l.
auto with arith.
simpl in |- *; auto with arith.
Qed.
Hint Resolve P2_clos.

Theorem P2_varshift1 :
 forall M N : terms, reg_varshift1 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; simpl in |- *; auto with arith.
Qed.
Hint Resolve P2_varshift1.

Theorem P2_varshift2 :
 forall M N : terms, reg_varshift2 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; repeat elim plus_n_O;
 auto with arith.
Qed.
Hint Resolve P2_varshift2.

Theorem P2_fvarcons :
 forall M N : terms, reg_fvarcons M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.
Qed.
Hint Resolve P2_fvarcons.

Theorem P2_fvarlift1 :
 forall M N : terms, reg_fvarlift1 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change (1 * S (4 * e_P2 _ s) > 1) in |- *.
auto with arith.
Qed.
Hint Resolve P2_fvarlift1.

Theorem P2_fvarlift2 :
 forall M N : terms, reg_fvarlift2 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; repeat elim plus_n_O;
 auto with arith.
Qed.
Hint Resolve P2_fvarlift2.

Theorem P2_rvarcons :
 forall M N : terms, reg_rvarcons M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; repeat elim plus_n_O;
 auto with arith.
Qed.
Hint Resolve P2_rvarcons.

Theorem P2_rvarlift1 :
 forall M N : terms, reg_rvarlift1 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; repeat elim plus_n_O.
elim mult_n_2; auto with arith.
Qed.
Hint Resolve P2_rvarlift1.

Theorem P2_rvarlift2 :
 forall M N : terms, reg_rvarlift2 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change
  (1 * S (4 * e_P2 _ s * S (e_P2 _ t)) >
   1 * S (e_P2 _ s * S (1 * S (e_P2 _ t)))) in |- *.
unfold mult at 1 in |- *; unfold mult at 3 in |- *; unfold mult at 4 in |- *;
 repeat elim plus_n_O.
apply gt_n_S; repeat elim mult_n_Sm; elim plus_assoc.
apply gt_plus_plus.
elim mult_assoc_l; auto with arith.
elim mult_n_2; elim mult_sym; auto with arith.
Qed.
Hint Resolve P2_rvarlift2.

Theorem P2_assenv :
 forall M N : sub_explicits, reg_assenv M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *.
rewrite mult_assoc_reverse; simpl in |- *; auto with arith.
Qed.
Hint Resolve P2_assenv.

Theorem P2_mapenv :
 forall M N : sub_explicits, reg_mapenv M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; elim Mult.mult_plus_distr_r;
 auto with arith.
Qed.
Hint Resolve P2_mapenv.

Theorem P2_shiftcons :
 forall M N : sub_explicits, reg_shiftcons M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; elim plus_n_O; auto with arith.
Qed.
Hint Resolve P2_shiftcons.

Theorem P2_shiftlift1 :
 forall M N : sub_explicits, reg_shiftlift1 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change (1 * S (4 * e_P2 _ s) > e_P2 _ s * 2) in |- *.
unfold mult at 1 in |- *; elim plus_n_O.
apply gt_S_l; elim mult_sym; auto with arith.
Qed.
Hint Resolve P2_shiftlift1.

Theorem P2_shiftlift2 :
 forall M N : sub_explicits, reg_shiftlift2 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change
  (1 * S (4 * e_P2 _ s * S (e_P2 _ t)) > e_P2 _ s * S (1 * S (e_P2 _ t)))
 in |- *.
unfold mult at 1 in |- *; elim plus_n_O; unfold mult at 4 in |- *;
 elim plus_n_O.
apply gt_S_l; repeat elim mult_n_Sm; elim plus_assoc.
apply gt_plus_plus.
elim mult_assoc_l; auto with arith.
elim mult_n_2; elim mult_sym; auto with arith.
Qed.
Hint Resolve P2_shiftlift2.

Theorem P2_lift1 :
 forall M N : sub_explicits, reg_lift1 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change (4 * e_P2 _ s * S (4 * e_P2 _ t) > 4 * (e_P2 _ s * S (e_P2 _ t)))
 in |- *.
elim mult_assoc_reverse; auto with arith.
Qed.
Hint Resolve P2_lift1.

Theorem P2_lift2 :
 forall M N : sub_explicits, reg_lift2 M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change
  (4 * e_P2 _ s * S (4 * e_P2 _ t * S (e_P2 _ u)) >
   4 * (e_P2 _ s * S (e_P2 _ t)) * S (e_P2 _ u)) in |- *.
elim mult_assoc_reverse;
 elim (mult_assoc_l (4 * e_P2 _ s) (S (e_P2 _ t)) (S (e_P2 _ u)));
 apply gt_mult_reg_l.
auto with arith.
apply gt_S_l; apply gt_mult_reg_r.
auto with arith.
apply gt_trans with (3 * e_P2 _ t).
auto with arith.
simpl in |- *; elim plus_n_O; rewrite S_plus; apply plus_gt_compat_l.
elim mult_n_2; auto with arith.
Qed.
Hint Resolve P2_lift2.

Theorem P2_liftenv :
 forall M N : sub_explicits, reg_liftenv M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros.
change
  (4 * e_P2 _ s * S (S (e_P2 _ a + e_P2 _ t)) >
   S (e_P2 _ a + e_P2 _ s * S (e_P2 _ t))) in |- *.
cut (S (S (e_P2 _ a + e_P2 _ t)) = e_P2 _ a + (e_P2 _ t + 2)).
intro H1; rewrite H1. 
rewrite (S_plus (e_P2 _ a + e_P2 _ s * S (e_P2 _ t)));
 rewrite comparith.mult_plus_distr_r.
elim plus_assoc; apply gt_plus_plus.
apply gt_mult_l.
auto with arith.
auto with arith.
replace (e_P2 _ t + 2) with (e_P2 _ t + 1 + 1).
rewrite comparith.mult_plus_distr_r; apply gt_plus_plus.
elim S_plus; elim mult_assoc_l.
apply gt_mult_l; auto with arith.
apply gt_mult_l; auto with arith.
elim (plus_n_Sm (e_P2 _ t) 1); auto with arith.
rewrite plus_assoc; elim plus_n_Sm; elim plus_n_Sm; elim plus_n_O;
 auto with arith.
Qed.
Hint Resolve P2_liftenv.

Theorem P2_idl :
 forall M N : sub_explicits, reg_idl M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; simpl in |- *; intros; elim plus_n_O; auto with arith.
Qed.
Hint Resolve P2_idl.

Theorem P2_idr :
 forall M N : sub_explicits, reg_idr M N -> e_P2 _ M > e_P2 _ N.
Proof. 
simple induction 1; intros; simpl in |- *; auto with arith.
Qed.
Hint Resolve P2_idr.

Theorem P2_liftid :
 forall M N : sub_explicits, reg_liftid M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; auto with arith.
Qed.
Hint Resolve P2_liftid.

Theorem P2_id : forall M N : terms, reg_id M N -> e_P2 _ M > e_P2 _ N.
Proof.
simple induction 1; intros; simpl in |- *; auto with arith.
Qed.
Hint Resolve P2_id.

