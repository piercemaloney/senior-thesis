
Require Import TS.
(* TS:
Inductive wsort : Set :=
  | ws : wsort
  | wt : wsort.

Inductive TS : wsort -> Set :=
  | var : nat -> TS wt
  | app : TS wt -> TS wt -> TS wt
  | lambda : TS wt -> TS wt
  | env : TS wt -> TS ws -> TS wt
  | id : TS ws
  | shift : TS ws
  | cons : TS wt -> TS ws -> TS ws
  | comp : TS ws -> TS ws -> TS ws
  | lift : TS ws -> TS ws
  | meta_X : nat -> TS wt
  | meta_x : nat -> TS ws.

Definition terms := TS wt.

Definition sub_explicits := TS ws.
 
Goal (terms -> Prop) -> forall b : wsort, TS b -> Prop.
intros P b; elim b.
exact (fun x : TS ws => True).
exact P.
Defined Pterms.

Lemma terms_ind :
 forall P : terms -> Prop,
 (forall n : nat, P (var n)) ->
 (forall a b : terms, P a -> P b -> P (app a b)) ->
 (forall a : terms, P a -> P (lambda a)) ->
 (forall a : terms, P a -> forall s : sub_explicits, P (env a s)) ->
 (forall n : nat, P (meta_X n)) -> forall a : terms, P a.

Goal (sub_explicits -> Prop) -> forall b : wsort, TS b -> Prop.
intros P b; elim b.
exact P.
exact (fun x : TS wt => True).
Defined Psubst.

Lemma sub_explicits_ind :
 forall P : sub_explicits -> Prop,
 P id ->
 P shift ->
 (forall s : sub_explicits, P s -> forall a : terms, P (cons a s)) ->
 (forall s t : sub_explicits, P s -> P t -> P (comp s t)) ->
 (forall s : sub_explicits, P s -> P (lift s)) ->
 (forall n : nat, P (meta_x n)) -> forall s : sub_explicits, P s. *)
Require Import sur_les_relations.
(* sur_les_relations:
Section Rels.

Variable A : Set.

Inductive explicit_star (R : A -> A -> Prop) : A -> A -> Prop :=
  | star_refl : forall x : A, explicit_star R x x
  | star_trans1 :
      forall x y z : A, R x y -> explicit_star R y z -> explicit_star R x z.

Inductive explicit_comp_rel (R1 R2 : A -> A -> Prop) : A -> A -> Prop :=
    comp_2rel :
      forall x y z : A, R1 x y -> R2 y z -> explicit_comp_rel R1 R2 x z.

Inductive explicit_rel_plus (R : A -> A -> Prop) : A -> A -> Prop :=
  | relplus_1step : forall x y : A, R x y -> explicit_rel_plus R x y
  | relplus_trans1 :
      forall x y z : A,
      R x y -> explicit_rel_plus R y z -> explicit_rel_plus R x z. 

End Rels.

Hint Resolve star_refl.
Hint Resolve relplus_1step.

Notation star := (explicit_star _) (only parsing).

Notation comp_rel := (explicit_comp_rel _) (only parsing).

Notation rel_plus := (explicit_rel_plus _) (only parsing).

Section rels_prop.

Variable A : Set.
Variable R : A -> A -> Prop.

Definition confluence_en (x : A) :=
  forall y z : A,
  explicit_star _ R x y ->
  explicit_star _ R x z ->
  exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_confluence := forall x : A, confluence_en x.

Definition local_confluence_en (x : A) :=
  forall y z : A,
  R x y ->
  R x z -> exists u : A, explicit_star _ R y u /\ explicit_star _ R z u.

Definition explicit_local_confluence := forall x : A, local_confluence_en x.

Definition strong_confluence_en (x : A) :=
  forall y z : A, R x y -> R x z -> exists u : A, R y u /\ R z u.

Definition explicit_strong_confluence := forall x : A, strong_confluence_en x.

End rels_prop.

Notation confluence := (explicit_confluence _) (only parsing).

Notation local_confluence := (explicit_local_confluence _) (only parsing).

Notation strong_confluence := (explicit_strong_confluence _) (only parsing).

Definition explicit_inclus (A : Set) (R1 R2 : A -> A -> Prop) :=
  forall x y : A, R1 x y -> R2 x y.

Notation inclus := (explicit_inclus _) (only parsing).

Section relations_noetherian.

Variable U : Set.

Variable R : U -> U -> Prop.

Definition a_set := U -> Prop.

Definition sub (A B : a_set) := forall x : U, A x -> B x.

Definition universal (A : a_set) := forall x : U, A x.

Definition adjoint (A : a_set) : a_set := fun x : U => sub (R x) A.

Definition hereditary (A : a_set) := sub (adjoint A) A.

Definition explicit_noetherian :=
  forall A : a_set, hereditary A -> universal A.

End relations_noetherian.

Notation noetherian := (explicit_noetherian _) (only parsing).

Goal
forall (A : Set) (P Q : A -> Prop),
(exists u : A, P u /\ Q u) -> exists u : A, Q u /\ P u.
simple induction 1; intros u1 H1.
elim H1; intros H2 H3.
exists u1; split; assumption.
Save Ex_PQ.
Hint Resolve Ex_PQ.
 
Lemma star_trans :
 forall (A : Set) (R : A -> A -> Prop) (x y z : A),
 explicit_star _ R x y -> explicit_star _ R y z -> explicit_star _ R x z.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
R x y -> explicit_star _ R x y.
intros; apply star_trans1 with y.
assumption.
apply star_refl.
Save star_step1.

Hint Resolve star_step1.

Goal
forall (A : Set) (R1 R2 : A -> A -> Prop) (M N : A),
explicit_comp_rel _ R1 R2 M N -> exists u : A, R1 M u /\ R2 u N.  
intros A R1 R2 M N H; elim H.
intros x y z H1 H2; exists y; split; assumption.
Save comp_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_comp_rel _ R (explicit_star _ R) x y -> explicit_rel_plus _ R x y.
intros A R x y H; elim H.
intros a b c H1 H2; generalize H1; generalize a.
elim H2.
intros; apply relplus_1step; assumption.
intros x0 y0 z H3 H4 H5 a0 H6; apply relplus_trans1 with x0.
assumption.
apply H5; assumption.
Save comp_relplus.

Goal
forall (A : Set) (R : A -> A -> Prop) (M N : A),
explicit_star _ R M N ->
M = N \/ (exists u : A, R M u /\ explicit_star _ R u N).
intros A R M N H; elim H.
intros x; left; trivial.
intros x y z H1 H2 H3; right; exists y; split; trivial.
Save star_case.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_rel_plus _ R x y ->
explicit_rel_plus _ R y z -> explicit_rel_plus _ R x z.
simple induction 1.
intros; apply relplus_trans1 with y0; trivial.
intros; apply relplus_trans1 with y0; auto.
Save Rplus_transitive.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y : A),
explicit_rel_plus _ R x y -> explicit_star _ R x y.
simple induction 1; intros.
auto.
apply star_trans1 with y0; auto.
Save Rplus_Rstar.

Hint Resolve Rplus_Rstar.

Goal
forall (A : Set) (R : A -> A -> Prop) (x y z : A),
explicit_star _ R x y ->
explicit_rel_plus _ R y z -> exists u : A, R x u /\ explicit_star _ R u z.
simple induction 1; intros.
elim H0; intros.
exists y0; auto.
exists y0; auto.
exists y0; split; trivial.
apply star_trans with z0; auto.
Save Rstar_Rplus_R.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_noetherian _ R ->
forall A1 : a_set A,
hereditary A (explicit_rel_plus _ R) A1 ->
universal A (adjoint A (explicit_star _ R) A1).
unfold explicit_noetherian in |- *; unfold hereditary in |- *;
 unfold universal in |- *; unfold sub in |- *; intros A R N A1 H x.
apply (N (adjoint A (explicit_star _ R) A1)).
unfold adjoint in |- *; unfold sub in |- *; intros.
apply H; unfold adjoint in |- *; unfold sub in |- *; intros.
elim Rstar_Rplus_R with A R x0 x1 x2; trivial.
intro z; simple induction 1; intros C1 C2; apply H0 with z; trivial.
Save noetherian_course_of_values.

Lemma plus_preserves_noetherian :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R -> explicit_noetherian _ (explicit_rel_plus _ R).

Lemma noetherian_induction1 :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, R y z -> P z) -> P y) -> P x.

Lemma noetherian_induction :
 forall (A : Set) (R : A -> A -> Prop),
 explicit_noetherian _ R ->
 forall (x : A) (P : A -> Prop),
 (forall y : A, (forall z : A, explicit_rel_plus _ R y z -> P z) -> P y) ->
 P x.

Lemma noether_inclus :
 forall (A : Set) (R R' : A -> A -> Prop),
 explicit_noetherian _ R ->
 (forall x y : A, R' x y -> R x y) -> explicit_noetherian _ R'.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R (explicit_star _ S) ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
intros A R S H; red in |- *; simple induction 1.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans with y0; auto.
Save inclus_star.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ (explicit_star _ R) (explicit_star _ S).
unfold explicit_inclus in |- *; simple induction 2.
auto.
intros x0 y0 z H1 H2 H3; apply star_trans1 with y0.
apply (H x0 y0 H1).
assumption.
Save inclus_reg_star.
Hint Resolve inclus_reg_star.

Goal
forall (A : Set) (R1 R2 S : A -> A -> Prop),
explicit_inclus _ R1 S ->
explicit_inclus _ R2 S ->

(forall x y z : A, S x y -> S y z -> S x z) ->
explicit_inclus _ (explicit_comp_rel _ R1 R2) S.   
intros A R1 R2 S H H0 H1; red in |- *; simple induction 1.
intros x0 y0 z H3 H4; apply H1 with y0; auto.
Save inclus_comp.
Hint Resolve inclus_comp.

Goal
forall (A : Set) (R : A -> A -> Prop),
explicit_strong_confluence _ R -> explicit_confluence _ R.
intros A R H; red in |- *; red in |- *.
intros x y z H1; generalize z; elim H1.
intros x0 z0 H2; exists z0; split; auto.
intros x0 y0 y1 H2 H3 H4 z0 H5.
cut (exists u : A, explicit_star _ R y0 u /\ R z0 u).
intro H6; elim H6; intros z1 H7; elim H7; intros H8 H9.
elim (H4 z1 H8); intros u H10; elim H10; intros H11 H12.
exists u; split.
assumption.
apply star_trans1 with z1; assumption.
generalize H2; generalize y0; elim H5.
intros x1 y2 H6; exists y2; split; auto.
intros x1 y2 z1 H6 H7 H8 y3 H9; elim (H x1 y3 y2).
intros x2 H10; elim H10; intros H11 H12.
elim (H8 x2 H12); intros u H13; elim H13; intros H14 H15.
exists u; split; [ apply star_trans1 with x2; assumption | assumption ];
 trivial.
assumption.
assumption.
Save strong_conf_conf.

Goal
forall (A : Set) (R S : A -> A -> Prop),
explicit_inclus _ R S ->
explicit_inclus _ S (explicit_star _ R) ->
explicit_confluence _ S -> explicit_confluence _ R.
red in |- *; red in |- *; intros A R S H H0 H1 x y z H2 H3.
cut (explicit_inclus _ (explicit_star _ R) (explicit_star _ S)).
2: auto.
intro H4; elim (H1 x y z (H4 x y H2) (H4 x z H3)).
intros x' H5; elim H5; intros H6 H7.
exists x'; split.
exact (inclus_star A S R H0 y x' H6).
exact (inclus_star A S R H0 z x' H7).
Save inclus_conf. *)

Inductive e_beta_par : forall b : wsort, TS b -> TS b -> Prop :=
  | var_bpar : forall n : nat, e_beta_par wt (var n) (var n)
  | id_bpar : e_beta_par ws id id
  | shift_bpar : e_beta_par ws shift shift
  | app_bpar :
      forall M N M' N' : terms,
      e_beta_par wt M M' ->
      e_beta_par wt N N' -> e_beta_par wt (app M N) (app M' N')
  | lambda_bpar :
      forall M M' : terms,
      e_beta_par wt M M' -> e_beta_par wt (lambda M) (lambda M')
  | env_bpar :
      forall (M M' : terms) (s s' : sub_explicits),
      e_beta_par wt M M' ->
      e_beta_par ws s s' -> e_beta_par wt (env M s) (env M' s')
  | beta_bpar :
      forall M N M' N' : terms,
      e_beta_par wt M M' ->
      e_beta_par wt N N' ->
      e_beta_par wt (app (lambda M) N) (env M' (cons N' id))
  | cons_bpar :
      forall (M M' : terms) (s s' : sub_explicits),
      e_beta_par wt M M' ->
      e_beta_par ws s s' -> e_beta_par ws (cons M s) (cons M' s')
  | lift_bpar :
      forall s s' : sub_explicits,
      e_beta_par ws s s' -> e_beta_par ws (lift s) (lift s')
  | comp_bpar :
      forall s s' t t' : sub_explicits,
      e_beta_par ws s s' ->
      e_beta_par ws t t' -> e_beta_par ws (comp s t) (comp s' t')
  | metaX_bpar : forall n : nat, e_beta_par wt (meta_X n) (meta_X n)
  | metax_bpar : forall n : nat, e_beta_par ws (meta_x n) (meta_x n).

Hint Resolve var_bpar id_bpar shift_bpar app_bpar lambda_bpar env_bpar
  beta_bpar cons_bpar lift_bpar comp_bpar metaX_bpar metax_bpar.

Notation beta_par := (e_beta_par _) (only parsing).

Goal forall (b : wsort) (M : TS b), e_beta_par _ M M.
simple induction M; auto.
Save refl_betapar.
Hint Resolve refl_betapar.

Definition e_betapar_inv (b : wsort) (M N : TS b) :=
  match M in (TS b) return Prop with
  | var n =>
       
      match N in (TS b) return Prop with
      | var m =>
            n = m
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False 
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | app M1 M2 =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => e_beta_par _ M1 N1 /\ e_beta_par _ M2 N2
           
      | lambda N1 => False 
           
      | env N1 N2 =>
          exists M3 : terms,
            (exists N3 : terms,
               M1 = lambda M3 /\
               e_beta_par _ M3 N1 /\ N2 = cons N3 id /\ e_beta_par _ M2 N3)
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | lambda M1 =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => e_beta_par _ M1 N1
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | env M1 M2 =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False 
           
      | env N1 N2 => e_beta_par _ M1 N1 /\ e_beta_par _ M2 N2
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | id =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => True
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | shift =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => True 
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end 
       
  | cons M1 M2 =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False 
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => e_beta_par _ M1 N1 /\ e_beta_par _ M2 N2
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | comp M1 M2 =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => e_beta_par _ M1 N1 /\ e_beta_par _ M2 N2
           
      | lift N1 => False
           
      | meta_X n => False
           
      | meta_x n => False
      end 
       
  | lift M1 =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => e_beta_par _ M1 N1
           
      | meta_X n => False
           
      | meta_x n => False
      end
       
  | meta_X n =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X m => n = m
           
      | meta_x m => False
      end
       
  | meta_x n =>
      match N in (TS b) return Prop with
      | var n =>
            False
           
      | app N1 N2 => False 
           
      | lambda N1 => False
           
      | env N1 N2 => False
           
      | id => False
           
      | shift => False
           
      | cons N1 N2 => False
           
      | comp N1 N2 => False
           
      | lift N1 => False
           
      | meta_X m => False
           
      | meta_x m => n = m
      end
  end.

Notation betapar_inv := (e_betapar_inv _) (only parsing).

Goal
forall (b : wsort) (M N : TS b), e_beta_par _ M N -> e_betapar_inv _ M N.
simple induction 1; intros; simpl in |- *; auto.
exists M0; exists N'; auto.
Save lemma1_inv_betapar.
Hint Resolve lemma1_inv_betapar.

Goal
forall (P : terms -> Prop) (n : nat),
P (var n) -> forall M : terms, e_beta_par _ (var n) M -> P M.
intros P n H M H0; cut (e_betapar_inv _ (var n) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1; assumption.

simple induction 3.

simple induction 2.

simple induction 2.
simple induction 1.
Save case_bvar.

Goal
forall (P : terms -> Prop) (a b : terms),
(forall a' b' : terms,
 e_beta_par _ a a' -> e_beta_par _ b b' -> P (app a' b')) ->
(forall a1 a1' b' : terms,
 a = lambda a1 ->
 e_beta_par _ a1 a1' -> e_beta_par _ b b' -> P (env a1' (cons b' id))) ->
forall M : terms, e_beta_par _ (app a b) M -> P M.
intros P a b H H0 M H1; cut (e_betapar_inv _ (app a b) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.

unfold e_betapar_inv at 3 in |- *; intros a' b' H2 H3 H4.
elim H4; intros H5 H6.
apply H; assumption.

simple induction 2.

unfold e_betapar_inv at 2 in |- *; intros a1' H2 s H3.
elim H3; intros a1 H4; elim H4; intros b' H5.
elim H5; intros H6 H7; elim H7; intros H8 H9; elim H9; intros H10 H11.
try rewrite H6; try rewrite H10; apply (H0 a1); assumption.
simple induction 1.
Save case_bapp.

Goal
forall (P : terms -> Prop) (a : terms),
(forall a' : terms, e_beta_par _ a a' -> P (lambda a')) ->
forall M : terms, e_beta_par _ (lambda a) M -> P M.
intros P a H M H0; cut (e_betapar_inv _ (lambda a) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.

simple induction 3.

unfold e_betapar_inv at 2 in |- *; intros a' H1 H2.
apply H; assumption.

simple induction 2.
simple induction 1.
Save case_blambda.

Goal
forall (P : terms -> Prop) (a : terms) (s : sub_explicits),
(forall (a' : terms) (s' : sub_explicits),
 e_beta_par _ a a' -> e_beta_par _ s s' -> P (env a' s')) ->
forall M : terms, e_beta_par _ (env a s) M -> P M.
intros P a s H M H0; cut (e_betapar_inv _ (env a s) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.

simple induction 3.

simple induction 2.

unfold e_betapar_inv at 2 in |- *; intros a' H1 s' H2.
elim H2; intros; apply H; assumption.
simple induction 1.
Save case_benv.

Goal
forall P : sub_explicits -> Prop,
P id -> forall M : sub_explicits, e_beta_par _ id M -> P M.
intros P H M H0; cut (e_betapar_inv _ id M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

intro; assumption.

simple induction 1.

simple induction 2.

simple induction 3.

simple induction 2.
simple induction 1.
Save case_bid.

Goal
forall P : sub_explicits -> Prop,
P shift -> forall M : sub_explicits, e_beta_par _ shift M -> P M.
intros P H M H0; cut (e_betapar_inv _ shift M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.

intro; assumption.

simple induction 2.

simple induction 3.

simple induction 2.
simple induction 1.
Save case_bshift.

Goal
forall (P : sub_explicits -> Prop) (a : terms) (s : sub_explicits),
(forall (a' : terms) (s' : sub_explicits),
 e_beta_par _ a a' -> e_beta_par _ s s' -> P (cons a' s')) ->
forall M : sub_explicits, e_beta_par _ (cons a s) M -> P M.
intros P a s H M H0; cut (e_betapar_inv _ (cons a s) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.

simple induction 1.

unfold e_betapar_inv at 2 in |- *; intros s' H1 a' H2.
elim H2; intros.
apply H; assumption.

simple induction 3.

simple induction 2.
simple induction 1.
Save case_bcons.

Goal
forall (P : sub_explicits -> Prop) (s t : sub_explicits),
(forall s' t' : sub_explicits,
 e_beta_par _ s s' -> e_beta_par _ t t' -> P (comp s' t')) ->
forall M : sub_explicits, e_beta_par _ (comp s t) M -> P M.
intros P s t H M H0; cut (e_betapar_inv _ (comp s t) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.

simple induction 1.

simple induction 2.

unfold e_betapar_inv at 3 in |- *.
intros s' t' H1 H2 H3; elim H3; intros; apply H; assumption.

simple induction 2.
simple induction 1.
Save case_bcomp.

Goal
forall (P : sub_explicits -> Prop) (s : sub_explicits),
(forall s' : sub_explicits, e_beta_par _ s s' -> P (lift s')) ->
forall M : sub_explicits, e_beta_par _ (lift s) M -> P M.
intros P s H M H0; cut (e_betapar_inv _ (lift s) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.

simple induction 1.

simple induction 2.

simple induction 3.

unfold e_betapar_inv at 2 in |- *.
intros s' H1 H2; apply H; assumption.
simple induction 1.
Save case_blift.

Goal
forall (P : terms -> Prop) (n : nat),
P (meta_X n) -> forall M : terms, e_beta_par _ (meta_X n) M -> P M.
intros P n H M H0; cut (e_betapar_inv _ (meta_X n) M).
2: auto.
pattern M in |- *; apply terms_ind.

simple induction 1.

simple induction 3.

simple induction 2.

simple induction 2.
simple induction 1; assumption.
Save case_bmetaX.

Goal
forall (P : sub_explicits -> Prop) (n : nat),
P (meta_x n) -> forall M : sub_explicits, e_beta_par _ (meta_x n) M -> P M.
intros P n H M H0; cut (e_betapar_inv _ (meta_x n) M).
2: auto.
pattern M in |- *; apply sub_explicits_ind.

simple induction 1.

simple induction 1.

simple induction 2.

simple induction 3.

simple induction 2.
simple induction 1; assumption.
Save case_bmetax.

