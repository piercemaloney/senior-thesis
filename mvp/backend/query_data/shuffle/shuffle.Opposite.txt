

Require Import Bool.

Require Import Words.
(* Words:
Require Import Bool.

Inductive word : Set :=
  | empty : word
  | bit : bool -> word -> word.

Inductive conc : word -> word -> word -> Prop :=
  | conc_empty : forall v : word, conc empty v v
  | conc_bit :
      forall (u v w : word) (b : bool),
      conc u v w -> conc (bit b u) v (bit b w).

Fixpoint append (u : word) : word -> word :=
  fun v : word =>
  match u with
  | empty => v
  | bit b w => bit b (append w v)
  end. 

Lemma conc_append : forall u v w : word, conc u v w -> w = append u v.

Lemma assoc_append :
 forall u v w : word, append u (append v w) = append (append u v) w.

Definition single (b : bool) := bit b empty.

Inductive odd : word -> Prop :=
    even_odd : forall w : word, even w -> forall b : bool, odd (bit b w)
with even : word -> Prop :=
  | even_empty : even empty
  | odd_even : forall w : word, odd w -> forall b : bool, even (bit b w).

Hint Resolve odd_even even_empty even_odd.

Lemma not_odd_empty : ~ odd empty.

Hint Resolve not_odd_empty.

Lemma inv_odd : forall (w : word) (b : bool), odd (bit b w) -> even w.

Lemma inv_even : forall (w : word) (b : bool), even (bit b w) -> odd w.

Lemma odd_or_even : forall w : word, odd w \/ even w.

Lemma not_odd_and_even : forall w : word, odd w -> even w -> False.

Lemma odd_even_conc :
 forall u v w : word,
 conc u v w ->
 odd w /\ (odd u /\ even v \/ even u /\ odd v) \/
 even w /\ (odd u /\ odd v \/ even u /\ even v).

Lemma even_conc :
 forall u v w : word,
 conc u v w -> even w -> odd u /\ odd v \/ even u /\ even v. *)

Require Import Alternate.
(* Alternate:
Require Import Bool.
Require Import Words.

Inductive alt : bool -> word -> Prop :=
  | alt_empty : forall b : bool, alt b empty
  | alt_bit : forall (b : bool) (w : word), alt (negb b) w -> alt b (bit b w).

Hint Resolve alt_empty alt_bit.

Lemma alt_neg_intro :
 forall (b b' : bool) (w : word), alt b (bit b' w) -> alt (negb b) w.

Lemma alt_neg_elim :
 forall (b b' : bool) (w : word), alt (negb b) (bit b' w) -> alt b w.

Lemma alt_eq : forall (b b' : bool) (w : word), alt b (bit b' w) -> b = b'.

Lemma alt_back :
 forall (b b' : bool) (w : word),
 alt b (bit b' w) -> b = b' /\ alt (negb b) w.

Inductive alternate (w : word) : Prop :=
    alter : forall b : bool, alt b w -> alternate w.

Lemma alt_conc_l :
 forall u v w : word, conc u v w -> forall b : bool, alt b w -> alt b u.

Lemma alt_conc_r :
 forall u v w : word,
 conc u v w ->
 forall b : bool, alt b w -> odd u /\ alt (negb b) v \/ even u /\ alt b v.

Lemma alt_conc :
 forall u v w : word, conc u v w -> alternate w -> alternate u /\ alternate v. *)



Inductive opposite : word -> word -> Prop :=

    opp : forall (u v : word) (b : bool), opposite (bit b u) (bit (negb b) v).



Hint Resolve opp.



Lemma not_opp_empty_r : forall u : word, ~ opposite u empty.

Proof.

unfold not in |- *; intros u op.

inversion op.

Qed.



Lemma not_opp_empty_l : forall u : word, ~ opposite empty u.

Proof.

unfold not in |- *; intros u op.

inversion op.

Qed.



Lemma not_opp_same :

 forall (u v : word) (b : bool), ~ opposite (bit b u) (bit b v).

Proof.

unfold not in |- *; intros u v b op.

inversion op.

apply (no_fixpoint_negb b); trivial.

Qed.



Lemma alt_neg_opp :

 forall (u v : word) (b : bool),

 odd u -> alt b u -> odd v -> alt (negb b) v -> opposite u v.

Proof.

simple induction u.

intros v b odd_empty; absurd (odd empty); trivial.

intros b u' H v; elim v.

intros b' H1 H2 odd_empty.

absurd (odd empty); trivial.

intros b' v' H' b'' H1 H2 H3 H4.

elim (alt_eq (negb b'') b' v'); trivial.

elim (alt_eq b'' b u'); trivial.

Qed.



Lemma alt_not_opp :

 forall (u v : word) (b : bool), alt b u -> alt b v -> ~ opposite u v.

Proof.

simple induction u.

intros; apply not_opp_empty_l.

intros b u' H v; elim v.

intros; apply not_opp_empty_r.

intros b' v' H1 b'' H2 H3.

elim (alt_eq b'' b' v'); trivial.

elim (alt_eq b'' b u'); trivial.

apply not_opp_same.

Qed.

