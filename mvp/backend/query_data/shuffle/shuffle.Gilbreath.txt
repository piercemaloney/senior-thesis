
Require Import Bool.
Require Import Words.
(* Words:
Require Import Bool.

Inductive word : Set :=
  | empty : word
  | bit : bool -> word -> word.

Inductive conc : word -> word -> word -> Prop :=
  | conc_empty : forall v : word, conc empty v v
  | conc_bit :
      forall (u v w : word) (b : bool),
      conc u v w -> conc (bit b u) v (bit b w).

Fixpoint append (u : word) : word -> word :=
  fun v : word =>
  match u with
  | empty => v
  | bit b w => bit b (append w v)
  end. 

Lemma conc_append : forall u v w : word, conc u v w -> w = append u v.

Lemma assoc_append :
 forall u v w : word, append u (append v w) = append (append u v) w.

Definition single (b : bool) := bit b empty.

Inductive odd : word -> Prop :=
    even_odd : forall w : word, even w -> forall b : bool, odd (bit b w)
with even : word -> Prop :=
  | even_empty : even empty
  | odd_even : forall w : word, odd w -> forall b : bool, even (bit b w).

Hint Resolve odd_even even_empty even_odd.

Lemma not_odd_empty : ~ odd empty.

Hint Resolve not_odd_empty.

Lemma inv_odd : forall (w : word) (b : bool), odd (bit b w) -> even w.

Lemma inv_even : forall (w : word) (b : bool), even (bit b w) -> odd w.

Lemma odd_or_even : forall w : word, odd w \/ even w.

Lemma not_odd_and_even : forall w : word, odd w -> even w -> False.

Lemma odd_even_conc :
 forall u v w : word,
 conc u v w ->
 odd w /\ (odd u /\ even v \/ even u /\ odd v) \/
 even w /\ (odd u /\ odd v \/ even u /\ even v).

Lemma even_conc :
 forall u v w : word,
 conc u v w -> even w -> odd u /\ odd v \/ even u /\ even v. *)
Require Import Alternate.
(* Alternate:
Require Import Bool.
Require Import Words.

Inductive alt : bool -> word -> Prop :=
  | alt_empty : forall b : bool, alt b empty
  | alt_bit : forall (b : bool) (w : word), alt (negb b) w -> alt b (bit b w).

Hint Resolve alt_empty alt_bit.

Lemma alt_neg_intro :
 forall (b b' : bool) (w : word), alt b (bit b' w) -> alt (negb b) w.

Lemma alt_neg_elim :
 forall (b b' : bool) (w : word), alt (negb b) (bit b' w) -> alt b w.

Lemma alt_eq : forall (b b' : bool) (w : word), alt b (bit b' w) -> b = b'.

Lemma alt_back :
 forall (b b' : bool) (w : word),
 alt b (bit b' w) -> b = b' /\ alt (negb b) w.

Inductive alternate (w : word) : Prop :=
    alter : forall b : bool, alt b w -> alternate w.

Lemma alt_conc_l :
 forall u v w : word, conc u v w -> forall b : bool, alt b w -> alt b u.

Lemma alt_conc_r :
 forall u v w : word,
 conc u v w ->
 forall b : bool, alt b w -> odd u /\ alt (negb b) v \/ even u /\ alt b v.

Lemma alt_conc :
 forall u v w : word, conc u v w -> alternate w -> alternate u /\ alternate v. *)
Require Import Opposite.
(* Opposite:
Require Import Bool.
Require Import Words.
Require Import Alternate.

Inductive opposite : word -> word -> Prop :=
    opp : forall (u v : word) (b : bool), opposite (bit b u) (bit (negb b) v).

Hint Resolve opp.

Lemma not_opp_empty_r : forall u : word, ~ opposite u empty.

Lemma not_opp_empty_l : forall u : word, ~ opposite empty u.

Lemma not_opp_same :
 forall (u v : word) (b : bool), ~ opposite (bit b u) (bit b v).

Lemma alt_neg_opp :
 forall (u v : word) (b : bool),
 odd u -> alt b u -> odd v -> alt (negb b) v -> opposite u v.

Lemma alt_not_opp :
 forall (u v : word) (b : bool), alt b u -> alt b v -> ~ opposite u v. *)
Require Import Paired.
(* Paired:
Require Import Bool.
Require Import Words.

Inductive paired : word -> Prop :=
  | paired_empty : paired empty
  | paired_bit :
      forall w : word,
      paired w -> forall b : bool, paired (bit (negb b) (bit b w)).

Definition paired_odd_l (b : bool) (w : word) := paired (bit (negb b) w).

Lemma paired_odd_l_intro :
 forall (b : bool) (w : word), paired w -> paired_odd_l b (bit b w).

Lemma paired_odd_l_elim :
 forall (b : bool) (w : word), paired_odd_l (negb b) w -> paired (bit b w).

Definition paired_odd_r (b : bool) (w : word) := paired (append w (single b)).

Inductive paired_rot : bool -> word -> Prop :=
  | paired_rot_empty : forall b : bool, paired_rot b empty
  | paired_rot_bit :
      forall (b : bool) (w : word),
      paired_odd_r b w -> paired_rot b (bit b w).

Lemma paired_odd_r_from_rot :
 forall (w : word) (b : bool),
 paired_rot b w -> paired_odd_r b (bit (negb b) w).

Inductive paired_bet (b : bool) : word -> Prop :=
    paired_bet_bit :
      forall w : word, paired_odd_r (negb b) w -> paired_bet b (bit b w).

Lemma paired_odd_r_from_bet :
 forall (b : bool) (w : word),
 paired_bet (negb b) w -> paired_odd_r b (bit b w).

Definition rotate (w : word) : word :=
  match w with
  | empty => empty
  | bit b w => append w (single b)
  end.

Lemma paired_rotate :
 forall (w : word) (b : bool), paired_rot b w -> paired (rotate w). *)
Require Import Shuffle.
(* Shuffle:
Require Import Bool.
Require Import Words.
Require Import Alternate.
Require Import Opposite.
Require Import Paired.

Inductive shuffle : word -> word -> word -> Prop :=
  | shuffle_empty : shuffle empty empty empty
  | shuffle_bit_left :
      forall u v w : word,
      shuffle u v w -> forall b : bool, shuffle (bit b u) v (bit b w)
  | shuffle_bit_right :
      forall u v w : word,
      shuffle u v w -> forall b : bool, shuffle u (bit b v) (bit b w).

Lemma Shuffling :
 forall u v w : word,
 shuffle u v w ->
 forall b : bool,
 alt b u ->
 odd u /\
 (odd v /\ (alt (negb b) v -> paired w) /\ (alt b v -> paired_bet b w) \/
  even v /\
  (alt b v -> paired_odd_l b w) /\
  (alt (negb b) v -> paired_odd_r (negb b) w)) \/
 even u /\
 (odd v /\
  (alt (negb b) v -> paired_odd_r b w) /\ (alt b v -> paired_odd_l b w) \/
  even v /\ (alt b v -> paired_rot b w) /\ (alt (negb b) v -> paired w)). *)

Section Context.

Variable x : word.
Hypothesis Even_x : even x.
Variable b : bool. 
Hypothesis A : alt b x.
Variable u v : word.
Hypothesis C : conc u v x.
Variable w : word.
Hypothesis S : shuffle u v w.

Lemma Alt_u : alt b u.
Proof.
apply alt_conc_l with v x.
apply C.
apply A.
Qed.

Section Case1_.
Hypothesis Odd_u : odd u.

Lemma Not_even_u : ~ even u.
Proof.
red in |- *; intro.
elim not_odd_and_even with u; trivial.
Qed.

Lemma Odd_v : odd v.
Proof.
elim even_conc with u v x.
intro H; elim H; trivial.
intro H; elim H; intro; elim Not_even_u; trivial.
apply C.
apply Even_x.
Qed.

Remark Alt_v_neg : alt (negb b) v.
Proof.
elim alt_conc_r with u v x b.
intro H; elim H; trivial.
intro H; elim H; intro; elim Not_even_u; trivial.
apply C.
apply A.
Qed.

Lemma Opp_uv : opposite u v.
Proof.
apply alt_neg_opp with b.
apply Odd_u.
apply Alt_u.
apply Odd_v.
apply Alt_v_neg.
Qed.

Lemma Case1 : paired w.
Proof.
elim Shuffling with u v w b.
simple induction 1; simple induction 2; simple induction 1;
 simple induction 2; intros P1 P2.
apply P1.
apply Alt_v_neg.
elim not_odd_and_even with v; trivial.
apply Odd_v.
simple induction 1; intro; elim Not_even_u; trivial.
apply S.
apply Alt_u.
Qed.
End Case1_.

Section Case2_.
Hypothesis Even_u : even u.

Lemma Not_odd_u : ~ odd u.
Proof.
red in |- *; intro; elim not_odd_and_even with u; trivial.
Qed.

Lemma Even_v : even v.
Proof.
elim even_conc with u v x.
intro H; elim H; intro; elim Not_odd_u; trivial.
intro H; elim H; trivial.
apply C.
apply Even_x.
Qed.

Remark Alt_v : alt b v.
Proof.
elim alt_conc_r with u v x b.
intro H; elim H; intro; elim Not_odd_u; trivial.
intro H; elim H; trivial.
apply C.
apply A.
Qed.

Lemma Not_opp_uv : ~ opposite u v.
Proof.
apply alt_not_opp with b.
apply Alt_u.
apply Alt_v.
Qed.

Lemma Case2 : paired (rotate w).
Proof.
apply paired_rotate with b.
elim Shuffling with u v w b.
simple induction 1; intro; elim Not_odd_u; trivial.
simple induction 1; simple induction 2.
simple induction 1; intros; elim not_odd_and_even with v; trivial.
apply Even_v.
simple induction 1; simple induction 2; intros P1 P2.
apply P1.
apply Alt_v.
apply S.
apply Alt_u.
Qed.

End Case2_.

Lemma Main : IF opposite u v then paired w else paired (rotate w).
Proof.
unfold IF_then_else in |- *; elim odd_or_even with u; intros.

left; split.
apply Opp_uv; trivial.
apply Case1; trivial.

right; split.
apply Not_opp_uv; trivial.
apply Case2; trivial.
Qed.

End Context.

Theorem Gilbreath :
 forall x : word,
 even x ->
 alternate x ->
 forall u v : word,
 conc u v x ->
 forall w : word,
 shuffle u v w -> IF opposite u v then paired w else paired (rotate w).

Proof.
simple induction 2; intros. 
apply Main with x b; trivial.
Qed.
