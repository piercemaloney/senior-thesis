

Require Import Bool.

Require Import Words.
(* Words:
Require Import Bool.

Inductive word : Set :=
  | empty : word
  | bit : bool -> word -> word.

Inductive conc : word -> word -> word -> Prop :=
  | conc_empty : forall v : word, conc empty v v
  | conc_bit :
      forall (u v w : word) (b : bool),
      conc u v w -> conc (bit b u) v (bit b w).

Fixpoint append (u : word) : word -> word :=
  fun v : word =>
  match u with
  | empty => v
  | bit b w => bit b (append w v)
  end. 

Lemma conc_append : forall u v w : word, conc u v w -> w = append u v.

Lemma assoc_append :
 forall u v w : word, append u (append v w) = append (append u v) w.

Definition single (b : bool) := bit b empty.

Inductive odd : word -> Prop :=
    even_odd : forall w : word, even w -> forall b : bool, odd (bit b w)
with even : word -> Prop :=
  | even_empty : even empty
  | odd_even : forall w : word, odd w -> forall b : bool, even (bit b w).

Hint Resolve odd_even even_empty even_odd.

Lemma not_odd_empty : ~ odd empty.

Hint Resolve not_odd_empty.

Lemma inv_odd : forall (w : word) (b : bool), odd (bit b w) -> even w.

Lemma inv_even : forall (w : word) (b : bool), even (bit b w) -> odd w.

Lemma odd_or_even : forall w : word, odd w \/ even w.

Lemma not_odd_and_even : forall w : word, odd w -> even w -> False.

Lemma odd_even_conc :
 forall u v w : word,
 conc u v w ->
 odd w /\ (odd u /\ even v \/ even u /\ odd v) \/
 even w /\ (odd u /\ odd v \/ even u /\ even v).

Lemma even_conc :
 forall u v w : word,
 conc u v w -> even w -> odd u /\ odd v \/ even u /\ even v. *)



Inductive paired : word -> Prop :=

  | paired_empty : paired empty

  | paired_bit :

      forall w : word,

      paired w -> forall b : bool, paired (bit (negb b) (bit b w)).



Definition paired_odd_l (b : bool) (w : word) := paired (bit (negb b) w).



Lemma paired_odd_l_intro :

 forall (b : bool) (w : word), paired w -> paired_odd_l b (bit b w).

Proof.

unfold paired_odd_l in |- *; intros.

apply paired_bit; trivial.

Qed.



Lemma paired_odd_l_elim :

 forall (b : bool) (w : word), paired_odd_l (negb b) w -> paired (bit b w).

Proof.

unfold paired_odd_l in |- *; intros.

rewrite (negb_intro b); trivial.

Qed.



Definition paired_odd_r (b : bool) (w : word) := paired (append w (single b)).



Inductive paired_rot : bool -> word -> Prop :=

  | paired_rot_empty : forall b : bool, paired_rot b empty

  | paired_rot_bit :

      forall (b : bool) (w : word),

      paired_odd_r b w -> paired_rot b (bit b w).



Lemma paired_odd_r_from_rot :

 forall (w : word) (b : bool),

 paired_rot b w -> paired_odd_r b (bit (negb b) w).

Proof.

simple induction 1.

intro; unfold paired_odd_r in |- *; simpl in |- *.

unfold single in |- *; apply paired_bit.

apply paired_empty.

intros b0 b' w'; unfold paired_odd_r in |- *; intros.

simpl in |- *; apply paired_bit; auto.

Qed.



Inductive paired_bet (b : bool) : word -> Prop :=

    paired_bet_bit :

      forall w : word, paired_odd_r (negb b) w -> paired_bet b (bit b w).



Lemma paired_odd_r_from_bet :

 forall (b : bool) (w : word),

 paired_bet (negb b) w -> paired_odd_r b (bit b w).

Proof.

intros b w pb.

rewrite (negb_intro b).

elim pb.

unfold paired_odd_r in |- *. 

intros; simpl in |- *.

apply paired_bit; trivial.

Qed.



Definition rotate (w : word) : word :=

  match w with

  | empty => empty

  | bit b w => append w (single b)

  end.



Lemma paired_rotate :

 forall (w : word) (b : bool), paired_rot b w -> paired (rotate w).

Proof.

simple induction 1.

intro; simpl in |- *; apply paired_empty.

intros b' w'; simpl in |- *.

unfold paired_odd_r in |- *; trivial.

Qed.

