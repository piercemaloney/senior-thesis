

Require Import Ensembles.
(* Ensembles:
Require Import Classical.

Section Ensembles.
   Variable U : Type.
   
   Definition Ensemble := U -> Prop.
   
   Definition In (B : Ensemble) (x : U) : Prop := B x.
   
   Definition Included (B C : Ensemble) : Prop :=
     forall x : U, In B x -> In C x.
   
   Inductive Empty_set : Ensemble :=.
   
   Inductive Singleton (x : U) : Ensemble :=
       In_singleton : In (Singleton x) x.
   
   Inductive Union (B C : Ensemble) : Ensemble :=
     | Union_introl : forall x : U, In B x -> In (Union B C) x
     | Union_intror : forall x : U, In C x -> In (Union B C) x.
   
   Inductive Intersection (B C : Ensemble) : Ensemble :=
       Intersection_intro :
         forall x : U, In B x -> In C x -> In (Intersection B C) x.
   
   Inductive Couple (x y : U) : Ensemble :=
     | Couple_l : In (Couple x y) x
     | Couple_r : In (Couple x y) y.
   
   Inductive Setminus (B C : Ensemble) : Ensemble :=
       Setminus_intro :
         forall x : U, In B x -> ~ In C x -> In (Setminus B C) x.
   
   Inductive Disjoint (B C : Ensemble) : Prop :=
       Disjoint_intro :
         (forall x : U, ~ In (Intersection B C) x) -> Disjoint B C.
   
   Inductive Non_empty (B : Ensemble) : Prop :=
       Non_empty_intro : forall x : U, In B x -> Non_empty B.
   
   Inductive Finite : Ensemble -> Prop :=
     | Empty_is_finite : Finite Empty_set
     | Union_is_finite :
         forall A : Ensemble,
         Finite A -> forall x : U, ~ In A x -> Finite (Union (Singleton x) A).

   Definition Same_set (B C : Ensemble) : Prop :=
     Included B C /\ Included C B.
      
   Lemma Same_set_intro :
    forall B C : Ensemble, Included B C -> Included C B -> Same_set B C.

   Axiom
     Extensionality_Ensembles :
       forall A B : Ensemble, Same_set A B -> A = B :>Ensemble.
   
End Ensembles.
Hint Unfold In.
Hint Unfold Included.
Hint Resolve Same_set_intro.
Hint Resolve Union_introl Union_intror.
Hint Resolve Intersection_intro.
Hint Resolve In_singleton.
Hint Resolve Couple_l Couple_r.
Hint Resolve Setminus_intro.
Hint Resolve Disjoint_intro.
Hint Resolve Empty_is_finite Union_is_finite.
Hint Resolve Extensionality_Ensembles. *)

Require Import Relations_1.
(* Relations_1:
Section Relations_1.
   Variable U : Type.
   
   Definition Relation := U -> U -> Prop.
   Variable R : Relation.
   
   Definition Reflexive : Prop := forall x : U, R x x.
   
   Definition Transitive : Prop := forall x y z : U, R x y -> R y z -> R x z.
   
   Definition Symmetric : Prop := forall x y : U, R x y -> R y x.
   
   Definition Antisymmetric : Prop :=
     forall x y : U, R x y -> R y x -> x = y :>U.
   
   Definition contains (R R' : Relation) : Prop :=
     forall x y : U, R' x y -> R x y.
   
   Definition same_relation (R R' : Relation) : Prop :=
     contains R R' /\ contains R' R.
   
   Inductive Preorder : Prop :=
       Definition_of_preorder : Reflexive -> Transitive -> Preorder.
   
   Inductive Order : Prop :=
       Definition_of_order :
         Reflexive -> Transitive -> Antisymmetric -> Order.
   
   Inductive Equivalence : Prop :=
       Definition_of_equivalence :
         Reflexive -> Transitive -> Symmetric -> Equivalence.
   
   Inductive PER : Prop :=
       Definition_of_PER : Symmetric -> Transitive -> PER.
   
End Relations_1.
Hint Unfold Reflexive.
Hint Unfold Transitive.
Hint Unfold Antisymmetric.
Hint Unfold Symmetric.
Hint Unfold contains.
Hint Unfold same_relation.
Hint Resolve Definition_of_preorder.
Hint Resolve Definition_of_order.
Hint Resolve Definition_of_equivalence.
Hint Resolve Definition_of_PER. *)

Require Import podefs.
(* podefs:
Require Import Ensembles.
Require Import Relations_1.

Section Partial_orders.
   Variable U : Type.
   
   Definition Carrier := Ensemble U.
   
   Definition Rel := Relation U.
   
   Inductive PO : Type :=
       Definition_of_PO :
         forall (C : Carrier) (R : Rel), Non_empty U C -> Order U R -> PO.
   
   Theorem Carrier_of : PO -> Carrier.

   Theorem Rel_of : PO -> Rel.

   Definition SRel_of (p : PO) : Rel := fun x y : U => Rel_of p x y /\ x <> y.
   
End Partial_orders.
Hint Unfold Carrier_of Rel_of. *)

Require Import podefs_1.
(* podefs_1:
Require Import Ensembles.
Require Import Relations_1.
Require Import podefs.

Section Bounds.
   Variable U : Type.
   Variable D : PO U.
   
   Let C := Carrier_of U D.
   
   Let R := Rel_of U D.
   
   Inductive Totally_ordered (B : Ensemble U) : Prop :=
       Totally_ordered_definition :
         (Included U B C ->
          forall x y : U, Included U (Couple U x y) B -> R x y \/ R y x) ->
         Totally_ordered B.
   
   Inductive Upper_Bound (B : Ensemble U) (x : U) : Prop :=
       Upper_Bound_definition :
         In U C x -> (forall y : U, In U B y -> R y x) -> Upper_Bound B x.
   
   Inductive Lower_Bound (B : Ensemble U) (x : U) : Prop :=
       Lower_Bound_definition :
         In U C x -> (forall y : U, In U B y -> R x y) -> Lower_Bound B x.
   
   Inductive Lub (B : Ensemble U) (x : U) : Prop :=
       Lub_definition :
         Upper_Bound B x ->
         (forall y : U, Upper_Bound B y -> R x y) -> Lub B x.
   
   Inductive Glb (B : Ensemble U) (x : U) : Prop :=
       Glb_definition :
         Lower_Bound B x ->
         (forall y : U, Lower_Bound B y -> R y x) -> Glb B x.
   
   Inductive Bottom (bot : U) : Prop :=
       Bottom_definition :
         In U C bot -> (forall y : U, In U C y -> R bot y) -> Bottom bot.
   
   Definition Compatible (x y : U) : Prop :=
     exists z : U,
       In U C x -> In U C y -> In U C z /\ Upper_Bound (Couple U x y) z.
   
   Inductive Directed (X : Ensemble U) : Prop :=
       Definition_of_Directed :
         Included U X C ->
         Non_empty U X ->
         (forall x1 x2 : U,
          Included U (Couple U x1 x2) X ->
          exists x3 : U, In U X x3 /\ Upper_Bound (Couple U x1 x2) x3) ->
         Directed X.
   
   Inductive Complete : Prop :=
       Definition_of_Complete :
         (exists bot : U, Bottom bot) ->
         (forall X : Ensemble U, Directed X -> exists bsup : U, Lub X bsup) ->
         Complete.
   
   Definition Cpo : Prop := Complete.
   
   Definition Chain : Prop := Totally_ordered C.
   
   Inductive Conditionally_complete : Prop :=
       Definition_of_Conditionally_complete :
         (forall X : Ensemble U,
          Included U X C ->
          (exists maj : U, Upper_Bound X maj) -> exists bsup : U, Lub X bsup) ->
         Conditionally_complete.
   
End Bounds.
Hint Unfold Carrier_of.
Hint Unfold Rel_of.
Hint Resolve Totally_ordered_definition Upper_Bound_definition
  Lower_Bound_definition Lub_definition Glb_definition Bottom_definition
  Definition_of_Complete Definition_of_Complete
  Definition_of_Conditionally_complete. *)

Require Import ps.
(* ps:
Require Import Classical.

Require Import Ensembles.
Require Import Relations_1.
Require Import Relations_1_facts.
Require Import podefs.
Require Import podefs_1.

Section The_power_set_partial_order.
   Variable U : Type.
   
   Inductive Power_set (A : Ensemble U) : Ensemble (Ensemble U) :=
       Definition_of_Power_set :
         forall X : Ensemble U,
         Included U X A -> In (Ensemble U) (Power_set A) X.
   Hint Resolve Definition_of_Power_set.
   
   Variable A : Ensemble U.
   
   Theorem Empty_set_minimal :
    forall X : Ensemble U, Included U (Empty_set U) X.
   Hint Resolve Empty_set_minimal.
   
   Theorem Power_set_non_empty :
    forall A : Ensemble U, Non_empty (Ensemble U) (Power_set A).
   Hint Resolve Power_set_non_empty.
   
   Theorem Inclusion_is_an_order : Order (Ensemble U) (Included U).
   Hint Resolve Inclusion_is_an_order.
   
   Theorem Inclusion_is_transitive : Transitive (Ensemble U) (Included U).
   Hint Resolve Inclusion_is_transitive.
   
   Theorem Same_set_equivalence : Equivalence (Ensemble U) (Same_set U).

   Theorem Same_set_reflexive : Reflexive (Ensemble U) (Same_set U).
   Hint Resolve Same_set_reflexive.
   
   Theorem Power_set_PO : PO (Ensemble U).
   Proof.
   apply Definition_of_PO with (Power_set A) (Included U); auto.
   
   Theorem Union_minimal :
    forall a b X : Ensemble U,
    Included U a X -> Included U b X -> Included U (Union U a b) X.
   Hint Resolve Union_minimal.
   
   Theorem Intersection_maximal :
    forall a b X : Ensemble U,
    Included U X a -> Included U X b -> Included U X (Intersection U a b).
   
   Theorem Union_increases_l :
    forall a b : Ensemble U, Included U a (Union U a b).
   
   Theorem Union_increases_r :
    forall a b : Ensemble U, Included U b (Union U a b).
   
   Theorem Intersection_decreases_l :
    forall a b : Ensemble U, Included U (Intersection U a b) a.
   
   Theorem Intersection_decreases_r :
    forall a b : Ensemble U, Included U (Intersection U a b) b.
   Hint Resolve Union_increases_l Union_increases_r Intersection_decreases_l
     Intersection_decreases_r.
   
   Theorem Empty_set_is_Bottom :
    Bottom (Ensemble U) Power_set_PO (Empty_set U).
   Hint Resolve Empty_set_is_Bottom.
  
   Theorem Union_is_Lub :
    forall a b : Ensemble U,
    Included U a A ->
    Included U b A ->
    Lub (Ensemble U) Power_set_PO (Couple (Ensemble U) a b) (Union U a b).

   Theorem Intersection_is_Glb :
    forall a b : Ensemble U,
    Included U a A ->
    Included U b A ->
    Glb (Ensemble U) Power_set_PO (Couple (Ensemble U) a b)
      (Intersection U a b).
   Proof.
   intros a b H' H'0.
   apply Glb_definition.
   apply Lower_Bound_definition; simpl in |- *.
   apply Definition_of_Power_set; auto.
   
   Theorem Empty_set_zero :
    forall X : Ensemble U, Union U (Empty_set U) X = X.
   
   Theorem Union_commutative :
    forall A B : Ensemble U, Union U A B = Union U B A.
   
   Theorem Union_associative :
    forall A B C : Ensemble U,
    Union U (Union U A B) C = Union U A (Union U B C).
   
   Theorem Non_disjoint_union :
    forall (X : Ensemble U) (x : U),
    In U X x -> Union U (Singleton U x) X = X.
   
   Theorem Finite_plus_one_is_finite :
    forall (X : Ensemble U) (x : U),
    Finite U X -> Finite U (Union U (Singleton U x) X).
   Hint Resolve Finite_plus_one_is_finite.
  
   Theorem Singleton_is_finite : forall x : U, Finite U (Singleton U x).
   Hint Resolve Singleton_is_finite.
   
   Theorem Union_of_finite_is_finite :
    forall X Y : Ensemble U,
    Finite U X -> Finite U Y -> Finite U (Union U X Y).
   
End The_power_set_partial_order.
Hint Resolve Empty_set_minimal.
Hint Resolve Power_set_non_empty.
Hint Resolve Inclusion_is_an_order.
Hint Resolve Inclusion_is_transitive.
Hint Resolve Same_set_reflexive.
Hint Resolve Union_minimal.
Hint Resolve Same_set_reflexive.
Hint Resolve Union_increases_l.
Hint Resolve Union_increases_r.
Hint Resolve Intersection_decreases_l.
Hint Resolve Intersection_decreases_r.
Hint Resolve Empty_set_is_Bottom.
Hint Resolve Empty_set_zero.
Hint Resolve Finite_plus_one_is_finite.
Hint Resolve Singleton_is_finite. *)

Require Import Partial_order_facts.
(* Partial_order_facts:
Require Import Ensembles.
Require Import Relations_1.
Require Import podefs.
Require Import podefs_1.
Require Import ps.

Section Lemmas_on_partial_orders.
   Variable U : Type.
   Variable B : Ensemble U.
   Variable D : PO U.
   
   Theorem Rel_of_reflexive : forall x : U, Rel_of U D x x.
   Hint Resolve Rel_of_reflexive.
   
   Theorem Rel_of_antisymmetric : Antisymmetric U (Rel_of U D).
   Hint Resolve Rel_of_antisymmetric.
   
   Theorem Rel_of_transitive : Transitive U (Rel_of U D).
   Hint Resolve Rel_of_transitive.
   
   Theorem Couple_included_in_carrier :
    forall x y : U,
    In U (Carrier_of U D) x ->
    In U (Carrier_of U D) y -> Included U (Couple U x y) (Carrier_of U D).
   Hint Resolve Couple_included_in_carrier.
   
   Theorem Lub_is_in_Carrier :
    forall (bsup : U) (X : Ensemble U),
    Included U X (Carrier_of U D) ->
    Lub U D X bsup -> In U (Carrier_of U D) bsup.
   
   Theorem Singleton_has_lub :
    forall x : U, In U (Carrier_of U D) x -> Lub U D (Singleton U x) x.
   Hint Resolve Singleton_has_lub.
   
   Theorem Empty_set_has_Upper_Bound :
    exists maj : U, Upper_Bound U D (Empty_set U) maj.
   Hint Resolve Empty_set_has_Upper_Bound.
   
   Theorem Empty_set_has_lub :
    Cpo U D -> exists bsup : U, Lub U D (Empty_set U) bsup.
   Hint Resolve Empty_set_has_lub.
 
   Theorem Upper_downward_stable :
    forall (A B : Ensemble U) (maj : U),
    Included U A (Carrier_of U D) ->
    Included U B (Carrier_of U D) ->
    Included U A B -> Upper_Bound U D B maj -> Upper_Bound U D A maj.
   
   Theorem Conditionally_complete_has_a_bottom :
    Conditionally_complete U D -> exists bot : U, Bottom U D bot.
   Hint Resolve Conditionally_complete_has_a_bottom.

   Theorem Compatible_is_reflexive : Reflexive U (Compatible U D).
   
   Theorem Couple_is_symmetric :
    forall x y : U, Couple U x y = Couple U y x :>Ensemble U.
   
   Theorem Compatible_is_symmetric : Symmetric U (Compatible U D).
   
End Lemmas_on_partial_orders.
Hint Resolve Couple_included_in_carrier.
Hint Resolve Singleton_has_lub.
Hint Resolve Empty_set_has_Upper_Bound.
Hint Resolve Empty_set_has_lub.
Hint Resolve Conditionally_complete_has_a_bottom. *)



Section First_inductive_lemmas.

   Variable U : Type.

   Variable B : Ensemble U.

   Variable D : PO U.

   

   Theorem Pairs_are_enough_finite_case :

    Cpo U D ->

    (forall x y : U,

     Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->

    forall X : Ensemble U,

    Finite U X ->

    Included U X (Carrier_of U D) ->

    (exists maj : U, Upper_Bound U D X maj) ->

    exists bsup : U, Lub U D X bsup.

   intros H' H'0 X H'1; elim H'1; auto.

   intros A H'2 H'3 x H'4 H'5 h; elim h; intros maj E; clear h.

   generalize (Upper_downward_stable U D A (Union U (Singleton U x) A) maj);

    intro h; lapply h;

    [ intro H'6; lapply H'6;

       [ intro H'7; lapply H'7;

          [ intro H'8; lapply H'8;

             [ intro H'9; clear h H'6 H'7 H'8

             | clear h H'6 H'7; try assumption ]

          | clear h H'6 ]

       | clear h ]

    | clear h ]; auto 10.

   lapply H'3;

    [ intro H'6; lapply H'6;

       [ intro H'7; clear H'3 H'6 | exists maj; clear H'3; try assumption ]

    | idtac ]; auto 10.

   elim H'7; intros bsup E0; clear H'7; try exact E0; auto 10.

   generalize (H'0 x bsup); intro h; lapply h;

    [ intro h0; elim h0; intros bsup0 E1; clear h h0; try exact E1

    | clear h ]; clear H'0.

   exists bsup0; apply Lub_definition; auto 10.

   elim E1; intros H'3 H'6.

   elim H'3; intros H'7 H'8.

   apply Upper_Bound_definition; auto 10.

   intros y H'10; elim H'10.

   intros x0 H'11; elim H'11; auto 10.

   intros x0 H'11; auto 10.

   generalize Rel_of_transitive; intro RoT; red in RoT.

   apply RoT with bsup; auto.

   elim E0.

   intro H'12; elim H'12; auto.

   elim E1.

   intros H'3 H'6 y H'7.

   apply H'6.

   elim H'7; intros H'8 H'10.

   apply Upper_Bound_definition; auto.

   intros y0 H'11; elim H'11; auto 10.

   elim H'7.

   elim E0; auto 10.

   red in |- *.

   elim H'9.

   intros H'0 H'3; exists maj; intros H'6 H'7; split;

    [ idtac | apply Upper_Bound_definition ]; auto 10.

   intros y H'10; elim H'10; auto 10.

   elim E; auto 10.

   elim E0; auto 10.

   Qed.

  

   Theorem Pairs_are_enough :

    Cpo U D ->

    (forall x y : U,

     Compatible U D x y -> exists bsup : U, Lub U D (Couple U x y) bsup) ->

    Conditionally_complete U D.

   intros H' H'0; apply Definition_of_Conditionally_complete.

   intros X H'1 H'2.

   generalize (Empty_set_has_lub U D); intro h; lapply h;

    [ intro H'3; clear h | clear h; try assumption ].

   elim H'3; intros bsup E; clear H'3.

   generalize (Inclusion_is_transitive U); intro T; red in T.

   lapply Pairs_are_enough_finite_case;

    [ intro H'3; lapply H'3; [ intro H'4; clear H'3 | try assumption ]

    | idtac ]; auto.

   elim H'; intros H'6 H'7; clear H'.

   generalize

    (H'7

       (fun bsup : U =>

        exists Y : Ensemble U, Included U Y X /\ Finite U Y /\ Lub U D Y bsup));

    intro h; lapply h; [ intro H'; clear h | clear h; try assumption ].

   2: apply Definition_of_Directed; auto 10.

   2: red in |- *; auto 10.

   2: intros x H'; elim H'; auto 10.

   2: intros x0 h; elim h; intros H'3 h0; elim h0; intros H'5 H'8; clear h h0;

       elim H'8; auto 10.

   2: intro H'9; elim H'9; auto 10.

   2: apply Non_empty_intro with bsup.

   2: red in |- *; auto 10.

   2: exists (Empty_set U); split;

       [ idtac | split; [ try assumption | idtac ] ]; 

       auto 10.

   2: intros x1 x2 H'; red in H'; auto 10.

   2: unfold In at 1 in |- *.

   2: unfold In at 2 in H'.

   2: generalize (H' x1); intro h; lapply h;

       [ intro H'3; clear h | clear h; try assumption ]; 

       auto 10.

   2: elim H'3; intros Y h; elim h; intros H'5 h0; elim h0; intros H'8 H'9;

       clear H'3 h h0; try exact H'8.

   2: generalize (H' x2); intro h; lapply h;

       [ intro H'3; clear h | clear h; try assumption ]; 

       auto 10.

   2: elim H'3; intros Y0 h; elim h; intros H'10 h0; elim h0;

       intros H'11 H'12; clear H'3 h h0; try exact H'11.

   2: generalize (Union_of_finite_is_finite U Y Y0); intro h; lapply h;

       [ intro H'3; lapply H'3;

          [ intro H'13; clear h H'3 | clear h; try assumption ]

       | clear h ]; auto 10.

   2: elim H'2; intros maj E0; clear H'2; try exact E0.

   2: generalize (H'4 (Union U Y Y0)); intro h; lapply h;

       [ intro H'2; lapply H'2;

          [ intro H'3; lapply H'3;

             [ intro H'14; clear h H'2 H'3

             | exists maj; clear h H'2; try assumption ]

          | clear h ]

       | clear h ]; auto.

   3: apply Upper_downward_stable with X; auto.

   2: elim H'14; intros bsup0 E1; clear H'14; try exact E1.

   2: exists bsup0; split;

       [ exists (Union U Y Y0); split;

          [ idtac | split; [ try assumption | idtac ] ]

       | idtac ]; auto 10.

   2: elim E1; intros H'2 H'3; clear E1.

   2: generalize (Upper_downward_stable U D Y (Union U Y Y0) bsup0); intro h;

       lapply h;

       [ intro H'14; lapply H'14;

          [ intro H'15; lapply H'15;

             [ intro H'16; lapply H'16;

                [ intro H'17; clear h H'14 H'15 H'16

                | clear h H'14 H'15; try assumption ]

             | clear h H'14 ]

          | clear h ]

       | clear h ]; auto.

   2: generalize (Upper_downward_stable U D Y0 (Union U Y Y0) bsup0); intro h;

       lapply h;

       [ intro H'14; lapply H'14;

          [ intro H'15; lapply H'15;

             [ intro H'16; lapply H'16;

                [ intro H'18; clear h H'14 H'15 H'16

                | clear h H'14 H'15; try assumption ]

             | clear h H'14 ]

          | clear h ]

       | clear h ]; auto.

   2: elim H'12; intros H'14 H'15; clear H'12.

   2: generalize (H'15 bsup0); intro h; lapply h;

       [ intro H'16; clear h | clear h; try assumption ]; 

       auto 10.

   2: elim H'9; intros H'12 H'19; clear H'9.

   2: generalize (H'19 bsup0); intro h; lapply h;

       [ intro H'9; clear h | clear h; try assumption ]; 

       auto 10.

   2: apply Upper_Bound_definition; auto 10.

   2: elim H'2; auto 10.

   2: intros y H'20; elim H'20; auto 10.

   elim H'; intros bsup0 E0; clear H'; try exact E0; auto 10.

   exists bsup0; apply Lub_definition.

   apply Upper_Bound_definition; auto 10.

   generalize

    (Lub_is_in_Carrier U D bsup0

       (fun bsup : U =>

        exists Y : Ensemble U, Included U Y X /\ Finite U Y /\ Lub U D Y bsup));

    intro h; lapply h;

    [ intro H'; lapply H';

       [ intro H'3; clear h H' | clear h; try assumption ]

    | clear h ]; auto 10.

   red in |- *.

   intros x H'; red in H'; auto 10.

   elim H'; intros Y h; elim h; intros H'3 h0; elim h0; intros H'5 H'8;

    clear H' h h0; try exact H'8; auto 10.

   apply Lub_is_in_Carrier with Y; auto.

   elim E0; intros H'3 H'5; clear E0.

   elim H'3; intros H'8 H'9; clear H'3.

   intros y H'; apply H'9; auto 10.

   red in |- *;

    (exists (Singleton U y); split;

      [ idtac | split; [ try assumption | idtac ] ]); 

    auto 10.

   red in |- *; (intros x H'3; elim H'3); auto 10.

   intros y H'; try assumption.

   elim E0; intros H'3 H'5; clear E0; apply H'5.

   apply Upper_Bound_definition; auto 10.

   elim H'; auto 10.

   intros y0 H'8; red in H'8; auto 10.

   elim H'8; intros Y h; elim h; intros H'9 h0; elim h0; intros H'10 H'11;

    clear H'8 h h0; try exact H'11; auto 10.

   elim H'11; intros H'8 H'12; clear H'11.

   apply H'12; auto 10.

   apply Upper_downward_stable with X; auto.

   Qed.

   

End First_inductive_lemmas.
