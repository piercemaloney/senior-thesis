

Require Import Ensembles.
(* Ensembles:
Require Import Classical.

Section Ensembles.
   Variable U : Type.
   
   Definition Ensemble := U -> Prop.
   
   Definition In (B : Ensemble) (x : U) : Prop := B x.
   
   Definition Included (B C : Ensemble) : Prop :=
     forall x : U, In B x -> In C x.
   
   Inductive Empty_set : Ensemble :=.
   
   Inductive Singleton (x : U) : Ensemble :=
       In_singleton : In (Singleton x) x.
   
   Inductive Union (B C : Ensemble) : Ensemble :=
     | Union_introl : forall x : U, In B x -> In (Union B C) x
     | Union_intror : forall x : U, In C x -> In (Union B C) x.
   
   Inductive Intersection (B C : Ensemble) : Ensemble :=
       Intersection_intro :
         forall x : U, In B x -> In C x -> In (Intersection B C) x.
   
   Inductive Couple (x y : U) : Ensemble :=
     | Couple_l : In (Couple x y) x
     | Couple_r : In (Couple x y) y.
   
   Inductive Setminus (B C : Ensemble) : Ensemble :=
       Setminus_intro :
         forall x : U, In B x -> ~ In C x -> In (Setminus B C) x.
   
   Inductive Disjoint (B C : Ensemble) : Prop :=
       Disjoint_intro :
         (forall x : U, ~ In (Intersection B C) x) -> Disjoint B C.
   
   Inductive Non_empty (B : Ensemble) : Prop :=
       Non_empty_intro : forall x : U, In B x -> Non_empty B.
   
   Inductive Finite : Ensemble -> Prop :=
     | Empty_is_finite : Finite Empty_set
     | Union_is_finite :
         forall A : Ensemble,
         Finite A -> forall x : U, ~ In A x -> Finite (Union (Singleton x) A).

   Definition Same_set (B C : Ensemble) : Prop :=
     Included B C /\ Included C B.
      
   Lemma Same_set_intro :
    forall B C : Ensemble, Included B C -> Included C B -> Same_set B C.

   Axiom
     Extensionality_Ensembles :
       forall A B : Ensemble, Same_set A B -> A = B :>Ensemble.
   
End Ensembles.
Hint Unfold In.
Hint Unfold Included.
Hint Resolve Same_set_intro.
Hint Resolve Union_introl Union_intror.
Hint Resolve Intersection_intro.
Hint Resolve In_singleton.
Hint Resolve Couple_l Couple_r.
Hint Resolve Setminus_intro.
Hint Resolve Disjoint_intro.
Hint Resolve Empty_is_finite Union_is_finite.
Hint Resolve Extensionality_Ensembles. *)

Require Import Relations_1.
(* Relations_1:
Section Relations_1.
   Variable U : Type.
   
   Definition Relation := U -> U -> Prop.
   Variable R : Relation.
   
   Definition Reflexive : Prop := forall x : U, R x x.
   
   Definition Transitive : Prop := forall x y z : U, R x y -> R y z -> R x z.
   
   Definition Symmetric : Prop := forall x y : U, R x y -> R y x.
   
   Definition Antisymmetric : Prop :=
     forall x y : U, R x y -> R y x -> x = y :>U.
   
   Definition contains (R R' : Relation) : Prop :=
     forall x y : U, R' x y -> R x y.
   
   Definition same_relation (R R' : Relation) : Prop :=
     contains R R' /\ contains R' R.
   
   Inductive Preorder : Prop :=
       Definition_of_preorder : Reflexive -> Transitive -> Preorder.
   
   Inductive Order : Prop :=
       Definition_of_order :
         Reflexive -> Transitive -> Antisymmetric -> Order.
   
   Inductive Equivalence : Prop :=
       Definition_of_equivalence :
         Reflexive -> Transitive -> Symmetric -> Equivalence.
   
   Inductive PER : Prop :=
       Definition_of_PER : Symmetric -> Transitive -> PER.
   
End Relations_1.
Hint Unfold Reflexive.
Hint Unfold Transitive.
Hint Unfold Antisymmetric.
Hint Unfold Symmetric.
Hint Unfold contains.
Hint Unfold same_relation.
Hint Resolve Definition_of_preorder.
Hint Resolve Definition_of_order.
Hint Resolve Definition_of_equivalence.
Hint Resolve Definition_of_PER. *)



Section Partial_orders.

   Variable U : Type.

   

   Definition Carrier := Ensemble U.

   

   Definition Rel := Relation U.

   

   Inductive PO : Type :=

       Definition_of_PO :

         forall (C : Carrier) (R : Rel), Non_empty U C -> Order U R -> PO.

   

   Theorem Carrier_of : PO -> Carrier.

   intro H'; elim H'.

   intros C R H'0 H'1; exact C.

   Defined.



   Theorem Rel_of : PO -> Rel.

   intro H'; elim H'.

   intros C R H'0 H'1; exact R.

   Defined.



   Definition SRel_of (p : PO) : Rel := fun x y : U => Rel_of p x y /\ x <> y.

   

End Partial_orders.

Hint Unfold Carrier_of Rel_of.
