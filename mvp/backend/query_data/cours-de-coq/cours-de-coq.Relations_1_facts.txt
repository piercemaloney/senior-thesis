

Require Import Relations_1.
(* Relations_1:
Section Relations_1.
   Variable U : Type.
   
   Definition Relation := U -> U -> Prop.
   Variable R : Relation.
   
   Definition Reflexive : Prop := forall x : U, R x x.
   
   Definition Transitive : Prop := forall x y z : U, R x y -> R y z -> R x z.
   
   Definition Symmetric : Prop := forall x y : U, R x y -> R y x.
   
   Definition Antisymmetric : Prop :=
     forall x y : U, R x y -> R y x -> x = y :>U.
   
   Definition contains (R R' : Relation) : Prop :=
     forall x y : U, R' x y -> R x y.
   
   Definition same_relation (R R' : Relation) : Prop :=
     contains R R' /\ contains R' R.
   
   Inductive Preorder : Prop :=
       Definition_of_preorder : Reflexive -> Transitive -> Preorder.
   
   Inductive Order : Prop :=
       Definition_of_order :
         Reflexive -> Transitive -> Antisymmetric -> Order.
   
   Inductive Equivalence : Prop :=
       Definition_of_equivalence :
         Reflexive -> Transitive -> Symmetric -> Equivalence.
   
   Inductive PER : Prop :=
       Definition_of_PER : Symmetric -> Transitive -> PER.
   
End Relations_1.
Hint Unfold Reflexive.
Hint Unfold Transitive.
Hint Unfold Antisymmetric.
Hint Unfold Symmetric.
Hint Unfold contains.
Hint Unfold same_relation.
Hint Resolve Definition_of_preorder.
Hint Resolve Definition_of_order.
Hint Resolve Definition_of_equivalence.
Hint Resolve Definition_of_PER. *)



Definition Complement (U : Type) (R : Relation U) : 

  Relation U := fun x y : U => ~ R x y.



Theorem Rsym_imp_notRsym :

 forall (U : Type) (R : Relation U),

 Symmetric U R -> Symmetric U (Complement U R).

unfold Symmetric, Complement in |- *.

intros U R H' x y H'0; red in |- *; intro H'1; apply H'0; auto.

Qed.



Theorem Equiv_from_preorder :

 forall (U : Type) (R : Relation U),

 Preorder U R -> Equivalence U (fun x y : U => R x y /\ R y x).

intros U R H'; elim H'; intros H'0 H'1.

apply Definition_of_equivalence.

red in H'0; auto 10.

2: red in |- *; intros x y h; elim h; intros H'3 H'4; auto 10.

red in H'1; red in |- *; auto 10.

intros x y z h; elim h; intros H'3 H'4; clear h.

intro h; elim h; intros H'5 H'6; clear h.

split; apply H'1 with y; auto 10.

Qed.

Hint Resolve Equiv_from_preorder.



Theorem Equiv_from_order :

 forall (U : Type) (R : Relation U),

 Order U R -> Equivalence U (fun x y : U => R x y /\ R y x).

intros U R H'; elim H'; auto 10.

Qed.

Hint Resolve Equiv_from_order.



Theorem contains_is_preorder :

 forall U : Type, Preorder (Relation U) (contains U).

auto 10.

Qed.

Hint Resolve contains_is_preorder.



Theorem same_relation_is_equivalence :

 forall U : Type, Equivalence (Relation U) (same_relation U).

unfold same_relation at 1 in |- *; auto 10.

Qed.

Hint Resolve same_relation_is_equivalence.
