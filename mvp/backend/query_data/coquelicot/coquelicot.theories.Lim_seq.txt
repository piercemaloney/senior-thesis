

Require Import Reals Psatz.

Require Import mathcomp.ssreflect.ssreflect.

Require Import Rcomplements.
(* Rcomplements:
Ltac evar_last :=
  match goal with
  | |- ?f ?x =>
    let tx := type of x in
    let tx := eval simpl in tx in
    let tmp := fresh "tmp" in
    evar (tmp : tx) ;
    refine (@eq_ind tx tmp f _ x _) ;
    unfold tmp ; clear tmp
  end.

Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Psatz.

Module MyNat.

Lemma neq_succ_0 (n : nat) : S n <> 0.

Lemma sub_succ (n m : nat) : S n - S m = n - m.

Lemma sub_succ_l (n m : nat) : n <= m -> S m - n = S (m - n).

Lemma lt_neq (n m : nat) : n < m -> n <> m.

Lemma minus_0_le (n m : nat) : n <= m -> n - m = 0.

Lemma sub_succ_r (n m : nat) : n - S m = pred (n - m).

Lemma sub_add (n m : nat) : n <= m -> m - n + n = m.

Lemma le_pred_le_succ (n m : nat) : pred n <= m <-> n <= S m.

End MyNat.

Require Import Even Div2.
Require Import mathcomp.ssreflect.seq mathcomp.ssreflect.ssrbool.

Open Scope R_scope.

Lemma floor_ex : forall x : R, {n : Z | IZR n <= x < IZR n + 1}.
Definition floor x := proj1_sig (floor_ex x).

Lemma floor1_ex : forall x : R, {n : Z | IZR n < x <= IZR n + 1}.
Definition floor1 x := proj1_sig (floor1_ex x).

Lemma nfloor_ex : forall x : R, 0 <= x -> {n : nat | INR n <= x < INR n + 1}.
Definition nfloor x pr := proj1_sig (nfloor_ex x pr).

Lemma nfloor1_ex : forall x : R, 0 < x -> {n : nat | INR n < x <= INR n + 1}.
Definition nfloor1 x pr := proj1_sig (nfloor1_ex x pr).

Lemma INRp1_pos : forall n, 0 < INR n + 1.

Lemma Rlt_nat (x : R) : (exists n : nat, x = INR (S n)) -> 0 < x.

Lemma Rle_pow_lin (a : R) (n : nat) :
  0 <= a -> 1 + INR n * a <= (1 + a) ^ n.

Lemma C_n_n: forall n, C n n = 1.

Lemma C_n_0: forall n, C n 0 = 1.

Fixpoint pow2 (n : nat) : nat :=
  match n with
    | O => 1%nat
    | S n => (2 * pow2 n)%nat
  end.

Lemma pow2_INR (n : nat) : INR (pow2 n) = 2^n.

Lemma pow2_pos (n : nat) : (0 < pow2 n)%nat.

Lemma Rinv_le_contravar :
  forall x y, 0 < x -> x <= y -> / y <= / x.

Lemma Rinv_lt_cancel (x y : R) :
  0 < y -> / y < / x -> x < y.

Lemma Rdiv_1 : forall x : R, x / 1 = x.

Lemma Rdiv_plus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b + c / d = (a * d + c * b) / (b * d).

Lemma Rdiv_minus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b - c / d = (a * d - c * b) / (b * d).

Lemma Rplus_lt_reg_l (x y z : R) : x + y < x + z -> y < z.

Lemma Rplus_lt_reg_r (x y z : R) : y + x < z + x -> y < z.

Lemma Rle_div_l : forall a b c, c > 0 -> (a / c <= b <-> a <= b * c).

Lemma Rle_div_r : forall a b c, c > 0 -> (a * c <= b <-> a <= b / c).

Lemma Rlt_div_l : forall a b c, c > 0 -> (a / c < b <-> a < b*c).

Lemma Rlt_div_r : forall a b c, c > 0 -> (a * c < b <-> a < b / c).

Lemma Rdiv_lt_0_compat : forall r1 r2 : R, 0 < r1 -> 0 < r2 -> 0 < r1 / r2.

Lemma Rdiv_le_0_compat : forall r1 r2 : R, 0 <= r1 -> 0 < r2 -> 0 <= r1 / r2.

Lemma Rdiv_lt_1 : forall r1 r2, 0 < r2 -> (r1 < r2 <-> r1 / r2 < 1).

Lemma Rdiv_le_1 : forall r1 r2, 0 < r2 -> (r1 <= r2 <-> r1/r2 <= 1).

Lemma Rle_mult_Rlt : forall c a b : R, 0 < b -> c < 1 -> a <= b*c -> a < b.

Lemma Rmult_le_0_r : forall a b, a <= 0 -> 0 <= b -> a * b <= 0.

Lemma Rmult_le_0_l : forall a b, 0 <= a -> b <= 0 -> a * b <= 0.

Lemma pow2_gt_0 (x : R) : x <> 0 -> 0 < x ^ 2.

Lemma Rminus_eq_0 : forall r : R, r - r = 0.

Lemma Rdiv_minus_distr : forall a b c, b <> 0 -> a / b - c = (a - b * c) / b.

Lemma Rmult_minus_distr_r: forall r1 r2 r3 : R, (r1 - r2) * r3 = r1 * r3 - r2 * r3.

Lemma Rminus_eq_compat_l : forall r r1 r2 : R, r1 = r2 <-> r - r1 = r - r2.

Lemma Ropp_plus_minus_distr : forall r1 r2 : R, - (r1 + r2) = - r1 - r2.

Lemma Rle_minus_l : forall a b c,(a - c <= b <-> a <= b + c).

Lemma Rlt_minus_r : forall a b c,(a < b - c <-> a + c < b).

Lemma Rlt_minus_l : forall a b c,(a - c < b <-> a < b + c).

Lemma Rle_minus_r : forall a b c,(a <= b - c <-> a + c <= b).

Lemma Rminus_le_0 : forall a b, a <= b <-> 0 <= b - a.

Lemma Rminus_lt_0 : forall a b, a < b <-> 0 < b - a.

Lemma sum_f_rw (a : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m a = sum_f_R0 a m - sum_f_R0 a n.

Lemma sum_f_rw_0 (u : nat -> R) (n : nat) :
  sum_f O n u = sum_f_R0 u n.

Lemma sum_f_n_Sm (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f n (S m) u = sum_f n m u + u (S m).
Lemma sum_f_u_Sk (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f (S n) (S m) u = sum_f n m (fun k => u (S k)).
Lemma sum_f_u_add (u : nat -> R) (p n m : nat) :
  (n <= m)%nat -> sum_f (n + p)%nat (m + p)%nat u = sum_f n m (fun k => u (k + p)%nat).

Lemma sum_f_Sn_m (u : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m u = sum_f n m u - u n.

Lemma sum_f_R0_skip (u : nat -> R) (n : nat) :
  sum_f_R0 (fun k => u (n - k)%nat) n = sum_f_R0 u n.

Lemma sum_f_chasles (u : nat -> R) (n m k : nat) :
  (n < m)%nat -> (m < k)%nat ->
  sum_f (S n) k u = sum_f (S n) m u + sum_f (S m) k u.

Lemma Rplus_max_distr_l :
  forall a b c, a + Rmax b c = Rmax (a + b) (a + c).

Lemma Rplus_max_distr_r :
  forall a b c, Rmax b c + a = Rmax (b + a) (c + a).

Lemma Rplus_min_distr_l :
  forall a b c, a + Rmin b c = Rmin (a + b) (a + c).

Lemma Rplus_min_distr_r :
  forall a b c, Rmin b c + a = Rmin (b + a) (c + a).

Lemma Rmult_max_distr_l :
  forall a b c, 0 <= a -> a * Rmax b c = Rmax (a * b) (a * c).

Lemma Rmult_max_distr_r :
  forall a b c, 0 <= a -> Rmax b c * a = Rmax (b * a) (c * a).

Lemma Rmult_min_distr_l :
  forall a b c, 0 <= a -> a * Rmin b c = Rmin (a * b) (a * c).

Lemma Rmult_min_distr_r :
  forall a b c, 0 <= a -> Rmin b c * a = Rmin (b * a) (c * a).

Lemma Rmin_assoc : forall x y z, Rmin x (Rmin y z) =
  Rmin (Rmin x y) z.

Lemma Rmax_assoc : forall x y z, Rmax x (Rmax y z) =
  Rmax (Rmax x y) z.

Lemma Rmax_le_compat : forall a b c d, a <= b -> c <= d -> Rmax a c <= Rmax b d.

Lemma Rmax_opp_Rmin : forall a b, Rmax (-a) (-b) = - Rmin a b.
Lemma Rmin_opp_Rmax : forall a b, Rmin (-a) (-b) = - Rmax a b.

Lemma Rmax_mult : forall a b c, 0 <= c -> Rmax a b * c = Rmax (a * c) (b * c).

Lemma Rmax_le_Rplus : forall a b : R, 0 <= a -> 0 <= b -> Rmax a b <= a + b.

Lemma Rplus_le_Rmax : forall a b : R, a + b <= 2*Rmax a b.

Lemma Rmin_Rmax_l : forall a b, Rmin a b <= a <= Rmax a b.

Lemma Rmin_Rmax_r : forall a b, Rmin a b <= b <= Rmax a b.

Lemma Rmin_Rmax : forall a b, Rmin a b <= Rmax a b.

Lemma Rabs_div : forall a b : R, b <> 0 -> Rabs (a/b) = (Rabs a) / (Rabs b).

Lemma Rabs_eq_0 : forall x, Rabs x = 0 -> x = 0.

Lemma Rabs_le_between : forall x y, (Rabs x <= y <-> -y <= x <= y).

Lemma Rabs_le_between' : forall x y z, Rabs (x - y) <= z <-> y-z <= x <= y+z.

Lemma Rabs_lt_between : forall x y, (Rabs x < y <-> -y < x < y).

Lemma Rabs_lt_between' : forall x y z, Rabs (x - y) < z <-> y-z < x < y+z.

Lemma Rabs_le_between_min_max : forall x y z, Rmin x y <= z <= Rmax x y -> Rabs (z - y) <= Rabs (x - y).

Lemma Rabs_le_between_Rmax : forall x m M,
  m <= x <= M -> Rabs x <= Rmax M (-m).

Lemma Rabs_lt_between_Rmax : forall x m M,
  m < x < M -> Rabs x < Rmax M (-m).

Lemma Rabs_maj2 : forall x, -x <= Rabs x.

Lemma Req_lt_aux : forall x y, (forall eps : posreal, Rabs (x - y) < eps) -> x = y.

Lemma Req_le_aux : forall x y, (forall eps : posreal, Rabs (x - y) <= eps) -> x = y.

Lemma is_pos_div_2 (eps : posreal) : 0 < eps / 2.
Definition pos_div_2 (eps : posreal) := mkposreal _ (is_pos_div_2 eps).

Definition sign (x : R) :=
  match total_order_T 0 x with
  | inleft (left _) => 1
  | inleft (right _) => 0
  | inright _ => -1
  end.

Lemma sign_0 : sign 0 = 0.

Lemma sign_opp (x : R) : sign (-x) = - sign x.

Lemma sign_eq_1 (x : R) : 0 < x -> sign x = 1.

Lemma sign_eq_m1 (x : R) : x < 0 -> sign x = -1.

Lemma sign_le (x y : R) : x <= y -> sign x <= sign y.

Lemma sign_ge_0 (x : R) : 0 <= x -> 0 <= sign x.

Lemma sign_le_0 (x : R) : x <= 0 -> sign x <= 0.

Lemma sign_neq_0 (x : R) : x <> 0 -> sign x <> 0.

Lemma sign_mult (x y : R) : sign (x * y) = sign x * sign y.

Lemma sign_min_max (a b : R) :
  sign (b - a) * (Rmax a b - Rmin a b) = b - a.

Lemma sum_INR : forall n, sum_f_R0 INR n = INR n * (INR n + 1) / 2.

Lemma interval_finite_subdiv (a b : R) (eps : posreal) : (a <= b) ->
  {l : seq R | head 0 l = a /\ last 0 l = b /\
    forall i, (S i < size l)%nat -> nth 0 l i < nth 0 l (S i) <= nth 0 l i + eps}.

Lemma interval_finite_subdiv_between (a b : R) (eps : posreal) (Hab : a <= b) :
  let l := proj1_sig (interval_finite_subdiv a b eps Hab) in
  forall i, (i < size l)%nat -> a <= nth 0 l i <= b.

Lemma SSR_leq (n m : nat) : is_true (ssrnat.leq n m) <-> (n <= m)%nat.
Lemma SSR_minus (n m : nat) : ssrnat.subn n m = (n - m)%nat.

Lemma rcons_ind {T : Type} (P : seq T -> Type) :
  P [::] -> (forall (s : seq T) (t : T), P s -> P (rcons s t)) -> forall s, P s.
Lemma rcons_dec {T : Type} (P : seq T -> Type) :
  (P [::]) -> (forall s t, P (rcons s t)) -> forall s, P s.
Lemma size_rcons_pos {T : Type} (s : seq T) (t : T) : (0 < size (rcons s t))%nat.

Lemma foldr_rcons {T T0 : Type} : forall (f : T0 -> T -> T) x0 s t,
  foldr f x0 (rcons s t) = foldr f (f t x0) s.
Lemma foldl_rcons {T T0 : Type} : forall (f : T -> T0 -> T) x0 s t,
  foldl f x0 (rcons s t) = f (foldl f x0 s) t.

Lemma head_rcons {T : Type} (x0 : T) (s : seq T) (t : T) : head x0 (rcons s t) = head t s.
Lemma behead_rcons {T : Type} (s : seq T) (t : T) :
  (0 < size s)%nat ->  behead (rcons s t) = rcons (behead s) t.
Definition belast {T : Type} (s : seq T) :=
  match s with
    | [::] => [::]
    | h :: s => belast h s
  end.
Lemma behead_rev {T : Type} (s : seq T) : behead (rev s) = rev (belast s).

Lemma pairmap_rcons {T T0 : Type} (f : T -> T -> T0) (s : seq T) h0 h x0 :
  pairmap f x0 (rcons (rcons s h0) h) = rcons (pairmap f x0 (rcons s h0)) (f h0 h).
Lemma map_pairmap {T T0 T1 : Type} (f : T0 -> T1) (g : T -> T -> T0) (s : seq T) (x0 : T) :
  map f (pairmap g x0 s) = pairmap (fun x y => f (g x y)) x0 s.
Lemma pairmap_map {T T0 T1 : Type} (f : T0 -> T0 -> T1) (g : T -> T0) (s : seq T) (x0 : T) :
  pairmap f (g x0) (map g s) = pairmap (fun x y => f (g x) (g y)) x0 s.

Lemma size_unzip1 {T T0 : Type} (s : seq (T * T0)) : size (unzip1 s) = size s.
Lemma size_unzip2 {T T0 : Type} (s : seq (T * T0)) : size (unzip2 s) = size s.
Lemma zip_cons {S T : Type} hs ht (s : seq S) (t : seq T) :
  zip (hs :: s) (ht :: t) = (hs,ht) :: zip s t.
Lemma zip_rcons {S T : Type} (s : seq S) (t : seq T) hs ht : size s = size t ->
  zip (rcons s hs) (rcons t ht) = rcons (zip s t) (hs,ht).
Lemma unzip1_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip1 (rcons s h) = rcons (unzip1 s) (fst h).
Lemma unzip2_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip2 (rcons s h) = rcons (unzip2 s) (snd h).
Lemma unzip1_belast {S T : Type} (s : seq (S*T)) :
  unzip1 (belast s) = belast (unzip1 s).
Lemma unzip2_belast {S T : Type} (s : seq (S*T)) :
  unzip2 (belast s) = belast (unzip2 s).
Lemma unzip1_behead {S T : Type} (s : seq (S*T)) :
  unzip1 (behead s) = behead (unzip1 s).
Lemma unzip2_behead {S T : Type} (s : seq (S*T)) :
  unzip2 (behead s) = behead (unzip2 s).
Lemma unzip1_fst {S T : Type} (s : seq (S*T)) :
  unzip1 s = map (@fst S T) s.
Lemma unzip2_snd {S T : Type} (s : seq (S*T)) :
  unzip2 s = map (@snd S T) s.
Lemma size_belast' {T : Type} (s : seq T) :
  size (belast s) = Peano.pred (size s).
Lemma head_map {T1 T2 : Type} (f : T1 -> T2) (s : seq T1) (x : T1) :
  head (f x) (map f s) = f (head x s).

Lemma StepFun_bound {a b : R} (f : StepFun a b) :
  exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_bound (f : R -> R) (a b : R) :
  Riemann_integrable f a b -> exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_ext : forall (f g : R -> R) (a b : R),
  (forall x, Rmin a b <= x <= Rmax a b -> f x = g x)
    -> Riemann_integrable f a b -> Riemann_integrable g a b.

Lemma RiemannInt_ext : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (Heq : forall x, Rmin a b <= x <= Rmax a b -> f x = g x),
    RiemannInt pr_f = RiemannInt pr_g.

Lemma Riemann_integrable_const : forall (c a b : R),
  Riemann_integrable (fun x => c) a b.

Lemma RiemannInt_const : forall (c a b : R) (pr : Riemann_integrable (fun x => c) a b),
  RiemannInt pr = c * (b-a).

Lemma Riemann_integrable_plus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x + g x) a b.

Lemma RiemannInt_plus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x + g x) a b),
  RiemannInt pr = RiemannInt pr_f + RiemannInt pr_g.

Lemma Riemann_integrable_minus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x - g x) a b.

Lemma RiemannInt_minus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x - g x) a b),
  RiemannInt pr = RiemannInt pr_f - RiemannInt pr_g.

Lemma Riemann_integrable_opp : forall (f : R -> R) (a b : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => - f x) a b.

Lemma RiemannInt_opp : forall (f : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => - f x) a b),
  RiemannInt pr = - RiemannInt pr_f.

Lemma Riemann_integrable_scal : forall (f : R -> R) (a b c : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => c * f x) a b.

Lemma RiemannInt_scal : forall (f : R -> R) (a b c : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => c * f x) a b),
  RiemannInt pr = c * RiemannInt pr_f.

Lemma ln_pow x n : 0 < x -> ln (x^n) = INR n * ln x.

Lemma ln_le x y : 0 < x -> x <= y -> ln x <= ln y.

Lemma ln_div x y : 0 < x -> 0 < y -> ln (x / y) = ln x - ln y.

Lemma derivable_pt_lim_atan :
  forall x, derivable_pt_lim atan x (/(1 + x^2)). *)

Require Import Rbar Lub Markov Hierarchy.
(* Rbar:
Require Import Reals.
Require Import mathcomp.ssreflect.ssreflect.
Require Import Rcomplements.

Open Scope R_scope.

Inductive Rbar :=
  | Finite : R -> Rbar
  | p_infty : Rbar
  | m_infty : Rbar.
Definition real (x : Rbar) :=
  match x with
    | Finite x => x
    | _ => 0
  end.
Coercion Finite : R >-> Rbar.
Coercion real : Rbar >-> R.

Definition is_finite (x : Rbar) := Finite (real x) = x.
Lemma is_finite_correct (x : Rbar) :
  is_finite x <-> exists y : R, x = Finite y.

Definition Rbar_lt (x y : Rbar) : Prop :=
  match x,y with
    | p_infty, _ | _, m_infty => False
    | m_infty, _ | _, p_infty => True
    | Finite x, Finite y => Rlt x y
  end.

Definition Rbar_le (x y : Rbar) : Prop :=
  match x,y with
    | m_infty, _ | _, p_infty => True
    | p_infty, _ | _, m_infty => False
    | Finite x, Finite y => Rle x y
  end.

Definition Rbar_opp (x : Rbar) :=
  match x with
    | Finite x => Finite (-x)
    | p_infty => m_infty
    | m_infty => p_infty
  end.

Definition Rbar_plus' (x y : Rbar) :=
  match x,y with
    | p_infty, m_infty | m_infty, p_infty => None
    | p_infty, _ | _, p_infty => Some p_infty
    | m_infty, _ | _, m_infty => Some m_infty
    | Finite x', Finite y' => Some (Finite (x' + y'))
  end.
Definition Rbar_plus (x y : Rbar) :=
  match Rbar_plus' x y with Some z => z | None => Finite 0 end.
Arguments Rbar_plus !x !y /.
Definition is_Rbar_plus (x y z : Rbar) : Prop :=
  Rbar_plus' x y = Some z.
Definition ex_Rbar_plus (x y : Rbar) : Prop :=
  match Rbar_plus' x y with Some _ => True | None => False end.
Arguments ex_Rbar_plus !x !y /.

Lemma is_Rbar_plus_unique (x y z : Rbar) :
  is_Rbar_plus x y z -> Rbar_plus x y = z.
Lemma Rbar_plus_correct (x y : Rbar) :
  ex_Rbar_plus x y -> is_Rbar_plus x y (Rbar_plus x y).

Definition Rbar_minus (x y : Rbar) := Rbar_plus x (Rbar_opp y).
Arguments Rbar_minus !x !y /.
Definition is_Rbar_minus (x y z : Rbar) : Prop :=
  is_Rbar_plus x (Rbar_opp y) z.
Definition ex_Rbar_minus (x y : Rbar) : Prop :=
  ex_Rbar_plus x (Rbar_opp y).
Arguments ex_Rbar_minus !x !y /.

Definition Rbar_inv (x : Rbar) : Rbar :=
  match x with
    | Finite x => Finite (/x)
    | _ => Finite 0
  end.

Definition Rbar_mult' (x y : Rbar) :=
  match x with
    | Finite x => match y with
      | Finite y => Some (Finite (x * y))
      | p_infty => match (Rle_dec 0 x) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some p_infty | right _ => None end
        | right _ => Some m_infty
      end
      | m_infty => match (Rle_dec 0 x) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some m_infty | right _ => None end
        | right _ => Some p_infty
      end
    end
    | p_infty => match y with
      | Finite y => match (Rle_dec 0 y) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some p_infty | right _ => None end
        | right _ => Some m_infty
      end
      | p_infty => Some p_infty
      | m_infty => Some m_infty
    end
    | m_infty => match y with
      | Finite y => match (Rle_dec 0 y) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some m_infty | right _ => None end
        | right _ => Some p_infty
      end
      | p_infty => Some m_infty
      | m_infty => Some p_infty
    end
  end.
Definition Rbar_mult (x y : Rbar) :=
  match Rbar_mult' x y with Some z => z | None => Finite 0 end.
Arguments Rbar_mult !x !y /.

Definition is_Rbar_mult (x y z : Rbar) : Prop :=
  Rbar_mult' x y = Some z.
Definition ex_Rbar_mult (x y : Rbar) : Prop :=
  match x with
    | Finite x => match y with
      | Finite y => True
      | p_infty => x <> 0
      | m_infty => x <> 0
    end
    | p_infty => match y with
      | Finite y => y <> 0
      | p_infty => True
      | m_infty => True
    end
    | m_infty => match y with
      | Finite y => y <> 0
      | p_infty => True
      | m_infty => True
    end
  end.
Arguments ex_Rbar_mult !x !y /.

Definition Rbar_mult_pos (x : Rbar) (y : posreal) :=
  match x with
    | Finite x => Finite (x*y)
    | _ => x
  end.

Lemma is_Rbar_mult_unique (x y z : Rbar) :
  is_Rbar_mult x y z -> Rbar_mult x y = z.
Lemma Rbar_mult_correct (x y : Rbar) :
  ex_Rbar_mult x y -> is_Rbar_mult x y (Rbar_mult x y).
Lemma Rbar_mult_correct' (x y z : Rbar) :
  is_Rbar_mult x y z -> ex_Rbar_mult x y.

Definition Rbar_div (x y : Rbar) : Rbar :=
  Rbar_mult x (Rbar_inv y).
Arguments Rbar_div !x !y /.
Definition is_Rbar_div (x y z : Rbar) : Prop :=
  is_Rbar_mult x (Rbar_inv y) z.
Definition ex_Rbar_div (x y : Rbar) : Prop :=
  ex_Rbar_mult x (Rbar_inv y).
Arguments ex_Rbar_div !x !y /.
Definition Rbar_div_pos (x : Rbar) (y : posreal) :=
  match x with
    | Finite x => Finite (x/y)
    | _ => x
  end.

Lemma Rbar_finite_eq (x y : R) :
  Finite x = Finite y <-> x = y.
Lemma Rbar_finite_neq (x y : R) :
  Finite x <> Finite y <-> x <> y.

Lemma Rbar_lt_not_eq (x y : Rbar) :
  Rbar_lt x y -> x<>y.

Lemma Rbar_not_le_lt (x y : Rbar) :
  ~ Rbar_le x y -> Rbar_lt y x.

Lemma Rbar_lt_not_le (x y : Rbar) :
  Rbar_lt y x -> ~ Rbar_le x y.

Lemma Rbar_not_lt_le (x y : Rbar) :
  ~ Rbar_lt x y -> Rbar_le y x.

Lemma Rbar_le_not_lt (x y : Rbar) :
  Rbar_le y x -> ~ Rbar_lt x y.

Lemma Rbar_le_refl :
  forall x : Rbar, Rbar_le x x.

Lemma Rbar_lt_le :
  forall x y : Rbar,
  Rbar_lt x y -> Rbar_le x y.

Lemma Rbar_total_order (x y : Rbar) :
  {Rbar_lt x y} + {x = y} + {Rbar_lt y x}.

Lemma Rbar_eq_dec (x y : Rbar) :
  {x = y} + {x <> y}.

Lemma Rbar_lt_dec (x y : Rbar) :
  {Rbar_lt x y} + {~Rbar_lt x y}.

Lemma Rbar_lt_le_dec (x y : Rbar) :
  {Rbar_lt x y} + {Rbar_le y x}.

Lemma Rbar_le_dec (x y : Rbar) :
  {Rbar_le x y} + {~Rbar_le x y}.

Lemma Rbar_le_lt_dec (x y : Rbar) :
  {Rbar_le x y} + {Rbar_lt y x}.

Lemma Rbar_le_lt_or_eq_dec (x y : Rbar) :
  Rbar_le x y -> { Rbar_lt x y } + { x = y }.

Lemma Rbar_lt_trans (x y z : Rbar) :
  Rbar_lt x y -> Rbar_lt y z -> Rbar_lt x z.

Lemma Rbar_lt_le_trans (x y z : Rbar) :
  Rbar_lt x y -> Rbar_le y z -> Rbar_lt x z.

Lemma Rbar_le_lt_trans (x y z : Rbar) :
  Rbar_le x y -> Rbar_lt y z -> Rbar_lt x z.

Lemma Rbar_le_trans (x y z : Rbar) :
  Rbar_le x y -> Rbar_le y z -> Rbar_le x z.

Lemma Rbar_le_antisym (x y : Rbar) :
  Rbar_le x y -> Rbar_le y x -> x = y.

Lemma Rbar_opp_involutive (x : Rbar) : (Rbar_opp (Rbar_opp x)) = x.

Lemma Rbar_opp_lt (x y : Rbar) : Rbar_lt (Rbar_opp x) (Rbar_opp y) <-> Rbar_lt y x.

Lemma Rbar_opp_le (x y : Rbar) : Rbar_le (Rbar_opp x) (Rbar_opp y) <-> Rbar_le y x.

Lemma Rbar_opp_eq (x y : Rbar) : (Rbar_opp x) = (Rbar_opp y) <-> x = y.

Lemma Rbar_opp_real (x : Rbar) : real (Rbar_opp x) = - real x.

Lemma Rbar_plus'_comm :
  forall x y, Rbar_plus' x y = Rbar_plus' y x.

Lemma ex_Rbar_plus_comm :
  forall x y,
  ex_Rbar_plus x y -> ex_Rbar_plus y x.

Lemma ex_Rbar_plus_opp (x y : Rbar) :
  ex_Rbar_plus x y -> ex_Rbar_plus (Rbar_opp x) (Rbar_opp y).

Lemma Rbar_plus_0_r (x : Rbar) : Rbar_plus x (Finite 0) = x.
Lemma Rbar_plus_0_l (x : Rbar) : Rbar_plus (Finite 0) x = x.

Lemma Rbar_plus_comm (x y : Rbar) : Rbar_plus x y = Rbar_plus y x.

Lemma Rbar_plus_lt_compat (a b c d : Rbar) :
  Rbar_lt a b -> Rbar_lt c d -> Rbar_lt (Rbar_plus a c) (Rbar_plus b d).

Lemma Rbar_plus_le_compat (a b c d : Rbar) :
  Rbar_le a b -> Rbar_le c d -> Rbar_le (Rbar_plus a c) (Rbar_plus b d).

Lemma Rbar_plus_opp (x y : Rbar) :
  Rbar_plus (Rbar_opp x) (Rbar_opp y) = Rbar_opp (Rbar_plus x y).

Lemma Rbar_minus_eq_0 (x : Rbar) : Rbar_minus x x = 0.
Lemma Rbar_opp_minus (x y : Rbar) :
  Rbar_opp (Rbar_minus x y) = Rbar_minus y x.

Lemma Rbar_inv_opp (x : Rbar) :
  x <> 0 -> Rbar_inv (Rbar_opp x) = Rbar_opp (Rbar_inv x).

Lemma Rbar_mult'_comm (x y : Rbar) :
  Rbar_mult' x y = Rbar_mult' y x.

Lemma Rbar_mult'_opp_r (x y : Rbar) :
  Rbar_mult' x (Rbar_opp y) = match Rbar_mult' x y with Some z => Some (Rbar_opp z) | None => None end.

Lemma Rbar_mult_comm (x y : Rbar) :
  Rbar_mult x y = Rbar_mult y x.
Lemma Rbar_mult_opp_r (x y : Rbar) :
  Rbar_mult x (Rbar_opp y) = (Rbar_opp (Rbar_mult x y)).
Lemma Rbar_mult_opp_l (x y : Rbar) :
  Rbar_mult (Rbar_opp x) y = Rbar_opp (Rbar_mult x y).
Lemma Rbar_mult_opp (x y : Rbar) :
  Rbar_mult (Rbar_opp x) (Rbar_opp y) = Rbar_mult x y.
Lemma Rbar_mult_0_l (x : Rbar) : Rbar_mult 0 x = 0.
Lemma Rbar_mult_0_r (x : Rbar) : Rbar_mult x 0 = 0.

Lemma Rbar_mult_eq_0 (y x : Rbar) :
  Rbar_mult x y = 0 -> x = 0 \/ y = 0.

Lemma ex_Rbar_mult_sym (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult y x.
Lemma ex_Rbar_mult_opp_l (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult (Rbar_opp x) y.
Lemma ex_Rbar_mult_opp_r (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult x (Rbar_opp y).

Lemma is_Rbar_mult_sym (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult y x z.
Lemma is_Rbar_mult_opp_l (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult (Rbar_opp x) y (Rbar_opp z).
Lemma is_Rbar_mult_opp_r (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult x (Rbar_opp y) (Rbar_opp z).

Lemma is_Rbar_mult_p_infty_pos (x : Rbar) :
  Rbar_lt 0 x -> is_Rbar_mult p_infty x p_infty.
Lemma is_Rbar_mult_p_infty_neg (x : Rbar) :
  Rbar_lt x 0 -> is_Rbar_mult p_infty x m_infty.
Lemma is_Rbar_mult_m_infty_pos (x : Rbar) :
  Rbar_lt 0 x -> is_Rbar_mult m_infty x m_infty.
Lemma is_Rbar_mult_m_infty_neg (x : Rbar) :
  Rbar_lt x 0 -> is_Rbar_mult m_infty x p_infty.

Lemma is_Rbar_div_p_infty (x : R) :
  is_Rbar_div x p_infty 0.
Lemma is_Rbar_div_m_infty (x : R) :
  is_Rbar_div x m_infty 0.

Lemma Rbar_mult_pos_eq (x y : Rbar) (z : posreal) :
  x = y <-> (Rbar_mult_pos x z) = (Rbar_mult_pos y z).

Lemma Rbar_mult_pos_lt (x y : Rbar) (z : posreal) :
  Rbar_lt x y <-> Rbar_lt (Rbar_mult_pos x z) (Rbar_mult_pos y z).

Lemma Rbar_mult_pos_le (x y : Rbar) (z : posreal) :
  Rbar_le x y <-> Rbar_le (Rbar_mult_pos x z) (Rbar_mult_pos y z).

Lemma Rbar_div_pos_eq (x y : Rbar) (z : posreal) :
  x = y <-> (Rbar_div_pos x z) = (Rbar_div_pos y z).

Lemma Rbar_div_pos_lt (x y : Rbar) (z : posreal) :
  Rbar_lt x y <-> Rbar_lt (Rbar_div_pos x z) (Rbar_div_pos y z).

Lemma Rbar_div_pos_le (x y : Rbar) (z : posreal) :
  Rbar_le x y <-> Rbar_le (Rbar_div_pos x z) (Rbar_div_pos y z).

Definition Rbar_min (x y : Rbar) : Rbar :=
  match x, y with
  | z, p_infty | p_infty, z => z
  | _ , m_infty | m_infty, _ => m_infty
  | Finite x, Finite y => Rmin x y
  end.

Lemma Rbar_lt_locally (a b : Rbar) (x : R) :
  Rbar_lt a x -> Rbar_lt x b ->
  exists delta : posreal,
    forall y, Rabs (y - x) < delta -> Rbar_lt a y /\ Rbar_lt y b.

Lemma Rbar_min_comm (x y : Rbar) : Rbar_min x y = Rbar_min y x.

Lemma Rbar_min_r (x y : Rbar) : Rbar_le (Rbar_min x y) y.

Lemma Rbar_min_l (x y : Rbar) : Rbar_le (Rbar_min x y) x.

Lemma Rbar_min_case (x y : Rbar) (P : Rbar -> Type) :
  P x -> P y -> P (Rbar_min x y).
Lemma Rbar_min_case_strong (r1 r2 : Rbar) (P : Rbar -> Type) :
  (Rbar_le r1 r2 -> P r1) -> (Rbar_le r2 r1 -> P r2)
    -> P (Rbar_min r1 r2).

Definition Rbar_abs (x : Rbar) :=
  match x with
    | Finite x => Finite (Rabs x)
    | _ => p_infty
  end.

Lemma Rbar_abs_lt_between (x y : Rbar) :
  Rbar_lt (Rbar_abs x) y <-> (Rbar_lt (Rbar_opp y) x /\ Rbar_lt x y).

Lemma Rbar_abs_opp (x : Rbar) :
  Rbar_abs (Rbar_opp x) = Rbar_abs x.

Lemma Rbar_abs_pos (x : Rbar) :
  Rbar_le 0 x -> Rbar_abs x = x.
Lemma Rbar_abs_neg (x : Rbar) :
  Rbar_le x 0 -> Rbar_abs x = Rbar_opp x. *)
(* Lub:
Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Rbar Rcomplements Markov.

Open Scope R_scope.

Definition is_ub_Rbar (E : R -> Prop) (l : Rbar) :=
  forall (x : R), E x -> Rbar_le x l.
Definition is_lb_Rbar (E : R -> Prop) (l : Rbar) :=
  forall (x : R), E x -> Rbar_le l x.

Lemma is_ub_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_lb_Rbar E l <-> is_ub_Rbar (fun x => E (- x)) (Rbar_opp l).
Lemma is_lb_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_ub_Rbar E l <-> is_lb_Rbar (fun x => E (- x)) (Rbar_opp l).

Lemma is_ub_Rbar_dec (E : R -> Prop) :
  {l : R | is_ub_Rbar E l} + {(forall l : R, ~is_ub_Rbar E l)}.

Lemma is_lb_Rbar_dec (E : R -> Prop) :
  {l : R | is_lb_Rbar E l} + {(forall l : R, ~is_lb_Rbar E l)}.

Lemma is_ub_Rbar_subset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_ub_Rbar E1 l -> is_ub_Rbar E2 l.
Lemma is_lb_Rbar_subset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_lb_Rbar E1 l -> is_lb_Rbar E2 l.

Definition is_lub_Rbar (E : R -> Prop) (l : Rbar) :=
  is_ub_Rbar E l /\ (forall b, is_ub_Rbar E b -> Rbar_le l b).
Definition is_glb_Rbar (E : R -> Prop) (l : Rbar) :=
  is_lb_Rbar E l /\ (forall b, is_lb_Rbar E b -> Rbar_le b l).

Lemma is_lub_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_glb_Rbar E l <-> is_lub_Rbar (fun x => E (- x)) (Rbar_opp l).
Lemma is_glb_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_lub_Rbar E l <-> is_glb_Rbar (fun x => E (- x)) (Rbar_opp l).

Lemma ex_lub_Rbar (E : R -> Prop) : {l : Rbar | is_lub_Rbar E l}.
Lemma ex_glb_Rbar (E : R -> Prop) : {l : Rbar | is_glb_Rbar E l}.

Definition Lub_Rbar (E : R -> Prop) := proj1_sig (ex_lub_Rbar E).
Definition Glb_Rbar (E : R -> Prop) := proj1_sig (ex_glb_Rbar E).

Lemma is_lub_Rbar_unique (E : R -> Prop) (l : Rbar) :
  is_lub_Rbar E l -> Lub_Rbar E = l.
Lemma is_glb_Rbar_unique (E : R -> Prop) (l : Rbar) :
  is_glb_Rbar E l -> Glb_Rbar E = l.

Lemma Lub_Rbar_correct (E : R -> Prop) :
  is_lub_Rbar E (Lub_Rbar E).
Lemma Glb_Rbar_correct (E : R -> Prop) :
  is_glb_Rbar E (Glb_Rbar E).

Lemma is_lub_Rbar_subset (E1 E2 : R -> Prop) (l1 l2 : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_lub_Rbar E1 l1 -> is_lub_Rbar E2 l2
    -> Rbar_le l2 l1.
Lemma is_glb_Rbar_subset (E1 E2 : R -> Prop) (l1 l2 : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_glb_Rbar E1 l1 -> is_glb_Rbar E2 l2
    -> Rbar_le l1 l2.

Lemma is_lub_Rbar_eqset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x <-> E1 x) -> is_lub_Rbar E1 l -> is_lub_Rbar E2 l.
Lemma is_glb_Rbar_eqset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x <-> E1 x) -> is_glb_Rbar E1 l -> is_glb_Rbar E2 l.

Lemma Lub_Rbar_eqset (E1 E2 : R -> Prop) :
  (forall x, E1 x <-> E2 x) -> Lub_Rbar E1 = Lub_Rbar E2.
Lemma Glb_Rbar_eqset (E1 E2 : R -> Prop) :
  (forall x, E1 x <-> E2 x) -> Glb_Rbar E1 = Glb_Rbar E2.

Definition Rbar_is_upper_bound (E : Rbar -> Prop) (l : Rbar) :=
  forall x, E x -> Rbar_le x l.

Definition Rbar_is_lower_bound (E : Rbar -> Prop) (l : Rbar) :=
  forall x, E x -> Rbar_le l x.

Lemma Rbar_ub_lb (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_upper_bound (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_lower_bound E l.
Lemma Rbar_lb_ub (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lower_bound (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_upper_bound E l.

Lemma is_ub_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_ub_Rbar E l <-> Rbar_is_upper_bound (fun x => is_finite x /\ E x) l.
Lemma is_lb_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_lb_Rbar E l <-> Rbar_is_lower_bound (fun x => is_finite x /\ E x) l.

Lemma Rbar_ub_p_infty (E : Rbar -> Prop) :
  Rbar_is_upper_bound E p_infty.
Lemma Rbar_lb_m_infty (E : Rbar -> Prop) :
  Rbar_is_lower_bound E m_infty.

Lemma Rbar_ub_Finite (E : Rbar -> Prop) (l : R) :
  Rbar_is_upper_bound E l ->
    is_upper_bound (fun (x : R) => E x) l.
Lemma Rbar_lb_Finite (E : Rbar -> Prop) (l : R) :
  Rbar_is_lower_bound E (Finite l) ->
    is_upper_bound (fun x => E (Finite (- x))) (- l).

Lemma Rbar_ub_m_infty (E : Rbar -> Prop) :
  Rbar_is_upper_bound E m_infty -> forall x, E x -> x = m_infty.
Lemma Rbar_lb_p_infty (E : Rbar -> Prop) :
  Rbar_is_lower_bound E p_infty -> (forall x, E x -> x = p_infty).

Lemma Rbar_lb_le_ub (E : Rbar -> Prop) (l1 l2 : Rbar) : (exists x, E x) ->
  Rbar_is_lower_bound E l1 -> Rbar_is_upper_bound E l2 -> Rbar_le l1 l2.
Lemma Rbar_lb_eq_ub (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lower_bound E l -> Rbar_is_upper_bound E l -> forall x, E x -> x = l.

Lemma Rbar_ub_dec (E : Rbar -> Prop) (Hp : ~ E p_infty) :
  {M : R | Rbar_is_upper_bound E M}
    + {(forall (M : R), ~Rbar_is_upper_bound E M)}.
Lemma Rbar_lb_dec (E : Rbar -> Prop) (Hm : ~ E m_infty) :
  {M : R | Rbar_is_lower_bound E (Finite M)}
    + {(forall M, ~Rbar_is_lower_bound E (Finite M))}.

Lemma Rbar_is_ub_subset (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x -> E2 x) -> (Rbar_is_upper_bound E2 l) -> (Rbar_is_upper_bound E1 l).
Lemma Rbar_is_lb_subset (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x -> E2 x) -> (Rbar_is_lower_bound E2 l) -> (Rbar_is_lower_bound E1 l).

Definition Rbar_is_lub (E : Rbar -> Prop) (l : Rbar) :=
  Rbar_is_upper_bound E l /\
    (forall b : Rbar, Rbar_is_upper_bound E b -> Rbar_le l b).
Definition Rbar_is_glb (E : Rbar -> Prop) (l : Rbar) :=
  Rbar_is_lower_bound E l /\
    (forall b : Rbar, Rbar_is_lower_bound E b -> Rbar_le b l).

Lemma Rbar_lub_glb (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lub (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_glb E l.
Lemma Rbar_glb_lub (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_glb (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_lub E l.

Lemma is_lub_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_lub_Rbar E l <-> Rbar_is_lub (fun x => is_finite x /\ E x) l.
Lemma is_glb_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_glb_Rbar E l <-> Rbar_is_glb (fun x => is_finite x /\ E x) l.

Lemma Rbar_ex_lub (E : Rbar -> Prop) :
  {l : Rbar | Rbar_is_lub E l}.

Lemma Rbar_ex_glb (E : Rbar -> Prop) :
  {l : Rbar | Rbar_is_glb E l}.

Definition Rbar_lub (E : Rbar -> Prop)
  := proj1_sig (Rbar_ex_lub E).
Definition Rbar_glb (E : Rbar -> Prop)
  := proj1_sig (Rbar_ex_glb E).

Lemma Rbar_opp_glb_lub (E : Rbar -> Prop) :
  Rbar_glb (fun x => E (Rbar_opp x)) = Rbar_opp (Rbar_lub E).
Lemma Rbar_opp_lub_glb (E : Rbar -> Prop) :
  Rbar_lub (fun x => E (Rbar_opp x)) = Rbar_opp (Rbar_glb E).

Lemma Rbar_is_lub_unique (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lub E l -> Rbar_lub E = l.
Lemma Rbar_is_glb_unique (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_glb E l -> Rbar_glb E = l.

Lemma Rbar_glb_le_lub (E : Rbar -> Prop) :
  (exists x, E x) -> Rbar_le (Rbar_glb E) (Rbar_lub E).

Lemma Rbar_is_lub_subset (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E1 x -> E2 x) -> (Rbar_is_lub E1 l1) -> (Rbar_is_lub E2 l2)
  -> Rbar_le l1 l2.
Lemma Rbar_is_glb_subset (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E2 x -> E1 x) -> (Rbar_is_glb E1 l1) -> (Rbar_is_glb E2 l2)
  -> Rbar_le l1 l2.

Lemma Rbar_is_lub_eq (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_lub E1 l1) -> (Rbar_is_lub E2 l2)
  -> l1 = l2.
Lemma Rbar_is_glb_eq (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_glb E1 l1) -> (Rbar_is_glb E2 l2)
  -> l1 = l2.

Lemma Rbar_is_lub_ext (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_lub E1 l) -> (Rbar_is_lub E2 l).
Lemma Rbar_is_glb_ext (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_glb E1 l) -> (Rbar_is_glb E2 l).

Lemma Rbar_lub_subset (E1 E2 : Rbar -> Prop) :
  (forall x, E1 x -> E2 x) -> Rbar_le (Rbar_lub E1) (Rbar_lub E2).
Lemma Rbar_glb_subset (E1 E2 : Rbar -> Prop) :
  (forall x, E2 x -> E1 x) -> Rbar_le (Rbar_glb E1) (Rbar_glb E2).

Lemma Rbar_lub_rw (E1 E2 : Rbar -> Prop) :
  (forall x, E1 x <-> E2 x) -> Rbar_lub E1 = Rbar_lub E2.
Lemma Rbar_glb_rw (E1 E2 : Rbar -> Prop) :
  (forall x, E1 x <-> E2 x) -> Rbar_glb E1 = Rbar_glb E2.

Definition Empty (E : R -> Prop) :=
  Lub_Rbar (fun x => x = 0 \/ E x) = Glb_Rbar (fun x => x = 0 \/ E x)
  /\ Lub_Rbar (fun x => x = 1 \/ E x) = Glb_Rbar (fun x => x = 1 \/ E x).

Lemma Empty_correct_1 (E : R -> Prop) :
  Empty E -> forall x, ~ E x.

Lemma Empty_correct_2 (E : R -> Prop) :
  (forall x, ~ E x) -> Empty E.

Lemma Empty_dec (E : R -> Prop) :
  {~Empty E}+{Empty E}.
Lemma not_Empty_dec (E : R -> Prop) : (Decidable.decidable (exists x, E x)) ->

Lemma uniqueness_dec P : (exists ! x : R, P x) -> {x : R | P x}. *)
(* Markov:
Require Import RIneq Rcomplements Omega.

Open Scope R_scope.

Theorem LPO_min :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n /\ forall i, (i < n)%nat -> ~ P i} + {forall n, ~ P n}.

Theorem LPO :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n} + {forall n, ~ P n}.

Lemma LPO_bool :
  forall f : nat -> bool,
  {n | f n = true} + {forall n, f n = false}.

Lemma LPO_notforall : forall P : nat -> Prop, (forall n, P n \/ ~P n) ->
  (~ forall n : nat, ~ P n) -> exists n : nat, P n.

Lemma LPO_notnotexists : forall P : nat -> Prop, (forall n, P n \/ ~P n) ->
  ~~ (exists n : nat, P n) -> exists n : nat, P n.

Lemma LPO_ub_dec : forall (u : nat -> R),
  {M : R | forall n, u n <= M} + {forall M : R, exists n, M < u n}.

Lemma EM_dec :
  forall P : Prop, {not (not P)} + {not P}.

Lemma EM_dec' :
  forall P : Prop, P \/ not P -> {P} + {not P}. *)
(* Hierarchy:
Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Rcomplements Rbar Markov Iter Lub.

Open Scope R_scope.

Class Filter {T : Type} (F : (T -> Prop) -> Prop) := {
  filter_true : F (fun _ => True) ;
  filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x => P x /\ Q x) ;
  filter_imp : forall P Q : T -> Prop, (forall x, P x -> Q x) -> F P -> F Q
}.

Global Hint Mode Filter + + : typeclass_instances.

Class ProperFilter' {T : Type} (F : (T -> Prop) -> Prop) := {
  filter_not_empty : not (F (fun _ => False)) ;
  filter_filter' :> Filter F
}.

Class ProperFilter {T : Type} (F : (T -> Prop) -> Prop) := {
  filter_ex : forall P, F P -> exists x, P x ;
  filter_filter :> Filter F
}.

Global Instance Proper_StrongProper :
  forall {T : Type} (F : (T -> Prop) -> Prop),
  ProperFilter F -> ProperFilter' F.

Lemma filter_forall :
  forall {T : Type} {F} {FF: @Filter T F} (P : T -> Prop),
  (forall x, P x) -> F P.

Lemma filter_const :
  forall {T : Type} {F} {FF: @ProperFilter T F} (P : Prop),
  F (fun _ => P) -> P.

Definition filter_le {T : Type} (F G : (T -> Prop) -> Prop) :=
  forall P, G P -> F P.

Lemma filter_le_refl :
  forall T F, @filter_le T F F.

Lemma filter_le_trans :
  forall T F G H, @filter_le T F G -> filter_le G H -> filter_le F H.

Definition filtermap {T U : Type} (f : T -> U) (F : (T -> Prop) -> Prop) :=
  fun P => F (fun x => P (f x)).

Global Instance filtermap_filter :
  forall T U (f : T -> U) (F : (T -> Prop) -> Prop),
  Filter F -> Filter (filtermap f F).

Global Instance filtermap_proper_filter' :
  forall T U (f : T -> U) (F : (T -> Prop) -> Prop),
  ProperFilter' F -> ProperFilter' (filtermap f F).

Global Instance filtermap_proper_filter :
  forall T U (f : T -> U) (F : (T -> Prop) -> Prop),
  ProperFilter F -> ProperFilter (filtermap f F).

Definition filtermapi {T U : Type} (f : T -> U -> Prop) (F : (T -> Prop) -> Prop) :=
  fun P : U -> Prop => F (fun x => exists y, f x y /\ P y).

Global Instance filtermapi_filter :
  forall T U (f : T -> U -> Prop) (F : (T -> Prop) -> Prop),
  F (fun x => (exists y, f x y) /\ forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  Filter F -> Filter (filtermapi f F).

Global Instance filtermapi_proper_filter' :
  forall T U (f : T -> U -> Prop) (F : (T -> Prop) -> Prop),
  F (fun x => (exists y, f x y) /\ forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  ProperFilter' F -> ProperFilter' (filtermapi f F).

Global Instance filtermapi_proper_filter :
  forall T U (f : T -> U -> Prop) (F : (T -> Prop) -> Prop),
  F (fun x => (exists y, f x y) /\ forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  ProperFilter F -> ProperFilter (filtermapi f F).

Definition filterlim {T U : Type} (f : T -> U) F G :=
  filter_le (filtermap f F) G.

Lemma filterlim_id :
  forall T (F : (T -> Prop) -> Prop), filterlim (fun x => x) F F.

Lemma filterlim_comp :
  forall T U V (f : T -> U) (g : U -> V) F G H,
  filterlim f F G -> filterlim g G H ->
  filterlim (fun x => g (f x)) F H.

Lemma filterlim_ext_loc :
  forall {T U F G} {FF : Filter F} (f g : T -> U),
  F (fun x => f x = g x) ->
  filterlim f F G ->
  filterlim g F G.

Lemma filterlim_ext :
  forall {T U F G} {FF : Filter F} (f g : T -> U),
  (forall x, f x = g x) ->
  filterlim f F G ->
  filterlim g F G.

Lemma filterlim_filter_le_1 :
  forall {T U F G H} (f : T -> U),
  filter_le G F ->
  filterlim f F H ->
  filterlim f G H.

Lemma filterlim_filter_le_2 :
  forall {T U F G H} (f : T -> U),
  filter_le G H ->
  filterlim f F G ->
  filterlim f F H.

Definition filterlimi {T U : Type} (f : T -> U -> Prop) F G :=
  filter_le (filtermapi f F) G.

Lemma filterlimi_comp :
  forall T U V (f : T -> U) (g : U -> V -> Prop) F G H,
  filterlim f F G -> filterlimi g G H ->
  filterlimi (fun x => g (f x)) F H.

Lemma filterlimi_ext_loc :
  forall {T U F G} {FF : Filter F} (f g : T -> U -> Prop),
  F (fun x => forall y, f x y <-> g x y) ->
  filterlimi f F G ->
  filterlimi g F G.

Lemma filterlimi_ext :
  forall {T U F G} {FF : Filter F} (f g : T -> U -> Prop),
  (forall x y, f x y <-> g x y) ->
  filterlimi f F G ->
  filterlimi g F G.

Lemma filterlimi_filter_le_1 :
  forall {T U F G H} (f : T -> U -> Prop),
  filter_le G F ->
  filterlimi f F H ->
  filterlimi f G H.

Lemma filterlimi_filter_le_2 :
  forall {T U F G H} (f : T -> U -> Prop),
  filter_le G H ->
  filterlimi f F G ->
  filterlimi f F H.

Inductive filter_prod {T U : Type} (F G : _ -> Prop) (P : T * U -> Prop) : Prop :=
  Filter_prod (Q : T -> Prop) (R : U -> Prop) :
    F Q -> G R -> (forall x y, Q x -> R y -> P (x, y)) -> filter_prod F G P.

Global Instance filter_prod_filter :
  forall T U (F : (T -> Prop) -> Prop) (G : (U -> Prop) -> Prop),
  Filter F -> Filter G -> Filter (filter_prod F G).

Global Instance filter_prod_proper' {T1 T2 : Type}
  {F : (T1 -> Prop) -> Prop} {G : (T2 -> Prop) -> Prop}
  {FF : ProperFilter' F} {FG : ProperFilter' G} :
  ProperFilter' (filter_prod F G).

Global Instance filter_prod_proper {T1 T2 : Type}
  {F : (T1 -> Prop) -> Prop} {G : (T2 -> Prop) -> Prop}
  {FF : ProperFilter F} {FG : ProperFilter G} :
  ProperFilter (filter_prod F G).

Lemma filterlim_fst :
  forall {T U F G} {FG : Filter G},
  filterlim (@fst T U) (filter_prod F G) F.

Lemma filterlim_snd :
  forall {T U F G} {FF : Filter F},
  filterlim (@snd T U) (filter_prod F G) G.

Lemma filterlim_pair :
  forall {T U V F G H} {FF : Filter F},
  forall (f : T -> U) (g : T -> V),
  filterlim f F G ->
  filterlim g F H ->
  filterlim (fun x => (f x, g x)) F (filter_prod G H).

Lemma filterlim_comp_2 :
  forall {T U V W F G H I} {FF : Filter F},
  forall (f : T -> U) (g : T -> V) (h : U -> V -> W),
  filterlim f F G ->
  filterlim g F H ->
  filterlim (fun x => h (fst x) (snd x)) (filter_prod G H) I ->
  filterlim (fun x => h (f x) (g x)) F I.

Lemma filterlimi_comp_2 :
  forall {T U V W F G H I} {FF : Filter F},
  forall (f : T -> U) (g : T -> V) (h : U -> V -> W -> Prop),
  filterlim f F G ->
  filterlim g F H ->
  filterlimi (fun x => h (fst x) (snd x)) (filter_prod G H) I ->
  filterlimi (fun x => h (f x) (g x)) F I.

Definition within {T : Type} D (F : (T -> Prop) -> Prop) (P : T -> Prop) :=
  F (fun x => D x -> P x).

Global Instance within_filter :
  forall T D F, Filter F -> Filter (@within T D F).

Lemma filter_le_within :
  forall {T} {F : (T -> Prop) -> Prop} {FF : Filter F} D,
  filter_le (within D F) F.

Lemma filterlim_within_ext :
  forall {T U F G} {FF : Filter F} D (f g : T -> U),
  (forall x, D x -> f x = g x) ->
  filterlim f (within D F) G ->
  filterlim g (within D F) G.

Definition subset_filter {T} (F : (T -> Prop) -> Prop) (dom : T -> Prop) (P : {x|dom x} -> Prop) : Prop :=
  F (fun x => forall H : dom x, P (exist _ x H)).

Global Instance subset_filter_filter :
  forall T F (dom : T -> Prop),
  Filter F ->
  Filter (subset_filter F dom).

Lemma subset_filter_proper' :
  forall {T F} {FF : Filter F} (dom : T -> Prop),
  (forall P, F P -> ~ ~ exists x, dom x /\ P x) ->
  ProperFilter' (subset_filter F dom).

Lemma subset_filter_proper :
  forall {T F} {FF : Filter F} (dom : T -> Prop),
  (forall P, F P -> exists x, dom x /\ P x) ->
  ProperFilter (subset_filter F dom).

Module AbelianGroup.

Record mixin_of (G : Type) := Mixin {
  plus : G -> G -> G ;
  opp : G -> G ;
  zero : G ;
  ax1 : forall x y, plus x y = plus y x ;
  ax2 : forall x y z, plus x (plus y z) = plus (plus x y) z ;
  ax3 : forall x, plus x zero = x ;
  ax4 : forall x, plus x (opp x) = zero
}.

Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.
Definition class (cT : type) := let: Pack _ c _ := cT return class_of cT in c.

End ClassDef.

Module Exports.

Coercion sort : type >-> Sortclass.
Notation AbelianGroup := type.

End Exports.

End AbelianGroup.

Export AbelianGroup.Exports.

Section AbelianGroup1.

Context {G : AbelianGroup}.

Definition zero := AbelianGroup.zero _ (AbelianGroup.class G).
Definition plus := AbelianGroup.plus _ (AbelianGroup.class G).
Definition opp := AbelianGroup.opp _ (AbelianGroup.class G).
Definition minus x y := (plus x (opp y)).

Lemma plus_comm :
  forall x y : G,
  plus x y = plus y x.

Lemma plus_assoc :
  forall x y z : G,
  plus x (plus y z) = plus (plus x y) z.

Lemma plus_zero_r :
  forall x : G,
  plus x zero = x.

Lemma plus_opp_r :
  forall x : G,
  plus x (opp x) = zero.

Lemma plus_zero_l :
  forall x : G,
  plus zero x = x.

Lemma plus_opp_l :
  forall x : G,
  plus (opp x) x = zero.

Lemma opp_zero :
  opp zero = zero.

Lemma minus_zero_r :
  forall x : G,
  minus x zero = x.

Lemma minus_eq_zero (x : G) :
  minus x x = zero.

Lemma plus_reg_l :
  forall r x y : G,
  plus r x = plus r y -> x = y.
Lemma plus_reg_r :
  forall r x y : G,
  plus x r = plus y r -> x = y.

Lemma opp_opp :
  forall x : G,
  opp (opp x) = x.

Lemma opp_plus :
  forall x y : G,
  opp (plus x y) = plus (opp x) (opp y).
Lemma opp_minus (x y : G) :
  opp (minus x y) = minus y x.

Lemma minus_trans (r x y : G) :
  minus x y = plus (minus x r) (minus r y).

End AbelianGroup1.

Section Sums.

Context {G : AbelianGroup}.

Definition sum_n_m (a : nat -> G) n m :=
  iter_nat plus zero a n m.
Definition sum_n (a : nat -> G) n :=
  sum_n_m a O n.

Lemma sum_n_m_Chasles (a : nat -> G) (n m k : nat) :
  (n <= S m)%nat -> (m <= k)%nat
    -> sum_n_m a n k = plus (sum_n_m a n m) (sum_n_m a (S m) k).

Lemma sum_n_n (a : nat -> G) (n : nat) :
  sum_n_m a n n = a n.
Lemma sum_O (a : nat -> G) : sum_n a 0 = a O.
Lemma sum_n_Sm (a : nat -> G) (n m : nat) :
  (n <= S m)%nat -> sum_n_m a n (S m) = plus (sum_n_m a n m) (a (S m)).
Lemma sum_Sn_m (a : nat -> G) (n m : nat) :
  (n <= m)%nat -> sum_n_m a n m = plus (a n) (sum_n_m a (S n) m).
Lemma sum_n_m_S (a : nat -> G) (n m : nat) :
  sum_n_m (fun n => a (S n)) n m = sum_n_m a (S n) (S m).

Lemma sum_Sn (a : nat -> G) (n : nat) :
  sum_n a (S n) = plus (sum_n a n) (a (S n)).

Lemma sum_n_m_zero (a : nat -> G) (n m : nat) :
  (m < n)%nat -> sum_n_m a n m = zero.
Lemma sum_n_m_const_zero (n m : nat) :
  sum_n_m (fun _ => zero) n m = zero.

Lemma sum_n_m_ext_loc (a b : nat -> G) (n m : nat) :
  (forall k, (n <= k <= m)%nat -> a k = b k) ->
  sum_n_m a n m = sum_n_m b n m.
Lemma sum_n_m_ext (a b : nat -> G) n m :
  (forall n, a n = b n) ->
  sum_n_m a n m = sum_n_m b n m.

Lemma sum_n_ext_loc :
  forall (a b : nat -> G) N,
  (forall n, (n <= N)%nat -> a n = b n) ->
  sum_n a N = sum_n b N.
Lemma sum_n_ext :
  forall (a b : nat -> G) N,
  (forall n, a n = b n) ->
  sum_n a N = sum_n b N.

Lemma sum_n_m_plus :
  forall (u v : nat -> G) (n m : nat),
  sum_n_m (fun k => plus (u k) (v k)) n m = plus (sum_n_m u n m) (sum_n_m v n m).

Lemma sum_n_plus :
  forall (u v : nat -> G) (n : nat),
  sum_n (fun k => plus (u k) (v k)) n = plus (sum_n u n) (sum_n v n).

Lemma sum_n_switch :
  forall (u : nat -> nat -> G) (m n : nat),
  sum_n (fun i => sum_n (u i) n) m = sum_n (fun j => sum_n (fun i => u i j) m) n.

Lemma sum_n_m_sum_n (a:nat -> G) (n m : nat) :
  (n <= m)%nat -> sum_n_m a (S n) m = minus (sum_n a m) (sum_n a n).

End Sums.

Module Ring.

Record mixin_of (K : AbelianGroup) := Mixin {
  mult : K -> K -> K ;
  one : K ;
  ax1 : forall x y z, mult x (mult y z) = mult (mult x y) z ;
  ax2 : forall x, mult x one = x ;
  ax3 : forall x, mult one x = x ;
  ax4 : forall x y z, mult (plus x y) z = plus (mult x z) (mult y z) ;
  ax5 : forall x y z, mult x (plus y z) = plus (mult x y) (mult x z)
}.

Section ClassDef.

Record class_of (K : Type) := Class {
  base : AbelianGroup.class_of K ;
  mixin : mixin_of (AbelianGroup.Pack _ base K)
}.
Local Coercion base : class_of >-> AbelianGroup.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> AbelianGroup.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Notation Ring := type.

End Exports.

End Ring.

Export Ring.Exports.

Section Ring1.

Context {K : Ring}.

Definition mult : K -> K -> K := Ring.mult _ (Ring.class K).
Definition one : K := Ring.one _ (Ring.class K).

Lemma mult_assoc :
  forall x y z : K,
  mult x (mult y z) = mult (mult x y) z.

Lemma mult_one_r :
  forall x : K,
  mult x one = x.

Lemma mult_one_l :
  forall x : K,
  mult one x = x.

Lemma mult_distr_r :
  forall x y z : K,
  mult (plus x y) z = plus (mult x z) (mult y z).

Lemma mult_distr_l :
  forall x y z : K,
  mult x (plus y z) = plus (mult x y) (mult x z).

Lemma mult_zero_r :
  forall x : K,
  mult x zero = zero.

Lemma mult_zero_l :
  forall x : K,
  mult zero x = zero.

Lemma opp_mult_r :
  forall x y : K,
  opp (mult x y) = mult x (opp y).

Lemma opp_mult_l :
  forall x y : K,
  opp (mult x y) = mult (opp x) y.

Lemma opp_mult_m1 :
  forall x : K,
  opp x = mult (opp one) x.

Lemma sum_n_m_mult_r :
 forall (a : K) (u : nat -> K) (n m : nat),
  sum_n_m (fun k => mult (u k) a) n m = mult (sum_n_m u n m) a.

Lemma sum_n_m_mult_l :
 forall (a : K) (u : nat -> K) (n m : nat),
  sum_n_m (fun k => mult a (u k)) n m = mult a (sum_n_m u n m).

Lemma sum_n_mult_r :
 forall (a : K) (u : nat -> K) (n : nat),
  sum_n (fun k => mult (u k) a) n = mult (sum_n u n) a.

Lemma sum_n_mult_l :
 forall (a : K) (u : nat -> K) (n : nat),
  sum_n (fun k => mult a (u k)) n = mult a (sum_n u n).

Fixpoint pow_n (x : K) (N : nat) {struct N} : K :=
  match N with
   | 0%nat => one
   | S i => mult x (pow_n x i)
  end.

Lemma pow_n_plus :
  forall (x : K) (n m : nat), pow_n x (n+m) = mult (pow_n x n) (pow_n x m).

Lemma pow_n_comm_1 :
  forall (x : K) (n : nat), mult (pow_n x n) x = mult x (pow_n x n).

Lemma pow_n_comm :
  forall (x : K) n m, mult (pow_n x n) (pow_n x m) = mult (pow_n x m) (pow_n x n).

End Ring1.

Module AbsRing.

Record mixin_of (K : Ring) := Mixin {
  abs : K -> R ;
  ax1 : abs zero = 0 ;
  ax2 : abs (opp one) = 1 ;
  ax3 : forall x y : K, abs (plus x y) <= abs x + abs y ;
  ax4 : forall x y : K, abs (mult x y) <= abs x * abs y ;
  ax5 : forall x : K, abs x = 0 -> x = zero
}.

Section ClassDef.

Record class_of (K : Type) := Class {
  base : Ring.class_of K ;
  mixin : mixin_of (Ring.Pack _ base K)
}.
Local Coercion base : class_of >-> Ring.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition Ring := Ring.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> Ring.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion Ring : type >-> Ring.type.
Canonical Ring.
Notation AbsRing := type.

End Exports.

End AbsRing.

Export AbsRing.Exports.

Section AbsRing1.

Context {K : AbsRing}.

Definition abs : K -> R := AbsRing.abs _ (AbsRing.class K).

Lemma abs_zero :
  abs zero = 0.

Lemma abs_opp_one :
  abs (opp one) = 1.

Lemma abs_triangle :
  forall x y : K,
  abs (plus x y) <= abs x + abs y.

Lemma abs_mult :
  forall x y : K,
  abs (mult x y) <= abs x * abs y.

Lemma abs_eq_zero :
  forall x : K,
  abs x = 0 -> x = zero.

Lemma abs_opp :
  forall x, abs (opp x) = abs x.

Lemma abs_minus :
  forall x y : K, abs (minus x y) = abs (minus y x).

Lemma abs_one :
  abs one = 1.

Lemma abs_ge_0 :
  forall x, 0 <= abs x.

Lemma abs_pow_n :
  forall (x : K) n,
  abs (pow_n x n) <= (abs x)^n.

End AbsRing1.

Module UniformSpace.

Record mixin_of (M : Type) := Mixin {
  ball : M -> R -> M -> Prop ;
  ax1 : forall x (e : posreal), ball x e x ;
  ax2 : forall x y e, ball x e y -> ball y e x ;
  ax3 : forall x y z e1 e2, ball x e1 y -> ball y e2 z -> ball x (e1 + e2) z
}.

Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.
Definition class (cT : type) := let: Pack _ c _ := cT return class_of cT in c.

End ClassDef.

Module Exports.

Coercion sort : type >-> Sortclass.
Notation UniformSpace := type.

End Exports.

End UniformSpace.

Export UniformSpace.Exports.

Section UniformSpace1.

Context {M : UniformSpace}.

Definition ball := UniformSpace.ball _ (UniformSpace.class M).

Lemma ball_center :
  forall (x : M) (e : posreal),
  ball x e x.

Lemma ball_sym :
  forall (x y : M) (e : R),
  ball x e y -> ball y e x.

Lemma ball_triangle :
  forall (x y z : M) (e1 e2 : R),
  ball x e1 y -> ball y e2 z -> ball x (e1 + e2) z.

Lemma ball_le :
  forall (x : M) (e1 e2 : R), e1 <= e2 ->
  forall (y : M), ball x e1 y -> ball x e2 y.

Definition close (x y : M) : Prop := forall eps : posreal, ball x eps y.

Lemma close_refl (x : M) : close x x.

Lemma close_sym (x y : M) : close x y -> close y x.

Lemma close_trans (x y z : M) : close x y -> close y z -> close x z.

End UniformSpace1.

Section AbsRing_UniformSpace.

Variable K : AbsRing.

Definition AbsRing_ball (x : K) (eps : R) (y : K) := abs (minus y x) < eps.

Lemma AbsRing_ball_center :
  forall (x : K) (e : posreal),
  AbsRing_ball x e x.

Lemma AbsRing_ball_sym :
  forall (x y : K) (e : R),
  AbsRing_ball x e y -> AbsRing_ball y e x.

Lemma AbsRing_ball_triangle :
  forall (x y z : K) (e1 e2 : R),
  AbsRing_ball x e1 y -> AbsRing_ball y e2 z ->
  AbsRing_ball x (e1 + e2) z.

Definition AbsRing_UniformSpace_mixin :=
  UniformSpace.Mixin _ _ AbsRing_ball_center AbsRing_ball_sym AbsRing_ball_triangle.

Canonical AbsRing_UniformSpace :=
  UniformSpace.Pack K AbsRing_UniformSpace_mixin K.

End AbsRing_UniformSpace.

Section fct_UniformSpace.

Variable (T : Type) (U : UniformSpace).

Definition fct_ball (x : T -> U) (eps : R) (y : T -> U) :=
  forall t : T, ball (x t) eps (y t).

Lemma fct_ball_center :
  forall (x : T -> U) (e : posreal),
  fct_ball x e x.

Lemma fct_ball_sym :
  forall (x y : T -> U) (e : R),
  fct_ball x e y -> fct_ball y e x.

Lemma fct_ball_triangle :
  forall (x y z : T -> U) (e1 e2 : R),
  fct_ball x e1 y -> fct_ball y e2 z -> fct_ball x (e1 + e2) z.

Definition fct_UniformSpace_mixin :=
  UniformSpace.Mixin _ _ fct_ball_center fct_ball_sym fct_ball_triangle.

Canonical fct_UniformSpace :=
  UniformSpace.Pack (T -> U) fct_UniformSpace_mixin (T -> U).

End fct_UniformSpace.

Definition locally_dist {T : Type} (d : T -> R) (P : T -> Prop) :=
  exists delta : posreal, forall y, d y < delta -> P y.

Global Instance locally_dist_filter :
  forall T (d : T -> R), Filter (locally_dist d).

Section Locally.

Context {T : UniformSpace}.

Definition locally (x : T) (P : T -> Prop) :=
  exists eps : posreal, forall y, ball x eps y -> P y.

Global Instance locally_filter :
  forall x : T, ProperFilter (locally x).

Lemma locally_locally :
  forall (x : T) (P : T -> Prop),
  locally x P -> locally x (fun y => locally y P).

Lemma locally_singleton :
  forall (x : T) (P : T -> Prop),
  locally x P -> P x.

Lemma locally_ball :
  forall (x : T) (eps : posreal), locally x (ball x eps).

Lemma locally_not' :
  forall (x : T) (P : T -> Prop),
  not (forall eps : posreal, not (forall y, ball x eps y -> not (P y))) ->
  {d : posreal | forall y, ball x d y -> not (P y)}.

Lemma locally_not :
  forall (x : T) (P : T -> Prop),
  not (forall eps : posreal, not (forall y, ball x eps y -> not (P y))) ->
  locally x (fun y => not (P y)).

Lemma locally_ex_not :
  forall (x : T) (P : T -> Prop),
  locally x (fun y => not (P y)) ->
  {d : posreal | forall y, ball x d y -> not (P y)}.

Lemma locally_ex_dec :
  forall (x : T) (P : T -> Prop),
  (forall x, P x \/ ~P x) ->
  locally x P ->
  {d : posreal | forall y, ball x d y -> P y}.

Definition is_filter_lim (F : (T -> Prop) -> Prop) (x : T) :=
  forall P, locally x P -> F P.

Lemma is_filter_lim_filter_le :
  forall {F G} (x : T),
  filter_le G F ->
  is_filter_lim F x -> is_filter_lim G x.

Lemma is_filter_lim_close {F} {FF : ProperFilter F} (x y : T) :
  is_filter_lim F x -> is_filter_lim F y -> close x y.

Lemma is_filter_lim_locally_close (x y : T) :
  is_filter_lim (locally x) y -> close x y.

End Locally.

Lemma filterlim_const :
  forall {T} {U : UniformSpace} {F : (T -> Prop) -> Prop} {FF : Filter F},
  forall a : U, filterlim (fun _ => a) F (locally a).

Section Locally_fct.

Context {T : Type} {U : UniformSpace}.

Lemma filterlim_locally :
  forall {F} {FF : Filter F} (f : T -> U) y,
  filterlim f F (locally y) <->
  forall eps : posreal, F (fun x => ball y eps (f x)).

Lemma filterlimi_locally :
  forall {F} {FF : Filter F} (f : T -> U -> Prop) y,
  filterlimi f F (locally y) <->
  forall eps : posreal, F (fun x => exists z, f x z /\ ball y eps z).

Lemma filterlim_locally_close :
  forall {F} {FF: ProperFilter F} (f : T -> U) l l',
  filterlim f F (locally l) ->  filterlim f F (locally l') ->
  close l l'.

Lemma filterlimi_locally_close :
  forall {F} {FF: ProperFilter F} (f : T -> U -> Prop) l l',
  F (fun x => forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  filterlimi f F (locally l) ->  filterlimi f F (locally l') ->
  close l l'.

End Locally_fct.

Lemma is_filter_lim_filtermap {T: UniformSpace} {U : UniformSpace} :
forall F x (f : T -> U),
  filterlim f (locally x) (locally (f x))
  -> is_filter_lim F x
  -> is_filter_lim (filtermap f F) (f x).

Definition locally' {T : UniformSpace} (x : T) :=
  within (fun y => y <> x) (locally x).

Global Instance locally'_filter :
  forall {T : UniformSpace} (x : T), Filter (locally' x).

Section at_point.

Context {T : UniformSpace}.

Definition at_point (a : T) (P : T -> Prop) : Prop := P a.

Global Instance at_point_filter (a : T) :
  ProperFilter (at_point a).

End at_point.

Section Open.

Context {T : UniformSpace}.

Definition open (D : T -> Prop) :=
  forall x, D x -> locally x D.

Lemma locally_open :
  forall (D E : T -> Prop),
  open D ->
  (forall x : T, D x -> E x) ->
  forall x : T, D x ->
  locally x E.

Lemma open_ext :
  forall D E : T -> Prop,
  (forall x, D x <-> E x) ->
  open D -> open E.

Lemma open_and :
  forall D E : T -> Prop,
  open D -> open E ->
  open (fun x => D x /\ E x).

Lemma open_or :
  forall D E : T -> Prop,
  open D -> open E ->
  open (fun x => D x \/ E x).

Lemma open_true :
  open (fun x : T => True).

Lemma open_false :
  open (fun x : T => False).

End Open.

Lemma open_comp :
  forall {T U : UniformSpace} (f : T -> U) (D : U -> Prop),
  (forall x, D (f x) -> filterlim f (locally x) (locally (f x))) ->
  open D -> open (fun x : T => D (f x)).

Section Closed.

Context {T : UniformSpace}.

Definition closed (D : T -> Prop) :=
  forall x, not (locally x (fun x : T => not (D x))) -> D x.

Lemma open_not :
  forall D : T -> Prop,
  closed D -> open (fun x => not (D x)).

Lemma closed_not :
  forall D : T -> Prop,
  open D -> closed (fun x => not (D x)).

Lemma closed_ext :
  forall D E : T -> Prop,
  (forall x, D x <-> E x) ->
  closed D -> closed E.

Lemma closed_and :
  forall D E : T -> Prop,
  closed D -> closed E ->
  closed (fun x => D x /\ E x).

Lemma closed_true :
  closed (fun x : T => True).

Lemma closed_false :
  closed (fun x : T => False).

End Closed.

Lemma closed_comp :
  forall {T U : UniformSpace} (f : T -> U) (D : U -> Prop),
  (forall x, filterlim f (locally x) (locally (f x))) ->
  closed D -> closed (fun x : T => D (f x)).

Lemma closed_filterlim_loc :
  forall {T} {U : UniformSpace} {F} {FF : ProperFilter' F} (f : T -> U) (D : U -> Prop),
  forall y, filterlim f F (locally y) ->
  F (fun x => D (f x)) ->
  closed D -> D y.

Lemma closed_filterlim :
  forall {T} {U : UniformSpace} {F} {FF : ProperFilter' F} (f : T -> U) (D : U -> Prop),
  forall y, filterlim f F (locally y) ->
  (forall x, D (f x)) ->
  closed D -> D y.

Definition cauchy {T : UniformSpace} (F : (T -> Prop) -> Prop) :=
  forall eps : posreal, exists x, F (ball x eps).

Module CompleteSpace.

Record mixin_of (T : UniformSpace) := Mixin {
  lim : ((T -> Prop) -> Prop) -> T ;
  ax1 : forall F, ProperFilter F -> cauchy F -> forall eps : posreal, F (ball (lim F) eps) ;
  ax2 : forall F1 F2, filter_le F1 F2 -> filter_le F2 F1 -> close (lim F1) (lim F2)
}.

Section ClassDef.

Record class_of (T : Type) := Class {
  base : UniformSpace.class_of T ;
  mixin : mixin_of (UniformSpace.Pack _ base T)
}.
Local Coercion base : class_of >-> UniformSpace.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition UniformSpace := UniformSpace.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> UniformSpace.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Notation CompleteSpace := type.

End Exports.

End CompleteSpace.

Export CompleteSpace.Exports.

Section CompleteSpace1.

Context {T : CompleteSpace}.

Definition lim : ((T -> Prop) -> Prop) -> T := CompleteSpace.lim _ (CompleteSpace.class T).

Lemma complete_cauchy :
  forall F : (T -> Prop) -> Prop,
  ProperFilter F -> cauchy F ->
  forall eps : posreal,
  F (ball (lim F) eps).

Lemma close_lim :
  forall F1 F2 : (T -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  close (lim F1) (lim F2).

Definition iota (P : T -> Prop) := lim (fun A => (forall x, P x -> A x)).

Lemma iota_correct_weak :
  forall P : T -> Prop,
  (forall x y, P x -> P y -> close x y) ->
  forall x, P x -> close (iota P) x.

Lemma close_iota :
  forall P Q : T -> Prop,
  (forall x, P x <-> Q x) ->
  close (iota P) (iota Q).

End CompleteSpace1.

Lemma cauchy_distance :
  forall {T : UniformSpace} {F} {FF : ProperFilter F},
  (forall eps : posreal, exists x, F (ball x eps)) <->
  (forall eps : posreal, exists P, F P /\ forall u v : T, P u -> P v -> ball u eps v).

Section fct_CompleteSpace.

Context {T : Type} {U : CompleteSpace}.

Lemma filterlim_locally_cauchy :
  forall {F} {FF : ProperFilter F} (f : T -> U),
  (forall eps : posreal, exists P, F P /\ forall u v : T, P u -> P v -> ball (f u) eps (f v)) <->
  exists y, filterlim f F (locally y).

Lemma filterlimi_locally_cauchy :
  forall {F} {FF : ProperFilter F} (f : T -> U -> Prop),
  F (fun x => (exists y, f x y) /\
    (forall y1 y2, f x y1 -> f x y2 -> y1 = y2)) ->
  ((forall eps : posreal, exists P, F P /\
   forall u v : T, P u -> P v -> forall u' v': U, f u u' -> f v v' -> ball u' eps v') <->
  exists y, filterlimi f F (locally y)).

Definition lim_fct (F : ((T -> U) -> Prop) -> Prop) (t : T) :=
  lim (fun P => F (fun g => P (g t))).

Lemma complete_cauchy_fct :
  forall (F : ((T -> U) -> Prop) -> Prop),
  ProperFilter F ->
  (forall eps : posreal, exists f : T -> U, F (ball f eps)) ->
  forall eps : posreal, F (ball (lim_fct F) eps).

Lemma close_lim_fct :
  forall F1 F2 : ((T -> U) -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  close (lim_fct F1) (lim_fct F2).

Definition fct_CompleteSpace_mixin :=
  CompleteSpace.Mixin _ lim_fct complete_cauchy_fct close_lim_fct.

Canonical fct_CompleteSpace :=
  CompleteSpace.Pack (T -> U) (CompleteSpace.Class _ _ fct_CompleteSpace_mixin) (T -> U).

End fct_CompleteSpace.

Section Filterlim_switch.

Context {T1 T2 : Type}.

Lemma filterlim_switch_1 {U : UniformSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : Filter F2) (f : T1 -> T2 -> U) g h (l : U) :
  filterlim f F1 (locally g) ->
  (forall x, filterlim (f x) F2 (locally (h x))) ->
  filterlim h F1 (locally l) -> filterlim g F2 (locally l).

Lemma filterlim_switch_2 {U : CompleteSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : ProperFilter F2) (f : T1 -> T2 -> U) g h :
  filterlim f F1 (locally g) ->
  (forall x, filterlim (f x) F2 (locally (h x))) ->
  exists l : U, filterlim h F1 (locally l).

Lemma filterlim_switch {U : CompleteSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : ProperFilter F2) (f : T1 -> T2 -> U) g h :
  filterlim f F1 (locally g) ->
  (forall x, filterlim (f x) F2 (locally (h x))) ->
  exists l : U, filterlim h F1 (locally l) /\ filterlim g F2 (locally l).

End Filterlim_switch.

Lemma filterlim_switch_dom {T1 T2 : Type} {U : CompleteSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : Filter F2)
  (dom : T2 -> Prop) (HF2 : forall P, F2 P -> exists x, dom x /\ P x)
  (f : T1 -> T2 -> U) g h :
  filterlim (fun x (y : {z : T2 | dom z}) => f x (proj1_sig y)) F1 (locally (T := fct_UniformSpace _ _) (fun y : {z : T2 | dom z} => g (proj1_sig y))) ->
  (forall x, filterlim (f x) (within dom F2) (locally (h x))) ->
  exists l : U, filterlim h F1 (locally l) /\ filterlim g (within dom F2) (locally l).

Module ModuleSpace.

Record mixin_of (K : Ring) (V : AbelianGroup) := Mixin {
  scal : K -> V -> V ;
  ax1 : forall x y u, scal x (scal y u) = scal (mult x y) u ;
  ax2 : forall u, scal one u = u ;
  ax3 : forall x u v, scal x (plus u v) = plus (scal x u) (scal x v) ;
  ax4 : forall x y u, scal (plus x y) u = plus (scal x u) (scal y u)
}.

Section ClassDef.

Variable K : Ring.

Record class_of (V : Type) := Class {
  base : AbelianGroup.class_of V ;
  mixin : mixin_of K (AbelianGroup.Pack _ base V)
}.
Local Coercion base : class_of >-> AbelianGroup.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> AbelianGroup.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Notation ModuleSpace := type.

End Exports.

End ModuleSpace.

Export ModuleSpace.Exports.

Section ModuleSpace1.

Context {K : Ring} {V : ModuleSpace K}.

Definition scal : K -> V -> V := ModuleSpace.scal _ _ (ModuleSpace.class K V).

Lemma scal_assoc :
  forall (x y : K) (u : V),
  scal x (scal y u) = scal (mult x y) u.

Lemma scal_one :
  forall (u : V), scal one u = u.

Lemma scal_distr_l :
  forall (x : K) (u v : V),
  scal x (plus u v) = plus (scal x u) (scal x v).

Lemma scal_distr_r :
  forall (x y : K) (u : V),
  scal (plus x y) u = plus (scal x u) (scal y u).

Lemma scal_zero_r :
  forall x : K,
  scal x zero = zero.

Lemma scal_zero_l :
  forall u : V,
  scal zero u = zero.

Lemma scal_opp_l :
  forall (x : K) (u : V),
  scal (opp x) u = opp (scal x u).

Lemma scal_opp_r :
  forall (x : K) (u : V),
  scal x (opp u) = opp (scal x u).

Lemma scal_opp_one :
  forall u : V,
  scal (opp one) u = opp u.

Lemma scal_minus_distr_l (x : K) (u v : V) :
   scal x (minus u v) = minus (scal x u) (scal x v).
Lemma scal_minus_distr_r (x y : K) (u : V) :
   scal (minus x y) u = minus (scal x u) (scal y u).

Lemma sum_n_m_scal_l :
  forall (a : K) (u : nat -> V) (n m : nat),
  sum_n_m (fun k => scal a (u k)) n m = scal a (sum_n_m u n m).

Lemma sum_n_scal_l :
  forall (a : K) (u : nat -> V) (n : nat),
  sum_n (fun k => scal a (u k)) n = scal a (sum_n u n).

End ModuleSpace1.

Section Ring_ModuleSpace.

Variable (K : Ring).

Definition Ring_ModuleSpace_mixin :=
  ModuleSpace.Mixin K _ _ mult_assoc mult_one_l mult_distr_l mult_distr_r.

Canonical Ring_ModuleSpace :=
  ModuleSpace.Pack K K (ModuleSpace.Class _ _ _ Ring_ModuleSpace_mixin) K.

End Ring_ModuleSpace.

Section AbsRing_ModuleSpace.

Variable (K : AbsRing).

Definition AbsRing_ModuleSpace_mixin :=
  ModuleSpace.Mixin K _ _ mult_assoc mult_one_l mult_distr_l mult_distr_r.

Canonical AbsRing_ModuleSpace :=
  ModuleSpace.Pack K K (ModuleSpace.Class _ _ _ AbsRing_ModuleSpace_mixin) K.

End AbsRing_ModuleSpace.

Module NormedModuleAux.

Section ClassDef.

Variable K : AbsRing.

Record class_of (T : Type) := Class {
  base : ModuleSpace.class_of K T ;
  mixin : UniformSpace.mixin_of T
}.
Local Coercion base : class_of >-> ModuleSpace.class_of.
Local Coercion mixin : class_of >-> UniformSpace.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition ModuleSpace := ModuleSpace.Pack _ cT xclass xT.
Definition UniformSpace := UniformSpace.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> ModuleSpace.class_of.
Coercion mixin : class_of >-> UniformSpace.class_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion ModuleSpace : type >-> ModuleSpace.type.
Canonical ModuleSpace.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Notation NormedModuleAux := type.

End Exports.

End NormedModuleAux.

Export NormedModuleAux.Exports.

Module NormedModule.

Record mixin_of (K : AbsRing) (V : NormedModuleAux K) := Mixin {
  norm : V -> R ;
  norm_factor : R ;
  ax1 : forall (x y : V), norm (plus x y) <= norm x + norm y ;
  ax2 : forall (l : K) (x : V), norm (scal l x) <= abs l * norm x ;
  ax3 : forall (x y : V) (eps : R), norm (minus y x) < eps -> ball x eps y ;
  ax4 : forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ;
  ax5 : forall x : V, norm x = 0 -> x = zero
}.

Section ClassDef.

Variable K : AbsRing.

Record class_of (T : Type) := Class {
  base : NormedModuleAux.class_of K T ;
  mixin : mixin_of K (NormedModuleAux.Pack K T base T)
}.
Local Coercion base : class_of >-> NormedModuleAux.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition ModuleSpace := ModuleSpace.Pack _ cT xclass xT.
Definition UniformSpace := UniformSpace.Pack cT xclass xT.
Definition NormedModuleAux := NormedModuleAux.Pack _ cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> NormedModuleAux.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion ModuleSpace : type >-> ModuleSpace.type.
Canonical ModuleSpace.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Coercion NormedModuleAux : type >-> NormedModuleAux.type.
Canonical NormedModuleAux.
Notation NormedModule := type.

End Exports.

End NormedModule.

Export NormedModule.Exports.

Section NormedModule1.

Context {K : AbsRing} {V : NormedModule K}.

Definition norm : V -> R := NormedModule.norm K _ (NormedModule.class K V).

Definition norm_factor : R := NormedModule.norm_factor K _ (NormedModule.class K V).

Lemma norm_triangle :
  forall x y : V,
  norm (plus x y) <= norm x + norm y.

Lemma norm_scal :
  forall (l : K) (x : V),
  norm (scal l x) <= abs l * norm x.

Lemma norm_compat1 :
  forall (x y : V) (eps : R),
  norm (minus y x) < eps -> ball x eps y.

Lemma norm_compat2 :
  forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps.

Lemma norm_eq_zero :
  forall x : V, norm x = 0 -> x = zero.

Lemma norm_zero :
  norm zero = 0.

Lemma norm_factor_gt_0 :
  0 < norm_factor.

Lemma norm_opp :
  forall x : V,
  norm (opp x) = norm x.

Lemma norm_ge_0 :
  forall x : V,
  0 <= norm x.

Lemma norm_triangle_inv :
  forall x y : V,
  Rabs (norm x - norm y) <= norm (minus x y).

Lemma eq_close :
  forall x y : V,
  close x y -> x = y.

Definition ball_norm (x : V) (eps : R) (y : V) := norm (minus y x) < eps.

Definition locally_norm (x : V) (P : V -> Prop) :=
  exists eps : posreal, forall y, ball_norm x eps y -> P y.

Lemma locally_le_locally_norm :
  forall x, filter_le (locally x) (locally_norm x).

Lemma locally_norm_le_locally :
  forall x, filter_le (locally_norm x) (locally x).

Lemma locally_norm_ball_norm :
  forall (x : V) (eps : posreal),
  locally_norm x (ball_norm x eps).

Lemma locally_norm_ball :
  forall (x : V) (eps : posreal),
  locally_norm x (ball x eps).

Lemma locally_ball_norm :
  forall (x : V) (eps : posreal),
  locally x (ball_norm x eps).

Lemma ball_norm_triangle (x y z : V) (e1 e2 : R) :
  ball_norm x e1 y -> ball_norm y e2 z -> ball_norm x (e1 + e2) z.

Lemma ball_norm_center (x : V) (e : posreal) :
  ball_norm x e x.

Lemma ball_norm_dec : forall (x y : V) (eps : posreal),
  {ball_norm x eps y} + {~ ball_norm x eps y}.

Lemma ball_norm_sym :
  forall (x y : V) (eps : posreal), ball_norm x eps y -> ball_norm y eps x.

Lemma ball_norm_le :
  forall (x : V) (e1 e2 : posreal), e1 <= e2 ->
  forall y, ball_norm x e1 y -> ball_norm x e2 y.

Lemma ball_norm_eq :
  forall x y : V,
  (forall eps : posreal, ball_norm x eps y) -> x = y.

Lemma is_filter_lim_unique :
  forall {F} {FF : ProperFilter' F} (x y : V),
  is_filter_lim F x -> is_filter_lim F y -> x = y.

Lemma is_filter_lim_locally_unique :
  forall (x y : V),
  is_filter_lim (locally x) y -> x = y.

End NormedModule1.

Section NormedModule2.

Context {T : Type} {K : AbsRing} {V : NormedModule K}.

Lemma filterlim_locally_unique :
  forall {F} {FF : ProperFilter' F} (f : T -> V) (x y : V),
  filterlim f F (locally x) -> filterlim f F (locally y) ->
  x = y.

Lemma filterlimi_locally_unique :
  forall {F} {FF : ProperFilter' F} (f : T -> V -> Prop) (x y : V),
  F (fun x => forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  filterlimi f F (locally x) -> filterlimi f F (locally y) ->
  x = y.

End NormedModule2.

Section AbsRing_NormedModule.

Variable (K : AbsRing).

Canonical AbsRing_NormedModuleAux :=
  NormedModuleAux.Pack K K (NormedModuleAux.Class _ _ (ModuleSpace.class _ (AbsRing_ModuleSpace K)) (UniformSpace.class (AbsRing_UniformSpace K))) K.

Lemma AbsRing_norm_compat2 :
  forall (x y : AbsRing_NormedModuleAux) (eps : posreal),
  ball x eps y -> abs (minus y x) < 1 * eps.

Definition AbsRing_NormedModule_mixin :=
  NormedModule.Mixin K _ abs 1 abs_triangle abs_mult (fun x y e H => H) AbsRing_norm_compat2 abs_eq_zero.

Canonical AbsRing_NormedModule :=
  NormedModule.Pack K _ (NormedModule.Class _ _ _ AbsRing_NormedModule_mixin) K.

End AbsRing_NormedModule.

Section NVS_continuity.

Context {K : AbsRing} {V : NormedModule K}.

Lemma filterlim_plus :
  forall x y : V,
  filterlim (fun z : V * V => plus (fst z) (snd z)) (filter_prod (locally x) (locally y)) (locally (plus x y)).

Lemma filterlim_scal (k : K) (x : V) :
  filterlim (fun z => scal (fst z) (snd z)) (filter_prod (locally k) (locally x)) (locally (scal k x)).
Lemma filterlim_scal_r (k : K) (x : V) :
  filterlim (fun z : V => scal k z) (locally x) (locally (scal k x)).
Lemma filterlim_scal_l (k : K) (x : V) :
  filterlim (fun z => scal z x) (locally k) (locally (scal k x)).

Lemma filterlim_opp :
  forall x : V,
  filterlim opp (locally x) (locally (opp x)).

End NVS_continuity.

Lemma filterlim_mult {K : AbsRing} (x y : K) :
  filterlim (fun z => mult (fst z) (snd z)) (filter_prod (locally x) (locally y)) (locally (mult x y)).

Lemma filterlim_locally_ball_norm :
  forall {K : AbsRing} {T} {U : NormedModule K} {F : (T -> Prop) -> Prop} {FF : Filter F} (f : T -> U) (y : U),
  filterlim f F (locally y) <-> forall eps : posreal, F (fun x => ball_norm y eps (f x)).

Module CompleteNormedModule.

Section ClassDef.

Variable K : AbsRing.

Record class_of (T : Type) := Class {
  base : NormedModule.class_of K T ;
  mixin : CompleteSpace.mixin_of (UniformSpace.Pack T base T)
}.
Local Coercion base : class_of >-> NormedModule.class_of.
Definition base2 T (cT : class_of T) : CompleteSpace.class_of T :=
  CompleteSpace.Class _ (base T cT) (mixin T cT).
Local Coercion base2 : class_of >-> CompleteSpace.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition ModuleSpace := ModuleSpace.Pack _ cT xclass xT.
Definition NormedModuleAux := NormedModuleAux.Pack _ cT xclass xT.
Definition NormedModule := NormedModule.Pack _ cT xclass xT.
Definition UniformSpace := UniformSpace.Pack cT xclass xT.
Definition CompleteSpace := CompleteSpace.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> NormedModule.class_of.
Coercion mixin : class_of >-> CompleteSpace.mixin_of.
Coercion base2 : class_of >-> CompleteSpace.class_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion ModuleSpace : type >-> ModuleSpace.type.
Canonical ModuleSpace.
Coercion NormedModuleAux : type >-> NormedModuleAux.type.
Canonical NormedModuleAux.
Coercion NormedModule : type >-> NormedModule.type.
Canonical NormedModule.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Coercion CompleteSpace : type >-> CompleteSpace.type.
Canonical CompleteSpace.
Notation CompleteNormedModule := type.

End Exports.

End CompleteNormedModule.

Export CompleteNormedModule.Exports.

Section CompleteNormedModule1.

Context {K : AbsRing} {V : CompleteNormedModule K}.

Lemma iota_unique :
  forall (P : V -> Prop) (x : V),
  (forall y, P y -> y = x) ->
  P x ->
  iota P = x.

Lemma iota_correct :
  forall P : V -> Prop,
  (exists! x : V, P x) ->
  P (iota P).

Lemma iota_is_filter_lim {F} {FF : ProperFilter' F} (l : V) :
  is_filter_lim F l ->
  iota (is_filter_lim F) = l.

Context {T : Type}.

Lemma iota_filterlim_locally {F} {FF : ProperFilter' F} (f : T -> V) l :
  filterlim f F (locally l) ->
  iota (fun x => filterlim f F (locally x)) = l.

Lemma iota_filterlimi_locally {F} {FF : ProperFilter' F} (f : T -> V -> Prop) l :
  F (fun x => forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  filterlimi f F (locally l) ->
  iota (fun x => filterlimi f F (locally x)) = l.

End CompleteNormedModule1.

Section prod_AbelianGroup.

Context {U V : AbelianGroup}.

Definition prod_plus (x y : U * V) :=
  (plus (fst x) (fst y), plus (snd x) (snd y)).

Definition prod_opp (x : U * V) :=
  (opp (fst x), opp (snd x)).

Definition prod_zero : U * V := (zero, zero).

Lemma prod_plus_comm :
  forall x y : U * V,
  prod_plus x y = prod_plus y x.

Lemma prod_plus_assoc :
  forall x y z : U * V,
  prod_plus x (prod_plus y z) = prod_plus (prod_plus x y) z.

Lemma prod_plus_zero_r :
  forall x : U * V,
  prod_plus x prod_zero = x.

Lemma prod_plus_opp_r :
  forall x : U * V,
  prod_plus x (prod_opp x) = prod_zero.

End prod_AbelianGroup.

Definition prod_AbelianGroup_mixin (U V : AbelianGroup) :=
  AbelianGroup.Mixin (U * V) _ _ _ prod_plus_comm prod_plus_assoc prod_plus_zero_r prod_plus_opp_r.

Canonical prod_AbelianGroup (U V : AbelianGroup) :=
  AbelianGroup.Pack (U * V) (prod_AbelianGroup_mixin U V) (U * V).

Section prod_UniformSpace.

Context {U V : UniformSpace}.

Definition prod_ball (x : U * V) (eps : R) (y : U * V) :=
  ball (fst x) eps (fst y) /\ ball (snd x) eps (snd y).

Lemma prod_ball_center :
  forall (x : U * V) (eps : posreal),
  prod_ball x eps x.

Lemma prod_ball_sym :
  forall (x y : U * V) (eps : R),
  prod_ball x eps y -> prod_ball y eps x.

Lemma prod_ball_triangle :
  forall (x y z : U * V) (e1 e2 : R),
  prod_ball x e1 y -> prod_ball y e2 z ->
  prod_ball x (e1 + e2) z.

End prod_UniformSpace.

Definition prod_UniformSpace_mixin (U V : UniformSpace) :=
  UniformSpace.Mixin (U * V) _ prod_ball_center prod_ball_sym prod_ball_triangle.

Canonical prod_UniformSpace (U V : UniformSpace) :=
  UniformSpace.Pack (U * V) (prod_UniformSpace_mixin U V) (U * V).

Section prod_ModuleSpace.

Context {K : Ring} {U V : ModuleSpace K}.

Definition prod_scal (x : K) (u : U * V) :=
  (scal x (fst u), scal x (snd u)).

Lemma prod_scal_assoc :
  forall (x y : K) (u : U * V),
  prod_scal x (prod_scal y u) = prod_scal (mult x y) u.

Lemma prod_scal_one :
  forall u : U * V,
  prod_scal one u = u.

Lemma prod_scal_distr_l :
  forall (x : K) (u v : U * V),
  prod_scal x (prod_plus u v) = prod_plus (prod_scal x u) (prod_scal x v).

Lemma prod_scal_distr_r :
  forall (x y : K) (u : U * V),
  prod_scal (plus x y) u = prod_plus (prod_scal x u) (prod_scal y u).

End prod_ModuleSpace.

Definition prod_ModuleSpace_mixin (K : Ring) (U V : ModuleSpace K) :=
  ModuleSpace.Mixin K _ _ (@prod_scal_assoc K U V) prod_scal_one prod_scal_distr_l prod_scal_distr_r.

Canonical prod_ModuleSpace (K : Ring) (U V : ModuleSpace K) :=
  ModuleSpace.Pack K (U * V) (ModuleSpace.Class _ _ _ (prod_ModuleSpace_mixin K U V)) (U * V).

Canonical prod_NormedModuleAux (K : AbsRing) (U V : NormedModuleAux K) :=
  NormedModuleAux.Pack K (U * V) (NormedModuleAux.Class _ _ (ModuleSpace.class K _) (UniformSpace.class (prod_UniformSpace U V))) (U * V).

Lemma sqrt_plus_sqr :
  forall x y : R, Rmax (Rabs x) (Rabs y) <= sqrt (x ^ 2 + y ^ 2) <= sqrt 2 * Rmax (Rabs x) (Rabs y).

Section prod_NormedModule.

Context {K : AbsRing} {U V : NormedModule K}.

Definition prod_norm (x : U * V) :=
  sqrt (norm (fst x) ^ 2 + norm (snd x) ^ 2).

Lemma prod_norm_triangle :
  forall x y : U * V,
  prod_norm (plus x y) <= prod_norm x + prod_norm y.

Lemma prod_norm_scal :
  forall (l : K) (x : U * V),
  prod_norm (scal l x) <= abs l * prod_norm x.

Lemma prod_norm_compat1 :
  forall (x y : U * V) (eps : R),
  prod_norm (minus y x) < eps -> ball x eps y.

Definition prod_norm_factor :=
  sqrt 2 * Rmax (@norm_factor K U) (@norm_factor K V).

Lemma prod_norm_compat2 :
  forall (x y : U * V) (eps : posreal),
  ball x eps y ->
  prod_norm (minus y x) < prod_norm_factor * eps.

Lemma prod_norm_eq_zero :
  forall x : U * V,
  prod_norm x = 0 -> x = zero.

End prod_NormedModule.

Definition prod_NormedModule_mixin (K : AbsRing) (U V : NormedModule K) :=
  NormedModule.Mixin K _ (@prod_norm K U V) prod_norm_factor prod_norm_triangle
  prod_norm_scal prod_norm_compat1 prod_norm_compat2 prod_norm_eq_zero.

Canonical prod_NormedModule (K : AbsRing) (U V : NormedModule K) :=
  NormedModule.Pack K (U * V) (NormedModule.Class K (U * V) _ (prod_NormedModule_mixin K U V)) (U * V).

Lemma norm_prod {K : AbsRing}
  {U : NormedModule K} {V : NormedModule K}
  (x : U) (y : V) :
  Rmax (norm x) (norm y) <= norm (x,y) <= sqrt 2 * Rmax (norm x) (norm y).

Fixpoint Tn (n : nat) (T : Type) : Type :=
  match n with
  | O => unit
  | S n => prod T (Tn n T)
  end.

Notation "[ x1 , .. , xn ]" := (pair x1 .. (pair xn tt) .. ).

Fixpoint mk_Tn {T} (n : nat) (u : nat -> T) : Tn n T :=
  match n with
    | O => (tt : Tn O T)
    | S n => (u O, mk_Tn n (fun n => u (S n)))
  end.
Fixpoint coeff_Tn {T} {n : nat} (x0 : T) : (Tn n T) -> nat -> T :=
  match n with
  | O => fun (_ : Tn O T) (_ : nat) => x0
  | S n' => fun (v : Tn (S n') T) (i : nat) => match i with
           | O => fst v
           | S i => coeff_Tn x0 (snd v) i
           end
  end.
Lemma mk_Tn_bij {T} {n : nat} (x0 : T) (v : Tn n T) :
  mk_Tn n (coeff_Tn x0 v) = v.
Lemma coeff_Tn_bij {T} {n : nat} (x0 : T) (u : nat -> T) :
  forall i, (i < n)%nat -> coeff_Tn x0 (mk_Tn n u) i = u i.
Lemma coeff_Tn_ext {T} {n : nat} (x1 x2 : T) (v1 v2 : Tn n T) :
  v1 = v2 <-> forall i, (i < n)%nat -> coeff_Tn x1 v1 i = coeff_Tn x2 v2 i.
Lemma mk_Tn_ext {T} (n : nat) (u1 u2 : nat -> T) :
  (forall i, (i < n)%nat -> (u1 i) = (u2 i))
    <-> (mk_Tn n u1) = (mk_Tn n u2).

Fixpoint Fn (n : nat) (T U : Type) : Type :=
  match n with
  | O => U
  | S n => T -> Fn n T U
  end.

Section Matrices.

Context {T : Type}.

Definition matrix (m n : nat) := Tn m (Tn n T).

Definition coeff_mat {m n : nat} (x0 : T) (A : matrix m n) (i j : nat) :=
  coeff_Tn x0 (coeff_Tn (mk_Tn _ (fun _ => x0)) A i) j.

Definition mk_matrix (m n : nat) (U : nat -> nat -> T) : matrix m n :=
  mk_Tn m (fun i => (mk_Tn n (U i))).

Lemma mk_matrix_bij {m n : nat} (x0 : T) (A : matrix m n) :
  mk_matrix m n (coeff_mat x0 A) = A.

Lemma coeff_mat_bij {m n : nat} (x0 : T) (u : nat -> nat -> T) :
  forall i j, (i < m)%nat -> (j < n)%nat -> coeff_mat x0 (mk_matrix m n u) i j = u i j.

Lemma coeff_mat_ext_aux {m n : nat} (x1 x2 : T) (v1 v2 : matrix m n) :
  v1 = v2 <-> forall i j, (i < m)%nat -> (j < n)%nat -> (coeff_mat x1 v1 i j) = (coeff_mat x2 v2 i j).

Lemma coeff_mat_ext {m n : nat} (x0 : T) (v1 v2 : matrix m n) :
  v1 = v2 <-> forall i j, (coeff_mat x0 v1 i j) = (coeff_mat x0 v2 i j).

Lemma mk_matrix_ext (m n : nat) (u1 u2 : nat -> nat -> T) :
  (forall i j, (i < m)%nat -> (j < n)%nat -> (u1 i j) = (u2 i j))
    <-> (mk_matrix m n u1) = (mk_matrix m n u2).

End Matrices.

Section MatrixGroup.

Context {G : AbelianGroup} {m n : nat}.

Definition Mzero := mk_matrix m n (fun i j => @zero G).

Definition Mplus (A B : @matrix G m n) :=
  mk_matrix m n (fun i j => plus (coeff_mat zero A i j) (coeff_mat zero B i j)).

Definition Mopp (A : @matrix G m n) :=
  mk_matrix m n (fun i j => opp (coeff_mat zero A i j)).

Lemma Mplus_comm :
  forall A B : @matrix G m n,
  Mplus A B = Mplus B A.

Lemma Mplus_assoc :
  forall A B C : @matrix G m n,
  Mplus A (Mplus B C) = Mplus (Mplus A B) C.

Lemma Mplus_zero_r :
  forall A : @matrix G m n,
  Mplus A Mzero = A.

Lemma Mplus_opp_r :
  forall A : @matrix G m n,
  Mplus A (Mopp A) = Mzero.

Definition matrix_AbelianGroup_mixin :=
  AbelianGroup.Mixin _ _ _ _ Mplus_comm Mplus_assoc Mplus_zero_r Mplus_opp_r.

Canonical matrix_AbelianGroup :=
  AbelianGroup.Pack _ matrix_AbelianGroup_mixin (@matrix G m n).

End MatrixGroup.

Section MatrixRing.

Context {T : Ring}.

Fixpoint Mone_seq i j : T :=
  match i,j with
    | O, O => one
    | O, S _ | S _, O => zero
    | S i, S j => Mone_seq i j end.

Definition Mone {n} : matrix n n :=
  mk_matrix n n Mone_seq.

Lemma Mone_seq_diag :
  forall i j : nat, i = j -> Mone_seq i j = @one T.
Lemma Mone_seq_not_diag :
  forall i j : nat, i <> j -> Mone_seq i j = @zero T.

Definition Mmult {n m k} (A : @matrix T n m) (B : @matrix T m k) :=
  mk_matrix n k (fun i j => sum_n (fun l => mult (coeff_mat zero A i l) (coeff_mat zero B l j)) (pred m)).

Lemma Mmult_assoc {n m k l} :
  forall (A : matrix n m) (B : matrix m k) (C : matrix k l),
  Mmult A (Mmult B C) = Mmult (Mmult A B) C.

Lemma Mmult_one_r {m n} :
  forall x : matrix m n, Mmult x Mone = x.

Lemma Mmult_one_l {m n} :
  forall x : matrix m n, Mmult Mone x = x.

Lemma Mmult_distr_r {m n k} :
  forall (A B : @matrix T m n) (C : @matrix T n k),
  Mmult (Mplus A B) C = Mplus (Mmult A C) (Mmult B C).

Lemma Mmult_distr_l {m n k} :
  forall (A : @matrix T m n) (B C : @matrix T n k),
  Mmult A (Mplus B C) = Mplus (Mmult A B) (Mmult A C).

Definition matrix_Ring_mixin {n} :=
  Ring.Mixin _ _ _ (@Mmult_assoc n n n n) Mmult_one_r Mmult_one_l Mmult_distr_r Mmult_distr_l.

Canonical matrix_Ring {n} :=
  Ring.Pack (@matrix T n n) (Ring.Class _ _ matrix_Ring_mixin) (@matrix T n n).

Definition matrix_ModuleSpace_mixin {m n} :=
  ModuleSpace.Mixin (@matrix_Ring m) (@matrix_AbelianGroup T m n) Mmult
    Mmult_assoc Mmult_one_l Mmult_distr_l Mmult_distr_r.

Canonical matrix_ModuleSpace {m n} :=
  ModuleSpace.Pack _ (@matrix T m n) (ModuleSpace.Class _ _ _ matrix_ModuleSpace_mixin) (@matrix T m n).

End MatrixRing.

Definition eventually (P : nat -> Prop) :=
  exists N : nat, forall n, (N <= n)%nat -> P n.

Global Instance eventually_filter : ProperFilter eventually.

Definition R_AbelianGroup_mixin :=
  AbelianGroup.Mixin _ _ _ _ Rplus_comm (fun x y z => sym_eq (Rplus_assoc x y z)) Rplus_0_r Rplus_opp_r.

Canonical R_AbelianGroup :=
  AbelianGroup.Pack _ R_AbelianGroup_mixin R.

Definition R_Ring_mixin :=
  Ring.Mixin _ _ _ (fun x y z => sym_eq (Rmult_assoc x y z)) Rmult_1_r Rmult_1_l Rmult_plus_distr_r Rmult_plus_distr_l.

Canonical R_Ring :=
  Ring.Pack R (Ring.Class _ _ R_Ring_mixin) R.

Lemma Rabs_m1 :
  Rabs (-1) = 1.

Definition R_AbsRing_mixin :=
  AbsRing.Mixin _ _ Rabs_R0 Rabs_m1 Rabs_triang (fun x y => Req_le _ _ (Rabs_mult x y)) Rabs_eq_0.

Canonical R_AbsRing :=
  AbsRing.Pack R (AbsRing.Class _ _ R_AbsRing_mixin) R.

Definition R_UniformSpace_mixin :=
  AbsRing_UniformSpace_mixin R_AbsRing.

Canonical R_UniformSpace :=
  UniformSpace.Pack R R_UniformSpace_mixin R.

Definition R_complete_lim (F : (R -> Prop) -> Prop) : R :=
  Lub_Rbar (fun x : R => F (ball (x + 1) (mkposreal _ Rlt_0_1))).

Lemma R_complete_ax1 :
  forall F : (R -> Prop) -> Prop,
  ProperFilter' F ->
  (forall eps : posreal, exists x : R, F (ball x eps)) ->
  forall eps : posreal, F (ball (R_complete_lim F) eps).

Lemma R_complete :
  forall F : (R -> Prop) -> Prop,
  ProperFilter F ->
  (forall eps : posreal, exists x : R, F (ball x eps)) ->
  forall eps : posreal, F (ball (R_complete_lim F) eps).

Lemma R_complete_ax2 :
  forall F1 F2 : (R -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  R_complete_lim F1 = R_complete_lim F2.

Lemma R_complete_close :
  forall F1 F2 : (R -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  close (R_complete_lim F1) (R_complete_lim F2).

Definition R_CompleteSpace_mixin :=
  CompleteSpace.Mixin _ R_complete_lim R_complete R_complete_close.

Canonical R_CompleteSpace :=
  CompleteSpace.Pack R (CompleteSpace.Class _ _ R_CompleteSpace_mixin) R.

Definition R_ModuleSpace_mixin :=
  AbsRing_ModuleSpace_mixin R_AbsRing.

Canonical R_ModuleSpace :=
  ModuleSpace.Pack _ R (ModuleSpace.Class _ _ _ R_ModuleSpace_mixin) R.

Canonical R_NormedModuleAux :=
  NormedModuleAux.Pack _ R (NormedModuleAux.Class _ _ (ModuleSpace.class _ R_ModuleSpace) (UniformSpace.class R_UniformSpace)) R.

Definition R_NormedModule_mixin :=
  AbsRing_NormedModule_mixin R_AbsRing.

Canonical R_NormedModule :=
  NormedModule.Pack _ R (NormedModule.Class _ _ _ R_NormedModule_mixin) R.

Canonical R_CompleteNormedModule :=
  CompleteNormedModule.Pack _ R (CompleteNormedModule.Class R_AbsRing _ (NormedModule.class _ R_NormedModule) R_CompleteSpace_mixin) R.

Definition at_left x := within (fun u : R => Rlt u x) (locally x).
Definition at_right x := within (fun u : R => Rlt x u) (locally x).

Global Instance at_right_proper_filter : forall (x : R),
  ProperFilter (at_right x).
Global Instance at_left_proper_filter : forall (x : R),
  ProperFilter (at_left x).

Lemma sum_n_Reals : forall a N, sum_n a N = sum_f_R0 a N.
Lemma sum_n_m_Reals a n m : (n <= m)%nat -> sum_n_m a n m = sum_f n m a.

Lemma sum_n_m_const (n m : nat) (a : R) :
  sum_n_m (fun _ => a) n m = INR (S m - n) * a.
Lemma sum_n_const (n : nat) (a : R) :
  sum_n (fun _ => a) n = INR (S n) * a.

Lemma norm_sum_n_m {K : AbsRing} {V : NormedModule K} (a : nat -> V) (n m : nat) :
  norm (sum_n_m a n m) <= sum_n_m (fun n => norm (a n)) n m.

Lemma sum_n_m_le (a b : nat -> R) (n m : nat) :
  (forall k, a k <= b k)
  -> sum_n_m a n m <= sum_n_m b n m.

Lemma pow_n_pow :
  forall (x : R) k, pow_n x k = x^k.

Lemma filterlim_norm {K : AbsRing} {V : NormedModule K} :
  forall (x : V), filterlim norm (locally x) (locally (norm x)).

Lemma filterlim_norm_zero {U} {K : AbsRing} {V : NormedModule K}
  {F : (U -> Prop) -> Prop} {FF : Filter F} (f : U -> V) :
  filterlim (fun x => norm (f x)) F (locally 0)
  -> filterlim f F (locally (zero (G := V))).

Lemma filterlim_bounded {K : AbsRing} {V : NormedModule K} (a : nat -> V) :
  (exists x, filterlim a eventually (locally x))
 -> {M : R | forall n, norm (a n) <= M}.

Lemma open_lt :
  forall y : R, open (fun u : R => u < y).

Lemma open_gt :
  forall y : R, open (fun u : R => y < u).

Lemma open_neq :
  forall y : R, open (fun u : R => u <> y).

Lemma closed_le :
  forall y : R, closed (fun u : R => u <= y).

Lemma closed_ge :
  forall y : R, closed (fun u : R => y <= u).

Lemma closed_eq :
  forall y : R, closed (fun u : R => u = y).

Lemma locally_interval (P : R -> Prop) (x : R) (a b : Rbar) :
  Rbar_lt a x -> Rbar_lt x b ->
  (forall (y : R), Rbar_lt a y -> Rbar_lt y b -> P y) ->
  locally x P.

Definition locally_2d (P : R -> R -> Prop) x y :=
  exists delta : posreal, forall u v, Rabs (u - x) < delta -> Rabs (v - y) < delta -> P u v.

Lemma locally_2d_locally :
  forall P x y,
  locally_2d P x y <-> locally (x,y) (fun z => P (fst z) (snd z)).

Lemma locally_2d_impl_strong :
  forall (P Q : R -> R -> Prop) x y, locally_2d (fun u v => locally_2d P u v -> Q u v) x y ->
  locally_2d P x y -> locally_2d Q x y.

Lemma locally_2d_singleton :
  forall (P : R -> R -> Prop) x y, locally_2d P x y -> P x y.

Lemma locally_2d_impl :
  forall (P Q : R -> R -> Prop) x y, locally_2d (fun u v => P u v -> Q u v) x y ->
  locally_2d P x y -> locally_2d Q x y.

Lemma locally_2d_forall :
  forall (P : R -> R -> Prop) x y, (forall u v, P u v) -> locally_2d P x y.

Lemma locally_2d_and :
  forall (P Q : R -> R -> Prop) x y, locally_2d P x y -> locally_2d Q x y ->
  locally_2d (fun u v => P u v /\ Q u v) x y.

Lemma locally_2d_align :
  forall (P Q : R -> R -> Prop) x y,
  ( forall eps : posreal, (forall u v, Rabs (u - x) < eps -> Rabs (v - y) < eps -> P u v) ->
    forall u v, Rabs (u - x) < eps -> Rabs (v - y) < eps -> Q u v ) ->
  locally_2d P x y -> locally_2d Q x y.

Lemma locally_2d_1d_const_x :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally y (fun t => P x t).

Lemma locally_2d_1d_const_y :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally x (fun t => P t y).

Lemma locally_2d_1d_strong :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally_2d (fun u v => forall t, 0 <= t <= 1 ->
    locally t (fun z => locally_2d P (x + z * (u - x)) (y + z * (v - y)))) x y.

Lemma locally_2d_1d :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally_2d (fun u v => forall t, 0 <= t <= 1 -> locally_2d P (x + t * (u - x)) (y + t * (v - y))) x y.

Lemma locally_2d_ex_dec :
  forall P x y,
  (forall x y, P x y \/ ~P x y) ->
  locally_2d P x y ->
  {d : posreal | forall u v, Rabs (u-x) < d -> Rabs (v-y) < d -> P u v}.

Definition Rbar_locally' (a : Rbar) (P : R -> Prop) :=
  match a with
    | Finite a => locally' a P
    | p_infty => exists M : R, forall x, M < x -> P x
    | m_infty => exists M : R, forall x, x < M -> P x
  end.
Definition Rbar_locally (a : Rbar) (P : R -> Prop) :=
  match a with
    | Finite a => locally a P
    | p_infty => exists M : R, forall x, M < x -> P x
    | m_infty => exists M : R, forall x, x < M -> P x
  end.

Global Instance Rbar_locally'_filter :
  forall x, ProperFilter (Rbar_locally' x).

Global Instance Rbar_locally_filter :
  forall x, ProperFilter (Rbar_locally x).

Lemma open_Rbar_lt :
  forall y, open (fun u : R => Rbar_lt u y).

Lemma open_Rbar_gt :
  forall y, open (fun u : R => Rbar_lt y u).

Lemma open_Rbar_lt' :
  forall x y, Rbar_lt x y -> Rbar_locally x (fun u => Rbar_lt u y).

Lemma open_Rbar_gt' :
  forall x y, Rbar_lt y x -> Rbar_locally x (fun u => Rbar_lt y u).

Lemma Rbar_locally'_le :
  forall x, filter_le (Rbar_locally' x) (Rbar_locally x).

Lemma Rbar_locally'_le_finite :
  forall x : R, filter_le (Rbar_locally' x) (locally x).

Definition Rbar_loc_seq (x : Rbar) (n : nat) := match x with
    | Finite x => x + / (INR n + 1)
    | p_infty => INR n
    | m_infty => - INR n
  end.

Lemma filterlim_Rbar_loc_seq :
  forall x, filterlim (Rbar_loc_seq x) eventually (Rbar_locally' x).

Lemma continuity_pt_locally :
  forall f x,
  continuity_pt f x <->
  forall eps : posreal, locally x (fun u => Rabs (f u - f x) < eps).

Lemma continuity_pt_locally' :
  forall f x,
  continuity_pt f x <->
  forall eps : posreal, locally' x (fun u => Rabs (f u - f x) < eps).

Lemma continuity_pt_filterlim :
  forall (f : R -> R) (x : R),
  continuity_pt f x <->
  filterlim f (locally x) (locally (f x)).

Lemma continuity_pt_filterlim' :
  forall f x,
  continuity_pt f x <->
  filterlim f (locally' x) (locally (f x)).

Lemma locally_pt_comp (P : R -> Prop) (f : R -> R) (x : R) :
  locally (f x) P -> continuity_pt f x ->
  locally x (fun x => P (f x)). *)



Open Scope R_scope.



Definition is_sup_seq (u : nat -> Rbar) (l : Rbar) :=

  match l with

    | Finite l => forall (eps : posreal), (forall n, Rbar_lt (u n) (l+eps))

                                       /\ (exists n, Rbar_lt (l-eps) (u n))

    | p_infty => forall M : R, exists n, Rbar_lt M (u n)

    | m_infty => forall M : R, forall n, Rbar_lt (u n) M

  end.

Definition is_inf_seq (u : nat -> Rbar) (l : Rbar) :=

  match l with

    | Finite l => forall (eps : posreal), (forall n, Rbar_lt (Finite (l-eps)) (u n))

                                       /\ (exists n, Rbar_lt (u n) (Finite (l+eps)))

    | p_infty => forall M : R, forall n, Rbar_lt (Finite M) (u n)

    | m_infty => forall M : R, exists n, Rbar_lt (u n) (Finite M)

  end.



Lemma is_inf_opp_sup_seq (u : nat -> Rbar) (l : Rbar) :

  is_inf_seq (fun n => Rbar_opp (u n)) (Rbar_opp l)

  <-> is_sup_seq u l.

Proof.

  destruct l as [l | | ] ; split ; intros Hl.



  intro eps ; case (Hl eps) ; clear Hl ; intros lb (n, glb) ; split.

  intro n0 ; apply Rbar_opp_lt ; simpl ; rewrite (Ropp_plus_distr l eps) ; apply lb.

  exists n ; apply Rbar_opp_lt ; assert (Rw : -(l-eps) = -l+eps).

  ring.

  simpl ; rewrite Rw ; clear Rw ; auto.

  intro eps ; case (Hl eps) ; clear Hl ; intros ub (n, lub) ; split.

  intros n0 ; unfold Rminus ; rewrite <-(Ropp_plus_distr l eps) ;

  apply (Rbar_opp_lt (Finite (l+eps)) (u n0)) ; simpl ; apply ub.

  exists n ; assert (Rw : -(l-eps) = -l+eps).

  ring.

  simpl ; rewrite <-Rw ; apply (Rbar_opp_lt (u n) (Finite (l-eps))) ; auto.



  intro M ; case (Hl (-M)) ; clear Hl ; intros n Hl ; exists n ; apply Rbar_opp_lt ; auto.

  intro M ; case (Hl (-M)) ; clear Hl ; intros n Hl ; exists n ; apply Rbar_opp_lt ;

  rewrite Rbar_opp_involutive ; auto.



  intros M n ; apply Rbar_opp_lt, Hl.

  intros M n ; apply Rbar_opp_lt ; rewrite Rbar_opp_involutive ; apply Hl.

Qed.

Lemma is_sup_opp_inf_seq (u : nat -> Rbar) (l : Rbar) :

  is_sup_seq (fun n => Rbar_opp (u n)) (Rbar_opp l)

  <-> is_inf_seq u l.

Proof.

  case: l => [l | | ] ; split => Hl.



  move => eps ; case: (Hl eps) => {Hl} [lb [n lub]] ; split.

  move => n0 ; apply Rbar_opp_lt ; have : (-(l-eps) = -l+eps) ; first by ring.

  by move => /= ->.

  exists n ; apply Rbar_opp_lt ; rewrite /= (Ropp_plus_distr l eps) ; apply lub.

  move => eps ; case: (Hl eps) => {Hl} [ub [n lub]] ; split.

  move => n0 ; have : (-(l-eps) = (-l+eps)) ; first by ring.

  move => /= <- ; by apply (Rbar_opp_lt (u n0) (Finite (l-eps))).

  exists n ; rewrite /Rminus -(Ropp_plus_distr l eps) ;

  by apply (Rbar_opp_lt (Finite (l+eps)) (u n)).



  move => M n ; apply Rbar_opp_lt, Hl.

  move => M n ; apply Rbar_opp_lt ; rewrite Rbar_opp_involutive ; apply Hl.



  move => M ; case: (Hl (-M)) => {Hl} n Hl ; exists n ; by apply Rbar_opp_lt.

  move => M ; case: (Hl (-M)) => {Hl} n Hl ; exists n ; apply Rbar_opp_lt ;

  by rewrite Rbar_opp_involutive.

Qed.



Lemma is_sup_seq_lub (u : nat -> Rbar) (l : Rbar) :

  is_sup_seq u l -> Rbar_is_lub (fun x => exists n, x = u n) l.

Proof.

  destruct l as [l | | ] ; intro Hl ; split.



  intro x ; destruct x as [x | | ] ; simpl ; intros (n, Hn).

  apply le_epsilon ; intros e He ; set (eps := mkposreal e He).

  change (Rbar_le x (l + e)).

  rewrite Hn ; apply Rbar_lt_le, (Hl eps).

  now generalize (proj1 (Hl (mkposreal _ Rlt_0_1)) n) ; clear Hl ; simpl ; intros Hl ; rewrite <-Hn in Hl.

  easy.

  intros b ; destruct b as [b | | ] ; intros Hb ; apply Rbar_not_lt_le ; auto ; intros He.

  set (eps := mkposreal _ (Rlt_Rminus _ _ He)) ; case (proj2 (Hl eps)) ; clear Hl ; intros n.

  apply Rbar_le_not_lt ; assert (l - eps = b) .

  simpl ; ring.

  rewrite H ; clear H ; apply Hb ; exists n ; auto.

  generalize (Rbar_ub_m_infty _ Hb) ; clear Hb ; intros Hb.

  case (proj2 (Hl (mkposreal _ Rlt_0_1))) ; clear Hl ; simpl ; intros n Hl.

  assert (H : (exists n0 : nat, u n = u n0)).

  exists n ; auto.

  generalize (Hb (u n) H) Hl ; clear Hb ; now case (u n).



  apply Rbar_ub_p_infty.

  intro b ; destruct b as [b | | ] ; simpl ; intro Hb.

  case (Hl b) ; clear Hl ; intros n Hl.

  contradict Hl ; apply Rbar_le_not_lt, Hb ; exists n ; auto.

  easy.

  generalize (Rbar_ub_m_infty _ Hb) ; clear Hb ; intro Hb.

  case (Hl 0) ; clear Hl; intros n Hl.

  assert (H : (exists n0 : nat, u n = u n0)).

  exists n ; auto.

  generalize (Hb (u n) H) Hl ; clear Hl ; now case (u n).



  intro x ; destruct x as [x | | ] ; intros (n, Hx).

  generalize (Hl x n) ; clear Hl ; intro Hl ; rewrite <-Hx in Hl ; apply Rlt_irrefl in Hl ; intuition.

  generalize (Hl 0 n) ; rewrite <-Hx ; intuition.

  easy.

  now intros b ; destruct b as [b | | ].

Qed.



Lemma Rbar_is_lub_sup_seq (u : nat -> Rbar) (l : Rbar) :

  Rbar_is_lub (fun x => exists n, x = u n) l -> is_sup_seq u l.

Proof.

  destruct l as [l | | ] ; intros (ub, lub).



  intro eps ; split.

  intro n ; apply Rbar_le_lt_trans with (y := Finite l).

  apply ub ; exists n ; auto.

  pattern l at 1 ; rewrite <-(Rplus_0_r l) ; apply Rplus_lt_compat_l, eps.

  apply LPO_notforall.

  intro n.

  destruct (Rbar_lt_dec (l - eps) (u n)) as [H|H].

  now left.

  now right.

  intro H.

  assert (H0 : (Rbar_is_upper_bound (fun x : Rbar => exists n : nat, x = u n) (Finite (l - eps)))).

  intros x (n,Hn) ; rewrite Hn ; clear Hn ; apply Rbar_not_lt_le, H.

  generalize (lub _ H0) ; clear lub ; apply Rbar_lt_not_le ; pattern l at 2 ;

  rewrite <-(Rplus_0_r l) ;

  apply Rplus_lt_compat_l, Ropp_lt_gt_0_contravar, eps.



  intro M ; apply LPO_notforall.

  intro n.

  destruct (Rbar_lt_dec M (u n)) as [H|H].

  now left.

  now right.

  intro H.

  assert (H0 : Rbar_is_upper_bound (fun x : Rbar => exists n : nat, x = u n) (Finite M)).

  intros x (n,Hn) ; rewrite Hn ; clear Hn ; apply Rbar_not_lt_le, H.

  generalize (lub _ H0) ; clear lub ; apply Rbar_lt_not_le ; simpl ; auto.



  intros M n.

  apply Rbar_le_lt_trans with (y := m_infty) ; simpl ; auto.

  apply ub ; exists n ; auto.

Qed.



Lemma is_inf_seq_glb (u : nat -> Rbar) (l : Rbar) :

  is_inf_seq u l -> Rbar_is_glb (fun x => exists n, x = u n) l.

Proof.

  move => H ;

  apply Rbar_lub_glb ;

  apply (Rbar_is_lub_ext (fun x : Rbar => exists n : nat, x = Rbar_opp (u n))).

  move => x ; split ; case => n Hn ; exists n.

  by rewrite Hn Rbar_opp_involutive.

  by rewrite -Hn Rbar_opp_involutive.

  apply (is_sup_seq_lub (fun n => Rbar_opp (u n)) (Rbar_opp l)) ;

  by apply is_sup_opp_inf_seq.

Qed.

Lemma Rbar_is_glb_inf_seq (u : nat -> Rbar) (l : Rbar) :

  Rbar_is_glb (fun x => exists n, x = u n) l -> is_inf_seq u l.

Proof.

  move => H ;

  apply is_sup_opp_inf_seq ;

  apply Rbar_is_lub_sup_seq ;

  apply Rbar_glb_lub.

  rewrite Rbar_opp_involutive ;

  apply (Rbar_is_glb_ext (fun x : Rbar => exists n : nat, x = u n)) => // x ;

  split ; case => n Hx ; exists n ; by apply Rbar_opp_eq.

Qed.



Lemma is_sup_seq_ext (u v : nat -> Rbar) (l : Rbar) :

  (forall n, u n = v n)

  -> is_sup_seq u l -> is_sup_seq v l.

Proof.

  case: l => [l | | ] Heq ; rewrite /is_sup_seq => Hu.



  move => eps ; case: (Hu eps) => {Hu} Hu1 Hu2 ; split.

  move => n ; by rewrite -Heq.

  case: Hu2 => n Hu2 ; exists n ; by rewrite -Heq.



  move => M ; case: (Hu M) => {Hu} n Hu ; exists n ; by rewrite -Heq.



  move => M n ; by rewrite -Heq.

Qed.

Lemma is_inf_seq_ext (u v : nat -> Rbar) (l : Rbar) :

  (forall n, u n = v n)

  -> is_inf_seq u l -> is_inf_seq v l.

Proof.

  case: l => [l | | ] Heq ; rewrite /is_inf_seq => Hu.



  move => eps ; case: (Hu eps) => {Hu} Hu1 Hu2 ; split.

  move => n ; by rewrite -Heq.

  case: Hu2 => n Hu2 ; exists n ; by rewrite -Heq.



  move => M n ; by rewrite -Heq.



  move => M ; case: (Hu M) => {Hu} n Hu ; exists n ; by rewrite -Heq.

Qed.



Lemma ex_sup_seq (u : nat -> Rbar) : {l : Rbar | is_sup_seq u l}.

Proof.

  case (LPO (fun n => p_infty = u n)) => [/= |  [np Hnp] | Hnp].

    intro n0 ; destruct (u n0) as [r | | ].

    now right.

    left ; auto.

    now right.

  exists p_infty => M.

  exists np ; by rewrite -Hnp.

  case (Rbar_ex_lub (fun x => exists n, x = u n)).

  intros l Hl ; exists l ; apply Rbar_is_lub_sup_seq ; auto.

Qed.



Lemma ex_inf_seq (u : nat -> Rbar) : {l : Rbar | is_inf_seq u l}.

Proof.

  case : (ex_sup_seq (fun n => Rbar_opp (u n))) => l Hl.

  exists (Rbar_opp l) ; apply is_sup_opp_inf_seq ; by rewrite Rbar_opp_involutive.

Qed.



Definition Sup_seq (u : nat -> Rbar) := proj1_sig (ex_sup_seq u).



Definition Inf_seq (u : nat -> Rbar) := proj1_sig (ex_inf_seq u).



Lemma is_sup_seq_unique (u : nat -> Rbar) (l : Rbar) :

  is_sup_seq u l -> Sup_seq u = l.

Proof.

  move => Hl ; rewrite /Sup_seq ; case: (ex_sup_seq _) => l0 Hl0 /= ;

  case: l Hl => [l | | ] Hl ; case: l0 Hl0 => [l0 | | ] Hl0 //.

  apply Rbar_finite_eq, Rle_antisym ; apply le_epsilon => e He ;

  set eps := mkposreal e He ; apply Rlt_le ;

  case: (Hl (pos_div_2 eps)) => {Hl} Hl [n Hn] ;

  case: (Hl0 (pos_div_2 eps)) => {Hl0} Hl0 [n0 Hn0].

  have: (l0 = (l0 - eps/2) + eps/2) ; [by field | move => -> ] ;

  have : (l + e = (l + eps/2) + eps/2) ; [ simpl ; field | move => -> ] ;

  apply Rplus_lt_compat_r, (Rbar_lt_trans

    (Finite (l0 - eps/2)) (u n0) (Finite (l + eps/2)) Hn0 (Hl _)).

  have: (l = (l - eps/2) + eps/2) ; [by field | move => -> ] ;

  have : (l0 + e = (l0 + eps/2) + eps/2) ; [ simpl ; field | move => -> ] ;

  apply Rplus_lt_compat_r, (Rbar_lt_trans

    (Finite (l - eps/2)) (u n) (Finite (l0 + eps/2)) Hn (Hl0 _)).

  case: (Hl0 (l + 1)) => n {Hl0} Hl0 ; contradict Hl0 ;

    apply Rbar_le_not_lt, Rbar_lt_le, (Hl (mkposreal _ Rlt_0_1)).

  case: (Hl (mkposreal _ Rlt_0_1)) => {Hl} _ [n Hl] ; contradict Hl ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl0.

  case: (Hl (l0 + 1)) => n {Hl} Hl ; contradict Hl ;

    apply Rbar_le_not_lt, Rbar_lt_le, (Hl0 (mkposreal _ Rlt_0_1)).

  case: (Hl 0) => n {Hl} Hl ; contradict Hl ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl0.

  case: (Hl0 (mkposreal _ Rlt_0_1)) => {Hl0} _ [n Hl0] ; contradict Hl0 ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl.

  case: (Hl0 0) => n {Hl0} Hl0 ; contradict Hl0 ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl.

Qed.

Lemma Sup_seq_correct (u : nat -> Rbar) :

  is_sup_seq u (Sup_seq u).

Proof.

  rewrite /Sup_seq ; case: (ex_sup_seq _) => l Hl //.

Qed.

Lemma is_inf_seq_unique (u : nat -> Rbar) (l : Rbar) :

  is_inf_seq u l -> Inf_seq u = l.

Proof.

  move => Hl ; rewrite /Inf_seq ; case: (ex_inf_seq _) => l0 Hl0 /= ;

  case: l Hl => [l | | ] Hl ; case: l0 Hl0 => [l0 | | ] Hl0 //.

  apply Rbar_finite_eq, Rle_antisym ; apply le_epsilon => e He ;

  set eps := mkposreal e He ; apply Rlt_le ;

  case: (Hl (pos_div_2 eps)) => {Hl} Hl [n Hn] ;

  case: (Hl0 (pos_div_2 eps)) => {Hl0} Hl0 [n0 Hn0].

  have: (l0 = (l0 - eps/2) + eps/2) ; [by field | move => -> ] ;

  have : (l + e = (l + eps/2) + eps/2) ; [ simpl ; field | move => -> ] ;

  apply Rplus_lt_compat_r, (Rbar_lt_trans

    (Finite (l0 - eps/2)) (u n) (Finite (l + eps/2)) (Hl0 _) Hn).

  have: (l = (l - eps/2) + eps/2) ; [by field | move => -> ] ;

  have : (l0 + e = (l0 + eps/2) + eps/2) ; [ simpl ; field | move => -> ] ;

  apply Rplus_lt_compat_r, (Rbar_lt_trans

    (Finite (l - eps/2)) (u n0) (Finite (l0 + eps/2)) (Hl _) Hn0).

  case: (Hl (mkposreal _ Rlt_0_1)) => {Hl} _ [n Hl] ; contradict Hl ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl0.

  case: (Hl0 (l - 1)) => n {Hl0} Hl0 ; contradict Hl0 ;

    apply Rbar_le_not_lt, Rbar_lt_le, (Hl (mkposreal _ Rlt_0_1)).

  case: (Hl0 (mkposreal _ Rlt_0_1)) => {Hl0} _ [n Hl0] ; contradict Hl0 ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl.

  case: (Hl0 0) => n {Hl0} Hl0 ; contradict Hl0 ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl.

  case: (Hl (l0 - 1)) => n {Hl} Hl ; contradict Hl ;

    apply Rbar_le_not_lt, Rbar_lt_le, (Hl0 (mkposreal _ Rlt_0_1)).

  case: (Hl 0) => n {Hl} Hl ; contradict Hl ;

    apply Rbar_le_not_lt, Rbar_lt_le, Hl0.

Qed.

Lemma Inf_seq_correct (u : nat -> Rbar) :

  is_inf_seq u (Inf_seq u).

Proof.

  rewrite /Inf_seq ; case: (ex_inf_seq _) => l Hl //.

Qed.



Lemma Sup_seq_ext (u v : nat -> Rbar) :

  (forall n, (u n) = (v n)) -> Sup_seq u = Sup_seq v.

Proof.

  intro Heq ; rewrite {2}/Sup_seq ;

  case (ex_sup_seq v) ; simpl ; intros l2 Hv.

  by apply (is_sup_seq_unique u), is_sup_seq_ext with v.

Qed.

Lemma Inf_seq_ext (u v : nat -> Rbar) :

  (forall n, (u n) = (v n)) -> Inf_seq u = Inf_seq v.

Proof.

  intro Heq ; rewrite {2}/Inf_seq ;

  case (ex_inf_seq v) ; simpl ; intros l2 Hv.

  by apply (is_inf_seq_unique u), is_inf_seq_ext with v.

Qed.



Lemma Rbar_sup_eq_lub (u : nat -> Rbar) :

  Sup_seq u = Rbar_lub (fun x => exists n, x = u n).

Proof.

  rewrite /Sup_seq ; case: (ex_sup_seq _) => /= s Hs.

  rewrite /Rbar_lub ; case: (Rbar_ex_lub _) => /= l Hl.

  apply (Rbar_is_lub_eq

    (fun x : Rbar => exists n : nat, x = u n)

    (fun x : Rbar => exists n : nat, x = u n)) => // ;

  by apply is_sup_seq_lub.

Qed.

Lemma Inf_eq_glb (u : nat -> Rbar) :

  Inf_seq u = Rbar_glb (fun x => exists n, x = u n).

Proof.

  rewrite /Inf_seq ; case: (ex_inf_seq _) => /= s Hs.

  rewrite /Rbar_glb ; case: (Rbar_ex_glb _) => /= l Hl.

  apply (Rbar_is_glb_eq

    (fun x : Rbar => exists n : nat, x = u n)

    (fun x : Rbar => exists n : nat, x = u n)) => // ;

  by apply is_inf_seq_glb.

Qed.



Lemma Sup_opp_inf (u : nat -> Rbar) :

  Sup_seq u = Rbar_opp (Inf_seq (fun n => Rbar_opp (u n))).

Proof.

  rewrite /Inf_seq ; case: (ex_inf_seq _) => iu Hiu /=.

  apply is_sup_seq_unique.

  apply is_inf_opp_sup_seq.

  by rewrite Rbar_opp_involutive.

Qed.

Lemma Inf_opp_sup (u : nat -> Rbar) :

  Inf_seq u = Rbar_opp (Sup_seq (fun n => Rbar_opp (u n))).

Proof.

  rewrite Sup_opp_inf Rbar_opp_involutive.

  rewrite /Inf_seq.

  repeat (case: ex_inf_seq ; intros) => /=.

  apply is_inf_seq_glb in p.

  apply is_inf_seq_glb in p0.

  move: p p0 ; apply Rbar_is_glb_eq.

  move => x1 ; split ; case => n -> ; exists n ; by rewrite Rbar_opp_involutive.

Qed.



Lemma Sup_seq_scal_l (a : R) (u : nat -> Rbar) : 0 <= a ->

  Sup_seq (fun n => Rbar_mult a (u n)) = Rbar_mult a (Sup_seq u).

Proof.

  case => Ha.



  rewrite /Sup_seq.

  case: ex_sup_seq => al Hau.

  case: ex_sup_seq => l Hu.

  simpl proj1_sig.

  apply Rbar_le_antisym.



  apply is_sup_seq_lub in Hau.

  apply is_sup_seq_lub in Hu.

  apply Hau => _ [n ->].

  suff : Rbar_le (u n) l.

    case: (u n) => [un | | ] ; case: (l) => [l' | | ] /= ; try (by case) ;

    try (case: Rle_dec (Rlt_le _ _ Ha) => //= Ha' _ ;

    case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => //= _ _ _ ; by left).

  intros H ; apply Rmult_le_compat_l => // ;

  by apply Rlt_le.

  apply Hu.

  by exists n.



  suff : Rbar_le l (Rbar_div_pos al (mkposreal a Ha)).

  case: (al) => [al' | | ] ; case: (l) => [l' | | ] /= ; try (by case) ;

    try (case: Rle_dec (Rlt_le _ _ Ha) => //= Ha' _ ;

    case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => //= _ _ _ ; by left).

  intros H ; rewrite Rmult_comm ;

  apply Rle_div_r => //.

  apply is_sup_seq_lub in Hau.

  apply is_sup_seq_lub in Hu.

  apply Hu => _ [n ->].

  suff : Rbar_le (Rbar_mult a (u n)) al.

    case: (u n) => [un | | ] ; case: (al) => [al' | | ] /= ; try (by case) ;

    try (case: Rle_dec (Rlt_le _ _ Ha) => //= Ha' _ ;

    case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => //= _ _ ; try (by case) ; by left).

  intros H ; rewrite Rmult_comm in H ;

  apply Rle_div_r => //.

  apply Hau.

  by exists n.



  rewrite -Ha.

  transitivity (Sup_seq (fun _ => 0)).

  apply Sup_seq_ext.

  move => n ; case: (u n) => [un | | ] /=.

  apply f_equal ; ring.

  case: Rle_dec (Rle_refl 0) => //= H _.

  case: Rle_lt_or_eq_dec (Rle_not_lt _ _ H) => //= H _.

  case: Rle_dec (Rle_refl 0) => //= H _.

  case: Rle_lt_or_eq_dec (Rle_not_lt _ _ H) => //= H _.



  transitivity 0.

  apply is_sup_seq_unique.

  move => eps ; split => /=.

  move => _ ; ring_simplify ; by apply eps.

  exists 0%nat ; apply Rminus_lt_0 ; ring_simplify ; by apply eps.



  case: (Sup_seq u) => [l | | ] /=.

  apply f_equal ; ring.

  case: Rle_dec (Rle_refl 0) => //= H _.

  case: Rle_lt_or_eq_dec (Rle_not_lt _ _ H) => //= H _.

  case: Rle_dec (Rle_refl 0) => //= H _.

  case: Rle_lt_or_eq_dec (Rle_not_lt _ _ H) => //= H _.

Qed.

Lemma Inf_seq_scal_l (a : R) (u : nat -> Rbar) : 0 <= a ->

  Inf_seq (fun n => Rbar_mult a (u n)) = Rbar_mult a (Inf_seq u).

Proof.

  move => Ha.

  rewrite Inf_opp_sup.

  rewrite -(Sup_seq_ext (fun n => Rbar_mult a (Rbar_opp (u n)))).

  rewrite Sup_seq_scal_l.

  by rewrite -Rbar_mult_opp_r -(Inf_opp_sup u).

  by [].

  move => n ; by rewrite Rbar_mult_opp_r.

Qed.



Lemma is_sup_seq_le (u v : nat -> Rbar) {l1 l2 : Rbar} :

  (forall n, Rbar_le (u n) (v n))

  -> (is_sup_seq u l1) -> (is_sup_seq v l2) -> Rbar_le l1 l2.

Proof.

  destruct l1 as [l1 | | ] ; destruct l2 as [l2 | | ] ; intros Hle Hu Hv ;

  case (is_sup_seq_lub _ _ Hu) ; clear Hu ; intros _ Hu ;

  case (is_sup_seq_lub _ _ Hv) ; clear Hv ; intros Hv _ ;

  apply Hu ; intros x (n,Hn) ; rewrite Hn ; clear x Hn ; apply Rbar_le_trans with (1 := Hle _), Hv ; exists n ; auto.

Qed.

Lemma is_inf_seq_le (u v : nat -> Rbar) {l1 l2 : Rbar} :

  (forall n, Rbar_le (u n) (v n))

  -> (is_inf_seq u l1) -> (is_inf_seq v l2) -> Rbar_le l1 l2.

Proof.

  case: l1 => [l1 | | ] ; case: l2 => [l2 | | ] Hle Hu Hv ;

  case: (is_inf_seq_glb _ _ Hu) => {Hu} Hu _ ;

  case: (is_inf_seq_glb _ _ Hv) => {Hv} _ Hv ;

  apply Hv => _ [n ->] ; apply Rbar_le_trans with (2 := Hle _), Hu ; by exists n.

Qed.



Lemma Sup_seq_le (u v : nat -> Rbar) :

  (forall n, Rbar_le (u n) (v n)) -> Rbar_le (Sup_seq u) (Sup_seq v).

Proof.

  intros Heq ; unfold Sup_seq ;

  case (ex_sup_seq u) ; intros l1 Hu ; case (ex_sup_seq v) ; simpl ; intros l2 Hv.

  apply (is_sup_seq_le u v) ; auto.

Qed.

Lemma Inf_seq_le (u v : nat -> Rbar) :

  (forall n, Rbar_le (u n) (v n)) -> Rbar_le (Inf_seq u) (Inf_seq v).

Proof.

  move => Heq ; rewrite /Inf_seq ;

  case: (ex_inf_seq u) => l1 Hu ; case: (ex_inf_seq v) => /= l2 Hv.

  by apply (is_inf_seq_le u v).

Qed.



Lemma Inf_le_sup (u : nat -> Rbar) : Rbar_le (Inf_seq u) (Sup_seq u).

Proof.

  rewrite /Inf_seq ; case: (ex_inf_seq _) ; case => [iu | | ] Hiu ;

  rewrite /Sup_seq ; case: (ex_sup_seq _) ; case => [su | | ] Hsu //=.



  apply le_epsilon => e He ; set eps := mkposreal e He ;

  case: (Hiu (pos_div_2 eps)) => {Hiu} Hiu _ ;

  case: (Hsu (pos_div_2 eps)) => {Hsu} Hsu _ ;

  apply Rlt_le.

  have : (iu = iu - e/2 + e/2) ; first by ring.

  move => -> ; have : (su+e = su + e/2 + e/2) ; first by field.

  by move => -> ; apply Rplus_lt_compat_r,

  (Rbar_lt_trans (Finite (iu - e/2)) (u O) (Finite (su + e/2))).



  set eps := mkposreal _ Rlt_0_1 ; case: (Hiu eps) => {Hiu} Hiu _ ;

  move: (Hiu O) => {Hiu} ; apply Rbar_le_not_lt, Rbar_lt_le, Hsu.



  set eps := mkposreal _ Rlt_0_1 ; case: (Hsu eps) => {Hsu} Hsu _ ;

  move: (Hsu O) => {Hsu} ; apply Rbar_le_not_lt, Rbar_lt_le, Hiu.



  move: (Hiu 0 O) => {Hiu} ; apply Rbar_le_not_lt, Rbar_lt_le, Hsu.

Qed.



Lemma is_sup_seq_major (u : nat -> Rbar) (l : Rbar) (n : nat) :

  is_sup_seq u l -> Rbar_le (u n) l.

Proof.

  case: l => [l | | ] //= Hl.

  move: (fun eps => proj1 (Hl eps) n) => {Hl}.

  case: (u n) => [un | | ] //= Hun.

  apply le_epsilon => e He ; apply Rlt_le.

  apply: Hun (mkposreal e He).

  by move: (Hun (mkposreal _ Rlt_0_1)).

  case: (u n) => [un | | ] //.

  move: (Hl (u n) n) ; case: (u n) => [un | | ] //= {Hl} Hl.

  by apply Rlt_irrefl in Hl.

Qed.



Lemma Sup_seq_minor_lt (u : nat -> Rbar) (M : R) :

  Rbar_lt M (Sup_seq u) <-> exists n, Rbar_lt M (u n).

Proof.

  rewrite /Sup_seq ; case: ex_sup_seq => l Hl ; simpl proj1_sig ; split => H.

  case: l Hl H => [l | | ] Hl H.

  apply Rminus_lt_0 in H.

  case: (proj2 (Hl (mkposreal _ H))) ; simpl pos => {Hl} n Hl.

  exists n.

  replace M with (l - (l - M)) by ring.

  by apply Hl.

  apply (Hl M).

  by [].

  case: H => n Hn.

  apply Rbar_lt_le_trans with (u n).

  exact: Hn.

  by apply is_sup_seq_major.

Qed.

Lemma Sup_seq_minor_le (u : nat -> Rbar) (M : R) (n : nat) :

  Rbar_le M (u n) -> Rbar_le M (Sup_seq u).

Proof.

  intros H'.

  destruct (Rbar_le_lt_or_eq_dec _ _ H') as [H|H].

  apply Rbar_lt_le.

  apply Sup_seq_minor_lt.

  by exists n.

  rewrite H.

  rewrite /Sup_seq ; case: ex_sup_seq => l Hl ; simpl proj1_sig.

  by apply is_sup_seq_major.

Qed.



Definition is_LimSup_seq (u : nat -> R) (l : Rbar) :=

  match l with

    | Finite l => forall eps : posreal,

        (forall N : nat, exists n : nat, (N <= n)%nat /\ l - eps < u n)

        /\ (exists N : nat, forall n : nat, (N <= n)%nat -> u n < l + eps)

    | p_infty => forall M : R, (forall N : nat, exists n : nat, (N <= n)%nat /\ M < u n)

    | m_infty => forall M : R, (exists N : nat, forall n : nat, (N <= n)%nat -> u n < M)

  end.



Definition is_LimInf_seq (u : nat -> R) (l : Rbar) :=

  match l with

    | Finite l => forall eps : posreal,

        (forall N : nat, exists n : nat, (N <= n)%nat /\ u n < l + eps)

        /\ (exists N : nat, forall n : nat, (N <= n)%nat -> l - eps < u n)

    | p_infty => forall M : R, (exists N : nat, forall n : nat, (N <= n)%nat -> M < u n)

    | m_infty => forall M : R, (forall N : nat, exists n : nat, (N <= n)%nat /\ u n < M)

  end.



Lemma is_LimInf_opp_LimSup_seq (u : nat -> R) (l : Rbar) :

  is_LimInf_seq (fun n => - u n) (Rbar_opp l)

    <-> is_LimSup_seq u l.

Proof.

  case: l => [l | | ] /= ; split => Hl.



  move => eps ; case: (Hl eps) => {Hl} H1 H2 ; split.

  move => N ; case: (H1 N) => {H1} n [Hn H1].

  exists n ; split.

  by [].

  apply Ropp_lt_cancel.

  apply Rlt_le_trans with (1 := H1) ; right ; ring.

  case: H2 => N H2.

  exists N => n Hn.

  apply Ropp_lt_cancel.

  apply Rle_lt_trans with (2 := H2 _ Hn) ; right ; ring.



  move => eps ; case: (Hl eps) => {Hl} H1 H2 ; split.

  move => N ; case: (H1 N) => {H1} n [Hn H1].

  exists n ; split.

  by [].

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  apply Rle_lt_trans with (2 := H1) ; right ; ring.

  case: H2 => N H2.

  exists N => n Hn.

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  apply Rlt_le_trans with (1 := H2 _ Hn) ; right ; ring.



  move => M N.

  case: (Hl (-M) N) => {Hl} n [Hn Hl].

  exists n ; split.

  by [].

  by apply Ropp_lt_cancel.

  move => M N.

  case: (Hl (-M) N) => {Hl} n [Hn Hl].

  exists n ; split.

  by [].

  apply Ropp_lt_cancel ; by rewrite Ropp_involutive.



  move => M.

  case: (Hl (-M)) => {Hl} N Hl.

  exists N => n Hn.

  apply Ropp_lt_cancel.

  by apply Hl.

  move => M.

  case: (Hl (-M)) => {Hl} N Hl.

  exists N => n Hn.

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  by apply Hl.

Qed.

Lemma is_LimSup_opp_LimInf_seq (u : nat -> R) (l : Rbar) :

  is_LimSup_seq (fun n => - u n) (Rbar_opp l)

    <-> is_LimInf_seq u l.

Proof.

  case: l => [l | | ] /= ; split => Hl.



  move => eps ; case: (Hl eps) => {Hl} H1 H2 ; split.

  move => N ; case: (H1 N) => {H1} n [Hn H1].

  exists n ; split.

  by [].

  apply Ropp_lt_cancel.

  apply Rle_lt_trans with (2 := H1) ; right ; ring.

  case: H2 => N H2.

  exists N => n Hn.

  apply Ropp_lt_cancel.

  apply Rlt_le_trans with (1 := H2 _ Hn) ; right ; ring.



  move => eps ; case: (Hl eps) => {Hl} H1 H2 ; split.

  move => N ; case: (H1 N) => {H1} n [Hn H1].

  exists n ; split.

  by [].

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  apply Rlt_le_trans with (1 := H1) ; right ; ring.

  case: H2 => N H2.

  exists N => n Hn.

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  apply Rle_lt_trans with (2 := H2 _ Hn) ; right ; ring.



  move => M.

  case: (Hl (-M)) => {Hl} N Hl.

  exists N => n Hn.

  apply Ropp_lt_cancel.

  by apply Hl.

  move => M.

  case: (Hl (-M)) => {Hl} N Hl.

  exists N => n Hn.

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  by apply Hl.



  move => M N.

  case: (Hl (-M) N) => {Hl} n [Hn Hl].

  exists n ; split.

  by [].

  by apply Ropp_lt_cancel.

  move => M N.

  case: (Hl (-M) N) => {Hl} n [Hn Hl].

  exists n ; split.

  by [].

  apply Ropp_lt_cancel ; by rewrite Ropp_involutive.

Qed.



Lemma is_LimSup_infSup_seq (u : nat -> R) (l : Rbar) :

  is_LimSup_seq u l <-> is_inf_seq (fun m => Sup_seq (fun n => u (n + m)%nat)) l.

Proof.

  case: l => [l | | ] ;

  rewrite /is_LimSup_seq /is_inf_seq ;

  split => Hl.



  split.

  move => N.

  apply Sup_seq_minor_lt.

  case: (proj1 (Hl eps) N) => {Hl} n Hl.

  exists (n - N)%nat.

  rewrite MyNat.sub_add ; intuition.

  case: (proj2 (Hl (pos_div_2 eps))) => /= {Hl} N Hl.

  exists N ; rewrite /Sup_seq ; case: ex_sup_seq => un Hun ; simpl proj1_sig.

  case: un Hun => [un | | ] /= Hun.

  case: (proj2 (Hun (pos_div_2 eps))) => {Hun} /= n Hun.

  apply Rlt_minus_l in Hun.

  apply Rlt_trans with (1 := Hun).

  apply Rlt_minus_r.

  apply Rlt_le_trans with (1 := Hl _ (le_plus_r _ _)) ; right ; field.

  case: (Hun (l + eps / 2)) => {Hun} n.

  apply Rle_not_lt, Rlt_le, Hl, le_plus_r.

  by [].



  split.

  move => N.

  move: (proj1 (Hl eps) N) => {Hl} Hl.

  apply Sup_seq_minor_lt in Hl.

  case: Hl => /= n Hl.

  exists (n + N)%nat ; intuition.

  case: (proj2 (Hl eps)) => {Hl} N Hl.

  exists N => n Hn.

  apply (Rbar_not_le_lt (l + eps) (u n)).

  contradict Hl.

  apply Rbar_le_not_lt.

  apply Sup_seq_minor_le with (n - N)%nat.

  by rewrite MyNat.sub_add.



  move => M N.

  case: (Hl M N) => {Hl} n Hl.

  apply Sup_seq_minor_lt.

  exists (n - N)%nat.

  rewrite MyNat.sub_add ; intuition.

  move => M N.

  move: (Hl M N) => {Hl} Hl.

  apply Sup_seq_minor_lt in Hl.

  case: Hl => /= n Hl.

  exists (n + N)%nat ; intuition.



  move => M.

  case: (Hl (M-1)) => {Hl} N Hl.

  exists N ; rewrite /Sup_seq ; case: ex_sup_seq => un Hun ; simpl proj1_sig.

  case: un Hun => [un | | ] /= Hun.

  case: (proj2 (Hun (mkposreal _ Rlt_0_1))) => {Hun} /= n Hun.

  apply Rlt_minus_l in Hun.

  apply Rlt_trans with (1 := Hun).

  apply Rlt_minus_r.

  apply Hl ; intuition.

  case: (Hun (M-1)) => {Hun} n.

  apply Rle_not_lt, Rlt_le, Hl, le_plus_r.

  by [].

  move => M.

  case: (Hl M) => {Hl} N Hl.

  exists N => n Hn.

  apply (Rbar_not_le_lt M (u n)).

  contradict Hl.

  apply Rbar_le_not_lt.

  apply Sup_seq_minor_le with (n - N)%nat.

  by rewrite MyNat.sub_add.

Qed.

Lemma is_LimInf_supInf_seq (u : nat -> R) (l : Rbar) :

  is_LimInf_seq u l <-> is_sup_seq (fun m => Inf_seq (fun n => u (n + m)%nat)) l.

Proof.

  rewrite -is_LimSup_opp_LimInf_seq.

  rewrite is_LimSup_infSup_seq.

  rewrite -is_sup_opp_inf_seq.

  rewrite Rbar_opp_involutive.

  split ; apply is_sup_seq_ext => n ;

  by rewrite Inf_opp_sup.

Qed.



Lemma is_LimSup_seq_ext_loc (u v : nat -> R) (l : Rbar) :

  eventually (fun n => u n = v n) ->

  is_LimSup_seq u l -> is_LimSup_seq v l.

Proof.

  case: l => [l | | ] /= [Next Hext] Hu.

  move => eps.

  case: (Hu eps) => {Hu} H1 H2 ; split.

  move => N.

  case: (H1 (N + Next)%nat) => {H1} n [Hn H1].

  exists n ; rewrite -Hext ; intuition.

  case: H2 => N H2.

  exists (N + Next)%nat => n Hn.

  rewrite -Hext ; intuition.

  move => M N.

  case: (Hu M (N + Next)%nat) => {Hu} n [Hn Hu].

  exists n ; rewrite -Hext ; intuition.

  move => M.

  case: (Hu M) => {Hu} N Hu.

  exists (N + Next)%nat => n Hn.

  rewrite -Hext ; intuition.

Qed.

Lemma is_LimSup_seq_ext (u v : nat -> R) (l : Rbar) :

  (forall n, u n = v n)

  -> is_LimSup_seq u l -> is_LimSup_seq v l.

Proof.

  move => Hext.

  apply is_LimSup_seq_ext_loc.

  exists O => n _ ; by apply Hext.

Qed.



Lemma is_LimInf_seq_ext_loc (u v : nat -> R) (l : Rbar) :

  eventually (fun n => u n = v n) ->

  is_LimInf_seq u l -> is_LimInf_seq v l.

Proof.

  case => N Hext Hu.

  apply is_LimSup_opp_LimInf_seq.

  apply is_LimSup_seq_ext_loc with (fun n => - u n).

  exists N => n Hn ; by rewrite Hext.

  by apply is_LimSup_opp_LimInf_seq.

Qed.

Lemma is_LimInf_seq_ext (u v : nat -> R) (l : Rbar) :

  (forall n, u n = v n)

  -> is_LimInf_seq u l -> is_LimInf_seq v l.

Proof.

  move => Hext.

  apply is_LimInf_seq_ext_loc.

  exists O => n _ ; by apply Hext.

Qed.



Lemma ex_LimSup_seq (u : nat -> R) :

  {l : Rbar | is_LimSup_seq u l}.

Proof.

  case: (ex_inf_seq (fun m : nat => Sup_seq (fun n : nat => u (n + m)%nat))) => l Hl.

  exists l.

  by apply is_LimSup_infSup_seq.

Qed.

Lemma ex_LimInf_seq (u : nat -> R) :

  {l : Rbar | is_LimInf_seq u l}.

Proof.

  case: (ex_sup_seq (fun m : nat => Inf_seq (fun n : nat => u (n + m)%nat))) => l Hl.

  exists l.

  by apply is_LimInf_supInf_seq.

Qed.



Definition LimSup_seq (u : nat -> R) :=

  proj1_sig (ex_LimSup_seq u).

Definition LimInf_seq (u : nat -> R) :=

  proj1_sig (ex_LimInf_seq u).



Lemma is_LimSup_seq_unique (u : nat -> R) (l : Rbar) :

  is_LimSup_seq u l -> LimSup_seq u = l.

Proof.

  move => H.

  rewrite /LimSup_seq.

  case: ex_LimSup_seq => lu Hu /=.

  apply is_LimSup_infSup_seq in H.

  apply is_LimSup_infSup_seq in Hu.

  rewrite -(is_inf_seq_unique _ _ Hu).

  by apply is_inf_seq_unique.

Qed.

Lemma is_LimInf_seq_unique (u : nat -> R) (l : Rbar) :

  is_LimInf_seq u l -> LimInf_seq u = l.

Proof.

  move => H.

  rewrite /LimInf_seq.

  case: ex_LimInf_seq => lu Hu /=.

  apply is_LimInf_supInf_seq in H.

  apply is_LimInf_supInf_seq in Hu.

  rewrite -(is_sup_seq_unique _ _ Hu).

  by apply is_sup_seq_unique.

Qed.



Lemma LimSup_InfSup_seq (u : nat -> R) :

  LimSup_seq u = Inf_seq (fun m => Sup_seq (fun n => u (n + m)%nat)).

Proof.

  apply is_LimSup_seq_unique.

  apply is_LimSup_infSup_seq.

  rewrite /Inf_seq.

  by case: ex_inf_seq.

Qed.

Lemma LimInf_SupInf_seq (u : nat -> R) :

  LimInf_seq u = Sup_seq (fun m => Inf_seq (fun n => u (n + m)%nat)).

Proof.

  apply is_LimInf_seq_unique.

  apply is_LimInf_supInf_seq.

  rewrite /Sup_seq.

  by case: ex_sup_seq.

Qed.



Lemma is_LimSup_LimInf_seq_le (u : nat -> R) (ls li : Rbar) :

  is_LimSup_seq u ls -> is_LimInf_seq u li -> Rbar_le li ls.

Proof.

  case: ls => [ls | | ] ; case: li => [li | | ] //= Hls Hli.

  apply le_epsilon => e He ;

  set eps := pos_div_2 (mkposreal e He).

  replace li with ((li - eps) + eps) by ring.

  replace (ls + e) with ((ls + eps) + eps) by (simpl ; field).

  apply Rplus_le_compat_r, Rlt_le.

  case: (proj2 (Hls eps)) => {Hls} Ns Hls.

  case: (proj2 (Hli eps)) => {Hli} Ni Hli.

  apply Rlt_trans with (u (Ns + Ni)%nat).

  apply Hli ; by intuition.

  apply Hls ; by intuition.

  case: (proj2 (Hls (mkposreal _ Rlt_0_1))) => {Hls} /= Ns Hls.

  case: (Hli (ls + 1)) => {Hli} Ni Hli.

  absurd (ls + 1 < u (Ns + Ni)%nat).

  apply Rle_not_lt, Rlt_le, Hls ; by intuition.

  apply Hli ; by intuition.

  case: (proj2 (Hli (mkposreal _ Rlt_0_1))) => {Hli} /= Ni Hli.

  case: (Hls (li - 1)) => {Hls} Ns Hls.

  absurd (li - 1 < u (Ns + Ni)%nat).

  apply Rle_not_lt, Rlt_le, Hls ; by intuition.

  apply Hli ; by intuition.

  case: (Hli 0) => {Hli} /= Ni Hli.

  case: (Hls 0) => {Hls} Ns Hls.

  absurd (0 < u (Ns + Ni)%nat).

  apply Rle_not_lt, Rlt_le, Hls ; by intuition.

  apply Hli ; by intuition.

Qed.

Lemma LimSup_LimInf_seq_le (u : nat -> R) :

  Rbar_le (LimInf_seq u) (LimSup_seq u).

Proof.

  rewrite /LimInf_seq ; case: ex_LimInf_seq => /= li Hli.

  rewrite /LimSup_seq ; case: ex_LimSup_seq => /= ls Hls.

  by apply is_LimSup_LimInf_seq_le with u.

Qed.



Lemma is_LimSup_seq_const (a : R) :

  is_LimSup_seq (fun _ => a) a.

Proof.

  intros eps ; split.

  intros N ; exists N ; split.

  by apply le_refl.

  apply Rminus_lt_0 ; ring_simplify.

  by apply eps.

  exists O => _ _.

  apply Rminus_lt_0 ; ring_simplify.

  by apply eps.

Qed.

Lemma LimSup_seq_const (a : R) :

  LimSup_seq (fun _ => a) = a.

Proof.

  apply is_LimSup_seq_unique.

  by apply is_LimSup_seq_const.

Qed.



Lemma is_LimInf_seq_const (a : R) :

  is_LimInf_seq (fun _ => a) a.

Proof.

  intros eps ; split.

  intros N ; exists N ; split.

  by apply le_refl.

  apply Rminus_lt_0 ; ring_simplify.

  by apply eps.

  exists O => _ _.

  apply Rminus_lt_0 ; ring_simplify.

  by apply eps.

Qed.

Lemma LimInf_seq_const (a : R) :

  LimInf_seq (fun _ => a) = a.

Proof.

  apply is_LimInf_seq_unique.

  by apply is_LimInf_seq_const.

Qed.



Lemma LimSup_seq_opp (u : nat -> R) :

  LimSup_seq (fun n => - u n) = Rbar_opp (LimInf_seq u).

Proof.

  rewrite LimSup_InfSup_seq LimInf_SupInf_seq.

  rewrite Inf_opp_sup ; apply f_equal, Sup_seq_ext => m.

  rewrite Inf_opp_sup ; by apply f_equal, Sup_seq_ext => n.

Qed.

Lemma LimInf_seq_opp (u : nat -> R) :

  LimInf_seq (fun n => - u n) = Rbar_opp (LimSup_seq u).

Proof.

  rewrite LimSup_InfSup_seq LimInf_SupInf_seq.

  rewrite Sup_opp_inf ; apply f_equal, Inf_seq_ext => m.

  rewrite Sup_opp_inf ; by apply f_equal, Inf_seq_ext => n.

Qed.



Lemma LimSup_le (u v : nat -> R) :

  eventually (fun n => u n <= v n)

  -> Rbar_le (LimSup_seq u) (LimSup_seq v).

Proof.

  intros (N,H).

  rewrite /LimSup_seq.

  case: ex_LimSup_seq ; case => [lu | | ] //= Hlu ;

  case: ex_LimSup_seq ; case => [lv | | ] //= Hlv.

  apply Rnot_lt_le => Hl.

  apply Rminus_lt_0 in Hl.

  case: (Hlv (pos_div_2 (mkposreal _ Hl))) => {Hlv} /= _ [n Hlv].

  case: (proj1 (Hlu (pos_div_2 (mkposreal _ Hl))) (N + n)%nat) => {Hlu} m /= [Hm Hlu].

  move: (H _ (le_trans _ _ _ (le_plus_l _ _) Hm)).

  apply Rlt_not_le.

  eapply Rlt_trans, Hlu.

  eapply Rlt_le_trans.

  eapply Hlv, le_trans, Hm.

  by apply le_plus_r.

  apply Req_le ; field.



  case: (Hlv (lu - 1)) => {Hlv} n Hlv.

  case: (proj1 (Hlu (mkposreal _ Rlt_0_1)) (N + n)%nat) => {Hlu} m /= [Hm Hlu].

  move: (H _ (le_trans _ _ _ (le_plus_l _ _) Hm)).

  apply Rlt_not_le.

  eapply Rlt_trans, Hlu.

  eapply Hlv, le_trans, Hm.

  by apply le_plus_r.



  case: (Hlv (mkposreal _ Rlt_0_1)) => {Hlv} /= _ [n Hlv].

  case: (Hlu (lv + 1) (N + n)%nat) => {Hlu} /= m [Hm Hlu].

  move: (H _ (le_trans _ _ _ (le_plus_l _ _) Hm)).

  apply Rlt_not_le.

  eapply Rlt_trans, Hlu.

  eapply Hlv, le_trans, Hm.

  by apply le_plus_r.



  case: (Hlv 0) => {Hlv} n Hlv.

  case: (Hlu 0 (N + n)%nat) => {Hlu} m [Hm Hlu].

  move: (H _ (le_trans _ _ _ (le_plus_l _ _) Hm)).

  apply Rlt_not_le.

  eapply Rlt_trans, Hlu.

  eapply Hlv, le_trans, Hm.

  by apply le_plus_r.

Qed.

Lemma LimInf_le (u v : nat -> R) :

  eventually (fun n => u n <= v n)

  -> Rbar_le (LimInf_seq u) (LimInf_seq v).

Proof.

  intros.

  apply Rbar_opp_le.

  rewrite -!LimSup_seq_opp.

  apply LimSup_le.

  move: H ; apply filter_imp => n.

  by apply Ropp_le_contravar.

Qed.



Lemma is_LimSup_seq_scal_pos (a : R) (u : nat -> R) (l : Rbar) :

  (0 < a) -> is_LimSup_seq u l ->

    is_LimSup_seq (fun n => a * u n) (Rbar_mult a l).

Proof.

  case: l => [l | | ] /= Ha Hu.

  move => eps.

  suff He : 0 < eps / a.

  case: (Hu (mkposreal _ He)) => {Hu} /= H1 H2 ; split.

  move => N ; case: (H1 N) => {H1} n [Hn H1].

  exists n ; split.

  by [].

  rewrite (Rmult_comm _ (u n)) ; apply Rlt_div_l.

  by [].

  apply Rle_lt_trans with (2 := H1) ; right ; field ; by apply Rgt_not_eq.

  case: H2 => N H2.

  exists N => n Hn.

  rewrite (Rmult_comm _ (u n)) ; apply Rlt_div_r.

  by [].

  apply Rlt_le_trans with (1 := H2 _ Hn) ; right ; field ; by apply Rgt_not_eq.

  apply Rdiv_lt_0_compat ; [ by case eps | by [] ].

  case: Rle_dec (Rlt_le _ _ Ha) => // H _.

  case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => {H} // _ _.

  move => M N.

  case: (Hu (M / a) N) => {Hu} n [Hn Hu].

  exists n ; split.

  by [].

  rewrite (Rmult_comm _ (u n)) ; apply Rlt_div_l.

  by [].

  by [].

  case: Rle_dec (Rlt_le _ _ Ha) => // H _.

  case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => {H} // _ _.

  move => M.

  case: (Hu (M / a)) => {Hu} N Hu.

  exists N => n Hn.

  rewrite (Rmult_comm _ (u n)) ; apply Rlt_div_r.

  by [].

  by apply Hu.

Qed.

Lemma is_LimInf_seq_scal_pos (a : R) (u : nat -> R) (l : Rbar) :

  (0 < a) -> is_LimInf_seq u l ->

    is_LimInf_seq (fun n => a * u n) (Rbar_mult a l).

Proof.

  move => Ha Hu.

  apply is_LimSup_opp_LimInf_seq in Hu.

  apply is_LimSup_opp_LimInf_seq.

  replace (Rbar_opp (Rbar_mult a l)) with (Rbar_mult a (Rbar_opp l)).

  apply is_LimSup_seq_ext with (fun n => a * - u n).

  move => n ; ring.

  by apply is_LimSup_seq_scal_pos.

  case: (l) => [x | | ] /=.

  apply f_equal ; ring.

  case: Rle_dec (Rlt_le _ _ Ha) => // H _.

  case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => // H _.

  case: Rle_dec (Rlt_le _ _ Ha) => // H _.

  case: Rle_lt_or_eq_dec (Rlt_not_eq _ _ Ha) => // H _.

Qed.



Lemma is_LimSup_seq_ind_1 (u : nat -> R) (l : Rbar) :

  is_LimSup_seq u l <->

    is_LimSup_seq (fun n => u (S n)) l.

Proof.

  case: l => [l | | ] ; split => //= Hu.



  move => eps.

  case: (Hu eps) => {Hu} H1 H2 ; split.

  move => N.

  case: (H1 (S N)) => {H1} n [Hn H1].

  exists (pred n).

  case: (n) Hn H1 => /= [ | m] Hm H1.

  by apply le_Sn_O in Hm.

  split.

  by apply le_S_n.

  by apply H1.

  case: H2 => N H2.

  exists N => n Hn.

  apply H2 ; intuition.

  move => eps.

  case: (Hu eps) => {Hu} H1 H2 ; split.

  move => N.

  case: (H1 N) => {H1} n [Hn H1].

  exists (S n) ; intuition.

  case: H2 => N H2.

  exists (S N) => n Hn.

  case: (n) Hn => /= [ | m] Hm.

  by apply le_Sn_O in Hm.

  apply H2 ; intuition.



  move => M N.

  case: (Hu M (S N)) => {Hu} n [Hn Hu].

  exists (pred n).

  case: (n) Hn Hu => /= [ | m] Hm Hu.

  by apply le_Sn_O in Hm.

  split.

  by apply le_S_n.

  by apply Hu.

  move => M N.

  case: (Hu M N) => {Hu} n [Hn Hu].

  exists (S n) ; intuition.



  move => M.

  case: (Hu M) => {Hu} N Hu.

  exists N => n Hn.

  apply Hu ; intuition.

  move => M.

  case: (Hu M) => {Hu} N Hu.

  exists (S N) => n Hn.

  case: (n) Hn => /= [ | m] Hm.

  by apply le_Sn_O in Hm.

  apply Hu ; intuition.

Qed.

Lemma is_LimInf_seq_ind_1 (u : nat -> R) (l : Rbar) :

  is_LimInf_seq u l <->

    is_LimInf_seq (fun n => u (S n)) l.

Proof.

  rewrite -?is_LimSup_opp_LimInf_seq.

  by apply is_LimSup_seq_ind_1.

Qed.



Lemma is_LimSup_seq_ind_k (u : nat -> R) (k : nat) (l : Rbar) :

  is_LimSup_seq u l <->

    is_LimSup_seq (fun n => u (n + k)%nat) l.

Proof.

  elim: k u => [ | k IH] /= u.

  split ; apply is_LimSup_seq_ext => n ; by rewrite -plus_n_O.

  rewrite is_LimSup_seq_ind_1.

  rewrite (IH (fun n => u (S n))).

  split ; apply is_LimSup_seq_ext => n ; by rewrite plus_n_Sm.

Qed.

Lemma is_LimInf_seq_ind_k (u : nat -> R) (k : nat) (l : Rbar) :

  is_LimInf_seq u l <->

    is_LimInf_seq (fun n => u (n + k)%nat) l.

Proof.

  rewrite -?is_LimSup_opp_LimInf_seq.

  by apply (is_LimSup_seq_ind_k (fun n => - u n)).

Qed.



Definition is_lim_seq (u : nat -> R) (l : Rbar) :=

  filterlim u eventually (Rbar_locally l).



Definition is_lim_seq' (u : nat -> R) (l : Rbar) :=

  match l with

    | Finite l => forall eps : posreal, eventually (fun n => Rabs (u n - l) < eps)

    | p_infty => forall M : R, eventually (fun n => M < u n)

    | m_infty => forall M : R, eventually (fun n => u n < M)

  end.

Definition ex_lim_seq (u : nat -> R) :=

  exists l, is_lim_seq u l.

Definition ex_finite_lim_seq (u : nat -> R) :=

  exists l : R, is_lim_seq u l.

Definition Lim_seq (u : nat -> R) : Rbar :=

  Rbar_div_pos (Rbar_plus (LimSup_seq u) (LimInf_seq u))

    {| pos := 2; cond_pos := Rlt_R0_R2 |}.



Lemma is_lim_seq_spec :

  forall u l,

  is_lim_seq' u l <-> is_lim_seq u l.

Proof.

destruct l as [l| |] ; split.

- intros H P [eps LP].

  destruct (H eps) as [N HN].

  exists N => n Hn.

  apply LP.

  now apply HN.

- intros LP eps.

  specialize (LP (fun y => Rabs (y - l) < eps)).

  apply LP.

  now exists eps.

- intros H P [M LP].

  destruct (H M) as [N HN].

  exists N => n Hn.

  apply LP.

  now apply HN.

- intros LP M.

  specialize (LP (fun y => M < y)).

  apply LP.

  now exists M.

- intros H P [M LP].

  destruct (H M) as [N HN].

  exists N => n Hn.

  apply LP.

  now apply HN.

- intros LP M.

  specialize (LP (fun y => y < M)).

  apply LP.

  now exists M.

Qed.



Lemma is_lim_seq_Reals (u : nat -> R) (l : R) :

  is_lim_seq u l <-> Un_cv u l.

Proof.

  split => Hl.

  move => e He.

  apply (Hl (fun y => R_dist y l < e)).

  now exists (mkposreal _ He).

  unfold is_lim_seq.

  change (Rbar_locally l) with (locally l).

  apply (filterlim_locally u l).

  case => e He.

  case: (Hl e He) => {Hl} /= N Hl.

  exists N => n Hn.

  by apply (Hl n Hn).

Qed.

Lemma is_lim_seq_p_infty_Reals (u : nat -> R) :

  is_lim_seq u p_infty <-> cv_infty u.

Proof.

  split => Hl.

  move => M.

  case: (Hl (fun x => M < x)) => {Hl} [ | N Hl].

  by exists M.

  by exists N.

  move => P [M HP].

  eapply filter_imp.

  by apply HP.

  case: (Hl M) => {Hl} N HN.

  by exists N.

Qed.



Lemma is_lim_LimSup_seq (u : nat -> R) (l : Rbar) :

  is_lim_seq u l -> is_LimSup_seq u l.

Proof.

  move /is_lim_seq_spec.

  case: l => [l | | ] /= Hu.

  move => eps ; case: (Hu eps) => {Hu} N Hu ; split.

  move => N0.

  exists (N + N0)%nat ; split.

  by apply le_plus_r.

  by apply Rabs_lt_between', Hu, le_plus_l.

  exists N => n Hn.

  by apply Rabs_lt_between', Hu.

  move => M N0.

  case: (Hu M) => {Hu} N Hu.

  exists (N + N0)%nat ; split.

  by apply le_plus_r.

  by apply Hu, le_plus_l.

  by [].

Qed.

Lemma is_lim_LimInf_seq (u : nat -> R) (l : Rbar) :

  is_lim_seq u l -> is_LimInf_seq u l.

Proof.

  move /is_lim_seq_spec.

  case: l => [l | | ] /= Hu.

  move => eps ; case: (Hu eps) => {Hu} N Hu ; split.

  move => N0.

  exists (N + N0)%nat ; split.

  by apply le_plus_r.

  by apply Rabs_lt_between', Hu, le_plus_l.

  exists N => n Hn.

  by apply Rabs_lt_between', Hu.

  by [].

  move => M N0.

  case: (Hu M) => {Hu} N Hu.

  exists (N + N0)%nat ; split.

  by apply le_plus_r.

  by apply Hu, le_plus_l.

Qed.

Lemma is_LimSup_LimInf_lim_seq (u : nat -> R) (l : Rbar) :

  is_LimSup_seq u l -> is_LimInf_seq u l -> is_lim_seq u l.

Proof.

  case: l => [l | | ] /= Hs Hi ; apply is_lim_seq_spec.

  move => eps.

  case: (proj2 (Hs eps)) => {Hs} Ns Hs.

  case: (proj2 (Hi eps)) => {Hi} Ni Hi.

  exists (Ns + Ni)%nat => n Hn.

  apply Rabs_lt_between' ; split.

  apply Hi ; intuition.

  apply Hs ; intuition.

  exact Hi.

  exact Hs.

Qed.



Lemma ex_lim_LimSup_LimInf_seq (u : nat -> R) :

  ex_lim_seq u <-> LimSup_seq u = LimInf_seq u.

Proof.

  split => Hl.

  case: Hl => l Hu.

  transitivity l.

  apply is_LimSup_seq_unique.

  by apply is_lim_LimSup_seq.

  apply sym_eq, is_LimInf_seq_unique.

  by apply is_lim_LimInf_seq.

  exists (LimSup_seq u).

  apply is_LimSup_LimInf_lim_seq.

  rewrite /LimSup_seq ; by case: ex_LimSup_seq.

  rewrite Hl /LimInf_seq ; by case: ex_LimInf_seq.

Qed.



Lemma is_lim_seq_ext_loc (u v : nat -> R) (l : Rbar) :

  eventually (fun n => u n = v n) ->

  is_lim_seq u l -> is_lim_seq v l.

Proof.

  apply filterlim_ext_loc.

Qed.

Lemma ex_lim_seq_ext_loc (u v : nat -> R) :

  eventually (fun n => u n = v n) ->

  ex_lim_seq u -> ex_lim_seq v.

Proof.

  move => H [l H0].

  exists l ; by apply is_lim_seq_ext_loc with u.

Qed.

Lemma Lim_seq_ext_loc (u v : nat -> R) :

  eventually (fun n => u n = v n) ->

  Lim_seq u = Lim_seq v.

Proof.

  intros.

  rewrite /Lim_seq.

  apply (f_equal (fun x => Rbar_div_pos x _)).

  apply f_equal2 ; apply sym_eq.

  apply is_LimSup_seq_unique.

  apply is_LimSup_seq_ext_loc with u.

  by [].

  rewrite /LimSup_seq ; by case: ex_LimSup_seq.

  apply is_LimInf_seq_unique.

  apply is_LimInf_seq_ext_loc with u.

  by [].

  rewrite /LimInf_seq ; by case: ex_LimInf_seq.

Qed.



Lemma is_lim_seq_ext (u v : nat -> R) (l : Rbar) :

  (forall n, u n = v n) -> is_lim_seq u l -> is_lim_seq v l.

Proof.

  move => Hext.

  apply is_lim_seq_ext_loc.

  by exists O.

Qed.

Lemma ex_lim_seq_ext (u v : nat -> R) :

  (forall n, u n = v n) -> ex_lim_seq u -> ex_lim_seq v.

Proof.

  move => H [l H0].

  exists l ; by apply is_lim_seq_ext with u.

Qed.

Lemma Lim_seq_ext (u v : nat -> R) :

  (forall n, u n = v n) ->

  Lim_seq u = Lim_seq v.

Proof.

  move => Hext.

  apply Lim_seq_ext_loc.

  by exists O.

Qed.



Lemma is_lim_seq_unique (u : nat -> R) (l : Rbar) :

  is_lim_seq u l -> Lim_seq u = l.

Proof.

  move => Hu.

  rewrite /Lim_seq.

  replace l with (Rbar_div_pos (Rbar_plus l l) {| pos := 2; cond_pos := Rlt_R0_R2 |})

    by (case: (l) => [x | | ] //= ; apply f_equal ; field).

  apply (f_equal (fun x => Rbar_div_pos x _)).

  apply f_equal2.

  apply is_LimSup_seq_unique.

  by apply is_lim_LimSup_seq.

  apply is_LimInf_seq_unique.

  by apply is_lim_LimInf_seq.

Qed.

Lemma Lim_seq_correct (u : nat -> R) :

  ex_lim_seq u -> is_lim_seq u (Lim_seq u).

Proof.

  intros (l,H).

  cut (Lim_seq u = l).

    intros ; rewrite H0 ; apply H.

  apply is_lim_seq_unique, H.

Qed.

Lemma Lim_seq_correct' (u : nat -> R) :

  ex_finite_lim_seq u -> is_lim_seq u (real (Lim_seq u)).

Proof.

  intros (l,H).

  cut (real (Lim_seq u) = l).

    intros ; rewrite H0 ; apply H.

  replace l with (real l) by auto.

  apply f_equal, is_lim_seq_unique, H.

Qed.



Lemma ex_finite_lim_seq_correct (u : nat -> R) :

  ex_finite_lim_seq u <-> ex_lim_seq u /\ is_finite (Lim_seq u).

Proof.

  split.

  case => l Hl.

  split.

  by exists l.

  by rewrite (is_lim_seq_unique _ _ Hl).

  case ; case => l Hl H.

  exists l.

  rewrite -(is_lim_seq_unique _ _ Hl).

  by rewrite H (is_lim_seq_unique _ _ Hl).

Qed.



Lemma ex_lim_seq_dec (u : nat -> R) :

  {ex_lim_seq u} + {~ex_lim_seq u}.

Proof.

  case: (Rbar_eq_dec (LimSup_seq u) (LimInf_seq u)) => H.

  left ; by apply ex_lim_LimSup_LimInf_seq.

  right ; contradict H ; by apply ex_lim_LimSup_LimInf_seq.

Qed.



Lemma ex_finite_lim_seq_dec (u : nat -> R) :

  {ex_finite_lim_seq u} + {~ ex_finite_lim_seq u}.

Proof.

  case: (ex_lim_seq_dec u) => H.

  apply Lim_seq_correct in H.

  case: (Lim_seq u) H => [l | | ] H.

  left ; by exists l.

  right ; rewrite ex_finite_lim_seq_correct.

  rewrite (is_lim_seq_unique _ _ H) /is_finite //= ; by case.

  right ; rewrite ex_finite_lim_seq_correct.

  rewrite (is_lim_seq_unique _ _ H) /is_finite //= ; by case.

  right ; rewrite ex_finite_lim_seq_correct.

  contradict H ; by apply H.

Qed.



Definition ex_lim_seq_cauchy (u : nat -> R) :=

  forall eps : posreal, exists N : nat, forall n m,

    (N <= n)%nat -> (N <= m)%nat -> Rabs (u n - u m) < eps.

Lemma ex_lim_seq_cauchy_corr (u : nat -> R) :

  (ex_finite_lim_seq u) <-> ex_lim_seq_cauchy u.

Proof.

  split => Hcv.



  apply Lim_seq_correct' in Hcv.

  apply is_lim_seq_spec in Hcv.

  move => eps.

  case: (Hcv (pos_div_2 eps)) => /= {Hcv} N H.

  exists N => n m Hn Hm.

  replace (u n - u m) with ((u n - (real (Lim_seq u))) - (u m - (real (Lim_seq u)))) by ring.

  apply Rle_lt_trans with (1 := Rabs_triang _ _).

  rewrite Rabs_Ropp (double_var eps).

  apply Rplus_lt_compat ; by apply H.



  exists (LimSup_seq u).

  apply is_lim_seq_spec.

  intros eps.

  rewrite /LimSup_seq ; case: ex_LimSup_seq => /= l Hl.

  case: (Hcv (pos_div_2 eps)) => {Hcv} /= Ncv Hcv.

  case: l Hl => [l | | ] /= Hl.

  case: (Hl (pos_div_2 eps)) => {Hl} /= H1 [Nl H2].

  exists (Ncv + Nl)%nat => n Hn.

  apply Rabs_lt_between' ; split.

  case: (H1 Ncv) => {H1} m [Hm H1].

  replace (l - eps) with ((l - eps / 2) - eps / 2) by field.

  apply Rlt_trans with (u m - eps / 2).

  by apply Rplus_lt_compat_r.

  apply Rabs_lt_between'.

  apply Hcv ; intuition.

  apply Rlt_trans with (l + eps / 2).

  apply H2 ; intuition.

  apply Rminus_lt_0 ; field_simplify ; rewrite ?Rdiv_1.

  by apply is_pos_div_2.

  move: (fun n Hn => proj2 (proj1 (Rabs_lt_between' _ _ _) (Hcv n Ncv Hn (le_refl _))))

  => {Hcv} Hcv.

  case: (Hl (u Ncv + eps / 2) Ncv) => {Hl} n [Hn Hl].

  contradict Hl ; apply Rle_not_lt, Rlt_le.

  by apply Hcv.

  move: (fun n Hn => proj1 (proj1 (Rabs_lt_between' _ _ _) (Hcv n Ncv Hn (le_refl _))))

  => {Hcv} Hcv.

  case: (Hl (u Ncv - eps / 2)) => {Hl} N Hl.

  move: (Hcv _ (le_plus_l Ncv N)) => H.

  contradict H ; apply Rle_not_lt, Rlt_le, Hl, le_plus_r.

Qed.



Lemma is_lim_seq_INR :

  is_lim_seq INR p_infty.

Proof.

  apply is_lim_seq_spec.

  move => M.

  suff Hm : 0 <= Rmax 0 M.

  exists (S (nfloor (Rmax 0 M) Hm)) => n Hn.

  apply Rlt_le_trans with (2 := le_INR _ _ Hn).

  rewrite /nfloor S_INR.

  case: nfloor_ex => {n Hn} /= n Hn.

  apply Rle_lt_trans with (1 := Rmax_r 0 M).

  by apply Hn.

  apply Rmax_l.

Qed.

Lemma ex_lim_seq_INR :

  ex_lim_seq INR.

Proof.

  exists p_infty ; by apply is_lim_seq_INR.

Qed.

Lemma Lim_seq_INR :

  Lim_seq INR = p_infty.

Proof.

  intros.

  apply is_lim_seq_unique.

  apply is_lim_seq_INR.

Qed.



Lemma is_lim_seq_const (a : R) :

  is_lim_seq (fun n => a) a.

Proof.

apply filterlim_const.

Qed.

Lemma ex_lim_seq_const (a : R) :

  ex_lim_seq (fun n => a).

Proof.

  exists a ; by apply is_lim_seq_const.

Qed.

Lemma Lim_seq_const (a : R) :

  Lim_seq (fun n => a) = a.

Proof.

  intros.

  apply is_lim_seq_unique.

  apply is_lim_seq_const.

Qed.



Lemma eventually_subseq_loc :

  forall phi,

  eventually (fun n => (phi n < phi (S n))%nat) ->

  filterlim phi eventually eventually.

Proof.

intros phi [M Hphi] P [N HP].

exists (N+M)%nat.

intros n Hn.

apply HP.

apply plus_le_reg_l with M.

rewrite Arith.Plus.plus_comm ; apply le_trans with (1:=Hn).

apply le_trans with (1:=le_plus_r (phi M) _).

assert (H:(forall x, M+phi M + x <= M+phi (x+M))%nat).

induction x as [|x IH].

rewrite plus_0_l plus_0_r.

apply le_refl.

rewrite <- plus_n_Sm.

apply lt_le_S.

apply le_lt_trans with (1:=IH).

apply plus_lt_compat_l.

apply Hphi.

apply le_plus_r.

assert (M <= n)%nat.

apply le_trans with (2:=Hn); apply le_plus_r.

specialize (H (n-M)%nat).

replace (n-M+M)%nat with n in H.

apply le_trans with (2:=H).

rewrite (Arith.Plus.plus_comm _ (phi M)) -Arith.Plus.plus_assoc.

apply plus_le_compat_l.

rewrite le_plus_minus_r.

apply le_refl.

exact H0.

rewrite Arith.Plus.plus_comm.

now apply sym_eq, le_plus_minus_r.

Qed.

Lemma eventually_subseq :

  forall phi,

  (forall n, (phi n < phi (S n))%nat) ->

  filterlim phi eventually eventually.

Proof.

intros phi Hphi.

apply eventually_subseq_loc.

by apply filter_forall.

Qed.



Lemma is_lim_seq_subseq (u : nat -> R) (l : Rbar) (phi : nat -> nat) :

  filterlim phi eventually eventually ->

  is_lim_seq u l ->

  is_lim_seq (fun n => u (phi n)) l.

Proof.

intros Hphi.

now apply filterlim_comp.

Qed.

Lemma ex_lim_seq_subseq (u : nat -> R) (phi : nat -> nat) :

  filterlim phi eventually eventually ->

  ex_lim_seq u ->

  ex_lim_seq (fun n => u (phi n)).

Proof.

  move => Hphi [l Hu].

  exists l.

  by apply is_lim_seq_subseq.

Qed.

Lemma Lim_seq_subseq (u : nat -> R) (phi : nat -> nat) :

  filterlim phi eventually eventually ->

  ex_lim_seq u ->

  Lim_seq (fun n => u (phi n)) = Lim_seq u.

Proof.

  move => Hphi Hu.

  apply is_lim_seq_unique.

  apply is_lim_seq_subseq.

  exact Hphi.

  by apply Lim_seq_correct.

Qed.



Lemma is_lim_seq_incr_1 (u : nat -> R) (l : Rbar) :

  is_lim_seq u l <-> is_lim_seq (fun n => u (S n)) l.

Proof.

split ; intros H P HP ; destruct (H P HP) as [N HN].

- exists N.

  intros n Hn.

  apply HN.

  now apply le_S.

- exists (S N).

  intros n Hn.

  destruct n as [|n] ; try easy.

  apply HN.

  now apply le_S_n.

Qed.

Lemma ex_lim_seq_incr_1 (u : nat -> R) :

  ex_lim_seq u <-> ex_lim_seq (fun n => u (S n)).

Proof.

  split ; move => [l H] ; exists l.

  by apply -> is_lim_seq_incr_1.

  by apply is_lim_seq_incr_1.

Qed.

Lemma Lim_seq_incr_1 (u : nat -> R) :

  Lim_seq (fun n => u (S n)) = Lim_seq u.

Proof.

  rewrite /Lim_seq.

  replace (LimSup_seq (fun n : nat => u (S n)))

    with (LimSup_seq u).

  replace (LimInf_seq (fun n : nat => u (S n)))

    with (LimInf_seq u).

  by [].



  rewrite /LimInf_seq ;

  case: ex_LimInf_seq => l1 H1 ;

  case: ex_LimInf_seq => l2 H2 /= ;

  case: l1 H1 => [l1 | | ] /= H1 ;

  case: l2 H2 => [l2 | | ] /= H2.

  apply Rbar_finite_eq, Rle_antisym ;

  apply le_epsilon => e He ; set eps := mkposreal e He ;

  apply Rlt_le.

  case: (proj2 (H1 (pos_div_2 eps))) => /= {H1} N H1.

  case: (proj1 (H2 (pos_div_2 eps)) N) => /= {H2} n [Hn H2].

  apply Rlt_trans with (u (S n) + e/2).

  replace l1 with ((l1-e/2)+e/2) by ring.

  apply Rplus_lt_compat_r.

  apply H1.

  apply le_trans with (1 := Hn).

  apply le_n_Sn.

  replace (l2+e) with ((l2+e/2)+e/2) by field.

  by apply Rplus_lt_compat_r, H2.

  case: (proj2 (H2 (pos_div_2 eps))) => /= {H2} N H2.

  case: (proj1 (H1 (pos_div_2 eps)) (S N)) => /= {H1} .

  case => [ | n] [Hn H1].

  by apply le_Sn_0 in Hn.

  apply Rlt_trans with (u (S n) + e/2).

  replace l2 with ((l2-e/2)+e/2) by ring.

  apply Rplus_lt_compat_r.

  apply H2.

  by apply le_S_n, Hn.

  replace (l1+e) with ((l1+e/2)+e/2) by field.

  by apply Rplus_lt_compat_r, H1.

  have : False => //.

  case: (H2 (l1+1)) => {H2} N /= H2.

  case: (proj1 (H1 (mkposreal _ Rlt_0_1)) (S N)) ;

  case => /= {H1} [ | n] [Hn].

  by apply le_Sn_0 in Hn.

  apply Rle_not_lt, Rlt_le, H2.

  by apply le_S_n.

  have : False => //.

  case: (proj2 (H1 (mkposreal _ Rlt_0_1))) => {H1} N /= H1.

  case: ((H2 (l1-1)) N) => /= {H2}  n [Hn].

  apply Rle_not_lt, Rlt_le, H1.

  by apply le_trans with (2 := le_n_Sn _).

  have : False => //.

  case: (H1 (l2+1)) => {H1} N /= H1.

  case: (proj1 (H2 (mkposreal _ Rlt_0_1)) N) => /= {H2}  n [Hn].

  apply Rle_not_lt, Rlt_le, H1.

  by apply le_trans with (2 := le_n_Sn _).

  by [].

  have : False => //.

  case: (H1 0) => {H1} N H1.

  case: (H2 0 N)=> {H2} n [Hn].

  apply Rle_not_lt, Rlt_le, H1.

  by apply le_trans with (2 := le_n_Sn _).

  have : False => //.

  case: (proj2 (H2 (mkposreal _ Rlt_0_1))) => /= {H2} N H2.

  case: (H1 (l2-1) (S N)) ;

  case => [ | n] [Hn].

  by apply le_Sn_0 in Hn.

  by apply Rle_not_lt, Rlt_le, H2, le_S_n.

  have : False => //.

  case: (H2 0) => {H2} N H2.

  case: (H1 0 (S N)) ;

  case => [ | n] [Hn].

  by apply le_Sn_0 in Hn.

  by apply Rle_not_lt, Rlt_le, H2, le_S_n.

  by [].



  rewrite /LimSup_seq ;

  case: ex_LimSup_seq => l1 H1 ;

  case: ex_LimSup_seq => l2 H2 /= ;

  case: l1 H1 => [l1 | | ] /= H1 ;

  case: l2 H2 => [l2 | | ] /= H2.

  apply Rbar_finite_eq, Rle_antisym ;

  apply le_epsilon => e He ; set eps := mkposreal e He ;

  apply Rlt_le.

  case: (proj2 (H2 (pos_div_2 eps))) => /= {H2} N H2.

  case: ((proj1 (H1 (pos_div_2 eps))) (S N)) ;

  case => /= {H1} [ | n] [Hn H1].

  by apply le_Sn_0 in Hn.

  replace l1 with ((l1-e/2)+e/2) by ring.

  replace (l2+e) with ((l2+e/2)+e/2) by field.

  apply Rplus_lt_compat_r.

  apply Rlt_trans with (1 := H1).

  by apply H2, le_S_n.

  case: (proj2 (H1 (pos_div_2 eps))) => /= {H1} N H1.

  case: ((proj1 (H2 (pos_div_2 eps))) N) => /= {H2} n [Hn H2].

  replace l2 with ((l2-e/2)+e/2) by ring.

  replace (l1+e) with ((l1+e/2)+e/2) by field.

  apply Rplus_lt_compat_r.

  apply Rlt_trans with (1 := H2).

  by apply H1, le_trans with (2 := le_n_Sn _).

  have : False => //.

  case: (proj2 (H1 (mkposreal _ Rlt_0_1))) => /= {H1} N H1.

  case: (H2 (l1+1) N) => n [Hn].

  by apply Rle_not_lt, Rlt_le, H1, le_trans with (2 := le_n_Sn _).

  have : False => //.

  case: (H2 (l1-1)) => {H2} N H2.

  case: (proj1 (H1 (mkposreal _ Rlt_0_1)) (S N)) ;

  case => [ | n] [Hn] /= .

  by apply le_Sn_0 in Hn.

  by apply Rle_not_lt, Rlt_le, H2, le_S_n.

  have : False => //.

  case: (proj2 (H2 (mkposreal _ Rlt_0_1))) => {H2} /= N H2.

  case: (H1 (l2+1) (S N)) ;

  case => [ | n] [Hn] /= .

  by apply le_Sn_0 in Hn.

  by apply Rle_not_lt, Rlt_le, H2, le_S_n.

  by [].

  have : False => //.

  case: (H2 0) => {H2} N H2.

  case: (H1 0 (S N)) ;

  case => [ | n] [Hn] /= .

  by apply le_Sn_0 in Hn.

  by apply Rle_not_lt, Rlt_le, H2, le_S_n.

  have : False => //.

  case: (H1 (l2-1)) => {H1} N H1.

  case: (proj1 (H2 (mkposreal _ Rlt_0_1)) N) => /= {H2} n [Hn].

  by apply Rle_not_lt, Rlt_le, H1, le_trans with (2 := le_n_Sn _).

  have : False => //.

  case: (H1 0) => {H1} N H1.

  case: (H2 0 N) => {H2} n [Hn].

  by apply Rle_not_lt, Rlt_le, H1, le_trans with (2 := le_n_Sn _).

  by [].

Qed.



Lemma is_lim_seq_incr_n (u : nat -> R) (N : nat) (l : Rbar) :

  is_lim_seq u l <-> is_lim_seq (fun n => u (n + N)%nat) l.

Proof.

  split.

  elim: N u => [ | N IH] u Hu.

  move: Hu ; apply is_lim_seq_ext => n ; by rewrite plus_0_r.

  apply is_lim_seq_incr_1, IH in Hu.

  move: Hu ; by apply is_lim_seq_ext => n ; by rewrite plus_n_Sm.

  elim: N u => [ | N IH] u Hu.

  move: Hu ; apply is_lim_seq_ext => n ; by rewrite plus_0_r.

  apply is_lim_seq_incr_1, IH.

  move: Hu ; by apply is_lim_seq_ext => n ; by rewrite plus_n_Sm.

Qed.

Lemma ex_lim_seq_incr_n (u : nat -> R) (N : nat) :

  ex_lim_seq u <-> ex_lim_seq (fun n => u (n + N)%nat).

Proof.

  split ; move => [l H] ; exists l.

  by apply -> is_lim_seq_incr_n.

  by apply is_lim_seq_incr_n in H.

Qed.

Lemma Lim_seq_incr_n (u : nat -> R) (N : nat) :

  Lim_seq (fun n => u (n + N)%nat) = Lim_seq u.

Proof.

  elim: N u => [ | N IH] u.

  apply Lim_seq_ext => n ; by rewrite plus_0_r.

  rewrite -(Lim_seq_incr_1 u) -(IH (fun n => u (S n))).

  apply Lim_seq_ext => n ; by rewrite plus_n_Sm.

Qed.



Lemma filterlim_le :

  forall {T F} {FF : ProperFilter' F} (f g : T -> R) (lf lg : Rbar),

  F (fun x => f x <= g x) ->

  filterlim f F (Rbar_locally lf) ->

  filterlim g F (Rbar_locally lg) ->

  Rbar_le lf lg.

Proof.

intros T F FF f g lf lg H Hf Hg.

apply Rbar_not_lt_le.

intros Hl.

apply filter_not_empty.

destruct lf as [lf| |] ; destruct lg as [lg| |] ; try easy.

- assert (Hl' : 0 < (lf - lg) / 2).

    apply Rdiv_lt_0_compat.

    now apply -> Rminus_lt_0.

    apply Rlt_R0_R2.

  assert (Hlf : locally lf (fun y => (lf + lg) / 2 < y)).

    apply open_gt.

    replace ((lf + lg) / 2) with (lf - (lf - lg) / 2) by field.

    apply Rabs_lt_between'.

    by rewrite /Rminus Rplus_opp_r Rabs_R0.

  assert (Hlg : locally lg (fun y => y < (lf + lg) / 2)).

    apply open_lt.

    replace ((lf + lg) / 2) with (lg + (lf - lg) / 2) by field.

    apply Rabs_lt_between'.

    by rewrite /Rminus Rplus_opp_r Rabs_R0.

  specialize (Hf _ Hlf).

  specialize (Hg _ Hlg).

  unfold filtermap in Hf, Hg.

  generalize (filter_and _ _ (filter_and _ _ Hf Hg) H).

  apply filter_imp.

  intros x [[H1 H2] H3].

  apply Rle_not_lt with (1 := H3).

  now apply Rlt_trans with ((lf + lg) / 2).

- assert (Hlf : locally lf (fun y => lf - 1 < y)).

    apply open_gt.

    apply Rabs_lt_between'.

    rewrite /Rminus Rplus_opp_r Rabs_R0.

    apply Rlt_0_1.

  assert (Hlg : Rbar_locally m_infty (fun y => Rbar_lt y (lf - 1))).

    now apply open_Rbar_lt'.

  specialize (Hf _ Hlf).

  specialize (Hg _ Hlg).

  unfold filtermap in Hf, Hg.

  generalize (filter_and _ _ (filter_and _ _ Hf Hg) H).

  apply filter_imp.

  intros x [[H1 H2] H3].

  apply Rle_not_lt with (1 := H3).

  now apply Rlt_trans with (lf - 1).

- assert (Hlf : Rbar_locally p_infty (fun y => Rbar_lt (lg + 1) y)).

    now apply open_Rbar_gt'.

  assert (Hlg : locally lg (fun y => y < lg + 1)).

    apply open_lt.

    apply Rabs_lt_between'.

    rewrite /Rminus Rplus_opp_r Rabs_R0.

    apply Rlt_0_1.

  specialize (Hf _ Hlf).

  specialize (Hg _ Hlg).

  unfold filtermap in Hf, Hg.

  generalize (filter_and _ _ (filter_and _ _ Hf Hg) H).

  apply filter_imp.

  intros x [[H1 H2] H3].

  apply Rle_not_lt with (1 := H3).

  now apply Rlt_trans with (lg + 1).

- assert (Hlf : Rbar_locally p_infty (fun y => Rbar_lt 0 y)).

    now apply open_Rbar_gt'.

  assert (Hlg : Rbar_locally m_infty (fun y => Rbar_lt y 0)).

    now apply open_Rbar_lt'.

  specialize (Hf _ Hlf).

  specialize (Hg _ Hlg).

  unfold filtermap in Hf, Hg.

  generalize (filter_and _ _ (filter_and _ _ Hf Hg) H).

  apply filter_imp.

  intros x [[H1 H2] H3].

  apply Rle_not_lt with (1 := H3).

  now apply Rlt_trans with 0.

Qed.



Lemma is_lim_seq_le_loc (u v : nat -> R) (l1 l2 : Rbar) :

  eventually (fun n => u n <= v n) ->

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  Rbar_le l1 l2.

Proof.

  apply filterlim_le.

Qed.

Lemma Lim_seq_le_loc (u v : nat -> R) :

  eventually (fun n => u n <= v n) ->

  Rbar_le (Lim_seq u) (Lim_seq v).

Proof.

  intros.

  move: (LimSup_le _ _ H) (LimInf_le _ _ H).

  move: (LimSup_LimInf_seq_le u) (LimSup_LimInf_seq_le v).

  unfold Lim_seq.

  case: (LimSup_seq u) => [lsu | | ] //= ;

  case: (LimInf_seq u) => [liu | | ] //= ;

  case: (LimSup_seq v) => [lsv | | ] //= ;

  case: (LimInf_seq v) => [liv | | ] //= ;

  intros.

  apply Rmult_le_compat_r.

  apply Rlt_le, Rinv_0_lt_compat, Rlt_0_2.

  by apply Rplus_le_compat.

  by apply Req_le.

Qed.



Lemma is_lim_seq_le (u v : nat -> R) (l1 l2 : Rbar) :

  (forall n, u n <= v n) -> is_lim_seq u l1 -> is_lim_seq v l2 -> Rbar_le l1 l2.

Proof.

  intros H.

  apply filterlim_le.

  now apply filter_forall.

Qed.



Lemma filterlim_ge_p_infty :

  forall {T F} {FF : Filter F} (f g : T -> R),

  F (fun x => f x <= g x) ->

  filterlim f F (Rbar_locally p_infty) ->

  filterlim g F (Rbar_locally p_infty).

Proof.

intros T F FF f g H Hf.

intros P [M HM].

assert (H' : Rbar_locally p_infty (fun y => M < y)).

  now exists M.

unfold filtermap.

generalize (filter_and (fun x : T => f x <= g x) _ H (Hf (fun y : R => M < y) H')).

apply filter_imp.

intros x [H1 H2].

apply HM.

now apply Rlt_le_trans with (f x).

Qed.



Lemma filterlim_le_m_infty :

  forall {T F} {FF : Filter F} (f g : T -> R),

  F (fun x => g x <= f x) ->

  filterlim f F (Rbar_locally m_infty) ->

  filterlim g F (Rbar_locally m_infty).

Proof.

intros T F FF f g H Hf.

intros P [M HM].

pose ineq (y : R) := y < M.

assert (H' : Rbar_locally m_infty ineq).

  now exists M.

unfold filtermap.

generalize (filter_and _ (fun x : T => ineq (f x)) H (Hf ineq H')).

apply filter_imp.

intros x [H1 H2].

apply HM.

now apply Rle_lt_trans with (f x).

Qed.



Lemma filterlim_le_le :

  forall {T F} {FF : Filter F} (f g h : T -> R) (l : Rbar),

  F (fun x => f x <= g x <= h x) ->

  filterlim f F (Rbar_locally l) ->

  filterlim h F (Rbar_locally l) ->

  filterlim g F (Rbar_locally l).

Proof.

intros T F FF f g h l H Hf Hh.

destruct l as [l| |].

- intros P [eps He].

  assert (H' : Rbar_locally l (fun y => Rabs (y - l) < eps)).

    now exists eps.

  unfold filterlim, filter_le, filtermap in Hf, Hh |- *.

  generalize (filter_and _ _ H (filter_and _ _ (Hf _ H') (Hh _ H'))).

  apply filter_imp.

  intros x [H1 [H2 H3]].

  apply He.

  apply Rabs_lt_between'.

  split.

  apply Rlt_le_trans with (2 := proj1 H1).

  now apply Rabs_lt_between'.

  apply Rle_lt_trans with (1 := proj2 H1).

  now apply Rabs_lt_between'.

- apply filterlim_ge_p_infty with (2 := Hf).

  apply: filter_imp H.

  now intros x [H _].

- apply filterlim_le_m_infty with (2 := Hh).

  apply: filter_imp H.

  now intros x [_ H].

Qed.



Lemma is_lim_seq_le_le_loc (u v w : nat -> R) (l : Rbar) :

  eventually (fun n => u n <= v n <= w n) -> is_lim_seq u l -> is_lim_seq w l -> is_lim_seq v l.

Proof.

  apply filterlim_le_le.

Qed.



Lemma is_lim_seq_le_le (u v w : nat -> R) (l : Rbar) :

  (forall n, u n <= v n <= w n) -> is_lim_seq u l -> is_lim_seq w l -> is_lim_seq v l.

Proof.

  intros H.

  apply filterlim_le_le.

  now apply filter_forall.

Qed.



Lemma is_lim_seq_le_p_loc (u v : nat -> R) :

  eventually (fun n => u n <= v n) ->

  is_lim_seq u p_infty ->

  is_lim_seq v p_infty.

Proof.

  apply filterlim_ge_p_infty.

Qed.



Lemma is_lim_seq_le_m_loc (u v : nat -> R) :

  eventually (fun n => v n <= u n) ->

  is_lim_seq u m_infty ->

  is_lim_seq v m_infty.

Proof.

  apply filterlim_le_m_infty.

Qed.



Lemma is_lim_seq_decr_compare (u : nat -> R) (l : R) :

  is_lim_seq u l

  -> (forall n, (u (S n)) <= (u n))

  -> forall n, l <= u n.

Proof.

  move /is_lim_seq_spec => Hu H n.

  apply Rnot_lt_le => H0.

  apply Rminus_lt_0 in H0.

  case: (Hu (mkposreal _ H0)) => {Hu} /= Nu Hu.

  move: (Hu _ (le_plus_r n Nu)).

  apply Rle_not_lt.

  apply Rle_trans with (2 := Rabs_maj2 _).

  rewrite Ropp_minus_distr'.

  apply Rplus_le_compat_l.

  apply Ropp_le_contravar.

  elim: (Nu) => [ | m IH].

  rewrite plus_0_r ; by apply Rle_refl.

  rewrite -plus_n_Sm.

  apply Rle_trans with (2 := IH).

  by apply H.

Qed.

Lemma is_lim_seq_incr_compare (u : nat -> R) (l : R) :

  is_lim_seq u l

  -> (forall n, (u n) <= (u (S n)))

  -> forall n, u n <= l.

Proof.

  move /is_lim_seq_spec => Hu H n.

  apply Rnot_lt_le => H0.

  apply Rminus_lt_0 in H0.

  case: (Hu (mkposreal _ H0)) => {Hu} /= Nu Hu.

  move: (Hu _ (le_plus_r n Nu)).

  apply Rle_not_lt.

  apply Rle_trans with (2 := Rle_abs _).

  apply Rplus_le_compat_r.

  elim: (Nu) => [ | m IH].

  rewrite plus_0_r ; by apply Rle_refl.

  rewrite -plus_n_Sm.

  apply Rle_trans with (1 := IH).

  by apply H.

Qed.



Lemma ex_lim_seq_decr (u : nat -> R) :

  (forall n, (u (S n)) <= (u n))

    -> ex_lim_seq u.

Proof.

  move => H.

  exists (Inf_seq u).

  apply is_lim_seq_spec.

  rewrite /Inf_seq ; case: ex_inf_seq ; case => [l | | ] //= Hl.

  move => eps ; case: (Hl eps) => Hl1 [N Hl2].

  exists N => n Hn.

  apply Rabs_lt_between' ; split.

  by apply Hl1.

  apply Rle_lt_trans with (2 := Hl2).

  elim: n N {Hl2} Hn => [ | n IH] N Hn.

  rewrite (le_n_O_eq _ Hn).

  apply Rle_refl.

  apply le_lt_eq_dec in Hn.

  case: Hn => [Hn | ->].

  apply Rle_trans with (1 := H _), IH ; intuition.

  by apply Rle_refl.

  move => M ; exists O => n _ ; by apply Hl.

  move => M.

  case: (Hl M) => {Hl} N Hl.

  exists N => n Hn.

  apply Rle_lt_trans with (2 := Hl).

  elim: Hn => [ | {n} n Hn IH].

  by apply Rle_refl.

  apply Rle_trans with (2 := IH).

  by apply H.

Qed.

Lemma ex_lim_seq_incr (u : nat -> R) :

  (forall n, (u n) <= (u (S n)))

    -> ex_lim_seq u.

Proof.

  move => H.

  exists (Sup_seq u).

  apply is_lim_seq_spec.

  rewrite /Sup_seq ; case: ex_sup_seq ; case => [l | | ] //= Hl.

  move => eps ; case: (Hl eps) => Hl1 [N Hl2].

  exists N => n Hn.

  apply Rabs_lt_between' ; split.

  apply Rlt_le_trans with (1 := Hl2).

  elim: Hn => [ | {n} n Hn IH].

  by apply Rle_refl.

  apply Rle_trans with (1 := IH).

  by apply H.

  by apply Hl1.

  move => M.

  case: (Hl M) => {Hl} N Hl.

  exists N => n Hn.

  apply Rlt_le_trans with (1 := Hl).

  elim: Hn => [ | {n} n Hn IH].

  by apply Rle_refl.

  apply Rle_trans with (1 := IH).

  by apply H.

  move => M ; exists O => n Hn ; by apply Hl.

Qed.



Lemma ex_finite_lim_seq_decr (u : nat -> R) (M : R) :

  (forall n, (u (S n)) <= (u n)) -> (forall n, M <= u n)

    -> ex_finite_lim_seq u.

Proof.

  intros.

  apply ex_finite_lim_seq_correct.

  have H1 : ex_lim_seq u.

  exists (real (Inf_seq u)).

  apply is_lim_seq_spec.

  rewrite /Inf_seq ; case: ex_inf_seq ; case => [l | | ] //= Hl.

  move => eps ; case: (Hl eps) => Hl1 [N Hl2].

  exists N => n Hn.

  apply Rabs_lt_between' ; split.

  by apply Hl1.

  apply Rle_lt_trans with (2 := Hl2).

  elim: n N {Hl2} Hn => [ | n IH] N Hn.

  rewrite (le_n_O_eq _ Hn).

  apply Rle_refl.

  apply le_lt_eq_dec in Hn.

  case: Hn => [Hn | ->].

  apply Rle_trans with (1 := H _), IH ; intuition.

  by apply Rle_refl.

  move: (Hl (u O) O) => H1 ; by apply Rlt_irrefl in H1.

  case: (Hl M) => {Hl} n Hl.

  apply Rlt_not_le in Hl.

  by move: (Hl (H0 n)).

  split => //.

  apply Lim_seq_correct in H1.

  case: (Lim_seq u) H1 => [l | | ] /= Hu.

  by [].

  apply is_lim_seq_spec in Hu.

  case: (Hu (u O)) => {Hu} N Hu.

  move: (Hu N (le_refl _)) => {Hu} Hu.

  contradict Hu ; apply Rle_not_lt.

  elim: N => [ | N IH].

  by apply Rle_refl.

  by apply Rle_trans with (1 := H _).

  apply is_lim_seq_spec in Hu.

  case: (Hu M) => {Hu} N Hu.

  move: (Hu N (le_refl _)) => {Hu} Hu.

  contradict Hu ; by apply Rle_not_lt.

Qed.

Lemma ex_finite_lim_seq_incr (u : nat -> R) (M : R) :

  (forall n, (u n) <= (u (S n))) -> (forall n, u n <= M)

    -> ex_finite_lim_seq u.

Proof.

  intros.

  case: (ex_finite_lim_seq_decr (fun n => - u n) (- M)).

  move => n ; by apply Ropp_le_contravar.

  move => n ; by apply Ropp_le_contravar.

  move => l ; move => Hu.

  exists (- l).

  apply is_lim_seq_spec in Hu.

  apply is_lim_seq_spec.

  intros eps.

  case: (Hu eps) => {Hu} N Hu.

  exists N => n Hn.

  replace (u n - - l) with (-(- u n - l)) by ring.

  rewrite Rabs_Ropp ; by apply Hu.

Qed.



Lemma filterlim_Rbar_opp :

  forall x,

  filterlim Ropp (Rbar_locally x) (Rbar_locally (Rbar_opp x)).

Proof.

intros [x| |] P [eps He].

- exists eps.

  intros y Hy.

  apply He.

  rewrite /ball /= /AbsRing_ball /abs /minus /plus /opp /=.

  by rewrite Ropp_involutive Rplus_comm Rabs_minus_sym.

- exists (-eps).

  intros y Hy.

  apply He.

  apply Ropp_lt_cancel.

  by rewrite Ropp_involutive.

- exists (-eps).

  intros y Hy.

  apply He.

  apply Ropp_lt_cancel.

  by rewrite Ropp_involutive.

Qed.



Lemma is_lim_seq_opp (u : nat -> R) (l : Rbar) :

  is_lim_seq u l <-> is_lim_seq (fun n => -u n) (Rbar_opp l).

Proof.

  split ; move => Hu.

  apply is_LimSup_LimInf_lim_seq.

  apply is_LimSup_opp_LimInf_seq.

  by apply is_lim_LimInf_seq.

  apply is_LimInf_opp_LimSup_seq.

  by apply is_lim_LimSup_seq.

  apply is_LimSup_LimInf_lim_seq.

  apply is_LimInf_opp_LimSup_seq.

  by apply is_lim_LimInf_seq.

  apply is_LimSup_opp_LimInf_seq.

  by apply is_lim_LimSup_seq.

Qed.



Lemma ex_lim_seq_opp (u : nat -> R) :

  ex_lim_seq u <-> ex_lim_seq (fun n => -u n).

Proof.

  split ; case => l Hl ; exists (Rbar_opp l).

  by apply -> is_lim_seq_opp.

  apply is_lim_seq_ext with (fun n => - - u n).

  move => n ; by apply Ropp_involutive.

  by apply -> is_lim_seq_opp.

Qed.



Lemma Lim_seq_opp (u : nat -> R) :

  Lim_seq (fun n => - u n) = Rbar_opp (Lim_seq u).

Proof.

  rewrite /Lim_seq.

  rewrite LimSup_seq_opp LimInf_seq_opp.

  case: (LimInf_seq u) => [li | | ] ;

  case: (LimSup_seq u) => [ls | | ] //= ;

  apply f_equal ; field.

Qed.



Lemma filterlim_Rbar_plus :

  forall x y z,

  is_Rbar_plus x y z ->

  filterlim (fun z => fst z + snd z) (filter_prod (Rbar_locally x) (Rbar_locally y)) (Rbar_locally z).

Proof.

  intros x y z.

  wlog: x y z / (Rbar_le 0 z).

    intros Hw.

    case: (Rbar_le_lt_dec 0 z) => Hz Hp.

    by apply Hw.

    apply (filterlim_ext (fun z => - (- fst z + - snd z))).

    intros t.

    ring.

    rewrite -(Rbar_opp_involutive z).

    eapply filterlim_comp.

    2: apply filterlim_Rbar_opp.

    assert (Hw' : filterlim (fun z => fst z + snd z) (filter_prod (Rbar_locally (Rbar_opp x)) (Rbar_locally (Rbar_opp y))) (Rbar_locally (Rbar_opp z))).

    apply Hw.

    rewrite -Ropp_0 -/(Rbar_opp 0).

    apply <- Rbar_opp_le.

    now apply Rbar_lt_le.

    revert Hp.

    clear.

    destruct x as [x| |] ; destruct y as [y| |] ; destruct z as [z| |] => //=.

    unfold is_Rbar_plus ; simpl => H.

    injection H => <-.

    apply f_equal, f_equal ; ring.

    clear Hw.

    intros P HP.

    specialize (Hw' P HP).

    destruct Hw' as [Q R H1 H2 H3].

    exists (fun x => Q (- x)) (fun x => R (- x)).

    now apply filterlim_Rbar_opp.

    now apply filterlim_Rbar_opp.

    intros u v HQ HR.

    exact (H3 _ _ HQ HR).



  unfold is_Rbar_plus.

  case: z => [z| |] Hz Hp ;

  try by case: Hz.



  case: x y Hp Hz => [x| |] ; case => [y| |] //= ; case => <- Hz.

  intros P [eps He].

  exists (fun u => Rabs (u - x) < pos_div_2 eps) (fun v => Rabs (v - y) < pos_div_2 eps).

  now exists (pos_div_2 eps).

  now exists (pos_div_2 eps).

  intros u v Hu Hv.

  apply He.

  rewrite /ball /= /AbsRing_ball /abs /minus /plus /opp /=.

  replace (u + v + - (x + y)) with ((u - x) + (v - y)) by ring.

  rewrite (double_var eps) ;

  apply Rle_lt_trans with (1 := Rabs_triang _ _), Rplus_lt_compat.

  now apply Hu.

  now apply Hv.



  wlog: x y Hp {Hz} / (is_finite x) => [Hw|Hx].

    case: x y Hp {Hz} => [x| |] ;

    case => [y| |] // _.

    now apply (Hw x p_infty).

    assert (Hw': filterlim (fun z => fst z + snd z) (filter_prod (Rbar_locally y) (Rbar_locally p_infty)) (Rbar_locally p_infty)).

    exact: Hw.

    intros P HP.

    specialize (Hw' P HP).

    destruct Hw' as [Q R H1 H2 H3].

    exists R Q ; try assumption.

    intros u v Hu Hv.

    rewrite Rplus_comm.

    now apply (H3 v u).

    clear Hw.

    intros P [N HN].

    exists (fun x => N/2 < x) (fun x => N/2 < x).

    now exists (N/2).

    now exists (N/2).

    intros x y Hx Hy.

    simpl.

    apply HN.

    rewrite (double_var N).

    now apply Rplus_lt_compat.

  case: x y Hp Hx => [x| |] ;

  case => [y| | ] //= _ _.

  intros P [N HN].

  exists (fun u => Rabs (u - x) < 1) (fun v => N - x + 1 < v).

  now exists (mkposreal _ Rlt_0_1).

  now exists (N - x + 1).

  intros u v Hu Hv.

  simpl.

  apply HN.

  replace N with (x - 1 + (N - x + 1)) by ring.

  apply Rplus_lt_compat.

  now apply Rabs_lt_between'.

  exact Hv.

Qed.



Lemma is_lim_seq_plus (u v : nat -> R) (l1 l2 l : Rbar) :

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  is_Rbar_plus l1 l2 l ->

  is_lim_seq (fun n => u n + v n) l.

Proof.

intros Hu Hv Hl.

eapply filterlim_comp_2 ; try eassumption.

now apply filterlim_Rbar_plus.

Qed.

Lemma is_lim_seq_plus' (u v : nat -> R) (l1 l2 : R) :

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  is_lim_seq (fun n => u n + v n) (l1 + l2).

Proof.

intros Hu Hv.

eapply is_lim_seq_plus.

by apply Hu.

by apply Hv.

by [].

Qed.



Lemma ex_lim_seq_plus (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v ->

  ex_Rbar_plus (Lim_seq u) (Lim_seq v) ->

  ex_lim_seq (fun n => u n + v n).

Proof.

  intros [lu Hu] [lv Hv] Hl ; exists (Rbar_plus lu lv).

  apply is_lim_seq_plus with lu lv ; try assumption.

  rewrite -(is_lim_seq_unique u lu) //.

  rewrite -(is_lim_seq_unique v lv) //.

  by apply Rbar_plus_correct.

Qed.



Lemma Lim_seq_plus (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v ->

  ex_Rbar_plus (Lim_seq u) (Lim_seq v) ->

  Lim_seq (fun n => u n + v n) = Rbar_plus (Lim_seq u) (Lim_seq v).

Proof.

  intros Hu Hv Hl.

  apply is_lim_seq_unique.

  eapply is_lim_seq_plus ; try apply Lim_seq_correct ; try assumption.

  by apply Rbar_plus_correct.

Qed.



Lemma is_lim_seq_minus (u v : nat -> R) (l1 l2 l : Rbar) :

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  is_Rbar_minus l1 l2 l ->

  is_lim_seq (fun n => u n - v n) l.

Proof.

  intros H1 H2 Hl.

  eapply is_lim_seq_plus ; try eassumption.

  apply -> is_lim_seq_opp ; apply H2.

Qed.

Lemma is_lim_seq_minus' (u v : nat -> R) (l1 l2 : R) :

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  is_lim_seq (fun n => u n - v n) (l1 - l2).

Proof.

intros Hu Hv.

eapply is_lim_seq_minus ; try eassumption.

by [].

Qed.



Lemma ex_lim_seq_minus (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v ->

  ex_Rbar_minus (Lim_seq u) (Lim_seq v) ->

  ex_lim_seq (fun n => u n - v n).

Proof.

  intros [lu Hu] [lv Hv] Hl ; exists (Rbar_minus lu lv).

  eapply is_lim_seq_minus ; try eassumption.

  rewrite -(is_lim_seq_unique u lu) //.

  rewrite -(is_lim_seq_unique v lv) //.

  by apply Rbar_plus_correct.

Qed.



Lemma Lim_seq_minus (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v ->

  ex_Rbar_minus (Lim_seq u) (Lim_seq v) ->

  Lim_seq (fun n => u n - v n) = Rbar_minus (Lim_seq u) (Lim_seq v).

Proof.

  intros Hu Hv Hl.

  apply is_lim_seq_unique.

  eapply is_lim_seq_minus ; try apply Lim_seq_correct ; try assumption.

  by apply Rbar_plus_correct.

Qed.



Lemma filterlim_Rbar_inv :

  forall l : Rbar, l <> 0 ->

  filterlim Rinv (Rbar_locally l) (Rbar_locally (Rbar_inv l)).

Proof.

  intros l.

  wlog: l / (Rbar_lt 0 l).

    intros Hw.

    case: (Rbar_lt_le_dec 0 l) => Hl.

    by apply Hw.

    case: (Rbar_le_lt_or_eq_dec _ _ Hl) => // {Hl} Hl Hl0.

    rewrite -(Rbar_opp_involutive (Rbar_inv l)).

    replace (Rbar_opp (Rbar_inv l)) with (Rbar_inv (Rbar_opp l))

    by (case: (l) Hl0 => [x | | ] //= Hl0 ; apply f_equal ;

      field ; contradict Hl0 ; by apply f_equal).

    apply (filterlim_ext_loc (fun x => (- / - x))).

    case: l Hl {Hl0} => [l| |] //= Hl.

    apply Ropp_0_gt_lt_contravar in Hl.

    exists (mkposreal _ Hl) => /= x H.

    field ; apply Rlt_not_eq.

    rewrite /ball /= /AbsRing_ball /abs /minus /plus /opp /= in H.

    apply Rabs_lt_between' in H.

    apply Rlt_le_trans with (1 := proj2 H), Req_le.

    apply Rplus_opp_r.

    exists 0 => x H.

    field ; by apply Rlt_not_eq.

    eapply filterlim_comp.

    2: apply filterlim_Rbar_opp.

    eapply filterlim_comp.

    apply filterlim_Rbar_opp.

    apply Hw.

    apply Rbar_opp_lt.

    rewrite Rbar_opp_involutive /= Ropp_0 ; by apply Hl.

    contradict Hl0.

    rewrite -(Rbar_opp_involutive l) Hl0 /= ; apply f_equal ; ring.

  case: l => [l| |] //= Hl _.

  

  assert (H1: 0 < l / 2).

  apply Rdiv_lt_0_compat with (1 := Hl).

  apply Rlt_R0_R2.

  intros P [eps HP].

  suff He : 0 < Rmin (eps * ((l / 2) * l)) (l / 2).

  exists (mkposreal _ He) => x /= Hx.

  apply HP.

  assert (H2: l / 2 < x).

  apply Rle_lt_trans with (l - l / 2).

  apply Req_le ; field.

  apply Rabs_lt_between'.

  apply Rlt_le_trans with (1 := Hx).

  apply Rmin_r.

  assert (H3: 0 < x).

  now apply Rlt_trans with (l / 2).

  rewrite /ball /= /AbsRing_ball /abs /minus /plus /opp /=.

  replace (/ x + - / l) with (- (x - l) / (x * l)).

  rewrite Rabs_div.

  rewrite Rabs_Ropp.

  apply Rlt_div_l.

  apply Rabs_pos_lt, Rgt_not_eq.

  now apply Rmult_lt_0_compat.

  apply Rlt_le_trans with (eps * ((l / 2) * l)).

  apply Rlt_le_trans with (1 := Hx).

  apply Rmin_l.

  apply Rmult_le_compat_l.

  apply Rlt_le, eps.

  rewrite Rabs_mult.

  rewrite (Rabs_pos_eq l).

  apply Rmult_le_compat_r.

  now apply Rlt_le.

  apply Rle_trans with (2 := Rle_abs _).

  now apply Rlt_le.

  now apply Rlt_le.

  apply Rgt_not_eq.

  now apply Rmult_lt_0_compat.

  field ; split ; apply Rgt_not_eq => //.

  apply Rmin_case.

  apply Rmult_lt_0_compat.

  apply cond_pos.

  now apply Rmult_lt_0_compat.

  exact H1.

  

  intros P [eps HP].

  exists (/eps) => n Hn.

  apply HP.

  rewrite /ball /= /AbsRing_ball /abs /minus /plus /opp /=.

  rewrite Ropp_0 Rplus_0_r Rabs_Rinv.

  rewrite -(Rinv_involutive eps).

  apply Rinv_lt_contravar.

  apply Rmult_lt_0_compat.

  apply Rinv_0_lt_compat, eps.

  apply Rabs_pos_lt, Rgt_not_eq, Rlt_trans with (/eps).

  apply Rinv_0_lt_compat, eps.

  exact Hn.

  apply Rlt_le_trans with (2 := Rle_abs _).

  exact Hn.

  apply Rgt_not_eq, eps.

  apply Rgt_not_eq, Rlt_trans with (/eps).

  apply Rinv_0_lt_compat, eps.

  exact Hn.

Qed.



Lemma is_lim_seq_inv (u : nat -> R) (l : Rbar) :

  is_lim_seq u l -> l <> 0 ->

  is_lim_seq (fun n => / u n) (Rbar_inv l).

Proof.

intros Hu Hl.

apply filterlim_comp with (1 := Hu).

now apply filterlim_Rbar_inv.

Qed.



Lemma ex_lim_seq_inv (u : nat -> R) :

  ex_lim_seq u

  -> Lim_seq u <> 0

    -> ex_lim_seq (fun n => / u n).

Proof.

  intros.

  apply Lim_seq_correct in H.

  exists (Rbar_inv (Lim_seq u)).

  by apply is_lim_seq_inv.

Qed.



Lemma Lim_seq_inv (u : nat -> R) :

  ex_lim_seq u -> (Lim_seq u <> 0)

    -> Lim_seq (fun n => / u n) = Rbar_inv (Lim_seq u).

Proof.

  move => Hl Hu.

  apply is_lim_seq_unique.

  apply is_lim_seq_inv.

  by apply Lim_seq_correct.

  by apply Hu.

Qed.



Lemma filterlim_Rbar_mult :

  forall x y z,

  is_Rbar_mult x y z ->

  filterlim (fun z => fst z * snd z) (filter_prod (Rbar_locally x) (Rbar_locally y)) (Rbar_locally z).

Proof.

  intros x y z.

  wlog: x y z / (Rbar_le 0 x).

    intros Hw.

    case: (Rbar_le_lt_dec 0 x) => Hx Hp.

    by apply Hw.

    apply (filterlim_ext (fun z => - (- fst z * snd z))).

    intros t.

    ring.

    rewrite -(Rbar_opp_involutive z).

    eapply filterlim_comp.

    2: apply filterlim_Rbar_opp.

    assert (Hw' : filterlim (fun z => fst z * snd z) (filter_prod (Rbar_locally (Rbar_opp x)) (Rbar_locally y)) (Rbar_locally (Rbar_opp z))).

    apply Hw.

    replace (Finite 0) with (Rbar_opp 0) by apply (f_equal Finite), Ropp_0.

    apply Rbar_opp_le.

    by apply Rbar_lt_le.

    by apply is_Rbar_mult_opp_l.

    clear Hw.

    intros P HP.

    specialize (Hw' P HP).

    destruct Hw' as [Q R H1 H2 H3].

    exists (fun x => Q (- x)) R.

    now apply filterlim_Rbar_opp.

    exact H2.

    intros u v HQ HR.

    exact (H3 _ _ HQ HR).

  wlog: x y z / (Rbar_le 0 y).

    intros Hw.

    case: (Rbar_le_lt_dec 0 y) => Hy Hx Hp.

    by apply Hw.

    apply (filterlim_ext (fun z => - (fst z * -snd z))).

    intros t.

    ring.

    rewrite -(Rbar_opp_involutive z).

    eapply filterlim_comp.

    2: apply filterlim_Rbar_opp.

    assert (Hw' : filterlim (fun z => fst z * snd z) (filter_prod (Rbar_locally x) (Rbar_locally (Rbar_opp y))) (Rbar_locally (Rbar_opp z))).

    apply Hw.

    replace (Finite 0) with (Rbar_opp 0) by apply (f_equal Finite), Ropp_0.

    apply Rbar_opp_le.

    by apply Rbar_lt_le.

    by [].

    by apply is_Rbar_mult_opp_r.

    clear Hw.

    intros P HP.

    specialize (Hw' P HP).

    destruct Hw' as [Q R H1 H2 H3].

    exists Q (fun x => R (- x)).

    exact H1.

    now apply filterlim_Rbar_opp.

    intros u v HQ HR.

    exact (H3 _ _ HQ HR).

  wlog: x y z / (Rbar_le x y).

    intros Hw.

    case: (Rbar_le_lt_dec x y) => Hl Hx Hy Hp.

    by apply Hw.

    assert (Hw' : filterlim (fun z => fst z * snd z) (filter_prod (Rbar_locally y) (Rbar_locally x)) (Rbar_locally z)).

    apply Hw ; try assumption.

    by apply Rbar_lt_le.

    by apply is_Rbar_mult_sym.

    intros P HP.

    specialize (Hw' P HP).

    destruct Hw' as [Q R H1 H2 H3].

    exists R Q ; try assumption.

    intros u v HR HQ.

    simpl.

    rewrite Rmult_comm.

    exact (H3 _ _ HQ HR).

  case: x => [x| | ] ; case: y => [y| | ] ; case: z => [z| | ] Hl Hy Hx Hp ;

  try (by case: Hl) || (by case: Hx) || (by case: Hy).



  case: Hp => <-.

  intros P [eps HP].

  assert (He: 0 < eps / (x + y + 1)).

  apply Rdiv_lt_0_compat.

  apply cond_pos.

  apply Rplus_le_lt_0_compat.

  now apply Rplus_le_le_0_compat.

  apply Rlt_0_1.

  set (d := mkposreal _ (Rmin_stable_in_posreal (mkposreal _ Rlt_0_1) (mkposreal _ He))).

  exists (fun u => Rabs (u - x) < d) (fun v => Rabs (v - y) < d).

  now exists d.

  now exists d.

  simpl.

  intros u v Hu Hv.

  apply HP.

  rewrite /ball /= /AbsRing_ball /abs /minus /plus /opp /=.

  replace (u * v + - (x * y)) with (x * (v - y) + y * (u - x) + (u - x) * (v - y)) by ring.

  replace (pos eps) with (x * (eps / (x + y + 1)) + y * (eps / (x + y + 1)) + 1 * (eps / (x + y + 1))).

  apply Rle_lt_trans with (1 := Rabs_triang _ _).

  apply Rplus_le_lt_compat.

  apply Rle_trans with (1 := Rabs_triang _ _).

  apply Rplus_le_compat.

  rewrite Rabs_mult Rabs_pos_eq //.

  apply Rmult_le_compat_l with (1 := Hx).

  apply Rlt_le.

  apply Rlt_le_trans with (1 := Hv).

  apply Rmin_r.

  rewrite Rabs_mult Rabs_pos_eq //.

  apply Rmult_le_compat_l with (1 := Hy).

  apply Rlt_le.

  apply Rlt_le_trans with (1 := Hu).

  apply Rmin_r.

  rewrite Rabs_mult.

  apply Rmult_le_0_lt_compat ; try apply Rabs_pos.

  apply Rlt_le_trans with (1 := Hu).

  apply Rmin_l.

  apply Rlt_le_trans with (1 := Hv).

  apply Rmin_r.

  field.

  apply Rgt_not_eq.

  apply Rplus_le_lt_0_compat.

  now apply Rplus_le_le_0_compat.

  apply Rlt_0_1.



  move: Hp ; unfold is_Rbar_mult, Rbar_mult'.

  case: Rle_dec => // Hx'.

  case: Rle_lt_or_eq_dec => {Hl Hx Hy Hx'} // Hx.

  move: Hp ; unfold is_Rbar_mult, Rbar_mult'.

  case: Rle_dec => // Hx'.

  case: Rle_lt_or_eq_dec => {Hl Hx Hy Hx'} // Hx _.

  intros P [N HN].

  exists (fun u => Rabs (u - x) < x / 2) (fun v => Rmax 0 (N / (x / 2)) < v).

  now exists (pos_div_2 (mkposreal _ Hx)).

  now exists (Rmax 0 (N / (x / 2))).

  intros u v Hu Hv.

  simpl.

  apply HN.

  apply Rle_lt_trans with ((x - x / 2) * Rmax 0 (N / (x / 2))).

  apply Rmax_case_strong => H.

  rewrite Rmult_0_r ; apply Rnot_lt_le ; contradict H ; apply Rlt_not_le.

  repeat apply Rdiv_lt_0_compat => //.

  by apply Rlt_R0_R2.

  apply Req_le ; field.

  by apply Rgt_not_eq.

  apply Rmult_le_0_lt_compat.

  lra.

  apply Rmax_l.

  now apply Rabs_lt_between'.

  exact Hv.

  move: Hp ; unfold is_Rbar_mult, Rbar_mult'.

  case: Rle_dec => // Hx'.

  case: Rle_lt_or_eq_dec => {Hl Hx Hy Hx'} // Hx.



  clear.

  intros P [N HN].

  exists (fun u => 1 < u) (fun v => Rabs N < v).

  now exists 1.

  now exists (Rabs N).

  intros u v Hu Hv.

  simpl.

  apply HN.

  apply Rle_lt_trans with (1 := Rle_abs _).

  rewrite -(Rmult_1_l (Rabs N)).

  apply Rmult_le_0_lt_compat.

  by apply Rle_0_1.

  by apply Rabs_pos.

  exact Hu.

  exact Hv.

Qed.



Lemma is_lim_seq_mult (u v : nat -> R) (l1 l2 l : Rbar) :

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  is_Rbar_mult l1 l2 l ->

  is_lim_seq (fun n => u n * v n) l.

Proof.

intros Hu Hv Hp.

eapply filterlim_comp_2 ; try eassumption.

now apply filterlim_Rbar_mult.

Qed.

Lemma is_lim_seq_mult' (u v : nat -> R) (l1 l2 : R) :

  is_lim_seq u l1 -> is_lim_seq v l2 ->

  is_lim_seq (fun n => u n * v n) (l1 * l2).

Proof.

intros Hu Hv.

eapply is_lim_seq_mult ; try eassumption.

by [].

Qed.



Lemma ex_lim_seq_mult (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v ->

  ex_Rbar_mult (Lim_seq u) (Lim_seq v) ->

  ex_lim_seq (fun n => u n * v n).

Proof.

  intros [lu Hu] [lv Hv] H ; exists (Rbar_mult lu lv).

  eapply is_lim_seq_mult ; try eassumption.

  rewrite -(is_lim_seq_unique u lu) //.

  rewrite -(is_lim_seq_unique v lv) //.

  by apply Rbar_mult_correct.

Qed.



Lemma Lim_seq_mult (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v ->

  ex_Rbar_mult (Lim_seq u) (Lim_seq v) ->

  Lim_seq (fun n => u n * v n) = Rbar_mult (Lim_seq u) (Lim_seq v).

Proof.

  move => H1 H2 Hl.

  apply is_lim_seq_unique.

  eapply is_lim_seq_mult ; try apply Lim_seq_correct ; try eassumption.

  by apply Rbar_mult_correct.

Qed.



Lemma filterlim_Rbar_mult_l :

  forall (a : R) (l : Rbar),

  filterlim (Rmult a) (Rbar_locally l) (Rbar_locally (Rbar_mult a l)).

Proof.

  intros a l.

  case: (Req_dec a 0) => [->|Ha].

  apply (filterlim_ext (fun _ => 0)).

  intros x.

  apply sym_eq, Rmult_0_l.

  rewrite Rbar_mult_0_l.

  apply filterlim_const.

  eapply filterlim_comp_2.

  apply filterlim_const.

  apply filterlim_id.

  eapply (filterlim_Rbar_mult a l).

  apply Rbar_mult_correct ; by case: l.

Qed.



Lemma filterlim_Rbar_mult_r :

  forall (a : R) (l : Rbar),

  filterlim (fun x => Rmult x a) (Rbar_locally l) (Rbar_locally (Rbar_mult l a)).

Proof.

intros a l.

apply (filterlim_ext (fun x => a * x)).

apply Rmult_comm.

rewrite Rbar_mult_comm.

apply filterlim_Rbar_mult_l.

Qed.



Lemma is_lim_seq_scal_l (u : nat -> R) (a : R) (lu : Rbar) :

  is_lim_seq u lu ->

  is_lim_seq (fun n => a * u n) (Rbar_mult a lu).

Proof.

intros Hu H.

apply filterlim_comp with (1 := Hu).

by apply filterlim_Rbar_mult_l.

Qed.



Lemma ex_lim_seq_scal_l (u : nat -> R) (a : R) :

  ex_lim_seq u -> ex_lim_seq (fun n => a * u n).

Proof.

  move => [l H].

  exists (Rbar_mult a l).

  eapply is_lim_seq_scal_l ; try eassumption.

Qed.



Lemma Lim_seq_scal_l (u : nat -> R) (a : R) :

  Lim_seq (fun n => a * u n) = Rbar_mult a (Lim_seq u).

Proof.

  case: (Req_dec a 0) => [ -> | Ha].

  rewrite -(Lim_seq_ext (fun _ => 0)) /=.

  rewrite Lim_seq_const.

  case: (Lim_seq u) => [x | | ] //=.

  by rewrite Rmult_0_l.

  case: Rle_dec (Rle_refl 0) => // H _.

  case: Rle_lt_or_eq_dec (Rlt_irrefl 0) => // _ _.

  case: Rle_dec (Rle_refl 0) => // H _.

  case: Rle_lt_or_eq_dec (Rlt_irrefl 0) => // _ _.

  move => n ; by rewrite Rmult_0_l.



  wlog: a u Ha / (0 < a) => [Hw | {Ha} Ha].

    case: (Rlt_le_dec 0 a) => Ha'.

    by apply Hw.

    case: Ha' => // Ha'.

    rewrite -(Lim_seq_ext (fun n => - a * - u n)).

    rewrite -Rbar_mult_opp.

    rewrite -Lim_seq_opp.

    apply Hw.

    contradict Ha ; rewrite -(Ropp_involutive a) Ha ; ring.

    apply Ropp_lt_cancel ; by rewrite Ropp_0 Ropp_involutive.

    move => n ; ring.

  rewrite /Lim_seq.

  rewrite {2}/LimSup_seq ; case: ex_LimSup_seq => ls Hs ;

  rewrite {2}/LimInf_seq ; case: ex_LimInf_seq => li Hi ; simpl proj1_sig.

  apply (is_LimSup_seq_scal_pos a) in Hs => //.

  apply (is_LimInf_seq_scal_pos a) in Hi => //.

  rewrite (is_LimSup_seq_unique _ _ Hs).

  rewrite (is_LimInf_seq_unique _ _ Hi).

  case: ls {Hs} => [ls | | ] ; case: li {Hi} => [li | | ] //= ;

  case: (Rle_dec 0 a) (Rlt_le _ _ Ha) => // Ha' _ ;

  case: (Rle_lt_or_eq_dec 0 a Ha') (Rlt_not_eq _ _ Ha) => //= _ _ ;

  apply f_equal ; field.

Qed.



Lemma is_lim_seq_scal_r (u : nat -> R) (a : R) (lu : Rbar) :

  is_lim_seq u lu ->

    is_lim_seq (fun n => u n * a) (Rbar_mult lu a).

Proof.

  move => Hu Ha.

  apply is_lim_seq_ext with ((fun n : nat => a * u n)).

  move => n ; by apply Rmult_comm.

  rewrite Rbar_mult_comm.

  apply is_lim_seq_scal_l.

  by apply Hu.

Qed.



Lemma ex_lim_seq_scal_r (u : nat -> R) (a : R) :

  ex_lim_seq u -> ex_lim_seq (fun n => u n * a).

Proof.

  move => Hu.

  apply ex_lim_seq_ext with ((fun n : nat => a * u n)) ; try by intuition.

  apply ex_lim_seq_scal_l.

  by apply Hu.

Qed.



Lemma Lim_seq_scal_r (u : nat -> R) (a : R) :

  Lim_seq (fun n => u n * a) = Rbar_mult (Lim_seq u) a.

Proof.

  rewrite Rbar_mult_comm -Lim_seq_scal_l.

  apply Lim_seq_ext ; by intuition.

Qed.



Lemma is_lim_seq_div (u v : nat -> R) (l1 l2 l : Rbar) :

  is_lim_seq u l1 -> is_lim_seq v l2 -> l2 <> 0 ->

  is_Rbar_div l1 l2 l ->

  is_lim_seq (fun n => u n / v n) l.

Proof.

  intros.

  eapply is_lim_seq_mult ; try eassumption.

  now apply is_lim_seq_inv.

Qed.

Lemma is_lim_seq_div' (u v : nat -> R) (l1 l2 : R) :

  is_lim_seq u l1 -> is_lim_seq v l2 -> l2 <> 0 ->

  is_lim_seq (fun n => u n / v n) (l1 / l2).

Proof.

  intros.

  eapply is_lim_seq_div ; try eassumption.

  now contradict H1 ; case: H1 => ->.

  by [].

Qed.

Lemma ex_lim_seq_div (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v -> Lim_seq v <> 0 ->

  ex_Rbar_div (Lim_seq u) (Lim_seq v) ->

  ex_lim_seq (fun n => u n / v n).

Proof.

  intros.

  apply Lim_seq_correct in H.

  apply Lim_seq_correct in H0.

  exists (Rbar_div (Lim_seq u) (Lim_seq v)).

  eapply is_lim_seq_div ; try eassumption.

  by apply Rbar_mult_correct.

Qed.

Lemma Lim_seq_div (u v : nat -> R) :

  ex_lim_seq u -> ex_lim_seq v -> (Lim_seq v <> 0) ->

  ex_Rbar_div (Lim_seq u) (Lim_seq v) ->

  Lim_seq (fun n => u n / v n) = Rbar_div (Lim_seq u) (Lim_seq v).

Proof.

  move => H0 H1 H2 H3.

  apply is_lim_seq_unique.

  eapply is_lim_seq_div ; try apply Lim_seq_correct ; try eassumption.

  by apply Rbar_mult_correct.

Qed.



Lemma ex_lim_seq_adj (u v : nat -> R) :

  (forall n, u n <= u (S n)) -> (forall n, v (S n) <= v n)

  -> is_lim_seq (fun n => v n - u n) 0

  -> ex_finite_lim_seq u /\ ex_finite_lim_seq v /\ Lim_seq u = Lim_seq v.

Proof.

  move => Hu Hv H0.

  suff H : forall n, u n <= v n.

  suff Eu : ex_finite_lim_seq u.

    split ; try auto.

  suff Ev : ex_finite_lim_seq v.

    split ; try auto.



  apply is_lim_seq_unique in H0.

  rewrite Lim_seq_minus in H0 ; try by intuition.

  apply ex_finite_lim_seq_correct in Eu.

  apply ex_finite_lim_seq_correct in Ev.

  rewrite -(proj2 Eu) -(proj2 Ev) /= in H0 |- *.

  apply Rbar_finite_eq in H0 ; apply Rbar_finite_eq.

  by apply sym_eq, Rminus_diag_uniq, H0.

  by apply ex_finite_lim_seq_correct.

  by apply ex_finite_lim_seq_correct.

  apply ex_finite_lim_seq_correct in Eu.

  apply ex_finite_lim_seq_correct in Ev.

  by rewrite -(proj2 Eu) -(proj2 Ev).

  apply ex_finite_lim_seq_decr with (u O) => //.

  move => n ; apply Rle_trans with (2 := H _).

  elim: n => [ | n IH].

  by apply Rle_refl.

  by apply Rle_trans with (2 := Hu _).

  apply ex_finite_lim_seq_incr with (v O) => //.

  move => n ; apply Rle_trans with (1 := H _).

  elim: n => [ | n IH].

  by apply Rle_refl.

  by apply Rle_trans with (1 := Hv _).

  move => n0 ; apply Rnot_lt_le ; move/Rminus_lt_0 => H.

  apply is_lim_seq_spec in H0.

  case: (H0 (mkposreal _ H)) => /= {H0} N H0.

  move: (H0 _ (le_plus_r n0 N)) ; apply Rle_not_lt.

  rewrite Rminus_0_r ; apply Rle_trans with (2 := Rabs_maj2 _).

  rewrite Ropp_minus_distr'.

  apply Rplus_le_compat, Ropp_le_contravar.

  elim: (N) => [ | m IH].

  rewrite plus_0_r ; apply Rle_refl.

  rewrite -plus_n_Sm ; by apply Rle_trans with (2 := Hu _).

  elim: (N) => [ | m IH].

  rewrite plus_0_r ; apply Rle_refl.

  rewrite -plus_n_Sm ; by apply Rle_trans with (1 := Hv _).

Qed.



Lemma is_lim_seq_continuous (f : R -> R) (u : nat -> R) (l : R) :

  continuity_pt f l -> is_lim_seq u l

  -> is_lim_seq (fun n => f (u n)) (f l).

Proof.

  move => Cf Hu.

  apply continuity_pt_filterlim in Cf.

  apply filterlim_comp with (1 := Hu).

  exact Cf.

Qed.



Lemma filterlim_Rabs :

  forall l : Rbar,

  filterlim Rabs (Rbar_locally l) (Rbar_locally (Rbar_abs l)).

Proof.

  case => [l| |] /=.



  apply @filterlim_norm.



  intros P [N HP].

  exists N => x Hx.

  apply HP.

  apply Rlt_le_trans with (1 := Hx).

  apply Rle_abs.



  intros P [N HP].

  exists (-N) => x Hx.

  apply HP.

  apply Rlt_le_trans with (2 := Rabs_maj2 _), Ropp_lt_cancel.

  by rewrite Ropp_involutive.

Qed.



Lemma is_lim_seq_abs (u : nat -> R) (l : Rbar) :

  is_lim_seq u l -> is_lim_seq (fun n => Rabs (u n)) (Rbar_abs l).

Proof.

intros Hu.

apply filterlim_comp with (1 := Hu).

apply filterlim_Rabs.

Qed.

Lemma ex_lim_seq_abs (u : nat -> R) :

  ex_lim_seq u -> ex_lim_seq (fun n => Rabs (u n)).

Proof.

  move => [l Hu].

  exists (Rbar_abs l) ; by apply is_lim_seq_abs.

Qed.

Lemma Lim_seq_abs (u : nat -> R) :

  ex_lim_seq u ->

  Lim_seq (fun n => Rabs (u n)) = Rbar_abs (Lim_seq u).

Proof.

  intros.

  apply is_lim_seq_unique.

  apply is_lim_seq_abs.

  by apply Lim_seq_correct.

Qed.



Lemma is_lim_seq_abs_0 (u : nat -> R) :

  is_lim_seq u 0 <-> is_lim_seq (fun n => Rabs (u n)) 0.

Proof.

  split => Hu.

  rewrite -Rabs_R0.

  by apply (is_lim_seq_abs _ 0).

  apply is_lim_seq_spec in Hu.

  apply is_lim_seq_spec.

  move => eps.

  case: (Hu eps) => {Hu} N Hu.

  exists N => n Hn.

  move: (Hu n Hn) ;

  by rewrite ?Rminus_0_r Rabs_Rabsolu.

Qed.



Lemma is_lim_seq_geom (q : R) :

  Rabs q < 1 -> is_lim_seq (fun n => q ^ n) 0.

Proof.

  intros Hq.

  apply is_lim_seq_spec.

  move => [e He] /=.

  case: (pow_lt_1_zero q Hq e He) => N H.

  exists N => n Hn.

  rewrite Rminus_0_r ; by apply H.

Qed.

Lemma ex_lim_seq_geom (q : R) :

  Rabs q < 1 -> ex_lim_seq (fun n => q ^ n).

Proof.

  move => Hq ; exists 0 ; by apply is_lim_seq_geom.

Qed.

Lemma Lim_seq_geom (q : R) :

  Rabs q < 1 -> Lim_seq (fun n => q ^ n) = 0.

Proof.

  intros.

  apply is_lim_seq_unique.

  by apply is_lim_seq_geom.

Qed.



Lemma is_lim_seq_geom_p (q : R) :

  1 < q -> is_lim_seq (fun n => q ^ n) p_infty.

Proof.

  intros Hq.

  apply is_lim_seq_spec.

  move => M /=.

  case: (fun Hq => Pow_x_infinity q Hq (M+1)) => [ | N H].

  by apply Rlt_le_trans with (1 := Hq), Rle_abs.

  exists N => n Hn.

  apply Rlt_le_trans with (M+1).

  rewrite -{1}(Rplus_0_r M) ; by apply Rplus_lt_compat_l, Rlt_0_1.

  rewrite -(Rabs_pos_eq (q^n)).

  by apply Rge_le, H.

  by apply pow_le, Rlt_le, Rlt_trans with (1 := Rlt_0_1).

Qed.

Lemma ex_lim_seq_geom_p (q : R) :

  1 < q -> ex_lim_seq (fun n => q ^ n).

Proof.

  move => Hq ; exists p_infty ; by apply is_lim_seq_geom_p.

Qed.

Lemma Lim_seq_geom_p (q : R) :

  1 < q -> Lim_seq (fun n => q ^ n) = p_infty.

Proof.

  intros.

  apply is_lim_seq_unique.

  by apply is_lim_seq_geom_p.

Qed.



Lemma ex_lim_seq_geom_m (q : R) :

  q <= -1 -> ~ ex_lim_seq (fun n => q ^ n).

Proof.

  intros Hq [l H].

  apply is_lim_seq_spec in H.

  destruct l as [l| |].

  case: Hq => Hq.



  case: (H (mkposreal _ Rlt_0_1)) => /= {H} N H.

  move: (fun n Hn => Rabs_lt_between_Rmax _ _ _ (proj1 (Rabs_lt_between' _ _ _) (H n Hn))).

  set M := Rmax (l + 1) (- (l - 1)) => H0.

  case: (fun Hq => Pow_x_infinity q Hq M) => [ | N0 H1].

  rewrite Rabs_left.

  apply Ropp_lt_cancel ; by rewrite Ropp_involutive.

  apply Rlt_trans with (1 := Hq) ;

  apply Ropp_lt_cancel ;

  rewrite Ropp_involutive Ropp_0 ;

  by apply Rlt_0_1.

  move: (H0 _ (le_plus_l N N0)).

  by apply Rle_not_lt, Rge_le, H1, le_plus_r.



  case: (H (mkposreal _ Rlt_0_1)) => /= {H} N H.

  rewrite Hq in H => {q Hq}.

  move: (H _ (le_n_2n _)) ; rewrite pow_1_even ; case/Rabs_lt_between' => _ H1.

  have H2 : (N <= S (2 * N))%nat.

    by apply le_trans with (1 := le_n_2n _), le_n_Sn.

  move: (H _ H2) ; rewrite pow_1_odd ; case/Rabs_lt_between' => {H H2} H2 _.

  move: H1 ; apply Rle_not_lt, Rlt_le.

  pattern 1 at 2 ; replace (1) with ((-1)+2) by ring.

  replace (l+1) with ((l-1)+2) by ring.

  by apply Rplus_lt_compat_r.



  case: (H 0) => {H} N H.

  have H0 : (N <= S (2 * N))%nat.

    by apply le_trans with (1 := le_n_2n _), le_n_Sn.

  move: (H _ H0) ; apply Rle_not_lt ; rewrite /pow -/pow.

  apply Rmult_le_0_r.

  apply Rle_trans with (1 := Hq), Ropp_le_cancel ;

  rewrite Ropp_involutive Ropp_0 ;

  by apply Rle_0_1.

  apply Ropp_le_contravar in Hq ; rewrite Ropp_involutive in Hq.

  rewrite pow_sqr -Rmult_opp_opp ; apply pow_le, Rmult_le_pos ;

  apply Rle_trans with (2 := Hq), Rle_0_1.



  case: (H 0) => {H} N H.

  move: (H _ (le_n_2n _)).

  apply Rle_not_lt.

  apply Ropp_le_contravar in Hq ; rewrite Ropp_involutive in Hq.

  rewrite pow_sqr -Rmult_opp_opp ; apply pow_le, Rmult_le_pos ;

  apply Rle_trans with (2 := Hq), Rle_0_1.

Qed.



Lemma is_lim_seq_Rbar_loc_seq (x : Rbar) :

  is_lim_seq (Rbar_loc_seq x) x.

Proof.

  intros P HP.

  apply filterlim_Rbar_loc_seq.

  now apply Rbar_locally'_le.

Qed.

