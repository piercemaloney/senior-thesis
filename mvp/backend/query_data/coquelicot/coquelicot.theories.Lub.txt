

Require Import Reals mathcomp.ssreflect.ssreflect.

Require Import Rbar Rcomplements Markov.
(* Rbar:
Require Import Reals.
Require Import mathcomp.ssreflect.ssreflect.
Require Import Rcomplements.

Open Scope R_scope.

Inductive Rbar :=
  | Finite : R -> Rbar
  | p_infty : Rbar
  | m_infty : Rbar.
Definition real (x : Rbar) :=
  match x with
    | Finite x => x
    | _ => 0
  end.
Coercion Finite : R >-> Rbar.
Coercion real : Rbar >-> R.

Definition is_finite (x : Rbar) := Finite (real x) = x.
Lemma is_finite_correct (x : Rbar) :
  is_finite x <-> exists y : R, x = Finite y.

Definition Rbar_lt (x y : Rbar) : Prop :=
  match x,y with
    | p_infty, _ | _, m_infty => False
    | m_infty, _ | _, p_infty => True
    | Finite x, Finite y => Rlt x y
  end.

Definition Rbar_le (x y : Rbar) : Prop :=
  match x,y with
    | m_infty, _ | _, p_infty => True
    | p_infty, _ | _, m_infty => False
    | Finite x, Finite y => Rle x y
  end.

Definition Rbar_opp (x : Rbar) :=
  match x with
    | Finite x => Finite (-x)
    | p_infty => m_infty
    | m_infty => p_infty
  end.

Definition Rbar_plus' (x y : Rbar) :=
  match x,y with
    | p_infty, m_infty | m_infty, p_infty => None
    | p_infty, _ | _, p_infty => Some p_infty
    | m_infty, _ | _, m_infty => Some m_infty
    | Finite x', Finite y' => Some (Finite (x' + y'))
  end.
Definition Rbar_plus (x y : Rbar) :=
  match Rbar_plus' x y with Some z => z | None => Finite 0 end.
Arguments Rbar_plus !x !y /.
Definition is_Rbar_plus (x y z : Rbar) : Prop :=
  Rbar_plus' x y = Some z.
Definition ex_Rbar_plus (x y : Rbar) : Prop :=
  match Rbar_plus' x y with Some _ => True | None => False end.
Arguments ex_Rbar_plus !x !y /.

Lemma is_Rbar_plus_unique (x y z : Rbar) :
  is_Rbar_plus x y z -> Rbar_plus x y = z.
Lemma Rbar_plus_correct (x y : Rbar) :
  ex_Rbar_plus x y -> is_Rbar_plus x y (Rbar_plus x y).

Definition Rbar_minus (x y : Rbar) := Rbar_plus x (Rbar_opp y).
Arguments Rbar_minus !x !y /.
Definition is_Rbar_minus (x y z : Rbar) : Prop :=
  is_Rbar_plus x (Rbar_opp y) z.
Definition ex_Rbar_minus (x y : Rbar) : Prop :=
  ex_Rbar_plus x (Rbar_opp y).
Arguments ex_Rbar_minus !x !y /.

Definition Rbar_inv (x : Rbar) : Rbar :=
  match x with
    | Finite x => Finite (/x)
    | _ => Finite 0
  end.

Definition Rbar_mult' (x y : Rbar) :=
  match x with
    | Finite x => match y with
      | Finite y => Some (Finite (x * y))
      | p_infty => match (Rle_dec 0 x) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some p_infty | right _ => None end
        | right _ => Some m_infty
      end
      | m_infty => match (Rle_dec 0 x) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some m_infty | right _ => None end
        | right _ => Some p_infty
      end
    end
    | p_infty => match y with
      | Finite y => match (Rle_dec 0 y) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some p_infty | right _ => None end
        | right _ => Some m_infty
      end
      | p_infty => Some p_infty
      | m_infty => Some m_infty
    end
    | m_infty => match y with
      | Finite y => match (Rle_dec 0 y) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some m_infty | right _ => None end
        | right _ => Some p_infty
      end
      | p_infty => Some m_infty
      | m_infty => Some p_infty
    end
  end.
Definition Rbar_mult (x y : Rbar) :=
  match Rbar_mult' x y with Some z => z | None => Finite 0 end.
Arguments Rbar_mult !x !y /.

Definition is_Rbar_mult (x y z : Rbar) : Prop :=
  Rbar_mult' x y = Some z.
Definition ex_Rbar_mult (x y : Rbar) : Prop :=
  match x with
    | Finite x => match y with
      | Finite y => True
      | p_infty => x <> 0
      | m_infty => x <> 0
    end
    | p_infty => match y with
      | Finite y => y <> 0
      | p_infty => True
      | m_infty => True
    end
    | m_infty => match y with
      | Finite y => y <> 0
      | p_infty => True
      | m_infty => True
    end
  end.
Arguments ex_Rbar_mult !x !y /.

Definition Rbar_mult_pos (x : Rbar) (y : posreal) :=
  match x with
    | Finite x => Finite (x*y)
    | _ => x
  end.

Lemma is_Rbar_mult_unique (x y z : Rbar) :
  is_Rbar_mult x y z -> Rbar_mult x y = z.
Lemma Rbar_mult_correct (x y : Rbar) :
  ex_Rbar_mult x y -> is_Rbar_mult x y (Rbar_mult x y).
Lemma Rbar_mult_correct' (x y z : Rbar) :
  is_Rbar_mult x y z -> ex_Rbar_mult x y.

Definition Rbar_div (x y : Rbar) : Rbar :=
  Rbar_mult x (Rbar_inv y).
Arguments Rbar_div !x !y /.
Definition is_Rbar_div (x y z : Rbar) : Prop :=
  is_Rbar_mult x (Rbar_inv y) z.
Definition ex_Rbar_div (x y : Rbar) : Prop :=
  ex_Rbar_mult x (Rbar_inv y).
Arguments ex_Rbar_div !x !y /.
Definition Rbar_div_pos (x : Rbar) (y : posreal) :=
  match x with
    | Finite x => Finite (x/y)
    | _ => x
  end.

Lemma Rbar_finite_eq (x y : R) :
  Finite x = Finite y <-> x = y.
Lemma Rbar_finite_neq (x y : R) :
  Finite x <> Finite y <-> x <> y.

Lemma Rbar_lt_not_eq (x y : Rbar) :
  Rbar_lt x y -> x<>y.

Lemma Rbar_not_le_lt (x y : Rbar) :
  ~ Rbar_le x y -> Rbar_lt y x.

Lemma Rbar_lt_not_le (x y : Rbar) :
  Rbar_lt y x -> ~ Rbar_le x y.

Lemma Rbar_not_lt_le (x y : Rbar) :
  ~ Rbar_lt x y -> Rbar_le y x.

Lemma Rbar_le_not_lt (x y : Rbar) :
  Rbar_le y x -> ~ Rbar_lt x y.

Lemma Rbar_le_refl :
  forall x : Rbar, Rbar_le x x.

Lemma Rbar_lt_le :
  forall x y : Rbar,
  Rbar_lt x y -> Rbar_le x y.

Lemma Rbar_total_order (x y : Rbar) :
  {Rbar_lt x y} + {x = y} + {Rbar_lt y x}.

Lemma Rbar_eq_dec (x y : Rbar) :
  {x = y} + {x <> y}.

Lemma Rbar_lt_dec (x y : Rbar) :
  {Rbar_lt x y} + {~Rbar_lt x y}.

Lemma Rbar_lt_le_dec (x y : Rbar) :
  {Rbar_lt x y} + {Rbar_le y x}.

Lemma Rbar_le_dec (x y : Rbar) :
  {Rbar_le x y} + {~Rbar_le x y}.

Lemma Rbar_le_lt_dec (x y : Rbar) :
  {Rbar_le x y} + {Rbar_lt y x}.

Lemma Rbar_le_lt_or_eq_dec (x y : Rbar) :
  Rbar_le x y -> { Rbar_lt x y } + { x = y }.

Lemma Rbar_lt_trans (x y z : Rbar) :
  Rbar_lt x y -> Rbar_lt y z -> Rbar_lt x z.

Lemma Rbar_lt_le_trans (x y z : Rbar) :
  Rbar_lt x y -> Rbar_le y z -> Rbar_lt x z.

Lemma Rbar_le_lt_trans (x y z : Rbar) :
  Rbar_le x y -> Rbar_lt y z -> Rbar_lt x z.

Lemma Rbar_le_trans (x y z : Rbar) :
  Rbar_le x y -> Rbar_le y z -> Rbar_le x z.

Lemma Rbar_le_antisym (x y : Rbar) :
  Rbar_le x y -> Rbar_le y x -> x = y.

Lemma Rbar_opp_involutive (x : Rbar) : (Rbar_opp (Rbar_opp x)) = x.

Lemma Rbar_opp_lt (x y : Rbar) : Rbar_lt (Rbar_opp x) (Rbar_opp y) <-> Rbar_lt y x.

Lemma Rbar_opp_le (x y : Rbar) : Rbar_le (Rbar_opp x) (Rbar_opp y) <-> Rbar_le y x.

Lemma Rbar_opp_eq (x y : Rbar) : (Rbar_opp x) = (Rbar_opp y) <-> x = y.

Lemma Rbar_opp_real (x : Rbar) : real (Rbar_opp x) = - real x.

Lemma Rbar_plus'_comm :
  forall x y, Rbar_plus' x y = Rbar_plus' y x.

Lemma ex_Rbar_plus_comm :
  forall x y,
  ex_Rbar_plus x y -> ex_Rbar_plus y x.

Lemma ex_Rbar_plus_opp (x y : Rbar) :
  ex_Rbar_plus x y -> ex_Rbar_plus (Rbar_opp x) (Rbar_opp y).

Lemma Rbar_plus_0_r (x : Rbar) : Rbar_plus x (Finite 0) = x.
Lemma Rbar_plus_0_l (x : Rbar) : Rbar_plus (Finite 0) x = x.

Lemma Rbar_plus_comm (x y : Rbar) : Rbar_plus x y = Rbar_plus y x.

Lemma Rbar_plus_lt_compat (a b c d : Rbar) :
  Rbar_lt a b -> Rbar_lt c d -> Rbar_lt (Rbar_plus a c) (Rbar_plus b d).

Lemma Rbar_plus_le_compat (a b c d : Rbar) :
  Rbar_le a b -> Rbar_le c d -> Rbar_le (Rbar_plus a c) (Rbar_plus b d).

Lemma Rbar_plus_opp (x y : Rbar) :
  Rbar_plus (Rbar_opp x) (Rbar_opp y) = Rbar_opp (Rbar_plus x y).

Lemma Rbar_minus_eq_0 (x : Rbar) : Rbar_minus x x = 0.
Lemma Rbar_opp_minus (x y : Rbar) :
  Rbar_opp (Rbar_minus x y) = Rbar_minus y x.

Lemma Rbar_inv_opp (x : Rbar) :
  x <> 0 -> Rbar_inv (Rbar_opp x) = Rbar_opp (Rbar_inv x).

Lemma Rbar_mult'_comm (x y : Rbar) :
  Rbar_mult' x y = Rbar_mult' y x.

Lemma Rbar_mult'_opp_r (x y : Rbar) :
  Rbar_mult' x (Rbar_opp y) = match Rbar_mult' x y with Some z => Some (Rbar_opp z) | None => None end.

Lemma Rbar_mult_comm (x y : Rbar) :
  Rbar_mult x y = Rbar_mult y x.
Lemma Rbar_mult_opp_r (x y : Rbar) :
  Rbar_mult x (Rbar_opp y) = (Rbar_opp (Rbar_mult x y)).
Lemma Rbar_mult_opp_l (x y : Rbar) :
  Rbar_mult (Rbar_opp x) y = Rbar_opp (Rbar_mult x y).
Lemma Rbar_mult_opp (x y : Rbar) :
  Rbar_mult (Rbar_opp x) (Rbar_opp y) = Rbar_mult x y.
Lemma Rbar_mult_0_l (x : Rbar) : Rbar_mult 0 x = 0.
Lemma Rbar_mult_0_r (x : Rbar) : Rbar_mult x 0 = 0.

Lemma Rbar_mult_eq_0 (y x : Rbar) :
  Rbar_mult x y = 0 -> x = 0 \/ y = 0.

Lemma ex_Rbar_mult_sym (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult y x.
Lemma ex_Rbar_mult_opp_l (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult (Rbar_opp x) y.
Lemma ex_Rbar_mult_opp_r (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult x (Rbar_opp y).

Lemma is_Rbar_mult_sym (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult y x z.
Lemma is_Rbar_mult_opp_l (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult (Rbar_opp x) y (Rbar_opp z).
Lemma is_Rbar_mult_opp_r (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult x (Rbar_opp y) (Rbar_opp z).

Lemma is_Rbar_mult_p_infty_pos (x : Rbar) :
  Rbar_lt 0 x -> is_Rbar_mult p_infty x p_infty.
Lemma is_Rbar_mult_p_infty_neg (x : Rbar) :
  Rbar_lt x 0 -> is_Rbar_mult p_infty x m_infty.
Lemma is_Rbar_mult_m_infty_pos (x : Rbar) :
  Rbar_lt 0 x -> is_Rbar_mult m_infty x m_infty.
Lemma is_Rbar_mult_m_infty_neg (x : Rbar) :
  Rbar_lt x 0 -> is_Rbar_mult m_infty x p_infty.

Lemma is_Rbar_div_p_infty (x : R) :
  is_Rbar_div x p_infty 0.
Lemma is_Rbar_div_m_infty (x : R) :
  is_Rbar_div x m_infty 0.

Lemma Rbar_mult_pos_eq (x y : Rbar) (z : posreal) :
  x = y <-> (Rbar_mult_pos x z) = (Rbar_mult_pos y z).

Lemma Rbar_mult_pos_lt (x y : Rbar) (z : posreal) :
  Rbar_lt x y <-> Rbar_lt (Rbar_mult_pos x z) (Rbar_mult_pos y z).

Lemma Rbar_mult_pos_le (x y : Rbar) (z : posreal) :
  Rbar_le x y <-> Rbar_le (Rbar_mult_pos x z) (Rbar_mult_pos y z).

Lemma Rbar_div_pos_eq (x y : Rbar) (z : posreal) :
  x = y <-> (Rbar_div_pos x z) = (Rbar_div_pos y z).

Lemma Rbar_div_pos_lt (x y : Rbar) (z : posreal) :
  Rbar_lt x y <-> Rbar_lt (Rbar_div_pos x z) (Rbar_div_pos y z).

Lemma Rbar_div_pos_le (x y : Rbar) (z : posreal) :
  Rbar_le x y <-> Rbar_le (Rbar_div_pos x z) (Rbar_div_pos y z).

Definition Rbar_min (x y : Rbar) : Rbar :=
  match x, y with
  | z, p_infty | p_infty, z => z
  | _ , m_infty | m_infty, _ => m_infty
  | Finite x, Finite y => Rmin x y
  end.

Lemma Rbar_lt_locally (a b : Rbar) (x : R) :
  Rbar_lt a x -> Rbar_lt x b ->
  exists delta : posreal,
    forall y, Rabs (y - x) < delta -> Rbar_lt a y /\ Rbar_lt y b.

Lemma Rbar_min_comm (x y : Rbar) : Rbar_min x y = Rbar_min y x.

Lemma Rbar_min_r (x y : Rbar) : Rbar_le (Rbar_min x y) y.

Lemma Rbar_min_l (x y : Rbar) : Rbar_le (Rbar_min x y) x.

Lemma Rbar_min_case (x y : Rbar) (P : Rbar -> Type) :
  P x -> P y -> P (Rbar_min x y).
Lemma Rbar_min_case_strong (r1 r2 : Rbar) (P : Rbar -> Type) :
  (Rbar_le r1 r2 -> P r1) -> (Rbar_le r2 r1 -> P r2)
    -> P (Rbar_min r1 r2).

Definition Rbar_abs (x : Rbar) :=
  match x with
    | Finite x => Finite (Rabs x)
    | _ => p_infty
  end.

Lemma Rbar_abs_lt_between (x y : Rbar) :
  Rbar_lt (Rbar_abs x) y <-> (Rbar_lt (Rbar_opp y) x /\ Rbar_lt x y).

Lemma Rbar_abs_opp (x : Rbar) :
  Rbar_abs (Rbar_opp x) = Rbar_abs x.

Lemma Rbar_abs_pos (x : Rbar) :
  Rbar_le 0 x -> Rbar_abs x = x.
Lemma Rbar_abs_neg (x : Rbar) :
  Rbar_le x 0 -> Rbar_abs x = Rbar_opp x. *)
(* Rcomplements:
Ltac evar_last :=
  match goal with
  | |- ?f ?x =>
    let tx := type of x in
    let tx := eval simpl in tx in
    let tmp := fresh "tmp" in
    evar (tmp : tx) ;
    refine (@eq_ind tx tmp f _ x _) ;
    unfold tmp ; clear tmp
  end.

Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Psatz.

Module MyNat.

Lemma neq_succ_0 (n : nat) : S n <> 0.

Lemma sub_succ (n m : nat) : S n - S m = n - m.

Lemma sub_succ_l (n m : nat) : n <= m -> S m - n = S (m - n).

Lemma lt_neq (n m : nat) : n < m -> n <> m.

Lemma minus_0_le (n m : nat) : n <= m -> n - m = 0.

Lemma sub_succ_r (n m : nat) : n - S m = pred (n - m).

Lemma sub_add (n m : nat) : n <= m -> m - n + n = m.

Lemma le_pred_le_succ (n m : nat) : pred n <= m <-> n <= S m.

End MyNat.

Require Import Even Div2.
Require Import mathcomp.ssreflect.seq mathcomp.ssreflect.ssrbool.

Open Scope R_scope.

Lemma floor_ex : forall x : R, {n : Z | IZR n <= x < IZR n + 1}.
Definition floor x := proj1_sig (floor_ex x).

Lemma floor1_ex : forall x : R, {n : Z | IZR n < x <= IZR n + 1}.
Definition floor1 x := proj1_sig (floor1_ex x).

Lemma nfloor_ex : forall x : R, 0 <= x -> {n : nat | INR n <= x < INR n + 1}.
Definition nfloor x pr := proj1_sig (nfloor_ex x pr).

Lemma nfloor1_ex : forall x : R, 0 < x -> {n : nat | INR n < x <= INR n + 1}.
Definition nfloor1 x pr := proj1_sig (nfloor1_ex x pr).

Lemma INRp1_pos : forall n, 0 < INR n + 1.

Lemma Rlt_nat (x : R) : (exists n : nat, x = INR (S n)) -> 0 < x.

Lemma Rle_pow_lin (a : R) (n : nat) :
  0 <= a -> 1 + INR n * a <= (1 + a) ^ n.

Lemma C_n_n: forall n, C n n = 1.

Lemma C_n_0: forall n, C n 0 = 1.

Fixpoint pow2 (n : nat) : nat :=
  match n with
    | O => 1%nat
    | S n => (2 * pow2 n)%nat
  end.

Lemma pow2_INR (n : nat) : INR (pow2 n) = 2^n.

Lemma pow2_pos (n : nat) : (0 < pow2 n)%nat.

Lemma Rinv_le_contravar :
  forall x y, 0 < x -> x <= y -> / y <= / x.

Lemma Rinv_lt_cancel (x y : R) :
  0 < y -> / y < / x -> x < y.

Lemma Rdiv_1 : forall x : R, x / 1 = x.

Lemma Rdiv_plus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b + c / d = (a * d + c * b) / (b * d).

Lemma Rdiv_minus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b - c / d = (a * d - c * b) / (b * d).

Lemma Rplus_lt_reg_l (x y z : R) : x + y < x + z -> y < z.

Lemma Rplus_lt_reg_r (x y z : R) : y + x < z + x -> y < z.

Lemma Rle_div_l : forall a b c, c > 0 -> (a / c <= b <-> a <= b * c).

Lemma Rle_div_r : forall a b c, c > 0 -> (a * c <= b <-> a <= b / c).

Lemma Rlt_div_l : forall a b c, c > 0 -> (a / c < b <-> a < b*c).

Lemma Rlt_div_r : forall a b c, c > 0 -> (a * c < b <-> a < b / c).

Lemma Rdiv_lt_0_compat : forall r1 r2 : R, 0 < r1 -> 0 < r2 -> 0 < r1 / r2.

Lemma Rdiv_le_0_compat : forall r1 r2 : R, 0 <= r1 -> 0 < r2 -> 0 <= r1 / r2.

Lemma Rdiv_lt_1 : forall r1 r2, 0 < r2 -> (r1 < r2 <-> r1 / r2 < 1).

Lemma Rdiv_le_1 : forall r1 r2, 0 < r2 -> (r1 <= r2 <-> r1/r2 <= 1).

Lemma Rle_mult_Rlt : forall c a b : R, 0 < b -> c < 1 -> a <= b*c -> a < b.

Lemma Rmult_le_0_r : forall a b, a <= 0 -> 0 <= b -> a * b <= 0.

Lemma Rmult_le_0_l : forall a b, 0 <= a -> b <= 0 -> a * b <= 0.

Lemma pow2_gt_0 (x : R) : x <> 0 -> 0 < x ^ 2.

Lemma Rminus_eq_0 : forall r : R, r - r = 0.

Lemma Rdiv_minus_distr : forall a b c, b <> 0 -> a / b - c = (a - b * c) / b.

Lemma Rmult_minus_distr_r: forall r1 r2 r3 : R, (r1 - r2) * r3 = r1 * r3 - r2 * r3.

Lemma Rminus_eq_compat_l : forall r r1 r2 : R, r1 = r2 <-> r - r1 = r - r2.

Lemma Ropp_plus_minus_distr : forall r1 r2 : R, - (r1 + r2) = - r1 - r2.

Lemma Rle_minus_l : forall a b c,(a - c <= b <-> a <= b + c).

Lemma Rlt_minus_r : forall a b c,(a < b - c <-> a + c < b).

Lemma Rlt_minus_l : forall a b c,(a - c < b <-> a < b + c).

Lemma Rle_minus_r : forall a b c,(a <= b - c <-> a + c <= b).

Lemma Rminus_le_0 : forall a b, a <= b <-> 0 <= b - a.

Lemma Rminus_lt_0 : forall a b, a < b <-> 0 < b - a.

Lemma sum_f_rw (a : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m a = sum_f_R0 a m - sum_f_R0 a n.

Lemma sum_f_rw_0 (u : nat -> R) (n : nat) :
  sum_f O n u = sum_f_R0 u n.

Lemma sum_f_n_Sm (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f n (S m) u = sum_f n m u + u (S m).
Lemma sum_f_u_Sk (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f (S n) (S m) u = sum_f n m (fun k => u (S k)).
Lemma sum_f_u_add (u : nat -> R) (p n m : nat) :
  (n <= m)%nat -> sum_f (n + p)%nat (m + p)%nat u = sum_f n m (fun k => u (k + p)%nat).

Lemma sum_f_Sn_m (u : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m u = sum_f n m u - u n.

Lemma sum_f_R0_skip (u : nat -> R) (n : nat) :
  sum_f_R0 (fun k => u (n - k)%nat) n = sum_f_R0 u n.

Lemma sum_f_chasles (u : nat -> R) (n m k : nat) :
  (n < m)%nat -> (m < k)%nat ->
  sum_f (S n) k u = sum_f (S n) m u + sum_f (S m) k u.

Lemma Rplus_max_distr_l :
  forall a b c, a + Rmax b c = Rmax (a + b) (a + c).

Lemma Rplus_max_distr_r :
  forall a b c, Rmax b c + a = Rmax (b + a) (c + a).

Lemma Rplus_min_distr_l :
  forall a b c, a + Rmin b c = Rmin (a + b) (a + c).

Lemma Rplus_min_distr_r :
  forall a b c, Rmin b c + a = Rmin (b + a) (c + a).

Lemma Rmult_max_distr_l :
  forall a b c, 0 <= a -> a * Rmax b c = Rmax (a * b) (a * c).

Lemma Rmult_max_distr_r :
  forall a b c, 0 <= a -> Rmax b c * a = Rmax (b * a) (c * a).

Lemma Rmult_min_distr_l :
  forall a b c, 0 <= a -> a * Rmin b c = Rmin (a * b) (a * c).

Lemma Rmult_min_distr_r :
  forall a b c, 0 <= a -> Rmin b c * a = Rmin (b * a) (c * a).

Lemma Rmin_assoc : forall x y z, Rmin x (Rmin y z) =
  Rmin (Rmin x y) z.

Lemma Rmax_assoc : forall x y z, Rmax x (Rmax y z) =
  Rmax (Rmax x y) z.

Lemma Rmax_le_compat : forall a b c d, a <= b -> c <= d -> Rmax a c <= Rmax b d.

Lemma Rmax_opp_Rmin : forall a b, Rmax (-a) (-b) = - Rmin a b.
Lemma Rmin_opp_Rmax : forall a b, Rmin (-a) (-b) = - Rmax a b.

Lemma Rmax_mult : forall a b c, 0 <= c -> Rmax a b * c = Rmax (a * c) (b * c).

Lemma Rmax_le_Rplus : forall a b : R, 0 <= a -> 0 <= b -> Rmax a b <= a + b.

Lemma Rplus_le_Rmax : forall a b : R, a + b <= 2*Rmax a b.

Lemma Rmin_Rmax_l : forall a b, Rmin a b <= a <= Rmax a b.

Lemma Rmin_Rmax_r : forall a b, Rmin a b <= b <= Rmax a b.

Lemma Rmin_Rmax : forall a b, Rmin a b <= Rmax a b.

Lemma Rabs_div : forall a b : R, b <> 0 -> Rabs (a/b) = (Rabs a) / (Rabs b).

Lemma Rabs_eq_0 : forall x, Rabs x = 0 -> x = 0.

Lemma Rabs_le_between : forall x y, (Rabs x <= y <-> -y <= x <= y).

Lemma Rabs_le_between' : forall x y z, Rabs (x - y) <= z <-> y-z <= x <= y+z.

Lemma Rabs_lt_between : forall x y, (Rabs x < y <-> -y < x < y).

Lemma Rabs_lt_between' : forall x y z, Rabs (x - y) < z <-> y-z < x < y+z.

Lemma Rabs_le_between_min_max : forall x y z, Rmin x y <= z <= Rmax x y -> Rabs (z - y) <= Rabs (x - y).

Lemma Rabs_le_between_Rmax : forall x m M,
  m <= x <= M -> Rabs x <= Rmax M (-m).

Lemma Rabs_lt_between_Rmax : forall x m M,
  m < x < M -> Rabs x < Rmax M (-m).

Lemma Rabs_maj2 : forall x, -x <= Rabs x.

Lemma Req_lt_aux : forall x y, (forall eps : posreal, Rabs (x - y) < eps) -> x = y.

Lemma Req_le_aux : forall x y, (forall eps : posreal, Rabs (x - y) <= eps) -> x = y.

Lemma is_pos_div_2 (eps : posreal) : 0 < eps / 2.
Definition pos_div_2 (eps : posreal) := mkposreal _ (is_pos_div_2 eps).

Definition sign (x : R) :=
  match total_order_T 0 x with
  | inleft (left _) => 1
  | inleft (right _) => 0
  | inright _ => -1
  end.

Lemma sign_0 : sign 0 = 0.

Lemma sign_opp (x : R) : sign (-x) = - sign x.

Lemma sign_eq_1 (x : R) : 0 < x -> sign x = 1.

Lemma sign_eq_m1 (x : R) : x < 0 -> sign x = -1.

Lemma sign_le (x y : R) : x <= y -> sign x <= sign y.

Lemma sign_ge_0 (x : R) : 0 <= x -> 0 <= sign x.

Lemma sign_le_0 (x : R) : x <= 0 -> sign x <= 0.

Lemma sign_neq_0 (x : R) : x <> 0 -> sign x <> 0.

Lemma sign_mult (x y : R) : sign (x * y) = sign x * sign y.

Lemma sign_min_max (a b : R) :
  sign (b - a) * (Rmax a b - Rmin a b) = b - a.

Lemma sum_INR : forall n, sum_f_R0 INR n = INR n * (INR n + 1) / 2.

Lemma interval_finite_subdiv (a b : R) (eps : posreal) : (a <= b) ->
  {l : seq R | head 0 l = a /\ last 0 l = b /\
    forall i, (S i < size l)%nat -> nth 0 l i < nth 0 l (S i) <= nth 0 l i + eps}.

Lemma interval_finite_subdiv_between (a b : R) (eps : posreal) (Hab : a <= b) :
  let l := proj1_sig (interval_finite_subdiv a b eps Hab) in
  forall i, (i < size l)%nat -> a <= nth 0 l i <= b.

Lemma SSR_leq (n m : nat) : is_true (ssrnat.leq n m) <-> (n <= m)%nat.
Lemma SSR_minus (n m : nat) : ssrnat.subn n m = (n - m)%nat.

Lemma rcons_ind {T : Type} (P : seq T -> Type) :
  P [::] -> (forall (s : seq T) (t : T), P s -> P (rcons s t)) -> forall s, P s.
Lemma rcons_dec {T : Type} (P : seq T -> Type) :
  (P [::]) -> (forall s t, P (rcons s t)) -> forall s, P s.
Lemma size_rcons_pos {T : Type} (s : seq T) (t : T) : (0 < size (rcons s t))%nat.

Lemma foldr_rcons {T T0 : Type} : forall (f : T0 -> T -> T) x0 s t,
  foldr f x0 (rcons s t) = foldr f (f t x0) s.
Lemma foldl_rcons {T T0 : Type} : forall (f : T -> T0 -> T) x0 s t,
  foldl f x0 (rcons s t) = f (foldl f x0 s) t.

Lemma head_rcons {T : Type} (x0 : T) (s : seq T) (t : T) : head x0 (rcons s t) = head t s.
Lemma behead_rcons {T : Type} (s : seq T) (t : T) :
  (0 < size s)%nat ->  behead (rcons s t) = rcons (behead s) t.
Definition belast {T : Type} (s : seq T) :=
  match s with
    | [::] => [::]
    | h :: s => belast h s
  end.
Lemma behead_rev {T : Type} (s : seq T) : behead (rev s) = rev (belast s).

Lemma pairmap_rcons {T T0 : Type} (f : T -> T -> T0) (s : seq T) h0 h x0 :
  pairmap f x0 (rcons (rcons s h0) h) = rcons (pairmap f x0 (rcons s h0)) (f h0 h).
Lemma map_pairmap {T T0 T1 : Type} (f : T0 -> T1) (g : T -> T -> T0) (s : seq T) (x0 : T) :
  map f (pairmap g x0 s) = pairmap (fun x y => f (g x y)) x0 s.
Lemma pairmap_map {T T0 T1 : Type} (f : T0 -> T0 -> T1) (g : T -> T0) (s : seq T) (x0 : T) :
  pairmap f (g x0) (map g s) = pairmap (fun x y => f (g x) (g y)) x0 s.

Lemma size_unzip1 {T T0 : Type} (s : seq (T * T0)) : size (unzip1 s) = size s.
Lemma size_unzip2 {T T0 : Type} (s : seq (T * T0)) : size (unzip2 s) = size s.
Lemma zip_cons {S T : Type} hs ht (s : seq S) (t : seq T) :
  zip (hs :: s) (ht :: t) = (hs,ht) :: zip s t.
Lemma zip_rcons {S T : Type} (s : seq S) (t : seq T) hs ht : size s = size t ->
  zip (rcons s hs) (rcons t ht) = rcons (zip s t) (hs,ht).
Lemma unzip1_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip1 (rcons s h) = rcons (unzip1 s) (fst h).
Lemma unzip2_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip2 (rcons s h) = rcons (unzip2 s) (snd h).
Lemma unzip1_belast {S T : Type} (s : seq (S*T)) :
  unzip1 (belast s) = belast (unzip1 s).
Lemma unzip2_belast {S T : Type} (s : seq (S*T)) :
  unzip2 (belast s) = belast (unzip2 s).
Lemma unzip1_behead {S T : Type} (s : seq (S*T)) :
  unzip1 (behead s) = behead (unzip1 s).
Lemma unzip2_behead {S T : Type} (s : seq (S*T)) :
  unzip2 (behead s) = behead (unzip2 s).
Lemma unzip1_fst {S T : Type} (s : seq (S*T)) :
  unzip1 s = map (@fst S T) s.
Lemma unzip2_snd {S T : Type} (s : seq (S*T)) :
  unzip2 s = map (@snd S T) s.
Lemma size_belast' {T : Type} (s : seq T) :
  size (belast s) = Peano.pred (size s).
Lemma head_map {T1 T2 : Type} (f : T1 -> T2) (s : seq T1) (x : T1) :
  head (f x) (map f s) = f (head x s).

Lemma StepFun_bound {a b : R} (f : StepFun a b) :
  exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_bound (f : R -> R) (a b : R) :
  Riemann_integrable f a b -> exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_ext : forall (f g : R -> R) (a b : R),
  (forall x, Rmin a b <= x <= Rmax a b -> f x = g x)
    -> Riemann_integrable f a b -> Riemann_integrable g a b.

Lemma RiemannInt_ext : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (Heq : forall x, Rmin a b <= x <= Rmax a b -> f x = g x),
    RiemannInt pr_f = RiemannInt pr_g.

Lemma Riemann_integrable_const : forall (c a b : R),
  Riemann_integrable (fun x => c) a b.

Lemma RiemannInt_const : forall (c a b : R) (pr : Riemann_integrable (fun x => c) a b),
  RiemannInt pr = c * (b-a).

Lemma Riemann_integrable_plus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x + g x) a b.

Lemma RiemannInt_plus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x + g x) a b),
  RiemannInt pr = RiemannInt pr_f + RiemannInt pr_g.

Lemma Riemann_integrable_minus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x - g x) a b.

Lemma RiemannInt_minus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x - g x) a b),
  RiemannInt pr = RiemannInt pr_f - RiemannInt pr_g.

Lemma Riemann_integrable_opp : forall (f : R -> R) (a b : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => - f x) a b.

Lemma RiemannInt_opp : forall (f : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => - f x) a b),
  RiemannInt pr = - RiemannInt pr_f.

Lemma Riemann_integrable_scal : forall (f : R -> R) (a b c : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => c * f x) a b.

Lemma RiemannInt_scal : forall (f : R -> R) (a b c : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => c * f x) a b),
  RiemannInt pr = c * RiemannInt pr_f.

Lemma ln_pow x n : 0 < x -> ln (x^n) = INR n * ln x.

Lemma ln_le x y : 0 < x -> x <= y -> ln x <= ln y.

Lemma ln_div x y : 0 < x -> 0 < y -> ln (x / y) = ln x - ln y.

Lemma derivable_pt_lim_atan :
  forall x, derivable_pt_lim atan x (/(1 + x^2)). *)
(* Markov:
Require Import RIneq Rcomplements Omega.

Open Scope R_scope.

Theorem LPO_min :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n /\ forall i, (i < n)%nat -> ~ P i} + {forall n, ~ P n}.

Theorem LPO :
  forall P : nat -> Prop, (forall n, P n \/ ~ P n) ->
  {n : nat | P n} + {forall n, ~ P n}.

Lemma LPO_bool :
  forall f : nat -> bool,
  {n | f n = true} + {forall n, f n = false}.

Lemma LPO_notforall : forall P : nat -> Prop, (forall n, P n \/ ~P n) ->
  (~ forall n : nat, ~ P n) -> exists n : nat, P n.

Lemma LPO_notnotexists : forall P : nat -> Prop, (forall n, P n \/ ~P n) ->
  ~~ (exists n : nat, P n) -> exists n : nat, P n.

Lemma LPO_ub_dec : forall (u : nat -> R),
  {M : R | forall n, u n <= M} + {forall M : R, exists n, M < u n}.

Lemma EM_dec :
  forall P : Prop, {not (not P)} + {not P}.

Lemma EM_dec' :
  forall P : Prop, P \/ not P -> {P} + {not P}. *)



Open Scope R_scope.



Definition is_ub_Rbar (E : R -> Prop) (l : Rbar) :=

  forall (x : R), E x -> Rbar_le x l.

Definition is_lb_Rbar (E : R -> Prop) (l : Rbar) :=

  forall (x : R), E x -> Rbar_le l x.



Lemma is_ub_Rbar_opp (E : R -> Prop) (l : Rbar) :

  is_lb_Rbar E l <-> is_ub_Rbar (fun x => E (- x)) (Rbar_opp l).

Proof.

  split ; intros Hl x Hx ; apply Rbar_opp_le.

  now rewrite Rbar_opp_involutive ; apply Hl.

  now apply Hl ; rewrite Ropp_involutive.

Qed.

Lemma is_lb_Rbar_opp (E : R -> Prop) (l : Rbar) :

  is_ub_Rbar E l <-> is_lb_Rbar (fun x => E (- x)) (Rbar_opp l).

Proof.

  split ; intros Hl x Hx ; apply Rbar_opp_le.

  now rewrite Rbar_opp_involutive ; apply Hl.

  now apply Hl ; rewrite Ropp_involutive.

Qed.



Lemma is_ub_Rbar_dec (E : R -> Prop) :

  {l : R | is_ub_Rbar E l} + {(forall l : R, ~is_ub_Rbar E l)}.

Proof.

  set (F (n : nat) (x : R) := x = 0 \/ (E x /\ x <= INR n)).

  assert (F_b : forall n, bound (F n)).

    intros ; exists (INR n) => x ; case => [-> | Hx].

    by apply pos_INR.

    by apply Hx.

  assert (F_ex : forall n, (exists x : R, F n x)).

    intros ; exists 0 ; by left.

  set (u (n : nat) := proj1_sig (completeness (F n) (F_b n) (F_ex n))).

  destruct (LPO_ub_dec u) as [ [M HM] | HM].

  + left ; exists M => x Hx.

    destruct (nfloor_ex (Rmax 0 x)) as [n Hn].

    by apply Rmax_l.

    eapply Rle_trans, (HM (S n)).

    rewrite /u ; case: completeness => l Hl /=.

    apply Hl ; right ; split => //.

    rewrite S_INR ; eapply Rle_trans, Rlt_le, Hn.

    by apply Rmax_r.

  + right => l Hl.

    case: (HM (Rmax 0 l)) => n {HM}.

    apply Rle_not_lt.

    rewrite /u ; case: completeness => M HM /=.

    apply HM => x ; case => [ -> | Hx].

    by apply Rmax_l.

    eapply Rle_trans, Rmax_r.

    apply Hl, Hx.

Qed.



Lemma is_lb_Rbar_dec (E : R -> Prop) :

  {l : R | is_lb_Rbar E l} + {(forall l : R, ~is_lb_Rbar E l)}.

Proof.

  destruct (is_ub_Rbar_dec (fun x => E (- x))) as [ [l Hl] | Hl ].

  left ; exists (Rbar_opp l).

  by apply is_ub_Rbar_opp ; rewrite (Rbar_opp_involutive l).

  right => l.

  specialize (Hl (Rbar_opp l)).

  contradict Hl.

  by apply (is_ub_Rbar_opp E l).

Qed.



Lemma is_ub_Rbar_subset (E1 E2 : R -> Prop) (l : Rbar) :

  (forall x : R, E2 x -> E1 x) -> is_ub_Rbar E1 l -> is_ub_Rbar E2 l.

Proof.

  move => H ub1 x Hx.

  apply: ub1 ; by apply: H.

Qed.

Lemma is_lb_Rbar_subset (E1 E2 : R -> Prop) (l : Rbar) :

  (forall x : R, E2 x -> E1 x) -> is_lb_Rbar E1 l -> is_lb_Rbar E2 l.

Proof.

  move => H ub1 x Hx.

  apply: ub1 ; by apply: H.

Qed.



Definition is_lub_Rbar (E : R -> Prop) (l : Rbar) :=

  is_ub_Rbar E l /\ (forall b, is_ub_Rbar E b -> Rbar_le l b).

Definition is_glb_Rbar (E : R -> Prop) (l : Rbar) :=

  is_lb_Rbar E l /\ (forall b, is_lb_Rbar E b -> Rbar_le b l).



Lemma is_lub_Rbar_opp (E : R -> Prop) (l : Rbar) :

  is_glb_Rbar E l <-> is_lub_Rbar (fun x => E (- x)) (Rbar_opp l).

Proof.

  split => [[lb glb] | [ub lub] ] ; split.

  by apply is_ub_Rbar_opp.

  intros b Hb.

  apply Rbar_opp_le ; rewrite Rbar_opp_involutive.

  apply glb, is_ub_Rbar_opp ; by rewrite Rbar_opp_involutive.

  by apply is_ub_Rbar_opp.

  intros b Hb.

  apply Rbar_opp_le.

  by apply lub, is_ub_Rbar_opp.

Qed.

Lemma is_glb_Rbar_opp (E : R -> Prop) (l : Rbar) :

  is_lub_Rbar E l <-> is_glb_Rbar (fun x => E (- x)) (Rbar_opp l).

Proof.

  split => [[lb glb] | [ub lub] ] ; split.

  by apply is_lb_Rbar_opp.

  intros b Hb.

  apply Rbar_opp_le ; rewrite Rbar_opp_involutive.

  apply glb, is_lb_Rbar_opp ; by rewrite Rbar_opp_involutive.

  by apply is_lb_Rbar_opp.

  intros b Hb.

  apply Rbar_opp_le.

  by apply lub, is_lb_Rbar_opp.

Qed.



Lemma ex_lub_Rbar (E : R -> Prop) : {l : Rbar | is_lub_Rbar E l}.

Proof.

  destruct (is_ub_Rbar_dec E)  as [[M HM] | HM] ; first last.



  exists p_infty ; split.

  by [].

  case => [l | | ] // Hl.

  by specialize (HM l).

  specialize (HM 0).

  contradict HM => x Hx.

  by specialize (Hl x Hx).



rename E into F.

  assert (F_b : bound F).

    exists M => x Hx.

    by apply HM.

    clear -F_b.



  set (E (m : nat) (x : R) := x = - INR m \/ F x).

  assert (E_b : forall m, bound (E m)).

    intros m.

    case: F_b => l Hl.

    exists (Rmax l (- INR m)) => x ; case => [ -> | Hx].

    by apply Rmax_r.

    eapply Rle_trans, Rmax_l.

    by apply Hl.

  assert (E_ex : forall m, exists x : R, E m x).

    intros m ; exists (- INR m) ; by left.

  set (u m := proj1_sig (completeness (E m) (E_b m) (E_ex m))).



  destruct (LPO (fun n => u n <> - INR n)) as [ [n Hn] | Hn].

    intros n.

    case: (Req_EM_T (u n) (- INR n)) => H.

    by right.

    by left.

  exists (u n).

  move: Hn ; rewrite /u ; case: completeness => l Hl /= H.

  split.

  intros x Hx.

  apply Hl ; by right.

  assert (- INR n < l).

  case: Hl => Hl _.

  case: (Hl (-INR n)) => //=.

  by left.

  intros H0 ; contradict H.

  by rewrite -H0.

  case => [b | | ] //= Hb.

  + apply Hl => x Hx.

    case: Hx => Hx ; first last.

    by apply Hb.

    rewrite Hx.

    apply Rnot_lt_le ; contradict H0.

    apply Rle_not_lt.

    apply Hl => y Hy.

    case: Hy => Hy.

    rewrite Hy ; apply Rle_refl.

    eapply Rle_trans, Rlt_le, H0.

    by apply Hb.

  + contradict H.

    apply Rle_antisym ; apply Hl.

    intros x Hx.

    case: Hx => [-> | Hx] //.

    by apply Rle_refl.

    by apply Hb in Hx.

    by left.

  assert (forall n, u n = - INR n).

    intros n.

    specialize (Hn n).

    case: (Req_dec (u n) (- INR n)) => // H.

    clear Hn.

  exists m_infty ; split => // x Hx.

  destruct (nfloor_ex (Rmax 0 (- x))) as [n Hn].

  by apply Rmax_l.

  specialize (H (S n)).

  contradict H.

  apply Rgt_not_eq.

  rewrite /u S_INR ; case: completeness => l Hl /=.

  eapply Rlt_le_trans with x.

  apply Ropp_lt_cancel ; rewrite Ropp_involutive.

  eapply Rle_lt_trans, Hn.

  by apply Rmax_r.

  apply Hl.

  by right.

Qed.

Lemma ex_glb_Rbar (E : R -> Prop) : {l : Rbar | is_glb_Rbar E l}.

Proof.

  case: (ex_lub_Rbar (fun x => E (- x))) => l Hl.

  exists (Rbar_opp l).

  apply is_lub_Rbar_opp ; by rewrite Rbar_opp_involutive.

Qed.



Definition Lub_Rbar (E : R -> Prop) := proj1_sig (ex_lub_Rbar E).

Definition Glb_Rbar (E : R -> Prop) := proj1_sig (ex_glb_Rbar E).



Lemma is_lub_Rbar_unique (E : R -> Prop) (l : Rbar) :

  is_lub_Rbar E l -> Lub_Rbar E = l.

Proof.

  move => Hl ; rewrite /Lub_Rbar ; case: ex_lub_Rbar => l' /= Hl'.

  apply Rbar_le_antisym.

  by apply Hl', Hl.

  by apply Hl, Hl'.

Qed.

Lemma is_glb_Rbar_unique (E : R -> Prop) (l : Rbar) :

  is_glb_Rbar E l -> Glb_Rbar E = l.

Proof.

  move => Hl ; rewrite /Glb_Rbar ; case: ex_glb_Rbar => l' /= Hl'.

  apply Rbar_le_antisym.

  by apply Hl, Hl'.

  by apply Hl', Hl.

Qed.



Lemma Lub_Rbar_correct (E : R -> Prop) :

  is_lub_Rbar E (Lub_Rbar E).

Proof.

  rewrite /Lub_Rbar ; by case: ex_lub_Rbar => l /= Hl.

Qed.

Lemma Glb_Rbar_correct (E : R -> Prop) :

  is_glb_Rbar E (Glb_Rbar E).

Proof.

  rewrite /Glb_Rbar ; by case: ex_glb_Rbar => l /= Hl.

Qed.



Lemma is_lub_Rbar_subset (E1 E2 : R -> Prop) (l1 l2 : Rbar) :

  (forall x : R, E2 x -> E1 x) -> is_lub_Rbar E1 l1 -> is_lub_Rbar E2 l2

    -> Rbar_le l2 l1.

Proof.

  move => H [ub1 _] [_ lub2].

  apply: lub2 ; by apply (is_ub_Rbar_subset E1), ub1.

Qed.

Lemma is_glb_Rbar_subset (E1 E2 : R -> Prop) (l1 l2 : Rbar) :

  (forall x : R, E2 x -> E1 x) -> is_glb_Rbar E1 l1 -> is_glb_Rbar E2 l2

    -> Rbar_le l1 l2.

Proof.

  move => H [ub1 _] [_ lub2].

  apply: lub2 ; by apply (is_lb_Rbar_subset E1), ub1.

Qed.



Lemma is_lub_Rbar_eqset (E1 E2 : R -> Prop) (l : Rbar) :

  (forall x : R, E2 x <-> E1 x) -> is_lub_Rbar E1 l -> is_lub_Rbar E2 l.

Proof.

  move => H [ub1 lub1] ; split.

  apply (is_ub_Rbar_subset E1) ; [apply H | apply ub1].

  move => b Hb ; apply: lub1 ; apply (is_ub_Rbar_subset E2) ; [apply H | apply Hb].

Qed.

Lemma is_glb_Rbar_eqset (E1 E2 : R -> Prop) (l : Rbar) :

  (forall x : R, E2 x <-> E1 x) -> is_glb_Rbar E1 l -> is_glb_Rbar E2 l.

Proof.

  move => H [ub1 lub1] ; split.

  apply (is_lb_Rbar_subset E1) ; [apply H | apply ub1].

  move => b Hb ; apply: lub1 ; apply (is_lb_Rbar_subset E2) ; [apply H | apply Hb].

Qed.



Lemma Lub_Rbar_eqset (E1 E2 : R -> Prop) :

  (forall x, E1 x <-> E2 x) -> Lub_Rbar E1 = Lub_Rbar E2.

Proof.

  move => H ; rewrite {2}/Lub_Rbar ;

  case: ex_lub_Rbar => l /= Hl.

  apply is_lub_Rbar_unique.

  move: Hl ; by apply is_lub_Rbar_eqset.

Qed.

Lemma Glb_Rbar_eqset (E1 E2 : R -> Prop) :

  (forall x, E1 x <-> E2 x) -> Glb_Rbar E1 = Glb_Rbar E2.

Proof.

  move => H ; rewrite {2}/Glb_Rbar ;

  case: (ex_glb_Rbar E2) => l2 H2 /=.

  apply is_glb_Rbar_unique.

  move: H2 ; by apply is_glb_Rbar_eqset.

Qed.



Definition Rbar_is_upper_bound (E : Rbar -> Prop) (l : Rbar) :=

  forall x, E x -> Rbar_le x l.



Definition Rbar_is_lower_bound (E : Rbar -> Prop) (l : Rbar) :=

  forall x, E x -> Rbar_le l x.



Lemma Rbar_ub_lb (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_upper_bound (fun x => E (Rbar_opp x)) (Rbar_opp l)

    <-> Rbar_is_lower_bound E l.

Proof.

  split => Hl x Hx.

  apply Rbar_opp_le.

  apply Hl.

  by rewrite Rbar_opp_involutive.

  apply Rbar_opp_le.

  rewrite Rbar_opp_involutive.

  by apply Hl.

Qed.

Lemma Rbar_lb_ub (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_lower_bound (fun x => E (Rbar_opp x)) (Rbar_opp l)

    <-> Rbar_is_upper_bound E l.

Proof.

  split => Hl x Hx.

  apply Rbar_opp_le.

  apply Hl.

  by rewrite Rbar_opp_involutive.

  apply Rbar_opp_le.

  rewrite Rbar_opp_involutive.

  by apply Hl.

Qed.



Lemma is_ub_Rbar_correct (E : R -> Prop) (l : Rbar) :

  is_ub_Rbar E l <-> Rbar_is_upper_bound (fun x => is_finite x /\ E x) l.

Proof.

  split => [H x [<- Hx] | H x Hx] ; apply H => // ;

  by exists x.

Qed.

Lemma is_lb_Rbar_correct (E : R -> Prop) (l : Rbar) :

  is_lb_Rbar E l <-> Rbar_is_lower_bound (fun x => is_finite x /\ E x) l.

Proof.

  split => [H x [<- Hx] | H x Hx] ; apply H => // ;

  by exists x.

Qed.



Lemma Rbar_ub_p_infty (E : Rbar -> Prop) :

  Rbar_is_upper_bound E p_infty.

Proof.

  now intros [x| |] Hx.

Qed.

Lemma Rbar_lb_m_infty (E : Rbar -> Prop) :

  Rbar_is_lower_bound E m_infty.

Proof.

  easy.

Qed.



Lemma Rbar_ub_Finite (E : Rbar -> Prop) (l : R) :

  Rbar_is_upper_bound E l ->

    is_upper_bound (fun (x : R) => E x) l.

Proof.

  intros H x Ex.

  now apply (H (Finite x)).

Qed.

Lemma Rbar_lb_Finite (E : Rbar -> Prop) (l : R) :

  Rbar_is_lower_bound E (Finite l) ->

    is_upper_bound (fun x => E (Finite (- x))) (- l).

Proof.

  intros H x Ex.

  apply Ropp_le_cancel ; rewrite Ropp_involutive ;

  now apply (H (Finite (-x))).

Qed.



Lemma Rbar_ub_m_infty (E : Rbar -> Prop) :

  Rbar_is_upper_bound E m_infty -> forall x, E x -> x = m_infty.

Proof.

  intros H [x| |] Hx ;

  now specialize (H _ Hx).

Qed.

Lemma Rbar_lb_p_infty (E : Rbar -> Prop) :

  Rbar_is_lower_bound E p_infty -> (forall x, E x -> x = p_infty).

Proof.

  intros H x ;

  case x ; auto ; clear x ; [intros x| ] ; intros Hx.

  case (H _ Hx) ; simpl ; intuition.

  case (H _ Hx) ; simpl ; intuition.

Qed.



Lemma Rbar_lb_le_ub (E : Rbar -> Prop) (l1 l2 : Rbar) : (exists x, E x) ->

  Rbar_is_lower_bound E l1 -> Rbar_is_upper_bound E l2 -> Rbar_le l1 l2.

Proof.

  intros (x, Hex) Hl Hu ;

  apply Rbar_le_trans with (y := x) ; [apply Hl | apply Hu] ; auto.

Qed.

Lemma Rbar_lb_eq_ub (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_lower_bound E l -> Rbar_is_upper_bound E l -> forall x, E x -> x = l.

Proof.

  intros Hl Hu x Hx.

  apply Rbar_le_antisym ; [apply Hu | apply Hl] ; auto.

Qed.



Lemma Rbar_ub_dec (E : Rbar -> Prop) (Hp : ~ E p_infty) :

  {M : R | Rbar_is_upper_bound E M}

    + {(forall (M : R), ~Rbar_is_upper_bound E M)}.

Proof.

  destruct (is_ub_Rbar_dec E) as [ [M HM] | HM ].

  left ; exists M ; case => [x | | ] //= Hx.

  by apply HM.

  right => M.

  specialize (HM M).

  contradict HM => x Hx.

  by apply HM.

Qed.

Lemma Rbar_lb_dec (E : Rbar -> Prop) (Hm : ~ E m_infty) :

  {M : R | Rbar_is_lower_bound E (Finite M)}

    + {(forall M, ~Rbar_is_lower_bound E (Finite M))}.

Proof.

  destruct (Rbar_ub_dec (fun x => E (Rbar_opp x)) Hm) as [(M, H)|H].

  left ; exists (-M).

  apply Rbar_ub_lb ; simpl ; rewrite (Ropp_involutive M) ; auto.

  right ; intro M ; generalize (H (-M)) ; clear H ; intro H ; contradict H ;

  apply (Rbar_ub_lb E (Finite M)) ; auto.

Qed.



Lemma Rbar_is_ub_subset (E1 E2 : Rbar -> Prop) (l : Rbar) :

  (forall x, E1 x -> E2 x) -> (Rbar_is_upper_bound E2 l) -> (Rbar_is_upper_bound E1 l).

Proof.

  intros Hs Hl x Ex ; apply Hl, Hs ; auto.

Qed.

Lemma Rbar_is_lb_subset (E1 E2 : Rbar -> Prop) (l : Rbar) :

  (forall x, E1 x -> E2 x) -> (Rbar_is_lower_bound E2 l) -> (Rbar_is_lower_bound E1 l).

Proof.

  intros Hs Hl x Ex ; apply Hl, Hs ; auto.

Qed.



Definition Rbar_is_lub (E : Rbar -> Prop) (l : Rbar) :=

  Rbar_is_upper_bound E l /\

    (forall b : Rbar, Rbar_is_upper_bound E b -> Rbar_le l b).

Definition Rbar_is_glb (E : Rbar -> Prop) (l : Rbar) :=

  Rbar_is_lower_bound E l /\

    (forall b : Rbar, Rbar_is_lower_bound E b -> Rbar_le b l).



Lemma Rbar_lub_glb (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_lub (fun x => E (Rbar_opp x)) (Rbar_opp l)

    <-> Rbar_is_glb E l.

Proof.

  split ; [intros (ub, lub) | intros (lb, glb)] ; split.

  apply Rbar_ub_lb ; auto.

  intros b Hb ; generalize (lub _ (proj2 (Rbar_ub_lb _ _) Hb)) ; apply Rbar_opp_le.

  apply Rbar_lb_ub ; intros x ; simpl ; repeat rewrite Rbar_opp_involutive ; apply lb.

  intros b Hb.

  apply Rbar_opp_le ; rewrite Rbar_opp_involutive ; apply glb, Rbar_ub_lb ;

  rewrite Rbar_opp_involutive ; auto.

Qed.

Lemma Rbar_glb_lub (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_glb (fun x => E (Rbar_opp x)) (Rbar_opp l)

    <-> Rbar_is_lub E l.

Proof.

  split ; [ intros (lb, glb) | intros (ub, lub)] ; split.

  apply Rbar_lb_ub ; auto.

  intros b Hb ; generalize (glb _ (proj2 (Rbar_lb_ub _ _) Hb)) ; apply Rbar_opp_le.

  apply Rbar_ub_lb ; intro x ; simpl ; repeat rewrite Rbar_opp_involutive ; apply ub.

  intros b Hb.

  apply Rbar_opp_le ; rewrite Rbar_opp_involutive ; apply lub, Rbar_lb_ub ;

  rewrite Rbar_opp_involutive ; auto.

Qed.



Lemma is_lub_Rbar_correct (E : R -> Prop) (l : Rbar) :

  is_lub_Rbar E l <-> Rbar_is_lub (fun x => is_finite x /\ E x) l.

Proof.

  split => [[Hub Hlub]|[Hub Hlub]].

  split ; [ | move => b Hb ; apply Hlub ] ; by apply is_ub_Rbar_correct.

  split ; [ | move => b Hb ; apply Hlub ] ; by apply is_ub_Rbar_correct.

Qed.

Lemma is_glb_Rbar_correct (E : R -> Prop) (l : Rbar) :

  is_glb_Rbar E l <-> Rbar_is_glb (fun x => is_finite x /\ E x) l.

Proof.

  split => [[Hub Hlub]|[Hub Hlub]].

  split ; [ | move => b Hb ; apply Hlub ] ; by apply is_lb_Rbar_correct.

  split ; [ | move => b Hb ; apply Hlub ] ; by apply is_lb_Rbar_correct.

Qed.



Lemma Rbar_ex_lub (E : Rbar -> Prop) :

  {l : Rbar | Rbar_is_lub E l}.

Proof.

  destruct (EM_dec (E p_infty)) as [Hp|Hp].

  exists p_infty ; split.

  by case.

  intros b Hb.

  apply Rbar_not_lt_le.

  contradict Hp => H.

  apply: Rbar_le_not_lt Hp.

  by apply Hb.

  destruct (ex_lub_Rbar E) as [l Hl].

  exists l ; split.

  case => [x | | ] // Hx.

  by apply Hl.

  intros b Hb.

  apply Hl => x Hx.

  by apply Hb.

Qed.



Lemma Rbar_ex_glb (E : Rbar -> Prop) :

  {l : Rbar | Rbar_is_glb E l}.

Proof.

  destruct (Rbar_ex_lub (fun x => E (Rbar_opp x))) as [l Hl].

  exists (Rbar_opp l).

  now apply Rbar_lub_glb ; rewrite Rbar_opp_involutive.

Qed.



Definition Rbar_lub (E : Rbar -> Prop)

  := proj1_sig (Rbar_ex_lub E).

Definition Rbar_glb (E : Rbar -> Prop)

  := proj1_sig (Rbar_ex_glb E).



Lemma Rbar_opp_glb_lub (E : Rbar -> Prop) :

  Rbar_glb (fun x => E (Rbar_opp x)) = Rbar_opp (Rbar_lub E).

Proof.

  unfold Rbar_glb ; case (Rbar_ex_glb _) ; simpl ; intros g [Hg Hg'] ;

  unfold Rbar_lub ; case (Rbar_ex_lub _) ; simpl ; intros l [Hl Hl'] ;

  apply Rbar_le_antisym.

  apply Rbar_opp_le ; rewrite Rbar_opp_involutive ; apply Hl', Rbar_lb_ub ;

  rewrite Rbar_opp_involutive ; auto.

  apply Hg', Rbar_lb_ub ; auto.

Qed.

Lemma Rbar_opp_lub_glb (E : Rbar -> Prop) :

  Rbar_lub (fun x => E (Rbar_opp x)) = Rbar_opp (Rbar_glb E).

Proof.

  unfold Rbar_glb ; case (Rbar_ex_glb _) ; simpl ; intros g (Hg, Hg') ;

  unfold Rbar_lub ; case (Rbar_ex_lub _) ; simpl ; intros l [Hl Hl'] ;

  apply Rbar_le_antisym.

  apply Hl', Rbar_lb_ub ; rewrite Rbar_opp_involutive ;

  apply (Rbar_is_lb_subset _ E) ; auto ; intros x ; rewrite Rbar_opp_involutive ; auto.

  apply Rbar_opp_le ; rewrite Rbar_opp_involutive ; apply Hg', Rbar_ub_lb ;

  rewrite Rbar_opp_involutive ; auto.

Qed.



Lemma Rbar_is_lub_unique (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_lub E l -> Rbar_lub E = l.

Proof.

  move => H.

  rewrite /Rbar_lub.

  case: Rbar_ex_lub => l0 H0 /=.

  apply Rbar_le_antisym.

  apply H0, H.

  apply H, H0.

Qed.

Lemma Rbar_is_glb_unique (E : Rbar -> Prop) (l : Rbar) :

  Rbar_is_glb E l -> Rbar_glb E = l.

Proof.

  move => H.

  rewrite /Rbar_glb.

  case: Rbar_ex_glb => l0 H0 /=.

  apply Rbar_le_antisym.

  apply H, H0.

  apply H0, H.

Qed.



Lemma Rbar_glb_le_lub (E : Rbar -> Prop) :

  (exists x, E x) -> Rbar_le (Rbar_glb E) (Rbar_lub E).

Proof.

  case => x Hex.

  apply Rbar_le_trans with x.

  unfold Rbar_glb ; case (Rbar_ex_glb _) ; simpl ; intros g (Hg, _) ; apply Hg ; auto.

  unfold Rbar_lub ; case (Rbar_ex_lub _) ; simpl ; intros l (Hl, _) ; apply Hl ; auto.

Qed.



Lemma Rbar_is_lub_subset (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :

  (forall x, E1 x -> E2 x) -> (Rbar_is_lub E1 l1) -> (Rbar_is_lub E2 l2)

  -> Rbar_le l1 l2.

Proof.

  intros Hs (_,H1) (H2, _).

  apply H1 ; intros x Hx ; apply H2, Hs, Hx.

Qed.

Lemma Rbar_is_glb_subset (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :

  (forall x, E2 x -> E1 x) -> (Rbar_is_glb E1 l1) -> (Rbar_is_glb E2 l2)

  -> Rbar_le l1 l2.

Proof.

  intros Hs (H1, _) (_, H2).

  apply H2 ; intros x Hx ; apply H1, Hs, Hx.

Qed.



Lemma Rbar_is_lub_eq (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :

  (forall x, E1 x <-> E2 x) -> (Rbar_is_lub E1 l1) -> (Rbar_is_lub E2 l2)

  -> l1 = l2.

Proof.

  intros Hs H1 H2 ; apply Rbar_le_antisym ;

  [apply (Rbar_is_lub_subset E1 E2) | apply (Rbar_is_lub_subset E2 E1) ] ; auto ; intros x H ;

  apply Hs ; auto.

Qed.

Lemma Rbar_is_glb_eq (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :

  (forall x, E1 x <-> E2 x) -> (Rbar_is_glb E1 l1) -> (Rbar_is_glb E2 l2)

  -> l1 = l2.

Proof.

  intros Hs H1 H2 ; apply Rbar_le_antisym ;

  [apply (Rbar_is_glb_subset E1 E2) | apply (Rbar_is_glb_subset E2 E1) ] ; auto ; intros x H ;

  apply Hs ; auto.

Qed.



Lemma Rbar_is_lub_ext (E1 E2 : Rbar -> Prop) (l : Rbar) :

  (forall x, E1 x <-> E2 x) -> (Rbar_is_lub E1 l) -> (Rbar_is_lub E2 l).

Proof.

  intros Heq (H1,H2) ; split.

  apply (Rbar_is_ub_subset _ E1) ; auto ; intros x Hx ; apply Heq ; auto.

  intros b Hb ; apply H2 ; apply (Rbar_is_ub_subset _ E2) ; auto ; intros x Hx ; apply Heq ; auto.

Qed.

Lemma Rbar_is_glb_ext (E1 E2 : Rbar -> Prop) (l : Rbar) :

  (forall x, E1 x <-> E2 x) -> (Rbar_is_glb E1 l) -> (Rbar_is_glb E2 l).

Proof.

  intros Heq (H1, H2) ; split.

  apply (Rbar_is_lb_subset _ E1) ; auto ; intros x Hx ; apply Heq ; auto.

  intros b Hb ; apply H2 ; apply (Rbar_is_lb_subset _ E2) ; auto ; intros x Hx ; apply Heq ; auto.

Qed.



Lemma Rbar_lub_subset (E1 E2 : Rbar -> Prop) :

  (forall x, E1 x -> E2 x) -> Rbar_le (Rbar_lub E1) (Rbar_lub E2).

Proof.

  intros Hs ; unfold Rbar_lub ; case (Rbar_ex_lub E1) ; intros l1 Hl1 ;

  case (Rbar_ex_lub E2) ; simpl ; intros l2 Hl2 ; apply (Rbar_is_lub_subset E1 E2) ; auto.

Qed.

Lemma Rbar_glb_subset (E1 E2 : Rbar -> Prop) :

  (forall x, E2 x -> E1 x) -> Rbar_le (Rbar_glb E1) (Rbar_glb E2).

Proof.

  intro Hs ; unfold Rbar_glb ; case (Rbar_ex_glb E1) ; intros l1 Hl1 ;

  case (Rbar_ex_glb E2) ; simpl ; intros l2 Hl2 ; apply (Rbar_is_glb_subset E1 E2) ; auto.

Qed.



Lemma Rbar_lub_rw (E1 E2 : Rbar -> Prop) :

  (forall x, E1 x <-> E2 x) -> Rbar_lub E1 = Rbar_lub E2.

Proof.

  intro Hs ; apply Rbar_le_antisym ; apply Rbar_lub_subset ; intros x H ; apply Hs ; auto.

Qed.

Lemma Rbar_glb_rw (E1 E2 : Rbar -> Prop) :

  (forall x, E1 x <-> E2 x) -> Rbar_glb E1 = Rbar_glb E2.

Proof.

  intros Hs ; apply Rbar_le_antisym ; apply Rbar_glb_subset ; intros x H ; apply Hs ; auto.

Qed.



Definition Empty (E : R -> Prop) :=

  Lub_Rbar (fun x => x = 0 \/ E x) = Glb_Rbar (fun x => x = 0 \/ E x)

  /\ Lub_Rbar (fun x => x = 1 \/ E x) = Glb_Rbar (fun x => x = 1 \/ E x).



Lemma Empty_correct_1 (E : R -> Prop) :

  Empty E -> forall x, ~ E x.

Proof.

  case => E0 E1 x Ex.

  rewrite /Lub_Rbar /Glb_Rbar in E0 ;

  case : (ex_lub_Rbar (fun x : R => x = 0 \/ E x)) E0 => /= s0 Hs0 ;

  case : (ex_glb_Rbar (fun x : R => x = 0 \/ E x)) => i0 Hi0 /= E0.

  have : (x = 0) ; last move => {s0 Hs0 i0 Hi0 E0}.

  apply Rle_antisym.

  apply (Rbar_le_trans x s0 0).

  apply Hs0 ; by right.

  rewrite E0 ; apply Hi0 ; by left.

  apply (Rbar_le_trans 0 s0 x).

  apply Hs0 ; by left.

  rewrite E0 ; apply Hi0 ; by right.

  rewrite /Lub_Rbar /Glb_Rbar in E1 ;

  case : (ex_lub_Rbar (fun x : R => x = 1 \/ E x)) E1 => /= s1 Hs1 ;

  case : (ex_glb_Rbar (fun x : R => x = 1 \/ E x)) => i1 Hi1 /= E1.

  have : (x = 1) ; last move => {s1 Hs1 i1 Hi1 E1}.

  apply Rle_antisym.

  apply (Rbar_le_trans x s1 1).

  apply Hs1 ; by right.

  rewrite E1 ; apply Hi1 ; by left.

  apply (Rbar_le_trans 1 s1 x).

  apply Hs1 ; by left.

  rewrite E1 ; apply Hi1 ; by right.

  move => -> ; apply R1_neq_R0.

Qed.



Lemma Empty_correct_2 (E : R -> Prop) :

  (forall x, ~ E x) -> Empty E.

Proof.

  move => H ; split ;

  rewrite /Glb_Rbar /Lub_Rbar ;

  [ case : (ex_lub_Rbar (fun x : R => x = 0 \/ E x)) => s0 Hs0 ;

  case : (ex_glb_Rbar (fun x : R => x = 0 \/ E x)) => i0 Hi0 /=

  | case : (ex_lub_Rbar (fun x : R => x = 1 \/ E x)) => s1 Hs1 ;

  case : (ex_glb_Rbar (fun x : R => x = 1 \/ E x)) => i1 Hi1 /=].

  have : (i0 = Finite 0) ; last move => -> ;

  apply: Rbar_le_antisym.

  apply Hi0 ; by left.

  apply Hi0 => y ; case => H0.

  rewrite H0 ; by right.

  contradict H0 ; apply H.

  apply Hs0 => y ; case => H0.

  rewrite H0 ; by right.

  contradict H0 ; apply H.

  apply Hs0 ; by left.

  have : (i1 = Finite 1) ; last move => -> ;

  apply: Rbar_le_antisym.

  apply Hi1 ; by left.

  apply Hi1 => y ; case => H1.

  rewrite H1 ; by right.

  contradict H1 ; apply H.

  apply Hs1 => y ; case => H1.

  rewrite H1 ; by right.

  contradict H1 ; apply H.

  apply Hs1 ; by left.

Qed.



Lemma Empty_dec (E : R -> Prop) :

  {~Empty E}+{Empty E}.

Proof.

  case: (Rbar_eq_dec (Lub_Rbar (fun x => x = 0 \/ E x)) (Glb_Rbar (fun x => x = 0 \/ E x))) => H0 ;

    [ | left].

  case: (Rbar_eq_dec (Lub_Rbar (fun x => x = 1 \/ E x)) (Glb_Rbar (fun x => x = 1 \/ E x))) => H1 ;

    [by right | left].

  contradict H1 ; apply H1.

  contradict H0 ; apply H0.

Qed.

Lemma not_Empty_dec (E : R -> Prop) : (Decidable.decidable (exists x, E x)) ->

  {(exists x, E x)} + {(forall x, ~ E x)}.

Proof.

  move => He ;

  case: (Empty_dec E) => Hx ;

  [left|right].

  case: He => // He.

  contradict Hx ;

  apply: Empty_correct_2 => x ; contradict He ; by exists x.

  by apply: Empty_correct_1.

Qed.



Lemma uniqueness_dec P : (exists ! x : R, P x) -> {x : R | P x}.

Proof.

  move => H.

  exists (Lub_Rbar P).

  case: H => x Hx.

  replace (real (Lub_Rbar P)) with (real (Finite x)).

  by apply Hx.

  apply f_equal, sym_eq, is_lub_Rbar_unique.

  split.

  move => y Hy.

  right ; by apply sym_eq, Hx.

  move => b Hb.

  by apply Hb, Hx.

Qed.

