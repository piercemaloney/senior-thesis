

Require Import Reals Psatz.

Require Import mathcomp.ssreflect.ssreflect mathcomp.ssreflect.seq mathcomp.ssreflect.ssrbool.

Require Import Rcomplements Rbar Lub.
(* Rcomplements:
Ltac evar_last :=
  match goal with
  | |- ?f ?x =>
    let tx := type of x in
    let tx := eval simpl in tx in
    let tmp := fresh "tmp" in
    evar (tmp : tx) ;
    refine (@eq_ind tx tmp f _ x _) ;
    unfold tmp ; clear tmp
  end.

Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Psatz.

Module MyNat.

Lemma neq_succ_0 (n : nat) : S n <> 0.

Lemma sub_succ (n m : nat) : S n - S m = n - m.

Lemma sub_succ_l (n m : nat) : n <= m -> S m - n = S (m - n).

Lemma lt_neq (n m : nat) : n < m -> n <> m.

Lemma minus_0_le (n m : nat) : n <= m -> n - m = 0.

Lemma sub_succ_r (n m : nat) : n - S m = pred (n - m).

Lemma sub_add (n m : nat) : n <= m -> m - n + n = m.

Lemma le_pred_le_succ (n m : nat) : pred n <= m <-> n <= S m.

End MyNat.

Require Import Even Div2.
Require Import mathcomp.ssreflect.seq mathcomp.ssreflect.ssrbool.

Open Scope R_scope.

Lemma floor_ex : forall x : R, {n : Z | IZR n <= x < IZR n + 1}.
Definition floor x := proj1_sig (floor_ex x).

Lemma floor1_ex : forall x : R, {n : Z | IZR n < x <= IZR n + 1}.
Definition floor1 x := proj1_sig (floor1_ex x).

Lemma nfloor_ex : forall x : R, 0 <= x -> {n : nat | INR n <= x < INR n + 1}.
Definition nfloor x pr := proj1_sig (nfloor_ex x pr).

Lemma nfloor1_ex : forall x : R, 0 < x -> {n : nat | INR n < x <= INR n + 1}.
Definition nfloor1 x pr := proj1_sig (nfloor1_ex x pr).

Lemma INRp1_pos : forall n, 0 < INR n + 1.

Lemma Rlt_nat (x : R) : (exists n : nat, x = INR (S n)) -> 0 < x.

Lemma Rle_pow_lin (a : R) (n : nat) :
  0 <= a -> 1 + INR n * a <= (1 + a) ^ n.

Lemma C_n_n: forall n, C n n = 1.

Lemma C_n_0: forall n, C n 0 = 1.

Fixpoint pow2 (n : nat) : nat :=
  match n with
    | O => 1%nat
    | S n => (2 * pow2 n)%nat
  end.

Lemma pow2_INR (n : nat) : INR (pow2 n) = 2^n.

Lemma pow2_pos (n : nat) : (0 < pow2 n)%nat.

Lemma Rinv_le_contravar :
  forall x y, 0 < x -> x <= y -> / y <= / x.

Lemma Rinv_lt_cancel (x y : R) :
  0 < y -> / y < / x -> x < y.

Lemma Rdiv_1 : forall x : R, x / 1 = x.

Lemma Rdiv_plus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b + c / d = (a * d + c * b) / (b * d).

Lemma Rdiv_minus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b - c / d = (a * d - c * b) / (b * d).

Lemma Rplus_lt_reg_l (x y z : R) : x + y < x + z -> y < z.

Lemma Rplus_lt_reg_r (x y z : R) : y + x < z + x -> y < z.

Lemma Rle_div_l : forall a b c, c > 0 -> (a / c <= b <-> a <= b * c).

Lemma Rle_div_r : forall a b c, c > 0 -> (a * c <= b <-> a <= b / c).

Lemma Rlt_div_l : forall a b c, c > 0 -> (a / c < b <-> a < b*c).

Lemma Rlt_div_r : forall a b c, c > 0 -> (a * c < b <-> a < b / c).

Lemma Rdiv_lt_0_compat : forall r1 r2 : R, 0 < r1 -> 0 < r2 -> 0 < r1 / r2.

Lemma Rdiv_le_0_compat : forall r1 r2 : R, 0 <= r1 -> 0 < r2 -> 0 <= r1 / r2.

Lemma Rdiv_lt_1 : forall r1 r2, 0 < r2 -> (r1 < r2 <-> r1 / r2 < 1).

Lemma Rdiv_le_1 : forall r1 r2, 0 < r2 -> (r1 <= r2 <-> r1/r2 <= 1).

Lemma Rle_mult_Rlt : forall c a b : R, 0 < b -> c < 1 -> a <= b*c -> a < b.

Lemma Rmult_le_0_r : forall a b, a <= 0 -> 0 <= b -> a * b <= 0.

Lemma Rmult_le_0_l : forall a b, 0 <= a -> b <= 0 -> a * b <= 0.

Lemma pow2_gt_0 (x : R) : x <> 0 -> 0 < x ^ 2.

Lemma Rminus_eq_0 : forall r : R, r - r = 0.

Lemma Rdiv_minus_distr : forall a b c, b <> 0 -> a / b - c = (a - b * c) / b.

Lemma Rmult_minus_distr_r: forall r1 r2 r3 : R, (r1 - r2) * r3 = r1 * r3 - r2 * r3.

Lemma Rminus_eq_compat_l : forall r r1 r2 : R, r1 = r2 <-> r - r1 = r - r2.

Lemma Ropp_plus_minus_distr : forall r1 r2 : R, - (r1 + r2) = - r1 - r2.

Lemma Rle_minus_l : forall a b c,(a - c <= b <-> a <= b + c).

Lemma Rlt_minus_r : forall a b c,(a < b - c <-> a + c < b).

Lemma Rlt_minus_l : forall a b c,(a - c < b <-> a < b + c).

Lemma Rle_minus_r : forall a b c,(a <= b - c <-> a + c <= b).

Lemma Rminus_le_0 : forall a b, a <= b <-> 0 <= b - a.

Lemma Rminus_lt_0 : forall a b, a < b <-> 0 < b - a.

Lemma sum_f_rw (a : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m a = sum_f_R0 a m - sum_f_R0 a n.

Lemma sum_f_rw_0 (u : nat -> R) (n : nat) :
  sum_f O n u = sum_f_R0 u n.

Lemma sum_f_n_Sm (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f n (S m) u = sum_f n m u + u (S m).
Lemma sum_f_u_Sk (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f (S n) (S m) u = sum_f n m (fun k => u (S k)).
Lemma sum_f_u_add (u : nat -> R) (p n m : nat) :
  (n <= m)%nat -> sum_f (n + p)%nat (m + p)%nat u = sum_f n m (fun k => u (k + p)%nat).

Lemma sum_f_Sn_m (u : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m u = sum_f n m u - u n.

Lemma sum_f_R0_skip (u : nat -> R) (n : nat) :
  sum_f_R0 (fun k => u (n - k)%nat) n = sum_f_R0 u n.

Lemma sum_f_chasles (u : nat -> R) (n m k : nat) :
  (n < m)%nat -> (m < k)%nat ->
  sum_f (S n) k u = sum_f (S n) m u + sum_f (S m) k u.

Lemma Rplus_max_distr_l :
  forall a b c, a + Rmax b c = Rmax (a + b) (a + c).

Lemma Rplus_max_distr_r :
  forall a b c, Rmax b c + a = Rmax (b + a) (c + a).

Lemma Rplus_min_distr_l :
  forall a b c, a + Rmin b c = Rmin (a + b) (a + c).

Lemma Rplus_min_distr_r :
  forall a b c, Rmin b c + a = Rmin (b + a) (c + a).

Lemma Rmult_max_distr_l :
  forall a b c, 0 <= a -> a * Rmax b c = Rmax (a * b) (a * c).

Lemma Rmult_max_distr_r :
  forall a b c, 0 <= a -> Rmax b c * a = Rmax (b * a) (c * a).

Lemma Rmult_min_distr_l :
  forall a b c, 0 <= a -> a * Rmin b c = Rmin (a * b) (a * c).

Lemma Rmult_min_distr_r :
  forall a b c, 0 <= a -> Rmin b c * a = Rmin (b * a) (c * a).

Lemma Rmin_assoc : forall x y z, Rmin x (Rmin y z) =
  Rmin (Rmin x y) z.

Lemma Rmax_assoc : forall x y z, Rmax x (Rmax y z) =
  Rmax (Rmax x y) z.

Lemma Rmax_le_compat : forall a b c d, a <= b -> c <= d -> Rmax a c <= Rmax b d.

Lemma Rmax_opp_Rmin : forall a b, Rmax (-a) (-b) = - Rmin a b.
Lemma Rmin_opp_Rmax : forall a b, Rmin (-a) (-b) = - Rmax a b.

Lemma Rmax_mult : forall a b c, 0 <= c -> Rmax a b * c = Rmax (a * c) (b * c).

Lemma Rmax_le_Rplus : forall a b : R, 0 <= a -> 0 <= b -> Rmax a b <= a + b.

Lemma Rplus_le_Rmax : forall a b : R, a + b <= 2*Rmax a b.

Lemma Rmin_Rmax_l : forall a b, Rmin a b <= a <= Rmax a b.

Lemma Rmin_Rmax_r : forall a b, Rmin a b <= b <= Rmax a b.

Lemma Rmin_Rmax : forall a b, Rmin a b <= Rmax a b.

Lemma Rabs_div : forall a b : R, b <> 0 -> Rabs (a/b) = (Rabs a) / (Rabs b).

Lemma Rabs_eq_0 : forall x, Rabs x = 0 -> x = 0.

Lemma Rabs_le_between : forall x y, (Rabs x <= y <-> -y <= x <= y).

Lemma Rabs_le_between' : forall x y z, Rabs (x - y) <= z <-> y-z <= x <= y+z.

Lemma Rabs_lt_between : forall x y, (Rabs x < y <-> -y < x < y).

Lemma Rabs_lt_between' : forall x y z, Rabs (x - y) < z <-> y-z < x < y+z.

Lemma Rabs_le_between_min_max : forall x y z, Rmin x y <= z <= Rmax x y -> Rabs (z - y) <= Rabs (x - y).

Lemma Rabs_le_between_Rmax : forall x m M,
  m <= x <= M -> Rabs x <= Rmax M (-m).

Lemma Rabs_lt_between_Rmax : forall x m M,
  m < x < M -> Rabs x < Rmax M (-m).

Lemma Rabs_maj2 : forall x, -x <= Rabs x.

Lemma Req_lt_aux : forall x y, (forall eps : posreal, Rabs (x - y) < eps) -> x = y.

Lemma Req_le_aux : forall x y, (forall eps : posreal, Rabs (x - y) <= eps) -> x = y.

Lemma is_pos_div_2 (eps : posreal) : 0 < eps / 2.
Definition pos_div_2 (eps : posreal) := mkposreal _ (is_pos_div_2 eps).

Definition sign (x : R) :=
  match total_order_T 0 x with
  | inleft (left _) => 1
  | inleft (right _) => 0
  | inright _ => -1
  end.

Lemma sign_0 : sign 0 = 0.

Lemma sign_opp (x : R) : sign (-x) = - sign x.

Lemma sign_eq_1 (x : R) : 0 < x -> sign x = 1.

Lemma sign_eq_m1 (x : R) : x < 0 -> sign x = -1.

Lemma sign_le (x y : R) : x <= y -> sign x <= sign y.

Lemma sign_ge_0 (x : R) : 0 <= x -> 0 <= sign x.

Lemma sign_le_0 (x : R) : x <= 0 -> sign x <= 0.

Lemma sign_neq_0 (x : R) : x <> 0 -> sign x <> 0.

Lemma sign_mult (x y : R) : sign (x * y) = sign x * sign y.

Lemma sign_min_max (a b : R) :
  sign (b - a) * (Rmax a b - Rmin a b) = b - a.

Lemma sum_INR : forall n, sum_f_R0 INR n = INR n * (INR n + 1) / 2.

Lemma interval_finite_subdiv (a b : R) (eps : posreal) : (a <= b) ->
  {l : seq R | head 0 l = a /\ last 0 l = b /\
    forall i, (S i < size l)%nat -> nth 0 l i < nth 0 l (S i) <= nth 0 l i + eps}.

Lemma interval_finite_subdiv_between (a b : R) (eps : posreal) (Hab : a <= b) :
  let l := proj1_sig (interval_finite_subdiv a b eps Hab) in
  forall i, (i < size l)%nat -> a <= nth 0 l i <= b.

Lemma SSR_leq (n m : nat) : is_true (ssrnat.leq n m) <-> (n <= m)%nat.
Lemma SSR_minus (n m : nat) : ssrnat.subn n m = (n - m)%nat.

Lemma rcons_ind {T : Type} (P : seq T -> Type) :
  P [::] -> (forall (s : seq T) (t : T), P s -> P (rcons s t)) -> forall s, P s.
Lemma rcons_dec {T : Type} (P : seq T -> Type) :
  (P [::]) -> (forall s t, P (rcons s t)) -> forall s, P s.
Lemma size_rcons_pos {T : Type} (s : seq T) (t : T) : (0 < size (rcons s t))%nat.

Lemma foldr_rcons {T T0 : Type} : forall (f : T0 -> T -> T) x0 s t,
  foldr f x0 (rcons s t) = foldr f (f t x0) s.
Lemma foldl_rcons {T T0 : Type} : forall (f : T -> T0 -> T) x0 s t,
  foldl f x0 (rcons s t) = f (foldl f x0 s) t.

Lemma head_rcons {T : Type} (x0 : T) (s : seq T) (t : T) : head x0 (rcons s t) = head t s.
Lemma behead_rcons {T : Type} (s : seq T) (t : T) :
  (0 < size s)%nat ->  behead (rcons s t) = rcons (behead s) t.
Definition belast {T : Type} (s : seq T) :=
  match s with
    | [::] => [::]
    | h :: s => belast h s
  end.
Lemma behead_rev {T : Type} (s : seq T) : behead (rev s) = rev (belast s).

Lemma pairmap_rcons {T T0 : Type} (f : T -> T -> T0) (s : seq T) h0 h x0 :
  pairmap f x0 (rcons (rcons s h0) h) = rcons (pairmap f x0 (rcons s h0)) (f h0 h).
Lemma map_pairmap {T T0 T1 : Type} (f : T0 -> T1) (g : T -> T -> T0) (s : seq T) (x0 : T) :
  map f (pairmap g x0 s) = pairmap (fun x y => f (g x y)) x0 s.
Lemma pairmap_map {T T0 T1 : Type} (f : T0 -> T0 -> T1) (g : T -> T0) (s : seq T) (x0 : T) :
  pairmap f (g x0) (map g s) = pairmap (fun x y => f (g x) (g y)) x0 s.

Lemma size_unzip1 {T T0 : Type} (s : seq (T * T0)) : size (unzip1 s) = size s.
Lemma size_unzip2 {T T0 : Type} (s : seq (T * T0)) : size (unzip2 s) = size s.
Lemma zip_cons {S T : Type} hs ht (s : seq S) (t : seq T) :
  zip (hs :: s) (ht :: t) = (hs,ht) :: zip s t.
Lemma zip_rcons {S T : Type} (s : seq S) (t : seq T) hs ht : size s = size t ->
  zip (rcons s hs) (rcons t ht) = rcons (zip s t) (hs,ht).
Lemma unzip1_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip1 (rcons s h) = rcons (unzip1 s) (fst h).
Lemma unzip2_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip2 (rcons s h) = rcons (unzip2 s) (snd h).
Lemma unzip1_belast {S T : Type} (s : seq (S*T)) :
  unzip1 (belast s) = belast (unzip1 s).
Lemma unzip2_belast {S T : Type} (s : seq (S*T)) :
  unzip2 (belast s) = belast (unzip2 s).
Lemma unzip1_behead {S T : Type} (s : seq (S*T)) :
  unzip1 (behead s) = behead (unzip1 s).
Lemma unzip2_behead {S T : Type} (s : seq (S*T)) :
  unzip2 (behead s) = behead (unzip2 s).
Lemma unzip1_fst {S T : Type} (s : seq (S*T)) :
  unzip1 s = map (@fst S T) s.
Lemma unzip2_snd {S T : Type} (s : seq (S*T)) :
  unzip2 s = map (@snd S T) s.
Lemma size_belast' {T : Type} (s : seq T) :
  size (belast s) = Peano.pred (size s).
Lemma head_map {T1 T2 : Type} (f : T1 -> T2) (s : seq T1) (x : T1) :
  head (f x) (map f s) = f (head x s).

Lemma StepFun_bound {a b : R} (f : StepFun a b) :
  exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_bound (f : R -> R) (a b : R) :
  Riemann_integrable f a b -> exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_ext : forall (f g : R -> R) (a b : R),
  (forall x, Rmin a b <= x <= Rmax a b -> f x = g x)
    -> Riemann_integrable f a b -> Riemann_integrable g a b.

Lemma RiemannInt_ext : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (Heq : forall x, Rmin a b <= x <= Rmax a b -> f x = g x),
    RiemannInt pr_f = RiemannInt pr_g.

Lemma Riemann_integrable_const : forall (c a b : R),
  Riemann_integrable (fun x => c) a b.

Lemma RiemannInt_const : forall (c a b : R) (pr : Riemann_integrable (fun x => c) a b),
  RiemannInt pr = c * (b-a).

Lemma Riemann_integrable_plus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x + g x) a b.

Lemma RiemannInt_plus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x + g x) a b),
  RiemannInt pr = RiemannInt pr_f + RiemannInt pr_g.

Lemma Riemann_integrable_minus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x - g x) a b.

Lemma RiemannInt_minus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x - g x) a b),
  RiemannInt pr = RiemannInt pr_f - RiemannInt pr_g.

Lemma Riemann_integrable_opp : forall (f : R -> R) (a b : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => - f x) a b.

Lemma RiemannInt_opp : forall (f : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => - f x) a b),
  RiemannInt pr = - RiemannInt pr_f.

Lemma Riemann_integrable_scal : forall (f : R -> R) (a b c : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => c * f x) a b.

Lemma RiemannInt_scal : forall (f : R -> R) (a b c : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => c * f x) a b),
  RiemannInt pr = c * RiemannInt pr_f.

Lemma ln_pow x n : 0 < x -> ln (x^n) = INR n * ln x.

Lemma ln_le x y : 0 < x -> x <= y -> ln x <= ln y.

Lemma ln_div x y : 0 < x -> 0 < y -> ln (x / y) = ln x - ln y.

Lemma derivable_pt_lim_atan :
  forall x, derivable_pt_lim atan x (/(1 + x^2)). *)
(* Rbar:
Require Import Reals.
Require Import mathcomp.ssreflect.ssreflect.
Require Import Rcomplements.

Open Scope R_scope.

Inductive Rbar :=
  | Finite : R -> Rbar
  | p_infty : Rbar
  | m_infty : Rbar.
Definition real (x : Rbar) :=
  match x with
    | Finite x => x
    | _ => 0
  end.
Coercion Finite : R >-> Rbar.
Coercion real : Rbar >-> R.

Definition is_finite (x : Rbar) := Finite (real x) = x.
Lemma is_finite_correct (x : Rbar) :
  is_finite x <-> exists y : R, x = Finite y.

Definition Rbar_lt (x y : Rbar) : Prop :=
  match x,y with
    | p_infty, _ | _, m_infty => False
    | m_infty, _ | _, p_infty => True
    | Finite x, Finite y => Rlt x y
  end.

Definition Rbar_le (x y : Rbar) : Prop :=
  match x,y with
    | m_infty, _ | _, p_infty => True
    | p_infty, _ | _, m_infty => False
    | Finite x, Finite y => Rle x y
  end.

Definition Rbar_opp (x : Rbar) :=
  match x with
    | Finite x => Finite (-x)
    | p_infty => m_infty
    | m_infty => p_infty
  end.

Definition Rbar_plus' (x y : Rbar) :=
  match x,y with
    | p_infty, m_infty | m_infty, p_infty => None
    | p_infty, _ | _, p_infty => Some p_infty
    | m_infty, _ | _, m_infty => Some m_infty
    | Finite x', Finite y' => Some (Finite (x' + y'))
  end.
Definition Rbar_plus (x y : Rbar) :=
  match Rbar_plus' x y with Some z => z | None => Finite 0 end.
Arguments Rbar_plus !x !y /.
Definition is_Rbar_plus (x y z : Rbar) : Prop :=
  Rbar_plus' x y = Some z.
Definition ex_Rbar_plus (x y : Rbar) : Prop :=
  match Rbar_plus' x y with Some _ => True | None => False end.
Arguments ex_Rbar_plus !x !y /.

Lemma is_Rbar_plus_unique (x y z : Rbar) :
  is_Rbar_plus x y z -> Rbar_plus x y = z.
Lemma Rbar_plus_correct (x y : Rbar) :
  ex_Rbar_plus x y -> is_Rbar_plus x y (Rbar_plus x y).

Definition Rbar_minus (x y : Rbar) := Rbar_plus x (Rbar_opp y).
Arguments Rbar_minus !x !y /.
Definition is_Rbar_minus (x y z : Rbar) : Prop :=
  is_Rbar_plus x (Rbar_opp y) z.
Definition ex_Rbar_minus (x y : Rbar) : Prop :=
  ex_Rbar_plus x (Rbar_opp y).
Arguments ex_Rbar_minus !x !y /.

Definition Rbar_inv (x : Rbar) : Rbar :=
  match x with
    | Finite x => Finite (/x)
    | _ => Finite 0
  end.

Definition Rbar_mult' (x y : Rbar) :=
  match x with
    | Finite x => match y with
      | Finite y => Some (Finite (x * y))
      | p_infty => match (Rle_dec 0 x) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some p_infty | right _ => None end
        | right _ => Some m_infty
      end
      | m_infty => match (Rle_dec 0 x) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some m_infty | right _ => None end
        | right _ => Some p_infty
      end
    end
    | p_infty => match y with
      | Finite y => match (Rle_dec 0 y) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some p_infty | right _ => None end
        | right _ => Some m_infty
      end
      | p_infty => Some p_infty
      | m_infty => Some m_infty
    end
    | m_infty => match y with
      | Finite y => match (Rle_dec 0 y) with
        | left H => match Rle_lt_or_eq_dec _ _ H with left _ => Some m_infty | right _ => None end
        | right _ => Some p_infty
      end
      | p_infty => Some m_infty
      | m_infty => Some p_infty
    end
  end.
Definition Rbar_mult (x y : Rbar) :=
  match Rbar_mult' x y with Some z => z | None => Finite 0 end.
Arguments Rbar_mult !x !y /.

Definition is_Rbar_mult (x y z : Rbar) : Prop :=
  Rbar_mult' x y = Some z.
Definition ex_Rbar_mult (x y : Rbar) : Prop :=
  match x with
    | Finite x => match y with
      | Finite y => True
      | p_infty => x <> 0
      | m_infty => x <> 0
    end
    | p_infty => match y with
      | Finite y => y <> 0
      | p_infty => True
      | m_infty => True
    end
    | m_infty => match y with
      | Finite y => y <> 0
      | p_infty => True
      | m_infty => True
    end
  end.
Arguments ex_Rbar_mult !x !y /.

Definition Rbar_mult_pos (x : Rbar) (y : posreal) :=
  match x with
    | Finite x => Finite (x*y)
    | _ => x
  end.

Lemma is_Rbar_mult_unique (x y z : Rbar) :
  is_Rbar_mult x y z -> Rbar_mult x y = z.
Lemma Rbar_mult_correct (x y : Rbar) :
  ex_Rbar_mult x y -> is_Rbar_mult x y (Rbar_mult x y).
Lemma Rbar_mult_correct' (x y z : Rbar) :
  is_Rbar_mult x y z -> ex_Rbar_mult x y.

Definition Rbar_div (x y : Rbar) : Rbar :=
  Rbar_mult x (Rbar_inv y).
Arguments Rbar_div !x !y /.
Definition is_Rbar_div (x y z : Rbar) : Prop :=
  is_Rbar_mult x (Rbar_inv y) z.
Definition ex_Rbar_div (x y : Rbar) : Prop :=
  ex_Rbar_mult x (Rbar_inv y).
Arguments ex_Rbar_div !x !y /.
Definition Rbar_div_pos (x : Rbar) (y : posreal) :=
  match x with
    | Finite x => Finite (x/y)
    | _ => x
  end.

Lemma Rbar_finite_eq (x y : R) :
  Finite x = Finite y <-> x = y.
Lemma Rbar_finite_neq (x y : R) :
  Finite x <> Finite y <-> x <> y.

Lemma Rbar_lt_not_eq (x y : Rbar) :
  Rbar_lt x y -> x<>y.

Lemma Rbar_not_le_lt (x y : Rbar) :
  ~ Rbar_le x y -> Rbar_lt y x.

Lemma Rbar_lt_not_le (x y : Rbar) :
  Rbar_lt y x -> ~ Rbar_le x y.

Lemma Rbar_not_lt_le (x y : Rbar) :
  ~ Rbar_lt x y -> Rbar_le y x.

Lemma Rbar_le_not_lt (x y : Rbar) :
  Rbar_le y x -> ~ Rbar_lt x y.

Lemma Rbar_le_refl :
  forall x : Rbar, Rbar_le x x.

Lemma Rbar_lt_le :
  forall x y : Rbar,
  Rbar_lt x y -> Rbar_le x y.

Lemma Rbar_total_order (x y : Rbar) :
  {Rbar_lt x y} + {x = y} + {Rbar_lt y x}.

Lemma Rbar_eq_dec (x y : Rbar) :
  {x = y} + {x <> y}.

Lemma Rbar_lt_dec (x y : Rbar) :
  {Rbar_lt x y} + {~Rbar_lt x y}.

Lemma Rbar_lt_le_dec (x y : Rbar) :
  {Rbar_lt x y} + {Rbar_le y x}.

Lemma Rbar_le_dec (x y : Rbar) :
  {Rbar_le x y} + {~Rbar_le x y}.

Lemma Rbar_le_lt_dec (x y : Rbar) :
  {Rbar_le x y} + {Rbar_lt y x}.

Lemma Rbar_le_lt_or_eq_dec (x y : Rbar) :
  Rbar_le x y -> { Rbar_lt x y } + { x = y }.

Lemma Rbar_lt_trans (x y z : Rbar) :
  Rbar_lt x y -> Rbar_lt y z -> Rbar_lt x z.

Lemma Rbar_lt_le_trans (x y z : Rbar) :
  Rbar_lt x y -> Rbar_le y z -> Rbar_lt x z.

Lemma Rbar_le_lt_trans (x y z : Rbar) :
  Rbar_le x y -> Rbar_lt y z -> Rbar_lt x z.

Lemma Rbar_le_trans (x y z : Rbar) :
  Rbar_le x y -> Rbar_le y z -> Rbar_le x z.

Lemma Rbar_le_antisym (x y : Rbar) :
  Rbar_le x y -> Rbar_le y x -> x = y.

Lemma Rbar_opp_involutive (x : Rbar) : (Rbar_opp (Rbar_opp x)) = x.

Lemma Rbar_opp_lt (x y : Rbar) : Rbar_lt (Rbar_opp x) (Rbar_opp y) <-> Rbar_lt y x.

Lemma Rbar_opp_le (x y : Rbar) : Rbar_le (Rbar_opp x) (Rbar_opp y) <-> Rbar_le y x.

Lemma Rbar_opp_eq (x y : Rbar) : (Rbar_opp x) = (Rbar_opp y) <-> x = y.

Lemma Rbar_opp_real (x : Rbar) : real (Rbar_opp x) = - real x.

Lemma Rbar_plus'_comm :
  forall x y, Rbar_plus' x y = Rbar_plus' y x.

Lemma ex_Rbar_plus_comm :
  forall x y,
  ex_Rbar_plus x y -> ex_Rbar_plus y x.

Lemma ex_Rbar_plus_opp (x y : Rbar) :
  ex_Rbar_plus x y -> ex_Rbar_plus (Rbar_opp x) (Rbar_opp y).

Lemma Rbar_plus_0_r (x : Rbar) : Rbar_plus x (Finite 0) = x.
Lemma Rbar_plus_0_l (x : Rbar) : Rbar_plus (Finite 0) x = x.

Lemma Rbar_plus_comm (x y : Rbar) : Rbar_plus x y = Rbar_plus y x.

Lemma Rbar_plus_lt_compat (a b c d : Rbar) :
  Rbar_lt a b -> Rbar_lt c d -> Rbar_lt (Rbar_plus a c) (Rbar_plus b d).

Lemma Rbar_plus_le_compat (a b c d : Rbar) :
  Rbar_le a b -> Rbar_le c d -> Rbar_le (Rbar_plus a c) (Rbar_plus b d).

Lemma Rbar_plus_opp (x y : Rbar) :
  Rbar_plus (Rbar_opp x) (Rbar_opp y) = Rbar_opp (Rbar_plus x y).

Lemma Rbar_minus_eq_0 (x : Rbar) : Rbar_minus x x = 0.
Lemma Rbar_opp_minus (x y : Rbar) :
  Rbar_opp (Rbar_minus x y) = Rbar_minus y x.

Lemma Rbar_inv_opp (x : Rbar) :
  x <> 0 -> Rbar_inv (Rbar_opp x) = Rbar_opp (Rbar_inv x).

Lemma Rbar_mult'_comm (x y : Rbar) :
  Rbar_mult' x y = Rbar_mult' y x.

Lemma Rbar_mult'_opp_r (x y : Rbar) :
  Rbar_mult' x (Rbar_opp y) = match Rbar_mult' x y with Some z => Some (Rbar_opp z) | None => None end.

Lemma Rbar_mult_comm (x y : Rbar) :
  Rbar_mult x y = Rbar_mult y x.
Lemma Rbar_mult_opp_r (x y : Rbar) :
  Rbar_mult x (Rbar_opp y) = (Rbar_opp (Rbar_mult x y)).
Lemma Rbar_mult_opp_l (x y : Rbar) :
  Rbar_mult (Rbar_opp x) y = Rbar_opp (Rbar_mult x y).
Lemma Rbar_mult_opp (x y : Rbar) :
  Rbar_mult (Rbar_opp x) (Rbar_opp y) = Rbar_mult x y.
Lemma Rbar_mult_0_l (x : Rbar) : Rbar_mult 0 x = 0.
Lemma Rbar_mult_0_r (x : Rbar) : Rbar_mult x 0 = 0.

Lemma Rbar_mult_eq_0 (y x : Rbar) :
  Rbar_mult x y = 0 -> x = 0 \/ y = 0.

Lemma ex_Rbar_mult_sym (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult y x.
Lemma ex_Rbar_mult_opp_l (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult (Rbar_opp x) y.
Lemma ex_Rbar_mult_opp_r (x y : Rbar) :
  ex_Rbar_mult x y -> ex_Rbar_mult x (Rbar_opp y).

Lemma is_Rbar_mult_sym (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult y x z.
Lemma is_Rbar_mult_opp_l (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult (Rbar_opp x) y (Rbar_opp z).
Lemma is_Rbar_mult_opp_r (x y z : Rbar) :
  is_Rbar_mult x y z -> is_Rbar_mult x (Rbar_opp y) (Rbar_opp z).

Lemma is_Rbar_mult_p_infty_pos (x : Rbar) :
  Rbar_lt 0 x -> is_Rbar_mult p_infty x p_infty.
Lemma is_Rbar_mult_p_infty_neg (x : Rbar) :
  Rbar_lt x 0 -> is_Rbar_mult p_infty x m_infty.
Lemma is_Rbar_mult_m_infty_pos (x : Rbar) :
  Rbar_lt 0 x -> is_Rbar_mult m_infty x m_infty.
Lemma is_Rbar_mult_m_infty_neg (x : Rbar) :
  Rbar_lt x 0 -> is_Rbar_mult m_infty x p_infty.

Lemma is_Rbar_div_p_infty (x : R) :
  is_Rbar_div x p_infty 0.
Lemma is_Rbar_div_m_infty (x : R) :
  is_Rbar_div x m_infty 0.

Lemma Rbar_mult_pos_eq (x y : Rbar) (z : posreal) :
  x = y <-> (Rbar_mult_pos x z) = (Rbar_mult_pos y z).

Lemma Rbar_mult_pos_lt (x y : Rbar) (z : posreal) :
  Rbar_lt x y <-> Rbar_lt (Rbar_mult_pos x z) (Rbar_mult_pos y z).

Lemma Rbar_mult_pos_le (x y : Rbar) (z : posreal) :
  Rbar_le x y <-> Rbar_le (Rbar_mult_pos x z) (Rbar_mult_pos y z).

Lemma Rbar_div_pos_eq (x y : Rbar) (z : posreal) :
  x = y <-> (Rbar_div_pos x z) = (Rbar_div_pos y z).

Lemma Rbar_div_pos_lt (x y : Rbar) (z : posreal) :
  Rbar_lt x y <-> Rbar_lt (Rbar_div_pos x z) (Rbar_div_pos y z).

Lemma Rbar_div_pos_le (x y : Rbar) (z : posreal) :
  Rbar_le x y <-> Rbar_le (Rbar_div_pos x z) (Rbar_div_pos y z).

Definition Rbar_min (x y : Rbar) : Rbar :=
  match x, y with
  | z, p_infty | p_infty, z => z
  | _ , m_infty | m_infty, _ => m_infty
  | Finite x, Finite y => Rmin x y
  end.

Lemma Rbar_lt_locally (a b : Rbar) (x : R) :
  Rbar_lt a x -> Rbar_lt x b ->
  exists delta : posreal,
    forall y, Rabs (y - x) < delta -> Rbar_lt a y /\ Rbar_lt y b.

Lemma Rbar_min_comm (x y : Rbar) : Rbar_min x y = Rbar_min y x.

Lemma Rbar_min_r (x y : Rbar) : Rbar_le (Rbar_min x y) y.

Lemma Rbar_min_l (x y : Rbar) : Rbar_le (Rbar_min x y) x.

Lemma Rbar_min_case (x y : Rbar) (P : Rbar -> Type) :
  P x -> P y -> P (Rbar_min x y).
Lemma Rbar_min_case_strong (r1 r2 : Rbar) (P : Rbar -> Type) :
  (Rbar_le r1 r2 -> P r1) -> (Rbar_le r2 r1 -> P r2)
    -> P (Rbar_min r1 r2).

Definition Rbar_abs (x : Rbar) :=
  match x with
    | Finite x => Finite (Rabs x)
    | _ => p_infty
  end.

Lemma Rbar_abs_lt_between (x y : Rbar) :
  Rbar_lt (Rbar_abs x) y <-> (Rbar_lt (Rbar_opp y) x /\ Rbar_lt x y).

Lemma Rbar_abs_opp (x : Rbar) :
  Rbar_abs (Rbar_opp x) = Rbar_abs x.

Lemma Rbar_abs_pos (x : Rbar) :
  Rbar_le 0 x -> Rbar_abs x = x.
Lemma Rbar_abs_neg (x : Rbar) :
  Rbar_le x 0 -> Rbar_abs x = Rbar_opp x. *)
(* Lub:
Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Rbar Rcomplements Markov.

Open Scope R_scope.

Definition is_ub_Rbar (E : R -> Prop) (l : Rbar) :=
  forall (x : R), E x -> Rbar_le x l.
Definition is_lb_Rbar (E : R -> Prop) (l : Rbar) :=
  forall (x : R), E x -> Rbar_le l x.

Lemma is_ub_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_lb_Rbar E l <-> is_ub_Rbar (fun x => E (- x)) (Rbar_opp l).
Lemma is_lb_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_ub_Rbar E l <-> is_lb_Rbar (fun x => E (- x)) (Rbar_opp l).

Lemma is_ub_Rbar_dec (E : R -> Prop) :
  {l : R | is_ub_Rbar E l} + {(forall l : R, ~is_ub_Rbar E l)}.

Lemma is_lb_Rbar_dec (E : R -> Prop) :
  {l : R | is_lb_Rbar E l} + {(forall l : R, ~is_lb_Rbar E l)}.

Lemma is_ub_Rbar_subset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_ub_Rbar E1 l -> is_ub_Rbar E2 l.
Lemma is_lb_Rbar_subset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_lb_Rbar E1 l -> is_lb_Rbar E2 l.

Definition is_lub_Rbar (E : R -> Prop) (l : Rbar) :=
  is_ub_Rbar E l /\ (forall b, is_ub_Rbar E b -> Rbar_le l b).
Definition is_glb_Rbar (E : R -> Prop) (l : Rbar) :=
  is_lb_Rbar E l /\ (forall b, is_lb_Rbar E b -> Rbar_le b l).

Lemma is_lub_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_glb_Rbar E l <-> is_lub_Rbar (fun x => E (- x)) (Rbar_opp l).
Lemma is_glb_Rbar_opp (E : R -> Prop) (l : Rbar) :
  is_lub_Rbar E l <-> is_glb_Rbar (fun x => E (- x)) (Rbar_opp l).

Lemma ex_lub_Rbar (E : R -> Prop) : {l : Rbar | is_lub_Rbar E l}.
Lemma ex_glb_Rbar (E : R -> Prop) : {l : Rbar | is_glb_Rbar E l}.

Definition Lub_Rbar (E : R -> Prop) := proj1_sig (ex_lub_Rbar E).
Definition Glb_Rbar (E : R -> Prop) := proj1_sig (ex_glb_Rbar E).

Lemma is_lub_Rbar_unique (E : R -> Prop) (l : Rbar) :
  is_lub_Rbar E l -> Lub_Rbar E = l.
Lemma is_glb_Rbar_unique (E : R -> Prop) (l : Rbar) :
  is_glb_Rbar E l -> Glb_Rbar E = l.

Lemma Lub_Rbar_correct (E : R -> Prop) :
  is_lub_Rbar E (Lub_Rbar E).
Lemma Glb_Rbar_correct (E : R -> Prop) :
  is_glb_Rbar E (Glb_Rbar E).

Lemma is_lub_Rbar_subset (E1 E2 : R -> Prop) (l1 l2 : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_lub_Rbar E1 l1 -> is_lub_Rbar E2 l2
    -> Rbar_le l2 l1.
Lemma is_glb_Rbar_subset (E1 E2 : R -> Prop) (l1 l2 : Rbar) :
  (forall x : R, E2 x -> E1 x) -> is_glb_Rbar E1 l1 -> is_glb_Rbar E2 l2
    -> Rbar_le l1 l2.

Lemma is_lub_Rbar_eqset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x <-> E1 x) -> is_lub_Rbar E1 l -> is_lub_Rbar E2 l.
Lemma is_glb_Rbar_eqset (E1 E2 : R -> Prop) (l : Rbar) :
  (forall x : R, E2 x <-> E1 x) -> is_glb_Rbar E1 l -> is_glb_Rbar E2 l.

Lemma Lub_Rbar_eqset (E1 E2 : R -> Prop) :
  (forall x, E1 x <-> E2 x) -> Lub_Rbar E1 = Lub_Rbar E2.
Lemma Glb_Rbar_eqset (E1 E2 : R -> Prop) :
  (forall x, E1 x <-> E2 x) -> Glb_Rbar E1 = Glb_Rbar E2.

Definition Rbar_is_upper_bound (E : Rbar -> Prop) (l : Rbar) :=
  forall x, E x -> Rbar_le x l.

Definition Rbar_is_lower_bound (E : Rbar -> Prop) (l : Rbar) :=
  forall x, E x -> Rbar_le l x.

Lemma Rbar_ub_lb (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_upper_bound (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_lower_bound E l.
Lemma Rbar_lb_ub (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lower_bound (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_upper_bound E l.

Lemma is_ub_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_ub_Rbar E l <-> Rbar_is_upper_bound (fun x => is_finite x /\ E x) l.
Lemma is_lb_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_lb_Rbar E l <-> Rbar_is_lower_bound (fun x => is_finite x /\ E x) l.

Lemma Rbar_ub_p_infty (E : Rbar -> Prop) :
  Rbar_is_upper_bound E p_infty.
Lemma Rbar_lb_m_infty (E : Rbar -> Prop) :
  Rbar_is_lower_bound E m_infty.

Lemma Rbar_ub_Finite (E : Rbar -> Prop) (l : R) :
  Rbar_is_upper_bound E l ->
    is_upper_bound (fun (x : R) => E x) l.
Lemma Rbar_lb_Finite (E : Rbar -> Prop) (l : R) :
  Rbar_is_lower_bound E (Finite l) ->
    is_upper_bound (fun x => E (Finite (- x))) (- l).

Lemma Rbar_ub_m_infty (E : Rbar -> Prop) :
  Rbar_is_upper_bound E m_infty -> forall x, E x -> x = m_infty.
Lemma Rbar_lb_p_infty (E : Rbar -> Prop) :
  Rbar_is_lower_bound E p_infty -> (forall x, E x -> x = p_infty).

Lemma Rbar_lb_le_ub (E : Rbar -> Prop) (l1 l2 : Rbar) : (exists x, E x) ->
  Rbar_is_lower_bound E l1 -> Rbar_is_upper_bound E l2 -> Rbar_le l1 l2.
Lemma Rbar_lb_eq_ub (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lower_bound E l -> Rbar_is_upper_bound E l -> forall x, E x -> x = l.

Lemma Rbar_ub_dec (E : Rbar -> Prop) (Hp : ~ E p_infty) :
  {M : R | Rbar_is_upper_bound E M}
    + {(forall (M : R), ~Rbar_is_upper_bound E M)}.
Lemma Rbar_lb_dec (E : Rbar -> Prop) (Hm : ~ E m_infty) :
  {M : R | Rbar_is_lower_bound E (Finite M)}
    + {(forall M, ~Rbar_is_lower_bound E (Finite M))}.

Lemma Rbar_is_ub_subset (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x -> E2 x) -> (Rbar_is_upper_bound E2 l) -> (Rbar_is_upper_bound E1 l).
Lemma Rbar_is_lb_subset (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x -> E2 x) -> (Rbar_is_lower_bound E2 l) -> (Rbar_is_lower_bound E1 l).

Definition Rbar_is_lub (E : Rbar -> Prop) (l : Rbar) :=
  Rbar_is_upper_bound E l /\
    (forall b : Rbar, Rbar_is_upper_bound E b -> Rbar_le l b).
Definition Rbar_is_glb (E : Rbar -> Prop) (l : Rbar) :=
  Rbar_is_lower_bound E l /\
    (forall b : Rbar, Rbar_is_lower_bound E b -> Rbar_le b l).

Lemma Rbar_lub_glb (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lub (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_glb E l.
Lemma Rbar_glb_lub (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_glb (fun x => E (Rbar_opp x)) (Rbar_opp l)
    <-> Rbar_is_lub E l.

Lemma is_lub_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_lub_Rbar E l <-> Rbar_is_lub (fun x => is_finite x /\ E x) l.
Lemma is_glb_Rbar_correct (E : R -> Prop) (l : Rbar) :
  is_glb_Rbar E l <-> Rbar_is_glb (fun x => is_finite x /\ E x) l.

Lemma Rbar_ex_lub (E : Rbar -> Prop) :
  {l : Rbar | Rbar_is_lub E l}.

Lemma Rbar_ex_glb (E : Rbar -> Prop) :
  {l : Rbar | Rbar_is_glb E l}.

Definition Rbar_lub (E : Rbar -> Prop)
  := proj1_sig (Rbar_ex_lub E).
Definition Rbar_glb (E : Rbar -> Prop)
  := proj1_sig (Rbar_ex_glb E).

Lemma Rbar_opp_glb_lub (E : Rbar -> Prop) :
  Rbar_glb (fun x => E (Rbar_opp x)) = Rbar_opp (Rbar_lub E).
Lemma Rbar_opp_lub_glb (E : Rbar -> Prop) :
  Rbar_lub (fun x => E (Rbar_opp x)) = Rbar_opp (Rbar_glb E).

Lemma Rbar_is_lub_unique (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_lub E l -> Rbar_lub E = l.
Lemma Rbar_is_glb_unique (E : Rbar -> Prop) (l : Rbar) :
  Rbar_is_glb E l -> Rbar_glb E = l.

Lemma Rbar_glb_le_lub (E : Rbar -> Prop) :
  (exists x, E x) -> Rbar_le (Rbar_glb E) (Rbar_lub E).

Lemma Rbar_is_lub_subset (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E1 x -> E2 x) -> (Rbar_is_lub E1 l1) -> (Rbar_is_lub E2 l2)
  -> Rbar_le l1 l2.
Lemma Rbar_is_glb_subset (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E2 x -> E1 x) -> (Rbar_is_glb E1 l1) -> (Rbar_is_glb E2 l2)
  -> Rbar_le l1 l2.

Lemma Rbar_is_lub_eq (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_lub E1 l1) -> (Rbar_is_lub E2 l2)
  -> l1 = l2.
Lemma Rbar_is_glb_eq (E1 E2 : Rbar -> Prop) (l1 l2 : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_glb E1 l1) -> (Rbar_is_glb E2 l2)
  -> l1 = l2.

Lemma Rbar_is_lub_ext (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_lub E1 l) -> (Rbar_is_lub E2 l).
Lemma Rbar_is_glb_ext (E1 E2 : Rbar -> Prop) (l : Rbar) :
  (forall x, E1 x <-> E2 x) -> (Rbar_is_glb E1 l) -> (Rbar_is_glb E2 l).

Lemma Rbar_lub_subset (E1 E2 : Rbar -> Prop) :
  (forall x, E1 x -> E2 x) -> Rbar_le (Rbar_lub E1) (Rbar_lub E2).
Lemma Rbar_glb_subset (E1 E2 : Rbar -> Prop) :
  (forall x, E2 x -> E1 x) -> Rbar_le (Rbar_glb E1) (Rbar_glb E2).

Lemma Rbar_lub_rw (E1 E2 : Rbar -> Prop) :
  (forall x, E1 x <-> E2 x) -> Rbar_lub E1 = Rbar_lub E2.
Lemma Rbar_glb_rw (E1 E2 : Rbar -> Prop) :
  (forall x, E1 x <-> E2 x) -> Rbar_glb E1 = Rbar_glb E2.

Definition Empty (E : R -> Prop) :=
  Lub_Rbar (fun x => x = 0 \/ E x) = Glb_Rbar (fun x => x = 0 \/ E x)
  /\ Lub_Rbar (fun x => x = 1 \/ E x) = Glb_Rbar (fun x => x = 1 \/ E x).

Lemma Empty_correct_1 (E : R -> Prop) :
  Empty E -> forall x, ~ E x.

Lemma Empty_correct_2 (E : R -> Prop) :
  (forall x, ~ E x) -> Empty E.

Lemma Empty_dec (E : R -> Prop) :
  {~Empty E}+{Empty E}.
Lemma not_Empty_dec (E : R -> Prop) : (Decidable.decidable (exists x, E x)) ->

Lemma uniqueness_dec P : (exists ! x : R, P x) -> {x : R | P x}. *)

Require Import Hierarchy.
(* Hierarchy:
Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Rcomplements Rbar Markov Iter Lub.

Open Scope R_scope.

Class Filter {T : Type} (F : (T -> Prop) -> Prop) := {
  filter_true : F (fun _ => True) ;
  filter_and : forall P Q : T -> Prop, F P -> F Q -> F (fun x => P x /\ Q x) ;
  filter_imp : forall P Q : T -> Prop, (forall x, P x -> Q x) -> F P -> F Q
}.

Global Hint Mode Filter + + : typeclass_instances.

Class ProperFilter' {T : Type} (F : (T -> Prop) -> Prop) := {
  filter_not_empty : not (F (fun _ => False)) ;
  filter_filter' :> Filter F
}.

Class ProperFilter {T : Type} (F : (T -> Prop) -> Prop) := {
  filter_ex : forall P, F P -> exists x, P x ;
  filter_filter :> Filter F
}.

Global Instance Proper_StrongProper :
  forall {T : Type} (F : (T -> Prop) -> Prop),
  ProperFilter F -> ProperFilter' F.

Lemma filter_forall :
  forall {T : Type} {F} {FF: @Filter T F} (P : T -> Prop),
  (forall x, P x) -> F P.

Lemma filter_const :
  forall {T : Type} {F} {FF: @ProperFilter T F} (P : Prop),
  F (fun _ => P) -> P.

Definition filter_le {T : Type} (F G : (T -> Prop) -> Prop) :=
  forall P, G P -> F P.

Lemma filter_le_refl :
  forall T F, @filter_le T F F.

Lemma filter_le_trans :
  forall T F G H, @filter_le T F G -> filter_le G H -> filter_le F H.

Definition filtermap {T U : Type} (f : T -> U) (F : (T -> Prop) -> Prop) :=
  fun P => F (fun x => P (f x)).

Global Instance filtermap_filter :
  forall T U (f : T -> U) (F : (T -> Prop) -> Prop),
  Filter F -> Filter (filtermap f F).

Global Instance filtermap_proper_filter' :
  forall T U (f : T -> U) (F : (T -> Prop) -> Prop),
  ProperFilter' F -> ProperFilter' (filtermap f F).

Global Instance filtermap_proper_filter :
  forall T U (f : T -> U) (F : (T -> Prop) -> Prop),
  ProperFilter F -> ProperFilter (filtermap f F).

Definition filtermapi {T U : Type} (f : T -> U -> Prop) (F : (T -> Prop) -> Prop) :=
  fun P : U -> Prop => F (fun x => exists y, f x y /\ P y).

Global Instance filtermapi_filter :
  forall T U (f : T -> U -> Prop) (F : (T -> Prop) -> Prop),
  F (fun x => (exists y, f x y) /\ forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  Filter F -> Filter (filtermapi f F).

Global Instance filtermapi_proper_filter' :
  forall T U (f : T -> U -> Prop) (F : (T -> Prop) -> Prop),
  F (fun x => (exists y, f x y) /\ forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  ProperFilter' F -> ProperFilter' (filtermapi f F).

Global Instance filtermapi_proper_filter :
  forall T U (f : T -> U -> Prop) (F : (T -> Prop) -> Prop),
  F (fun x => (exists y, f x y) /\ forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  ProperFilter F -> ProperFilter (filtermapi f F).

Definition filterlim {T U : Type} (f : T -> U) F G :=
  filter_le (filtermap f F) G.

Lemma filterlim_id :
  forall T (F : (T -> Prop) -> Prop), filterlim (fun x => x) F F.

Lemma filterlim_comp :
  forall T U V (f : T -> U) (g : U -> V) F G H,
  filterlim f F G -> filterlim g G H ->
  filterlim (fun x => g (f x)) F H.

Lemma filterlim_ext_loc :
  forall {T U F G} {FF : Filter F} (f g : T -> U),
  F (fun x => f x = g x) ->
  filterlim f F G ->
  filterlim g F G.

Lemma filterlim_ext :
  forall {T U F G} {FF : Filter F} (f g : T -> U),
  (forall x, f x = g x) ->
  filterlim f F G ->
  filterlim g F G.

Lemma filterlim_filter_le_1 :
  forall {T U F G H} (f : T -> U),
  filter_le G F ->
  filterlim f F H ->
  filterlim f G H.

Lemma filterlim_filter_le_2 :
  forall {T U F G H} (f : T -> U),
  filter_le G H ->
  filterlim f F G ->
  filterlim f F H.

Definition filterlimi {T U : Type} (f : T -> U -> Prop) F G :=
  filter_le (filtermapi f F) G.

Lemma filterlimi_comp :
  forall T U V (f : T -> U) (g : U -> V -> Prop) F G H,
  filterlim f F G -> filterlimi g G H ->
  filterlimi (fun x => g (f x)) F H.

Lemma filterlimi_ext_loc :
  forall {T U F G} {FF : Filter F} (f g : T -> U -> Prop),
  F (fun x => forall y, f x y <-> g x y) ->
  filterlimi f F G ->
  filterlimi g F G.

Lemma filterlimi_ext :
  forall {T U F G} {FF : Filter F} (f g : T -> U -> Prop),
  (forall x y, f x y <-> g x y) ->
  filterlimi f F G ->
  filterlimi g F G.

Lemma filterlimi_filter_le_1 :
  forall {T U F G H} (f : T -> U -> Prop),
  filter_le G F ->
  filterlimi f F H ->
  filterlimi f G H.

Lemma filterlimi_filter_le_2 :
  forall {T U F G H} (f : T -> U -> Prop),
  filter_le G H ->
  filterlimi f F G ->
  filterlimi f F H.

Inductive filter_prod {T U : Type} (F G : _ -> Prop) (P : T * U -> Prop) : Prop :=
  Filter_prod (Q : T -> Prop) (R : U -> Prop) :
    F Q -> G R -> (forall x y, Q x -> R y -> P (x, y)) -> filter_prod F G P.

Global Instance filter_prod_filter :
  forall T U (F : (T -> Prop) -> Prop) (G : (U -> Prop) -> Prop),
  Filter F -> Filter G -> Filter (filter_prod F G).

Global Instance filter_prod_proper' {T1 T2 : Type}
  {F : (T1 -> Prop) -> Prop} {G : (T2 -> Prop) -> Prop}
  {FF : ProperFilter' F} {FG : ProperFilter' G} :
  ProperFilter' (filter_prod F G).

Global Instance filter_prod_proper {T1 T2 : Type}
  {F : (T1 -> Prop) -> Prop} {G : (T2 -> Prop) -> Prop}
  {FF : ProperFilter F} {FG : ProperFilter G} :
  ProperFilter (filter_prod F G).

Lemma filterlim_fst :
  forall {T U F G} {FG : Filter G},
  filterlim (@fst T U) (filter_prod F G) F.

Lemma filterlim_snd :
  forall {T U F G} {FF : Filter F},
  filterlim (@snd T U) (filter_prod F G) G.

Lemma filterlim_pair :
  forall {T U V F G H} {FF : Filter F},
  forall (f : T -> U) (g : T -> V),
  filterlim f F G ->
  filterlim g F H ->
  filterlim (fun x => (f x, g x)) F (filter_prod G H).

Lemma filterlim_comp_2 :
  forall {T U V W F G H I} {FF : Filter F},
  forall (f : T -> U) (g : T -> V) (h : U -> V -> W),
  filterlim f F G ->
  filterlim g F H ->
  filterlim (fun x => h (fst x) (snd x)) (filter_prod G H) I ->
  filterlim (fun x => h (f x) (g x)) F I.

Lemma filterlimi_comp_2 :
  forall {T U V W F G H I} {FF : Filter F},
  forall (f : T -> U) (g : T -> V) (h : U -> V -> W -> Prop),
  filterlim f F G ->
  filterlim g F H ->
  filterlimi (fun x => h (fst x) (snd x)) (filter_prod G H) I ->
  filterlimi (fun x => h (f x) (g x)) F I.

Definition within {T : Type} D (F : (T -> Prop) -> Prop) (P : T -> Prop) :=
  F (fun x => D x -> P x).

Global Instance within_filter :
  forall T D F, Filter F -> Filter (@within T D F).

Lemma filter_le_within :
  forall {T} {F : (T -> Prop) -> Prop} {FF : Filter F} D,
  filter_le (within D F) F.

Lemma filterlim_within_ext :
  forall {T U F G} {FF : Filter F} D (f g : T -> U),
  (forall x, D x -> f x = g x) ->
  filterlim f (within D F) G ->
  filterlim g (within D F) G.

Definition subset_filter {T} (F : (T -> Prop) -> Prop) (dom : T -> Prop) (P : {x|dom x} -> Prop) : Prop :=
  F (fun x => forall H : dom x, P (exist _ x H)).

Global Instance subset_filter_filter :
  forall T F (dom : T -> Prop),
  Filter F ->
  Filter (subset_filter F dom).

Lemma subset_filter_proper' :
  forall {T F} {FF : Filter F} (dom : T -> Prop),
  (forall P, F P -> ~ ~ exists x, dom x /\ P x) ->
  ProperFilter' (subset_filter F dom).

Lemma subset_filter_proper :
  forall {T F} {FF : Filter F} (dom : T -> Prop),
  (forall P, F P -> exists x, dom x /\ P x) ->
  ProperFilter (subset_filter F dom).

Module AbelianGroup.

Record mixin_of (G : Type) := Mixin {
  plus : G -> G -> G ;
  opp : G -> G ;
  zero : G ;
  ax1 : forall x y, plus x y = plus y x ;
  ax2 : forall x y z, plus x (plus y z) = plus (plus x y) z ;
  ax3 : forall x, plus x zero = x ;
  ax4 : forall x, plus x (opp x) = zero
}.

Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.
Definition class (cT : type) := let: Pack _ c _ := cT return class_of cT in c.

End ClassDef.

Module Exports.

Coercion sort : type >-> Sortclass.
Notation AbelianGroup := type.

End Exports.

End AbelianGroup.

Export AbelianGroup.Exports.

Section AbelianGroup1.

Context {G : AbelianGroup}.

Definition zero := AbelianGroup.zero _ (AbelianGroup.class G).
Definition plus := AbelianGroup.plus _ (AbelianGroup.class G).
Definition opp := AbelianGroup.opp _ (AbelianGroup.class G).
Definition minus x y := (plus x (opp y)).

Lemma plus_comm :
  forall x y : G,
  plus x y = plus y x.

Lemma plus_assoc :
  forall x y z : G,
  plus x (plus y z) = plus (plus x y) z.

Lemma plus_zero_r :
  forall x : G,
  plus x zero = x.

Lemma plus_opp_r :
  forall x : G,
  plus x (opp x) = zero.

Lemma plus_zero_l :
  forall x : G,
  plus zero x = x.

Lemma plus_opp_l :
  forall x : G,
  plus (opp x) x = zero.

Lemma opp_zero :
  opp zero = zero.

Lemma minus_zero_r :
  forall x : G,
  minus x zero = x.

Lemma minus_eq_zero (x : G) :
  minus x x = zero.

Lemma plus_reg_l :
  forall r x y : G,
  plus r x = plus r y -> x = y.
Lemma plus_reg_r :
  forall r x y : G,
  plus x r = plus y r -> x = y.

Lemma opp_opp :
  forall x : G,
  opp (opp x) = x.

Lemma opp_plus :
  forall x y : G,
  opp (plus x y) = plus (opp x) (opp y).
Lemma opp_minus (x y : G) :
  opp (minus x y) = minus y x.

Lemma minus_trans (r x y : G) :
  minus x y = plus (minus x r) (minus r y).

End AbelianGroup1.

Section Sums.

Context {G : AbelianGroup}.

Definition sum_n_m (a : nat -> G) n m :=
  iter_nat plus zero a n m.
Definition sum_n (a : nat -> G) n :=
  sum_n_m a O n.

Lemma sum_n_m_Chasles (a : nat -> G) (n m k : nat) :
  (n <= S m)%nat -> (m <= k)%nat
    -> sum_n_m a n k = plus (sum_n_m a n m) (sum_n_m a (S m) k).

Lemma sum_n_n (a : nat -> G) (n : nat) :
  sum_n_m a n n = a n.
Lemma sum_O (a : nat -> G) : sum_n a 0 = a O.
Lemma sum_n_Sm (a : nat -> G) (n m : nat) :
  (n <= S m)%nat -> sum_n_m a n (S m) = plus (sum_n_m a n m) (a (S m)).
Lemma sum_Sn_m (a : nat -> G) (n m : nat) :
  (n <= m)%nat -> sum_n_m a n m = plus (a n) (sum_n_m a (S n) m).
Lemma sum_n_m_S (a : nat -> G) (n m : nat) :
  sum_n_m (fun n => a (S n)) n m = sum_n_m a (S n) (S m).

Lemma sum_Sn (a : nat -> G) (n : nat) :
  sum_n a (S n) = plus (sum_n a n) (a (S n)).

Lemma sum_n_m_zero (a : nat -> G) (n m : nat) :
  (m < n)%nat -> sum_n_m a n m = zero.
Lemma sum_n_m_const_zero (n m : nat) :
  sum_n_m (fun _ => zero) n m = zero.

Lemma sum_n_m_ext_loc (a b : nat -> G) (n m : nat) :
  (forall k, (n <= k <= m)%nat -> a k = b k) ->
  sum_n_m a n m = sum_n_m b n m.
Lemma sum_n_m_ext (a b : nat -> G) n m :
  (forall n, a n = b n) ->
  sum_n_m a n m = sum_n_m b n m.

Lemma sum_n_ext_loc :
  forall (a b : nat -> G) N,
  (forall n, (n <= N)%nat -> a n = b n) ->
  sum_n a N = sum_n b N.
Lemma sum_n_ext :
  forall (a b : nat -> G) N,
  (forall n, a n = b n) ->
  sum_n a N = sum_n b N.

Lemma sum_n_m_plus :
  forall (u v : nat -> G) (n m : nat),
  sum_n_m (fun k => plus (u k) (v k)) n m = plus (sum_n_m u n m) (sum_n_m v n m).

Lemma sum_n_plus :
  forall (u v : nat -> G) (n : nat),
  sum_n (fun k => plus (u k) (v k)) n = plus (sum_n u n) (sum_n v n).

Lemma sum_n_switch :
  forall (u : nat -> nat -> G) (m n : nat),
  sum_n (fun i => sum_n (u i) n) m = sum_n (fun j => sum_n (fun i => u i j) m) n.

Lemma sum_n_m_sum_n (a:nat -> G) (n m : nat) :
  (n <= m)%nat -> sum_n_m a (S n) m = minus (sum_n a m) (sum_n a n).

End Sums.

Module Ring.

Record mixin_of (K : AbelianGroup) := Mixin {
  mult : K -> K -> K ;
  one : K ;
  ax1 : forall x y z, mult x (mult y z) = mult (mult x y) z ;
  ax2 : forall x, mult x one = x ;
  ax3 : forall x, mult one x = x ;
  ax4 : forall x y z, mult (plus x y) z = plus (mult x z) (mult y z) ;
  ax5 : forall x y z, mult x (plus y z) = plus (mult x y) (mult x z)
}.

Section ClassDef.

Record class_of (K : Type) := Class {
  base : AbelianGroup.class_of K ;
  mixin : mixin_of (AbelianGroup.Pack _ base K)
}.
Local Coercion base : class_of >-> AbelianGroup.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> AbelianGroup.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Notation Ring := type.

End Exports.

End Ring.

Export Ring.Exports.

Section Ring1.

Context {K : Ring}.

Definition mult : K -> K -> K := Ring.mult _ (Ring.class K).
Definition one : K := Ring.one _ (Ring.class K).

Lemma mult_assoc :
  forall x y z : K,
  mult x (mult y z) = mult (mult x y) z.

Lemma mult_one_r :
  forall x : K,
  mult x one = x.

Lemma mult_one_l :
  forall x : K,
  mult one x = x.

Lemma mult_distr_r :
  forall x y z : K,
  mult (plus x y) z = plus (mult x z) (mult y z).

Lemma mult_distr_l :
  forall x y z : K,
  mult x (plus y z) = plus (mult x y) (mult x z).

Lemma mult_zero_r :
  forall x : K,
  mult x zero = zero.

Lemma mult_zero_l :
  forall x : K,
  mult zero x = zero.

Lemma opp_mult_r :
  forall x y : K,
  opp (mult x y) = mult x (opp y).

Lemma opp_mult_l :
  forall x y : K,
  opp (mult x y) = mult (opp x) y.

Lemma opp_mult_m1 :
  forall x : K,
  opp x = mult (opp one) x.

Lemma sum_n_m_mult_r :
 forall (a : K) (u : nat -> K) (n m : nat),
  sum_n_m (fun k => mult (u k) a) n m = mult (sum_n_m u n m) a.

Lemma sum_n_m_mult_l :
 forall (a : K) (u : nat -> K) (n m : nat),
  sum_n_m (fun k => mult a (u k)) n m = mult a (sum_n_m u n m).

Lemma sum_n_mult_r :
 forall (a : K) (u : nat -> K) (n : nat),
  sum_n (fun k => mult (u k) a) n = mult (sum_n u n) a.

Lemma sum_n_mult_l :
 forall (a : K) (u : nat -> K) (n : nat),
  sum_n (fun k => mult a (u k)) n = mult a (sum_n u n).

Fixpoint pow_n (x : K) (N : nat) {struct N} : K :=
  match N with
   | 0%nat => one
   | S i => mult x (pow_n x i)
  end.

Lemma pow_n_plus :
  forall (x : K) (n m : nat), pow_n x (n+m) = mult (pow_n x n) (pow_n x m).

Lemma pow_n_comm_1 :
  forall (x : K) (n : nat), mult (pow_n x n) x = mult x (pow_n x n).

Lemma pow_n_comm :
  forall (x : K) n m, mult (pow_n x n) (pow_n x m) = mult (pow_n x m) (pow_n x n).

End Ring1.

Module AbsRing.

Record mixin_of (K : Ring) := Mixin {
  abs : K -> R ;
  ax1 : abs zero = 0 ;
  ax2 : abs (opp one) = 1 ;
  ax3 : forall x y : K, abs (plus x y) <= abs x + abs y ;
  ax4 : forall x y : K, abs (mult x y) <= abs x * abs y ;
  ax5 : forall x : K, abs x = 0 -> x = zero
}.

Section ClassDef.

Record class_of (K : Type) := Class {
  base : Ring.class_of K ;
  mixin : mixin_of (Ring.Pack _ base K)
}.
Local Coercion base : class_of >-> Ring.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition Ring := Ring.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> Ring.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion Ring : type >-> Ring.type.
Canonical Ring.
Notation AbsRing := type.

End Exports.

End AbsRing.

Export AbsRing.Exports.

Section AbsRing1.

Context {K : AbsRing}.

Definition abs : K -> R := AbsRing.abs _ (AbsRing.class K).

Lemma abs_zero :
  abs zero = 0.

Lemma abs_opp_one :
  abs (opp one) = 1.

Lemma abs_triangle :
  forall x y : K,
  abs (plus x y) <= abs x + abs y.

Lemma abs_mult :
  forall x y : K,
  abs (mult x y) <= abs x * abs y.

Lemma abs_eq_zero :
  forall x : K,
  abs x = 0 -> x = zero.

Lemma abs_opp :
  forall x, abs (opp x) = abs x.

Lemma abs_minus :
  forall x y : K, abs (minus x y) = abs (minus y x).

Lemma abs_one :
  abs one = 1.

Lemma abs_ge_0 :
  forall x, 0 <= abs x.

Lemma abs_pow_n :
  forall (x : K) n,
  abs (pow_n x n) <= (abs x)^n.

End AbsRing1.

Module UniformSpace.

Record mixin_of (M : Type) := Mixin {
  ball : M -> R -> M -> Prop ;
  ax1 : forall x (e : posreal), ball x e x ;
  ax2 : forall x y e, ball x e y -> ball y e x ;
  ax3 : forall x y z e1 e2, ball x e1 y -> ball y e2 z -> ball x (e1 + e2) z
}.

Notation class_of := mixin_of (only parsing).

Section ClassDef.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.
Definition class (cT : type) := let: Pack _ c _ := cT return class_of cT in c.

End ClassDef.

Module Exports.

Coercion sort : type >-> Sortclass.
Notation UniformSpace := type.

End Exports.

End UniformSpace.

Export UniformSpace.Exports.

Section UniformSpace1.

Context {M : UniformSpace}.

Definition ball := UniformSpace.ball _ (UniformSpace.class M).

Lemma ball_center :
  forall (x : M) (e : posreal),
  ball x e x.

Lemma ball_sym :
  forall (x y : M) (e : R),
  ball x e y -> ball y e x.

Lemma ball_triangle :
  forall (x y z : M) (e1 e2 : R),
  ball x e1 y -> ball y e2 z -> ball x (e1 + e2) z.

Lemma ball_le :
  forall (x : M) (e1 e2 : R), e1 <= e2 ->
  forall (y : M), ball x e1 y -> ball x e2 y.

Definition close (x y : M) : Prop := forall eps : posreal, ball x eps y.

Lemma close_refl (x : M) : close x x.

Lemma close_sym (x y : M) : close x y -> close y x.

Lemma close_trans (x y z : M) : close x y -> close y z -> close x z.

End UniformSpace1.

Section AbsRing_UniformSpace.

Variable K : AbsRing.

Definition AbsRing_ball (x : K) (eps : R) (y : K) := abs (minus y x) < eps.

Lemma AbsRing_ball_center :
  forall (x : K) (e : posreal),
  AbsRing_ball x e x.

Lemma AbsRing_ball_sym :
  forall (x y : K) (e : R),
  AbsRing_ball x e y -> AbsRing_ball y e x.

Lemma AbsRing_ball_triangle :
  forall (x y z : K) (e1 e2 : R),
  AbsRing_ball x e1 y -> AbsRing_ball y e2 z ->
  AbsRing_ball x (e1 + e2) z.

Definition AbsRing_UniformSpace_mixin :=
  UniformSpace.Mixin _ _ AbsRing_ball_center AbsRing_ball_sym AbsRing_ball_triangle.

Canonical AbsRing_UniformSpace :=
  UniformSpace.Pack K AbsRing_UniformSpace_mixin K.

End AbsRing_UniformSpace.

Section fct_UniformSpace.

Variable (T : Type) (U : UniformSpace).

Definition fct_ball (x : T -> U) (eps : R) (y : T -> U) :=
  forall t : T, ball (x t) eps (y t).

Lemma fct_ball_center :
  forall (x : T -> U) (e : posreal),
  fct_ball x e x.

Lemma fct_ball_sym :
  forall (x y : T -> U) (e : R),
  fct_ball x e y -> fct_ball y e x.

Lemma fct_ball_triangle :
  forall (x y z : T -> U) (e1 e2 : R),
  fct_ball x e1 y -> fct_ball y e2 z -> fct_ball x (e1 + e2) z.

Definition fct_UniformSpace_mixin :=
  UniformSpace.Mixin _ _ fct_ball_center fct_ball_sym fct_ball_triangle.

Canonical fct_UniformSpace :=
  UniformSpace.Pack (T -> U) fct_UniformSpace_mixin (T -> U).

End fct_UniformSpace.

Definition locally_dist {T : Type} (d : T -> R) (P : T -> Prop) :=
  exists delta : posreal, forall y, d y < delta -> P y.

Global Instance locally_dist_filter :
  forall T (d : T -> R), Filter (locally_dist d).

Section Locally.

Context {T : UniformSpace}.

Definition locally (x : T) (P : T -> Prop) :=
  exists eps : posreal, forall y, ball x eps y -> P y.

Global Instance locally_filter :
  forall x : T, ProperFilter (locally x).

Lemma locally_locally :
  forall (x : T) (P : T -> Prop),
  locally x P -> locally x (fun y => locally y P).

Lemma locally_singleton :
  forall (x : T) (P : T -> Prop),
  locally x P -> P x.

Lemma locally_ball :
  forall (x : T) (eps : posreal), locally x (ball x eps).

Lemma locally_not' :
  forall (x : T) (P : T -> Prop),
  not (forall eps : posreal, not (forall y, ball x eps y -> not (P y))) ->
  {d : posreal | forall y, ball x d y -> not (P y)}.

Lemma locally_not :
  forall (x : T) (P : T -> Prop),
  not (forall eps : posreal, not (forall y, ball x eps y -> not (P y))) ->
  locally x (fun y => not (P y)).

Lemma locally_ex_not :
  forall (x : T) (P : T -> Prop),
  locally x (fun y => not (P y)) ->
  {d : posreal | forall y, ball x d y -> not (P y)}.

Lemma locally_ex_dec :
  forall (x : T) (P : T -> Prop),
  (forall x, P x \/ ~P x) ->
  locally x P ->
  {d : posreal | forall y, ball x d y -> P y}.

Definition is_filter_lim (F : (T -> Prop) -> Prop) (x : T) :=
  forall P, locally x P -> F P.

Lemma is_filter_lim_filter_le :
  forall {F G} (x : T),
  filter_le G F ->
  is_filter_lim F x -> is_filter_lim G x.

Lemma is_filter_lim_close {F} {FF : ProperFilter F} (x y : T) :
  is_filter_lim F x -> is_filter_lim F y -> close x y.

Lemma is_filter_lim_locally_close (x y : T) :
  is_filter_lim (locally x) y -> close x y.

End Locally.

Lemma filterlim_const :
  forall {T} {U : UniformSpace} {F : (T -> Prop) -> Prop} {FF : Filter F},
  forall a : U, filterlim (fun _ => a) F (locally a).

Section Locally_fct.

Context {T : Type} {U : UniformSpace}.

Lemma filterlim_locally :
  forall {F} {FF : Filter F} (f : T -> U) y,
  filterlim f F (locally y) <->
  forall eps : posreal, F (fun x => ball y eps (f x)).

Lemma filterlimi_locally :
  forall {F} {FF : Filter F} (f : T -> U -> Prop) y,
  filterlimi f F (locally y) <->
  forall eps : posreal, F (fun x => exists z, f x z /\ ball y eps z).

Lemma filterlim_locally_close :
  forall {F} {FF: ProperFilter F} (f : T -> U) l l',
  filterlim f F (locally l) ->  filterlim f F (locally l') ->
  close l l'.

Lemma filterlimi_locally_close :
  forall {F} {FF: ProperFilter F} (f : T -> U -> Prop) l l',
  F (fun x => forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  filterlimi f F (locally l) ->  filterlimi f F (locally l') ->
  close l l'.

End Locally_fct.

Lemma is_filter_lim_filtermap {T: UniformSpace} {U : UniformSpace} :
forall F x (f : T -> U),
  filterlim f (locally x) (locally (f x))
  -> is_filter_lim F x
  -> is_filter_lim (filtermap f F) (f x).

Definition locally' {T : UniformSpace} (x : T) :=
  within (fun y => y <> x) (locally x).

Global Instance locally'_filter :
  forall {T : UniformSpace} (x : T), Filter (locally' x).

Section at_point.

Context {T : UniformSpace}.

Definition at_point (a : T) (P : T -> Prop) : Prop := P a.

Global Instance at_point_filter (a : T) :
  ProperFilter (at_point a).

End at_point.

Section Open.

Context {T : UniformSpace}.

Definition open (D : T -> Prop) :=
  forall x, D x -> locally x D.

Lemma locally_open :
  forall (D E : T -> Prop),
  open D ->
  (forall x : T, D x -> E x) ->
  forall x : T, D x ->
  locally x E.

Lemma open_ext :
  forall D E : T -> Prop,
  (forall x, D x <-> E x) ->
  open D -> open E.

Lemma open_and :
  forall D E : T -> Prop,
  open D -> open E ->
  open (fun x => D x /\ E x).

Lemma open_or :
  forall D E : T -> Prop,
  open D -> open E ->
  open (fun x => D x \/ E x).

Lemma open_true :
  open (fun x : T => True).

Lemma open_false :
  open (fun x : T => False).

End Open.

Lemma open_comp :
  forall {T U : UniformSpace} (f : T -> U) (D : U -> Prop),
  (forall x, D (f x) -> filterlim f (locally x) (locally (f x))) ->
  open D -> open (fun x : T => D (f x)).

Section Closed.

Context {T : UniformSpace}.

Definition closed (D : T -> Prop) :=
  forall x, not (locally x (fun x : T => not (D x))) -> D x.

Lemma open_not :
  forall D : T -> Prop,
  closed D -> open (fun x => not (D x)).

Lemma closed_not :
  forall D : T -> Prop,
  open D -> closed (fun x => not (D x)).

Lemma closed_ext :
  forall D E : T -> Prop,
  (forall x, D x <-> E x) ->
  closed D -> closed E.

Lemma closed_and :
  forall D E : T -> Prop,
  closed D -> closed E ->
  closed (fun x => D x /\ E x).

Lemma closed_true :
  closed (fun x : T => True).

Lemma closed_false :
  closed (fun x : T => False).

End Closed.

Lemma closed_comp :
  forall {T U : UniformSpace} (f : T -> U) (D : U -> Prop),
  (forall x, filterlim f (locally x) (locally (f x))) ->
  closed D -> closed (fun x : T => D (f x)).

Lemma closed_filterlim_loc :
  forall {T} {U : UniformSpace} {F} {FF : ProperFilter' F} (f : T -> U) (D : U -> Prop),
  forall y, filterlim f F (locally y) ->
  F (fun x => D (f x)) ->
  closed D -> D y.

Lemma closed_filterlim :
  forall {T} {U : UniformSpace} {F} {FF : ProperFilter' F} (f : T -> U) (D : U -> Prop),
  forall y, filterlim f F (locally y) ->
  (forall x, D (f x)) ->
  closed D -> D y.

Definition cauchy {T : UniformSpace} (F : (T -> Prop) -> Prop) :=
  forall eps : posreal, exists x, F (ball x eps).

Module CompleteSpace.

Record mixin_of (T : UniformSpace) := Mixin {
  lim : ((T -> Prop) -> Prop) -> T ;
  ax1 : forall F, ProperFilter F -> cauchy F -> forall eps : posreal, F (ball (lim F) eps) ;
  ax2 : forall F1 F2, filter_le F1 F2 -> filter_le F2 F1 -> close (lim F1) (lim F2)
}.

Section ClassDef.

Record class_of (T : Type) := Class {
  base : UniformSpace.class_of T ;
  mixin : mixin_of (UniformSpace.Pack _ base T)
}.
Local Coercion base : class_of >-> UniformSpace.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition UniformSpace := UniformSpace.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> UniformSpace.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Notation CompleteSpace := type.

End Exports.

End CompleteSpace.

Export CompleteSpace.Exports.

Section CompleteSpace1.

Context {T : CompleteSpace}.

Definition lim : ((T -> Prop) -> Prop) -> T := CompleteSpace.lim _ (CompleteSpace.class T).

Lemma complete_cauchy :
  forall F : (T -> Prop) -> Prop,
  ProperFilter F -> cauchy F ->
  forall eps : posreal,
  F (ball (lim F) eps).

Lemma close_lim :
  forall F1 F2 : (T -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  close (lim F1) (lim F2).

Definition iota (P : T -> Prop) := lim (fun A => (forall x, P x -> A x)).

Lemma iota_correct_weak :
  forall P : T -> Prop,
  (forall x y, P x -> P y -> close x y) ->
  forall x, P x -> close (iota P) x.

Lemma close_iota :
  forall P Q : T -> Prop,
  (forall x, P x <-> Q x) ->
  close (iota P) (iota Q).

End CompleteSpace1.

Lemma cauchy_distance :
  forall {T : UniformSpace} {F} {FF : ProperFilter F},
  (forall eps : posreal, exists x, F (ball x eps)) <->
  (forall eps : posreal, exists P, F P /\ forall u v : T, P u -> P v -> ball u eps v).

Section fct_CompleteSpace.

Context {T : Type} {U : CompleteSpace}.

Lemma filterlim_locally_cauchy :
  forall {F} {FF : ProperFilter F} (f : T -> U),
  (forall eps : posreal, exists P, F P /\ forall u v : T, P u -> P v -> ball (f u) eps (f v)) <->
  exists y, filterlim f F (locally y).

Lemma filterlimi_locally_cauchy :
  forall {F} {FF : ProperFilter F} (f : T -> U -> Prop),
  F (fun x => (exists y, f x y) /\
    (forall y1 y2, f x y1 -> f x y2 -> y1 = y2)) ->
  ((forall eps : posreal, exists P, F P /\
   forall u v : T, P u -> P v -> forall u' v': U, f u u' -> f v v' -> ball u' eps v') <->
  exists y, filterlimi f F (locally y)).

Definition lim_fct (F : ((T -> U) -> Prop) -> Prop) (t : T) :=
  lim (fun P => F (fun g => P (g t))).

Lemma complete_cauchy_fct :
  forall (F : ((T -> U) -> Prop) -> Prop),
  ProperFilter F ->
  (forall eps : posreal, exists f : T -> U, F (ball f eps)) ->
  forall eps : posreal, F (ball (lim_fct F) eps).

Lemma close_lim_fct :
  forall F1 F2 : ((T -> U) -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  close (lim_fct F1) (lim_fct F2).

Definition fct_CompleteSpace_mixin :=
  CompleteSpace.Mixin _ lim_fct complete_cauchy_fct close_lim_fct.

Canonical fct_CompleteSpace :=
  CompleteSpace.Pack (T -> U) (CompleteSpace.Class _ _ fct_CompleteSpace_mixin) (T -> U).

End fct_CompleteSpace.

Section Filterlim_switch.

Context {T1 T2 : Type}.

Lemma filterlim_switch_1 {U : UniformSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : Filter F2) (f : T1 -> T2 -> U) g h (l : U) :
  filterlim f F1 (locally g) ->
  (forall x, filterlim (f x) F2 (locally (h x))) ->
  filterlim h F1 (locally l) -> filterlim g F2 (locally l).

Lemma filterlim_switch_2 {U : CompleteSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : ProperFilter F2) (f : T1 -> T2 -> U) g h :
  filterlim f F1 (locally g) ->
  (forall x, filterlim (f x) F2 (locally (h x))) ->
  exists l : U, filterlim h F1 (locally l).

Lemma filterlim_switch {U : CompleteSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : ProperFilter F2) (f : T1 -> T2 -> U) g h :
  filterlim f F1 (locally g) ->
  (forall x, filterlim (f x) F2 (locally (h x))) ->
  exists l : U, filterlim h F1 (locally l) /\ filterlim g F2 (locally l).

End Filterlim_switch.

Lemma filterlim_switch_dom {T1 T2 : Type} {U : CompleteSpace}
  F1 (FF1 : ProperFilter F1) F2 (FF2 : Filter F2)
  (dom : T2 -> Prop) (HF2 : forall P, F2 P -> exists x, dom x /\ P x)
  (f : T1 -> T2 -> U) g h :
  filterlim (fun x (y : {z : T2 | dom z}) => f x (proj1_sig y)) F1 (locally (T := fct_UniformSpace _ _) (fun y : {z : T2 | dom z} => g (proj1_sig y))) ->
  (forall x, filterlim (f x) (within dom F2) (locally (h x))) ->
  exists l : U, filterlim h F1 (locally l) /\ filterlim g (within dom F2) (locally l).

Module ModuleSpace.

Record mixin_of (K : Ring) (V : AbelianGroup) := Mixin {
  scal : K -> V -> V ;
  ax1 : forall x y u, scal x (scal y u) = scal (mult x y) u ;
  ax2 : forall u, scal one u = u ;
  ax3 : forall x u v, scal x (plus u v) = plus (scal x u) (scal x v) ;
  ax4 : forall x y u, scal (plus x y) u = plus (scal x u) (scal y u)
}.

Section ClassDef.

Variable K : Ring.

Record class_of (V : Type) := Class {
  base : AbelianGroup.class_of V ;
  mixin : mixin_of K (AbelianGroup.Pack _ base V)
}.
Local Coercion base : class_of >-> AbelianGroup.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> AbelianGroup.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Notation ModuleSpace := type.

End Exports.

End ModuleSpace.

Export ModuleSpace.Exports.

Section ModuleSpace1.

Context {K : Ring} {V : ModuleSpace K}.

Definition scal : K -> V -> V := ModuleSpace.scal _ _ (ModuleSpace.class K V).

Lemma scal_assoc :
  forall (x y : K) (u : V),
  scal x (scal y u) = scal (mult x y) u.

Lemma scal_one :
  forall (u : V), scal one u = u.

Lemma scal_distr_l :
  forall (x : K) (u v : V),
  scal x (plus u v) = plus (scal x u) (scal x v).

Lemma scal_distr_r :
  forall (x y : K) (u : V),
  scal (plus x y) u = plus (scal x u) (scal y u).

Lemma scal_zero_r :
  forall x : K,
  scal x zero = zero.

Lemma scal_zero_l :
  forall u : V,
  scal zero u = zero.

Lemma scal_opp_l :
  forall (x : K) (u : V),
  scal (opp x) u = opp (scal x u).

Lemma scal_opp_r :
  forall (x : K) (u : V),
  scal x (opp u) = opp (scal x u).

Lemma scal_opp_one :
  forall u : V,
  scal (opp one) u = opp u.

Lemma scal_minus_distr_l (x : K) (u v : V) :
   scal x (minus u v) = minus (scal x u) (scal x v).
Lemma scal_minus_distr_r (x y : K) (u : V) :
   scal (minus x y) u = minus (scal x u) (scal y u).

Lemma sum_n_m_scal_l :
  forall (a : K) (u : nat -> V) (n m : nat),
  sum_n_m (fun k => scal a (u k)) n m = scal a (sum_n_m u n m).

Lemma sum_n_scal_l :
  forall (a : K) (u : nat -> V) (n : nat),
  sum_n (fun k => scal a (u k)) n = scal a (sum_n u n).

End ModuleSpace1.

Section Ring_ModuleSpace.

Variable (K : Ring).

Definition Ring_ModuleSpace_mixin :=
  ModuleSpace.Mixin K _ _ mult_assoc mult_one_l mult_distr_l mult_distr_r.

Canonical Ring_ModuleSpace :=
  ModuleSpace.Pack K K (ModuleSpace.Class _ _ _ Ring_ModuleSpace_mixin) K.

End Ring_ModuleSpace.

Section AbsRing_ModuleSpace.

Variable (K : AbsRing).

Definition AbsRing_ModuleSpace_mixin :=
  ModuleSpace.Mixin K _ _ mult_assoc mult_one_l mult_distr_l mult_distr_r.

Canonical AbsRing_ModuleSpace :=
  ModuleSpace.Pack K K (ModuleSpace.Class _ _ _ AbsRing_ModuleSpace_mixin) K.

End AbsRing_ModuleSpace.

Module NormedModuleAux.

Section ClassDef.

Variable K : AbsRing.

Record class_of (T : Type) := Class {
  base : ModuleSpace.class_of K T ;
  mixin : UniformSpace.mixin_of T
}.
Local Coercion base : class_of >-> ModuleSpace.class_of.
Local Coercion mixin : class_of >-> UniformSpace.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition ModuleSpace := ModuleSpace.Pack _ cT xclass xT.
Definition UniformSpace := UniformSpace.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> ModuleSpace.class_of.
Coercion mixin : class_of >-> UniformSpace.class_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion ModuleSpace : type >-> ModuleSpace.type.
Canonical ModuleSpace.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Notation NormedModuleAux := type.

End Exports.

End NormedModuleAux.

Export NormedModuleAux.Exports.

Module NormedModule.

Record mixin_of (K : AbsRing) (V : NormedModuleAux K) := Mixin {
  norm : V -> R ;
  norm_factor : R ;
  ax1 : forall (x y : V), norm (plus x y) <= norm x + norm y ;
  ax2 : forall (l : K) (x : V), norm (scal l x) <= abs l * norm x ;
  ax3 : forall (x y : V) (eps : R), norm (minus y x) < eps -> ball x eps y ;
  ax4 : forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps ;
  ax5 : forall x : V, norm x = 0 -> x = zero
}.

Section ClassDef.

Variable K : AbsRing.

Record class_of (T : Type) := Class {
  base : NormedModuleAux.class_of K T ;
  mixin : mixin_of K (NormedModuleAux.Pack K T base T)
}.
Local Coercion base : class_of >-> NormedModuleAux.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition ModuleSpace := ModuleSpace.Pack _ cT xclass xT.
Definition UniformSpace := UniformSpace.Pack cT xclass xT.
Definition NormedModuleAux := NormedModuleAux.Pack _ cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> NormedModuleAux.class_of.
Coercion mixin : class_of >-> mixin_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion ModuleSpace : type >-> ModuleSpace.type.
Canonical ModuleSpace.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Coercion NormedModuleAux : type >-> NormedModuleAux.type.
Canonical NormedModuleAux.
Notation NormedModule := type.

End Exports.

End NormedModule.

Export NormedModule.Exports.

Section NormedModule1.

Context {K : AbsRing} {V : NormedModule K}.

Definition norm : V -> R := NormedModule.norm K _ (NormedModule.class K V).

Definition norm_factor : R := NormedModule.norm_factor K _ (NormedModule.class K V).

Lemma norm_triangle :
  forall x y : V,
  norm (plus x y) <= norm x + norm y.

Lemma norm_scal :
  forall (l : K) (x : V),
  norm (scal l x) <= abs l * norm x.

Lemma norm_compat1 :
  forall (x y : V) (eps : R),
  norm (minus y x) < eps -> ball x eps y.

Lemma norm_compat2 :
  forall (x y : V) (eps : posreal), ball x eps y -> norm (minus y x) < norm_factor * eps.

Lemma norm_eq_zero :
  forall x : V, norm x = 0 -> x = zero.

Lemma norm_zero :
  norm zero = 0.

Lemma norm_factor_gt_0 :
  0 < norm_factor.

Lemma norm_opp :
  forall x : V,
  norm (opp x) = norm x.

Lemma norm_ge_0 :
  forall x : V,
  0 <= norm x.

Lemma norm_triangle_inv :
  forall x y : V,
  Rabs (norm x - norm y) <= norm (minus x y).

Lemma eq_close :
  forall x y : V,
  close x y -> x = y.

Definition ball_norm (x : V) (eps : R) (y : V) := norm (minus y x) < eps.

Definition locally_norm (x : V) (P : V -> Prop) :=
  exists eps : posreal, forall y, ball_norm x eps y -> P y.

Lemma locally_le_locally_norm :
  forall x, filter_le (locally x) (locally_norm x).

Lemma locally_norm_le_locally :
  forall x, filter_le (locally_norm x) (locally x).

Lemma locally_norm_ball_norm :
  forall (x : V) (eps : posreal),
  locally_norm x (ball_norm x eps).

Lemma locally_norm_ball :
  forall (x : V) (eps : posreal),
  locally_norm x (ball x eps).

Lemma locally_ball_norm :
  forall (x : V) (eps : posreal),
  locally x (ball_norm x eps).

Lemma ball_norm_triangle (x y z : V) (e1 e2 : R) :
  ball_norm x e1 y -> ball_norm y e2 z -> ball_norm x (e1 + e2) z.

Lemma ball_norm_center (x : V) (e : posreal) :
  ball_norm x e x.

Lemma ball_norm_dec : forall (x y : V) (eps : posreal),
  {ball_norm x eps y} + {~ ball_norm x eps y}.

Lemma ball_norm_sym :
  forall (x y : V) (eps : posreal), ball_norm x eps y -> ball_norm y eps x.

Lemma ball_norm_le :
  forall (x : V) (e1 e2 : posreal), e1 <= e2 ->
  forall y, ball_norm x e1 y -> ball_norm x e2 y.

Lemma ball_norm_eq :
  forall x y : V,
  (forall eps : posreal, ball_norm x eps y) -> x = y.

Lemma is_filter_lim_unique :
  forall {F} {FF : ProperFilter' F} (x y : V),
  is_filter_lim F x -> is_filter_lim F y -> x = y.

Lemma is_filter_lim_locally_unique :
  forall (x y : V),
  is_filter_lim (locally x) y -> x = y.

End NormedModule1.

Section NormedModule2.

Context {T : Type} {K : AbsRing} {V : NormedModule K}.

Lemma filterlim_locally_unique :
  forall {F} {FF : ProperFilter' F} (f : T -> V) (x y : V),
  filterlim f F (locally x) -> filterlim f F (locally y) ->
  x = y.

Lemma filterlimi_locally_unique :
  forall {F} {FF : ProperFilter' F} (f : T -> V -> Prop) (x y : V),
  F (fun x => forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  filterlimi f F (locally x) -> filterlimi f F (locally y) ->
  x = y.

End NormedModule2.

Section AbsRing_NormedModule.

Variable (K : AbsRing).

Canonical AbsRing_NormedModuleAux :=
  NormedModuleAux.Pack K K (NormedModuleAux.Class _ _ (ModuleSpace.class _ (AbsRing_ModuleSpace K)) (UniformSpace.class (AbsRing_UniformSpace K))) K.

Lemma AbsRing_norm_compat2 :
  forall (x y : AbsRing_NormedModuleAux) (eps : posreal),
  ball x eps y -> abs (minus y x) < 1 * eps.

Definition AbsRing_NormedModule_mixin :=
  NormedModule.Mixin K _ abs 1 abs_triangle abs_mult (fun x y e H => H) AbsRing_norm_compat2 abs_eq_zero.

Canonical AbsRing_NormedModule :=
  NormedModule.Pack K _ (NormedModule.Class _ _ _ AbsRing_NormedModule_mixin) K.

End AbsRing_NormedModule.

Section NVS_continuity.

Context {K : AbsRing} {V : NormedModule K}.

Lemma filterlim_plus :
  forall x y : V,
  filterlim (fun z : V * V => plus (fst z) (snd z)) (filter_prod (locally x) (locally y)) (locally (plus x y)).

Lemma filterlim_scal (k : K) (x : V) :
  filterlim (fun z => scal (fst z) (snd z)) (filter_prod (locally k) (locally x)) (locally (scal k x)).
Lemma filterlim_scal_r (k : K) (x : V) :
  filterlim (fun z : V => scal k z) (locally x) (locally (scal k x)).
Lemma filterlim_scal_l (k : K) (x : V) :
  filterlim (fun z => scal z x) (locally k) (locally (scal k x)).

Lemma filterlim_opp :
  forall x : V,
  filterlim opp (locally x) (locally (opp x)).

End NVS_continuity.

Lemma filterlim_mult {K : AbsRing} (x y : K) :
  filterlim (fun z => mult (fst z) (snd z)) (filter_prod (locally x) (locally y)) (locally (mult x y)).

Lemma filterlim_locally_ball_norm :
  forall {K : AbsRing} {T} {U : NormedModule K} {F : (T -> Prop) -> Prop} {FF : Filter F} (f : T -> U) (y : U),
  filterlim f F (locally y) <-> forall eps : posreal, F (fun x => ball_norm y eps (f x)).

Module CompleteNormedModule.

Section ClassDef.

Variable K : AbsRing.

Record class_of (T : Type) := Class {
  base : NormedModule.class_of K T ;
  mixin : CompleteSpace.mixin_of (UniformSpace.Pack T base T)
}.
Local Coercion base : class_of >-> NormedModule.class_of.
Definition base2 T (cT : class_of T) : CompleteSpace.class_of T :=
  CompleteSpace.Class _ (base T cT) (mixin T cT).
Local Coercion base2 : class_of >-> CompleteSpace.class_of.

Structure type := Pack { sort; _ : class_of sort ; _ : Type }.
Local Coercion sort : type >-> Sortclass.

Variable cT : type.

Definition class := let: Pack _ c _ := cT return class_of cT in c.

Let xT := let: Pack T _ _ := cT in T.
Notation xclass := (class : class_of xT).

Definition AbelianGroup := AbelianGroup.Pack cT xclass xT.
Definition ModuleSpace := ModuleSpace.Pack _ cT xclass xT.
Definition NormedModuleAux := NormedModuleAux.Pack _ cT xclass xT.
Definition NormedModule := NormedModule.Pack _ cT xclass xT.
Definition UniformSpace := UniformSpace.Pack cT xclass xT.
Definition CompleteSpace := CompleteSpace.Pack cT xclass xT.

End ClassDef.

Module Exports.

Coercion base : class_of >-> NormedModule.class_of.
Coercion mixin : class_of >-> CompleteSpace.mixin_of.
Coercion base2 : class_of >-> CompleteSpace.class_of.
Coercion sort : type >-> Sortclass.
Coercion AbelianGroup : type >-> AbelianGroup.type.
Canonical AbelianGroup.
Coercion ModuleSpace : type >-> ModuleSpace.type.
Canonical ModuleSpace.
Coercion NormedModuleAux : type >-> NormedModuleAux.type.
Canonical NormedModuleAux.
Coercion NormedModule : type >-> NormedModule.type.
Canonical NormedModule.
Coercion UniformSpace : type >-> UniformSpace.type.
Canonical UniformSpace.
Coercion CompleteSpace : type >-> CompleteSpace.type.
Canonical CompleteSpace.
Notation CompleteNormedModule := type.

End Exports.

End CompleteNormedModule.

Export CompleteNormedModule.Exports.

Section CompleteNormedModule1.

Context {K : AbsRing} {V : CompleteNormedModule K}.

Lemma iota_unique :
  forall (P : V -> Prop) (x : V),
  (forall y, P y -> y = x) ->
  P x ->
  iota P = x.

Lemma iota_correct :
  forall P : V -> Prop,
  (exists! x : V, P x) ->
  P (iota P).

Lemma iota_is_filter_lim {F} {FF : ProperFilter' F} (l : V) :
  is_filter_lim F l ->
  iota (is_filter_lim F) = l.

Context {T : Type}.

Lemma iota_filterlim_locally {F} {FF : ProperFilter' F} (f : T -> V) l :
  filterlim f F (locally l) ->
  iota (fun x => filterlim f F (locally x)) = l.

Lemma iota_filterlimi_locally {F} {FF : ProperFilter' F} (f : T -> V -> Prop) l :
  F (fun x => forall y1 y2, f x y1 -> f x y2 -> y1 = y2) ->
  filterlimi f F (locally l) ->
  iota (fun x => filterlimi f F (locally x)) = l.

End CompleteNormedModule1.

Section prod_AbelianGroup.

Context {U V : AbelianGroup}.

Definition prod_plus (x y : U * V) :=
  (plus (fst x) (fst y), plus (snd x) (snd y)).

Definition prod_opp (x : U * V) :=
  (opp (fst x), opp (snd x)).

Definition prod_zero : U * V := (zero, zero).

Lemma prod_plus_comm :
  forall x y : U * V,
  prod_plus x y = prod_plus y x.

Lemma prod_plus_assoc :
  forall x y z : U * V,
  prod_plus x (prod_plus y z) = prod_plus (prod_plus x y) z.

Lemma prod_plus_zero_r :
  forall x : U * V,
  prod_plus x prod_zero = x.

Lemma prod_plus_opp_r :
  forall x : U * V,
  prod_plus x (prod_opp x) = prod_zero.

End prod_AbelianGroup.

Definition prod_AbelianGroup_mixin (U V : AbelianGroup) :=
  AbelianGroup.Mixin (U * V) _ _ _ prod_plus_comm prod_plus_assoc prod_plus_zero_r prod_plus_opp_r.

Canonical prod_AbelianGroup (U V : AbelianGroup) :=
  AbelianGroup.Pack (U * V) (prod_AbelianGroup_mixin U V) (U * V).

Section prod_UniformSpace.

Context {U V : UniformSpace}.

Definition prod_ball (x : U * V) (eps : R) (y : U * V) :=
  ball (fst x) eps (fst y) /\ ball (snd x) eps (snd y).

Lemma prod_ball_center :
  forall (x : U * V) (eps : posreal),
  prod_ball x eps x.

Lemma prod_ball_sym :
  forall (x y : U * V) (eps : R),
  prod_ball x eps y -> prod_ball y eps x.

Lemma prod_ball_triangle :
  forall (x y z : U * V) (e1 e2 : R),
  prod_ball x e1 y -> prod_ball y e2 z ->
  prod_ball x (e1 + e2) z.

End prod_UniformSpace.

Definition prod_UniformSpace_mixin (U V : UniformSpace) :=
  UniformSpace.Mixin (U * V) _ prod_ball_center prod_ball_sym prod_ball_triangle.

Canonical prod_UniformSpace (U V : UniformSpace) :=
  UniformSpace.Pack (U * V) (prod_UniformSpace_mixin U V) (U * V).

Section prod_ModuleSpace.

Context {K : Ring} {U V : ModuleSpace K}.

Definition prod_scal (x : K) (u : U * V) :=
  (scal x (fst u), scal x (snd u)).

Lemma prod_scal_assoc :
  forall (x y : K) (u : U * V),
  prod_scal x (prod_scal y u) = prod_scal (mult x y) u.

Lemma prod_scal_one :
  forall u : U * V,
  prod_scal one u = u.

Lemma prod_scal_distr_l :
  forall (x : K) (u v : U * V),
  prod_scal x (prod_plus u v) = prod_plus (prod_scal x u) (prod_scal x v).

Lemma prod_scal_distr_r :
  forall (x y : K) (u : U * V),
  prod_scal (plus x y) u = prod_plus (prod_scal x u) (prod_scal y u).

End prod_ModuleSpace.

Definition prod_ModuleSpace_mixin (K : Ring) (U V : ModuleSpace K) :=
  ModuleSpace.Mixin K _ _ (@prod_scal_assoc K U V) prod_scal_one prod_scal_distr_l prod_scal_distr_r.

Canonical prod_ModuleSpace (K : Ring) (U V : ModuleSpace K) :=
  ModuleSpace.Pack K (U * V) (ModuleSpace.Class _ _ _ (prod_ModuleSpace_mixin K U V)) (U * V).

Canonical prod_NormedModuleAux (K : AbsRing) (U V : NormedModuleAux K) :=
  NormedModuleAux.Pack K (U * V) (NormedModuleAux.Class _ _ (ModuleSpace.class K _) (UniformSpace.class (prod_UniformSpace U V))) (U * V).

Lemma sqrt_plus_sqr :
  forall x y : R, Rmax (Rabs x) (Rabs y) <= sqrt (x ^ 2 + y ^ 2) <= sqrt 2 * Rmax (Rabs x) (Rabs y).

Section prod_NormedModule.

Context {K : AbsRing} {U V : NormedModule K}.

Definition prod_norm (x : U * V) :=
  sqrt (norm (fst x) ^ 2 + norm (snd x) ^ 2).

Lemma prod_norm_triangle :
  forall x y : U * V,
  prod_norm (plus x y) <= prod_norm x + prod_norm y.

Lemma prod_norm_scal :
  forall (l : K) (x : U * V),
  prod_norm (scal l x) <= abs l * prod_norm x.

Lemma prod_norm_compat1 :
  forall (x y : U * V) (eps : R),
  prod_norm (minus y x) < eps -> ball x eps y.

Definition prod_norm_factor :=
  sqrt 2 * Rmax (@norm_factor K U) (@norm_factor K V).

Lemma prod_norm_compat2 :
  forall (x y : U * V) (eps : posreal),
  ball x eps y ->
  prod_norm (minus y x) < prod_norm_factor * eps.

Lemma prod_norm_eq_zero :
  forall x : U * V,
  prod_norm x = 0 -> x = zero.

End prod_NormedModule.

Definition prod_NormedModule_mixin (K : AbsRing) (U V : NormedModule K) :=
  NormedModule.Mixin K _ (@prod_norm K U V) prod_norm_factor prod_norm_triangle
  prod_norm_scal prod_norm_compat1 prod_norm_compat2 prod_norm_eq_zero.

Canonical prod_NormedModule (K : AbsRing) (U V : NormedModule K) :=
  NormedModule.Pack K (U * V) (NormedModule.Class K (U * V) _ (prod_NormedModule_mixin K U V)) (U * V).

Lemma norm_prod {K : AbsRing}
  {U : NormedModule K} {V : NormedModule K}
  (x : U) (y : V) :
  Rmax (norm x) (norm y) <= norm (x,y) <= sqrt 2 * Rmax (norm x) (norm y).

Fixpoint Tn (n : nat) (T : Type) : Type :=
  match n with
  | O => unit
  | S n => prod T (Tn n T)
  end.

Notation "[ x1 , .. , xn ]" := (pair x1 .. (pair xn tt) .. ).

Fixpoint mk_Tn {T} (n : nat) (u : nat -> T) : Tn n T :=
  match n with
    | O => (tt : Tn O T)
    | S n => (u O, mk_Tn n (fun n => u (S n)))
  end.
Fixpoint coeff_Tn {T} {n : nat} (x0 : T) : (Tn n T) -> nat -> T :=
  match n with
  | O => fun (_ : Tn O T) (_ : nat) => x0
  | S n' => fun (v : Tn (S n') T) (i : nat) => match i with
           | O => fst v
           | S i => coeff_Tn x0 (snd v) i
           end
  end.
Lemma mk_Tn_bij {T} {n : nat} (x0 : T) (v : Tn n T) :
  mk_Tn n (coeff_Tn x0 v) = v.
Lemma coeff_Tn_bij {T} {n : nat} (x0 : T) (u : nat -> T) :
  forall i, (i < n)%nat -> coeff_Tn x0 (mk_Tn n u) i = u i.
Lemma coeff_Tn_ext {T} {n : nat} (x1 x2 : T) (v1 v2 : Tn n T) :
  v1 = v2 <-> forall i, (i < n)%nat -> coeff_Tn x1 v1 i = coeff_Tn x2 v2 i.
Lemma mk_Tn_ext {T} (n : nat) (u1 u2 : nat -> T) :
  (forall i, (i < n)%nat -> (u1 i) = (u2 i))
    <-> (mk_Tn n u1) = (mk_Tn n u2).

Fixpoint Fn (n : nat) (T U : Type) : Type :=
  match n with
  | O => U
  | S n => T -> Fn n T U
  end.

Section Matrices.

Context {T : Type}.

Definition matrix (m n : nat) := Tn m (Tn n T).

Definition coeff_mat {m n : nat} (x0 : T) (A : matrix m n) (i j : nat) :=
  coeff_Tn x0 (coeff_Tn (mk_Tn _ (fun _ => x0)) A i) j.

Definition mk_matrix (m n : nat) (U : nat -> nat -> T) : matrix m n :=
  mk_Tn m (fun i => (mk_Tn n (U i))).

Lemma mk_matrix_bij {m n : nat} (x0 : T) (A : matrix m n) :
  mk_matrix m n (coeff_mat x0 A) = A.

Lemma coeff_mat_bij {m n : nat} (x0 : T) (u : nat -> nat -> T) :
  forall i j, (i < m)%nat -> (j < n)%nat -> coeff_mat x0 (mk_matrix m n u) i j = u i j.

Lemma coeff_mat_ext_aux {m n : nat} (x1 x2 : T) (v1 v2 : matrix m n) :
  v1 = v2 <-> forall i j, (i < m)%nat -> (j < n)%nat -> (coeff_mat x1 v1 i j) = (coeff_mat x2 v2 i j).

Lemma coeff_mat_ext {m n : nat} (x0 : T) (v1 v2 : matrix m n) :
  v1 = v2 <-> forall i j, (coeff_mat x0 v1 i j) = (coeff_mat x0 v2 i j).

Lemma mk_matrix_ext (m n : nat) (u1 u2 : nat -> nat -> T) :
  (forall i j, (i < m)%nat -> (j < n)%nat -> (u1 i j) = (u2 i j))
    <-> (mk_matrix m n u1) = (mk_matrix m n u2).

End Matrices.

Section MatrixGroup.

Context {G : AbelianGroup} {m n : nat}.

Definition Mzero := mk_matrix m n (fun i j => @zero G).

Definition Mplus (A B : @matrix G m n) :=
  mk_matrix m n (fun i j => plus (coeff_mat zero A i j) (coeff_mat zero B i j)).

Definition Mopp (A : @matrix G m n) :=
  mk_matrix m n (fun i j => opp (coeff_mat zero A i j)).

Lemma Mplus_comm :
  forall A B : @matrix G m n,
  Mplus A B = Mplus B A.

Lemma Mplus_assoc :
  forall A B C : @matrix G m n,
  Mplus A (Mplus B C) = Mplus (Mplus A B) C.

Lemma Mplus_zero_r :
  forall A : @matrix G m n,
  Mplus A Mzero = A.

Lemma Mplus_opp_r :
  forall A : @matrix G m n,
  Mplus A (Mopp A) = Mzero.

Definition matrix_AbelianGroup_mixin :=
  AbelianGroup.Mixin _ _ _ _ Mplus_comm Mplus_assoc Mplus_zero_r Mplus_opp_r.

Canonical matrix_AbelianGroup :=
  AbelianGroup.Pack _ matrix_AbelianGroup_mixin (@matrix G m n).

End MatrixGroup.

Section MatrixRing.

Context {T : Ring}.

Fixpoint Mone_seq i j : T :=
  match i,j with
    | O, O => one
    | O, S _ | S _, O => zero
    | S i, S j => Mone_seq i j end.

Definition Mone {n} : matrix n n :=
  mk_matrix n n Mone_seq.

Lemma Mone_seq_diag :
  forall i j : nat, i = j -> Mone_seq i j = @one T.
Lemma Mone_seq_not_diag :
  forall i j : nat, i <> j -> Mone_seq i j = @zero T.

Definition Mmult {n m k} (A : @matrix T n m) (B : @matrix T m k) :=
  mk_matrix n k (fun i j => sum_n (fun l => mult (coeff_mat zero A i l) (coeff_mat zero B l j)) (pred m)).

Lemma Mmult_assoc {n m k l} :
  forall (A : matrix n m) (B : matrix m k) (C : matrix k l),
  Mmult A (Mmult B C) = Mmult (Mmult A B) C.

Lemma Mmult_one_r {m n} :
  forall x : matrix m n, Mmult x Mone = x.

Lemma Mmult_one_l {m n} :
  forall x : matrix m n, Mmult Mone x = x.

Lemma Mmult_distr_r {m n k} :
  forall (A B : @matrix T m n) (C : @matrix T n k),
  Mmult (Mplus A B) C = Mplus (Mmult A C) (Mmult B C).

Lemma Mmult_distr_l {m n k} :
  forall (A : @matrix T m n) (B C : @matrix T n k),
  Mmult A (Mplus B C) = Mplus (Mmult A B) (Mmult A C).

Definition matrix_Ring_mixin {n} :=
  Ring.Mixin _ _ _ (@Mmult_assoc n n n n) Mmult_one_r Mmult_one_l Mmult_distr_r Mmult_distr_l.

Canonical matrix_Ring {n} :=
  Ring.Pack (@matrix T n n) (Ring.Class _ _ matrix_Ring_mixin) (@matrix T n n).

Definition matrix_ModuleSpace_mixin {m n} :=
  ModuleSpace.Mixin (@matrix_Ring m) (@matrix_AbelianGroup T m n) Mmult
    Mmult_assoc Mmult_one_l Mmult_distr_l Mmult_distr_r.

Canonical matrix_ModuleSpace {m n} :=
  ModuleSpace.Pack _ (@matrix T m n) (ModuleSpace.Class _ _ _ matrix_ModuleSpace_mixin) (@matrix T m n).

End MatrixRing.

Definition eventually (P : nat -> Prop) :=
  exists N : nat, forall n, (N <= n)%nat -> P n.

Global Instance eventually_filter : ProperFilter eventually.

Definition R_AbelianGroup_mixin :=
  AbelianGroup.Mixin _ _ _ _ Rplus_comm (fun x y z => sym_eq (Rplus_assoc x y z)) Rplus_0_r Rplus_opp_r.

Canonical R_AbelianGroup :=
  AbelianGroup.Pack _ R_AbelianGroup_mixin R.

Definition R_Ring_mixin :=
  Ring.Mixin _ _ _ (fun x y z => sym_eq (Rmult_assoc x y z)) Rmult_1_r Rmult_1_l Rmult_plus_distr_r Rmult_plus_distr_l.

Canonical R_Ring :=
  Ring.Pack R (Ring.Class _ _ R_Ring_mixin) R.

Lemma Rabs_m1 :
  Rabs (-1) = 1.

Definition R_AbsRing_mixin :=
  AbsRing.Mixin _ _ Rabs_R0 Rabs_m1 Rabs_triang (fun x y => Req_le _ _ (Rabs_mult x y)) Rabs_eq_0.

Canonical R_AbsRing :=
  AbsRing.Pack R (AbsRing.Class _ _ R_AbsRing_mixin) R.

Definition R_UniformSpace_mixin :=
  AbsRing_UniformSpace_mixin R_AbsRing.

Canonical R_UniformSpace :=
  UniformSpace.Pack R R_UniformSpace_mixin R.

Definition R_complete_lim (F : (R -> Prop) -> Prop) : R :=
  Lub_Rbar (fun x : R => F (ball (x + 1) (mkposreal _ Rlt_0_1))).

Lemma R_complete_ax1 :
  forall F : (R -> Prop) -> Prop,
  ProperFilter' F ->
  (forall eps : posreal, exists x : R, F (ball x eps)) ->
  forall eps : posreal, F (ball (R_complete_lim F) eps).

Lemma R_complete :
  forall F : (R -> Prop) -> Prop,
  ProperFilter F ->
  (forall eps : posreal, exists x : R, F (ball x eps)) ->
  forall eps : posreal, F (ball (R_complete_lim F) eps).

Lemma R_complete_ax2 :
  forall F1 F2 : (R -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  R_complete_lim F1 = R_complete_lim F2.

Lemma R_complete_close :
  forall F1 F2 : (R -> Prop) -> Prop,
  filter_le F1 F2 -> filter_le F2 F1 ->
  close (R_complete_lim F1) (R_complete_lim F2).

Definition R_CompleteSpace_mixin :=
  CompleteSpace.Mixin _ R_complete_lim R_complete R_complete_close.

Canonical R_CompleteSpace :=
  CompleteSpace.Pack R (CompleteSpace.Class _ _ R_CompleteSpace_mixin) R.

Definition R_ModuleSpace_mixin :=
  AbsRing_ModuleSpace_mixin R_AbsRing.

Canonical R_ModuleSpace :=
  ModuleSpace.Pack _ R (ModuleSpace.Class _ _ _ R_ModuleSpace_mixin) R.

Canonical R_NormedModuleAux :=
  NormedModuleAux.Pack _ R (NormedModuleAux.Class _ _ (ModuleSpace.class _ R_ModuleSpace) (UniformSpace.class R_UniformSpace)) R.

Definition R_NormedModule_mixin :=
  AbsRing_NormedModule_mixin R_AbsRing.

Canonical R_NormedModule :=
  NormedModule.Pack _ R (NormedModule.Class _ _ _ R_NormedModule_mixin) R.

Canonical R_CompleteNormedModule :=
  CompleteNormedModule.Pack _ R (CompleteNormedModule.Class R_AbsRing _ (NormedModule.class _ R_NormedModule) R_CompleteSpace_mixin) R.

Definition at_left x := within (fun u : R => Rlt u x) (locally x).
Definition at_right x := within (fun u : R => Rlt x u) (locally x).

Global Instance at_right_proper_filter : forall (x : R),
  ProperFilter (at_right x).
Global Instance at_left_proper_filter : forall (x : R),
  ProperFilter (at_left x).

Lemma sum_n_Reals : forall a N, sum_n a N = sum_f_R0 a N.
Lemma sum_n_m_Reals a n m : (n <= m)%nat -> sum_n_m a n m = sum_f n m a.

Lemma sum_n_m_const (n m : nat) (a : R) :
  sum_n_m (fun _ => a) n m = INR (S m - n) * a.
Lemma sum_n_const (n : nat) (a : R) :
  sum_n (fun _ => a) n = INR (S n) * a.

Lemma norm_sum_n_m {K : AbsRing} {V : NormedModule K} (a : nat -> V) (n m : nat) :
  norm (sum_n_m a n m) <= sum_n_m (fun n => norm (a n)) n m.

Lemma sum_n_m_le (a b : nat -> R) (n m : nat) :
  (forall k, a k <= b k)
  -> sum_n_m a n m <= sum_n_m b n m.

Lemma pow_n_pow :
  forall (x : R) k, pow_n x k = x^k.

Lemma filterlim_norm {K : AbsRing} {V : NormedModule K} :
  forall (x : V), filterlim norm (locally x) (locally (norm x)).

Lemma filterlim_norm_zero {U} {K : AbsRing} {V : NormedModule K}
  {F : (U -> Prop) -> Prop} {FF : Filter F} (f : U -> V) :
  filterlim (fun x => norm (f x)) F (locally 0)
  -> filterlim f F (locally (zero (G := V))).

Lemma filterlim_bounded {K : AbsRing} {V : NormedModule K} (a : nat -> V) :
  (exists x, filterlim a eventually (locally x))
 -> {M : R | forall n, norm (a n) <= M}.

Lemma open_lt :
  forall y : R, open (fun u : R => u < y).

Lemma open_gt :
  forall y : R, open (fun u : R => y < u).

Lemma open_neq :
  forall y : R, open (fun u : R => u <> y).

Lemma closed_le :
  forall y : R, closed (fun u : R => u <= y).

Lemma closed_ge :
  forall y : R, closed (fun u : R => y <= u).

Lemma closed_eq :
  forall y : R, closed (fun u : R => u = y).

Lemma locally_interval (P : R -> Prop) (x : R) (a b : Rbar) :
  Rbar_lt a x -> Rbar_lt x b ->
  (forall (y : R), Rbar_lt a y -> Rbar_lt y b -> P y) ->
  locally x P.

Definition locally_2d (P : R -> R -> Prop) x y :=
  exists delta : posreal, forall u v, Rabs (u - x) < delta -> Rabs (v - y) < delta -> P u v.

Lemma locally_2d_locally :
  forall P x y,
  locally_2d P x y <-> locally (x,y) (fun z => P (fst z) (snd z)).

Lemma locally_2d_impl_strong :
  forall (P Q : R -> R -> Prop) x y, locally_2d (fun u v => locally_2d P u v -> Q u v) x y ->
  locally_2d P x y -> locally_2d Q x y.

Lemma locally_2d_singleton :
  forall (P : R -> R -> Prop) x y, locally_2d P x y -> P x y.

Lemma locally_2d_impl :
  forall (P Q : R -> R -> Prop) x y, locally_2d (fun u v => P u v -> Q u v) x y ->
  locally_2d P x y -> locally_2d Q x y.

Lemma locally_2d_forall :
  forall (P : R -> R -> Prop) x y, (forall u v, P u v) -> locally_2d P x y.

Lemma locally_2d_and :
  forall (P Q : R -> R -> Prop) x y, locally_2d P x y -> locally_2d Q x y ->
  locally_2d (fun u v => P u v /\ Q u v) x y.

Lemma locally_2d_align :
  forall (P Q : R -> R -> Prop) x y,
  ( forall eps : posreal, (forall u v, Rabs (u - x) < eps -> Rabs (v - y) < eps -> P u v) ->
    forall u v, Rabs (u - x) < eps -> Rabs (v - y) < eps -> Q u v ) ->
  locally_2d P x y -> locally_2d Q x y.

Lemma locally_2d_1d_const_x :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally y (fun t => P x t).

Lemma locally_2d_1d_const_y :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally x (fun t => P t y).

Lemma locally_2d_1d_strong :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally_2d (fun u v => forall t, 0 <= t <= 1 ->
    locally t (fun z => locally_2d P (x + z * (u - x)) (y + z * (v - y)))) x y.

Lemma locally_2d_1d :
  forall (P : R -> R -> Prop) x y,
  locally_2d P x y ->
  locally_2d (fun u v => forall t, 0 <= t <= 1 -> locally_2d P (x + t * (u - x)) (y + t * (v - y))) x y.

Lemma locally_2d_ex_dec :
  forall P x y,
  (forall x y, P x y \/ ~P x y) ->
  locally_2d P x y ->
  {d : posreal | forall u v, Rabs (u-x) < d -> Rabs (v-y) < d -> P u v}.

Definition Rbar_locally' (a : Rbar) (P : R -> Prop) :=
  match a with
    | Finite a => locally' a P
    | p_infty => exists M : R, forall x, M < x -> P x
    | m_infty => exists M : R, forall x, x < M -> P x
  end.
Definition Rbar_locally (a : Rbar) (P : R -> Prop) :=
  match a with
    | Finite a => locally a P
    | p_infty => exists M : R, forall x, M < x -> P x
    | m_infty => exists M : R, forall x, x < M -> P x
  end.

Global Instance Rbar_locally'_filter :
  forall x, ProperFilter (Rbar_locally' x).

Global Instance Rbar_locally_filter :
  forall x, ProperFilter (Rbar_locally x).

Lemma open_Rbar_lt :
  forall y, open (fun u : R => Rbar_lt u y).

Lemma open_Rbar_gt :
  forall y, open (fun u : R => Rbar_lt y u).

Lemma open_Rbar_lt' :
  forall x y, Rbar_lt x y -> Rbar_locally x (fun u => Rbar_lt u y).

Lemma open_Rbar_gt' :
  forall x y, Rbar_lt y x -> Rbar_locally x (fun u => Rbar_lt y u).

Lemma Rbar_locally'_le :
  forall x, filter_le (Rbar_locally' x) (Rbar_locally x).

Lemma Rbar_locally'_le_finite :
  forall x : R, filter_le (Rbar_locally' x) (locally x).

Definition Rbar_loc_seq (x : Rbar) (n : nat) := match x with
    | Finite x => x + / (INR n + 1)
    | p_infty => INR n
    | m_infty => - INR n
  end.

Lemma filterlim_Rbar_loc_seq :
  forall x, filterlim (Rbar_loc_seq x) eventually (Rbar_locally' x).

Lemma continuity_pt_locally :
  forall f x,
  continuity_pt f x <->
  forall eps : posreal, locally x (fun u => Rabs (f u - f x) < eps).

Lemma continuity_pt_locally' :
  forall f x,
  continuity_pt f x <->
  forall eps : posreal, locally' x (fun u => Rabs (f u - f x) < eps).

Lemma continuity_pt_filterlim :
  forall (f : R -> R) (x : R),
  continuity_pt f x <->
  filterlim f (locally x) (locally (f x)).

Lemma continuity_pt_filterlim' :
  forall f x,
  continuity_pt f x <->
  filterlim f (locally' x) (locally (f x)).

Lemma locally_pt_comp (P : R -> Prop) (f : R -> R) (x : R) :
  locally (f x) P -> continuity_pt f x ->
  locally x (fun x => P (f x)). *)



Open Scope R_scope.



Fixpoint seq2Rlist (s : seq R) :=

  match s with

    | [::] => RList.nil

    | h::t => RList.cons h (seq2Rlist t)

  end.

Fixpoint Rlist2seq (s : Rlist) : seq R :=

  match s with

    | RList.nil => [::]

    | RList.cons h t => h::(Rlist2seq t)

  end.



Lemma seq2Rlist_bij (s : Rlist) :

  seq2Rlist (Rlist2seq s) = s.

Proof.

  by elim: s => //= h s ->.

Qed.

Lemma Rlist2seq_bij (s : seq R) :

  Rlist2seq (seq2Rlist s) = s.

Proof.

  by elim: s => //= h s ->.

Qed.



Lemma size_compat (s : seq R) :

  Rlength (seq2Rlist s) = size s.

Proof.

  elim: s => // t s IHs /= ; by rewrite IHs.

Qed.



Lemma nth_compat (s : seq R) (n : nat) :

  pos_Rl (seq2Rlist s) n = nth 0 s n.

Proof.

  elim: s n => [n|t s IHs n] /= ;

  case: n => //=.

Qed.



Lemma rev_rev {T} (l : seq T) : rev (rev l) = l.

Proof.

  elim: l => /= [ | h l IH].

  by [].

  by rewrite rev_cons rev_rcons IH.

Qed.

Lemma head_rev {T} (x0 : T) (l : seq T) :

  head x0 (rev l) = last x0 l.

Proof.

  elim: l x0 => /= [ | x1 l IH] x0.

  by [].

  by rewrite rev_cons head_rcons.

Qed.

Lemma last_rev {T} (x0 : T) (l : seq T) :

  last x0 (rev l) = head x0 l.

Proof.

  by rewrite -head_rev rev_rev.

Qed.



Lemma last_unzip1 {S T} x0 y0 (s : seq (S * T)) :

  last x0 (unzip1 s) = fst (last (x0,y0) s).

Proof.

  case: s => [ | h s] //= .

  elim: s h => [ | h0 s IH] h //=.

Qed.



Fixpoint sorted {T : Type} (Ord : T -> T -> Prop) (s : seq T) :=

  match s with

    | [::] | [:: _] => True

    | h0 :: (h1 :: t1) as t0 => Ord h0 h1 /\ sorted Ord t0

  end.

Lemma sorted_nth {T : Type} (Ord : T -> T -> Prop) (s : seq T) :

  sorted Ord s <-> (forall i : nat,

    (i < Peano.pred (size s))%nat -> forall x0 : T, Ord (nth x0 s i) (nth x0 s (S i))).

Proof.

  case: s.

  split => // _ i Hi ; contradict Hi ; apply lt_n_O.

  move => t s ; elim: s t => [ t | t s IHs t0] ; split => // H.

  move => i Hi ; contradict Hi ; apply lt_n_O.

  case => [| i] Hi x0 ; simpl in Hi.

  apply H.

  case: (IHs t) => {IHs} IHs _ ;

  apply (IHs (proj2 H) i (lt_S_n _ _ Hi) x0).

  split.

  apply (H O (lt_0_Sn _) t).

  case: (IHs t) => {IHs} _ IHs.

  apply: IHs => i Hi x0 ; apply: (H (S i)) ; simpl ; apply lt_n_S, Hi.

Qed.

Lemma sorted_cat  {T : Type} (Ord : T -> T -> Prop) (s1 s2 : seq T) x0 :

  sorted Ord s1 -> sorted Ord s2 -> Ord (last x0 s1)  (head x0 s2)

  -> sorted Ord (s1 ++ s2).

Proof.

  move/sorted_nth => H1.

  move/sorted_nth => H2 H0.

  apply sorted_nth => i Hi => x1.

  rewrite ?nth_cat.

  rewrite ?SSR_minus.

  case: (le_dec (S i) (size s1)) => Hi0.

  move: (proj2 (SSR_leq _ _) Hi0) ;

  case: (ssrnat.leq (S i) (size s1)) => // _.

  case: (le_dec (S (S i)) (size s1)) => Hi1.

  move: (proj2 (SSR_leq _ _) Hi1) ;

  case: (ssrnat.leq (S (S i)) (size s1)) => // _.

  apply H1 ; intuition.

  have : ~ (ssrnat.leq (S (S i)) (size s1)).

  contradict Hi1 ; by apply SSR_leq.

  case: (ssrnat.leq (S (S i)) (size s1)) => // _.

  suff Hi' : i = Peano.pred (size s1).

  rewrite Hi' nth_last.

  replace (S (Peano.pred (size s1)) - size s1)%nat with O.

  rewrite nth0.

  apply not_le in Hi1.

  case: (s1) H0 Hi Hi' Hi0 Hi1 => [ | x2 s1'] //= H0 Hi Hi' Hi0 Hi1.

  by apply le_Sn_O in Hi0.

  case: (s2) H0 Hi0 Hi => [ | x3 s2'] //= H0 Hi0 Hi.

  rewrite cats0 /= in Hi.

  rewrite Hi' in Hi.

  by apply lt_irrefl in Hi.

  case: (s1) Hi0 => //= [ | x2 s0] Hi0.

  by apply le_Sn_O in Hi0.

  by rewrite minus_diag.

  apply sym_eq, le_antisym.

  apply MyNat.le_pred_le_succ.

  apply not_le in Hi1.

  by apply lt_n_Sm_le.

  replace i with (Peano.pred (S i)) by auto.

  by apply le_pred.

  have : ~ (ssrnat.leq (S i) (size s1)).

  contradict Hi0 ; by apply SSR_leq.

  case: (ssrnat.leq (S i) (size s1)) => // _.

  have : ~ssrnat.leq (S (S i)) (size s1).

  contradict Hi0.

  apply SSR_leq in Hi0.

  intuition.

  case: (ssrnat.leq (S (S i)) (size s1)) => // _.

  replace (S i - size s1)%nat with (S (i - size s1)).

  apply H2.

  rewrite size_cat in Hi.

  apply not_le in Hi0.

  elim: (size s1) i Hi Hi0 => [ | n IH] /= i Hi Hi0.

  rewrite -minus_n_O.

  unfold ssrnat.addn, ssrnat.addn_rec in Hi.

  by rewrite plus_0_l in Hi.

  case: i Hi Hi0 => [ | i] /= Hi Hi0.

  by apply lt_S_n, lt_n_O in Hi0.

  apply IH ; by intuition.

  apply not_le in Hi0.

  rewrite minus_Sn_m ; by intuition.

Qed.



Lemma sorted_head (s : seq R) i :

  sorted Rle s -> (i < size s)%nat -> forall x0, head x0 s <= nth x0 s i.

Proof.

  case: s => [| h s].

   move => _ Hi ; by apply lt_n_O in Hi.

  elim: s h i => [| h0 s IH] h i Hs Hi x0.

    apply lt_n_Sm_le, le_n_O_eq in Hi ; rewrite -Hi ; apply Rle_refl.

  case: i Hi => [| i] Hi.

  apply Rle_refl.

  apply Rle_trans with (r2 := head x0 (h0::s)).

  apply Hs.

  apply IH.

  apply Hs.

  apply lt_S_n, Hi.

Qed.



Lemma sorted_incr (s : seq R) i j : sorted Rle s -> (i <= j)%nat -> (j < size s)%nat

  -> forall x0, nth x0 s i <= nth x0 s j.

Proof.

  elim: i j s => [| i IH] j s Hs Hij Hj x0.

  rewrite nth0 ; by apply sorted_head.

  case: j Hij Hj => [| j] Hij Hj.

  by apply le_Sn_O in Hij.

  case: s Hs Hj => [| h s] Hs Hj.

  by apply lt_n_O in Hj.

  apply (IH j s) with (x0 := x0) => //.

  case: (s) Hs => {s Hj} [| h0 s] Hs ; apply Hs.

  apply le_S_n, Hij.

  apply le_S_n, Hj.

Qed.



Lemma sorted_last (s : seq R) i :

  sorted Rle s -> (i < size s)%nat -> forall x0, nth x0 s i <= last x0 s.

Proof.

  move => Hs Hi x0 ; rewrite -nth_last.

  case: s Hi Hs => [| h s] Hi Hs //.

  by apply lt_n_O in Hi.

  apply sorted_incr => //.

  intuition.

Qed.



Lemma sorted_dec (s : seq R) x0 (x : R) :

  sorted Rle s -> head x0 s <= x <= last x0 s ->

    {i : nat | nth x0 s i <= x < nth x0 s (S i) /\ (S (S i) < size s)%nat}

    + {nth x0 s (size s - 2)%nat <= x <= nth x0 s (size s - 1)%nat}.

Proof.

  case: s => [/= _ Hx| h s] ; simpl minus ; rewrite -?minus_n_O.

    by right.

  case: s => [/= _ Hx| h0 s] ; simpl minus ; rewrite -?minus_n_O.

    by right.

  elim: s h h0 => [/= | h1 s IH] h h0 Hs Hx.

    by right.

  case: (Rlt_le_dec x h0) => Hx'.

    left ; exists O => /= ; intuition.

  case: (IH h0 h1) => [ | |[i Hi]|Hi].

  apply Hs.

  split ; [apply Hx'|apply Hx].

  left ; exists (S i) => /= ; intuition.

  right => /= ; simpl in Hi.

  by rewrite -minus_n_O in Hi.

Qed.



Lemma sorted_compat (s : seq R) :

  sorted Rle s <-> ordered_Rlist (seq2Rlist s).

Proof.

  case: s => [| h s].



  split => // H i /= Hi ; contradict Hi ; apply lt_n_O.

  elim: s h => [h | h s IHs h'].



  split => // H i /= Hi ; contradict Hi ; apply lt_n_O.



  split => H.

  case => [ /= | i] ; rewrite size_compat => Hi ; simpl in Hi.

  apply H.

  apply (proj1 (IHs h) (proj2 H) i) ; rewrite size_compat /= ; apply lt_S_n => //.

  split.

  apply (H O) ; rewrite size_compat /= ; apply lt_O_Sn.

  apply IHs => i ; rewrite size_compat /= => Hi ; apply (H (S i)) ;

  rewrite size_compat /= ; apply lt_n_S, Hi.

Qed.



Definition seq_step (s : seq R) :=

  foldr Rmax 0 (pairmap (fun x y => Rabs (Rminus y x)) (head 0 s) (behead s)).



Lemma seq_step_ge_0 x : (0 <= seq_step x).

Proof.

  clear ; unfold seq_step ; case: x => [ | x0 x] //= .

  by apply Rle_refl.

  elim: x x0 => [ | x1 x IH] //= x0.

  by apply Rle_refl.

  apply Rmax_case.

  by apply Rabs_pos.

  by [].

Qed.

Lemma seq_step_cat (x y : seq R) :

  (0 < size x)%nat -> (0 < size y)%nat ->

  last 0 x = head 0 y ->

  seq_step (cat x (behead y)) = Rmax (seq_step x) (seq_step y).

Proof.

  case: x => /= [ H | x0 x _].

  by apply lt_irrefl in H.

  case: y => /= [ H | y0 y _].

  by apply lt_irrefl in H.

  move => <-.

  elim: x y x0 {y0} => /= [ | x1 x IH] y x0.

  rewrite {2}/seq_step /=.

  rewrite /Rmax ; case: Rle_dec (seq_step_ge_0 (x0 :: y)) => // _ _.

  unfold seq_step ; simpl.

  rewrite -Rmax_assoc.

  apply f_equal.

  by apply IH.

Qed.



Lemma seq_step_rev (l : seq R) : seq_step (rev l) = seq_step l.

Proof.

  rewrite /seq_step.

  rewrite head_rev behead_rev /=.

  case: l => [ | x0 l] //=.

  case: l => [ | x1 l] //=.

  rewrite rev_cons.

  case: l => [ | x2 l] //=.

  by rewrite -Rabs_Ropp Ropp_minus_distr'.

  rewrite rev_cons pairmap_rcons foldr_rcons.

  rewrite -Rabs_Ropp Ropp_minus_distr'.

  generalize (Rabs (x1 - x0)) ; clear.

  elim: l x1 x2 => [ | x2 l IH] x0 x1 r //=.

  rewrite -Rabs_Ropp Ropp_minus_distr' !Rmax_assoc.

  apply f_equal2 => //.

  by apply Rmax_comm.

  rewrite rev_cons pairmap_rcons foldr_rcons.

  rewrite -Rabs_Ropp Ropp_minus_distr' Rmax_assoc IH.

  by rewrite (Rmax_comm _ r) !Rmax_assoc.

Qed.



Lemma nth_le_seq_step x0 (l : seq R) (i : nat) : (S i < size l)%nat ->

  Rabs (nth x0 l (S i) - nth x0 l i) <= seq_step l.

Proof.

  elim: i l => [ | i IH] ; case => [ | x1 l] /= Hi.

  by apply lt_n_O in Hi.

  apply lt_S_n in Hi.

  destruct l as [ | x2 l].

  by apply lt_n_O in Hi.

  by apply Rmax_l.

  by apply lt_n_O in Hi.

  apply lt_S_n in Hi.

  move: (IH l Hi).

  destruct l as [ | x2 l] ; simpl.

  by apply lt_n_O in Hi.

  simpl in Hi ; apply lt_S_n in Hi.

  move => {IH} IH.

  eapply Rle_trans.

  by apply IH.

  by apply Rmax_r.

Qed.



Section SF_seq.

Context {T : Type}.



Record SF_seq := mkSF_seq {SF_h : R ; SF_t : seq (R * T)}.

Definition SF_lx (s : SF_seq) : seq R := (SF_h s)::(unzip1 (SF_t s)).

Definition SF_ly (s : SF_seq) : seq T := unzip2 (SF_t s).

Definition SF_make (lx : seq R) (ly : seq T) (Hs : size lx = S (size ly)) : SF_seq :=

  mkSF_seq (head 0 lx) (zip (behead lx) ly).



Lemma SF_size_lx_ly (s : SF_seq) : size (SF_lx s) = S (size (SF_ly s)).

Proof.

  case: s => sh st ;

  rewrite /SF_lx /SF_ly /= ;

  elim: st => //= t s -> //.

Qed.

Lemma SF_seq_bij (s : SF_seq) :

  SF_make (SF_lx s) (SF_ly s) (SF_size_lx_ly s) = s.

Proof.

  case: s => sh st ; by rewrite /SF_make (zip_unzip st).

Qed.

Lemma SF_seq_bij_lx (lx : seq R) (ly : seq T)

  (Hs : size lx = S (size ly)) : SF_lx (SF_make lx ly Hs) = lx.

Proof.

  case: lx Hs => // x lx Hs ;

  rewrite /SF_make / SF_lx unzip1_zip //= ;

  apply SSR_leq, le_S_n ; rewrite -Hs => //.

Qed.

Lemma SF_seq_bij_ly (lx : seq R) (ly : seq T)

  (Hs : size lx = S (size ly)) : SF_ly (SF_make lx ly Hs) = ly.

Proof.

  case: lx Hs => // x lx Hs ;

  rewrite /SF_make / SF_ly unzip2_zip //= ;

  apply SSR_leq, le_S_n ; rewrite -Hs => //.

Qed.



Definition SF_nil (x0 : R) : SF_seq := mkSF_seq x0 [::].

Definition SF_cons (h : R*T) (s : SF_seq) :=

  mkSF_seq (fst h) ((SF_h s,snd h)::(SF_t s)).

Definition SF_rcons (s : SF_seq) (t : R*T) :=

  mkSF_seq (SF_h s) (rcons (SF_t s) t).



Lemma SF_cons_dec (P : SF_seq -> Type) :

  (forall x0 : R, P (SF_nil x0)) -> (forall h s, P (SF_cons h s))

    -> (forall s, P s).

Proof.

  move => Hnil Hcons [sh st] ; case: st => [| h sf].

  apply Hnil.

  move: (Hcons (sh,snd h) (mkSF_seq (fst h) sf)) => {Hcons} ;

  rewrite /SF_cons -surjective_pairing //=.

Qed.

Lemma SF_cons_ind (P : SF_seq -> Type) :

  (forall x0 : R, P (SF_nil x0)) -> (forall h s, P s -> P (SF_cons h s))

    -> (forall s, P s).

Proof.

  move => Hnil Hcons [sh st] ; elim: st sh => [sh |h sf IHst sh].

  apply Hnil.

  move: (IHst (fst h)) => {IHst} IHst.

  move: (Hcons (sh,snd h) (mkSF_seq (fst h) sf) IHst) => {Hcons} ;

  rewrite /SF_cons -surjective_pairing //=.

Qed.



Lemma SF_rcons_dec (P : SF_seq -> Type) :

  (forall x0 : R, P (SF_nil x0)) -> (forall s t, P (SF_rcons s t))

    -> (forall s, P s).

Proof.

  move => Hnil Hrcons [sh st] ; move: st ; apply rcons_dec => [| st t].

  apply Hnil.

  apply (Hrcons (mkSF_seq sh st) t).

Qed.

Lemma SF_rcons_ind (P : SF_seq -> Type) :

  (forall x0 : R, P (SF_nil x0)) -> (forall s t, P s -> P (SF_rcons s t))

    -> (forall s, P s).

Proof.

  move => Hnil Hrcons [sh st] ; move: st sh ;

  apply (rcons_ind (fun st => forall sh, P {| SF_h := sh; SF_t := st |})) => [sh | st t IHst sh].

  apply Hnil.

  apply (Hrcons (mkSF_seq sh st) t) => //.

Qed.



Lemma SF_cons_rcons (h : R*T) (s : SF_seq) (l : R*T) :

  SF_cons h (SF_rcons s l) = SF_rcons (SF_cons h s) l.

Proof.

  case: h => hx hy ;

  case: l => lx ly ;

  case: s => sh st //.

Qed.



Lemma SF_lx_nil (x0 : R) :

  SF_lx (SF_nil x0) = [:: x0].

Proof.

  by [].

Qed.

Lemma SF_ly_nil (x0 : R) :

  SF_ly (SF_nil x0) = [::].

Proof.

  by [].

Qed.



Lemma SF_lx_cons (h : R*T) (s : SF_seq) :

  SF_lx (SF_cons h s) = (fst h) :: (SF_lx s).

Proof.

  by [].

Qed.

Lemma SF_ly_cons (h : R*T) (s : SF_seq) :

  SF_ly (SF_cons h s) = (snd h) :: (SF_ly s).

Proof.

  by [].

Qed.

Lemma SF_lx_rcons (s : SF_seq) (h : R*T) :

  SF_lx (SF_rcons s h) = rcons (SF_lx s) (fst h).

Proof.

  case: s => sh st ; rewrite /SF_lx /SF_rcons /= ; elim: st sh => // [[x y] st] IHst sh /= ;

  by rewrite (IHst x).

Qed.

Lemma SF_ly_rcons (s : SF_seq) (h : R*T) :

  SF_ly (SF_rcons s h) = rcons (SF_ly s) (snd h).

Proof.

  case: s => sh st ; rewrite /SF_ly /SF_rcons /= ; elim: st sh => // [[x y] st] IHst sh /= ;

  by rewrite (IHst x).

Qed.



Lemma SF_lx_surj (s s0 : SF_seq) :

  s = s0 -> SF_lx s = SF_lx s0.

Proof.

  by move => ->.

Qed.

Lemma SF_ly_surj (s s0 : SF_seq) :

  s = s0 -> SF_ly s = SF_ly s0.

Proof.

  by move => ->.

Qed.

Lemma SF_lx_ly_inj (s s0 : SF_seq) :

  SF_lx s = SF_lx s0 -> SF_ly s = SF_ly s0 -> s = s0.

Proof.

  move: s0 ; apply SF_cons_ind with (s := s) => {s} [x | h s IH] s0 ;

    apply SF_cons_dec with (s := s0) => {s0} [x0 | h0 s0] Hx Hy //.



  rewrite !SF_lx_nil in Hx.

  replace x with (head 0 ([::x])) by intuition ;

  by rewrite Hx.



  rewrite !SF_lx_cons in Hx ; rewrite !SF_ly_cons in Hy.

  replace h with (head (fst h) (fst h :: SF_lx s),head (snd h) (snd h :: SF_ly s)) ;

    [ rewrite Hx Hy (IH s0) //= | move => /= ; by apply injective_projections].

  replace (SF_lx s) with (behead (fst h :: SF_lx s)) by intuition ; by rewrite Hx.

  replace (SF_ly s) with (behead (snd h :: SF_ly s)) by intuition ; by rewrite Hy.

Qed.



Definition SF_size (s : SF_seq) := size (SF_t s).



Lemma SF_size_cons (h : R*T) (s : SF_seq) : SF_size (SF_cons h s) = S (SF_size s).

Proof.

  rewrite /SF_cons /SF_size //=.

Qed.



Lemma SF_size_rcons (s : SF_seq) (t : R*T) : SF_size (SF_rcons s t) = S (SF_size s).

Proof.

  rewrite /SF_rcons /SF_size size_rcons //=.

Qed.



Lemma SF_size_lx (s : SF_seq) : size (SF_lx s) = S (SF_size s).

Proof.

  case: s => sh st ; rewrite /SF_size /= ; elim: st => //= _ st -> //.

Qed.

Lemma SF_size_ly (s : SF_seq) : size (SF_ly s) = SF_size s.

Proof.

  case: s => sh st ; rewrite /SF_size /= ; elim: st => //= _ st -> //.

Qed.



Lemma SF_rev_0 (s : SF_seq) :

  size (rev (SF_lx s)) = S (size (rev (SF_ly s))).

Proof.

  by rewrite ?size_rev SF_size_lx SF_size_ly.

Qed.

Definition SF_rev (s : SF_seq) : SF_seq :=

  SF_make (rev (SF_lx s)) (rev (SF_ly s)) (SF_rev_0 s).



Lemma SF_rev_cons (h : R*T) (s : SF_seq) :

  SF_rev (SF_cons h s) = SF_rcons (SF_rev s) h.

Proof.

  apply SF_lx_ly_inj.

  by rewrite SF_lx_rcons !SF_seq_bij_lx SF_lx_cons rev_cons.

  by rewrite SF_ly_rcons !SF_seq_bij_ly SF_ly_cons rev_cons.

Qed.

Lemma SF_rev_rcons (s : SF_seq) (t : R*T) :

  SF_rev (SF_rcons s t) = SF_cons t (SF_rev s).

Proof.

  apply SF_lx_ly_inj.

  by rewrite SF_lx_cons !SF_seq_bij_lx SF_lx_rcons rev_rcons.

  by rewrite SF_ly_cons !SF_seq_bij_ly SF_ly_rcons rev_rcons.

Qed.



Lemma SF_rev_invol (s : SF_seq) :

  SF_rev (SF_rev s) = s.

Proof.

  apply SF_lx_ly_inj.

  by rewrite /SF_rev ?SF_seq_bij_lx revK.

  by rewrite /SF_rev ?SF_seq_bij_ly revK.

Qed.



Lemma SF_lx_rev (s : SF_seq) : SF_lx (SF_rev s) = rev (SF_lx s).

Proof.

  by rewrite /SF_rev ?SF_seq_bij_lx.

Qed.

Lemma SF_ly_rev (s : SF_seq) : SF_ly (SF_rev s) = rev (SF_ly s).

Proof.

  by rewrite /SF_rev ?SF_seq_bij_ly.

Qed.



Lemma SF_size_rev (s : SF_seq) : SF_size (SF_rev s) = SF_size s.

Proof.

  by rewrite -?SF_size_ly SF_ly_rev size_rev.

Qed.



Lemma SF_rev_surj (s s0 : SF_seq) :

  s = s0 -> SF_rev s = SF_rev s0.

Proof.

  by move => ->.

Qed.

Lemma SF_rev_inj (s s0 : SF_seq) :

  SF_rev s = SF_rev s0 -> s = s0.

Proof.

  move => H ; by rewrite -(SF_rev_invol s) -(SF_rev_invol s0) H.

Qed.



Definition SF_cat (x y : SF_seq) := mkSF_seq (SF_h x) ((SF_t x) ++ (SF_t y)).

Lemma SF_lx_cat (x y : SF_seq) :

  SF_lx (SF_cat x y) = (SF_lx x) ++ (behead (SF_lx y)).

Proof.

  unfold SF_cat, SF_lx ; simpl.

  apply f_equal.

  by elim: (SF_t x) => //= t h ->.

Qed.

Lemma SF_last_cat (x y : SF_seq) :

  last (SF_h x) (SF_lx x) = head (SF_h y) (SF_lx y) ->

  last (SF_h (SF_cat x y)) (SF_lx (SF_cat x y)) = (last (SF_h y) (SF_lx y)).

Proof.

  rewrite SF_lx_cat.

  unfold SF_cat, SF_lx ; simpl => <- /=.

  elim: (SF_t x) (SF_h x) => //= {x} x1 x x0.

Qed.

Lemma SF_cons_cat x0 (x y : SF_seq) :

  SF_cons x0 (SF_cat x y) = SF_cat (SF_cons x0 x) y.

Proof.

  reflexivity.

Qed.



Definition SF_head (y0 : T) (s : SF_seq) := (SF_h s, head y0 (SF_ly s)).

Definition SF_behead (s : SF_seq) :=

  mkSF_seq (head (SF_h s) (unzip1 (SF_t s))) (behead (SF_t s)).



Definition SF_last y0 (s : SF_seq) : (R*T) :=

  last (SF_h s,y0) (SF_t s).

Definition SF_belast (s : SF_seq) : SF_seq :=

  mkSF_seq (SF_h s) (Rcomplements.belast (SF_t s)).



Lemma SF_last_lx x0 (s : SF_seq) :

  fst (SF_last x0 s) = last 0 (SF_lx s).

Proof.

  rewrite /SF_last /=.

  apply sym_eq ; by apply last_unzip1.

Qed.



Definition SF_sorted (Ord : R -> R -> Prop) (s : SF_seq) :=

  sorted Ord (SF_lx s).



End SF_seq.



Section SF_map.



Context {T T0 : Type}.



Definition SF_map  (f : T -> T0) (s : SF_seq) : SF_seq :=

  mkSF_seq (SF_h s) (map (fun x => (fst x,f (snd x))) (SF_t s)).



Lemma SF_map_cons (f : T -> T0) (h : R*T) (s : SF_seq) :

  SF_map f (SF_cons h s) = SF_cons (fst h, f (snd h)) (SF_map f s).

Proof.

  case: s => sh ; elim => // h st ; rewrite /SF_map => //.

Qed.



Lemma SF_map_rcons (f : T -> T0) (s : SF_seq) (h : R*T) :

  SF_map f (SF_rcons s h) = SF_rcons (SF_map f s) (fst h, f (snd h)).

Proof.

  move: h ; apply SF_cons_ind with (s := s) => {s} [x0 | h0 s IH] //= h.

  rewrite SF_map_cons.

  replace (SF_rcons (SF_cons h0 s) h) with

    (SF_cons h0 (SF_rcons s h)) by auto.

  rewrite SF_map_cons.

  rewrite IH.

  auto.

Qed.



Lemma SF_map_lx (f : T -> T0) (s : SF_seq) :

  SF_lx (SF_map f s) = SF_lx s.

Proof.

  apply SF_cons_ind with (s := s) => {s} //= h s IH ;

  by rewrite SF_map_cons ?SF_lx_cons IH.

Qed.



Lemma SF_map_ly (f : T -> T0) (s : SF_seq) :

  SF_ly (SF_map f s) = map f (SF_ly s).

Proof.

  apply SF_cons_ind with (s := s) => {s} //= h s IH ;

  by rewrite SF_map_cons ?SF_ly_cons IH.

Qed.



Lemma SF_map_rev (f : T -> T0) s :

  SF_rev (SF_map f s) = SF_map f (SF_rev s).

Proof.

  apply SF_lx_ly_inj.

  by rewrite SF_lx_rev ?SF_map_lx ?SF_lx_rev.

  by rewrite SF_ly_rev ?SF_map_ly ?SF_ly_rev map_rev.

Qed.



Lemma SF_map_sort (f : T -> T0) (s : SF_seq) (Ord : R -> R -> Prop) :

  SF_sorted Ord s -> SF_sorted Ord (SF_map f s).

Proof.

  unfold SF_sorted ;

  apply SF_cons_ind with (s := s) => {s} /= [x0 | [x0 _] /= s IH] Hs.

  by [].

  split.

  by apply Hs.

  now apply IH.

Qed.



Lemma SF_size_map (f : T -> T0) s :

  SF_size (SF_map f s) = SF_size s.

Proof.

  by rewrite -!SF_size_ly SF_map_ly size_map.

Qed.



End SF_map.



Definition pointed_subdiv (ptd : @SF_seq R) :=

  forall i : nat, (i < SF_size ptd)%nat ->

    nth 0 (SF_lx ptd) i <= nth 0 (SF_ly ptd) i <= nth 0 (SF_lx ptd) (S i).



Lemma ptd_cons h s : pointed_subdiv (SF_cons h s) -> pointed_subdiv s.

Proof.

  move => H i Hi ; apply (H (S i)) ; rewrite SF_size_cons ; intuition.

Qed.

Lemma ptd_sort ptd :

  pointed_subdiv ptd -> SF_sorted Rle ptd.

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} [x0 | [x0 y0] ptd] ;

  [ | apply SF_cons_dec with (s := ptd) => {ptd} [ x1 | [x1 y1] ptd] IH] =>

  Hptd ; try split => //=.

  apply Rle_trans with y0 ; apply (Hptd O) ; rewrite SF_size_cons ; apply lt_O_Sn.

  apply Rle_trans with y0 ; apply (Hptd O) ; rewrite SF_size_cons ; apply lt_O_Sn.

  apply IH, (ptd_cons (x0,y0)) => //.

Qed.

Lemma ptd_sort' ptd :

  pointed_subdiv ptd -> sorted Rle (SF_ly ptd).

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} [x0 | [x0 y0] ptd] ;

  [ | apply SF_cons_dec with (s := ptd) => {ptd} [ x1 | [x1 y1] ptd] IH] =>

  Hptd ; try split.

  apply Rle_trans with x1 ; [apply (Hptd O) | apply (Hptd 1%nat)] ;

  rewrite ?SF_size_cons ; repeat apply lt_n_S ; apply lt_O_Sn.

  apply IH, (ptd_cons (x0,y0)) => //.

Qed.



Lemma SF_cat_pointed (x y : SF_seq) :

  last (SF_h x) (SF_lx x) = head (SF_h y) (SF_lx y) ->

  pointed_subdiv x -> pointed_subdiv y

  -> pointed_subdiv (SF_cat x y).

Proof.

  intros Hxy Hx Hy.

  move: Hxy Hx.

  apply (SF_cons_ind (fun x => last (SF_h x) (SF_lx x) = head (SF_h y) (SF_lx y) -> pointed_subdiv x -> pointed_subdiv (SF_cat x y)))

    => {x} /= [x0 | x0 x IH] Hxy Hx.

  rewrite Hxy.

  by apply Hy.

  rewrite -SF_cons_cat.

  case => [ | i] Hi.

  apply (Hx O), lt_O_Sn.

  apply IH =>//.

  by apply ptd_cons with x0.

  by apply lt_S_n, Hi.

Qed.



Fixpoint seq_cut_down (s : seq (R*R)) (x : R) : seq (R*R) :=

  match s with

    | [::] => [:: (x,x)]

    | h :: t =>

        match Rle_dec (fst h) x with

          | right _ => [:: (x,Rmin (snd h) x)]

          | left _ => h :: (seq_cut_down t x)

        end

  end.

Fixpoint seq_cut_up (s : seq (R*R)) (x : R) : seq (R*R) :=

  match s with

    | [::] => [:: (x,x)]

    | h :: t =>

        match Rle_dec (fst h) x with

          | right _ => (x,x)::(fst h,Rmax (snd h) x)::t

          | left _ => seq_cut_up t x

        end

  end.



Definition SF_cut_down (sf : @SF_seq R) (x : R) :=

  let s := seq_cut_down ((SF_h sf,SF_h sf) :: (SF_t sf)) x in

  mkSF_seq (fst (head (SF_h sf,SF_h sf) s)) (behead s).

Definition SF_cut_up (sf : @SF_seq R) (x : R) :=

  let s := seq_cut_up ((SF_h sf,SF_h sf) :: (SF_t sf)) x in

  mkSF_seq (fst (head (SF_h sf,SF_h sf) s)) (behead s).



Lemma SF_cut_down_step s x eps :

  SF_h s <= x <= last (SF_h s) (SF_lx s) ->

  seq_step (SF_lx s) < eps

    -> seq_step (SF_lx (SF_cut_down s x)) < eps.

Proof.

  unfold SF_cut_down, seq_step ; simpl.

  case => Hh Hl.

  case: Rle_dec => //= _.

  move: Hh Hl ;

  apply SF_cons_ind with (s := s) => {s} [ x1 | [x1 y0] s IH ] /= Hx Hh Hl.

  rewrite (Rle_antisym _ _ Hx Hh) Rminus_eq_0 Rabs_R0.

  rewrite /Rmax ; by case: Rle_dec.

  case: Rle_dec => //= Hx'.

  apply Rmax_case.

  apply Rle_lt_trans with (2 := Hl) ; by apply Rmax_l.

  apply IH ; try assumption.

  apply Rle_lt_trans with (2 := Hl) ; by apply Rmax_r.

  apply Rle_lt_trans with (2 := Hl).

  apply Rmax_case ;

  apply Rle_trans with (2 := Rmax_l _ _).

  rewrite ?Rabs_pos_eq.

  apply Rplus_le_compat_r.

  by apply Rlt_le, Rnot_le_lt.

  rewrite -Rminus_le_0.

  apply Rle_trans with x.

  by [].

  by apply Rlt_le, Rnot_le_lt.

  by rewrite -Rminus_le_0.

  by apply Rabs_pos.

Qed.

Lemma SF_cut_up_step s x eps :

  SF_h s <= x <= last (SF_h s) (SF_lx s) ->

  seq_step (SF_lx s) < eps

    -> seq_step (SF_lx (SF_cut_up s x)) < eps.

Proof.

  unfold SF_cut_down, seq_step ; simpl.

  case => Hh Hl.

  case: Rle_dec => //= _.

  move: {4 5}(SF_h s) Hh Hl ;

  apply SF_cons_ind with (s := s) => {s} [ x1 | [x1 y0] s IH ] /= x0 Hh Hl He.

  by apply He.

  case: Rle_dec => //= Hx.

  apply (IH x0) => //=.

  apply Rle_lt_trans with (2 := He).

  by apply Rmax_r.

  apply Rle_lt_trans with (2 := He).

  apply Rnot_le_lt in Hx.

  apply Rmax_case.

  apply Rle_trans with (2 := Rmax_l _ _).

  rewrite ?Rabs_pos_eq.

  by apply Rplus_le_compat_l, Ropp_le_contravar.

  rewrite -Rminus_le_0 ; by apply Rlt_le, Rle_lt_trans with x.

  rewrite -Rminus_le_0 ; by apply Rlt_le.

  by apply Rmax_r.

Qed.



Lemma SF_cut_down_pointed s x :

  SF_h s <= x -> pointed_subdiv s

  -> pointed_subdiv (SF_cut_down s x).

Proof.

  unfold SF_cut_down ; simpl.

  case: Rle_dec => //= _.

  apply SF_cons_ind with (s := s) => {s} [x0 | [x1 y1] s IH] /= Hx0 H.

  move => i /= Hi.

  unfold SF_size in Hi ; simpl in Hi.

  apply lt_n_Sm_le, le_n_O_eq in Hi.

  rewrite -Hi ; simpl ; split.

  by [].

  by apply Rle_refl.

  case: Rle_dec => //= Hx1.

  move: (H O (lt_O_Sn _)) => /= H0.

  apply ptd_cons in H.

  move: (IH Hx1 H) => {IH} IH.

  rewrite /pointed_subdiv => i.

  destruct i => /= Hi.

  by apply H0.

  apply (IH i).

  apply lt_S_n, Hi.

  move => i /= Hi.

  unfold SF_size in Hi ; simpl in Hi.

  apply lt_n_Sm_le, le_n_O_eq in Hi.

  rewrite -Hi ; simpl ; split.

  apply Rmin_case.

  apply (H O).

  by apply lt_O_Sn.

  by [].

  by apply Rmin_r.

Qed.



Lemma SF_cut_up_pointed s x :

  SF_h s <= x ->

  pointed_subdiv s

  -> pointed_subdiv (SF_cut_up s x).

Proof.

  unfold SF_cut_up ; simpl.

  case: Rle_dec => //= _.

  move: {2 3}(SF_h s) ;

  apply SF_cons_ind with (s := s) => {s} [ x1 | [x1 y0] s IH] /= x0 Hx0 H i Hi.

  by apply lt_n_O in Hi.

  destruct (Rle_dec (SF_h s) x) as [Hx1|Hx1].

  apply IH => //=.

  move: H ; by apply ptd_cons.

  destruct i ; simpl.

  split.

  by apply Rmax_r.

  apply Rmax_case.

  by apply (H O), lt_O_Sn.

  by apply Rlt_le, Rnot_le_lt.

  apply (H (S i)), Hi.

Qed.

Lemma SF_cut_down_h s x :

  SF_h s <= x -> SF_h (SF_cut_down s x) = SF_h s.

Proof.

  unfold SF_cut_down ; simpl.

  by case: Rle_dec.

Qed.

Lemma SF_cut_up_h s x :

  SF_h (SF_cut_up s x) = x.

Proof.

  unfold SF_cut_up ; simpl.

  case: Rle_dec => //= ; simpl.

  move: {2 3}(SF_h s) ;

  apply SF_cons_ind with (s := s) => {s} [x1 | [x1 y1] s IH ] /= x0 Hx.

  by [].

  case: Rle_dec => //= Hx'.

  by apply IH.

Qed.

Lemma SF_cut_down_l s x :

  last (SF_h (SF_cut_down s x)) (SF_lx (SF_cut_down s x)) = x.

Proof.

  unfold SF_cut_down ; simpl.

  case: Rle_dec => //= ; simpl.

  apply SF_cons_ind with (s := s) => {s} [x1 | [x1 y1] s IH ] /= Hx.

  by [].

  case: Rle_dec => //= Hx'.

Qed.

Lemma SF_cut_up_l s x :

  x <= last (SF_h s) (SF_lx s) ->

  last (SF_h (SF_cut_up s x)) (SF_lx (SF_cut_up s x)) = last (SF_h s) (SF_lx s).

Proof.

  unfold SF_cut_down ; simpl.

  case: Rle_dec => //=.

  move: {3 4}(SF_h s);

  apply SF_cons_ind with (s := s) => {s} [x1 | [x1 y1] s IH ] /= x0 Hx Hx'.

  by apply Rle_antisym.

  case: Rle_dec => //= {Hx} Hx.

  by apply IH.

Qed.



Lemma SF_cut_down_cons_0 h ptd x :

  x < fst h -> SF_cut_down (SF_cons h ptd) x = SF_nil x.

Proof.

  intros H0.

  apply Rlt_not_le in H0.

  rewrite /SF_cut_down /=.

  by case: Rle_dec.

Qed.

Lemma SF_cut_up_cons_0 h ptd x :

  x < fst h -> SF_cut_up (SF_cons h ptd) x = SF_cons (x,Rmax (fst h) x) (SF_cons h ptd).

Proof.

  intros H0.

  apply Rlt_not_le in H0.

  rewrite /SF_cut_up /=.

  by case: Rle_dec.

Qed.

Lemma SF_cut_down_cons_1 h ptd x :

  fst h <= x < SF_h ptd -> SF_cut_down (SF_cons h ptd) x = SF_cons (fst h, Rmin (snd h) x) (SF_nil x).

Proof.

  intros [H0 Hx0].

  apply Rlt_not_le in Hx0.

  rewrite /SF_cut_down /=.

  case: Rle_dec => //= _.

  by case: Rle_dec.

Qed.

Lemma SF_cut_up_cons_1 h ptd x :

  fst h <= x < SF_h ptd -> SF_cut_up (SF_cons h ptd) x = SF_cons (x,Rmax (snd h) x) ptd.

Proof.

  intros [H0 Hx0].

  apply Rlt_not_le in Hx0.

  rewrite /SF_cut_up /=.

  case: Rle_dec => //= _.

  by case: Rle_dec.

Qed.

Lemma SF_cut_down_cons_2 h ptd x :

  fst h <= SF_h ptd <= x -> SF_cut_down (SF_cons h ptd) x = SF_cons h (SF_cut_down ptd x).

Proof.

  intros [H0 Hx0].

  rewrite /SF_cut_down /=.

  case: Rle_dec (Rle_trans _ _ _ H0 Hx0) => //= _ _.

  by case: Rle_dec.

Qed.

Lemma SF_cut_up_cons_2 h ptd x :

  fst h <= SF_h ptd <= x -> SF_cut_up (SF_cons h ptd) x = SF_cut_up ptd x.

Proof.

  intros [H0 Hx0].

  rewrite /SF_cut_up /=.

  case: Rle_dec (Rle_trans _ _ _ H0 Hx0) => //= _ _.

  case: Rle_dec => //= _.

  move: {2 3}(SF_h ptd) Hx0 ;

  apply SF_cons_ind with (s := ptd) => {ptd H0} [ x0 | [x0 y0] ptd IH ] //= x0' Hx0.

  case: Rle_dec => //= Hx1.

  by apply IH.

Qed.



Section SF_fun.



Context {T : Type}.



Fixpoint SF_fun_aux (h : R*T) (s : seq (R*T)) (y0 : T) (x : R) :=

  match s with

    | [::] => match Rle_dec x (fst h) with

        | left _ => snd h

        | right _ => y0

      end

    | h0 :: s0 => match Rlt_dec x (fst h) with

        | left _ => snd h

        | right _ => SF_fun_aux h0 s0 y0 x

      end

  end.

Definition SF_fun (s : SF_seq) (y0 : T) (x : R) :=

  SF_fun_aux (SF_h s,y0) (SF_t s) y0 x.



Lemma SF_fun_incr (s : SF_seq) (y0 : T) (x : R) Hs Hx :

  SF_fun s y0 x =

  match (sorted_dec (SF_lx s) 0 x Hs Hx) with

    | inleft H => nth y0 (SF_ly s) (proj1_sig H)

    | inright _ =>  nth y0 (SF_ly s) (SF_size s -1)%nat

  end.

Proof.

  rewrite /SF_fun /=.



  move: Hs Hx ; apply SF_cons_dec with (s := s) => {s} [/= x1 | h s] Hs /= Hx.

    case: sorted_dec => /= [[i Hi]|Hi] ; rewrite /SF_ly ; case: Rle_dec => //= ;

    case: i Hi => //.



  case: Rlt_dec => [Hx' | _].

  contradict Hx' ; apply Rle_not_lt, Hx.

  move: h Hs Hx ; apply SF_cons_ind with (s := s) => {s} [x1 | h0 s IH] h Hs /= Hx.

    case: sorted_dec => [/= [i [Hi' Hi]] /= |Hi].

    by apply lt_S_n, lt_S_n, lt_n_O in Hi.

  case: Hx => Hx Hx' ; apply Rle_not_lt in Hx ; case: Rle_dec => //.



  case: Rlt_dec => Hx'.

  case: sorted_dec => /= [[i Hi]|Hi]/=.

  case: i Hi => //= i Hi ; contradict Hx' ;

  apply Rle_not_lt, Rle_trans with (2 := proj1 (proj1 Hi)).

  simpl in Hs ; elim: (unzip1 (SF_t s)) (fst h0) (SF_h s) (i) (proj2 Hs) (proj2 Hi)

    => {s IH Hs Hx Hi h h0} [| h1 s IH] h h0 n Hs Hn.

    repeat apply lt_S_n in Hn ; by apply lt_n_O in Hn.

    case: n Hn => [| n] Hn.

    apply Rle_refl.

  apply Rle_trans with (1 := proj1 Hs) => //= ; intuition.

  contradict Hx' ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hi).

  simpl in Hs ; elim: (unzip1 (SF_t s)) (fst h0) (SF_h s) (proj2 Hs)

    => {s IH Hs Hx Hi h h0} [| h1 s IH] h h0 Hs.

    apply Rle_refl.

    apply Rle_trans with (1 := proj1 Hs) => //= ; intuition.

  have : fst h0 <= x <= last (SF_h s) (unzip1 (SF_t s)) => [ | {Hx'} Hx'].

    split ; [by apply Rnot_lt_le | by apply Hx].

  rewrite (IH h0 (proj2 Hs) Hx') => {IH} ;

  case: sorted_dec => [[i [Hxi Hi]]|Hi] ; case: sorted_dec => [[j [Hxj Hj]]|Hj] ;

  rewrite -?minus_n_O //=.



  move : h h0 i j Hs {Hx Hx'} Hxi Hi Hxj Hj ; apply SF_cons_ind with (s := s)

    => {s} [x1 | h1 s IH] h h0 i j Hs //= Hxi Hi Hxj Hj.

    by apply lt_S_n, lt_S_n, lt_n_O in Hi.

  case: j Hxj Hj => [/= | j] Hxj Hj.

  case: Hxj => _ Hxj ; contradict Hxj ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hxi).

  elim: (i) Hi => {i Hxi IH} //= [| i IH] Hi.

  apply Rle_refl.

  apply Rle_trans with (1 := IH (lt_trans _ _ _ (lt_n_Sn _) Hi)), (sorted_nth Rle) ;

  [apply Hs | simpl ; intuition].

  case: i Hxi Hi => [/= | i] Hxi Hi.

  case: j Hxj Hj => [//= | j] Hxj Hj.

  case: Hxi => _ Hxi ; contradict Hxi ;

  apply Rle_not_lt, Rle_trans with (2 := proj1 Hxj) ;

  elim: (j) Hj => {j Hxj IH} //= [| j IH] Hj.

  apply Rle_refl.

  apply Rle_trans with (1 := IH (lt_trans _ _ _ (lt_n_Sn _) Hj)), (sorted_nth Rle) ;

  [apply Hs | simpl ; intuition].

  apply (IH h0 h1 i j) => //.

  apply Hs.

  apply lt_S_n, Hi.

  apply lt_S_n, Hj.



  simpl in Hxi, Hj ; case: Hxi => _ Hxi ; contradict Hxi ;

  apply Rle_not_lt, Rle_trans with (2 := proj1 Hj).

  move: Hi Hs ; rewrite ?SF_lx_cons /SF_lx.

  elim: i (fst h) (fst h0) (SF_h s) (unzip1 (SF_t s))

    => {s Hx Hx' Hj h y0 h0} [| i IH] h h0 h1 s Hi Hs.

    case: s Hi Hs => [| h2 s] Hi Hs /=.

    by apply lt_S_n, lt_S_n, lt_n_O in Hi.

    elim: s h h0 h1 h2 {Hi} Hs => [| h3 s IH] h h0 h1 h2 Hs /=.

    apply Rle_refl.

    apply Rle_trans with (r2 := h2).

    apply Hs.

    apply (IH h0 h1).

    apply (proj2 Hs).

  case: s Hi Hs => [| h2 s] Hi Hs.

    by apply lt_S_n, lt_S_n, lt_n_O in Hi.

  apply (IH h0 h1 h2 s).

  apply lt_S_n, Hi.

  apply Hs.



  simpl in Hxj, Hi ; case: Hxj => _ Hxj ; contradict Hxj ;

  apply Rle_not_lt, Rle_trans with (2 := proj1 Hi).

  move: Hj Hs ; rewrite ?SF_lx_cons /SF_lx.

  rewrite -minus_n_O ;

  elim: j (fst h) (fst h0) (SF_h s) (unzip1 (SF_t s))

    => {s Hx Hx' Hi h y0 h0} [ | j IH] h h0 h1 s Hj Hs /=.

    elim: s h h0 h1 {Hj} Hs => [| h2 s IH] h h0 h1 Hs /=.

    apply Rle_refl.

    apply Rle_trans with (r2 := h1).

    apply Hs.

    apply (IH h0 h1 h2).

    apply (proj2 Hs).

  case: s Hj Hs => [| h2 s] Hj Hs.

    by apply lt_S_n, lt_S_n, lt_S_n, lt_n_O in Hj.

  apply (IH h0 h1 h2 s).

  apply lt_S_n, Hj.

  apply Hs.

Qed.



End SF_fun.



Lemma SF_fun_map {T T0 : Type} (f : T -> T0) (s : SF_seq) y0 :

  forall x, SF_fun (SF_map f s) (f y0) x = f (SF_fun s y0 x).

Proof.

  case: s => sh st ; rewrite /SF_fun /SF_map /= ; case: st => [| h st] x /=.

  by case: Rle_dec.

  case: Rlt_dec => //.

  elim: st sh h y0 x => [| h0 st IH] sh h y0 x Hx //=.

  by case: Rle_dec.

  case: Rlt_dec => // {Hx} Hx.

  by apply: (IH (fst h)).

Qed.



Definition SF_seq_f1 {T : Type} (f1 : R -> T) (P : seq R) : SF_seq :=

  mkSF_seq (head 0 P) (pairmap (fun x y => (y, f1 x)) (head 0 P) (behead P)).

Definition SF_seq_f2 {T : Type} (f2 : R -> R -> T) (P : seq R) : SF_seq :=

  mkSF_seq (head 0 P) (pairmap (fun x y => (y, f2 x y)) (head 0 P) (behead P)).



Lemma SF_cons_f1 {T : Type} (f1 : R -> T) (h : R) (P : seq R) :

  (0 < size P)%nat -> SF_seq_f1 f1 (h::P) = SF_cons (h,f1 h) (SF_seq_f1 f1 P).

Proof.

  case: P => [ H | h0 P _] //.

  by apply lt_n_O in H.

Qed.

Lemma SF_cons_f2 {T : Type} (f2 : R -> R -> T) (h : R) (P : seq R) :

  (0 < size P)%nat ->

    SF_seq_f2 f2 (h::P) = SF_cons (h,f2 h (head 0 P)) (SF_seq_f2 f2 P).

Proof.

  case: P => [ H | h0 P _] //.

  by apply lt_n_O in H.

Qed.



Lemma SF_size_f1 {T : Type} (f1 : R -> T) P :

  SF_size (SF_seq_f1 f1 P) = Peano.pred (size P).

Proof.

  case: P => [| h P] //= ; by rewrite /SF_size /= size_pairmap.

Qed.

Lemma SF_size_f2 {T : Type} (f2 : R -> R -> T) P :

  SF_size (SF_seq_f2 f2 P) = Peano.pred (size P).

Proof.

  case: P => [| h P] //= ; by rewrite /SF_size /= size_pairmap.

Qed.



Lemma SF_lx_f1 {T : Type} (f1 : R -> T) P :

  (0 < size P)%nat -> SF_lx (SF_seq_f1 f1 P) = P.

Proof.

  elim: P => [ H | h l IH _] //=.

  by apply lt_n_O in H.

  case: l IH => [ | h' l] //= IH.

  rewrite -{2}IH //.

  by apply lt_O_Sn.

Qed.

Lemma SF_lx_f2 {T : Type} (f2 : R -> R -> T) P :

  (0 < size P)%nat ->

  SF_lx (SF_seq_f2 f2 P) = P.

Proof.

  elim: P => [ H | h l IH _] //=.

  by apply lt_n_O in H.

  case: l IH => [ | h' l] //= IH.

  rewrite -{2}IH //.

  by apply lt_O_Sn.

Qed.



Lemma SF_ly_f1 {T : Type} (f1 : R -> T) P :

  SF_ly (SF_seq_f1 f1 P) = Rcomplements.belast (map f1 P).

Proof.

  case: P => [| h P] // ; elim: P h =>  //= h P IH h0 ;

  by rewrite -(IH h).

Qed.

Lemma SF_ly_f2 {T : Type} (f2 : R -> R -> T) P :

  SF_ly (SF_seq_f2 f2 P) = behead (pairmap f2 0 P).

Proof.

  case: P => [| h P] // ; elim: P h =>  //= h P IH h0 ;

  by rewrite -(IH h).

Qed.



Lemma SF_sorted_f1 {T : Type} (f1 : R -> T) P Ord :

  (sorted Ord P) <-> (SF_sorted Ord (SF_seq_f1 f1 P)).

Proof.

  case: P => [ | h P] //.

  rewrite /SF_sorted SF_lx_f1 //.

  by apply lt_O_Sn.

Qed.

Lemma SF_sorted_f2 {T : Type} (f2 : R -> R -> T) P Ord :

  (sorted Ord P) <-> (SF_sorted Ord (SF_seq_f2 f2 P)).

Proof.

  case: P => [ | h P] //.

  rewrite /SF_sorted SF_lx_f2 //.

  by apply lt_O_Sn.

Qed.



Lemma SF_rev_f2 {T : Type} (f2 : R -> R -> T) P : (forall x y, f2 x y = f2 y x) ->

  SF_rev (SF_seq_f2 f2 P) = SF_seq_f2 f2 (rev P).

Proof.

  move => Hf2 ; apply SF_lx_ly_inj ;

  case: P => [ | h P] //=.

  rewrite SF_lx_rev !SF_lx_f2 ?rev_cons /= 1?headI // ; by apply lt_O_Sn.

  rewrite SF_ly_rev !SF_ly_f2 /= ?rev_cons.

  elim: P h => [ | h0 P IH] h //=.

  rewrite !rev_cons pairmap_rcons behead_rcons ?(IH h0) ?(Hf2 h h0) //.

  rewrite size_pairmap size_rcons ; apply lt_O_Sn.

Qed.



Lemma SF_map_f1 {T T0 : Type} (f : T -> T0) (f1 : R -> T) P :

  SF_map f (SF_seq_f1 f1 P) = SF_seq_f1 (fun x => f (f1 x)) P.

Proof.

  case: P => [| h P] // ; elim: P h => [| h0 P IH] h //.

  rewrite ?(SF_cons_f1 _ _ (h0::P)) /= ; try intuition.

  rewrite SF_map_cons IH ; intuition.

Qed.

Lemma SF_map_f2 {T T0 : Type} (f : T -> T0) (f2 : R -> R -> T) P :

  SF_map f (SF_seq_f2 f2 P) = SF_seq_f2 (fun x y => f (f2 x y)) P.

Proof.

  case: P => [| h P] // ; elim: P h => [| h0 P IH] h //.

  rewrite ?(SF_cons_f2 _ _ (h0::P)) /= ; try intuition.

  rewrite SF_map_cons IH ; intuition.

Qed.



Lemma ptd_f2 (f : R -> R -> R) s :

  sorted Rle s -> (forall x y, x <= y -> x <= f x y <= y)

  -> pointed_subdiv (SF_seq_f2 f s).

Proof.

  intros Hs Hf.

  elim: s Hs => [ _ | h s].

  intros i Hi.

  by apply lt_n_O in Hi.

  case: s => [ | h' s] IH Hs.

  intros i Hi.

  by apply lt_n_O in Hi.

  case => [ | i] Hi.

  apply Hf, Hs.

  apply IH.

  apply Hs.

  by apply lt_S_n.

Qed.



Definition SF_fun_f1 {T : Type} (f1 : R -> T) (P : seq R) x : T :=

  SF_fun (SF_seq_f1 f1 P) (f1 0) x.

Definition SF_fun_f2 {T : Type} (f2 : R -> R -> T) (P : seq R) x :=

  SF_fun (SF_seq_f2 f2 P) (f2 0 0) x.



Definition unif_part (a b : R) (n : nat) : seq R :=

  mkseq (fun i => a + (INR i) * (b - a) / (INR n + 1)) (S (S n)).



Lemma unif_part_bound (a b : R) (n : nat) :

  unif_part a b n = rev (unif_part b a n).

Proof.

  apply (@eq_from_nth R 0) ; rewrite ?size_rev ?size_mkseq => // ;

  move => i Hi ; apply SSR_leq in Hi.

  rewrite nth_rev ?SSR_minus ?size_mkseq.

  2: now apply SSR_leq.

  rewrite ?nth_mkseq.

  3: now apply SSR_leq.

  rewrite minus_INR ?S_INR => // ; field.

  apply Rgt_not_eq, INRp1_pos.

  apply SSR_leq, INR_le ; rewrite ?S_INR minus_INR ?S_INR => //.

  apply Rminus_le_0 ; ring_simplify.

  apply pos_INR.

Qed.



Lemma unif_part_sort (a b : R) (n : nat) : a <= b -> sorted Rle (unif_part a b n).

Proof.

  move => Hab ; apply sorted_nth => i Hi x0 ;

  rewrite ?size_mkseq in Hi ; rewrite ?nth_mkseq ?S_INR ;

  [ |apply SSR_leq ; intuition | apply SSR_leq ; intuition ].

  apply Rminus_le_0 ; field_simplify ;

  [| apply Rgt_not_eq ; intuition] ; rewrite ?Rdiv_1 ;

  apply Rdiv_le_0_compat ; intuition.

  rewrite Rplus_comm ; by apply (proj1 (Rminus_le_0 _ _)).

Qed.



Lemma head_unif_part x0 (a b : R) (n : nat) :

  head x0 (unif_part a b n) = a.

Proof.

  rewrite /= Rmult_0_l /Rdiv ; ring.

Qed.



Lemma last_unif_part x0 (a b : R) (n : nat) :

  last x0 (unif_part a b n) = b.

Proof.

  rewrite (last_nth b) size_mkseq.

  replace (nth b (x0 :: unif_part a b n) (S (S n)))

    with (nth b (unif_part a b n) (S n)) by auto.

  rewrite nth_mkseq.

  rewrite S_INR ; field.

  by apply Rgt_not_eq, INRp1_pos.

  by [].

Qed.



Lemma unif_part_nat (a b : R) (n : nat) (x : R) : (a <= x <= b) ->

  {i : nat |

  nth 0 (unif_part a b n) i <= x < nth 0 (unif_part a b n) (S i) /\

  (S (S i) < size (unif_part a b n))%nat} +

  {nth 0 (unif_part a b n) (n) <= x <=

   nth 0 (unif_part a b n) (S n)}.

Proof.

  move: (sorted_dec (unif_part a b n) 0 x) => Hdec Hx.

  have Hs : sorted Rle (unif_part a b n) ;

    [ apply unif_part_sort, Rle_trans with (r2 := x) ; intuition

    | move: (Hdec Hs) => {Hdec Hs} Hdec].

  have Hx' : (head 0 (unif_part a b n) <= x <= last 0 (unif_part a b n)).

    by rewrite head_unif_part last_unif_part.

  case: (Hdec Hx') => {Hdec Hx'} [[i Hi]|Hi].

  left ; by exists i.

  right ; rewrite size_mkseq /= in Hi ; intuition.

  by rewrite -minus_n_O in H1.

Qed.



Lemma seq_step_unif_part (a b : R) (n : nat) :

  seq_step (unif_part a b n) = Rabs ((b - a) / (INR n + 1)).

Proof.

  assert (forall i, (S i < size (unif_part a b n))%nat ->

    (nth 0 (unif_part a b n) (S i) - nth 0 (unif_part a b n) i = (b - a) / (INR n + 1))%R).

    rewrite size_mkseq => i Hi.

    rewrite !nth_mkseq.

    rewrite S_INR /Rdiv /= ; ring.

    by apply SSR_leq, lt_le_weak.

    by apply SSR_leq.

  move: (eq_refl (size (unif_part a b n))).

  rewrite {2}size_mkseq.

  rewrite /seq_step ;

  elim: {2}(n) (unif_part a b n) H => [ | m IH] l //= ;

  destruct l as [ | x0 l] => //= ;

  destruct l as [ | x1 l] => //= ;

  destruct l as [ | x2 l] => //= ; intros.

  rewrite (H O).

  rewrite Rmax_comm /Rmax ; case: Rle_dec => // H1.

  contradict H1 ; by apply Rabs_pos.

  by apply lt_n_S, lt_O_Sn.

  rewrite -(IH (x1::x2::l)) /=.

  rewrite (H O).

  rewrite (H 1%nat).

  rewrite Rmax_assoc.

  apply f_equal2 => //.

  rewrite /Rmax ; by case: Rle_dec.

  by apply lt_n_S, lt_n_S, lt_O_Sn.

  by apply lt_n_S, lt_O_Sn.

  now intros ; apply (H (S i)), lt_n_S.

  by apply eq_add_S.

Qed.



Lemma seq_step_unif_part_ex (a b : R) (eps : posreal) :

  {n : nat | seq_step (unif_part a b n) < eps}.

Proof.

  destruct (nfloor_ex (Rabs ((b - a) / eps))) as [n Hn].

    by apply Rabs_pos.

  exists n.

  rewrite seq_step_unif_part.

  rewrite Rabs_div.

  rewrite (Rabs_pos_eq (INR n + 1)).

  apply Rlt_div_l.

  by apply INRp1_pos.

  rewrite Rmult_comm -Rlt_div_l.

  rewrite -(Rabs_pos_eq eps).

  rewrite -Rabs_div.

  by apply Hn.

  by apply Rgt_not_eq, eps.

  by apply Rlt_le, eps.

  by apply eps.

  by apply Rlt_le, INRp1_pos.

  by apply Rgt_not_eq, INRp1_pos.

Qed.



Lemma unif_part_S a b n :

  unif_part a b (S n) = a :: unif_part ((a * INR (S n) + b) / INR (S (S n))) b n.

Proof.

  apply eq_from_nth with 0.

  by rewrite /= !size_map !size_iota.

  case => [ | i] Hi.

  by rewrite nth0 head_unif_part.

  change (nth 0 (a :: unif_part ((a * INR (S n) + b) / INR (S (S n))) b n) (S i))

    with (nth 0 (unif_part ((a * INR (S n) + b) / INR (S (S n))) b n) i).

  rewrite /unif_part size_mkseq in Hi.

  rewrite /unif_part !nth_mkseq ; try by intuition.

  rewrite !S_INR ; field.

  rewrite -!S_INR ; split ; apply sym_not_eq, (not_INR 0), O_S.

Qed.



Definition SF_val_seq {T} (f : R -> T) (a b : R) (n : nat) : SF_seq :=

  SF_seq_f2 (fun x y => f ((x+y)/2)) (unif_part a b n).

Definition SF_val_fun {T} (f : R -> T) (a b : R) (n : nat) (x : R) : T :=

  SF_fun_f2 (fun x y => f ((x+y)/2)) (unif_part a b n) x.



Definition SF_val_ly {T} (f : R -> T) (a b : R) (n : nat) : seq T :=

  behead (pairmap (fun x y => f ((x+y)/2)) 0 (unif_part a b n)).



Lemma SF_val_ly_bound {T} (f : R -> T) (a b : R) (n : nat) :

  SF_val_ly f a b n = rev (SF_val_ly f b a n).

Proof.

  rewrite /SF_val_ly (unif_part_bound b a).

  case: (unif_part a b n) => [| h s] // ; elim: s h => [| h0 s IH] h //=.

  rewrite ?rev_cons.

  replace (pairmap (fun x y : R => f ((x + y) / 2)) 0 (rcons (rcons (rev s) h0) h))

    with (rcons (pairmap (fun x y : R => f ((x + y) / 2)) 0 (rcons (rev s) h0)) (f ((h0+h)/2))).

  rewrite behead_rcons.

  rewrite rev_rcons Rplus_comm -rev_cons -IH //.

  rewrite size_pairmap size_rcons ; apply lt_O_Sn.

  move: (0) h h0 {IH} ; apply rcons_ind with (s := s) => {s} [| s h1 IH] x0 h h0 //.

  rewrite ?rev_rcons /= IH //.

Qed.



Lemma Riemann_fine_unif_part :

  forall (f : R -> R -> R) (a b : R) (n : nat),

  (forall a b, a <= b -> a <= f a b <= b) ->

  a <= b ->

  seq_step (SF_lx (SF_seq_f2 f (unif_part a b n))) <= (b - a) / (INR n + 1) /\

  pointed_subdiv (SF_seq_f2 f (unif_part a b n)) /\

  SF_h (SF_seq_f2 f (unif_part a b n)) = a /\

  last (SF_h (SF_seq_f2 f (unif_part a b n))) (SF_lx (SF_seq_f2 f (unif_part a b n))) = b.

Proof.

intros f a b n Hf Hab.

assert (Hab' : 0 <= (b - a) / (INR n + 1)).

  apply Rdiv_le_0_compat.

  apply -> Rminus_le_0.

  apply Hab.

  apply INRp1_pos.

unfold pointed_subdiv.

rewrite SF_lx_f2.

change (head 0 (unif_part a b n) :: behead (unif_part a b n)) with (unif_part a b n).

split ; [|split ; [|split]].

- cut (forall i, (S i < size (unif_part a b n))%nat ->

    nth 0 (unif_part a b n) (S i) - nth 0 (unif_part a b n) i = (b - a) / (INR n + 1)).

  + induction (unif_part a b n) as [|x0 l IHl].

    now intros _.

    intros H.

    destruct l as [|x1 l].

    easy.

    change (seq_step _) with (Rmax (Rabs (x1 - x0)) (seq_step (x1 :: l))).

    apply Rmax_case.

    apply Req_le.

    rewrite (H 0%nat).

    now apply Rabs_pos_eq.

    apply lt_n_S.

    apply lt_0_Sn.

    apply IHl.

    intros i Hi.

    apply (H (S i)).

    now apply lt_n_S.

  + rewrite size_mkseq.

    intros i Hi.

    rewrite !nth_mkseq.

    rewrite S_INR.

    unfold Rdiv.

    ring.

    apply SSR_leq.

    now apply lt_le_weak.

    now apply SSR_leq.

- unfold pointed_subdiv.

  rewrite SF_size_f2.

  rewrite size_mkseq.

  intros i Hi.

  rewrite SF_ly_f2.

  rewrite nth_behead.

  apply gt_S_le, SSR_leq in Hi.

  rewrite (nth_pairmap 0).

  change (nth 0 (0 :: unif_part a b n) (S i)) with (nth 0 (unif_part a b n) i).

  apply Hf.

  rewrite !nth_mkseq //.

  rewrite S_INR.

  lra.

  now apply ssrnat.leqW.

  by rewrite size_mkseq.

- apply head_unif_part.

- apply last_unif_part.

rewrite size_mkseq ; by apply lt_O_Sn.

Qed.



Definition Riemann_fine (a b : R) :=

  within (fun ptd => pointed_subdiv ptd /\ SF_h ptd = Rmin a b /\ last (SF_h ptd) (SF_lx ptd) = Rmax a b)

    (locally_dist (fun ptd => seq_step (SF_lx ptd))).



Global Instance Riemann_fine_filter :

  forall a b, ProperFilter (Riemann_fine a b).

Proof.

intros a b.

constructor.

- intros P [alpha H].

  assert (Hab : Rmin a b <= Rmax a b).

    apply Rmax_case.

    apply Rmin_l.

    apply Rmin_r.

  assert (Hn : 0 <= ((Rmax a b - Rmin a b) / alpha)).

    apply Rdiv_le_0_compat.

    apply -> Rminus_le_0.

    apply Hab.

    apply cond_pos.

  set n := (nfloor _ Hn).

  exists (SF_seq_f2 (fun x y => x) (unif_part (Rmin a b) (Rmax a b) n)).

  destruct (Riemann_fine_unif_part (fun x y => x) (Rmin a b) (Rmax a b) n).

  intros u v Huv.

  split.

  apply Rle_refl.

  exact Huv.

  exact Hab.

  apply H.

  apply Rle_lt_trans with (1 := H0).

  apply Rlt_div_l.

  apply INRp1_pos.

  unfold n, nfloor.

  destruct nfloor_ex as [n' Hn'].

  simpl.

  rewrite Rmult_comm.

  apply Rlt_div_l.

  apply cond_pos.

  apply Hn'.

  exact H1.

- apply within_filter.

  apply locally_dist_filter.

Qed.



Section Riemann_sum.



Context {V : ModuleSpace R_Ring}.



Definition Riemann_sum (f : R -> V) (ptd : SF_seq) : V :=

  foldr plus zero (pairmap (fun x y => (scal (fst y - fst x) (f (snd y)))) (SF_h ptd,zero) (SF_t ptd)).



Lemma Riemann_sum_cons (f : R -> V) (h0 : R * R) (ptd : SF_seq) :

  Riemann_sum f (SF_cons h0 ptd) =

    plus (scal (SF_h ptd - fst h0) (f (snd h0))) (Riemann_sum f ptd).

Proof.

  rewrite /Riemann_sum /=.

  case: h0 => x0 y0 ;

  apply SF_cons_dec with (s := ptd) => {ptd} [ x1 | [x1 y1] ptd ] //=.

Qed.



Lemma Riemann_sum_rcons (f : R -> V) ptd l0 :

  Riemann_sum f (SF_rcons ptd l0) =

    plus (Riemann_sum f ptd) (scal (fst l0 - last (SF_h ptd) (SF_lx ptd)) (f (snd l0))).

Proof.

  rewrite /Riemann_sum .

  case: l0 => x0 y0.

  apply SF_rcons_dec with (s := ptd) => {ptd} [ x1 | ptd [x1 y1]].

  apply plus_comm.

  rewrite ?SF_map_rcons /=.

  rewrite pairmap_rcons foldr_rcons /=.

  rewrite unzip1_rcons last_rcons /=.

  set l := pairmap _ _ _.

  induction l ; simpl.

  apply plus_comm.

  rewrite IHl.

  apply plus_assoc.

Qed.



Lemma Riemann_sum_zero (f : R -> V) ptd :

  SF_sorted Rle ptd ->

  SF_h ptd = last (SF_h ptd) (SF_lx ptd) ->

  Riemann_sum f ptd = zero.

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} [x0 | [x0 y0] ptd IH] //= Hs Hhl.

  rewrite Riemann_sum_cons IH /= => {IH}.

  replace x0 with (SF_h ptd).

  rewrite Rminus_eq_0.

  rewrite plus_zero_r.

  by apply: scal_zero_l.

  apply Rle_antisym.

  rewrite Hhl => {Hhl} /=.

  apply (sorted_last (SF_h ptd :: @map (R*R) R (@fst R R) (SF_t ptd)) O) with (x0 := 0).

  replace ((SF_h ptd) :: map _ _) with (SF_lx ptd).

  apply Hs.

  apply SF_cons_ind with (s := ptd) => {ptd Hs} [x1 | [x1 y1] ptd IH] //=.

  apply lt_O_Sn.

  apply Hs.

  apply Hs.

  apply Rle_antisym.

  apply (sorted_last (SF_h ptd :: @map (R*R) R (@fst R R) (SF_t ptd)) O) with (x0 := 0).

  replace ((SF_h ptd) :: map _ _) with (SF_lx ptd).

  apply Hs.

  apply SF_cons_ind with (s := ptd) => {ptd Hs Hhl} [x1 | [x1 y1] ptd IH] //=.

  apply lt_O_Sn.

  move: Hhl ; rewrite -?(last_map (@fst R R)) /= => <- ; apply Hs.

Qed.



Lemma Riemann_sum_map (f : R -> V) (g : R -> R) ptd :

  Riemann_sum (fun x => f (g x)) ptd = Riemann_sum f (SF_map g ptd).

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} [x0 | h ptd IH].

  by [].

  rewrite SF_map_cons !Riemann_sum_cons /=.

  by rewrite IH.

Qed.



Lemma Riemann_sum_const (v : V) ptd :

  Riemann_sum (fun _ => v) ptd = scal (last (SF_h ptd) (SF_lx ptd) - SF_h ptd) v.

Proof.

apply SF_cons_ind with (s := ptd) => {ptd} [x0 | [x0 y0] s IH] /=.

by rewrite /Riemann_sum /= Rminus_eq_0 scal_zero_l.

rewrite Riemann_sum_cons IH /=.

rewrite -scal_distr_r /=.

apply (f_equal (fun x => scal x v)).

rewrite /plus /=.

ring.

Qed.



Lemma Riemann_sum_scal (a : R) (f : R -> V) ptd :

  Riemann_sum (fun x => scal a (f x)) ptd = scal a (Riemann_sum f ptd).

Proof.

apply SF_cons_ind with (s := ptd) => {ptd} /= [x0 | [x0 y0] s IH].

rewrite /Riemann_sum /=.

apply sym_eq. apply @scal_zero_r.

rewrite !Riemann_sum_cons /= IH.

rewrite scal_distr_l.

apply f_equal with (f := fun v => plus v _).

rewrite 2!scal_assoc.

by rewrite /mult /= Rmult_comm.

Qed.



Lemma Riemann_sum_opp (f : R -> V) ptd :

  Riemann_sum (fun x => opp (f x)) ptd = opp (Riemann_sum f ptd).

Proof.

apply SF_cons_ind with (s := ptd) => {ptd} /= [x0 | [x0 y0] s IH].

rewrite /Riemann_sum /=.

apply sym_eq, @opp_zero.

rewrite !Riemann_sum_cons /= IH.

rewrite opp_plus.

apply f_equal with (f := fun v => plus v (opp (Riemann_sum f s))).

apply scal_opp_r.

Qed.



Lemma Riemann_sum_plus (f g : R -> V) ptd :

  Riemann_sum (fun x => plus (f x) (g x)) ptd =

    plus (Riemann_sum f ptd) (Riemann_sum g ptd).

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} /= [x0 | [x0 y0] s IH].

  rewrite /Riemann_sum /=.

  apply sym_eq, @plus_zero_l.

  rewrite !Riemann_sum_cons /= ; rewrite IH.

  rewrite scal_distr_l.

  rewrite -!plus_assoc.

  apply f_equal.

  rewrite !plus_assoc.

  apply (f_equal (fun x => plus x (Riemann_sum g s))).

  apply plus_comm.

Qed.



Lemma Riemann_sum_minus (f g : R -> V) ptd :

  Riemann_sum (fun x => minus (f x) (g x)) ptd =

    minus (Riemann_sum f ptd) (Riemann_sum g ptd).

Proof.

unfold minus.

rewrite -Riemann_sum_opp.

apply Riemann_sum_plus.

Qed.



End Riemann_sum.



Section Riemann_sum_Normed.



Context {V : NormedModule R_AbsRing}.



Lemma Riemann_sum_Chasles_0

  (f : R -> V) (M : R) (x : R) ptd :

  forall (eps : posreal),

  (forall x, SF_h ptd <= x <= last (SF_h ptd) (SF_lx ptd) -> norm (f x) < M) ->

  SF_h ptd <= x <= last (SF_h ptd) (SF_lx ptd) ->

  pointed_subdiv ptd ->

  seq_step (SF_lx ptd) < eps ->

  norm (minus (plus (Riemann_sum f (SF_cut_down ptd x)) (Riemann_sum f (SF_cut_up ptd x)))

    (Riemann_sum f ptd)) < 2 * eps * M.

Proof.

  intros eps.

  apply (SF_cons_ind (T := R)) with (s := ptd)

    => {ptd} /= [ x0 | [x0 y1] ptd IH] /= Hfx [ Hx0 Hl] Hptd Hstep.

  + rewrite (Rle_antisym _ _ Hx0 Hl) ; clear -Hfx.

    rewrite /Riemann_sum /=.

    case: Rle_dec (Rle_refl x) => //= _ _.

    rewrite ?plus_zero_r Rminus_eq_0.

    rewrite scal_zero_l.

    rewrite /minus plus_zero_l norm_opp norm_zero.

    apply Rmult_lt_0_compat.

    apply Rmult_lt_0_compat.

    by apply Rlt_0_2.

    by apply eps.

    by apply Rle_lt_trans with (2:= (Hfx x0 (conj (Rle_refl _) (Rle_refl _)))), norm_ge_0.

  + case: (Rle_dec (SF_h ptd) x) => Hx1.

    - replace (minus (plus (Riemann_sum f (SF_cut_down (SF_cons (x0, y1) ptd) x))

        (Riemann_sum f (SF_cut_up (SF_cons (x0, y1) ptd) x)))

        (Riemann_sum f (SF_cons (x0, y1) ptd)))

        with (minus (plus (Riemann_sum f (SF_cut_down ptd x))

          (Riemann_sum f (SF_cut_up ptd x))) (Riemann_sum f ptd)).

      apply IH.

      intros y Hy.

      apply Hfx.

      split.

      apply Rle_trans with y1.

      by apply (Hptd O (lt_O_Sn _)).

      apply Rle_trans with (SF_h ptd).

      by apply (Hptd O (lt_O_Sn _)).

      by apply Hy.

      by apply Hy.

      by split.

      by apply ptd_cons in Hptd.

      apply Rle_lt_trans with (2 := Hstep).

      by apply Rmax_r.

      rewrite SF_cut_down_cons_2.

      rewrite SF_cut_up_cons_2.

      rewrite /minus 2?(Riemann_sum_cons _ (x0, y1)) SF_cut_down_h.

      rewrite opp_plus plus_assoc /=.

      apply (f_equal (fun x => plus x _)).

      rewrite (plus_comm (scal (SF_h ptd - x0) (f y1))) -2!plus_assoc.

      apply f_equal.

      by rewrite plus_comm -plus_assoc plus_opp_l plus_zero_r.

      by [].

      split ; [ | apply Hx1].

      apply Rle_trans with y1 ; by apply (Hptd O (lt_O_Sn _)).

      split ; [ | apply Hx1].

      apply Rle_trans with y1 ; by apply (Hptd O (lt_O_Sn _)).

    - apply Rnot_le_lt in Hx1.

      rewrite SF_cut_down_cons_1 /=.

      rewrite SF_cut_up_cons_1 /=.

      rewrite 3!Riemann_sum_cons /= => {IH}.

      replace (Riemann_sum f (SF_nil x) : V) with (zero : V) by auto.

      rewrite plus_zero_r /minus opp_plus.

      rewrite (plus_comm (opp (scal (SF_h ptd - x0) (f y1)))).

      rewrite ?plus_assoc -(plus_assoc _ _ (opp (Riemann_sum f ptd))).

      rewrite plus_opp_r plus_zero_r.

      rewrite -scal_opp_l.

      rewrite /opp /= Ropp_minus_distr.

      rewrite /Rmin /Rmax ; case: Rle_dec => _.

      rewrite (plus_comm (scal (x - x0) (f y1))) -plus_assoc.

      rewrite -scal_distr_r /plus /= -/plus.

      ring_simplify (x - x0 + (x0 - SF_h ptd)).

      eapply Rle_lt_trans.

      apply @norm_triangle.

      replace (2 * eps * M) with (eps * M + eps * M) by ring.

      apply Rplus_lt_compat ;

        eapply Rle_lt_trans ; try (apply @norm_scal) ;

        apply Rmult_le_0_lt_compat.

      by apply Rabs_pos.

      by apply norm_ge_0.

      apply Rle_lt_trans with (2 := Hstep).

      apply Rle_trans with (2 := Rmax_l _ _).

      simpl.

      apply Rlt_le in Hx1.

      move: (Rle_trans _ _ _ Hx0 Hx1) => Hx0'.

      apply Rminus_le_0 in Hx1.

      apply Rminus_le_0 in Hx0'.

      rewrite /abs /= ?Rabs_pos_eq //.

      by apply Rplus_le_compat_l, Ropp_le_contravar.

      apply Hfx.

      by split.

      by apply Rabs_pos.

      by apply norm_ge_0.

      apply Rle_lt_trans with (2 := Hstep).

      apply Rle_trans with (2 := Rmax_l _ _).

      rewrite /abs /plus /= -Ropp_minus_distr Rabs_Ropp.

      apply Rlt_le in Hx1.

      move: (Rle_trans _ _ _ Hx0 Hx1) => Hx0'.

      apply Rminus_le_0 in Hx1.

      apply Rminus_le_0 in Hx0'.

      rewrite ?Rabs_pos_eq //.

      by apply Rplus_le_compat_l, Ropp_le_contravar.

      apply Hfx.

      split.

      apply (Hptd O (lt_O_Sn _)).

      apply Rle_trans with (SF_h ptd).

      apply (Hptd O (lt_O_Sn _)).

      apply (fun H => sorted_last ((SF_h ptd) :: (unzip1 (SF_t ptd))) O H (lt_O_Sn _) (SF_h ptd)).

      apply ptd_sort in Hptd.

      by apply Hptd.

      rewrite -plus_assoc -scal_distr_r /plus /= -/plus.

      replace (SF_h ptd - x + (x0 - SF_h ptd)) with (opp (x - x0)) by (rewrite /opp /= ; ring).

      rewrite scal_opp_l -scal_opp_r.

      rewrite -scal_distr_l.

      eapply Rle_lt_trans. apply @norm_scal.

      replace (2 * eps * M) with (eps * (M + M)) by ring.

      apply Rmult_le_0_lt_compat.

      by apply Rabs_pos.

      by apply norm_ge_0.

      apply Rle_lt_trans with (2 := Hstep).

      apply Rle_trans with (2 := Rmax_l _ _).

      simpl.

      apply Rlt_le in Hx1.

      move: (Rle_trans _ _ _ Hx0 Hx1) => Hx0'.

      apply Rminus_le_0 in Hx0.

      apply Rminus_le_0 in Hx0'.

      rewrite /abs /= ?Rabs_pos_eq //.

      by apply Rplus_le_compat_r.

      apply Rle_lt_trans with (norm (f x) + norm (opp (f y1))).

      apply @norm_triangle.

      apply Rplus_lt_compat.

      apply Hfx.

      by split.

      rewrite norm_opp.

      apply Hfx.

      split.

      apply (Hptd O (lt_O_Sn _)).

      apply Rle_trans with (SF_h ptd).

      apply (Hptd O (lt_O_Sn _)).

      apply (fun H => sorted_last ((SF_h ptd) :: (unzip1 (SF_t ptd))) O H (lt_O_Sn _) (SF_h ptd)).

      apply ptd_sort in Hptd.

      by apply Hptd.

      by split.

      by split.

Qed.



Lemma Riemann_sum_norm (f : R -> V) (g : R -> R) ptd :

  pointed_subdiv ptd ->

  (forall t, SF_h ptd <= t <= last (SF_h ptd) (SF_lx ptd) -> norm (f t) <= g t)

  -> norm (Riemann_sum f ptd) <= Riemann_sum g ptd.

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} /= [x0 | [x0 y0] s IH] /= Hs H.

  rewrite norm_zero ; exact: Rle_refl.

  rewrite !Riemann_sum_cons /=.

  eapply Rle_trans.

  by apply @norm_triangle.

  apply Rplus_le_compat.

  eapply Rle_trans. apply @norm_scal.

  refine (_ (Hs O _)).

  simpl.

  intros [H1 H2].

  rewrite /abs /= Rabs_pos_eq.

  apply Rmult_le_compat_l.

  apply -> Rminus_le_0.

  now apply Rle_trans with y0.

  apply H.

  apply (conj H1).

  apply Rle_trans with (1 := H2).

  apply (sorted_last (SF_lx s) O) with (x0 := 0).

  by apply (ptd_sort _ Hs).

  exact: lt_O_Sn.

  apply -> Rminus_le_0.

  now apply Rle_trans with y0.

  exact: lt_O_Sn.

  apply IH.

  by apply ptd_cons with (h := (x0,y0)).

  move => t Ht ; apply H ; split.

  by apply Rle_trans with (2 := proj1 Ht), (ptd_sort _ Hs).

  by apply Ht.

Qed.



End Riemann_sum_Normed.



Lemma Riemann_sum_le (f : R -> R) (g : R -> R) ptd :

  pointed_subdiv ptd ->

  (forall t, SF_h ptd <= t <= last (SF_h ptd) (SF_lx ptd) -> f t <= g t) ->

  Riemann_sum f ptd <= Riemann_sum g ptd.

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} /= [x0 | [x0 y0] s IH] /= Hs H.

  apply Rle_refl.

  rewrite !Riemann_sum_cons /=.

  apply Rplus_le_compat.

  refine (_ (Hs O _)).

  simpl.

  intros [H1 H2].

  apply Rmult_le_compat_l.

  apply -> Rminus_le_0.

  now apply Rle_trans with y0.

  apply H.

  apply (conj H1).

  apply Rle_trans with (1 := H2).

  apply (sorted_last (SF_lx s) O) with (x0 := 0).

  by apply (ptd_sort _ Hs).

  exact: lt_O_Sn.

  exact: lt_O_Sn.

  apply IH.

  by apply ptd_cons with (h := (x0,y0)).

  move => t Ht ; apply H ; split.

  by apply Rle_trans with (2 := proj1 Ht), (ptd_sort _ Hs).

  by apply Ht.

Qed.



Lemma Riemann_sum_pair {U : ModuleSpace R_Ring} {V : ModuleSpace R_Ring}

  (f : R -> U * V) ptd :

  Riemann_sum f ptd =

    (Riemann_sum (fun t => fst (f t)) ptd, Riemann_sum (fun t => snd (f t)) ptd).

Proof.

  apply SF_cons_ind with (s := ptd) => {ptd} [x0 | h0 ptd IH].

  by [].

  rewrite !Riemann_sum_cons IH.

  by apply injective_projections.

Qed.



Section RInt_val.



Context {V : ModuleSpace R_Ring}.



Definition RInt_val (f : R -> V) (a b : R) (n : nat) :=

  Riemann_sum f (SF_seq_f2 (fun x y => (x + y) / 2) (unif_part a b n)).



Lemma RInt_val_point (f : R -> V) (a : R) (n : nat) :

  RInt_val f a a n = zero.

Proof.

  unfold RInt_val ; apply Riemann_sum_zero.

  rewrite /SF_sorted SF_lx_f2.

  apply unif_part_sort ; apply Rle_refl.

  rewrite size_mkseq ; by apply lt_O_Sn.

  rewrite SF_lx_f2 /=.

  rewrite -{2}[1]/(INR 1) last_map.

  unfold Rdiv ; ring.

  by apply lt_O_Sn.

Qed.



Lemma RInt_val_swap :

  forall (f : R -> V) (a b : R) (n : nat),

  RInt_val f a b n = opp (RInt_val f b a n).

Proof.

  intros f a b n.

  rewrite /RInt_val.

  rewrite -Riemann_sum_opp.

  rewrite unif_part_bound.

  elim: (unif_part b a n) => [ | x1 s IH] /=.

  by [].

  clear -IH.

  rewrite rev_cons.

  destruct s as [ | x2 s].

  by [].

  rewrite SF_cons_f2.

  2: by apply lt_O_Sn.

  rewrite Riemann_sum_cons /= -IH => {IH}.

  rewrite scal_opp_r -scal_opp_l /=.

  rewrite rev_cons.

  elim: (rev s) => {s} /= [ | x3 s IH].

  rewrite /Riemann_sum /=.

  apply (f_equal2 (fun x y => plus (scal x (f y)) _)) ;

    rewrite /Rdiv /opp /= ; ring.

  rewrite !SF_cons_f2 ; try (by rewrite size_rcons ; apply lt_O_Sn).

  rewrite !Riemann_sum_cons /= IH !plus_assoc => {IH}.

  apply (f_equal (fun x => plus x _)).

  rewrite plus_comm.

  apply f_equal.

  apply (f_equal2 (fun x y => scal (x - x3)

  (f ((x3 + y) / 2)))) ; clear ;

  by elim: s.

Qed.



Lemma RInt_val_ext (f g : R -> V) (a b : R) (n : nat) :

  (forall x, Rmin a b <= x <= Rmax a b -> f x = g x)

  -> RInt_val g a b n = RInt_val f a b n.

Proof.

  wlog: a b / (a <= b) => [Hw | Hab].

    case: (Rle_lt_dec a b) => Hab.

    by apply Hw.

    rewrite Rmin_comm Rmax_comm => Heq.

    apply Rlt_le in Hab.

    rewrite RInt_val_swap Hw => //=.

    apply sym_eq ; by apply RInt_val_swap.

  rewrite /Rmin /Rmax ; case: Rle_dec => //= _ Heq.

  unfold RInt_val.

  set l := (SF_seq_f2 (fun x y : R => (x + y) / 2) (unif_part a b n)).

  assert (forall i, (i < size (SF_ly l))%nat -> f (nth 0 (SF_ly l) i) = g (nth 0 (SF_ly l) i)).

    move => i Hi.

    apply Heq.

    destruct (fun H0 => Riemann_fine_unif_part (fun x y : R => (x + y) / 2) a b n H0 Hab) as [H [H0 [H1 H2]]].

    clear.

    intros a b Hab.

    lra.

    fold l in H, H0, H1, H2.

    rewrite -H1 -H2 ; split.

    apply Rle_trans with (head 0 (SF_ly l)).

    apply (H0 O).

    by apply lt_O_Sn.

    apply sorted_head.

    by apply ptd_sort'.

    by [].

    apply Rle_trans with (last 0 (SF_ly l)).

    apply sorted_last.

    by apply ptd_sort'.

    by [].

    rewrite -!nth_last SF_size_ly SF_size_lx SF_size_f2 size_mkseq.

    simpl Peano.pred.

    replace (nth (SF_h l) (SF_lx l) (S n)) with (nth 0 (SF_lx l) (S n)).

    apply (H0 n).

    rewrite SF_size_f2 size_mkseq /=.

    by apply lt_n_Sn.

    rewrite SF_lx_f2.

    assert (size (unif_part a b n) = S (S n)).

      by apply size_mkseq.

    elim: (S n) (unif_part a b n) H3 ; simpl ; clear ; intros.

    destruct unif_part0 ; simpl => //.

    replace unif_part0 with (head 0 unif_part0 :: behead unif_part0).

    apply H.

    destruct unif_part0 ; by intuition.

    destruct unif_part0 ; by intuition.

    by apply lt_O_Sn.

  move: H => {Heq}.

  apply SF_cons_ind with (s := l) => {l} [x0 | h0 s IH] /= Heq.

  by [].

  rewrite !Riemann_sum_cons.

  apply (f_equal2 (fun x y => plus (scal (SF_h s - fst h0) x) y)).

  by apply sym_eq, (Heq O), lt_O_Sn.

  apply IH => i Hi.

  now apply (Heq (S i)), lt_n_S.

Qed.



Lemma RInt_val_comp_opp (f : R -> V) (a b : R) (n : nat) :

  RInt_val (fun x => f (- x)) a b n = opp (RInt_val f (- a) (- b) n).

Proof.

  rewrite /RInt_val.

  replace (unif_part (- a) (- b) n) with (map Ropp (unif_part a b n)).

  elim: (unif_part a b n) {1}0 {2}0 => /= [ | x1 s IH] x0 x0'.

  rewrite /Riemann_sum /=.

  by apply sym_eq, @opp_zero.

  destruct s as [ | x2 s].

  rewrite /Riemann_sum /=.

  by apply sym_eq, @opp_zero.

  rewrite (SF_cons_f2 _ x1) ; try by apply lt_O_Sn.

  rewrite (SF_cons_f2 _ (- x1)) ; try by apply lt_O_Sn.

  rewrite !Riemann_sum_cons /=.

  rewrite opp_plus.

  apply f_equal2.

  rewrite -scal_opp_l.

  apply (f_equal2 (fun x y => scal x (f y))) ;

    rewrite /Rdiv /opp /= ; field.

  by apply IH.

  apply eq_from_nth with 0.

  by rewrite size_map !size_mkseq.

  rewrite size_map => i Hi.

  rewrite (nth_map 0 0) => //.

  rewrite size_mkseq in Hi.

  rewrite !nth_mkseq => //.

  field.

  now rewrite -S_INR ; apply not_0_INR, sym_not_eq, O_S.

Qed.



Lemma RInt_val_comp_lin (f : R -> V) (u v : R) (a b : R) (n : nat) :

  scal u (RInt_val (fun x => f (u * x + v)) a b n) = RInt_val f (u * a + v) (u * b + v) n.

Proof.

  rewrite /RInt_val.

  replace (unif_part (u * a + v) (u * b + v) n) with (map (fun x => u * x + v) (unif_part a b n)).

  elim: (unif_part a b n) {1}0 {2}0 => /= [ | x1 s IH] x0 x0'.

  by apply @scal_zero_r.

  destruct s as [ | x2 s].

  by apply @scal_zero_r.

  rewrite (SF_cons_f2 _ x1) ; try by apply lt_O_Sn.

  rewrite (SF_cons_f2 _ (u * x1 + v)) ; try by apply lt_O_Sn.

  rewrite !Riemann_sum_cons /=.

  rewrite scal_distr_l.

  apply f_equal2.

  rewrite scal_assoc.

  apply (f_equal2 (fun x y => scal x (f y))) ;

    rewrite /mult /= ; field.

  by apply IH.

  apply eq_from_nth with 0.

  by rewrite size_map !size_mkseq.

  rewrite size_map => i Hi.

  rewrite (nth_map 0 0) => //.

  rewrite size_mkseq in Hi.

  rewrite !nth_mkseq => //.

  field.

  now rewrite -S_INR ; apply not_0_INR, sym_not_eq, O_S.

Qed.



End RInt_val.



Fixpoint seq_cut_down' (s : seq (R*R)) (x x0 : R) : seq (R*R) :=

  match s with

    | [::] => [:: (x,x0)]

    | h :: t =>

        match Rle_dec (fst h) x with

          | right _ => [:: (x,snd h)]

          | left _ => h :: (seq_cut_down' t x (snd h))

        end

  end.

Fixpoint seq_cut_up' (s : seq (R*R)) (x x0 : R) : seq (R*R) :=

  match s with

    | [::] => [:: (x,x0)]

    | h :: t =>

        match Rle_dec (fst h) x with

          | right _ => (x,x0)::h::t

          | left _ => seq_cut_up' t x (snd h)

        end

  end.



Definition SF_cut_down' (sf : @SF_seq R) (x : R) x0 :=

  let s := seq_cut_down' ((SF_h sf,x0) :: (SF_t sf)) x x0 in

  mkSF_seq (fst (head (SF_h sf,x0) s)) (behead s).

Definition SF_cut_up' (sf : @SF_seq R) (x : R) x0 :=

  let s := seq_cut_up' ((SF_h sf,x0) :: (SF_t sf)) x x0 in

  mkSF_seq (fst (head (SF_h sf,x0) s)) (behead s).

Lemma SF_Chasles {V : ModuleSpace R_AbsRing} (f : R -> V) (s : SF_seq) x x0 :

  (SF_h s <= x <= last (SF_h s) (unzip1 (SF_t s))) ->

  Riemann_sum f s =

  plus (Riemann_sum f (SF_cut_down' s x x0)) (Riemann_sum f (SF_cut_up' s x x0)).

Proof.

  rename x0 into z0.

  apply SF_cons_ind with (s := s) => {s} /= [ x0 | [x0 y0] s IH] /= Hx.

  rewrite (Rle_antisym _ _ (proj1 Hx) (proj2 Hx)).

  move: (Rle_refl x).

  rewrite /SF_cut_down' /SF_cut_up' /= ; case: Rle_dec => //= _ _.

  by rewrite /Riemann_sum /= Rminus_eq_0 scal_zero_l !plus_zero_l.

  move: (fun Hx1 => IH (conj Hx1 (proj2 Hx))) => {IH}.

  rewrite /SF_cut_down' /SF_cut_up' /= ;

  case: (Rle_dec x0 _) (proj1 Hx) => //= Hx0 _.

  case: (Rle_dec (SF_h s) x) => //= Hx1 IH.

  move: (IH Hx1) => {IH} IH.

  rewrite (Riemann_sum_cons _ (x0,y0))

    (Riemann_sum_cons _ (x0,y0) (mkSF_seq (SF_h s) (seq_cut_down' (SF_t s) x y0)))

    IH /= => {IH}.

  rewrite -!plus_assoc ; apply f_equal.

  assert (forall x0 y0, fst (head (x0, z0) (seq_cut_up' (SF_t s) x y0)) = x).

    elim: (SF_t s) => [ | x2 t IH] x1 y1 //=.

    by case: Rle_dec.

  rewrite ?H.

  move: (proj2 Hx) Hx1 => {Hx} ;

  apply SF_cons_dec with (s := s) => {s H} /= [x1 | [x1 y1] s] //= Hx Hx1.

  by rewrite /Riemann_sum /= (Rle_antisym _ _ Hx Hx1) Rminus_eq_0 !scal_zero_l !plus_zero_l.

  case: Rle_dec => //.

  rewrite Riemann_sum_cons (Riemann_sum_cons _ (x,y0) s) {2}/Riemann_sum /=.

  clear IH.

  rewrite plus_zero_r !plus_assoc.

  apply f_equal2 => //.

  rewrite -scal_distr_r.

  apply f_equal2 => //.

  rewrite /plus /= ; ring.

Qed.



Lemma seq_cut_up_head' (s : seq (R*R)) x x0 z :

  fst (head z (seq_cut_up' s x x0)) = x.

Proof.

  elim: s z x0 => [ | x1 s IH] //= z x0.

  by case: Rle_dec.

Qed.



Lemma ad_SF_compat z0 (s : SF_seq) (pr : SF_sorted Rle s) :

  adapted_couple (SF_fun s z0) (head 0 (SF_lx s)) (last 0 (SF_lx s))

    (seq2Rlist (SF_lx s)) (seq2Rlist (SF_ly s)).

Proof.



  have H : ((head 0 (SF_lx s)) <= (last 0 (SF_lx s))).

    move: pr ; rewrite /SF_sorted.

    case: (SF_lx s) => {s} [| h s] Hs.

    apply Rle_refl.

    rewrite -nth0 ; apply sorted_last => // ; apply lt_O_Sn.

  rewrite /adapted_couple ?nth_compat ?size_compat ?nth0 ?nth_last

  /Rmin /Rmax ?SF_size_lx ?SF_size_ly ;

  case: (Rle_dec (head 0 (SF_lx s)) (last 0 (SF_lx s))) => // {H} _ ; intuition.



  apply sorted_compat => //.



  move: i pr H ; apply SF_cons_dec with (s := s)

    => {s} [x0 | h s] i Hs Hi x [Hx0 Hx1].

    by apply lt_n_O in Hi.

  rewrite /SF_fun ?SF_size_cons ?nth_compat -?SF_size_lx ?SF_lx_cons in Hi, Hx0, Hx1 |- *.

  simpl.

  move: h i x {1}z0 Hs Hi Hx0 Hx1 ; apply SF_cons_ind with (s := s)

    => {s} [x1 | h0 s IH] h ; case => [| i ] x z0' Hs Hi Hx0 Hx1 //= ; case: Rlt_dec => Hx' //.

  now contradict Hx' ; apply Rle_not_lt, Rlt_le, Hx0.

  now case: Rle_dec => Hx'' // ; contradict Hx'' ; apply Rlt_le, Hx1.

  now rewrite /= in Hi ; by apply lt_S_n, lt_n_O in Hi.

  now rewrite /= in Hi ; by apply lt_S_n, lt_n_O in Hi.

  now contradict Hx' ; apply Rle_not_lt, Rlt_le, Hx0.

  now case: Rlt_dec => Hx'' //.

  now contradict Hx' ; apply Rle_not_lt, Rlt_le, Rle_lt_trans with (2 := Hx0) ;

  have Hi' : (S i < size (SF_lx (SF_cons h (SF_cons h0 s))))%nat ;

  [ rewrite ?SF_lx_cons /= in Hi |-* ; apply lt_trans with (1 := Hi), lt_n_Sn | ] ;

  apply (sorted_head (SF_lx (SF_cons h (SF_cons h0 s))) (S i) Hs Hi' 0).

  rewrite -(IH h0 i x (snd h)) //=.

  apply Hs.

  rewrite ?SF_lx_cons /= in Hi |-* ; apply lt_S_n, Hi.

Qed.



Definition SF_compat_le (s : @SF_seq R) (pr : SF_sorted Rle s) :

  StepFun (head 0 (SF_lx s)) (last 0 (SF_lx s)).

Proof.

  exists (SF_fun s 0) ; exists (seq2Rlist (SF_lx s)) ; exists (seq2Rlist (SF_ly s)).

  by apply ad_SF_compat.

Defined.



Lemma Riemann_sum_compat f (s : SF_seq) (pr : SF_sorted Rle s) :

  Riemann_sum f s = RiemannInt_SF (SF_compat_le (SF_map f s) (SF_map_sort f s _ pr)).

Proof.

  rewrite /RiemannInt_SF ; case: Rle_dec => // [_ | H].

  move: pr ; apply SF_cons_ind with (s := s) => {s} [x0 | h s IH] pr //=.

  rewrite /= -IH /Riemann_sum /SF_map /= => {IH}.

  rewrite Rmult_comm.

  by apply SF_cons_dec with (s := s).

  apply pr.

  contradict H ; rewrite -nth_last -nth0 ; move: (le_refl (ssrnat.predn (size (SF_lx (SF_map f s))))) ;

  elim: {1 3}(ssrnat.predn (size (SF_lx (SF_map f s)))) => /= [| i IH] Hi.

  apply Rle_refl.

  apply Rle_trans with (1 := IH (le_trans _ _ _ (le_n_Sn i) Hi)), (sorted_nth Rle) ;

  intuition.

  by apply SF_map_sort.

Qed.



Lemma ad_SF_val_fun (f : R -> R) (a b : R) (n : nat) :

  ((a <= b) -> adapted_couple (SF_val_fun f a b n) a b

      (seq2Rlist (unif_part a b n)) (seq2Rlist (SF_val_ly f a b n)))

  /\ (~(a <= b) -> adapted_couple (SF_val_fun f b a n) a b

      (seq2Rlist (unif_part b a n)) (seq2Rlist (SF_val_ly f b a n))).

Proof.

  wlog : a b / (a <= b) => Hw.

    split ; case: (Rle_dec a b) => // Hab _.

    by apply Hw.

    apply StepFun_P2 ; apply Hw ; by apply Rlt_le, Rnot_le_lt.

  split ; case: (Rle_dec a b) => // {Hw} Hab _.



  have : (a = head 0 (SF_lx (SF_val_seq f a b n))) ;

  [rewrite SF_lx_f2 /= ; (try by apply lt_O_Sn) ; field ; apply Rgt_not_eq ; intuition | move => {2}->].

  pattern b at 3 ; replace b with (last 0 (SF_lx (SF_val_seq f a b n))).

  rewrite -(SF_lx_f2 (fun x y => f ((x+y)/2)) (unif_part a b n)) ; try by apply lt_O_Sn.

  rewrite /SF_val_ly -SF_ly_f2.

  unfold SF_val_fun, SF_fun_f2.

  replace (SF_seq_f2 (fun x y : R => f ((x + y) / 2)) (unif_part a b n))

    with (SF_val_seq f a b n) by auto.

  apply (ad_SF_compat _ (SF_val_seq f a b n)).

  by apply SF_sorted_f2, unif_part_sort.

  rewrite SF_lx_f2 ;

    replace (head 0 (unif_part a b n) :: behead (unif_part a b n))

    with (unif_part a b n) by auto.

    rewrite -nth_last size_mkseq nth_mkseq ?S_INR //= ;

    field ; apply Rgt_not_eq, INRp1_pos.

  now rewrite size_mkseq ; apply lt_O_Sn.

Qed.



Definition sf_SF_val_fun (f : R -> R) (a b : R) (n : nat) : StepFun a b.

Proof.

  case : (Rle_dec a b) => Hab.

  exists (SF_val_fun f a b n) ;

  exists (seq2Rlist (unif_part a b n)) ;

  exists (seq2Rlist (SF_val_ly f a b n)) ; by apply ad_SF_val_fun.

  exists (SF_val_fun f b a n) ;

  exists (seq2Rlist (unif_part b a n)) ;

  exists (seq2Rlist (SF_val_ly f b a n)) ; by apply ad_SF_val_fun.

Defined.

Lemma SF_val_subdiv (f : R -> R) (a b : R) (n : nat) :

  subdivision (sf_SF_val_fun f a b n) =

  match (Rle_dec a b) with

    | left _ => seq2Rlist (unif_part a b n)

    | right _ => seq2Rlist (unif_part b a n)

  end.

Proof.

  rewrite /sf_SF_val_fun ; case: (Rle_dec a b) => Hab //.

Qed.

Lemma SF_val_subdiv_val (f : R -> R) (a b : R) (n : nat) :

  subdivision_val (sf_SF_val_fun f a b n) =

  match (Rle_dec a b) with

    | left _ => seq2Rlist (SF_val_ly f a b n)

    | right _ => seq2Rlist (SF_val_ly f b a n)

  end.

Proof.

  rewrite /sf_SF_val_fun ; case: (Rle_dec a b) => Hab //.

Qed.



Lemma SF_val_fun_rw (f : R -> R) (a b : R) (n : nat) (x : R) (Hx : a <= x <= b) :

  SF_val_fun f a b n x =

    match (unif_part_nat a b n x Hx) with

      | inleft H => f (a + (INR (proj1_sig H) + /2) * (b-a) / (INR n + 1))

      | inright _ => f (a + (INR n + /2) * (b-a) / (INR n + 1))

    end.

Proof.

  have Hab : (a <= b) ; [by apply Rle_trans with (1 := proj1 Hx), Hx | ].

  case: unif_part_nat => {Hx} [ [ i [Hx Hi] ] | Hx] /=.



  rewrite /SF_val_fun /SF_fun_f2.

  replace (a + (INR i + /2) * (b - a) / (INR n+1))

    with ((nth 0 (unif_part a b n) i + nth 0 (unif_part a b n) (S i)) / 2) ;

    [ | rewrite size_mkseq in Hi ; rewrite ?nth_mkseq ?S_INR ;

    [field ; apply Rgt_not_eq | apply SSR_leq | apply SSR_leq ] ; intuition].

  case: (unif_part a b n) (unif_part_sort a b n Hab) i Hi x Hx => {a b Hab n} [| h s] Hs /= i Hi.

    by apply lt_n_O in Hi.

  case: (s) Hs (i) (lt_S_n _ _ Hi) => {s i Hi} [| h0 s] Hs /= i Hi.

    by apply lt_n_O in Hi.

  elim: (s) h h0 Hs (i) (lt_S_n _ _ Hi) => {s i Hi} [|h1 s IH] h h0 Hs /= i Hi x Hx.

    by apply lt_n_O in Hi.

  case: i Hx Hi => [|i]/= Hx Hi.

  rewrite /SF_fun /=.

  case: Rlt_dec => [Hx0 | _ ].

  contradict Hx0 ; apply Rle_not_lt, Hx.

  case: Rlt_dec => // Hx0 ; contradict Hx0 ; apply Hx.

  rewrite -(IH h0 h1 (proj2 Hs) i (lt_S_n _ _ Hi) x Hx).

  rewrite /SF_fun /= ; case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (1 := proj1 Hs),

  Rle_trans with (2 := proj1 Hx), (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ;

  simpl; intuition.

  case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hx),

  (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ; simpl; intuition.



  replace (a + (INR n + /2) * (b - a) / (INR n + 1))

    with ((nth 0 (unif_part a b n) (n) + nth 0 (unif_part a b n) (S n)) / 2) ;

    [ | rewrite ?nth_mkseq ?minus_INR ?S_INR /= ;

    [field ; apply Rgt_not_eq |

    apply SSR_leq | apply SSR_leq ] ; intuition].

  suff : (1 < size (unif_part a b n))%nat.

  move: x Hx ; have: (n = size (unif_part a b n) - 2)%nat ;

    [ rewrite size_mkseq ; intuition | ].

    move => {2 4 8 10}->.

  rewrite /SF_val_fun /SF_fun_f2.

  case: (unif_part a b n) (unif_part_sort a b n Hab) => {a b Hab n} [| h s Hs x Hx /= Hi] .

  intros _ x Hx Hi.

  by apply lt_n_O in Hi.

  case: s h Hs Hi x Hx => [| h0 s] h Hs /= Hi.

  by apply lt_irrefl in Hi.

  elim: s h h0 Hs {Hi} => [| h1 s IH] h h0 Hs /= x Hx.

  rewrite /SF_fun /= ; case: Rlt_dec => [Hx0 | _].

  contradict Hx0 ; apply Rle_not_lt, Hx.

  case: Rle_dec => [| Hx0] // ; contradict Hx0 ; apply Hx.

  rewrite -minus_n_O in IH.

  rewrite -(IH h0 h1 (proj2 Hs) x Hx ).

  rewrite /SF_fun /= ; case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (1 := proj1 Hs),

  Rle_trans with (2 := proj1 Hx), (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ;

  simpl; intuition.

  case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hx),

  (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ; simpl; intuition.

  rewrite size_mkseq ; by apply lt_n_S, lt_O_Sn.

Qed.



Lemma RInt_val_Reals (f : R -> R) (a b : R) (n : nat) :

  RInt_val f a b n = RiemannInt_SF (sf_SF_val_fun f a b n).

Proof.

rewrite /RiemannInt_SF SF_val_subdiv SF_val_subdiv_val ;

case: Rle_dec => Hab.



  rewrite /RInt_val /SF_val_ly ; case: (unif_part a b n) => [| h s] /=.

  by [].

  elim: s h => [|h0 s IH] h /=.

  by [].

  rewrite (SF_cons_f2 _ h).

  2: by apply lt_O_Sn.

  rewrite Riemann_sum_cons /= IH /plus /scal /= /mult /=.

  ring.



  rewrite RInt_val_swap /SF_val_ly /RInt_val.

  simpl opp ; apply f_equal.

  case: (unif_part b a n) => [| h s] /=.

  by [].

  elim: s h => [|h0 s IH] h /=.

  by [].

  rewrite SF_cons_f2.

  2: by apply lt_O_Sn.

  rewrite Riemann_sum_cons IH /= /plus /scal /= /mult /=.

  ring.

Qed.



Lemma ex_Im_fct (f : R -> R) (a b : R) : a <> b ->

  exists x, (fun y => exists x, y = f x /\ Rmin a b < x < Rmax a b) x.

Proof.

  exists (f ((a+b)/2)) ; exists ((a+b)/2) ; split.

  by [].

  rewrite /Rmin /Rmax.

  case Rle_dec ; lra.

Qed.



Definition Sup_fct (f : R -> R) (a b : R) : Rbar :=

  match Req_EM_T a b with

    | right Hab => Lub_Rbar (fun y => exists x, y = f x /\ Rmin a b < x < Rmax a b)

    | left _ => Finite 0

  end.

Definition Inf_fct (f : R -> R) (a b : R) : Rbar :=

  match Req_EM_T a b with

    | right Hab => Glb_Rbar (fun y => exists x, y = f x /\ Rmin a b < x < Rmax a b)

    | left _ => Finite 0

  end.



Lemma Sup_fct_bound (f : R -> R) (a b : R) :

  Sup_fct f a b = Sup_fct f b a.

Proof.

  rewrite /Sup_fct /= ;

  case: Req_EM_T => Hab ;

  case: Req_EM_T => Hba.

  by [].

  by apply sym_equal in Hab.

  by apply sym_equal in Hba.

  apply Lub_Rbar_eqset => x ;

  by rewrite Rmin_comm Rmax_comm.

Qed.

Lemma Inf_fct_bound (f : R -> R) (a b : R) :

  Inf_fct f a b = Inf_fct f b a.

Proof.

  rewrite /Inf_fct /= ;

  case: Req_EM_T => Hab ;

  case: Req_EM_T => Hba.

  by [].

  by apply sym_equal in Hab.

  by apply sym_equal in Hba.

  apply Glb_Rbar_eqset => x ;

  by rewrite Rmin_comm Rmax_comm.

Qed.



Lemma Sup_fct_le (f : R -> R) (a b : R) (x : R) :

  (Rmin a b < x < Rmax a b) ->

    Rbar_le (Finite (f x)) (Sup_fct f a b).

Proof.

  move => Hx ; rewrite /Sup_fct.

  case: Req_EM_T => Hab.

  move: (Rlt_trans _ _ _ (proj1 Hx) (proj2 Hx)) => {Hx} ;

  rewrite /Rmin /Rmax ;

  case: Rle_dec (Req_le _ _ Hab) => //= _ _ Hx.

  contradict Hx ; by apply Rle_not_lt, Req_le.

  rewrite /Lub_Rbar ;

  case: ex_lub_Rbar => l lub ;

  apply lub ; exists x ; split ; by [].

Qed.

Lemma Inf_fct_le (f : R -> R) (a b : R) (x : R) : (Rmin a b < x < Rmax a b) ->

  Rbar_le (Inf_fct f a b) (Finite (f x)).

Proof.

  move => Hx ; rewrite /Inf_fct.

  case: Req_EM_T => Hab.

  move: (Rlt_trans _ _ _ (proj1 Hx) (proj2 Hx)) => {Hx} ;

  rewrite /Rmin /Rmax ;

  case: Rle_dec (Req_le _ _ Hab) => //= _ _ Hx.

  contradict Hx ; by apply Rle_not_lt, Req_le.

  rewrite /Glb_Rbar ;

  case: ex_glb_Rbar => l lub ;

  apply lub ; exists x ; split ; by [].

Qed.



Lemma Sup_fct_maj (f : R -> R) (a b : R) (M : R) :

  (forall x, Rmin a b < x < Rmax a b -> f x <= M) ->

  is_finite (Sup_fct f a b).

Proof.

  rewrite /Sup_fct ; case: Req_EM_T => Hab Hf.

  by [].

  rewrite /Lub_Rbar ;

  case: ex_lub_Rbar ; case => [l | | ] [lub ub] /=.

  by [].

  case: (ub (Finite M)) => //.

  move => _ [x [-> Hx]].

  by apply Hf.

  case: (lub (f((a+b)/2))) => //.

  exists ((a + b) / 2) ; split.

  by [].

  rewrite /Rmin /Rmax.

  case Rle_dec ; lra.

Qed.

Lemma Inf_fct_min (f : R -> R) (a b : R) (m : R) :

  (forall x, Rmin a b < x < Rmax a b -> m <= f x) ->

  is_finite (Inf_fct f a b).

Proof.

  rewrite /Inf_fct ; case: Req_EM_T => Hab Hf.

  by [].

  rewrite /Glb_Rbar ;

  case: ex_glb_Rbar ; case => [l | | ] [lub ub] /=.

  by [].

  case: (lub (f((a+b)/2))) => //.

  exists ((a + b) / 2) ; split.

  by [].

  rewrite /Rmin /Rmax.

  case Rle_dec ; lra.

  case: (ub (Finite m)) => //.

  move => _ [x [-> Hx]].

  by apply Hf.

Qed.



Definition SF_sup_seq (f : R -> R) (a b : R) (n : nat) : SF_seq :=

  SF_seq_f2 (Sup_fct f) (unif_part a b n).

Lemma SF_sup_lx (f : R -> R) (a b : R) (n : nat) :

  SF_lx (SF_sup_seq f a b n) = unif_part a b n.

Proof.

  apply SF_lx_f2.

  now apply lt_O_Sn.

Qed.

Lemma SF_sup_ly (f : R -> R) (a b : R) (n : nat) :

  SF_ly (SF_sup_seq f a b n) = behead (pairmap (Sup_fct f) 0 (unif_part a b n)).

Proof.

  by apply SF_ly_f2.

Qed.



Definition SF_inf_seq (f : R -> R) (a b : R) (n : nat) : SF_seq :=

  SF_seq_f2 (Inf_fct f) (unif_part a b n).

Lemma SF_inf_lx (f : R -> R) (a b : R) (n : nat) :

  SF_lx (SF_inf_seq f a b n) = unif_part a b n.

Proof.

  by apply SF_lx_f2, lt_O_Sn.

Qed.

Lemma SF_inf_ly (f : R -> R) (a b : R) (n : nat) :

  SF_ly (SF_inf_seq f a b n) = behead (pairmap (Inf_fct f) 0 (unif_part a b n)).

Proof.

  by apply SF_ly_f2.

Qed.



Lemma SF_sup_bound (f : R -> R) (a b : R) (n : nat) :

  SF_rev (SF_sup_seq f a b n) = SF_sup_seq f b a n.

Proof.

  rewrite /SF_sup_seq unif_part_bound => //.

  rewrite SF_rev_f2 ?revK //.

  move => x y ; apply Sup_fct_bound.

Qed.

Lemma SF_inf_bound (f : R -> R) (a b : R) (n : nat) :

  SF_rev (SF_inf_seq f a b n) = SF_inf_seq f b a n.

Proof.

  rewrite /SF_inf_seq unif_part_bound => //.

  rewrite SF_rev_f2 ?revK //.

  move => x y ; apply Inf_fct_bound.

Qed.



Definition SF_sup_fun (f : R -> R) (a b : R) (n : nat) (x : R) : Rbar :=

  match (Rle_dec a b) with

    | left _ => SF_fun (SF_sup_seq f a b n) (Finite 0) x

    | right _ => SF_fun (SF_sup_seq f b a n) (Finite 0) x

  end.

Definition SF_inf_fun (f : R -> R) (a b : R) (n : nat) (x : R) : Rbar :=

  match (Rle_dec a b) with

    | left _ => SF_fun (SF_inf_seq f a b n) (Finite 0) x

    | right _ => SF_fun (SF_inf_seq f b a n) (Finite 0) x

  end.



Lemma SF_sup_fun_bound (f : R -> R) (a b : R) (n : nat) (x : R) :

  SF_sup_fun f a b n x = SF_sup_fun f b a n x.

Proof.

  rewrite /SF_sup_fun ; case: (Rle_dec a b) => Hab ; case : (Rle_dec b a) => Hba //.

  by rewrite (Rle_antisym _ _ Hab Hba).

  by contradict Hba ; apply Rlt_le, Rnot_le_lt.

Qed.

Lemma SF_inf_fun_bound (f : R -> R) (a b : R) (n : nat) (x : R) :

  SF_inf_fun f a b n x = SF_inf_fun f b a n x.

Proof.

  rewrite /SF_inf_fun ; case: (Rle_dec a b) => Hab ; case : (Rle_dec b a) => Hba //.

  by rewrite (Rle_antisym _ _ Hab Hba).

  by contradict Hba ; apply Rlt_le, Rnot_le_lt.

Qed.



Lemma SF_sup_fun_rw (f : R -> R) (a b : R) (n : nat) (x : R) (Hx : a <= x <= b) :

  SF_sup_fun f a b n x =

    match (unif_part_nat a b n x Hx) with

      | inleft H => Sup_fct f (nth 0 (unif_part a b n) (proj1_sig H))

          (nth 0 (unif_part a b n) (S (proj1_sig H)))

      | inright _ => Sup_fct f (nth 0 (unif_part a b n) (n))

          (nth 0 (unif_part a b n) (S n))

    end.

Proof.

  have Hab : (a <= b) ; [by apply Rle_trans with (1 := proj1 Hx), Hx | ].

  rewrite /SF_sup_fun /SF_sup_seq ; case: Rle_dec => // _.

  case: unif_part_nat => {Hx} [ [ i [Hx Hi] ] | Hx] ; simpl proj1_sig.



  case: (unif_part a b n) (unif_part_sort a b n Hab) i Hi x Hx => {a b Hab n} [| h s] Hs /= i Hi.

    by apply lt_n_O in Hi.

  case: (s) Hs (i) (lt_S_n _ _ Hi) => {s i Hi} [| h0 s] Hs /= i Hi.

    by apply lt_n_O in Hi.

  elim: (s) h h0 Hs (i) (lt_S_n _ _ Hi) => {s i Hi} [|h1 s IH] h h0 Hs /= i Hi x Hx.

    by apply lt_n_O in Hi.

  case: i Hx Hi => [|i]/= Hx Hi.

  rewrite /SF_fun /=.

  case: Rlt_dec => [Hx0 | _ ].

  contradict Hx0 ; apply Rle_not_lt, Hx.

  case: Rlt_dec => // Hx0 ; contradict Hx0 ; apply Hx.

  rewrite -(IH h0 h1 (proj2 Hs) i (lt_S_n _ _ Hi) x Hx).

  rewrite /SF_fun /= ; case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (1 := proj1 Hs),

  Rle_trans with (2 := proj1 Hx), (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ;

  simpl; intuition.

  case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hx),

  (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ; simpl; intuition.



  move: x Hx.

  suff : (1 < size (unif_part a b n))%nat.

  have: (n = size (unif_part a b n) - 2)%nat ;

    [ rewrite size_mkseq ; intuition | move => {3 5 8 10}->].

  case: (unif_part a b n) (unif_part_sort a b n Hab) => {a b Hab n} [| h s] Hs /= Hi.

  by apply lt_n_O in Hi.

  case: s h Hs Hi => [| h0 s] h Hs /= Hi.

  by apply lt_irrefl in Hi.

  rewrite -minus_n_O ; elim: s h h0 Hs {Hi} => [| h1 s IH] h h0 Hs /= x Hx.

  rewrite /SF_fun /= ; case: Rlt_dec => [Hx0 | _].

  contradict Hx0 ; apply Rle_not_lt, Hx.

  case: Rle_dec => [| Hx0] // ; contradict Hx0 ; apply Hx.

  rewrite -(IH h0 h1 (proj2 Hs) x Hx).

  rewrite /SF_fun /= ; case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (1 := proj1 Hs),

  Rle_trans with (2 := proj1 Hx), (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ;

  simpl; intuition.

  case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hx),

  (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ; simpl; intuition.

  rewrite size_mkseq ; by apply lt_n_S, lt_O_Sn.

Qed.



Lemma SF_inf_fun_rw (f : R -> R) (a b : R) (n : nat) (x : R) (Hx : a <= x <= b) :

  SF_inf_fun f a b n x =

    match (unif_part_nat a b n x Hx) with

      | inleft H => Inf_fct f (nth 0 (unif_part a b n) (proj1_sig H))

          (nth 0 (unif_part a b n) (S (proj1_sig H)))

      | inright _ => Inf_fct f (nth 0 (unif_part a b n) (n))

          (nth 0 (unif_part a b n) (S n))

    end.

Proof.

  have Hab : (a <= b) ; [by apply Rle_trans with (1 := proj1 Hx), Hx | ].

  rewrite /SF_inf_fun /SF_inf_seq ; case: Rle_dec => // _.

  case: unif_part_nat => {Hx} [ [ i [Hx Hi] ] | Hx] ; simpl proj1_sig.



  case: (unif_part a b n) (unif_part_sort a b n Hab) i Hi x Hx => {a b Hab n} [| h s] Hs /= i Hi.

    by apply lt_n_O in Hi.

  case: (s) Hs (i) (lt_S_n _ _ Hi) => {s i Hi} [| h0 s] Hs /= i Hi.

    by apply lt_n_O in Hi.

  elim: (s) h h0 Hs (i) (lt_S_n _ _ Hi) => {s i Hi} [|h1 s IH] h h0 Hs /= i Hi x Hx.

    by apply lt_n_O in Hi.

  case: i Hx Hi => [|i]/= Hx Hi.

  rewrite /SF_fun /=.

  case: Rlt_dec => [Hx0 | _ ].

  contradict Hx0 ; apply Rle_not_lt, Hx.

  case: Rlt_dec => // Hx0 ; contradict Hx0 ; apply Hx.

  rewrite -(IH h0 h1 (proj2 Hs) i (lt_S_n _ _ Hi) x Hx).

  rewrite /SF_fun /= ; case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (1 := proj1 Hs),

  Rle_trans with (2 := proj1 Hx), (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ;

  simpl; intuition.

  case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hx),

  (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ; simpl; intuition.



  move: x Hx.

  suff : (1 < size (unif_part a b n))%nat.

  have: (n = size (unif_part a b n) - 2)%nat ;

    [ rewrite size_mkseq ; intuition | move => {3 5 8 10}->].

  case: (unif_part a b n) (unif_part_sort a b n Hab) => {a b Hab n} [| h s] Hs /= Hi.

  by apply lt_n_O in Hi.

  case: s h Hs Hi => [| h0 s] h Hs /= Hi.

  by apply lt_irrefl in Hi.

  rewrite -minus_n_O ; elim: s h h0 Hs {Hi} => [| h1 s IH] h h0 Hs /= x Hx.

  rewrite /SF_fun /= ; case: Rlt_dec => [Hx0 | _].

  contradict Hx0 ; apply Rle_not_lt, Hx.

  case: Rle_dec => [| Hx0] // ; contradict Hx0 ; apply Hx.

  rewrite -(IH h0 h1 (proj2 Hs) x Hx).

  rewrite /SF_fun /= ; case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (1 := proj1 Hs),

  Rle_trans with (2 := proj1 Hx), (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ;

  simpl; intuition.

  case: Rlt_dec => [ Hx0 | _ ] //.

  contradict Hx0 ; apply Rle_not_lt, Rle_trans with (2 := proj1 Hx),

  (sorted_head [:: h0, h1 & s] _ (proj2 Hs)) ; simpl; intuition.

  rewrite size_mkseq ; by apply lt_n_S, lt_O_Sn.

Qed.



Lemma ad_SF_sup_r (f : R -> R) (a b : R) (n : nat) :

  ((a <= b) -> adapted_couple (fun x => real (SF_sup_fun f a b n x)) a b

      (seq2Rlist (unif_part a b n))

      (seq2Rlist (behead (pairmap (fun x y => real (Sup_fct f x y)) 0 (unif_part a b n)))))

  /\ (~(a <= b) -> adapted_couple (fun x => real (SF_sup_fun f a b n x)) a b

      (seq2Rlist (unif_part b a n))

      (seq2Rlist (behead (pairmap (fun x y => real (Sup_fct f x y)) 0 (unif_part b a n))))).

Proof.

  wlog : a b / (a <= b) => [Hw|Hab].

  case: (Rle_dec a b) => // Hab ; split => // _.

    by apply (Hw a b).

    apply Rnot_le_lt, Rlt_le in Hab ;

    case : (Hw b a Hab) => {Hw} Hw _ ;

    move: (Hw Hab) => {Hw} Hw ;

    rewrite /adapted_couple in Hw |-* ; rewrite Rmin_comm Rmax_comm ;

    intuition => x Hx ; rewrite SF_sup_fun_bound ; by apply H4.

  split ; case: (Rle_dec a b)=> // _ _.

  rewrite /SF_sup_fun ; case: (Rle_dec a b) => // _.

  have Hs : (SF_sorted Rle (SF_map real (SF_sup_seq f a b n))).

    rewrite /SF_sorted SF_map_lx SF_lx_f2.

    replace (head 0 (unif_part a b n) :: behead (unif_part a b n))

    with (unif_part a b n) by intuition.

    by apply unif_part_sort.

    by apply lt_O_Sn.

  have {2}<-: head 0 (unif_part a b n) = a.

    apply head_unif_part.

  have {3}<-: last 0 (unif_part a b n) = b.

    apply last_unif_part.

  replace (behead

    (pairmap (fun x y : R => real (Sup_fct f x y)) 0 (unif_part a b n)))

    with (SF_ly (SF_map real (SF_sup_seq f a b n))).

  replace (unif_part a b n)

  with (SF_lx (SF_map real (SF_sup_seq f a b n))).

  move: (ad_SF_compat (f ((0+0)/2)) (SF_map real (SF_sup_seq f a b n)) Hs) ;

  rewrite /adapted_couple => Had ; intuition.

  move: (H4 i H3) => {H4} H3' x H4.

  move: (H3' x H4) => {H3'} <-.

  rewrite -(SF_fun_map real).



  2: rewrite SF_map_lx SF_lx_f2 // ; by apply lt_O_Sn.

  2: rewrite SF_map_ly SF_ly_f2 ;

  by rewrite -behead_map map_pairmap.



  move: H3 H4.

  rewrite /SF_sup_seq.

  rewrite !nth_compat size_compat SF_map_lx SF_lx_f2.

  2: apply lt_O_Sn.

  unfold SF_fun.

  elim: (unif_part a b n) (unif_part_sort a b n Hab) {3}(0) {1}(f ((0 + 0) / 2)) i => [ | x0 l IH] Hl z0 z1 i Hi Hx.

  by apply lt_n_O in Hi.

  simpl in Hi.

  destruct l as [ | x1 l].

  by apply lt_n_O in Hi.

  rewrite SF_cons_f2.

  2: by apply lt_O_Sn.

  rewrite SF_map_cons.

  case: i Hi Hx => [ | i] Hi /= Hx.

  case: Rlt_dec => Hx0 //.

  contradict Hx0 ; apply Rle_not_lt, Rlt_le, Hx.

  case: (l)  => [ | x2 l'] /=.

  case: Rle_dec => // Hx1.

  contradict Hx1 ; by apply Rlt_le, Hx.

  case: Rlt_dec (proj2 Hx) => //.

  case: Rlt_dec => //= Hx0.

  contradict Hx0.

  apply Rle_not_lt, Rlt_le.

  eapply Rle_lt_trans, Hx.

  eapply Rle_trans, sorted_head.

  by apply Hl.

  by apply Hl.

  eapply lt_trans, Hi.

  by apply lt_n_Sn.

  eapply (IH (proj2 Hl) (Sup_fct f x0 x1) (Sup_fct f x0 x1)).

  2: apply Hx.

  simpl ; by apply lt_S_n.

Qed.



Definition SF_sup_r (f : R -> R) (a b : R) (n : nat) : StepFun a b.

Proof.

  exists (fun x => real (SF_sup_fun f a b n x)) ;

  case : (Rle_dec a b) => Hab.

  exists (seq2Rlist (unif_part a b n)) ;

  exists (seq2Rlist (behead (pairmap (fun x y => real (Sup_fct f x y)) 0 (unif_part a b n)))) ;

  by apply ad_SF_sup_r.

  exists (seq2Rlist ((unif_part b a n))) ;

  exists (seq2Rlist (behead (pairmap (fun x y => real (Sup_fct f x y)) 0 (unif_part b a n)))) ;

  by apply ad_SF_sup_r.

Defined.

Lemma SF_sup_subdiv (f : R -> R) (a b : R) (n : nat) :

  subdivision (SF_sup_r f a b n) =

  match (Rle_dec a b) with

    | left _ => seq2Rlist (unif_part a b n)

    | right _ => seq2Rlist (unif_part b a n)

  end.

Proof.

  rewrite /SF_sup_r ; case: (Rle_dec a b) => Hab //.

Qed.

Lemma SF_sup_subdiv_val (f : R -> R) (a b : R) (n : nat) :

  subdivision_val (SF_sup_r f a b n) =

  match (Rle_dec a b) with

    | left _ => (seq2Rlist (behead (pairmap (fun x y => real (Sup_fct f x y)) 0 (unif_part a b n))))

    | right _ => (seq2Rlist (behead (pairmap (fun x y => real (Sup_fct f x y)) 0 (unif_part b a n))))

  end.

Proof.

  rewrite /SF_sup_r ; case: (Rle_dec a b) => Hab //.

Qed.



Lemma SF_sup_r_bound (f : R -> R) (a b : R) (n : nat) :

  forall x, SF_sup_r f a b n x = SF_sup_r f b a n x.

Proof.

  move => x /= ; by rewrite SF_sup_fun_bound.

Qed.



Lemma ad_SF_inf_r (f : R -> R) (a b : R) (n : nat) :

  ((a <= b) -> adapted_couple (fun x => real (SF_inf_fun f a b n x)) a b

      (seq2Rlist (unif_part a b n))

      (seq2Rlist (behead (pairmap (fun x y => real (Inf_fct f x y)) 0 (unif_part a b n)))))

  /\ (~(a <= b) -> adapted_couple (fun x => real (SF_inf_fun f a b n x)) a b

      (seq2Rlist (unif_part b a n))

      (seq2Rlist (behead (pairmap (fun x y => real (Inf_fct f x y)) 0 (unif_part b a n))))).

Proof.

  wlog : a b / (a <= b) => [Hw|Hab].

  case: (Rle_dec a b) => // Hab ; split => // _.

    by apply (Hw a b).

    apply Rnot_le_lt, Rlt_le in Hab ;

    case : (Hw b a Hab) => {Hw} Hw _ ;

    move: (Hw Hab) => {Hw} Hw ;

    rewrite /adapted_couple in Hw |-* ; rewrite Rmin_comm Rmax_comm ;

    intuition => x Hx ; rewrite SF_inf_fun_bound ; by apply H4.

  split ; case: (Rle_dec a b)=> // _ _.

  rewrite /SF_inf_fun ; case: (Rle_dec a b) => // _.

  have Hs : (SF_sorted Rle (SF_map real (SF_inf_seq f a b n))).

    rewrite /SF_sorted SF_map_lx SF_lx_f2.

    replace (head 0 (unif_part a b n) :: behead (unif_part a b n))

    with (unif_part a b n) by intuition.

    by apply unif_part_sort.

    by apply lt_O_Sn.

  have {2}<-: head 0 (unif_part a b n) = a.

    apply head_unif_part.

  have {3}<-: last 0 (unif_part a b n) = b.

    apply last_unif_part.

  replace (behead

    (pairmap (fun x y : R => real (Inf_fct f x y)) 0 (unif_part a b n)))

    with (SF_ly (SF_map real (SF_inf_seq f a b n))).

  replace (unif_part a b n)

  with (SF_lx (SF_map real (SF_inf_seq f a b n))).

  move: (ad_SF_compat (f ((0+0)/2)) (SF_map real (SF_inf_seq f a b n)) Hs) ;

  rewrite /adapted_couple => Had ; intuition.

  move: (H4 i H3) => {H4} H3' x H4.

  move: (H3' x H4) => {H3'} <-.

  rewrite -(SF_fun_map real).



  2: rewrite SF_map_lx SF_lx_f2 // ; by apply lt_O_Sn.

  2: rewrite SF_map_ly SF_ly_f2 ;

  by rewrite -behead_map map_pairmap.



  move: H3 H4.

  rewrite /SF_inf_seq.

  rewrite !nth_compat size_compat SF_map_lx SF_lx_f2.

  2: apply lt_O_Sn.

  unfold SF_fun.

  elim: (unif_part a b n) (unif_part_sort a b n Hab) {3}(0) {1}(f ((0 + 0) / 2)) i => [ | x0 l IH] Hl z0 z1 i Hi Hx.

  by apply lt_n_O in Hi.

  simpl in Hi.

  destruct l as [ | x1 l].

  by apply lt_n_O in Hi.

  rewrite SF_cons_f2.

  2: by apply lt_O_Sn.

  rewrite SF_map_cons.

  case: i Hi Hx => [ | i] Hi /= Hx.

  case: Rlt_dec => Hx0 //.

  contradict Hx0 ; apply Rle_not_lt, Rlt_le, Hx.

  case: (l)  => [ | x2 l'] /=.

  case: Rle_dec => // Hx1.

  contradict Hx1 ; by apply Rlt_le, Hx.

  case: Rlt_dec (proj2 Hx) => //.

  case: Rlt_dec => //= Hx0.

  contradict Hx0.

  apply Rle_not_lt, Rlt_le.

  eapply Rle_lt_trans, Hx.

  eapply Rle_trans, sorted_head.

  by apply Hl.

  by apply Hl.

  eapply lt_trans, Hi.

  by apply lt_n_Sn.

  eapply (IH (proj2 Hl) (Inf_fct f x0 x1) (Inf_fct f x0 x1)).

  2: apply Hx.

  simpl ; by apply lt_S_n.

Qed.



Definition SF_inf_r (f : R -> R) (a b : R) (n : nat) : StepFun a b.

Proof.

  exists (fun x => real (SF_inf_fun f a b n x)) ;

  case : (Rle_dec a b) => Hab.

  exists (seq2Rlist (unif_part a b n)) ;

  exists (seq2Rlist (behead (pairmap (fun x y => real (Inf_fct f x y)) 0 (unif_part a b n)))) ;

  by apply ad_SF_inf_r.

  exists (seq2Rlist ((unif_part b a n))) ;

  exists (seq2Rlist (behead (pairmap (fun x y => real (Inf_fct f x y)) 0 (unif_part b a n)))) ;

  by apply ad_SF_inf_r.

Defined.

Lemma SF_inf_subdiv (f : R -> R) (a b : R) (n : nat) :

  subdivision (SF_inf_r f a b n) =

  match (Rle_dec a b) with

    | left _ => seq2Rlist (unif_part a b n)

    | right _ => seq2Rlist (unif_part b a n)

  end.

Proof.

  rewrite /SF_inf_r ; case: (Rle_dec a b) => Hab //.

Qed.

Lemma SF_inf_subdiv_val (f : R -> R) (a b : R) (n : nat) :

  subdivision_val (SF_inf_r f a b n) =

  match (Rle_dec a b) with

    | left _ => (seq2Rlist (behead (pairmap (fun x y => real (Inf_fct f x y)) 0 (unif_part a b n))))

    | right _ => (seq2Rlist (behead (pairmap (fun x y => real (Inf_fct f x y)) 0 (unif_part b a n))))

  end.

Proof.

  rewrite /SF_inf_r ; case: (Rle_dec a b) => Hab //.

Qed.



Lemma SF_inf_r_bound (f : R -> R) (a b : R) (n : nat) :

  forall x, SF_inf_r f a b n x = SF_inf_r f b a n x.

Proof.

  move => x /= ; by rewrite SF_inf_fun_bound.

Qed.

