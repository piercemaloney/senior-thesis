

Require Import Reals.

Require Import mathcomp.ssreflect.ssreflect.

Require Import List.



Require Import Rcomplements.
(* Rcomplements:
Ltac evar_last :=
  match goal with
  | |- ?f ?x =>
    let tx := type of x in
    let tx := eval simpl in tx in
    let tmp := fresh "tmp" in
    evar (tmp : tx) ;
    refine (@eq_ind tx tmp f _ x _) ;
    unfold tmp ; clear tmp
  end.

Require Import Reals mathcomp.ssreflect.ssreflect.
Require Import Psatz.

Module MyNat.

Lemma neq_succ_0 (n : nat) : S n <> 0.

Lemma sub_succ (n m : nat) : S n - S m = n - m.

Lemma sub_succ_l (n m : nat) : n <= m -> S m - n = S (m - n).

Lemma lt_neq (n m : nat) : n < m -> n <> m.

Lemma minus_0_le (n m : nat) : n <= m -> n - m = 0.

Lemma sub_succ_r (n m : nat) : n - S m = pred (n - m).

Lemma sub_add (n m : nat) : n <= m -> m - n + n = m.

Lemma le_pred_le_succ (n m : nat) : pred n <= m <-> n <= S m.

End MyNat.

Require Import Even Div2.
Require Import mathcomp.ssreflect.seq mathcomp.ssreflect.ssrbool.

Open Scope R_scope.

Lemma floor_ex : forall x : R, {n : Z | IZR n <= x < IZR n + 1}.
Definition floor x := proj1_sig (floor_ex x).

Lemma floor1_ex : forall x : R, {n : Z | IZR n < x <= IZR n + 1}.
Definition floor1 x := proj1_sig (floor1_ex x).

Lemma nfloor_ex : forall x : R, 0 <= x -> {n : nat | INR n <= x < INR n + 1}.
Definition nfloor x pr := proj1_sig (nfloor_ex x pr).

Lemma nfloor1_ex : forall x : R, 0 < x -> {n : nat | INR n < x <= INR n + 1}.
Definition nfloor1 x pr := proj1_sig (nfloor1_ex x pr).

Lemma INRp1_pos : forall n, 0 < INR n + 1.

Lemma Rlt_nat (x : R) : (exists n : nat, x = INR (S n)) -> 0 < x.

Lemma Rle_pow_lin (a : R) (n : nat) :
  0 <= a -> 1 + INR n * a <= (1 + a) ^ n.

Lemma C_n_n: forall n, C n n = 1.

Lemma C_n_0: forall n, C n 0 = 1.

Fixpoint pow2 (n : nat) : nat :=
  match n with
    | O => 1%nat
    | S n => (2 * pow2 n)%nat
  end.

Lemma pow2_INR (n : nat) : INR (pow2 n) = 2^n.

Lemma pow2_pos (n : nat) : (0 < pow2 n)%nat.

Lemma Rinv_le_contravar :
  forall x y, 0 < x -> x <= y -> / y <= / x.

Lemma Rinv_lt_cancel (x y : R) :
  0 < y -> / y < / x -> x < y.

Lemma Rdiv_1 : forall x : R, x / 1 = x.

Lemma Rdiv_plus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b + c / d = (a * d + c * b) / (b * d).

Lemma Rdiv_minus : forall a b c d : R, b <> 0 -> d <> 0 ->
  a / b - c / d = (a * d - c * b) / (b * d).

Lemma Rplus_lt_reg_l (x y z : R) : x + y < x + z -> y < z.

Lemma Rplus_lt_reg_r (x y z : R) : y + x < z + x -> y < z.

Lemma Rle_div_l : forall a b c, c > 0 -> (a / c <= b <-> a <= b * c).

Lemma Rle_div_r : forall a b c, c > 0 -> (a * c <= b <-> a <= b / c).

Lemma Rlt_div_l : forall a b c, c > 0 -> (a / c < b <-> a < b*c).

Lemma Rlt_div_r : forall a b c, c > 0 -> (a * c < b <-> a < b / c).

Lemma Rdiv_lt_0_compat : forall r1 r2 : R, 0 < r1 -> 0 < r2 -> 0 < r1 / r2.

Lemma Rdiv_le_0_compat : forall r1 r2 : R, 0 <= r1 -> 0 < r2 -> 0 <= r1 / r2.

Lemma Rdiv_lt_1 : forall r1 r2, 0 < r2 -> (r1 < r2 <-> r1 / r2 < 1).

Lemma Rdiv_le_1 : forall r1 r2, 0 < r2 -> (r1 <= r2 <-> r1/r2 <= 1).

Lemma Rle_mult_Rlt : forall c a b : R, 0 < b -> c < 1 -> a <= b*c -> a < b.

Lemma Rmult_le_0_r : forall a b, a <= 0 -> 0 <= b -> a * b <= 0.

Lemma Rmult_le_0_l : forall a b, 0 <= a -> b <= 0 -> a * b <= 0.

Lemma pow2_gt_0 (x : R) : x <> 0 -> 0 < x ^ 2.

Lemma Rminus_eq_0 : forall r : R, r - r = 0.

Lemma Rdiv_minus_distr : forall a b c, b <> 0 -> a / b - c = (a - b * c) / b.

Lemma Rmult_minus_distr_r: forall r1 r2 r3 : R, (r1 - r2) * r3 = r1 * r3 - r2 * r3.

Lemma Rminus_eq_compat_l : forall r r1 r2 : R, r1 = r2 <-> r - r1 = r - r2.

Lemma Ropp_plus_minus_distr : forall r1 r2 : R, - (r1 + r2) = - r1 - r2.

Lemma Rle_minus_l : forall a b c,(a - c <= b <-> a <= b + c).

Lemma Rlt_minus_r : forall a b c,(a < b - c <-> a + c < b).

Lemma Rlt_minus_l : forall a b c,(a - c < b <-> a < b + c).

Lemma Rle_minus_r : forall a b c,(a <= b - c <-> a + c <= b).

Lemma Rminus_le_0 : forall a b, a <= b <-> 0 <= b - a.

Lemma Rminus_lt_0 : forall a b, a < b <-> 0 < b - a.

Lemma sum_f_rw (a : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m a = sum_f_R0 a m - sum_f_R0 a n.

Lemma sum_f_rw_0 (u : nat -> R) (n : nat) :
  sum_f O n u = sum_f_R0 u n.

Lemma sum_f_n_Sm (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f n (S m) u = sum_f n m u + u (S m).
Lemma sum_f_u_Sk (u : nat -> R) (n m : nat) :
  (n <= m)%nat -> sum_f (S n) (S m) u = sum_f n m (fun k => u (S k)).
Lemma sum_f_u_add (u : nat -> R) (p n m : nat) :
  (n <= m)%nat -> sum_f (n + p)%nat (m + p)%nat u = sum_f n m (fun k => u (k + p)%nat).

Lemma sum_f_Sn_m (u : nat -> R) (n m : nat) :
  (n < m)%nat -> sum_f (S n) m u = sum_f n m u - u n.

Lemma sum_f_R0_skip (u : nat -> R) (n : nat) :
  sum_f_R0 (fun k => u (n - k)%nat) n = sum_f_R0 u n.

Lemma sum_f_chasles (u : nat -> R) (n m k : nat) :
  (n < m)%nat -> (m < k)%nat ->
  sum_f (S n) k u = sum_f (S n) m u + sum_f (S m) k u.

Lemma Rplus_max_distr_l :
  forall a b c, a + Rmax b c = Rmax (a + b) (a + c).

Lemma Rplus_max_distr_r :
  forall a b c, Rmax b c + a = Rmax (b + a) (c + a).

Lemma Rplus_min_distr_l :
  forall a b c, a + Rmin b c = Rmin (a + b) (a + c).

Lemma Rplus_min_distr_r :
  forall a b c, Rmin b c + a = Rmin (b + a) (c + a).

Lemma Rmult_max_distr_l :
  forall a b c, 0 <= a -> a * Rmax b c = Rmax (a * b) (a * c).

Lemma Rmult_max_distr_r :
  forall a b c, 0 <= a -> Rmax b c * a = Rmax (b * a) (c * a).

Lemma Rmult_min_distr_l :
  forall a b c, 0 <= a -> a * Rmin b c = Rmin (a * b) (a * c).

Lemma Rmult_min_distr_r :
  forall a b c, 0 <= a -> Rmin b c * a = Rmin (b * a) (c * a).

Lemma Rmin_assoc : forall x y z, Rmin x (Rmin y z) =
  Rmin (Rmin x y) z.

Lemma Rmax_assoc : forall x y z, Rmax x (Rmax y z) =
  Rmax (Rmax x y) z.

Lemma Rmax_le_compat : forall a b c d, a <= b -> c <= d -> Rmax a c <= Rmax b d.

Lemma Rmax_opp_Rmin : forall a b, Rmax (-a) (-b) = - Rmin a b.
Lemma Rmin_opp_Rmax : forall a b, Rmin (-a) (-b) = - Rmax a b.

Lemma Rmax_mult : forall a b c, 0 <= c -> Rmax a b * c = Rmax (a * c) (b * c).

Lemma Rmax_le_Rplus : forall a b : R, 0 <= a -> 0 <= b -> Rmax a b <= a + b.

Lemma Rplus_le_Rmax : forall a b : R, a + b <= 2*Rmax a b.

Lemma Rmin_Rmax_l : forall a b, Rmin a b <= a <= Rmax a b.

Lemma Rmin_Rmax_r : forall a b, Rmin a b <= b <= Rmax a b.

Lemma Rmin_Rmax : forall a b, Rmin a b <= Rmax a b.

Lemma Rabs_div : forall a b : R, b <> 0 -> Rabs (a/b) = (Rabs a) / (Rabs b).

Lemma Rabs_eq_0 : forall x, Rabs x = 0 -> x = 0.

Lemma Rabs_le_between : forall x y, (Rabs x <= y <-> -y <= x <= y).

Lemma Rabs_le_between' : forall x y z, Rabs (x - y) <= z <-> y-z <= x <= y+z.

Lemma Rabs_lt_between : forall x y, (Rabs x < y <-> -y < x < y).

Lemma Rabs_lt_between' : forall x y z, Rabs (x - y) < z <-> y-z < x < y+z.

Lemma Rabs_le_between_min_max : forall x y z, Rmin x y <= z <= Rmax x y -> Rabs (z - y) <= Rabs (x - y).

Lemma Rabs_le_between_Rmax : forall x m M,
  m <= x <= M -> Rabs x <= Rmax M (-m).

Lemma Rabs_lt_between_Rmax : forall x m M,
  m < x < M -> Rabs x < Rmax M (-m).

Lemma Rabs_maj2 : forall x, -x <= Rabs x.

Lemma Req_lt_aux : forall x y, (forall eps : posreal, Rabs (x - y) < eps) -> x = y.

Lemma Req_le_aux : forall x y, (forall eps : posreal, Rabs (x - y) <= eps) -> x = y.

Lemma is_pos_div_2 (eps : posreal) : 0 < eps / 2.
Definition pos_div_2 (eps : posreal) := mkposreal _ (is_pos_div_2 eps).

Definition sign (x : R) :=
  match total_order_T 0 x with
  | inleft (left _) => 1
  | inleft (right _) => 0
  | inright _ => -1
  end.

Lemma sign_0 : sign 0 = 0.

Lemma sign_opp (x : R) : sign (-x) = - sign x.

Lemma sign_eq_1 (x : R) : 0 < x -> sign x = 1.

Lemma sign_eq_m1 (x : R) : x < 0 -> sign x = -1.

Lemma sign_le (x y : R) : x <= y -> sign x <= sign y.

Lemma sign_ge_0 (x : R) : 0 <= x -> 0 <= sign x.

Lemma sign_le_0 (x : R) : x <= 0 -> sign x <= 0.

Lemma sign_neq_0 (x : R) : x <> 0 -> sign x <> 0.

Lemma sign_mult (x y : R) : sign (x * y) = sign x * sign y.

Lemma sign_min_max (a b : R) :
  sign (b - a) * (Rmax a b - Rmin a b) = b - a.

Lemma sum_INR : forall n, sum_f_R0 INR n = INR n * (INR n + 1) / 2.

Lemma interval_finite_subdiv (a b : R) (eps : posreal) : (a <= b) ->
  {l : seq R | head 0 l = a /\ last 0 l = b /\
    forall i, (S i < size l)%nat -> nth 0 l i < nth 0 l (S i) <= nth 0 l i + eps}.

Lemma interval_finite_subdiv_between (a b : R) (eps : posreal) (Hab : a <= b) :
  let l := proj1_sig (interval_finite_subdiv a b eps Hab) in
  forall i, (i < size l)%nat -> a <= nth 0 l i <= b.

Lemma SSR_leq (n m : nat) : is_true (ssrnat.leq n m) <-> (n <= m)%nat.
Lemma SSR_minus (n m : nat) : ssrnat.subn n m = (n - m)%nat.

Lemma rcons_ind {T : Type} (P : seq T -> Type) :
  P [::] -> (forall (s : seq T) (t : T), P s -> P (rcons s t)) -> forall s, P s.
Lemma rcons_dec {T : Type} (P : seq T -> Type) :
  (P [::]) -> (forall s t, P (rcons s t)) -> forall s, P s.
Lemma size_rcons_pos {T : Type} (s : seq T) (t : T) : (0 < size (rcons s t))%nat.

Lemma foldr_rcons {T T0 : Type} : forall (f : T0 -> T -> T) x0 s t,
  foldr f x0 (rcons s t) = foldr f (f t x0) s.
Lemma foldl_rcons {T T0 : Type} : forall (f : T -> T0 -> T) x0 s t,
  foldl f x0 (rcons s t) = f (foldl f x0 s) t.

Lemma head_rcons {T : Type} (x0 : T) (s : seq T) (t : T) : head x0 (rcons s t) = head t s.
Lemma behead_rcons {T : Type} (s : seq T) (t : T) :
  (0 < size s)%nat ->  behead (rcons s t) = rcons (behead s) t.
Definition belast {T : Type} (s : seq T) :=
  match s with
    | [::] => [::]
    | h :: s => belast h s
  end.
Lemma behead_rev {T : Type} (s : seq T) : behead (rev s) = rev (belast s).

Lemma pairmap_rcons {T T0 : Type} (f : T -> T -> T0) (s : seq T) h0 h x0 :
  pairmap f x0 (rcons (rcons s h0) h) = rcons (pairmap f x0 (rcons s h0)) (f h0 h).
Lemma map_pairmap {T T0 T1 : Type} (f : T0 -> T1) (g : T -> T -> T0) (s : seq T) (x0 : T) :
  map f (pairmap g x0 s) = pairmap (fun x y => f (g x y)) x0 s.
Lemma pairmap_map {T T0 T1 : Type} (f : T0 -> T0 -> T1) (g : T -> T0) (s : seq T) (x0 : T) :
  pairmap f (g x0) (map g s) = pairmap (fun x y => f (g x) (g y)) x0 s.

Lemma size_unzip1 {T T0 : Type} (s : seq (T * T0)) : size (unzip1 s) = size s.
Lemma size_unzip2 {T T0 : Type} (s : seq (T * T0)) : size (unzip2 s) = size s.
Lemma zip_cons {S T : Type} hs ht (s : seq S) (t : seq T) :
  zip (hs :: s) (ht :: t) = (hs,ht) :: zip s t.
Lemma zip_rcons {S T : Type} (s : seq S) (t : seq T) hs ht : size s = size t ->
  zip (rcons s hs) (rcons t ht) = rcons (zip s t) (hs,ht).
Lemma unzip1_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip1 (rcons s h) = rcons (unzip1 s) (fst h).
Lemma unzip2_rcons {S T : Type} (s : seq (S*T)) (h : S*T) :
  unzip2 (rcons s h) = rcons (unzip2 s) (snd h).
Lemma unzip1_belast {S T : Type} (s : seq (S*T)) :
  unzip1 (belast s) = belast (unzip1 s).
Lemma unzip2_belast {S T : Type} (s : seq (S*T)) :
  unzip2 (belast s) = belast (unzip2 s).
Lemma unzip1_behead {S T : Type} (s : seq (S*T)) :
  unzip1 (behead s) = behead (unzip1 s).
Lemma unzip2_behead {S T : Type} (s : seq (S*T)) :
  unzip2 (behead s) = behead (unzip2 s).
Lemma unzip1_fst {S T : Type} (s : seq (S*T)) :
  unzip1 s = map (@fst S T) s.
Lemma unzip2_snd {S T : Type} (s : seq (S*T)) :
  unzip2 s = map (@snd S T) s.
Lemma size_belast' {T : Type} (s : seq T) :
  size (belast s) = Peano.pred (size s).
Lemma head_map {T1 T2 : Type} (f : T1 -> T2) (s : seq T1) (x : T1) :
  head (f x) (map f s) = f (head x s).

Lemma StepFun_bound {a b : R} (f : StepFun a b) :
  exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_bound (f : R -> R) (a b : R) :
  Riemann_integrable f a b -> exists s : R, forall x, Rmin a b <= x <= Rmax a b -> f x <= s.

Lemma Riemann_integrable_ext : forall (f g : R -> R) (a b : R),
  (forall x, Rmin a b <= x <= Rmax a b -> f x = g x)
    -> Riemann_integrable f a b -> Riemann_integrable g a b.

Lemma RiemannInt_ext : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (Heq : forall x, Rmin a b <= x <= Rmax a b -> f x = g x),
    RiemannInt pr_f = RiemannInt pr_g.

Lemma Riemann_integrable_const : forall (c a b : R),
  Riemann_integrable (fun x => c) a b.

Lemma RiemannInt_const : forall (c a b : R) (pr : Riemann_integrable (fun x => c) a b),
  RiemannInt pr = c * (b-a).

Lemma Riemann_integrable_plus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x + g x) a b.

Lemma RiemannInt_plus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x + g x) a b),
  RiemannInt pr = RiemannInt pr_f + RiemannInt pr_g.

Lemma Riemann_integrable_minus : forall (f g : R -> R) (a b : R),
  Riemann_integrable f a b -> Riemann_integrable g a b ->
    Riemann_integrable (fun x => f x - g x) a b.

Lemma RiemannInt_minus : forall (f g : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b) (pr_g : Riemann_integrable g a b)
  (pr : Riemann_integrable (fun x => f x - g x) a b),
  RiemannInt pr = RiemannInt pr_f - RiemannInt pr_g.

Lemma Riemann_integrable_opp : forall (f : R -> R) (a b : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => - f x) a b.

Lemma RiemannInt_opp : forall (f : R -> R) (a b : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => - f x) a b),
  RiemannInt pr = - RiemannInt pr_f.

Lemma Riemann_integrable_scal : forall (f : R -> R) (a b c : R),
  Riemann_integrable f a b ->
    Riemann_integrable (fun x => c * f x) a b.

Lemma RiemannInt_scal : forall (f : R -> R) (a b c : R)
  (pr_f : Riemann_integrable f a b)
  (pr : Riemann_integrable (fun x => c * f x) a b),
  RiemannInt pr = c * RiemannInt pr_f.

Lemma ln_pow x n : 0 < x -> ln (x^n) = INR n * ln x.

Lemma ln_le x y : 0 < x -> x <= y -> ln x <= ln y.

Lemma ln_div x y : 0 < x -> 0 < y -> ln (x / y) = ln x - ln y.

Lemma derivable_pt_lim_atan :
  forall x, derivable_pt_lim atan x (/(1 + x^2)). *)



Open Scope R_scope.



Lemma completeness_any :

  forall P : R -> Prop,

  ( forall x y, x <= y -> P y -> P x ) ->

  forall He : (exists x, P x),

  forall Hb : (bound P),

  forall x, x < proj1_sig (completeness _ Hb He) ->

  ~ ~ P x.

Proof.

intros P HP He Hb x.

case completeness => y [Hy1 Hy2] /= Hxy Px.

apply Rle_not_lt with (2 := Hxy).

apply Hy2 => t Pt.

apply Rnot_lt_le => Hxt.

apply Px.

apply: HP Pt.

now apply Rlt_le.

Qed.



Lemma false_not_not :

  forall P Q : Prop, (P -> ~Q) -> (~~P -> ~Q).

Proof.

intros P Q H HP HQ.

apply HP.

intros H'.

now apply H.

Qed.



Section Compactness.



Fixpoint Tn n T : Type :=

  match n with

  | O => unit

  | S n => (T * Tn n T)%type

  end.



Fixpoint bounded_n n : Tn n R -> Tn n R -> Tn n R -> Prop :=

  match n return Tn n R -> Tn n R -> Tn n R -> Prop with

  | O => fun a b x : Tn O R => True

  | S n => fun a b x : Tn (S n) R =>

    let '(a1,a2) := a in

    let '(b1,b2) := b in

    let '(x1,x2) := x in

    a1 <= x1 <= b1 /\ bounded_n n a2 b2 x2

  end.



Fixpoint close_n n d : Tn n R -> Tn n R -> Prop :=

  match n return Tn n R -> Tn n R -> Prop with

  | O => fun x t : Tn O R => True

  | S n => fun x t : Tn (S n) R =>

    let '(x1,x2) := x in

    let '(t1,t2) := t in

    Rabs (x1 - t1) < d /\ close_n n d x2 t2

  end.



Lemma compactness_list :

  forall n a b (delta : Tn n R -> posreal),

  ~~ exists l, forall x, bounded_n n a b x -> exists t, In t l /\ bounded_n n a b t /\ close_n n (delta t) x t.

Proof.

induction n.

intros a b delta.

intros H.

apply H.

exists (tt :: nil).

intros x Hx.

exists tt.

repeat split.

now left.

simpl.



intros (a,a') (b,b') delta.

destruct (Rlt_le_dec b a) as [Hab|Hab].

intros H.

apply H.

exists nil.

intros (x,x') (Hx,_).

elim (Rlt_irrefl a).

apply Rle_lt_trans with (2 := Hab).

now apply Rle_trans with x.



set (P y := y <= b /\ ~~exists l, forall x, bounded_n (S n) (a,a') (y,b') x ->

  exists t, In t l /\ bounded_n (S n) (a,a') (b,b') t /\ close_n (S n) (delta t) x t).



assert (P1': P a).

split.

apply Hab.

simpl.

specialize (IHn a' b' (fun x' => delta (a,x'))).

contradict IHn.

contradict IHn.

destruct IHn as (l,Hl).

exists (fold_right (fun x' acc => (a,x')::acc) nil l).

intros (x,x') (Hx,Hx').

replace x with a by now apply Rle_antisym.

destruct (Hl x' Hx') as (t',(Ht1,Ht2)).

exists (a,t').

split.

clear -Ht1.

induction l.

easy.

simpl in Ht1 |- *.

destruct Ht1 as [Ht1|Ht1].

left.

now apply f_equal2.

right.

now apply IHl.

repeat split.

apply Rle_refl.

exact Hab.

apply Ht2.

rewrite /Rminus Rplus_opp_r Rabs_R0.

apply cond_pos.

apply Ht2.



assert (P2: bound P).

exists b => y Hy.

apply Hy.



assert (P3: forall x y, x <= y -> P y -> P x).

intros x y Hxy (Py1,Py2).

split.

now apply Rle_trans with y.

contradict Py2.

contradict Py2.

destruct Py2 as (l,Py2).

exists l => [[z z']] Hz.

apply Py2.

split.

split.

apply Hz.

now apply Rle_trans with (1 := proj2 (proj1 Hz)).

apply Hz.

assert (P1: exists x, P x).

now exists a.



set (y := proj1_sig (completeness _ P2 P1)).

assert (P4: ~~exists d : posreal, P (Rmin b (y + d))).

specialize (IHn a' b' (fun x' => delta (y,x'))).

contradict IHn.

contradict IHn.

destruct IHn as (l, Hl).

set (d := fold_right (fun t acc => mkposreal _ (Rmin_stable_in_posreal (delta (y,t)) acc)) (mkposreal _ Rlt_0_1) l).

assert (Hd: 0 < d/2).

apply Fourier_util.Rlt_mult_inv_pos.

apply cond_pos.

apply Rlt_R0_R2.

exists (mkposreal _ Hd).

split.

apply Rmin_l.

refine (_ (completeness_any _ P3 P1 P2 (y - d) _)).

intros Hy.

apply: false_not_not Hy => Hy.

destruct Hy as (Hy1,Hy2).

apply: false_not_not Hy2 => Hy2.

apply.

destruct Hy2 as (l',Hl').

exists (app (fold_right (fun x' acc => (y,x')::acc) nil l) l').

simpl.

intros (x,x') (Hx,Hx').

destruct (Rle_or_lt x (y - d)) as [Hxy|Hxy].

destruct (Hl' (x,x') (conj (conj (proj1 Hx) Hxy) Hx')) as (t,(Ht1,Ht2)).

exists t.

split.

apply in_or_app.

now right.

exact Ht2.

destruct (Hl x' Hx') as (t',(Ht1,Ht2)).

exists (y, t').

split.

apply in_or_app.

left.

clear -Ht1.

induction l.

easy.

simpl in Ht1 |- *.

destruct Ht1 as [Ht1|Ht1].

left.

now apply f_equal2.

right.

now apply IHl.

do 2 split.

unfold y.

case completeness => /= z [Hz1 Hz2].

split.

now apply Hz1.

apply Hz2.

intros w Hw.

apply Hw.

apply Ht2.

apply Rlt_le_trans with d.

apply Rabs_def1.

apply Rplus_lt_reg_r with y.

ring_simplify.

apply Rle_lt_trans with (y + d/2).

now apply Rle_trans with (2 := Rmin_r b _).

apply Rplus_lt_compat_l.

rewrite -(Rplus_0_r (d/2)).

rewrite {2}(double_var d).

now apply Rplus_lt_compat_l.

apply Rplus_lt_reg_l with y.

now ring_simplify (y + (x - y)).

clearbody y.

clear -Ht1.

induction l.

easy.

simpl in Ht1.

destruct Ht1 as [Ht1|Ht1].

rewrite -Ht1.

apply: Rmin_l.

unfold d.

simpl.

apply Rle_trans with (1 := Rmin_r _ _).

now apply IHl.

apply Ht2.

fold y.

rewrite -{2}(Rplus_0_r y) -Ropp_0.

apply Rplus_lt_compat_l.

apply Ropp_lt_contravar.

apply cond_pos.



apply: false_not_not P4 => P4.

destruct P4 as (d,P4).

destruct (Rle_or_lt b y) as [Hby|Hby].

rewrite Rmin_left in P4.

apply P4.

rewrite -(Rplus_0_r b).

apply Rplus_le_compat with (1 := Hby).

apply Rlt_le.

apply cond_pos.

elimtype False.

unfold y in *.

clear y.

revert P4 Hby.

case completeness => /= y [Hy1 Hy2] P4 Hby.

apply Rle_not_lt with (1 := Hy1 (Rmin b (y + d)) P4).

apply Rmin_case.

exact Hby.

rewrite -{1}(Rplus_0_r y).

apply Rplus_lt_compat_l.

apply cond_pos.

Qed.



Lemma compactness_value :

  forall n a b (delta : Tn n R -> posreal),

  { d : posreal | forall x, bounded_n n a b x -> ~~ exists t, bounded_n n a b t /\ close_n n (delta t) x t /\ d <= delta t }.

Proof.

intros n a b delta.

set (P d := d <= 1 /\ forall x, bounded_n n a b x -> exists t, bounded_n n a b t /\ close_n n (delta t) x t /\ d <= delta t).

assert (P1 : exists d, P d).

exists 0.

split.

apply Rle_0_1.

intros x Hx.

exists x.

split.

exact Hx.

split.

clear.

induction n.

easy.

destruct x as (x,x').

split.

rewrite /Rminus Rplus_opp_r Rabs_R0.

apply cond_pos.

apply (IHn (fun x' => delta (x,x'))).

apply Rlt_le.

apply cond_pos.

assert (P2 : bound P).

exists 1.

now intros d (Hd,_).

set (d := completeness P P2 P1).



assert (P3 : 0 < proj1_sig d).

revert d.

case completeness.

intros d (Hd1,Hd2).

simpl.

apply Rnot_le_lt.

intros Hd3.

apply (compactness_list n a b delta).

intros (l,Hl).

set (v := fold_right (fun t acc => mkposreal _ (Rmin_stable_in_posreal (delta t) acc)) (mkposreal _ Rlt_0_1) l).

apply (Rlt_not_le _ _ (cond_pos v)).

apply Rle_trans with (2 := Hd3).

apply Hd1.

split.

unfold v.

clear.

induction l.

apply Rle_refl.

simpl.

apply Rle_trans with (2 := IHl).

apply Rmin_r.

intros x Hx.

destruct (Hl x Hx) as (t,(Ht1,Ht2)).

exists t.

split.

apply Ht2.

split.

apply Ht2.

clear -Ht1.

induction l.

easy.

simpl in Ht1.

destruct Ht1 as [Ht1|Ht1].

simpl.

rewrite Ht1.

apply Rmin_l.

simpl.

eapply Rle_trans with (1 := Rmin_r _ _).

now apply IHl.



exists (mkposreal _ (Fourier_util.Rlt_mult_inv_pos _ _ P3 Rlt_R0_R2)).

intros x Hx.

simpl.

refine (_ (completeness_any P _ P1 P2 (proj1_sig d / 2) _)).

intros HP.

contradict HP.

contradict HP.

destruct HP as (_,HP).

now apply HP.

intros u v Huv (Pv1,Pv2).

split.

now apply Rle_trans with v.

intros z Hz.

destruct (Pv2 z Hz) as (t,Ht).

exists t.

split.

apply Ht.

split.

apply Ht.

apply Rle_trans with (1 := Huv).

apply Ht.

fold d.

rewrite -(Rplus_0_r (proj1_sig d / 2)).

rewrite {2}(double_var (proj1_sig d)).

apply Rplus_lt_compat_l.

apply Fourier_util.Rlt_mult_inv_pos.

exact P3.

apply Rlt_R0_R2.

Qed.



End Compactness.



Lemma compactness_value_1d :

  forall a b (delta : R -> posreal),

  { d : posreal | forall x, a <= x <= b -> ~~ exists t, a <= t <= b /\ Rabs (x - t) < delta t /\ d <= delta t }.

Proof.

intros a b delta.

destruct (compactness_value 1 (a,tt) (b,tt) (fun t => let '(t,_) := t in delta t)) as (d, Hd).

exists d.

intros x Hx.

specialize (Hd (x,tt) (conj Hx I)).

do 2 contradict Hd.

destruct Hd as ((t,t'),Ht).

exists t.

repeat split ; apply Ht.

Qed.



Lemma compactness_value_2d :

  forall a b a' b' (delta : R -> R -> posreal),

  { d : posreal | forall x y, a <= x <= b -> a' <= y <= b' ->

    ~~ exists u, exists v, a <= u <= b /\ a' <= v <= b' /\ Rabs (x - u) < delta u v /\ Rabs (y - v) < delta u v /\ d <= delta u v }.

Proof.

intros a b a' b' delta.

destruct (compactness_value 2 (a,(a',tt)) (b,(b',tt)) (fun t => let '(u,(v,_)) := t in delta u v)) as (d, Hd).

exists d.

intros x y Hx Hy.

specialize (Hd (x,(y,tt)) (conj Hx (conj Hy I))).

do 2 contradict Hd.

destruct Hd as ((u,(v,w)),Ht).

exists u.

exists v.

simpl in Ht.

repeat split ; apply Ht.

Qed.

