Require Import Arith Div2 List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.Cobham BellantoniCook.CobhamLib.
(* BellantoniCook.Lib:
Require Import Bool Arith Div2 List Permutation.
Require Export Omega.

Global Obligation Tactic := idtac.

Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) .. ).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.

Lemma length_tail A l : length (@tail A l) = length l - 1.

Lemma hd_nth_0 A (l : list A) d :
  hd d l = nth 0 l d.

Lemma hd_nth_1 A (l : list A) d :
  hd d (tl l) = nth 1 l d.

Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) :
  In (hd d l) l.

Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).

Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).

Lemma map_eq_hd :
  forall A B (f:A->B) d l1 l2,
  map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).

Lemma firstn_nil {A} n : firstn n (@nil A) = nil.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma nth_firstn : forall A i j (l:list A) d,
  i < j -> nth i (firstn j l) d = nth i l d.

Lemma nth_skipn A i j (l:list A) d : 
  nth i (skipn j l) d = nth (j+i) l d.

Lemma length_skipn : forall A n (y : list A),
  length (skipn n y) = length y - n.

Lemma skipn_length : forall {A} n (l:list A), 
  length (skipn n l) = length l - n.

Lemma cons_skipn :
  forall A d i (l:list A),
  i < length l ->
  nth i l d :: skipn (S i) l = skipn i l.

Lemma skipn_plus :
  forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).

Lemma skipn_hd : forall {A} n y (d:A), 
  n < length y -> 
  skipn n y = nth n y d :: skipn (S n) y.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma skipn_app {A} (l l' : list A) : 
  skipn (length l) (l ++ l') = l'.

Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.

Lemma map_firstn : forall A B (f:A->B) n l,
  map f (firstn n l) = firstn n (map f l).

Lemma map_skipn : forall A B (f:A->B) n l,
  map f (skipn n l) = skipn n (map f l).

Lemma map_nth_seq : forall A (l:list A) len n d,
  length l = len + n ->
  map (fun x : nat => nth x l d) (seq n len) = (skipn n l).

Lemma skipn_nil_length : forall A n (l : list A),
  skipn n l = nil -> length l <= n.

Lemma firstn_map_nth :
  forall A d n m (l:list A),
  m+n <= length l ->
  firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma in_seq_iff : forall x len start,
  In x (seq start len) <-> start <= x < start+len.

Lemma nth_map_cst :
  forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.

Lemma nth_S_tl A (l : list A) d n :
  nth n (tl l) d = nth (S n) l d.

Lemma map_ext2 : forall {A B} (f g : A -> B) l,
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma map_nth2
  (A B : Type) (f : A -> B) (l : list A) b d n :
  (f d) = b ->
  nth n (map f l) b = f (nth n l d).

Lemma length_plus_ex {A} n1 n2 (l : list A):
  length l = n1 + n2 ->
  exists l1, exists l2,
    length l1 = n1 /\ length l2 = n2 /\ l = l1 ++ l2.

Lemma tl_app : forall A (l1 l2 : list A),
  l1 <> nil ->
  tl (l1 ++ l2) = tl l1 ++ l2.

Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, 
 map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.

Lemma map_seq_shift : forall A m (f : nat -> A) n,
n <> 0 ->
map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).

Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, 
 map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.

Lemma seq_app : forall x y z,
  seq x y ++ seq (x + y) z = seq x (y + z).

Definition andl {A} (P:A->Prop)(l:list A) : Prop :=
  fold_right (fun a res => P a /\ res) True l.

Lemma forall_andl A (P:A->Prop) l :
  (forall x, In x l -> P x) <-> andl P l.

Fixpoint fun_power {A:Type}(n:nat)(f:A->A)(x:A) : A :=
  match n with
  | 0 => x
  | S n' => f (fun_power n' f x)
  end.

Lemma fun_power_minus_S : forall A (f:A->A) x m n,
  m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.

Definition mod2 (n : nat) : nat :=
  n - 2 * div2 n.

Fixpoint power (m n:nat) : nat :=
 match n with
 | 0 => 1
 | S n' => m * power m n'
 end.

Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.

Definition plusl (l:list nat) : nat :=
  fold_right plus 0 l.

Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.

Lemma plusl_app l1 l2 :
  plusl (l1++l2) = plusl l1 + plusl l2.

Lemma plusl_compat : forall A (l : list A) f g,
  (forall x, In x l -> f x <= g x) ->
  plusl (map f l) <= plusl (map g l).

Definition multl (l:list nat) : nat :=
  fold_right mult 1 l.

Lemma multl_app l1 l2 :
  multl (l1++l2) = multl l1 * multl l2.

Lemma multl_plus_distr_l n l :
  n * plusl l = plusl (map (fun m => n * m) l).

Fixpoint maxl l := 
  match l with
    | nil => 0
    | a :: l' => max a (maxl l')
  end.

Lemma in_le_maxl x l : In x l -> x <= maxl l.

Lemma maxl_map A l (f : A -> nat) n :
  (forall x, In x l -> f x = n) ->
  maxl (map f l) <= n.

Lemma maxl_le l e :
  maxl l <= e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le l e :
  maxl l = e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] = e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] <= e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_bound e1 e2 e3 e :
  e1 <= e -> e2 <= e -> e3 <= e ->
  maxl [e1; e2; e3] <= e.

Lemma maxl_bound_in l e :
  (forall e', In e' l -> e' <= e) -> maxl l <= e.

Lemma maxl_cons l n : n <= maxl (n :: l).

Lemma le_maxl_cons l m n :
 n <= maxl l -> n <= maxl (m :: l).

Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i,
  m d = 0 -> m (nth i l d) <= maxl (map m l).

Lemma length_hd_app A (l1 l2 : list (list A)) :
  length (hd nil l1) <= length (hd nil (l1 ++ l2)).

Lemma length_nth_app A (l1 l2 : list (list A)) i :
  length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).

Lemma maxl_nth l :
  exists i, maxl l = nth i l 0.

Lemma maxl_map_0 A l (f : A -> nat)  :
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_le_plusl : forall l, maxl l <= plusl l.

Lemma forallb_forall_conv :
  forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\ f x = false).

Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d,
  p d = true ->
  forallb p l = true ->
  p (nth n l d) = true.

Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d,
  forallb p l = true ->
  p d = true ->
  p (hd d l) = true.

Lemma forallb_tl : forall A (l : list A) (p : A -> bool),
  forallb p l = true ->
  forallb p (tail l) = true.

Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B),
  (forall x, In x l -> p (f x) = true) ->
  forallb p (map f l) = true.

Fixpoint repeat {A:Type}(n:nat)(x:A) : list A :=
  match n with
  | 0 => nil
  | S n' => x :: repeat n' x
  end.

Lemma firstn_repeat_le :
  forall A (x:A) m n,
  m <= n ->
  firstn m (repeat n x) = repeat m x.

Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.

Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).

Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.

Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.

Lemma nth_repeat :
  forall A n (x:A) d i, i < n ->
  nth i (repeat n x) d = x.

Definition move_forward {A}(i j:nat)(l:list A)(d:A) : list A :=
  firstn i l ++ firstn j (skipn (S i) l) ++ (nth i l d :: skipn (S (i+j)) l).

Lemma move_forward_map A B d1 d2 i j (f:A->B) l :
  f d1 = d2 ->
  move_forward i j (map f l) d2 = map f (move_forward i j l d1).

Lemma length_move_forward :
  forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.

Lemma in_move_forward_iff :
  forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).

Lemma firstn_simpl : forall A B (l : list A) (l2 : list B),
 length l2 = length l ->
 firstn (length l2) l = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .

Lemma firstn_firstn : forall A n (l : list A),
 firstn n (firstn n l) = firstn n l.

Lemma In_firstn : forall A n a (l : list A),
  In a (firstn n l) -> In a l. *)
(* BellantoniCook.Bitstring:
Require Import Bool Arith Div2 List.
Require Import BellantoniCook.Lib.

Notation bs := (list bool).

Definition unary (v : bs) := forallb id v.

Definition bs2bool (v:bs) : bool := hd false v.

Definition bool2bs (b:bool) : bs :=
  if b then true::nil else nil.

Lemma bs_nat2bool_true : forall v,
  bs2bool v = true -> length v <> 0.

Lemma bs_nat2bool_true_conv : forall v,
  unary v = true ->
  length v <> 0 -> bs2bool v = true.

Lemma bs_nat2bool_false v :
  unary v = true ->
  bs2bool v = false -> length v = 0.

Lemma bs_nat2bool_false_conv v :
  length v = 0 ->
  bs2bool v = false.

Fixpoint bs2nat (v:bs) : nat :=
  match v with
  | nil => 0
  | false :: v' => 2 * bs2nat v'
  | true  :: v' => S (2 * bs2nat v')
  end.

Fixpoint succ_bs (v : bs) : bs :=
  match v with
    | nil => [true]
    | false :: v' => true :: v'
    | true :: v' => false :: succ_bs v'
  end.

Lemma succ_bs_correct v : bs2nat (succ_bs v) = bs2nat v + 1.

Fixpoint nat2bs (n:nat) : bs :=
  match n with
  | 0 => nil
  | S n' => succ_bs (nat2bs n')
  end.

Lemma bs2nat_nil :
  bs2nat nil = 0.

Lemma bs2nat_false v :
  bs2nat (false :: v) = 2 * bs2nat v.

Lemma bs2nat_true v :
  bs2nat (true :: v) = 1 + 2 * bs2nat v.

Lemma bs2nat_tl : forall v, bs2nat (tl v) = div2 (bs2nat v).

Lemma bs2nat_nat2bs : forall n, bs2nat (nat2bs n) = n. *)
(* BellantoniCook.Cobham:
Require Import Bool Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.

Inductive Cobham : Type :=
| Zero : Cobham
| Proj : nat -> nat -> Cobham
| Succ : bool -> Cobham
| Smash : Cobham
| Rec  : Cobham -> Cobham -> Cobham -> Cobham -> Cobham
| Comp : nat -> Cobham -> list Cobham -> Cobham.

Definition Rec2 g h j := Rec g h h j.

Lemma Cobham_ind2' :
  forall P : Cobham -> Prop,
  forall Q : list Cobham -> Prop,
  Q nil ->
  (forall e l, P e -> Q l -> Q (e :: l)) ->
  P Zero ->
  (forall n i, P (Proj n i)) ->
  (forall b, P (Succ b)) ->
  P Smash ->
  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->
  (forall n h l, P h -> Q l -> P (Comp n h l)) ->
  forall e, P e.

Lemma Cobham_ind2 :
  forall P : Cobham -> Prop,
  P Zero ->
  (forall n i, P (Proj n i)) ->
  (forall b, P (Succ b)) ->
  P Smash ->
  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->
  (forall n h l, P h -> (forall e, In e l -> P e) ->
    P (Comp n h l)) ->
  forall e, P e.

Inductive Arity : Set :=
| error_Rec : Arity -> Arity -> Arity -> Arity -> Arity
| error_Comp : Arity -> list Arity -> Arity
| error_Proj : nat -> nat -> Arity
| ok_arity : nat -> Arity.

Definition arity_eq (a1 a2 : Arity) :=
  match a1, a2 with
    | ok_arity n1, ok_arity n2 => beq_nat n1 n2
    | _, _ => false
  end.

Lemma arity_eq_true x1 x2 :
  arity_eq x1 x2 = true -> x1 = x2.

Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.

Fixpoint arity (e : Cobham) : Arity :=
  match e with
    | Zero => ok_arity 0
    | Proj n j => if leb (S j) n 
      then ok_arity n else error_Proj n j 
    | Succ _ => ok_arity 1
    | Smash => ok_arity 2
    | Rec g h0 h1 j => 
      match arity g, arity h0, arity h1, arity j with
        | ok_arity gn, ok_arity h0n, ok_arity h1n, ok_arity jn =>
          if beq_nat (S (S gn)) h0n && 
             beq_nat h1n h0n &&
             beq_nat (S jn) h1n 
            then ok_arity jn 
            else error_Rec (ok_arity gn) (ok_arity h0n) 
              (ok_arity h1n) (ok_arity jn)
        | ag, ah0, ah1, aj => error_Rec ag ah0 ah1 aj 
      end
    | Comp n h l => 
      match arity h, map arity l with
        | ok_arity nh, al => 
          if beq_nat nh (length l) &&
            forallb (fun e => arity_eq e (ok_arity n)) al then
              ok_arity n else error_Comp (ok_arity nh) al
        | e , le => error_Comp e le 
      end
  end.

Lemma Cobham_ind_inf' :
  forall (P : nat -> Cobham -> Prop),
  forall Q : nat -> list Cobham -> Prop,
  (forall n, Q n nil) ->
  (forall e n l, P n e -> Q n l -> Q n (e :: l)) ->
  P 0 Zero ->
  (forall n i, i < n  ->  P n (Proj n i)) ->
  (forall b, P 1 (Succ b)) ->
  (P 2 Smash) ->
  (forall n g h0 h1 j, 
    arity g = ok_arity n ->
    arity h0 = ok_arity (S (S n)) ->
    arity h1 = ok_arity (S (S n)) ->
    arity j = ok_arity (S n) ->
    P n g -> 
    P (S (S n)) h0 -> 
    P (S (S n)) h1 -> 
    P (S n) j -> 
    P (S n) (Rec g h0 h1 j)) ->
  (forall n h rl, 
    arity h = ok_arity (length rl)  ->
    (forall e, In e rl -> arity e = ok_arity n) ->
    P (length rl)  h -> 
    Q n rl ->
    P n (Comp n h rl)) ->
  forall e n , arity e = ok_arity n -> P n e.

Lemma Cobham_ind_inf :
  forall (P : nat -> Cobham -> Prop),
  P 0 Zero ->
  (forall n i, i < n  ->  P n (Proj n i)) ->
  (forall b, P 1 (Succ b)) ->
  (P 2 Smash) ->
  (forall n g h0 h1 j, 
    arity g = ok_arity n ->
    arity h0 = ok_arity (S (S n)) ->
    arity h1 = ok_arity (S (S n)) ->
    arity j = ok_arity (S n) ->
    P n g -> 
    P (S (S n)) h0 -> 
    P (S (S n)) h1 -> 
    P (S n) j ->
    P (S n) (Rec g h0 h1 j)) ->
  (forall n h rl, 
    arity h = ok_arity (length rl)  ->
    (forall e, In e rl -> arity e = ok_arity n) ->
    P (length rl) h -> 
    (forall r, In r rl -> P n r) ->
    P n (Comp n h rl)) ->
  forall e n , arity e = ok_arity n -> P n e.

Fixpoint sem_Rec (sem_g sem_h0 sem_h1 : list bs -> bs) (v : bs) (vl : list bs) : bs :=
  match v with
    | nil => sem_g vl
    | b::v' => if b then 
      sem_h1 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)
      else sem_h0 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)
  end.

Fixpoint smash' (x y : bs) :=
  match x with 
    | nil => y
    | _ :: x' => false :: smash' x' y
  end.

Lemma length_smash' x y :
  length (smash' x y) = length x + length y.

Fixpoint smash_bs (x y : bs) : bs :=
  match x with
    | nil => true :: nil
    | _ :: x' => smash' y (smash_bs x' y)
  end.

Lemma length_smash x y :
  length (smash_bs x y) = 1 + length x * length y.

Fixpoint Sem (e: Cobham) (vl:list bs) : bs :=
  match e with
  | Zero => nil
  | Proj n j => nth j vl nil
  | Succ b => b :: hd nil vl
  | Smash => smash_bs (hd nil vl) (hd nil (tl vl))
  | Rec g h0 h1 j =>  
    sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil vl) (tail vl)
  | Comp _ h l => Sem h (List.map (fun e => Sem e vl) l)
  end.

Lemma simpl_Rec : forall g h0 h1 j l,
  Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).

Lemma Sem_add_zero : forall e n,
  arity e = ok_arity n ->
  forall l,
  length l <= n ->
  Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).

Lemma Sem_remove_zero : forall e n,
  arity e = ok_arity n ->
  forall l l',  n = length l ->
    Sem e l = Sem e (l ++ l').

Fixpoint rec_bounded' (e : Cobham) : Prop :=
  match e with
    | Rec g h0 h1 j =>
      rec_bounded' j  /\ 
      rec_bounded' g /\ 
      rec_bounded' h0 /\ 
      rec_bounded' h1 /\
      (match (arity e) with
         | ok_arity n => forall l, length l = n ->
           length (Sem e l) <= length (Sem j l)
        | _ => True 
       end)
    | Comp n h l => rec_bounded' h /\
        andl rec_bounded' l
    | _ => True
  end.

Fixpoint rec_bounded (e : Cobham) : Prop :=
  match e with
    | Rec g h0 h1 j =>
      rec_bounded j  /\ 
      rec_bounded g /\ 
      rec_bounded h0 /\ 
      rec_bounded h1 /\
      (forall l, 
        length (Sem e l) <= length (Sem j l))
    | Comp n h l => rec_bounded h /\
        andl rec_bounded l
    | _ => True
  end.

Lemma rec_bounded_spec (e : Cobham) :
  rec_bounded e -> rec_bounded' e.

Lemma rec_bounded'_spec : forall (e : Cobham) n,
  arity e = ok_arity n ->
  rec_bounded' e -> 
  rec_bounded e.

Fixpoint poly_Cobham (e : Cobham) :=
  match e with
    | Zero => pcst 0 0
    | Proj n i => pproj n i
    | Succ b => pplus (pcst 0 1) (pproj 1 0)
    | Smash => pplus (pcst 0 1) (pmult (pproj 2 0) (pproj 2 1))
    | Rec g h0 h1 j => poly_Cobham j
    | Comp n h l => 
      pplus (pcst n 0) 
      (pcomp (poly_Cobham h) (map poly_Cobham l))
  end.

Lemma parity_poly_Cobham : forall (e : Cobham) n,
  arity e = ok_arity n ->
  parity (poly_Cobham e) = n.

Lemma pWF_poly_Cobham : forall (e : Cobham) n,
  arity e = ok_arity n ->
  pWF (poly_Cobham e).

Lemma poly_Cobham_correct : forall (e : Cobham) xl,
  rec_bounded e ->  
  length (Sem e xl) <= 
  peval (poly_Cobham e) (map (@length _) xl). *)
(* BellantoniCook.CobhamLib:
Require Import Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Cobham.

Definition Zero_e (n:nat) : Cobham :=
  Comp n Zero nil.

Lemma arity_Zero n : arity (Zero_e n) = ok_arity n.

Lemma rec_bounded_Zero n : 
  rec_bounded (Zero_e n).

Definition One_e (n:nat) : Cobham :=
  Comp n (Comp 0 (Succ true) [Zero]) nil.

Lemma arity_One n : arity (One_e n) = ok_arity n.

Lemma rec_bounded_One n :
  rec_bounded (One_e n).

Definition App_e : Cobham :=
  Rec (Proj 1 0)
  (Comp 3 (Succ false) [Proj 3 1])
  (Comp 3 (Succ true) [Proj 3 1])
  (Comp 2 Smash [Comp 2 (Succ true) [Proj 2 0]; Comp 2 (Succ true) [Proj 2 1] ]).

Lemma arity_App : arity App_e = ok_arity 2.

Lemma rec_bounded_App : rec_bounded App_e.

Lemma App_correct : forall l,
  Sem App_e l = hd nil l ++ hd nil (tl l).

Opaque App_e.

Definition Rev_e : Cobham :=
  Rec
    Zero
    (Comp 2 App_e [Proj 2 1; Comp 2 (Succ false) [Zero_e 2]])
    (Comp 2 App_e [Proj 2 1; Comp 2 (Succ true) [Zero_e 2]])
    (Proj 1 0).

Lemma arity_Rev : 
  arity Rev_e = ok_arity 1.

Lemma rec_bounded_Rev :
  rec_bounded Rev_e.

Lemma Rev_correct l :
  Sem Rev_e l = List.rev (hd nil l).

Definition RemoveLSZ_e : Cobham :=
  Rec
    Zero
    (Proj 2 1)
    (Comp 2 (Succ true) [Proj 2 0])
    (Proj 1 0).

Lemma arity_RemoveLSZ : 
  arity RemoveLSZ_e = ok_arity 1.

Lemma rec_bounded_RemoveLSZ :
  rec_bounded RemoveLSZ_e.

Lemma RemoveLSZ_app u v l :
  Sem RemoveLSZ_e ((u++v)::l) =
  match Sem RemoveLSZ_e (u::l) with
  | nil => Sem RemoveLSZ_e (v::l)
  | u' => u'++v
  end.

Definition Cond : Cobham :=
  Rec (Proj 3 0) (Proj 5 4) (Proj 5 3) (
    Comp 4 Smash [
      Comp 4 (Succ true) [Proj 4 1];
      Comp 4 Smash [
        Comp 4 (Succ true) [Proj 4 2];
        Comp 4 (Succ true) [Proj 4 3]
      ]
    ]
  ).

Lemma arity_Cond : arity Cond = ok_arity 4.

Lemma rec_bounded_Cond : rec_bounded' Cond.

Lemma Cond_correct : forall l,
  Sem Cond l =
  match hd nil l with
  | nil => hd nil (tl l)
  | true::_ => hd nil (tl (tl l))
  | false::_ => hd nil (tl (tl (tl l)))
  end. *)

Opaque bs2nat.
Opaque Cond.

Lemma bs2nat_smash' : forall u v n,
  bs2nat v = power 2 n ->
  bs2nat (smash' u v) = power 2 (length u + n).
Proof.
  induction u; simpl; intros; auto.
  rewrite bs2nat_false, (IHu v n); trivial.
Qed.

Lemma bs2nat_smash_bs : forall u v,
  bs2nat (smash_bs u v) = power 2 (length u * length v).
Proof.
  induction u; simpl; intros; auto.
  rewrite bs2nat_smash' with (n := length u * length v); trivial.
Qed.

Lemma Smash_correct : forall l,
  bs2nat (Sem Smash l) = power 2 (length (hd nil l) * length (hd nil (tl l))).
Proof.
  intros [ | u [ | v l] ]; trivial; simpl.
  rewrite mult_0_r; simpl.
  induction u as [ | [ | ] u IH]; trivial.
  apply bs2nat_smash_bs.
Qed.

Lemma Zero_correct_bs n l: 
  Sem (Zero_e n) l = nil.
Proof.
  trivial.
Qed.

Lemma Zero_correct n l: 
  bs2nat (Sem (Zero_e n) l) = 0.
Proof.
  trivial.
Qed.

Definition False_e n :=
  Comp n (Succ false) [Zero_e n].

Lemma arity_False: forall n : nat, arity (False_e n) = ok_arity n.
Proof.
  simpl; simpl.
  intros.
  rewrite <- beq_nat_refl.
  simpl.
  trivial.
Qed.

Lemma rec_bounded_False: forall n : nat, rec_bounded (False_e n).
Proof.
 intros; simpl; intuition.
Qed.

Lemma False_correct: forall (n : nat) (l : list bs), bs2nat (Sem (False_e n) l) = 0.
Proof.
 intros; simpl; auto.
Qed.

Lemma False_correct_bs: forall (n : nat) (l : list bs), Sem (False_e n) l = [false].
Proof.
 intros; simpl; auto.
Qed.

Lemma One_correct n l: 
  bs2nat (Sem (One_e n) l) = 1.
Proof.
  trivial.
Qed.

Lemma One_correct_bs n l:
  Sem (One_e n) l = [true].
Proof.
  trivial.
Qed.

Opaque Zero_e One_e False_e Rev_e RemoveLSZ_e.

Definition Normalize_e : Cobham :=
  Comp 1 Rev_e [Comp 1 RemoveLSZ_e [Rev_e]].

Lemma arity_Normalize :
  arity Normalize_e = ok_arity 1.
Proof.
  trivial.
Qed.

Lemma rec_bounded_Normalize :
  rec_bounded Normalize_e.
Proof.
  simpl; intuition.
  apply rec_bounded_Rev.
  apply rec_bounded_RemoveLSZ.
  apply rec_bounded_Rev.
Qed.

Lemma Normalize_correct : forall l,
  bs2nat (Sem Normalize_e l) = bs2nat (Sem (Proj 1 0) l).
Proof.
  destruct l as [ | v l]; trivial;simpl.
  induction v as [ | [ | ] v IH]; trivial.
  
  rewrite bs2nat_true.
  do 2 rewrite Rev_correct in *; simpl in *.
  rewrite RemoveLSZ_app, <- IH.
  destruct (Sem RemoveLSZ_e [rev v]); trivial; simpl.
  rewrite rev_unit; trivial.

  rewrite bs2nat_false.
  do 2 rewrite Rev_correct in *; simpl in *.
  rewrite RemoveLSZ_app, <- IH.
  destruct (Sem RemoveLSZ_e [rev v]); trivial; simpl.
  rewrite rev_unit; trivial.
Qed.

Lemma Normalize_normal : forall l,
  Sem Normalize_e l = nil \/ bs2nat (Sem Normalize_e l) <> 0.
Proof.
  destruct l as [ | v l].
  tauto.
  simpl.
  induction v as [ | [ | ] v IH].
  
  tauto.

  do 2 rewrite Rev_correct in *.
  simpl in *.
  rewrite RemoveLSZ_app.
  destruct (Sem RemoveLSZ_e [rev v]).
  right.
  discriminate.
  right.
  simpl.
  rewrite rev_unit.
  discriminate.

  do 2 rewrite Rev_correct in *.
  simpl in *.
  rewrite RemoveLSZ_app.
  destruct (Sem RemoveLSZ_e [rev v]).
  trivial.
  simpl in *.
  rewrite rev_unit.
  simpl.
  right.
  rewrite bs2nat_false.
  destruct IH as [IH | IH].
  apply app_eq_nil in IH.
  destruct IH as [_ IH].
  congruence.
  omega.
Qed.

Opaque Normalize_e.

Definition Succ_e : Cobham :=
  Rec
    (Comp 0 (Succ true) [Zero])
    (Comp 2 (Succ true) [Proj 2 0])
    (Comp 2 (Succ false) [Proj 2 1])
    (Comp 1 (Succ true) [Proj 1 0]).

Lemma arity_Succ : arity Succ_e = ok_arity 1.
Proof.
  trivial.
Qed.

Lemma length_Succ : forall l,
  length (Sem Succ_e l) <= length (Sem (Comp 1 (Succ true) [Proj 1 0]) l).
Proof.
  destruct l as [ | v l]; trivial; simpl.
  induction v as [ | [ | ] v IH]; trivial; simpl; omega.
Qed.

Lemma le_1_length_Succ v : 
  1 <= length (Sem Succ_e [v]).
Proof.
  destruct v as [ | [ | ] v]; trivial; simpl; omega.
Qed.

Lemma le_length_Succ v :
  length v <= length (Sem Succ_e [v]).
Proof.
induction v as [ | [ | ] v IH].
simpl; omega.
simpl in *.
omega.
trivial.
Qed.

Lemma Succ_length v :
  length (Sem Succ_e v) <= S (length (hd nil v)).
Proof.
 intros; simpl.
 induction (hd nil v); simpl; auto.
 case a; simpl; omega.
Qed.  

Lemma rec_bounded_Succ :
  rec_bounded Succ_e.
Proof.
 simpl; intuition.
 eapply le_trans.
 eapply le_trans.
 2:apply length_Succ.
 simpl; trivial.
 trivial.
Qed.

Lemma Succ_correct : forall l,
  bs2nat (Sem Succ_e l) = 1 + bs2nat (hd nil l).
Proof.
  destruct l as [ | v l]; trivial; simpl hd.
  induction v as [ | [ | ] v IH]; trivial.
  simpl Sem in *.
  rewrite bs2nat_false, bs2nat_true, IH; ring.
Qed.

Opaque Succ_e.

Definition Pred'_e : Cobham :=
  Rec
    Zero
    (Comp 2 (Succ true) [Proj 2 1])
    (Comp 2 (Succ false) [Proj 2 0])
    (Proj 1 0).

Lemma arity_Pred' : arity Pred'_e = ok_arity 1.
Proof.
  trivial.
Qed.

Lemma rec_bounded_Pred' :
  rec_bounded Pred'_e.
Proof.
  simpl.
  intuition.
  destruct l as [ | v l].
  trivial.
  simpl.
  induction v as [ | [ | ] v IH].
  trivial.
  trivial.
  simpl; omega.
Qed.

Lemma Pred'_correct : forall l,
  hd nil l = nil \/ bs2nat (hd nil l) <> 0 ->
  bs2nat (Sem Pred'_e l) =  bs2nat (hd nil l) - 1.
Proof.
intros l H.
destruct l as [ | v l].
simpl.
trivial.
simpl hd.
induction v as [ | [ | ] v IH].

trivial.

simpl Sem in *.
rewrite bs2nat_false, bs2nat_true.
omega.

simpl Sem in *.
rewrite bs2nat_false, bs2nat_true, IH.
simpl in H.
destruct H as [H | H].
congruence.
rewrite bs2nat_false in H.
omega.
simpl in *.
destruct H as [H | H].
congruence.
rewrite bs2nat_false in H.

simpl in H.
right.
omega.
Qed.

Opaque Pred'_e.

Definition Pred_e : Cobham :=
  Comp 1 Pred'_e [Normalize_e].

Lemma arity_Pred : arity Pred_e = ok_arity 1.
Proof.
trivial.
Qed.

Lemma rec_bounded_Pred :
  rec_bounded Pred_e.
Proof.
simpl.
intuition.
apply rec_bounded_Pred'.
apply rec_bounded_Normalize.
Qed.

Lemma Pred_correct : forall l,
  bs2nat (Sem Pred_e l) =  bs2nat (hd nil l) - 1.
Proof.
intro l.
simpl.
rewrite Pred'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_0.
trivial.
apply Normalize_normal.
Qed.

Opaque Pred_e.

Definition OneMinus'_e : Cobham :=
  Rec2
    (One_e 0)
    (Zero_e 2)
    (One_e 1).

Lemma arity_OneMinus' : arity OneMinus'_e = ok_arity 1.
Proof.
trivial.
Qed.

Lemma rec_bounded_OneMinus' :
  rec_bounded OneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_One.
apply rec_bounded_One.
apply rec_bounded_Zero.
apply rec_bounded_Zero.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
auto with arith.
auto with arith.
Qed.

Lemma OneMinus'_correct : forall l,
  hd nil l = nil \/ bs2nat (hd nil l) <> 0 ->
  bs2nat (Sem OneMinus'_e l) = 1 - bs2nat (hd nil l).
Proof.
intros [ | v l] H.
trivial.
simpl hd.
destruct v as [ | [ | ] v].
trivial.
trivial.
simpl Sem in *.
simpl in *.
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct H as [H | H].
congruence.
destruct (2 * bs2nat v).
tauto.
trivial.
Qed.

Opaque OneMinus'_e.

Definition OneMinus_e : Cobham :=
  Comp 1 OneMinus'_e [Normalize_e].

Lemma arity_OneMinus : arity OneMinus_e = ok_arity 1.
Proof.
trivial.
Qed.

Lemma rec_bounded_OneMinus :
  rec_bounded OneMinus_e.
Proof.
simpl.
intuition.
apply rec_bounded_OneMinus'.
apply rec_bounded_Normalize.
Qed.

Lemma OneMinus_correct : forall l,
  bs2nat (Sem OneMinus_e l) = 1 - bs2nat (hd nil l).
Proof.
intro l.
simpl.
rewrite OneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_0.
trivial.
apply Normalize_normal.
Qed.

Opaque OneMinus_e.

Definition Div2_e : Cobham :=
  Rec2
    Zero
    (Proj 2 0)
    (Proj 1 0).

Lemma arity_Div2 : arity Div2_e = ok_arity 1.
Proof.
trivial.
Qed.

Lemma length_Div2 : forall l,
  length (Sem Div2_e l) = length (hd nil l) - 1.
Proof.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
simpl; omega.
simpl; omega.
Qed.

Lemma rec_bounded_Div2 :
  rec_bounded Div2_e.
Proof.
simpl.
intuition.
destruct l as [ | v l].
trivial.
simpl.
destruct v as [ | [ | ] v].
trivial.
simpl; omega.
simpl; omega.
Qed.

Lemma Div2_correct_bs : forall l,
  Sem Div2_e l =
  tl (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl.
destruct v as [ | [ | ] v]; trivial.
Qed.

Lemma Div2_correct : forall l,
  bs2nat (Sem Div2_e l) = div2 (bs2nat (hd nil l)).
Proof.
intros [ | v l].
trivial.
rewrite Div2_correct_bs.
simpl.
apply bs2nat_tl.
Qed.

Opaque Div2_e.

Definition Mod2_e : Cobham :=
  Rec
    Zero
    (False_e 2)
    (One_e 2)
    (One_e 1).

Lemma arity_Mod2 : arity Mod2_e = ok_arity 1.
Proof.
simpl.
trivial.
Qed.

Lemma rec_bounded_Mod2 :
  rec_bounded Mod2_e.
Proof.
simpl.
intuition.
apply rec_bounded_One.
apply rec_bounded_False.
apply rec_bounded_One.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH].
simpl; omega.
auto with arith.
auto with arith.
Qed.

Lemma Mod2_correct_bs : forall l, 
  (hd nil l) <> nil ->
  Sem Mod2_e l = [hd true (hd nil l)].
Proof.
  intros.
  simpl.
  destruct (hd nil l); simpl; trivial.
  elim H; trivial.
  case b.
  rewrite One_correct_bs.
  trivial.
  rewrite False_correct_bs.
  trivial.
Qed.

Lemma Mod2_correct : forall l,
  bs2nat (Sem Mod2_e l) = mod2 (bs2nat (hd nil l)).
Proof.
unfold mod2.
destruct l as [ | v l].
trivial.
simpl hd.
destruct v as [ | [ | ] v].
trivial.
simpl Sem in *.
rewrite One_correct, bs2nat_true.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
rewrite div2_double_plus_one.
omega.
simpl Sem in *.
rewrite bs2nat_false.
rewrite div2_double.
auto with arith.
Qed.

Opaque Mod2_e.

Definition Length_e : Cobham :=
  Rec2
    Zero
    (Comp 2 Succ_e [Proj 2 1])
    (Proj 1 0).

Lemma arity_Length : arity Length_e = ok_arity 1.
Proof.
  trivial.
Qed.

Lemma rec_bounded_Length :
  rec_bounded Length_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
apply rec_bounded_Succ.
destruct l as [ | v l].
trivial.
simpl.
induction v as [ | [ | ] v IH].
trivial.
simpl.
eapply le_trans.
apply length_Succ.
simpl; omega.
simpl.
eapply le_trans.
apply length_Succ.
simpl; omega.
Qed.

Lemma Length_correct : forall l,
  bs2nat (Sem Length_e l) = length (hd nil l).
Proof.
destruct l as [ | v l].
trivial.
simpl hd.
induction v as [ | [ | ] v IH].
trivial.
simpl.
rewrite Succ_correct.
simpl.
f_equal.
trivial.
simpl.
rewrite Succ_correct.
simpl.
f_equal.
trivial.
Qed.

Opaque Length_e.

Definition MultOneMinus'_e : Cobham :=
  Comp 2 Cond [
    Proj 2 1;
    Proj 2 0;
    Zero_e 2;
    Zero_e 2
  ].

Lemma arity_MultOneMinus' : arity MultOneMinus'_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_MultOneMinus' :
  rec_bounded MultOneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.
apply arity_Cond.
apply rec_bounded_Cond.
apply rec_bounded_Zero.
apply rec_bounded_Zero.
Qed.

Lemma MultOneMinus'_correct : forall l,
  hd nil (tl l) = nil \/ bs2nat (hd nil (tl l)) <> 0 ->
  bs2nat (Sem MultOneMinus'_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
trivial.
auto with arith.
simpl.
rewrite Cond_correct.
simpl in *.
destruct v as [ | [ | ] v].
auto with arith.
trivial.
rewrite Zero_correct.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.
congruence.
tauto.
trivial.
Qed. 

Opaque MultOneMinus'_e.

Definition MultOneMinus_e : Cobham :=
  Comp 2 MultOneMinus'_e [Proj 2 0; Comp 2 Normalize_e [Proj 2 1]].

Lemma arity_MultOneMinus : arity MultOneMinus_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_MultOneMinus :
  rec_bounded MultOneMinus_e.
Proof.
simpl.
intuition.
apply rec_bounded_MultOneMinus'.
apply rec_bounded_Normalize.
Qed.

Lemma MultOneMinus_correct : forall l,
  bs2nat (Sem MultOneMinus_e l) = bs2nat (hd nil l) * (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1, hd_nth_0.
trivial.
simpl.
apply Normalize_normal.
Qed.

Opaque MultOneMinus_e.

Definition PlusOneMinus'_e : Cobham :=
  Comp 2 Cond [
    Proj 2 1;
    Comp 2 Succ_e [Proj 2 0];
    Proj 2 0;
    Proj 2 0
  ].

Lemma arity_PlusOneMinus' : arity PlusOneMinus'_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_PlusOneMinus' :
  rec_bounded PlusOneMinus'_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.
apply arity_Cond.
apply rec_bounded_Cond.
apply rec_bounded_Succ.
Qed.

Lemma PlusOneMinus'_correct : forall l,
  hd nil (tl l) = nil \/ bs2nat (hd nil (tl l)) <> 0 ->
  bs2nat (Sem PlusOneMinus'_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intros [ | u [ | v l] ] H.
trivial.
simpl.
rewrite Cond_correct.
simpl.
rewrite Succ_correct, bs2nat_nil.
simpl; ring.
simpl.
rewrite Cond_correct.
simpl.
destruct v as [ | [ | ] v].
rewrite Succ_correct, bs2nat_nil.
simpl; ring.
trivial.
simpl in H.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.
congruence.
tauto.
trivial.
Qed.

Lemma PlusOneMinus'_length : forall l,
  length (Sem PlusOneMinus'_e [nth 0 l nil; Sem Normalize_e [nth 1 l nil]])
  <= S (length (hd nil l)).
Proof.
 intros; simpl.
 rewrite Cond_correct; simpl.
 rewrite hd_nth_0.
 destruct (Sem Normalize_e [nth 1 l nil]); auto.
 apply Succ_length.
 case b; auto.
Qed.

Opaque PlusOneMinus'_e.

Definition PlusOneMinus_e : Cobham :=
  Comp 2 PlusOneMinus'_e [Proj 2 0; Comp 2 Normalize_e [Proj 2 1] ].

Lemma arity_PlusOneMinus : arity PlusOneMinus_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_PlusOneMinus :
  rec_bounded PlusOneMinus_e.
Proof.
simpl.
intuition.
apply rec_bounded_PlusOneMinus'.
apply rec_bounded_Normalize.
Qed.

Lemma PlusOneMinus_correct : forall l,
  bs2nat (Sem PlusOneMinus_e l) = bs2nat (hd nil l) + (1 - bs2nat (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite PlusOneMinus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1, hd_nth_0.
trivial.
simpl.
apply Normalize_normal.
Qed.

Lemma PlusOneMinus_length : forall l,
  length (Sem PlusOneMinus_e [nth 0 l nil; nth 1 l nil]) <= S (length (nth 0 l nil)).
Proof.
 intros; simpl.
 rewrite <- hd_nth_0 at 2.
 apply PlusOneMinus'_length.
Qed.

Opaque PlusOneMinus_e.

Definition OneMinusMultPlus'_e : Cobham :=
  Rec
    (Proj 1 0)
    (Comp 3 (Succ false) [Proj 3 0])
    (Comp 3 (Succ true) [Proj 3 0])
    (Comp 2 Smash [Comp 2 Succ_e [Proj 2 1]; Comp 2 (Succ true) [Proj 2 0]]).

Lemma arity_OneMinusMultPlus' : arity OneMinusMultPlus'_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_OneMinusMultPlus' :
  rec_bounded OneMinusMultPlus'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Succ.
destruct l as [ | v l].
simpl; omega.
simpl.
induction v as [ | [ | ] v IH]; simpl.
rewrite length_smash.
simpl.
rewrite mult_1_r.
eapply le_trans; [idtac | apply le_n_S; apply le_length_Succ].
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
rewrite length_smash.
simpl.
apply le_n_S.
rewrite <- (mult_1_l (length v)).
apply mult_le_compat.
apply le_1_length_Succ.
omega.
Qed.

Lemma OneMinusMultPlus'_correct : forall l,
  hd nil l = nil \/ bs2nat (hd nil l) <> 0 ->
  bs2nat (Sem OneMinusMultPlus'_e l) =
  (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) +
  bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intros [ | v l] H.
trivial.
simpl.
destruct v as [ | [ | ] v]; simpl.
rewrite bs2nat_nil, hd_nth_0.
ring.
rewrite bs2nat_true.
simpl; ring.
simpl in *.
rewrite bs2nat_false in *.
destruct (2 * bs2nat v).
destruct H.
congruence.
tauto.
ring.
Qed.

Opaque OneMinusMultPlus'_e.

Definition OneMinusMultPlus_e : Cobham :=
  Comp 2 OneMinusMultPlus'_e [Comp 2 Normalize_e [Proj 2 0]; Proj 2 1].

Lemma arity_OneMinusMultPlus : arity OneMinusMultPlus_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_OneMinusMultPlus :
  rec_bounded OneMinusMultPlus_e.
Proof.
simpl.
intuition.
apply rec_bounded_OneMinusMultPlus'.
apply rec_bounded_Normalize.
Qed.

Lemma OneMinusMultPlus_correct : forall l,
  bs2nat (Sem OneMinusMultPlus_e l) =
  (1 - bs2nat (hd nil l)) * bs2nat (hd nil (tl l)) +
  bs2nat (hd nil l) * (1 - (1 - bs2nat (hd nil l))).
Proof.
intro l.
simpl.
rewrite OneMinusMultPlus'_correct.
simpl.
rewrite Normalize_correct.
simpl.
rewrite hd_nth_1, hd_nth_0.
trivial.
apply Normalize_normal.
Qed.

Opaque OneMinusMultPlus_e.

Definition PlusMod2_e : Cobham :=
  Comp 2 Cond [
     Proj 2 1;
     Proj 2 0;
     Comp 2 Succ_e [Proj 2 0];
     Proj 2 0
  ].

Lemma arity_PlusMod2 :
  arity PlusMod2_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_PlusMod2 :
  rec_bounded PlusMod2_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.
apply arity_Cond.
apply rec_bounded_Cond.
apply rec_bounded_Succ.
Qed.

Lemma PlusMod2_correct : forall l,
  bs2nat (Sem PlusMod2_e l) =
  bs2nat (hd nil l) + mod2 (bs2nat (hd nil (tl l))).
Proof.
unfold mod2.
intros [ | u [ | v l] ]; simpl.
trivial.
rewrite Cond_correct, bs2nat_nil; simpl.
omega.
rewrite Cond_correct; simpl.
destruct v as [ | [ | ] v].
rewrite bs2nat_nil.
simpl; omega.
rewrite bs2nat_true, Succ_correct.
change (1 + 2 * bs2nat v) with (S (2 * bs2nat v)).
rewrite div2_double_plus_one.
simpl hd; omega.
rewrite bs2nat_false, div2_double.
omega.
Qed.

Opaque PlusMod2_e.

Definition PlusOneMinusMod2_e : Cobham :=
  Comp 3 Cond [
    Proj 3 2;
    Proj 3 0;
    Comp 3 PlusOneMinus_e [Proj 3 0; Proj 3 1];
    Proj 3 0
  ].

Lemma arity_PlusOneMinusMod2 :
  arity PlusOneMinusMod2_e = ok_arity 3.
Proof.
trivial.
Qed.

Lemma rec_bounded_PlusOneMinusMod2 :
  rec_bounded PlusOneMinusMod2_e.
Proof.
simpl.
intuition.
apply rec_bounded'_spec with 4.
apply arity_Cond.
apply rec_bounded_Cond.
apply rec_bounded_PlusOneMinus.
Qed.

Lemma PlusOneMinusMod2_correct : forall l,
  bs2nat (Sem PlusOneMinusMod2_e l) =
  bs2nat (hd nil l) +
  (1 - bs2nat (hd nil (tl l))) *
  mod2 (bs2nat (hd nil (tl (tl l)))).
Proof.
unfold mod2.
intros [ | u [ | v [ | w l] ] ]; simpl.
trivial.
trivial.
rewrite Cond_correct.
simpl.
rewrite bs2nat_nil.
simpl; ring.
rewrite Cond_correct.
simpl.
destruct w as [ | [ | ] w].
rewrite bs2nat_nil.
simpl; ring.
rewrite PlusOneMinus_correct.
simpl.
rewrite bs2nat_true.
change (1 + 2 * bs2nat w) with (S (2 * bs2nat w)).
rewrite div2_double_plus_one.
case (bs2nat v).
omega.
trivial.
rewrite bs2nat_false.
rewrite div2_double.
case (bs2nat v).
omega.
trivial.
Qed.

Lemma PlusOneMinusMod2_length : forall l,
  length (Sem PlusOneMinusMod2_e l) <= S (length (hd nil l)).
Proof.
 intros; simpl.
 rewrite Cond_correct; simpl.
 rewrite hd_nth_0.
 destruct (nth 2 l nil); auto.
 case b; auto.
 apply PlusOneMinus_length.
Qed.

Opaque PlusOneMinusMod2_e.

Definition MultTwoPowerLength'_e : Cobham :=
  Rec2
    (Proj 1 0)
    (Comp 3 (Succ false) [Proj 3 1])
    (Comp 2 Smash [Comp 2 (Succ true) [Proj 2 0]; Comp 2 (Succ true) [Proj 2 1] ] ).

Lemma arity_MultTwoPowerLength' :
  arity MultTwoPowerLength'_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_MultTwoPowerLength' :
  rec_bounded MultTwoPowerLength'_e.
Proof.
simpl.
intuition.
destruct l as [ | u [ | v l] ]; simpl.
omega.
rewrite length_smash; simpl.
rewrite mult_1_r.
induction u as [ | [ | ] u IH]; simpl; omega.
rewrite length_smash', length_smash; simpl.
induction u as [ | [ | ] u IH]; simpl; omega.
Qed.

Lemma MultTwoPowerLength'_correct : forall l,
  bs2nat (Sem MultTwoPowerLength'_e l) =
  power 2 (length (hd nil l)) * bs2nat (hd nil (tl l)).
Proof.
destruct l as [ | u [ | v l] ].
trivial.
simpl.
rewrite bs2nat_nil, mult_0_r.
induction u as [ | [ | ] u IH].
trivial.
simpl.
rewrite bs2nat_false.
omega.
simpl.
rewrite bs2nat_false.
omega.
induction u as [ | [ | ] u IH]; simpl in *.
trivial.
rewrite bs2nat_false, plus_0_r, IH.
ring.
rewrite bs2nat_false, plus_0_r, IH.
ring.
Qed.

Opaque MultTwoPowerLength'_e.

Definition MultTwoPowerLength_e : Cobham :=
  Comp 2 MultTwoPowerLength'_e [Proj 2 1; Proj 2 0].

Lemma arity_MultTwoPowerLength :
  arity MultTwoPowerLength_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_MultTwoPowerLength :
  rec_bounded MultTwoPowerLength_e.
Proof.
simpl.
intuition.
apply rec_bounded_MultTwoPowerLength'.
Qed.

Lemma MultTwoPowerLength_correct : forall l,
  bs2nat (Sem MultTwoPowerLength_e l) =
  bs2nat (hd nil l) * power 2 (length (hd nil (tl l))).
Proof.
intro l.
simpl.
rewrite MultTwoPowerLength'_correct; simpl.
rewrite hd_nth_0, hd_nth_1.
ring.
Qed.

Opaque MultTwoPowerLength_e.

Definition DivTwoPower'_e : Cobham :=
  Rec2
    (Proj 1 0)
    (Comp 3 Div2_e [Proj 3 1])
    (Proj 2 1).

Lemma arity_DivTwoPower' :
  arity DivTwoPower'_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma length_DivTwoPower' : forall l,
  length (Sem DivTwoPower'_e l) = length (hd nil (tl l)) - length (hd nil l).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
induction u as [ | [ | ] u IH].
trivial.
simpl.
rewrite length_Div2.
simpl; omega.
simpl.
rewrite length_Div2.
simpl; omega.
induction u as [ | [ | ] u IH].
simpl; omega.
simpl in *.
rewrite length_Div2.
simpl; omega.
simpl in *.
rewrite length_Div2.
simpl; omega.
Qed.

Lemma rec_bounded_DivTwoPower' :
  rec_bounded DivTwoPower'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Div2.
apply rec_bounded_Div2.
destruct l as [ | u [ | v l] ].
trivial.
simpl.
induction u as [ | [ | ] u IH].
trivial.
simpl.
rewrite length_Div2.
simpl; omega.
simpl.
rewrite length_Div2.
simpl; omega.
induction u as [ | [ | ] u IH].
trivial.
simpl in *.
rewrite length_Div2.
simpl; omega.
simpl in *.
rewrite length_Div2.
simpl; omega.
Qed.

Lemma DivTwoPower'_correct_bs : forall l,
  Sem DivTwoPower'_e l =
  fun_power (length (hd nil l)) (@tl _) (hd nil (tl l)).
Proof.
intros [ | u [ | v l] ].
trivial.
simpl.
induction u as [ | [ | ] u IH].
trivial.
simpl.
rewrite Div2_correct_bs.
simpl; congruence.
simpl.
rewrite Div2_correct_bs.
simpl; congruence.
simpl.
induction u as [ | [ | ] u IH].
trivial.
simpl.
rewrite Div2_correct_bs.
simpl; congruence.
simpl.
rewrite Div2_correct_bs.
simpl; congruence.
Qed.

Lemma DivTwoPower'_correct : forall l,
  bs2nat (Sem DivTwoPower'_e l) =
  fun_power (length (hd nil l)) div2 (bs2nat (hd nil (tl l))).
Proof.
intro l.
rewrite DivTwoPower'_correct_bs.
induction (length (hd nil l)).
trivial.
simpl.
rewrite bs2nat_tl.
congruence.
Qed.

Opaque DivTwoPower'_e.

Definition DivTwoPower_e : Cobham :=
  Comp 2 DivTwoPower'_e [Proj 2 1; Proj 2 0].

Lemma arity_DivTwoPower :
  arity DivTwoPower_e = ok_arity 2.
Proof.
trivial.
Qed.

Lemma rec_bounded_DivTwoPower :
  rec_bounded DivTwoPower_e.
Proof.
simpl.
intuition.
apply rec_bounded_DivTwoPower'.
Qed.

Lemma DivTwoPower_correct_bs : forall l,
  Sem DivTwoPower_e l =
  fun_power (length (hd nil (tl l))) (@tl _) (hd nil l).
Proof.
intro l.
simpl.
rewrite DivTwoPower'_correct_bs.
simpl.
rewrite <- hd_nth_0, <- hd_nth_1.
trivial.
Qed.

Lemma length_DivTwoPower : forall l,
  length (Sem DivTwoPower_e l) = length (hd nil l) - length (hd nil (tl l)).
Proof.
intro l.
simpl.
rewrite length_DivTwoPower'.
simpl.
rewrite <- hd_nth_0, <- hd_nth_1.
trivial.
Qed.

Lemma skipn_tl : forall n (l : bs),
  skipn (S n) l = tl (skipn n l).
Proof.
  intros.
  destruct (le_lt_dec (length l) n).
  rewrite skipn_nil; simpl.
  rewrite skipn_nil; simpl; auto.
  omega.
  rewrite (skipn_hd n l true).
  reflexivity.
  trivial.
Qed.   
  
Lemma DivTwoPower_correct : forall l,
  Sem DivTwoPower_e l =
  skipn (length (nth 1 l nil)) (nth 0 l nil).
Proof.
  intros l.
  simpl.
  rewrite DivTwoPower'_correct_bs; simpl.
  induction (nth 1 l nil); simpl; auto.
  rewrite IHl0.
  destruct (nth 0 l nil); simpl.
  rewrite skipn_nil; simpl; auto.
  omega.
  rewrite <- skipn_tl.
  simpl.
  trivial.
Qed.

Opaque DivTwoPower_e.

Definition DivDivTwoPower_e : Cobham :=
  Comp 3 DivTwoPower_e [Proj 3 0; Comp 3 DivTwoPower_e [Proj 3 1; Proj 3 2] ].

Lemma arity_DivDivTwoPower :
  arity DivDivTwoPower_e = ok_arity 3.
Proof.
trivial.
Qed.

Lemma rec_bounded_DivDivTwoPower :
  rec_bounded DivDivTwoPower_e.
Proof.
simpl.
intuition.
apply rec_bounded_DivTwoPower.
apply rec_bounded_DivTwoPower.
Qed.

Lemma DivDivTwoPower_correct : forall l,
  Sem DivDivTwoPower_e l =
  skipn (length (nth 1 l nil) - length (nth 2 l nil)) (nth 0 l nil).
Proof.
  intros l.
  simpl.
  rewrite DivTwoPower_correct; simpl.
  rewrite DivTwoPower_correct; simpl.
  f_equal.
  rewrite length_skipn; trivial.
Qed.

Opaque DivDivTwoPower_e.

Fixpoint Repeat_e (n l : nat) (b : bool) : Cobham :=
  match l with
    | 0 => Zero_e n
    | S l' => Comp n (Succ b) [Repeat_e n l' b]
  end.

Lemma arity_Repeat : forall n len b,
  arity (Repeat_e n len b) = ok_arity n.
Proof.
induction len as [ | len' IH]; simpl; trivial; intros [ | ];
  rewrite IH; simpl; rewrite <- beq_nat_refl; trivial.
Qed.

Lemma rec_bounded_Repeat : forall n len b,
  rec_bounded (Repeat_e n len b).
Proof.
intros n len b.
induction len as [ | len' IH]; simpl.
apply rec_bounded_Zero.
intuition.
Qed.

Lemma length_Repeat : forall n l b l',
  length (Sem (Repeat_e n l b) l') = l.
Proof.
  induction l; simpl; auto.
Qed.

Opaque Repeat_e.

Definition RoseS'_e : Cobham :=
  Rec2
    (Zero_e 2)
    (Comp 4 PlusOneMinusMod2_e [
      Comp 4 (Succ false) [Proj 4 1];
      Comp 4 DivTwoPower_e [Comp 4 DivTwoPower_e [Proj 4 2; Proj 4 0]; Proj 4 3];
      Comp 4 DivDivTwoPower_e [Proj 4 2; Proj 4 2; Comp 4 (Succ false) [Proj 4 0]]
    ])
    (Comp 3 Smash [Proj 3 0; Repeat_e 3 2 true]).

Definition arity_RoseS' :
  arity RoseS'_e = ok_arity 3.
Proof.
trivial.
Qed.

Lemma rec_bounded_RoseS' :
  rec_bounded RoseS'_e.
Proof.
simpl.
intuition.
apply rec_bounded_Repeat.
apply rec_bounded_Zero.
apply rec_bounded_PlusOneMinusMod2.
apply rec_bounded_DivTwoPower.
apply rec_bounded_DivTwoPower.
apply rec_bounded_DivDivTwoPower.
apply rec_bounded_PlusOneMinusMod2.
apply rec_bounded_DivTwoPower.
apply rec_bounded_DivTwoPower.
apply rec_bounded_DivDivTwoPower.
rewrite <- hd_nth_0.
induction (hd nil l); simpl.
rewrite Zero_correct_bs; simpl; auto with arith.
case a.
eapply le_trans.
apply PlusOneMinusMod2_length.
simpl.
rewrite length_smash'.
rewrite length_Repeat.
omega.
eapply le_trans.
apply PlusOneMinusMod2_length.
simpl.
rewrite length_smash'.
rewrite length_Repeat.
omega.
Qed.

Definition RoseS_e : Cobham :=
  Comp 3 RoseS'_e [Proj 3 2; Proj 3 0; Proj 3 1].

Lemma arity_RoseS :
  arity RoseS_e = ok_arity 3.
Proof.
trivial.
Qed.

Opaque RoseS'_e.

Lemma rec_bounded_RoseS :
  rec_bounded RoseS_e.
Proof.
simpl.
intuition.
apply rec_bounded_RoseS'.
Qed.

Transparent RoseS'_e.

Lemma bs2nat_firstn_false : forall n l,
  bs2nat (firstn n (false :: l)) = 2 * bs2nat (firstn (n-1) l).
Proof.
  intros.
  destruct n.
  simpl.
  rewrite bs2nat_nil; ring.
  simpl firstn.
  rewrite bs2nat_false.
  f_equal.
  f_equal.
  f_equal.
  omega.
Qed.

Lemma bs2nat_app : forall l1 l2,
  bs2nat (l1 ++ l2) = bs2nat l1 + bs2nat (repeat (length l1) false ++ l2).
Proof.
 intros.
 induction l1; simpl.
 rewrite bs2nat_nil; auto.
 rewrite bs2nat_false; simpl.
 destruct a; simpl.
 repeat rewrite bs2nat_true.
 rewrite IHl1; simpl.
 simpl; ring.
 repeat rewrite bs2nat_false.
 rewrite IHl1; simpl.
 simpl; ring.
Qed.

Lemma bs2nat_power : forall l n,
  bs2nat (repeat n false ++ l) = (power 2 n) * (bs2nat l).
Proof.
 induction n; simpl; auto.
 rewrite bs2nat_false; simpl.
 rewrite IHn; ring.
Qed.

Fixpoint RoseS_spec (x y z : bs) :=
  match z with
    | nil => nil
    | _ :: z' =>
      if leb (length z) (length x - length y)
        then false :: RoseS_spec x y z'
        else hd false (skipn (length x - length z) x) :: RoseS_spec x y z'
  end.

Lemma RoseS_spec2_false : forall x y z,
  length z <= length x - length y ->
  bs2nat (RoseS_spec x y z) = 0.
Proof.
 induction z; simpl; intros.
 rewrite bs2nat_nil; trivial.
 case_eq (length x - length y); intros.
 rewrite H0 in H.
 elimtype False; omega.
 case_eq (leb (length z) n); intros.
 apply leb_complete in H1.
 rewrite bs2nat_false, IHz; auto.
 omega.
 apply leb_complete_conv in H1.
 elimtype False; omega.
Qed.

Lemma skipn_roseS : forall x y z,
  bs2nat (skipn (length z) (RoseS_spec x y z)) = 0.
Proof.
  induction z; simpl.
  rewrite bs2nat_nil; auto.
  case_eq (length x - length y); intros; auto.
  case_eq (leb (length z) n); intros; auto.
Qed.

Lemma RoseS_cons : forall x y z b1 b2,
  length z <= length x ->
  RoseS_spec (b1 :: x) (b2 :: y) z = RoseS_spec x y z.
Proof.
  induction z; simpl; trivial; intros.
  case_eq (length x - length y); intros.
  rewrite IHz;[ | omega ]; clear IHz.
  f_equal.
  destruct x; simpl in *.
  elimtype False; omega.
  destruct y; simpl in *.
  discriminate.
  destruct z; simpl.
  rewrite <- minus_n_O; trivial.
  simpl in *.
  cutrewrite (length x - length z = S (length x - S (length z))).
  simpl; trivial.
  omega.
  case_eq (leb (length z) n); intros.
  rewrite IHz; auto.
  omega.
  rewrite IHz.
  f_equal.  
  apply leb_complete_conv in H1.
  destruct x; simpl in *.
  discriminate.
  destruct y; simpl in *.
  elimtype False; omega.
  destruct z; simpl.
  rewrite <- minus_n_O; trivial.
  cutrewrite (length x - length z = S (length x - S (length z))).
  simpl; trivial.
  simpl in *; omega.
  omega.
Qed.

Lemma bs2nat_cons_eq : forall b l1 l2,
  bs2nat l1 = bs2nat l2 ->
  bs2nat (b :: l1) = bs2nat (b :: l2).
Proof.
  intros.
  case b.
  repeat rewrite bs2nat_true; ring [H].
  repeat rewrite bs2nat_false; ring [H].
Qed.

Fixpoint RoseS_spec' (x : bs) (y z : nat) :=
  match z with
    | 0 => nil
    | S z' =>
      if leb z (length x - y)
        then false :: RoseS_spec' x y z'
        else hd false (skipn (length x - z) x) :: RoseS_spec' x y z'
  end.
