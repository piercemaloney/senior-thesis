

Require Import Bool Arith List.

Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.
(* BellantoniCook.Lib:
Require Import Bool Arith Div2 List Permutation.
Require Export Omega.

Global Obligation Tactic := idtac.

Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) .. ).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.

Lemma length_tail A l : length (@tail A l) = length l - 1.

Lemma hd_nth_0 A (l : list A) d :
  hd d l = nth 0 l d.

Lemma hd_nth_1 A (l : list A) d :
  hd d (tl l) = nth 1 l d.

Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) :
  In (hd d l) l.

Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).

Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).

Lemma map_eq_hd :
  forall A B (f:A->B) d l1 l2,
  map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).

Lemma firstn_nil {A} n : firstn n (@nil A) = nil.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma nth_firstn : forall A i j (l:list A) d,
  i < j -> nth i (firstn j l) d = nth i l d.

Lemma nth_skipn A i j (l:list A) d : 
  nth i (skipn j l) d = nth (j+i) l d.

Lemma length_skipn : forall A n (y : list A),
  length (skipn n y) = length y - n.

Lemma skipn_length : forall {A} n (l:list A), 
  length (skipn n l) = length l - n.

Lemma cons_skipn :
  forall A d i (l:list A),
  i < length l ->
  nth i l d :: skipn (S i) l = skipn i l.

Lemma skipn_plus :
  forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).

Lemma skipn_hd : forall {A} n y (d:A), 
  n < length y -> 
  skipn n y = nth n y d :: skipn (S n) y.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma skipn_app {A} (l l' : list A) : 
  skipn (length l) (l ++ l') = l'.

Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.

Lemma map_firstn : forall A B (f:A->B) n l,
  map f (firstn n l) = firstn n (map f l).

Lemma map_skipn : forall A B (f:A->B) n l,
  map f (skipn n l) = skipn n (map f l).

Lemma map_nth_seq : forall A (l:list A) len n d,
  length l = len + n ->
  map (fun x : nat => nth x l d) (seq n len) = (skipn n l).

Lemma skipn_nil_length : forall A n (l : list A),
  skipn n l = nil -> length l <= n.

Lemma firstn_map_nth :
  forall A d n m (l:list A),
  m+n <= length l ->
  firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma in_seq_iff : forall x len start,
  In x (seq start len) <-> start <= x < start+len.

Lemma nth_map_cst :
  forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.

Lemma nth_S_tl A (l : list A) d n :
  nth n (tl l) d = nth (S n) l d.

Lemma map_ext2 : forall {A B} (f g : A -> B) l,
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma map_nth2
  (A B : Type) (f : A -> B) (l : list A) b d n :
  (f d) = b ->
  nth n (map f l) b = f (nth n l d).

Lemma length_plus_ex {A} n1 n2 (l : list A):
  length l = n1 + n2 ->
  exists l1, exists l2,
    length l1 = n1 /\ length l2 = n2 /\ l = l1 ++ l2.

Lemma tl_app : forall A (l1 l2 : list A),
  l1 <> nil ->
  tl (l1 ++ l2) = tl l1 ++ l2.

Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, 
 map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.

Lemma map_seq_shift : forall A m (f : nat -> A) n,
n <> 0 ->
map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).

Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, 
 map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.

Lemma seq_app : forall x y z,
  seq x y ++ seq (x + y) z = seq x (y + z).

Definition andl {A} (P:A->Prop)(l:list A) : Prop :=
  fold_right (fun a res => P a /\ res) True l.

Lemma forall_andl A (P:A->Prop) l :
  (forall x, In x l -> P x) <-> andl P l.

Fixpoint fun_power {A:Type}(n:nat)(f:A->A)(x:A) : A :=
  match n with
  | 0 => x
  | S n' => f (fun_power n' f x)
  end.

Lemma fun_power_minus_S : forall A (f:A->A) x m n,
  m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.

Definition mod2 (n : nat) : nat :=
  n - 2 * div2 n.

Fixpoint power (m n:nat) : nat :=
 match n with
 | 0 => 1
 | S n' => m * power m n'
 end.

Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.

Definition plusl (l:list nat) : nat :=
  fold_right plus 0 l.

Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.

Lemma plusl_app l1 l2 :
  plusl (l1++l2) = plusl l1 + plusl l2.

Lemma plusl_compat : forall A (l : list A) f g,
  (forall x, In x l -> f x <= g x) ->
  plusl (map f l) <= plusl (map g l).

Definition multl (l:list nat) : nat :=
  fold_right mult 1 l.

Lemma multl_app l1 l2 :
  multl (l1++l2) = multl l1 * multl l2.

Lemma multl_plus_distr_l n l :
  n * plusl l = plusl (map (fun m => n * m) l).

Fixpoint maxl l := 
  match l with
    | nil => 0
    | a :: l' => max a (maxl l')
  end.

Lemma in_le_maxl x l : In x l -> x <= maxl l.

Lemma maxl_map A l (f : A -> nat) n :
  (forall x, In x l -> f x = n) ->
  maxl (map f l) <= n.

Lemma maxl_le l e :
  maxl l <= e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le l e :
  maxl l = e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] = e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] <= e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_bound e1 e2 e3 e :
  e1 <= e -> e2 <= e -> e3 <= e ->
  maxl [e1; e2; e3] <= e.

Lemma maxl_bound_in l e :
  (forall e', In e' l -> e' <= e) -> maxl l <= e.

Lemma maxl_cons l n : n <= maxl (n :: l).

Lemma le_maxl_cons l m n :
 n <= maxl l -> n <= maxl (m :: l).

Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i,
  m d = 0 -> m (nth i l d) <= maxl (map m l).

Lemma length_hd_app A (l1 l2 : list (list A)) :
  length (hd nil l1) <= length (hd nil (l1 ++ l2)).

Lemma length_nth_app A (l1 l2 : list (list A)) i :
  length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).

Lemma maxl_nth l :
  exists i, maxl l = nth i l 0.

Lemma maxl_map_0 A l (f : A -> nat)  :
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_le_plusl : forall l, maxl l <= plusl l.

Lemma forallb_forall_conv :
  forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\ f x = false).

Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d,
  p d = true ->
  forallb p l = true ->
  p (nth n l d) = true.

Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d,
  forallb p l = true ->
  p d = true ->
  p (hd d l) = true.

Lemma forallb_tl : forall A (l : list A) (p : A -> bool),
  forallb p l = true ->
  forallb p (tail l) = true.

Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B),
  (forall x, In x l -> p (f x) = true) ->
  forallb p (map f l) = true.

Fixpoint repeat {A:Type}(n:nat)(x:A) : list A :=
  match n with
  | 0 => nil
  | S n' => x :: repeat n' x
  end.

Lemma firstn_repeat_le :
  forall A (x:A) m n,
  m <= n ->
  firstn m (repeat n x) = repeat m x.

Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.

Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).

Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.

Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.

Lemma nth_repeat :
  forall A n (x:A) d i, i < n ->
  nth i (repeat n x) d = x.

Definition move_forward {A}(i j:nat)(l:list A)(d:A) : list A :=
  firstn i l ++ firstn j (skipn (S i) l) ++ (nth i l d :: skipn (S (i+j)) l).

Lemma move_forward_map A B d1 d2 i j (f:A->B) l :
  f d1 = d2 ->
  move_forward i j (map f l) d2 = map f (move_forward i j l d1).

Lemma length_move_forward :
  forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.

Lemma in_move_forward_iff :
  forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).

Lemma firstn_simpl : forall A B (l : list A) (l2 : list B),
 length l2 = length l ->
 firstn (length l2) l = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .

Lemma firstn_firstn : forall A n (l : list A),
 firstn n (firstn n l) = firstn n l.

Lemma In_firstn : forall A n a (l : list A),
  In a (firstn n l) -> In a l. *)
(* BellantoniCook.Bitstring:
Require Import Bool Arith Div2 List.
Require Import BellantoniCook.Lib.

Notation bs := (list bool).

Definition unary (v : bs) := forallb id v.

Definition bs2bool (v:bs) : bool := hd false v.

Definition bool2bs (b:bool) : bs :=
  if b then true::nil else nil.

Lemma bs_nat2bool_true : forall v,
  bs2bool v = true -> length v <> 0.

Lemma bs_nat2bool_true_conv : forall v,
  unary v = true ->
  length v <> 0 -> bs2bool v = true.

Lemma bs_nat2bool_false v :
  unary v = true ->
  bs2bool v = false -> length v = 0.

Lemma bs_nat2bool_false_conv v :
  length v = 0 ->
  bs2bool v = false.

Fixpoint bs2nat (v:bs) : nat :=
  match v with
  | nil => 0
  | false :: v' => 2 * bs2nat v'
  | true  :: v' => S (2 * bs2nat v')
  end.

Fixpoint succ_bs (v : bs) : bs :=
  match v with
    | nil => [true]
    | false :: v' => true :: v'
    | true :: v' => false :: succ_bs v'
  end.

Lemma succ_bs_correct v : bs2nat (succ_bs v) = bs2nat v + 1.

Fixpoint nat2bs (n:nat) : bs :=
  match n with
  | 0 => nil
  | S n' => succ_bs (nat2bs n')
  end.

Lemma bs2nat_nil :
  bs2nat nil = 0.

Lemma bs2nat_false v :
  bs2nat (false :: v) = 2 * bs2nat v.

Lemma bs2nat_true v :
  bs2nat (true :: v) = 1 + 2 * bs2nat v.

Lemma bs2nat_tl : forall v, bs2nat (tl v) = div2 (bs2nat v).

Lemma bs2nat_nat2bs : forall n, bs2nat (nat2bs n) = n. *)
(* BellantoniCook.MultiPoly:
Require Import Arith List.
Require Import BellantoniCook.Lib.

Definition pow : Type := (nat*nat)%type.
Definition mon : Type := (nat * list pow)%type.
Definition pol : Type := (nat * list mon)%type.

Definition peval_pow (xn:pow)(l:list nat) : nat :=
  power (nth (fst xn) l 0) (snd xn).

Definition peval_mon (m:mon)(l:list nat) : nat :=
  (fst m) * multl (map (fun x => peval_pow x l) (snd m)).

Definition peval (p:pol)(l:list nat) :=
  plusl (map (fun m => peval_mon m l) (snd p)).

Lemma peval_parity : forall ar p l,
  peval (ar, snd p) l = peval p l.

Lemma peval_pow_monotonic : forall xn l1 l2, 
  (forall i, nth i l1 0 <= nth i l2 0) ->
  peval_pow xn l1 <= peval_pow xn l2.

Lemma peval_mon_monotonic : forall m l1 l2, 
  (forall i, nth i l1 0 <= nth i l2 0) ->
  peval_mon m l1 <= peval_mon m l2.

Lemma peval_monotonic : forall p l1 l2, 
  (forall i, nth i l1 0 <= nth i l2 0) ->
  peval p l1 <= peval p l2.

Lemma peval_nth i pl p l :
  peval (nth i pl p) l =
  nth i (map (fun p => peval p l) pl) (peval p l).

Notation parity := (@fst nat (list mon)).

Definition pWF_pow (ar:nat)(xn:pow) : Prop :=
  fst xn < ar.

Definition pWF_mon (ar:nat)(m:mon) : Prop :=
  andl (pWF_pow ar) (snd m).

Definition pWF' (ar:nat)(ml:list mon) : Prop :=
  andl (pWF_mon ar) ml.

Definition pWF (p:pol) : Prop :=
  pWF' (fst p) (snd p).

Lemma pWF_mon_le : forall ar1 ar2 m,
  ar1 <= ar2 -> 
  pWF_mon ar1 m -> pWF_mon ar2 m.

Lemma pWF'_le ar1 ar2 ml :
  ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.

Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2,
  pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) ->
  pWF_mon ar (a1*a2, xl1++xl2).

Lemma pWF'_app ar ml1 ml2 :
  pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).

Lemma pWF_nth i pl p0 :
  andl pWF pl -> pWF p0 -> pWF (nth i pl p0).

Lemma parity_mon_correct : forall ar m l l1 l2,
  pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).

Lemma parity_correct : forall p l l1 l2,
  pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).

Definition pcst (ar a:nat) : pol :=
  (ar, [(a,nil)]).

Lemma parity_pcst ar a :
  parity (pcst ar a) = ar.

Lemma pWF_pcst ar a : pWF (pcst ar a).

Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.

Definition pproj (ar i:nat) : pol :=
  (ar,[(1,[(i,1)])]).

Lemma parity_pproj n i :
  parity (pproj n i) = n.

Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).

Lemma pproj_correct : forall ar i l,
 peval (pproj ar i) l = nth i l 0.

Definition pscalar_mon (n:nat)(m:mon) : mon :=
  (n * fst m, snd m).

Definition pscalar (n:nat)(p:pol) : pol :=
  (fst p, map (pscalar_mon n) (snd p)).

Lemma parity_pscalar n p :
  parity (pscalar n p) = parity p.

Lemma pWF_pscalar : forall n p,
  pWF p -> pWF (pscalar n p).

Lemma pscalar_mon_correct : forall n m l,
  peval_mon (pscalar_mon n m) l = n * peval_mon m l.

Lemma map_pscalar_mon n ml l :
  plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) =
  n * plusl (map (fun m => peval_mon m l) ml).

Lemma pscalar_correct : forall n p l,
  peval (pscalar n p) l = n * peval p l.

Definition pplus (p1 p2:pol) : pol :=
  (max (fst p1) (fst p2), snd p1 ++ snd p2).

Lemma parity_pplus : forall p1 p2,
  parity (pplus p1 p2) = max (parity p1) (parity p2).

Lemma pWF_pplus : forall p1 p2,
  pWF p1 -> pWF p2 -> pWF (pplus p1 p2).

Lemma pplus_correct : forall p1 p2 l,
 peval (pplus p1 p2) l = peval p1 l + peval p2 l.

Definition pplusl (pl:list pol) : pol :=
  fold_right pplus (pcst 0 0) pl.

Lemma parity_pplusl : forall pl,
  parity (pplusl pl) = maxl (map parity pl).

Definition pWF_pplusl : forall pl,
  andl pWF pl -> pWF (pplusl pl).

Lemma pplusl_correct : forall pl l,
  peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).

Lemma peval_nth_pplus : forall pl l i n,
  peval (nth i pl (pcst n 0)) l <=
  peval (pplusl pl) l.

Definition pmult_mon (m12:mon*mon) : mon :=
  (fst (fst m12) * fst (snd m12), snd (fst m12) ++  snd (snd m12)).

Definition pmult (p1 p2:pol) : pol :=
  (max (fst p1) (fst p2), map pmult_mon (list_prod (snd p1) (snd p2))).

Lemma parity_pmult : forall p1 p2,
  parity (pmult p1 p2) = max (parity p1) (parity p2).

Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2,
  pWF_mon ar1 m1 -> pWF_mon ar2 m2 ->
  pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).

Lemma pWF_pmult : forall p1 p2,
  pWF p1 -> pWF p2 -> pWF (pmult p1 p2).

Lemma pmult_mon_correct : forall m12 l,
  peval_mon (pmult_mon m12) l =
  peval_mon (fst m12) l * peval_mon (snd m12) l.

Lemma map_pmult_mon : forall m1 ml2 l,
 map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 =
 map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.

Lemma pmult_correct : forall p1 p2 l,
 peval (pmult p1 p2) l = peval p1 l * peval p2 l.

Definition pmultl (pl:list pol) : pol :=
  fold_right pmult (pcst 0 1) pl.

Lemma parity_pmultl pl :
  parity (pmultl pl) = maxl (map parity pl).

Definition pWF_pmultl pl :
  andl pWF pl -> pWF (pmultl pl).

Lemma pmultl_correct pl l :
  peval (pmultl pl) l = multl (map (fun p => peval p l) pl).

Fixpoint ppower (p:pol)(n:nat) : pol :=
  match n with
  | 0 => pcst (fst p) 1
  | S n' => pmult p (ppower p n')
  end.

Lemma parity_ppower p n :
  parity (ppower p n) = parity p.

Lemma pWF_ppower p n :
  pWF p -> pWF (ppower p n).

Lemma ppower_correct p n l :
  peval (ppower p n) l = power (peval p l) n.

Definition pcomp_pow' (xn:pow)(pl:list pol) : pol :=
  ppower (nth (fst xn) pl (pcst 0 0)) (snd xn).

Definition pcomp_pow (xn:pow)(pl:list pol) : pol :=
  (maxl (map parity pl), snd (pcomp_pow' xn pl)).

Definition pcomp_mon' (m:mon)(pl:list pol) : pol :=
  pscalar (fst m) (pmultl (map (fun xn => pcomp_pow xn pl) (snd m))).

Definition pcomp_mon (m:mon)(pl:list pol) : pol :=
  (maxl (map parity pl), snd (pcomp_mon' m pl)).

Definition pcomp' (p:pol)(pl:list pol) : pol :=
  pplusl (map (fun m => pcomp_mon m pl) (snd p)).

Definition pcomp (p:pol)(pl:list pol) : pol :=
  (maxl (map parity pl), snd (pcomp' p pl)).

Lemma parity_pcomp_pow : forall xn pl,
  parity (pcomp_pow xn pl) = maxl (map parity pl).

Lemma map_parity_pcomp_pow xl pl :
  map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.

Lemma parity_pcomp_mon' : forall m pl,
  parity (pcomp_mon' m pl) <= maxl (map parity pl).

Lemma parity_pcomp_mon : forall m pl,
  parity (pcomp_mon m pl) = maxl (map parity pl).

Lemma parity_pcomp p pl :
  parity (pcomp p pl) = maxl (map parity pl).

Lemma pWF_pcomp_pow' : forall xn pl,
  andl pWF pl -> pWF (pcomp_pow' xn pl).

Lemma pWF_pcomp_pow : forall xn pl,
  andl pWF pl -> pWF (pcomp_pow xn pl).

Lemma pWF_pcomp_mon' : forall m pl,
  andl pWF pl -> pWF (pcomp_mon' m pl).

Lemma pWF_pcomp_mon : forall m pl,
  andl pWF pl -> pWF (pcomp_mon m pl).

Lemma pWF_pcomp' : forall p pl,
  andl pWF pl -> pWF (pcomp' p pl).

Lemma pWF_pcomp : forall p pl,
  andl pWF pl -> pWF (pcomp p pl).

Lemma pcomp_pow'_correct : forall xn pl l,
  peval (pcomp_pow' xn pl) l =
  power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).

Lemma pcomp_pow_correct xn pl l :
  peval (pcomp_pow xn pl) l =
  power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).

Lemma pcomp_mon'_correct : forall m pl l,
  peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).

Lemma pcomp_mon_correct : forall m pl l,
  peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).

Lemma pcomp'_correct : forall p pl l,
  peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).

Lemma pcomp_correct p pl l :
  peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).

Definition pshift_pow (xn:pow) : pow :=
  (S (fst xn), snd xn).

Definition pshift_mon (m:mon) : mon :=
  (fst m, map pshift_pow (snd m)).

Definition pshift (p:pol) : pol :=
  (S (fst p), map pshift_mon (snd p)).

Lemma parity_pshift : forall p,
  parity (pshift p) = S (parity p).

Lemma pWF_pshift_mon : forall ar m,
  pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).

Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).

Lemma pshift_pow_correct : forall xn l,
  peval_pow (pshift_pow xn) l = peval_pow xn (tl l).

Lemma pshift_mon_correct : forall m l,
  peval_mon (pshift_mon m) l = peval_mon m (tl l).

Lemma pshift_correct : forall p l,
  peval (pshift p) l = peval p (tl l).

Definition psum (start len : nat) : pol :=
  pplus (pcst (start+len) 0) (pplusl (map (pproj (start+len)) (seq start len))).

Lemma psum_correct start len l :
  peval (psum start len) l = 
  plusl (map (fun i => nth i l 0) (seq start len)).

Lemma pWF_psum start len : pWF (psum start len).

Lemma parity_psum start len : 
  parity (psum start len) = start + len.

Ltac pWF :=
  match goal with
  | |- pWF (pcst _ _) => apply pWF_pcst
  | |- pWF (pproj _ _) => apply pWF_pproj; try omega
  | |- pWF (pscalar _ _) => apply pWF_pscalar; pWF
  | |- pWF (pplus _ _) => apply pWF_pplus; pWF
  | |- pWF (pplusl _) => apply pWF_pplusl; rewrite <- forall_andl; intros; pWF
  | |- pWF (pmult _ _) => apply pWF_pmult; pWF
  | |- pWF (pmultl _) => apply pWF_pmultl; rewrite <- forall_andl; intros; pWF
  | |- pWF (ppower _ _) => apply pWF_ppower; pWF
  | |- pWF (pcomp _ _) => apply pWF_pcomp; rewrite <- forall_andl; intros; pWF
  | |- pWF (pshift _) => apply pWF_pshift; pWF
  | |- pWF (psum _ _) => apply pWF_psum
  | |- _ => idtac
  end.

Definition deg_mon (m:mon) : nat :=
  plusl (map (@snd _ _) (snd m)).

Definition deg (p:pol) : nat :=
  maxl (map deg_mon (snd p)). *)



Inductive Cobham : Type :=

| Zero : Cobham

| Proj : nat -> nat -> Cobham

| Succ : bool -> Cobham

| Smash : Cobham

| Rec  : Cobham -> Cobham -> Cobham -> Cobham -> Cobham

| Comp : nat -> Cobham -> list Cobham -> Cobham.



Definition Rec2 g h j := Rec g h h j.



Lemma Cobham_ind2' :

  forall P : Cobham -> Prop,

  forall Q : list Cobham -> Prop,

  Q nil ->

  (forall e l, P e -> Q l -> Q (e :: l)) ->

  P Zero ->

  (forall n i, P (Proj n i)) ->

  (forall b, P (Succ b)) ->

  P Smash ->

  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->

  (forall n h l, P h -> Q l -> P (Comp n h l)) ->

  forall e, P e.

Proof.

 fix Cobham_ind2' 11; intros.

 destruct e; auto.

 apply H5; eapply Cobham_ind2'; eauto.

 apply H6.

 eapply Cobham_ind2'; eauto.

 revert l.

 fix Cobham_ind2'0 1.

 intro.

 destruct l.

 apply H.

 apply H0.

 eapply Cobham_ind2'; eauto.

 apply Cobham_ind2'0.

Qed.



Lemma Cobham_ind2 :

  forall P : Cobham -> Prop,

  P Zero ->

  (forall n i, P (Proj n i)) ->

  (forall b, P (Succ b)) ->

  P Smash ->

  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->

  (forall n h l, P h -> (forall e, In e l -> P e) ->

    P (Comp n h l)) ->

  forall e, P e.

Proof.

 intros.

 induction e using Cobham_ind2' 

   with (Q := fun l => forall e, In e l -> P e); auto.

 simpl;intros; tauto.

 simpl.

 intros e' [ | ]; intros; subst; auto.

Qed.



Inductive Arity : Set :=

| error_Rec : Arity -> Arity -> Arity -> Arity -> Arity

| error_Comp : Arity -> list Arity -> Arity

| error_Proj : nat -> nat -> Arity

| ok_arity : nat -> Arity.



Definition arity_eq (a1 a2 : Arity) :=

  match a1, a2 with

    | ok_arity n1, ok_arity n2 => beq_nat n1 n2

    | _, _ => false

  end.



Lemma arity_eq_true x1 x2 :

  arity_eq x1 x2 = true -> x1 = x2.

Proof.

 intros; unfold arity_eq in H.

 destruct x1; try discriminate.

 destruct x2; try discriminate.

 apply beq_nat_true in H; subst; trivial.

Qed.



Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.

Proof.

  intros; case (ok_arity n); simpl; intros.

  rewrite beq_nat_true_iff; trivial.

Qed.



Fixpoint arity (e : Cobham) : Arity :=

  match e with

    | Zero => ok_arity 0

    | Proj n j => if leb (S j) n 

      then ok_arity n else error_Proj n j 

    | Succ _ => ok_arity 1

    | Smash => ok_arity 2

    | Rec g h0 h1 j => 

      match arity g, arity h0, arity h1, arity j with

        | ok_arity gn, ok_arity h0n, ok_arity h1n, ok_arity jn =>

          if beq_nat (S (S gn)) h0n && 

             beq_nat h1n h0n &&

             beq_nat (S jn) h1n 

            then ok_arity jn 

            else error_Rec (ok_arity gn) (ok_arity h0n) 

              (ok_arity h1n) (ok_arity jn)

        | ag, ah0, ah1, aj => error_Rec ag ah0 ah1 aj 

      end

    | Comp n h l => 

      match arity h, map arity l with

        | ok_arity nh, al => 

          if beq_nat nh (length l) &&

            forallb (fun e => arity_eq e (ok_arity n)) al then

              ok_arity n else error_Comp (ok_arity nh) al

        | e , le => error_Comp e le 

      end

  end.



Lemma Cobham_ind_inf' :

  forall (P : nat -> Cobham -> Prop),

  forall Q : nat -> list Cobham -> Prop,

  (forall n, Q n nil) ->

  (forall e n l, P n e -> Q n l -> Q n (e :: l)) ->

  P 0 Zero ->

  (forall n i, i < n  ->  P n (Proj n i)) ->

  (forall b, P 1 (Succ b)) ->

  (P 2 Smash) ->

  (forall n g h0 h1 j, 

    arity g = ok_arity n ->

    arity h0 = ok_arity (S (S n)) ->

    arity h1 = ok_arity (S (S n)) ->

    arity j = ok_arity (S n) ->

    P n g -> 

    P (S (S n)) h0 -> 

    P (S (S n)) h1 -> 

    P (S n) j -> 

    P (S n) (Rec g h0 h1 j)) ->

  (forall n h rl, 

    arity h = ok_arity (length rl)  ->

    (forall e, In e rl -> arity e = ok_arity n) ->

    P (length rl)  h -> 

    Q n rl ->

    P n (Comp n h rl)) ->

  forall e n , arity e = ok_arity n -> P n e.

Proof.

 fix Cobham_ind_inf' 11; intros.

 destruct e; simpl in *.



 injection H7; intros; subst; auto.



 destruct n0; try discriminate.

 case_eq (leb n1 n0); intros; rewrite H8 in H7; try discriminate.

 injection H7; intros; subst; auto.

 apply H2.

 apply leb_complete in H8; omega.



 injection H7; intros; subst; auto.

 injection H7; intros; subst; auto.



 case_eq (arity e1); intros; rewrite H8 in H7; try discriminate.

 case_eq (arity e2); intros; rewrite H9 in H7; try discriminate.

 case_eq (arity e3); intros; rewrite H10 in H7; try discriminate.

 case_eq (arity e4); intros; rewrite H11 in H7; try discriminate.

 destruct n1; simpl; intros; try discriminate; auto.

 destruct n1; simpl; intros; try discriminate; auto.

 case_eq (beq_nat n0 n1); intros; rewrite H12 in H7; try discriminate.

 apply beq_nat_true in H12; subst.

 case_eq (beq_nat n2 (S (S n1))); intros; rewrite H12 in H7; try discriminate.

 apply beq_nat_true in H12; subst.

 case_eq (beq_nat n3 (S n1)); intros; rewrite H12 in H7; try discriminate.

 apply beq_nat_true in H12; subst.

 simpl in H7.

 injection H7; intros; subst.

 apply H5; auto.

 eapply Cobham_ind_inf'; eauto.

 eapply Cobham_ind_inf'; eauto.

 eapply Cobham_ind_inf'; eauto.

 eapply Cobham_ind_inf'; eauto.



 case_eq (arity e); intros; rewrite H8 in H7; try discriminate.

 case_eq (beq_nat n1 (length l)); intros; rewrite H9 in H7; try discriminate.

 case_eq (forallb (fun e : Arity => arity_eq e (ok_arity n0)) (map arity l)); 

 intros; rewrite H10 in H7;try discriminate.

 simpl in H7.

 injection H7; intros; subst.

 rewrite forallb_forall in H10.

 apply beq_nat_true in H9; subst.

 apply H6; trivial.

 intros.

 apply arity_eq_true. 

 apply H10.

 apply in_map_iff.

 exists e0; split; trivial.

 eapply Cobham_ind_inf'; eauto.

 clear H8.

 revert l H10.

 fix Cobham_ind_inf'0 1.

 intros.

 destruct l.

 auto.

 eapply H0.

 eapply Cobham_ind_inf'; eauto.

 apply arity_eq_true.

 apply H10.

 simpl; auto.

 apply Cobham_ind_inf'0.

 intros.

 apply H10.

 simpl; auto.

Qed.



Lemma Cobham_ind_inf :

  forall (P : nat -> Cobham -> Prop),

  P 0 Zero ->

  (forall n i, i < n  ->  P n (Proj n i)) ->

  (forall b, P 1 (Succ b)) ->

  (P 2 Smash) ->

  (forall n g h0 h1 j, 

    arity g = ok_arity n ->

    arity h0 = ok_arity (S (S n)) ->

    arity h1 = ok_arity (S (S n)) ->

    arity j = ok_arity (S n) ->

    P n g -> 

    P (S (S n)) h0 -> 

    P (S (S n)) h1 -> 

    P (S n) j ->

    P (S n) (Rec g h0 h1 j)) ->

  (forall n h rl, 

    arity h = ok_arity (length rl)  ->

    (forall e, In e rl -> arity e = ok_arity n) ->

    P (length rl) h -> 

    (forall r, In r rl -> P n r) ->

    P n (Comp n h rl)) ->

  forall e n , arity e = ok_arity n -> P n e.

Proof.

  intros.

  apply Cobham_ind_inf'

    with (Q := fun n l => forall e , In e l -> P n e); auto; simpl in *; intros.

  tauto.

  destruct H8; subst; auto.

Qed.



Fixpoint sem_Rec (sem_g sem_h0 sem_h1 : list bs -> bs) (v : bs) (vl : list bs) : bs :=

  match v with

    | nil => sem_g vl

    | b::v' => if b then 

      sem_h1 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)

      else sem_h0 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)

  end.



Fixpoint smash' (x y : bs) :=

  match x with 

    | nil => y

    | _ :: x' => false :: smash' x' y

  end.



Lemma length_smash' x y :

  length (smash' x y) = length x + length y.

Proof.

  induction x; simpl; trivial.

  intros; rewrite IHx; trivial.

Qed.



Fixpoint smash_bs (x y : bs) : bs :=

  match x with

    | nil => true :: nil

    | _ :: x' => smash' y (smash_bs x' y)

  end.



Lemma length_smash x y :

  length (smash_bs x y) = 1 + length x * length y.

Proof.

  induction x; simpl; trivial; intros.

  rewrite length_smash', IHx; omega.

Qed.



Fixpoint Sem (e: Cobham) (vl:list bs) : bs :=

  match e with

  | Zero => nil

  | Proj n j => nth j vl nil

  | Succ b => b :: hd nil vl

  | Smash => smash_bs (hd nil vl) (hd nil (tl vl))

  | Rec g h0 h1 j =>  

    sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil vl) (tail vl)

  | Comp _ h l => Sem h (List.map (fun e => Sem e vl) l)

  end.



Lemma simpl_Rec : forall g h0 h1 j l,

  Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).

Proof.

 intros; simpl; trivial.

Qed.



Lemma Sem_add_zero : forall e n,

  arity e = ok_arity n ->

  forall l,

  length l <= n ->

  Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).

Proof.

 refine (Cobham_ind_inf (fun n e =>  forall l : list bs,

   length l <= n ->

   Sem e l = Sem e (l ++ map (fun _ : nat => nil) (seq 0 (n - length l)))) _ _ _ _ _ _); simpl; auto; intros.



 destruct (le_lt_dec (length l) i).

 rewrite nth_overflow; trivial.

 rewrite app_nth2; trivial.

 rewrite nth_map_cst; trivial. 

 rewrite app_nth1; trivial.

 f_equal; destruct l; simpl; trivial.

 f_equal; destruct l; simpl; trivial.

 destruct l0; simpl; trivial.

 destruct l; simpl in *; try discriminate.

 rewrite <- app_nil_l with (l := (map (fun _ : nat => nil) (seq 1 n))).

 rewrite <- seq_shift, map_map.

 replace n with (n - length (@nil bs)).

 apply H3; trivial.

 simpl; omega.

 simpl; omega.

 induction l; simpl.

 apply H3; trivial; omega.

 rewrite <- IHl.

 replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0

   :: l0 ++ map (fun _ : nat => nil) (seq 0 (n - length l0))) with

 ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ 

   (map (fun _ : nat => nil) (seq 0 (n - length l0)))); trivial.

 case a.

 erewrite H5; eauto; simpl; trivial; omega.

 erewrite H4; eauto; simpl; trivial; omega. 

 f_equal.

 apply map_ext2; intros.

 eapply H2; trivial.

Qed.



Lemma Sem_remove_zero : forall e n,

  arity e = ok_arity n ->

  forall l l',  n = length l ->

    Sem e l = Sem e (l ++ l').

Proof.

 refine (Cobham_ind_inf (fun n e => 

   forall l l',  n = length l -> Sem e l = Sem e (l ++ l')) _ _ _ _ _ _); simpl; auto; intros.

 rewrite app_nth1; trivial; omega.

 destruct l; simpl in *; try discriminate; trivial.

 destruct l; simpl in *; try discriminate; trivial.

 destruct l0; simpl in *; try discriminate; trivial.

 destruct l; simpl in *; try discriminate.

 induction l; simpl.

 eapply H3; eauto; omega.

 rewrite <- IHl.

 replace (l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0 ++ l') with

   ((l :: sem_Rec (Sem g) (Sem h0) (Sem h1) l l0 :: l0) ++ l'); trivial.

 case a.

 eapply H5; eauto; simpl; omega.

 eapply H4; eauto; simpl; omega.

 f_equal.

 apply map_ext2; intros.

 eapply H2; trivial.

Qed.



Fixpoint rec_bounded' (e : Cobham) : Prop :=

  match e with

    | Rec g h0 h1 j =>

      rec_bounded' j  /\ 

      rec_bounded' g /\ 

      rec_bounded' h0 /\ 

      rec_bounded' h1 /\

      (match (arity e) with

         | ok_arity n => forall l, length l = n ->

           length (Sem e l) <= length (Sem j l)

        | _ => True 

       end)

    | Comp n h l => rec_bounded' h /\

        andl rec_bounded' l

    | _ => True

  end.



Fixpoint rec_bounded (e : Cobham) : Prop :=

  match e with

    | Rec g h0 h1 j =>

      rec_bounded j  /\ 

      rec_bounded g /\ 

      rec_bounded h0 /\ 

      rec_bounded h1 /\

      (forall l, 

        length (Sem e l) <= length (Sem j l))

    | Comp n h l => rec_bounded h /\

        andl rec_bounded l

    | _ => True

  end.



Lemma rec_bounded_spec (e : Cobham) :

  rec_bounded e -> rec_bounded' e.

Proof.

 induction e using Cobham_ind2; simpl; auto; intros.

 decompose [and] H; clear H.

 repeat (split; try tauto).

 case_eq (arity e1); intros; try discriminate; auto.

 case_eq (arity e2); intros; try discriminate; auto.

 case_eq (arity e3); intros; try discriminate; auto.

 case_eq (arity e4); intros; try discriminate; auto.

 destruct n0; simpl; intros; try discriminate; auto.

 destruct n0; simpl; intros; try discriminate; auto.

 case_eq (beq_nat n n0); simpl; intros; try discriminate; auto.

 case_eq (beq_nat n1 (S (S n0))); simpl; intros; 

   try discriminate; auto.

 destruct n1; simpl; intros; try discriminate; auto.

 case_eq (beq_nat n2 n1); simpl; intros; try discriminate; auto.

 split; try tauto.

 revert e IHe H0.

 induction l; simpl; intros; trivial.

 split.

 apply H.

simpl; tauto.

tauto.

eapply IHl.

intros.

apply H.

simpl.

tauto.

trivial.

auto.

tauto.

Qed.



Lemma rec_bounded'_spec : forall (e : Cobham) n,

  arity e = ok_arity n ->

  rec_bounded' e -> 

  rec_bounded e.

Proof.

 refine (Cobham_ind_inf (fun n e => 

   rec_bounded' e -> rec_bounded e) _ _ _ _ _ _); simpl; auto; intros.

 decompose [and] H7; clear H7.

 rewrite H, H0, H1,H2 in H13.

 simpl in H13. 

 rewrite <- beq_nat_refl in H13.

 simpl in H13.

 repeat (split; try tauto).

 intros.

 rewrite <- simpl_Rec with (j := j).

 destruct (le_lt_dec (length l) (S n)).

 rewrite Sem_add_zero with (n := S n); trivial.

 rewrite Sem_add_zero with (e := j) (n := S n); trivial.

 apply H13; trivial.

 rewrite app_length, map_length, seq_length.

 omega.

 simpl.

 rewrite H, H0, H1, H2.

 repeat rewrite <- beq_nat_refl; simpl; trivial.



 rewrite <- firstn_skipn with (n := S n) (l := l).

 rewrite <- Sem_remove_zero with (n := S n); trivial.

 rewrite <- Sem_remove_zero with (n := S n); trivial.

 apply H13; trivial; trivial.

 rewrite firstn_length.

 rewrite min_l; trivial; omega.

 rewrite firstn_length.

 rewrite min_l; trivial; omega.

 simpl.

 rewrite H, H0, H1, H2.

 repeat rewrite <- beq_nat_refl; simpl.

 trivial.

 rewrite firstn_length.

 rewrite min_l; trivial; omega.



 split.

 tauto.

 apply forall_andl; intros.

 destruct H3.

 rewrite <- forall_andl in H5; auto.

Qed.



Fixpoint poly_Cobham (e : Cobham) :=

  match e with

    | Zero => pcst 0 0

    | Proj n i => pproj n i

    | Succ b => pplus (pcst 0 1) (pproj 1 0)

    | Smash => pplus (pcst 0 1) (pmult (pproj 2 0) (pproj 2 1))

    | Rec g h0 h1 j => poly_Cobham j

    | Comp n h l => 

      pplus (pcst n 0) 

      (pcomp (poly_Cobham h) (map poly_Cobham l))

  end.



Lemma parity_poly_Cobham : forall (e : Cobham) n,

  arity e = ok_arity n ->

  parity (poly_Cobham e) = n.

Proof.

  apply Cobham_ind_inf; simpl; auto; intros.

  apply max_l.

  apply maxl_map.

  intros.

  apply in_map_iff in H3.

  destruct H3 as (? & ? & ?); subst.

  apply H2; trivial.

Qed.



Lemma pWF_poly_Cobham : forall (e : Cobham) n,

  arity e = ok_arity n ->

  pWF (poly_Cobham e).

Proof.

  apply Cobham_ind_inf; simpl; auto; intros; try pWF.

  apply in_map_iff in H3.

  destruct H3 as (? & ? & ?); subst.

  apply H2; trivial.

Qed.



Lemma poly_Cobham_correct : forall (e : Cobham) xl,

  rec_bounded e ->  

  length (Sem e xl) <= 

  peval (poly_Cobham e) (map (@length _) xl).

Proof.

 induction e using Cobham_ind2; intros; simpl in *; trivial.



 rewrite <- (@map_nth _ _ (@length _) xl); simpl; trivial.

 rewrite pproj_correct; trivial.



 rewrite pplus_correct, pproj_correct.

 rewrite <- hd_nth_0, (map_hd _ _ (@length _)); simpl; omega.



 rewrite length_smash, pplus_correct, pmult_correct, pcst_correct, 

   pproj_correct, pproj_correct, <- hd_nth_0, hd_nth_1, (map_hd _ _ (@length _)); simpl.

 rewrite <- (@map_nth _ _ (@length _) xl); simpl.

 trivial.

 

 decompose [and] H; clear H.

 apply le_trans with (1 := H5 xl).

 apply IHe4; trivial.

 rewrite pplus_correct.

 rewrite pcst_correct.

 rewrite pcomp_correct.

 eapply le_trans.

 apply IHe.

 tauto.

 repeat rewrite map_map.

 apply peval_monotonic.

 intros.

 rewrite map_nth2 with (d := Zero);[ | simpl; trivial].

 rewrite map_nth2 with (d := Zero);[ | simpl; trivial].

 clear IHe.

 assert (rec_bounded (nth i l Zero)).

 clear H.

 revert i.

 induction l; simpl in *; intros; case i; simpl; trivial.

 tauto.

 intros.

 apply IHl.

 tauto.

 destruct (lt_dec i (length l)).

 apply H.

 apply nth_In; trivial.

 trivial.

 rewrite nth_overflow; simpl.

 trivial.

 omega.

Qed.

