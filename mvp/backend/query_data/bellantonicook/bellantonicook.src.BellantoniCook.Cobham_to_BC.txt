Require Import Bool Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly BellantoniCook.Cobham BellantoniCook.CobhamLib BellantoniCook.CobhamUnary BellantoniCook.BC BellantoniCook.BCLib BellantoniCook.BCUnary.
(* BellantoniCook.Lib:
Require Import Bool Arith Div2 List Permutation.
Require Export Omega.

Global Obligation Tactic := idtac.

Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) .. ).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.

Lemma length_tail A l : length (@tail A l) = length l - 1.

Lemma hd_nth_0 A (l : list A) d :
  hd d l = nth 0 l d.

Lemma hd_nth_1 A (l : list A) d :
  hd d (tl l) = nth 1 l d.

Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) :
  In (hd d l) l.

Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).

Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).

Lemma map_eq_hd :
  forall A B (f:A->B) d l1 l2,
  map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).

Lemma firstn_nil {A} n : firstn n (@nil A) = nil.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma nth_firstn : forall A i j (l:list A) d,
  i < j -> nth i (firstn j l) d = nth i l d.

Lemma nth_skipn A i j (l:list A) d : 
  nth i (skipn j l) d = nth (j+i) l d.

Lemma length_skipn : forall A n (y : list A),
  length (skipn n y) = length y - n.

Lemma skipn_length : forall {A} n (l:list A), 
  length (skipn n l) = length l - n.

Lemma cons_skipn :
  forall A d i (l:list A),
  i < length l ->
  nth i l d :: skipn (S i) l = skipn i l.

Lemma skipn_plus :
  forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).

Lemma skipn_hd : forall {A} n y (d:A), 
  n < length y -> 
  skipn n y = nth n y d :: skipn (S n) y.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma skipn_app {A} (l l' : list A) : 
  skipn (length l) (l ++ l') = l'.

Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.

Lemma map_firstn : forall A B (f:A->B) n l,
  map f (firstn n l) = firstn n (map f l).

Lemma map_skipn : forall A B (f:A->B) n l,
  map f (skipn n l) = skipn n (map f l).

Lemma map_nth_seq : forall A (l:list A) len n d,
  length l = len + n ->
  map (fun x : nat => nth x l d) (seq n len) = (skipn n l).

Lemma skipn_nil_length : forall A n (l : list A),
  skipn n l = nil -> length l <= n.

Lemma firstn_map_nth :
  forall A d n m (l:list A),
  m+n <= length l ->
  firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma in_seq_iff : forall x len start,
  In x (seq start len) <-> start <= x < start+len.

Lemma nth_map_cst :
  forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.

Lemma nth_S_tl A (l : list A) d n :
  nth n (tl l) d = nth (S n) l d.

Lemma map_ext2 : forall {A B} (f g : A -> B) l,
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma map_nth2
  (A B : Type) (f : A -> B) (l : list A) b d n :
  (f d) = b ->
  nth n (map f l) b = f (nth n l d).

Lemma length_plus_ex {A} n1 n2 (l : list A):
  length l = n1 + n2 ->
  exists l1, exists l2,
    length l1 = n1 /\ length l2 = n2 /\ l = l1 ++ l2.

Lemma tl_app : forall A (l1 l2 : list A),
  l1 <> nil ->
  tl (l1 ++ l2) = tl l1 ++ l2.

Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, 
 map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.

Lemma map_seq_shift : forall A m (f : nat -> A) n,
n <> 0 ->
map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).

Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, 
 map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.

Lemma seq_app : forall x y z,
  seq x y ++ seq (x + y) z = seq x (y + z).

Definition andl {A} (P:A->Prop)(l:list A) : Prop :=
  fold_right (fun a res => P a /\ res) True l.

Lemma forall_andl A (P:A->Prop) l :
  (forall x, In x l -> P x) <-> andl P l.

Fixpoint fun_power {A:Type}(n:nat)(f:A->A)(x:A) : A :=
  match n with
  | 0 => x
  | S n' => f (fun_power n' f x)
  end.

Lemma fun_power_minus_S : forall A (f:A->A) x m n,
  m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.

Definition mod2 (n : nat) : nat :=
  n - 2 * div2 n.

Fixpoint power (m n:nat) : nat :=
 match n with
 | 0 => 1
 | S n' => m * power m n'
 end.

Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.

Definition plusl (l:list nat) : nat :=
  fold_right plus 0 l.

Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.

Lemma plusl_app l1 l2 :
  plusl (l1++l2) = plusl l1 + plusl l2.

Lemma plusl_compat : forall A (l : list A) f g,
  (forall x, In x l -> f x <= g x) ->
  plusl (map f l) <= plusl (map g l).

Definition multl (l:list nat) : nat :=
  fold_right mult 1 l.

Lemma multl_app l1 l2 :
  multl (l1++l2) = multl l1 * multl l2.

Lemma multl_plus_distr_l n l :
  n * plusl l = plusl (map (fun m => n * m) l).

Fixpoint maxl l := 
  match l with
    | nil => 0
    | a :: l' => max a (maxl l')
  end.

Lemma in_le_maxl x l : In x l -> x <= maxl l.

Lemma maxl_map A l (f : A -> nat) n :
  (forall x, In x l -> f x = n) ->
  maxl (map f l) <= n.

Lemma maxl_le l e :
  maxl l <= e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le l e :
  maxl l = e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] = e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] <= e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_bound e1 e2 e3 e :
  e1 <= e -> e2 <= e -> e3 <= e ->
  maxl [e1; e2; e3] <= e.

Lemma maxl_bound_in l e :
  (forall e', In e' l -> e' <= e) -> maxl l <= e.

Lemma maxl_cons l n : n <= maxl (n :: l).

Lemma le_maxl_cons l m n :
 n <= maxl l -> n <= maxl (m :: l).

Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i,
  m d = 0 -> m (nth i l d) <= maxl (map m l).

Lemma length_hd_app A (l1 l2 : list (list A)) :
  length (hd nil l1) <= length (hd nil (l1 ++ l2)).

Lemma length_nth_app A (l1 l2 : list (list A)) i :
  length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).

Lemma maxl_nth l :
  exists i, maxl l = nth i l 0.

Lemma maxl_map_0 A l (f : A -> nat)  :
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_le_plusl : forall l, maxl l <= plusl l.

Lemma forallb_forall_conv :
  forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\ f x = false).

Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d,
  p d = true ->
  forallb p l = true ->
  p (nth n l d) = true.

Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d,
  forallb p l = true ->
  p d = true ->
  p (hd d l) = true.

Lemma forallb_tl : forall A (l : list A) (p : A -> bool),
  forallb p l = true ->
  forallb p (tail l) = true.

Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B),
  (forall x, In x l -> p (f x) = true) ->
  forallb p (map f l) = true.

Fixpoint repeat {A:Type}(n:nat)(x:A) : list A :=
  match n with
  | 0 => nil
  | S n' => x :: repeat n' x
  end.

Lemma firstn_repeat_le :
  forall A (x:A) m n,
  m <= n ->
  firstn m (repeat n x) = repeat m x.

Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.

Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).

Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.

Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.

Lemma nth_repeat :
  forall A n (x:A) d i, i < n ->
  nth i (repeat n x) d = x.

Definition move_forward {A}(i j:nat)(l:list A)(d:A) : list A :=
  firstn i l ++ firstn j (skipn (S i) l) ++ (nth i l d :: skipn (S (i+j)) l).

Lemma move_forward_map A B d1 d2 i j (f:A->B) l :
  f d1 = d2 ->
  move_forward i j (map f l) d2 = map f (move_forward i j l d1).

Lemma length_move_forward :
  forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.

Lemma in_move_forward_iff :
  forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).

Lemma firstn_simpl : forall A B (l : list A) (l2 : list B),
 length l2 = length l ->
 firstn (length l2) l = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .

Lemma firstn_firstn : forall A n (l : list A),
 firstn n (firstn n l) = firstn n l.

Lemma In_firstn : forall A n a (l : list A),
  In a (firstn n l) -> In a l. *)
(* BellantoniCook.Bitstring:
Require Import Bool Arith Div2 List.
Require Import BellantoniCook.Lib.

Notation bs := (list bool).

Definition unary (v : bs) := forallb id v.

Definition bs2bool (v:bs) : bool := hd false v.

Definition bool2bs (b:bool) : bs :=
  if b then true::nil else nil.

Lemma bs_nat2bool_true : forall v,
  bs2bool v = true -> length v <> 0.

Lemma bs_nat2bool_true_conv : forall v,
  unary v = true ->
  length v <> 0 -> bs2bool v = true.

Lemma bs_nat2bool_false v :
  unary v = true ->
  bs2bool v = false -> length v = 0.

Lemma bs_nat2bool_false_conv v :
  length v = 0 ->
  bs2bool v = false.

Fixpoint bs2nat (v:bs) : nat :=
  match v with
  | nil => 0
  | false :: v' => 2 * bs2nat v'
  | true  :: v' => S (2 * bs2nat v')
  end.

Fixpoint succ_bs (v : bs) : bs :=
  match v with
    | nil => [true]
    | false :: v' => true :: v'
    | true :: v' => false :: succ_bs v'
  end.

Lemma succ_bs_correct v : bs2nat (succ_bs v) = bs2nat v + 1.

Fixpoint nat2bs (n:nat) : bs :=
  match n with
  | 0 => nil
  | S n' => succ_bs (nat2bs n')
  end.

Lemma bs2nat_nil :
  bs2nat nil = 0.

Lemma bs2nat_false v :
  bs2nat (false :: v) = 2 * bs2nat v.

Lemma bs2nat_true v :
  bs2nat (true :: v) = 1 + 2 * bs2nat v.

Lemma bs2nat_tl : forall v, bs2nat (tl v) = div2 (bs2nat v).

Lemma bs2nat_nat2bs : forall n, bs2nat (nat2bs n) = n. *)
(* BellantoniCook.MultiPoly:
Require Import Arith List.
Require Import BellantoniCook.Lib.

Definition pow : Type := (nat*nat)%type.
Definition mon : Type := (nat * list pow)%type.
Definition pol : Type := (nat * list mon)%type.

Definition peval_pow (xn:pow)(l:list nat) : nat :=
  power (nth (fst xn) l 0) (snd xn).

Definition peval_mon (m:mon)(l:list nat) : nat :=
  (fst m) * multl (map (fun x => peval_pow x l) (snd m)).

Definition peval (p:pol)(l:list nat) :=
  plusl (map (fun m => peval_mon m l) (snd p)).

Lemma peval_parity : forall ar p l,
  peval (ar, snd p) l = peval p l.

Lemma peval_pow_monotonic : forall xn l1 l2, 
  (forall i, nth i l1 0 <= nth i l2 0) ->
  peval_pow xn l1 <= peval_pow xn l2.

Lemma peval_mon_monotonic : forall m l1 l2, 
  (forall i, nth i l1 0 <= nth i l2 0) ->
  peval_mon m l1 <= peval_mon m l2.

Lemma peval_monotonic : forall p l1 l2, 
  (forall i, nth i l1 0 <= nth i l2 0) ->
  peval p l1 <= peval p l2.

Lemma peval_nth i pl p l :
  peval (nth i pl p) l =
  nth i (map (fun p => peval p l) pl) (peval p l).

Notation parity := (@fst nat (list mon)).

Definition pWF_pow (ar:nat)(xn:pow) : Prop :=
  fst xn < ar.

Definition pWF_mon (ar:nat)(m:mon) : Prop :=
  andl (pWF_pow ar) (snd m).

Definition pWF' (ar:nat)(ml:list mon) : Prop :=
  andl (pWF_mon ar) ml.

Definition pWF (p:pol) : Prop :=
  pWF' (fst p) (snd p).

Lemma pWF_mon_le : forall ar1 ar2 m,
  ar1 <= ar2 -> 
  pWF_mon ar1 m -> pWF_mon ar2 m.

Lemma pWF'_le ar1 ar2 ml :
  ar1 <= ar2 -> pWF' ar1 ml -> pWF' ar2 ml.

Lemma pWF_mon_app : forall ar a1 xl1 a2 xl2,
  pWF_mon ar (a1, xl1) -> pWF_mon ar (a2, xl2) ->
  pWF_mon ar (a1*a2, xl1++xl2).

Lemma pWF'_app ar ml1 ml2 :
  pWF' ar ml1 -> pWF' ar ml2 -> pWF' ar (ml1++ml2).

Lemma pWF_nth i pl p0 :
  andl pWF pl -> pWF p0 -> pWF (nth i pl p0).

Lemma parity_mon_correct : forall ar m l l1 l2,
  pWF_mon ar m -> length l = ar -> peval_mon m (l++l1) = peval_mon m (l++l2).

Lemma parity_correct : forall p l l1 l2,
  pWF p -> length l = parity p -> peval p (l++l1) = peval p (l++l2).

Definition pcst (ar a:nat) : pol :=
  (ar, [(a,nil)]).

Lemma parity_pcst ar a :
  parity (pcst ar a) = ar.

Lemma pWF_pcst ar a : pWF (pcst ar a).

Lemma pcst_correct : forall ar k l, peval (pcst ar k) l = k.

Definition pproj (ar i:nat) : pol :=
  (ar,[(1,[(i,1)])]).

Lemma parity_pproj n i :
  parity (pproj n i) = n.

Lemma pWF_pproj ar i : i < ar -> pWF (pproj ar i).

Lemma pproj_correct : forall ar i l,
 peval (pproj ar i) l = nth i l 0.

Definition pscalar_mon (n:nat)(m:mon) : mon :=
  (n * fst m, snd m).

Definition pscalar (n:nat)(p:pol) : pol :=
  (fst p, map (pscalar_mon n) (snd p)).

Lemma parity_pscalar n p :
  parity (pscalar n p) = parity p.

Lemma pWF_pscalar : forall n p,
  pWF p -> pWF (pscalar n p).

Lemma pscalar_mon_correct : forall n m l,
  peval_mon (pscalar_mon n m) l = n * peval_mon m l.

Lemma map_pscalar_mon n ml l :
  plusl (map (fun m => peval_mon (pscalar_mon n m) l) ml) =
  n * plusl (map (fun m => peval_mon m l) ml).

Lemma pscalar_correct : forall n p l,
  peval (pscalar n p) l = n * peval p l.

Definition pplus (p1 p2:pol) : pol :=
  (max (fst p1) (fst p2), snd p1 ++ snd p2).

Lemma parity_pplus : forall p1 p2,
  parity (pplus p1 p2) = max (parity p1) (parity p2).

Lemma pWF_pplus : forall p1 p2,
  pWF p1 -> pWF p2 -> pWF (pplus p1 p2).

Lemma pplus_correct : forall p1 p2 l,
 peval (pplus p1 p2) l = peval p1 l + peval p2 l.

Definition pplusl (pl:list pol) : pol :=
  fold_right pplus (pcst 0 0) pl.

Lemma parity_pplusl : forall pl,
  parity (pplusl pl) = maxl (map parity pl).

Definition pWF_pplusl : forall pl,
  andl pWF pl -> pWF (pplusl pl).

Lemma pplusl_correct : forall pl l,
  peval (pplusl pl) l = plusl (map (fun p => peval p l) pl).

Lemma peval_nth_pplus : forall pl l i n,
  peval (nth i pl (pcst n 0)) l <=
  peval (pplusl pl) l.

Definition pmult_mon (m12:mon*mon) : mon :=
  (fst (fst m12) * fst (snd m12), snd (fst m12) ++  snd (snd m12)).

Definition pmult (p1 p2:pol) : pol :=
  (max (fst p1) (fst p2), map pmult_mon (list_prod (snd p1) (snd p2))).

Lemma parity_pmult : forall p1 p2,
  parity (pmult p1 p2) = max (parity p1) (parity p2).

Lemma pWF_pmult_mon : forall ar1 m1 ar2 m2,
  pWF_mon ar1 m1 -> pWF_mon ar2 m2 ->
  pWF_mon (max ar1 ar2) (pmult_mon (m1, m2)).

Lemma pWF_pmult : forall p1 p2,
  pWF p1 -> pWF p2 -> pWF (pmult p1 p2).

Lemma pmult_mon_correct : forall m12 l,
  peval_mon (pmult_mon m12) l =
  peval_mon (fst m12) l * peval_mon (snd m12) l.

Lemma map_pmult_mon : forall m1 ml2 l,
 map (fun m2 => peval_mon (pmult_mon (m1, m2)) l) ml2 =
 map (fun m2 => peval_mon m1 l * peval_mon m2 l) ml2.

Lemma pmult_correct : forall p1 p2 l,
 peval (pmult p1 p2) l = peval p1 l * peval p2 l.

Definition pmultl (pl:list pol) : pol :=
  fold_right pmult (pcst 0 1) pl.

Lemma parity_pmultl pl :
  parity (pmultl pl) = maxl (map parity pl).

Definition pWF_pmultl pl :
  andl pWF pl -> pWF (pmultl pl).

Lemma pmultl_correct pl l :
  peval (pmultl pl) l = multl (map (fun p => peval p l) pl).

Fixpoint ppower (p:pol)(n:nat) : pol :=
  match n with
  | 0 => pcst (fst p) 1
  | S n' => pmult p (ppower p n')
  end.

Lemma parity_ppower p n :
  parity (ppower p n) = parity p.

Lemma pWF_ppower p n :
  pWF p -> pWF (ppower p n).

Lemma ppower_correct p n l :
  peval (ppower p n) l = power (peval p l) n.

Definition pcomp_pow' (xn:pow)(pl:list pol) : pol :=
  ppower (nth (fst xn) pl (pcst 0 0)) (snd xn).

Definition pcomp_pow (xn:pow)(pl:list pol) : pol :=
  (maxl (map parity pl), snd (pcomp_pow' xn pl)).

Definition pcomp_mon' (m:mon)(pl:list pol) : pol :=
  pscalar (fst m) (pmultl (map (fun xn => pcomp_pow xn pl) (snd m))).

Definition pcomp_mon (m:mon)(pl:list pol) : pol :=
  (maxl (map parity pl), snd (pcomp_mon' m pl)).

Definition pcomp' (p:pol)(pl:list pol) : pol :=
  pplusl (map (fun m => pcomp_mon m pl) (snd p)).

Definition pcomp (p:pol)(pl:list pol) : pol :=
  (maxl (map parity pl), snd (pcomp' p pl)).

Lemma parity_pcomp_pow : forall xn pl,
  parity (pcomp_pow xn pl) = maxl (map parity pl).

Lemma map_parity_pcomp_pow xl pl :
  map (fun xn => parity (pcomp_pow xn pl)) xl = map (fun _ => maxl (map parity pl)) xl.

Lemma parity_pcomp_mon' : forall m pl,
  parity (pcomp_mon' m pl) <= maxl (map parity pl).

Lemma parity_pcomp_mon : forall m pl,
  parity (pcomp_mon m pl) = maxl (map parity pl).

Lemma parity_pcomp p pl :
  parity (pcomp p pl) = maxl (map parity pl).

Lemma pWF_pcomp_pow' : forall xn pl,
  andl pWF pl -> pWF (pcomp_pow' xn pl).

Lemma pWF_pcomp_pow : forall xn pl,
  andl pWF pl -> pWF (pcomp_pow xn pl).

Lemma pWF_pcomp_mon' : forall m pl,
  andl pWF pl -> pWF (pcomp_mon' m pl).

Lemma pWF_pcomp_mon : forall m pl,
  andl pWF pl -> pWF (pcomp_mon m pl).

Lemma pWF_pcomp' : forall p pl,
  andl pWF pl -> pWF (pcomp' p pl).

Lemma pWF_pcomp : forall p pl,
  andl pWF pl -> pWF (pcomp p pl).

Lemma pcomp_pow'_correct : forall xn pl l,
  peval (pcomp_pow' xn pl) l =
  power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).

Lemma pcomp_pow_correct xn pl l :
  peval (pcomp_pow xn pl) l =
  power (peval (nth (fst xn) pl (pcst 0 0)) l) (snd xn).

Lemma pcomp_mon'_correct : forall m pl l,
  peval (pcomp_mon' m pl) l = peval_mon m (map (fun p => peval p l) pl).

Lemma pcomp_mon_correct : forall m pl l,
  peval (pcomp_mon m pl) l = peval_mon m (map (fun p => peval p l) pl).

Lemma pcomp'_correct : forall p pl l,
  peval (pcomp' p pl) l = peval p (map (fun p' => peval p' l) pl).

Lemma pcomp_correct p pl l :
  peval (pcomp p pl) l = peval p (map (fun p => peval p l) pl).

Definition pshift_pow (xn:pow) : pow :=
  (S (fst xn), snd xn).

Definition pshift_mon (m:mon) : mon :=
  (fst m, map pshift_pow (snd m)).

Definition pshift (p:pol) : pol :=
  (S (fst p), map pshift_mon (snd p)).

Lemma parity_pshift : forall p,
  parity (pshift p) = S (parity p).

Lemma pWF_pshift_mon : forall ar m,
  pWF_mon ar m -> pWF_mon (S ar) (pshift_mon m).

Lemma pWF_pshift : forall p, pWF p -> pWF (pshift p).

Lemma pshift_pow_correct : forall xn l,
  peval_pow (pshift_pow xn) l = peval_pow xn (tl l).

Lemma pshift_mon_correct : forall m l,
  peval_mon (pshift_mon m) l = peval_mon m (tl l).

Lemma pshift_correct : forall p l,
  peval (pshift p) l = peval p (tl l).

Definition psum (start len : nat) : pol :=
  pplus (pcst (start+len) 0) (pplusl (map (pproj (start+len)) (seq start len))).

Lemma psum_correct start len l :
  peval (psum start len) l = 
  plusl (map (fun i => nth i l 0) (seq start len)).

Lemma pWF_psum start len : pWF (psum start len).

Lemma parity_psum start len : 
  parity (psum start len) = start + len.

Ltac pWF :=
  match goal with
  | |- pWF (pcst _ _) => apply pWF_pcst
  | |- pWF (pproj _ _) => apply pWF_pproj; try omega
  | |- pWF (pscalar _ _) => apply pWF_pscalar; pWF
  | |- pWF (pplus _ _) => apply pWF_pplus; pWF
  | |- pWF (pplusl _) => apply pWF_pplusl; rewrite <- forall_andl; intros; pWF
  | |- pWF (pmult _ _) => apply pWF_pmult; pWF
  | |- pWF (pmultl _) => apply pWF_pmultl; rewrite <- forall_andl; intros; pWF
  | |- pWF (ppower _ _) => apply pWF_ppower; pWF
  | |- pWF (pcomp _ _) => apply pWF_pcomp; rewrite <- forall_andl; intros; pWF
  | |- pWF (pshift _) => apply pWF_pshift; pWF
  | |- pWF (psum _ _) => apply pWF_psum
  | |- _ => idtac
  end.

Definition deg_mon (m:mon) : nat :=
  plusl (map (@snd _ _) (snd m)).

Definition deg (p:pol) : nat :=
  maxl (map deg_mon (snd p)). *)
(* BellantoniCook.Cobham:
Require Import Bool Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.

Inductive Cobham : Type :=
| Zero : Cobham
| Proj : nat -> nat -> Cobham
| Succ : bool -> Cobham
| Smash : Cobham
| Rec  : Cobham -> Cobham -> Cobham -> Cobham -> Cobham
| Comp : nat -> Cobham -> list Cobham -> Cobham.

Definition Rec2 g h j := Rec g h h j.

Lemma Cobham_ind2' :
  forall P : Cobham -> Prop,
  forall Q : list Cobham -> Prop,
  Q nil ->
  (forall e l, P e -> Q l -> Q (e :: l)) ->
  P Zero ->
  (forall n i, P (Proj n i)) ->
  (forall b, P (Succ b)) ->
  P Smash ->
  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->
  (forall n h l, P h -> Q l -> P (Comp n h l)) ->
  forall e, P e.

Lemma Cobham_ind2 :
  forall P : Cobham -> Prop,
  P Zero ->
  (forall n i, P (Proj n i)) ->
  (forall b, P (Succ b)) ->
  P Smash ->
  (forall j g h0 h1, P j -> P g -> P h0 -> P h1 -> P (Rec j g h0 h1)) ->
  (forall n h l, P h -> (forall e, In e l -> P e) ->
    P (Comp n h l)) ->
  forall e, P e.

Inductive Arity : Set :=
| error_Rec : Arity -> Arity -> Arity -> Arity -> Arity
| error_Comp : Arity -> list Arity -> Arity
| error_Proj : nat -> nat -> Arity
| ok_arity : nat -> Arity.

Definition arity_eq (a1 a2 : Arity) :=
  match a1, a2 with
    | ok_arity n1, ok_arity n2 => beq_nat n1 n2
    | _, _ => false
  end.

Lemma arity_eq_true x1 x2 :
  arity_eq x1 x2 = true -> x1 = x2.

Lemma arity_eq_refl : forall n, arity_eq (ok_arity n) (ok_arity n) = true.

Fixpoint arity (e : Cobham) : Arity :=
  match e with
    | Zero => ok_arity 0
    | Proj n j => if leb (S j) n 
      then ok_arity n else error_Proj n j 
    | Succ _ => ok_arity 1
    | Smash => ok_arity 2
    | Rec g h0 h1 j => 
      match arity g, arity h0, arity h1, arity j with
        | ok_arity gn, ok_arity h0n, ok_arity h1n, ok_arity jn =>
          if beq_nat (S (S gn)) h0n && 
             beq_nat h1n h0n &&
             beq_nat (S jn) h1n 
            then ok_arity jn 
            else error_Rec (ok_arity gn) (ok_arity h0n) 
              (ok_arity h1n) (ok_arity jn)
        | ag, ah0, ah1, aj => error_Rec ag ah0 ah1 aj 
      end
    | Comp n h l => 
      match arity h, map arity l with
        | ok_arity nh, al => 
          if beq_nat nh (length l) &&
            forallb (fun e => arity_eq e (ok_arity n)) al then
              ok_arity n else error_Comp (ok_arity nh) al
        | e , le => error_Comp e le 
      end
  end.

Lemma Cobham_ind_inf' :
  forall (P : nat -> Cobham -> Prop),
  forall Q : nat -> list Cobham -> Prop,
  (forall n, Q n nil) ->
  (forall e n l, P n e -> Q n l -> Q n (e :: l)) ->
  P 0 Zero ->
  (forall n i, i < n  ->  P n (Proj n i)) ->
  (forall b, P 1 (Succ b)) ->
  (P 2 Smash) ->
  (forall n g h0 h1 j, 
    arity g = ok_arity n ->
    arity h0 = ok_arity (S (S n)) ->
    arity h1 = ok_arity (S (S n)) ->
    arity j = ok_arity (S n) ->
    P n g -> 
    P (S (S n)) h0 -> 
    P (S (S n)) h1 -> 
    P (S n) j -> 
    P (S n) (Rec g h0 h1 j)) ->
  (forall n h rl, 
    arity h = ok_arity (length rl)  ->
    (forall e, In e rl -> arity e = ok_arity n) ->
    P (length rl)  h -> 
    Q n rl ->
    P n (Comp n h rl)) ->
  forall e n , arity e = ok_arity n -> P n e.

Lemma Cobham_ind_inf :
  forall (P : nat -> Cobham -> Prop),
  P 0 Zero ->
  (forall n i, i < n  ->  P n (Proj n i)) ->
  (forall b, P 1 (Succ b)) ->
  (P 2 Smash) ->
  (forall n g h0 h1 j, 
    arity g = ok_arity n ->
    arity h0 = ok_arity (S (S n)) ->
    arity h1 = ok_arity (S (S n)) ->
    arity j = ok_arity (S n) ->
    P n g -> 
    P (S (S n)) h0 -> 
    P (S (S n)) h1 -> 
    P (S n) j ->
    P (S n) (Rec g h0 h1 j)) ->
  (forall n h rl, 
    arity h = ok_arity (length rl)  ->
    (forall e, In e rl -> arity e = ok_arity n) ->
    P (length rl) h -> 
    (forall r, In r rl -> P n r) ->
    P n (Comp n h rl)) ->
  forall e n , arity e = ok_arity n -> P n e.

Fixpoint sem_Rec (sem_g sem_h0 sem_h1 : list bs -> bs) (v : bs) (vl : list bs) : bs :=
  match v with
    | nil => sem_g vl
    | b::v' => if b then 
      sem_h1 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)
      else sem_h0 (v' :: (sem_Rec sem_g sem_h0 sem_h1 v' vl) :: vl)
  end.

Fixpoint smash' (x y : bs) :=
  match x with 
    | nil => y
    | _ :: x' => false :: smash' x' y
  end.

Lemma length_smash' x y :
  length (smash' x y) = length x + length y.

Fixpoint smash_bs (x y : bs) : bs :=
  match x with
    | nil => true :: nil
    | _ :: x' => smash' y (smash_bs x' y)
  end.

Lemma length_smash x y :
  length (smash_bs x y) = 1 + length x * length y.

Fixpoint Sem (e: Cobham) (vl:list bs) : bs :=
  match e with
  | Zero => nil
  | Proj n j => nth j vl nil
  | Succ b => b :: hd nil vl
  | Smash => smash_bs (hd nil vl) (hd nil (tl vl))
  | Rec g h0 h1 j =>  
    sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil vl) (tail vl)
  | Comp _ h l => Sem h (List.map (fun e => Sem e vl) l)
  end.

Lemma simpl_Rec : forall g h0 h1 j l,
  Sem (Rec g h0 h1 j) l = sem_Rec (Sem g) (Sem h0) (Sem h1) (hd nil l) (tl l).

Lemma Sem_add_zero : forall e n,
  arity e = ok_arity n ->
  forall l,
  length l <= n ->
  Sem e l = Sem e (l ++ (map (fun e => nil) (seq 0 (n - length l)))).

Lemma Sem_remove_zero : forall e n,
  arity e = ok_arity n ->
  forall l l',  n = length l ->
    Sem e l = Sem e (l ++ l').

Fixpoint rec_bounded' (e : Cobham) : Prop :=
  match e with
    | Rec g h0 h1 j =>
      rec_bounded' j  /\ 
      rec_bounded' g /\ 
      rec_bounded' h0 /\ 
      rec_bounded' h1 /\
      (match (arity e) with
         | ok_arity n => forall l, length l = n ->
           length (Sem e l) <= length (Sem j l)
        | _ => True 
       end)
    | Comp n h l => rec_bounded' h /\
        andl rec_bounded' l
    | _ => True
  end.

Fixpoint rec_bounded (e : Cobham) : Prop :=
  match e with
    | Rec g h0 h1 j =>
      rec_bounded j  /\ 
      rec_bounded g /\ 
      rec_bounded h0 /\ 
      rec_bounded h1 /\
      (forall l, 
        length (Sem e l) <= length (Sem j l))
    | Comp n h l => rec_bounded h /\
        andl rec_bounded l
    | _ => True
  end.

Lemma rec_bounded_spec (e : Cobham) :
  rec_bounded e -> rec_bounded' e.

Lemma rec_bounded'_spec : forall (e : Cobham) n,
  arity e = ok_arity n ->
  rec_bounded' e -> 
  rec_bounded e.

Fixpoint poly_Cobham (e : Cobham) :=
  match e with
    | Zero => pcst 0 0
    | Proj n i => pproj n i
    | Succ b => pplus (pcst 0 1) (pproj 1 0)
    | Smash => pplus (pcst 0 1) (pmult (pproj 2 0) (pproj 2 1))
    | Rec g h0 h1 j => poly_Cobham j
    | Comp n h l => 
      pplus (pcst n 0) 
      (pcomp (poly_Cobham h) (map poly_Cobham l))
  end.

Lemma parity_poly_Cobham : forall (e : Cobham) n,
  arity e = ok_arity n ->
  parity (poly_Cobham e) = n.

Lemma pWF_poly_Cobham : forall (e : Cobham) n,
  arity e = ok_arity n ->
  pWF (poly_Cobham e).

Lemma poly_Cobham_correct : forall (e : Cobham) xl,
  rec_bounded e ->  
  length (Sem e xl) <= 
  peval (poly_Cobham e) (map (@length _) xl). *)
(* BellantoniCook.CobhamLib:
Require Import Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Cobham.

Definition Zero_e (n:nat) : Cobham :=
  Comp n Zero nil.

Lemma arity_Zero n : arity (Zero_e n) = ok_arity n.

Lemma rec_bounded_Zero n : 
  rec_bounded (Zero_e n).

Definition One_e (n:nat) : Cobham :=
  Comp n (Comp 0 (Succ true) [Zero]) nil.

Lemma arity_One n : arity (One_e n) = ok_arity n.

Lemma rec_bounded_One n :
  rec_bounded (One_e n).

Definition App_e : Cobham :=
  Rec (Proj 1 0)
  (Comp 3 (Succ false) [Proj 3 1])
  (Comp 3 (Succ true) [Proj 3 1])
  (Comp 2 Smash [Comp 2 (Succ true) [Proj 2 0]; Comp 2 (Succ true) [Proj 2 1] ]).

Lemma arity_App : arity App_e = ok_arity 2.

Lemma rec_bounded_App : rec_bounded App_e.

Lemma App_correct : forall l,
  Sem App_e l = hd nil l ++ hd nil (tl l).

Opaque App_e.

Definition Rev_e : Cobham :=
  Rec
    Zero
    (Comp 2 App_e [Proj 2 1; Comp 2 (Succ false) [Zero_e 2]])
    (Comp 2 App_e [Proj 2 1; Comp 2 (Succ true) [Zero_e 2]])
    (Proj 1 0).

Lemma arity_Rev : 
  arity Rev_e = ok_arity 1.

Lemma rec_bounded_Rev :
  rec_bounded Rev_e.

Lemma Rev_correct l :
  Sem Rev_e l = List.rev (hd nil l).

Definition RemoveLSZ_e : Cobham :=
  Rec
    Zero
    (Proj 2 1)
    (Comp 2 (Succ true) [Proj 2 0])
    (Proj 1 0).

Lemma arity_RemoveLSZ : 
  arity RemoveLSZ_e = ok_arity 1.

Lemma rec_bounded_RemoveLSZ :
  rec_bounded RemoveLSZ_e.

Lemma RemoveLSZ_app u v l :
  Sem RemoveLSZ_e ((u++v)::l) =
  match Sem RemoveLSZ_e (u::l) with
  | nil => Sem RemoveLSZ_e (v::l)
  | u' => u'++v
  end.

Definition Cond : Cobham :=
  Rec (Proj 3 0) (Proj 5 4) (Proj 5 3) (
    Comp 4 Smash [
      Comp 4 (Succ true) [Proj 4 1];
      Comp 4 Smash [
        Comp 4 (Succ true) [Proj 4 2];
        Comp 4 (Succ true) [Proj 4 3]
      ]
    ]
  ).

Lemma arity_Cond : arity Cond = ok_arity 4.

Lemma rec_bounded_Cond : rec_bounded' Cond.

Lemma Cond_correct : forall l,
  Sem Cond l =
  match hd nil l with
  | nil => hd nil (tl l)
  | true::_ => hd nil (tl (tl l))
  | false::_ => hd nil (tl (tl (tl l)))
  end. *)
(* BellantoniCook.CobhamUnary:
Require Import Arith List.
Require Import BellantoniCook.Lib BellantoniCook.MultiPoly BellantoniCook.Cobham BellantoniCook.CobhamLib.

Lemma Zero_correct n l: 
  length (Sem (Zero_e n) l) = 0.

Lemma One_correct n l: 
  length (Sem (One_e n) l) = 1.

Definition Succ_e : Cobham :=
  Comp 1 (Succ true) [Proj 1 0].

Lemma arity_Succ : arity Succ_e = ok_arity 1.

Lemma rec_bounded_Succ :
  rec_bounded Succ_e.

Lemma Succ_correct l : 
  length (Sem Succ_e l) = S (length (Sem (Proj 1 0) l)).

Opaque Succ_e.

Fixpoint Nat_e (n:nat) : Cobham :=
  match n with
    | 0 => Zero
    | S n' => Comp 0 Succ_e [Nat_e n']
  end.

Lemma arity_Nat n : arity (Nat_e n) = ok_arity 0.

Lemma rec_bounded_Nat n :
  rec_bounded (Nat_e n).

Lemma Nat_correct : forall n l,
  length (Sem (Nat_e n) l) = n.

Notation Plus_e := App_e.

Notation arity_Plus := arity_App.

Notation rec_bounded_Plus := rec_bounded_App.

Lemma Plus_correct : forall l,
  length (Sem Plus_e l) = length (hd nil l) + length (hd nil (tl l)).

Opaque Plus_e.

Fixpoint Plusl_e (ar:nat)(el:list Cobham) : Cobham :=
  match el with
    | nil => Zero_e ar
    | e' :: el' => Comp ar Plus_e [e'; Plusl_e ar el']
  end. 

Lemma arity_Plusl ar el : 
  andl (fun e => arity e = ok_arity ar) el ->
  arity (Plusl_e ar el) = ok_arity ar.

Lemma rec_bounded_Plusl ar el :
  andl rec_bounded el -> rec_bounded (Plusl_e ar el).

Lemma Plusl_correct : forall ar el l,
  length (Sem (Plusl_e ar el) l) = plusl (map (fun e => length (Sem e l)) el).

Opaque Plusl_e.

Definition Mult_e : Cobham :=
  Rec2
  (Zero_e 1)
  (Comp 3 Plus_e [Proj 3 1; Proj 3 2])
  (Comp 2 Smash [
    One_e 2;
    Comp 2 Smash [Comp 2 (Succ true) [Proj 2 0]; Comp 2 (Succ true) [Proj 2 1] ] ] ).

Lemma arity_Mult : arity Mult_e = ok_arity 2.

Lemma rec_bounded_Mult : rec_bounded Mult_e.

Lemma Mult_correct : forall l,
  length (Sem Mult_e l) = length (hd nil l) * length (hd nil (tl l)).

Opaque Mult_e.

Fixpoint Multl_e (ar:nat)(el:list Cobham) : Cobham :=
  match el with
    | nil => One_e ar
    | e' :: el' => Comp ar Mult_e [e'; Multl_e ar el']
  end. 

Lemma arity_Multl ar el : 
  andl (fun e => arity e = ok_arity ar) el ->
  arity (Multl_e ar el) = ok_arity ar.

Lemma rec_bounded_Multl ar el :
  andl rec_bounded el -> rec_bounded (Multl_e ar el).

Lemma Multl_correct : forall ar el l,
  length (Sem (Multl_e ar el) l) = 
  multl (map (fun e => length (Sem e l)) el).

Fixpoint Power_e (n:nat) : Cobham :=
  match n with
    | 0 => One_e 1
    | S n' => Comp 1 Mult_e [Proj 1 0; Power_e n']
  end.

Lemma arity_Power n : arity (Power_e n) = ok_arity 1.

Lemma rec_bounded_Power n : rec_bounded (Power_e n).

Lemma Power_correct : forall n l,
  length (Sem (Power_e n) l) = power (length (hd nil l)) n.

Definition Poly_pow (ar:nat) (xn:pow) : Cobham :=
  Comp ar (Power_e (snd xn)) [Proj ar (fst xn)].

Lemma arity_Poly_pow : forall ar xn,
  pWF_pow ar xn -> arity (Poly_pow ar xn) = ok_arity ar.

Lemma rec_bounded_Poly_pow : forall ar xn,
  rec_bounded (Poly_pow ar xn).

Lemma Poly_pow_correct : forall ar xn l,
  length (Sem (Poly_pow ar xn) l) = peval_pow xn (map (@length _) l).

Opaque Poly_pow.

Definition Poly_mon (ar:nat)(m:mon) : Cobham :=
  Comp ar Mult_e [Comp ar (Nat_e (fst m)) nil; Multl_e ar (map (Poly_pow ar) (snd m))].

Lemma arity_Poly_mon : forall ar m,
  pWF_mon ar m ->
  arity (Poly_mon ar m) = ok_arity ar.

Lemma rec_bounded_Poly_mon : forall ar m,
  rec_bounded (Poly_mon ar m).

Lemma Poly_mon_correct : forall ar m l,
  length (Sem (Poly_mon ar m) l) = peval_mon m (map (@length _) l).

Opaque Poly_mon.

Definition Poly (p : pol) : Cobham :=
  Plusl_e (fst p) (map (Poly_mon (fst p)) (snd p)).

Lemma arity_Poly : forall p,
  pWF p ->
  arity (Poly p) = ok_arity (parity p).

Lemma rec_bounded_Poly : forall p,
  rec_bounded (Poly p).

Lemma Poly_correct : forall p l,
  length (Sem (Poly p) l) = peval p (map (@length _) l).

Opaque Poly. *)
(* BellantoniCook.BC:
Require Import Bool Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.

Inductive BC : Set :=
| zero : BC
| proj : nat -> nat -> nat -> BC
| succ : bool -> BC
| pred : BC
| cond : BC
| rec : BC -> BC -> BC -> BC
| comp : nat -> nat -> BC -> list BC -> list BC -> BC.  

Lemma BC_ind2' :
  forall P : BC -> Prop,
  forall Q : list BC -> Prop,
  Q nil ->
  (forall e l, P e -> Q l -> Q (e :: l)) ->
  P zero ->
  (forall n s i, P (proj n s i)) ->
  (forall b, P (succ b)) ->
  P pred ->
  P cond ->
  (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) ->
  (forall n s h rl tl, P h -> Q rl -> Q tl ->
    P (comp n s h rl tl)) ->
  forall e, P e.

Lemma BC_ind2 :
  forall P : BC -> Prop,
  P zero ->
  (forall n s i, P (proj n s i)) ->
  (forall b, P (succ b)) ->
  P pred ->
  P cond ->
  (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) ->
  (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> 
    (forall s, In s tl -> P s) ->
    P (comp n s h rl tl)) ->
  forall e, P e.

Inductive Arities : Set :=
| error_rec : Arities -> Arities -> Arities -> Arities
| error_comp : Arities -> list Arities -> list Arities -> Arities
| error_proj : nat -> nat -> nat -> Arities
| ok_arities : nat -> nat -> Arities.

Definition aeq (x y:Arities) : bool :=
  match x, y with
  | ok_arities xn xs, ok_arities yn ys => beq_nat xn yn && beq_nat xs ys
  | _, _ => false
  end.

Lemma aeq_eq (x y : Arities) :
  aeq x y = true -> x = y.

Lemma aeq_eq_conv xn yn xs ys :
  aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \/ xs <> ys.

Fixpoint arities (e:BC) : Arities :=
  match e with
  | zero => ok_arities 0 0
  | proj n s i => 
    if leb (S i) (n + s) then ok_arities n s
      else error_proj n s i
  | succ _ => ok_arities 0 1
  | pred => ok_arities 0 1
  | cond => ok_arities 0 4
  | rec g h0 h1 =>
      match arities g, arities h0, arities h1 
        with | ok_arities gn gs, ok_arities h0n h0s, ok_arities h1n h1s =>
          if beq_nat (S gn) h0n && beq_nat h0n h1n &&
            beq_nat (S gs) h0s && beq_nat h0s h1s 
          then ok_arities h0n gs 
            else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s)
        | e1, e2, e3 => error_rec e1 e2 e3
      end
    | comp n s h nl sl =>
      match arities h, map arities nl, map arities sl with
      | ok_arities hn hs, anl, asl =>
        if beq_nat hn (length nl) && beq_nat hs (length sl) && 
          forallb (fun ne => aeq (arities ne) (ok_arities n 0)) nl &&
          forallb (fun se => aeq (arities se) (ok_arities n s)) sl
          then ok_arities n s
          else error_comp (ok_arities hn hs) anl asl 
      | e , anl, asl => error_comp e anl asl
      end
  end.

Definition arities2 e :=
  match arities e with
    | ok_arities n s => (n, s)
    | _ => (0, 0)
  end.

Lemma proj_arities : forall n s i, 
  i < n+s -> 
  arities (proj n s i) = ok_arities n s.

Lemma comp_arities : forall n s e nel sel,
  arities e = ok_arities (length nel) (length sel) ->
  andl (fun ne => arities ne = ok_arities n 0) nel ->
  andl (fun se => arities se = ok_arities n s) sel ->
  arities (comp n s e nel sel) = ok_arities n s.

Lemma arities_nth :
  forall l i e n s,
  (forall e, In e l -> arities e = ok_arities n s) ->
  arities e = ok_arities n s ->
  arities (nth i l e) = ok_arities n s.

Lemma BC_ind_inf' :
  forall (P : nat -> nat -> BC -> Prop),
  forall Q : nat -> nat -> list BC -> Prop,
  (forall n s, Q n s nil) ->
  (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) ->
  P 0 0 zero ->
  (forall n s i, i < n + s ->  P n s (proj n s i)) ->
  (forall b, P 0 1 (succ b)) ->
  P 0 1 pred ->
  P 0 4 cond ->
  (forall n s g h0 h1, 
    arities g = ok_arities n s ->
    arities h0 = ok_arities (S n) (S s) ->
    arities h1 = ok_arities (S n) (S s) ->
    P n s g -> 
    P (S n) (S s) h0 -> 
    P (S n) (S s) h1 -> 
    P (S n) s (rec g h0 h1)) ->
  (forall n s h rl tl, 
    arities h = ok_arities (length rl) (length tl) ->
    (forall e, In e rl -> arities e = ok_arities n 0) ->
    (forall e, In e tl -> arities e = ok_arities n s) ->
    P (length rl) (length tl) h -> 
    Q n 0 rl -> 
    Q n s tl ->
    P n s (comp n s h rl tl)) ->
  forall e n s , arities e = ok_arities n s -> P n s e.

Lemma BC_ind_inf :
  forall (P : nat -> nat -> BC -> Prop),
  P 0 0 zero ->
  (forall n s i, i < n + s ->  P n s (proj n s i)) ->
  (forall b, P 0 1 (succ b)) ->
  P 0 1 pred ->
  P 0 4 cond ->
  (forall n s g h0 h1, 
    arities g = ok_arities n s ->
    arities h0 = ok_arities (S n) (S s) ->
    arities h1 = ok_arities (S n) (S s) ->
    P n s g -> 
    P (S n) (S s) h0 -> 
    P (S n) (S s) h1 -> 
    P (S n) s (rec g h0 h1)) ->
  (forall n s h rl tl, 
    arities h = ok_arities (length rl) (length tl) ->
    (forall e, In e rl -> arities e = ok_arities n 0) ->
    (forall e, In e tl -> arities e = ok_arities n s) ->
    P (length rl) (length tl) h -> 
    (forall r, In r rl -> P n 0 r) ->
    (forall r, In r tl -> P n s r) ->
    P n s (comp n s h rl tl)) ->
  forall e n s , arities e = ok_arities n s -> P n s e.

Fixpoint sem_rec (sem_g sem_h0 sem_h1:list bs->list bs->bs)(v:bs)(vnl vsl:list bs) :=
  match v with
    | nil => sem_g vnl vsl
    | b::v' =>
      if b then sem_h1 (v'::vnl) (sem_rec sem_g sem_h0 sem_h1 v' vnl vsl :: vsl)
      else sem_h0 (v'::vnl) (sem_rec sem_g sem_h0 sem_h1 v' vnl vsl :: vsl)
  end.

Fixpoint sem (e:BC)(vnl vsl:list bs) : bs :=
  match e with
  | zero => nil
  | proj n s j => 
    if leb (S j) n then
      nth j vnl nil
      else nth (j-n) vsl nil
  | succ b => b :: hd nil vsl
  | pred => tail (hd nil vsl)
  | cond =>
      match vsl with
      | a :: b :: c :: d :: _ => 
        match a with 
          | nil => b
          | true :: _ => c
          | false :: _ => d
        end
      | a :: b :: c :: _ => 
        match a with 
          | nil => b
          | true :: _ => c
          | false :: _ => nil
        end
      | a :: b :: _ => 
        match a with 
          | nil => b
          | _ => nil
        end
      | _ => nil
      end
  | rec g h0 h1 => sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tail vnl) vsl
  | comp _ _ h nl sl => 
    sem h (List.map (fun ne => sem ne vnl nil) nl) 
          (List.map (fun se => sem se vnl vsl) sl)
  end.

Lemma sem_comp :
  forall n s f nel sel nl sl, 
  sem (comp n s f nel sel) nl sl =
  sem f (map (fun ne => sem ne nl nil) nel) (map (fun se => sem se nl sl) sel).

Lemma cond_simpl_nil n s fn fc ff ft l1 l2 :
  sem fc l1 l2 = nil ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.

Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 :
  sem fc l1 l2 <> nil ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = 
  match sem fc l1 l2 with
    | nil => nil 
    | true :: _ => sem ft l1 l2 
    | false :: _ => sem ff l1 l2
  end.

Lemma cond_simpl_true n s fn fc ff ft l1 l2 :
  hd false (sem fc l1 l2) = true ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.

Lemma cond_simpl_false n s fn fc ff ft l1 l2 l :
  sem fc l1 l2 = false :: l ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.

Lemma sem_nth :
  forall i start len f d vnl vsl,
  0 <= i < len ->
  sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.

Lemma map_sem_nth :
  forall i f1 f2 vnl vsl d,
  map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 ->
  sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.

Lemma sem_proj_S_normal :
  forall n s i f vsl vnl,
  i < n ->
  sem (proj (S n) s (S i)) (f::vnl) vsl =
  sem (proj n s i) vnl vsl.

Lemma sem_proj_S_safe :
  forall n s i f vsl vnl,
  n <= i ->
  sem (proj n (S s) (S i)) vnl (f::vsl) =
  sem (proj n s i) vnl vsl.

Lemma sem_firstn_safe :
  forall f n s vnl vsl,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f vnl (firstn s vsl).

Lemma sem_firstn_normal :
  forall f n s vnl vsl,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f (firstn n vnl) vsl.

Lemma sem_firstn :
  forall f n s vnl vsl,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).

Lemma sem_repeat :
  forall f vnl vsl n s,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).

Lemma map_sem_repeat :
  forall fl vnl vsl n s,
  (forall f, In f fl -> arities f = ok_arities n s) ->
  map (fun f => sem f vnl vsl) fl =
  map (
    fun f =>
      sem f
        (vnl ++ repeat (n - length vnl) nil)
        (vsl ++ repeat (s - length vsl) nil)
  ) fl.

Lemma map_proj_seq_normal_gen :
  forall n i vnl,
  n+i <= length vnl ->
  map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) =
  firstn n (skipn i vnl).

Lemma map_proj_seq_normal :
  forall n vnl,
  map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) =
  firstn n vnl ++ repeat (n - length vnl) nil.

Lemma map_proj_seq_safe_gen :
  forall n s i vnl vsl,
  s+i <= length vsl ->
  map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) =
  firstn s (skipn i vsl).

Lemma map_proj_seq_safe :
  forall n s vnl vsl,
  map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) =
  firstn s vsl ++ repeat (s - length vsl) nil.

Definition zero_e (n s:nat) : BC :=
  comp n s zero nil nil.

Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i,
n2 <> 0 -> i < n2 ->
sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil =
sem (nth i f1 (zero_e n1 0)) vnl nil.

Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i,
n2 <= i ->
sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl =
sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.

Fixpoint poly_BC n (e : BC) : pol :=
  match e with 
    | zero => pcst 0 0
    | proj n s i => if (leb (S i) n) then pproj n i else (pcst n 0)
    | succ b => pcst 0 1
    | pred => pcst 0 0
    | cond => pcst 0 0
    | rec g h0 h1 =>
        pplus (pshift (poly_BC (n - 1) g)) 
        (pmult (pproj n 0) (pplus (poly_BC n h0) (poly_BC n h1)))
    | comp n s h rl tl =>
      (pplus (pcst n 0)
        (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl ))
          (pplusl (map (poly_BC n) tl))))
  end.

Lemma arity_poly_BC : forall e n s,
  arities e = ok_arities n s ->
  parity (poly_BC n e) = n.

Lemma pWF_poly_BC : forall e n s,
  arities e = ok_arities n s -> pWF (poly_BC n e).
  
Lemma polymax_bounding : forall (e : BC) xl yl n s,
  arities e = ok_arities n s ->
  length (sem e xl yl) <= 
  peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).

Lemma proj_seq_shift_safe : forall n m ln ls d,
 map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) =
 map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).

Lemma proj_seq_shift_normal : forall n ln ls d,
 map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) =
 map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).

Section TIME.

  Variable ptime_zero_cost ptime_succ_cost ptime_pred_cost ptime_cond_cost: nat.
  Variable ptime_proj_cost : nat -> nat -> nat -> nat.

  Fixpoint sem_cost_rec (sem_g sem_h0 sem_h1:list bs->list bs->bs*nat)(v:bs)(vnl vsl:list bs) :
    bs * nat :=
    match v with
      | nil => sem_g vnl vsl
      | b::v' =>
        if b
          then
            let sem_cost := sem_cost_rec sem_g sem_h0 sem_h1 v' vnl vsl in
              let sem_cost_h := sem_h1 (v'::vnl) (fst sem_cost :: vsl) in
                (fst sem_cost_h, snd sem_cost + snd sem_cost_h)
          else
            let sem_cost := sem_cost_rec sem_g sem_h0 sem_h1 v' vnl vsl in
              let sem_cost_h := sem_h0 (v'::vnl) (fst sem_cost :: vsl) in
                (fst sem_cost_h, snd sem_cost + snd sem_cost_h)
    end.

Fixpoint sem_cost (e:BC)(vnl vsl:list bs) : bs*nat :=
 match e with
 | zero => (nil, ptime_zero_cost)
 | proj n s j => (
   if leb (S j) n then
     nth j vnl nil
     else nth (j-n) vsl nil, ptime_proj_cost n s j
   )
 | succ b => (b :: hd nil vsl, ptime_succ_cost)
 | pred => (tail (hd nil vsl), ptime_pred_cost)
 | cond => (
     match vsl with
     | a :: b :: c :: d :: _ =>
       match a with
         | nil => b
         | true :: _ => c
         | false :: _ => d
       end
     | a :: b :: c :: _ =>
       match a with
         | nil => b
         | true :: _ => c
         | false :: _ => nil
       end
     | a :: b :: _ =>
       match a with
         | nil => b
         | _ => nil
       end
     | _ => nil
     end, ptime_cond_cost
   )
 | rec g h0 h1 =>
     sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tail vnl) vsl
 | comp _ _ h nl sl =>
   let sem_cost_nl := List.map (fun ne => sem_cost ne vnl nil) nl in
   let sem_cost_sl := List.map (fun se => sem_cost se vnl vsl) sl in
   let sem_nl := List.map (@fst _ _) sem_cost_nl in
   let sem_sl := List.map (@fst _ _) sem_cost_sl in
   let cost_nl := List.map (@snd _ _) sem_cost_nl in
   let cost_sl := List.map (@snd _ _) sem_cost_sl in
   let sem_cost_h := sem_cost h sem_nl sem_sl in
   (fst sem_cost_h, snd sem_cost_h + plusl cost_nl + plusl cost_sl)
 end.

Lemma sem_cost_correct :
 forall e n s,
 arities e = ok_arities n s ->
 forall vnl vsl,
 fst (sem_cost e vnl vsl) = sem e vnl vsl.

  Variable ptime_zero ptime_succ ptime_pred ptime_cond: pol.
  Variable ptime_proj : nat -> nat -> nat -> pol.

  Hypothesis ptime_zero_spec : 
    snd (sem_cost zero nil nil) <= peval ptime_zero nil.

  Hypothesis ptime_zero_wf : pWF ptime_zero.

  Hypothesis ptime_zero_arity : parity ptime_zero = 0.

  Hypothesis ptime_succ_spec : forall b,
    snd (sem_cost (succ b) nil nil) <= peval ptime_succ nil.

  Hypothesis ptime_succ_wf : pWF ptime_succ.

  Hypothesis ptime_succ_arity : parity ptime_succ = 0.

  Hypothesis ptime_proj_spec : forall n s i l,
    length l = n ->
    snd (sem_cost (proj n s i) l nil) <= peval (ptime_proj n s i) (map (@length _) l).

  Hypothesis ptime_proj_wf : forall n s i, pWF (ptime_proj n s i).

  Hypothesis ptime_proj_arity : forall n s i, parity (ptime_proj n s i) = n.

  Hypothesis ptime_cond_spec : 
    snd (sem_cost cond nil nil) <= peval ptime_cond nil.

  Hypothesis ptime_cond_wf : pWF ptime_cond.

  Hypothesis ptime_cond_arity : parity ptime_cond = 0.

  Hypothesis ptime_pred_spec : 
    snd (sem_cost pred nil nil) <= peval ptime_pred nil.

  Hypothesis ptime_pred_wf : pWF ptime_pred.

  Hypothesis ptime_pred_arity : parity ptime_pred = 0.

Fixpoint poly_time n (e:BC) : pol :=
  match e with
    | zero => ptime_zero
    | succ _ => ptime_succ
    | pred => ptime_pred
    | cond  => ptime_cond
    | proj n s i => ptime_proj n s i
    | rec g h0 h1 => 
      pplus (pshift (poly_time (n - 1) g))
      (pmult (pproj n 0) (pplus (poly_time n h0) (poly_time n h1)))
    | comp n0 s h rl tl =>
      pplus (pplus (pcst n0 0) (pcomp (poly_time (length rl) h) (map (poly_BC n0) rl)))
      (pplus (pplusl (map (poly_time n0) rl)) (pplusl (map (poly_time n0) tl)))
  end.
 
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).

Lemma arity_poly_time : forall e n s,
  arities e = ok_arities n s ->
  parity (poly_time n e) = n.

Lemma sem_cost_bounded : forall e n s,
 arities e = ok_arities n s ->
 (forall vnl vsl,
   length vnl = n -> 
   length vsl = s -> 
   snd (sem_cost e vnl vsl) <=
   peval (poly_time n e) (List.map (@length _) vnl)).

End TIME. *)
(* BellantoniCook.BCLib:
Require Import Bool Arith Even List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.BC.

Definition inv_e (e : BC) : BC :=
  comp 2 0 e (proj 2 0 1 :: proj 2 0 0 :: nil) nil.

Definition from_11_to_20 (e : BC) : BC :=
  comp 2 0 e (proj 2 0 0 :: nil) (proj 2 0 1 :: nil).

Lemma from_11_to_20_correct e v1 v2 :
  sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.

Definition app_e : BC :=
  rec (proj 0 1 0)
      (comp 1 2 (succ false) nil ((proj 1 2 1) :: nil))
      (comp 1 2 (succ true) nil ((proj 1 2 1) :: nil)).

Lemma app_correct v1 v2 :
  sem app_e [v1] [v2] = v1 ++ v2.

Program Fixpoint constant (v:bs) : { e : BC | arities e = ok_arities 0 0 /\ sem e nil nil = v } :=
  match v with
  | nil => BC.zero

Definition rec2 g h := rec g h h.

Lemma rec2_correct v1 v2 g h0 h1 :
  unary (hd nil v1) = true ->
  sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.

Lemma rec2_simpl g h i z l1 l2 :
  sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).

Lemma rec2_sem_rec g h z l1 l2 :
  sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.

Definition cond2 n s x g h0 h1 : BC :=
  comp n s
    cond nil [
      x;
      g;
      comp n s h0
        (map (proj n 0) (seq 0 n))
        (comp n s pred nil [x] :: map (proj n s) (seq n s));
      comp n s h1
        (map (proj n 0) (seq 0 n))
        (comp n s pred nil [x] :: map (proj n s) (seq n s))
    ].

Lemma arities_cond2 n s x g h0 h1
  (Hx : arities x = ok_arities n s)
  (Hg : arities g = ok_arities n s)
  (Hh0 : arities h0 = ok_arities n (S s))
  (Hh1 : arities h1 = ok_arities n (S s)) :
  arities (cond2 n s x g h0 h1) = ok_arities n s.

Definition cond2_correct n s x g h0 h1 vnl vsl :
  length vnl = n ->
  length vsl = s ->
  sem (cond2 n s x g h0 h1) vnl vsl =
  match sem x vnl vsl with
  | nil => sem g vnl vsl
  | true  :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl)
  | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl)
  end.

Definition rec1 n s g h :=
  rec
    g
    (comp (S n) (S s) h
      (comp (S n) 0 (succ false) nil [proj (S n) 0 0] ::
       map (proj (S n) 0)     (seq 1     n))
      (map (proj (S n) (S s)) (seq (S n) (S s))))
    (comp (S n) (S s) h
      (comp (S n) 0 (succ true) nil [proj (S n) 0 0] ::
       map (proj (S n) 0)     (seq 1     n))
      (map (proj (S n) (S s)) (seq (S n) (S s)))).

Lemma sem_rec_false g h0 h1 vnl vsl v :
  sem (rec g h0 h1) ((false :: v) :: vnl) vsl =
  sem h0 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).

Lemma sem_rec_true g h0 h1 vnl vsl v :
  sem (rec g h0 h1) ((true :: v) :: vnl) vsl =
  sem h1 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).

Lemma rec1_arities n s g h
  (Hg : arities g = ok_arities n s)
  (Hh : arities h = ok_arities (S n) (S s)) :
  arities (rec1 n s g h) = ok_arities (S n) s.

Fixpoint sem_rec1
  (g h:BC)(v : bs)(vnl vsl : list bs) {struct v} :=
  match v with
    | nil => sem g vnl vsl
    | _::v' => sem h (v::vnl) (sem_rec1 g h v' vnl vsl :: vsl)
  end.

Lemma rec1_correct n s g h vnl vsl :
  length vnl = S n ->
  length vsl = s ->
  sem (rec1 n s g h) vnl vsl =
  sem_rec1 g h (hd nil vnl) (tl vnl) vsl.

Definition rec3 n s x g h : BC :=
  comp n s
    (rec1 n s g h)
    (x ::
     map (proj n 0) (seq 0 n))
    (map (proj n s) (seq n s)).

Lemma arities_rec3 n s x g h
  (Hx : arities x = ok_arities n 0)
  (Hg : arities g = ok_arities n s)
  (Hh : arities h = ok_arities (S n) (S s)) :
  arities (rec3 n s x g h) = ok_arities n s.

Lemma rec3_correct n s x g h vnl vsl :
  length vnl = n ->
  length vsl = s ->
  sem (rec3 n s x g h) vnl vsl =
  sem_rec1 g h (sem x vnl nil) vnl vsl.

Definition true_e (n s:nat) : BC :=
  comp n s (comp 0 0 (succ true) nil (zero :: nil)) nil nil.

Lemma true_correct n s l1 l2: 
 bs2bool (sem (true_e n s) l1 l2) = true.

Lemma true_correct_nat n s l1 l2: 
 bs2nat (sem (true_e n s) l1 l2) = 1.

Definition false_e (n s:nat) : BC :=
  comp n s (comp 0 0 (succ false) nil (zero :: nil)) nil nil.

Lemma false_correct n s l1 l2: 
 bs2bool (sem (false_e n s) l1 l2) = false.

Lemma false_correct_nat n s l1 l2: 
 bs2nat (sem (false_e n s) l1 l2) = 0.

Definition parity_e : BC := 
  comp 0 1 cond nil [proj 0 1 0; false_e 0 1; true_e 0 1; false_e 0 1].

Lemma parity_correct_even v :
  bs2bool (sem parity_e nil [v]) = false ->
  even (bs2nat v).

Lemma parity_correct_odd v :
  bs2bool (sem parity_e nil [v]) = true ->
  odd (bs2nat v).

Definition P (x:bs)(y:bs) : bs := skipn (length x) y.

Lemma P_nil : forall x, P x nil = nil.

Definition P_e : BC :=
  rec (proj 0 1 0)
      (comp 1 2 pred nil [proj 1 2 1])
      (comp 1 2 pred nil [proj 1 2 1]).

Lemma P_correct x y :
  sem P_e [x] [y] = P x y.

Global Opaque P_e.

Definition P'_e := from_11_to_20 P_e.

Definition Y (z w y:bs) : bs :=
  P (P z w) y. 

Definition Y_e : BC :=
  comp 2 1 P_e 
  [comp 2 0 P'_e [proj 2 0 0; proj 2 0 1] nil] 
  [proj 2 1 2].

Lemma Y_correct z w y :
  sem Y_e [z;w] [y] = Y z w y.

Lemma Y_skipn z w y :
  Y z w y = skipn (length w - length z) y.

Global Opaque Y_e.

Lemma Y_nth x y z :
 hd false (Y x y z) = nth (length y - length x) z false.

Lemma Y_nil x y : Y x y nil = nil.

Lemma Y_refl x y : Y x x y = y.

Lemma Y_nil_length x y z :
  Y x y z = nil ->
  length z <= length y - length x.

Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.

Lemma Y_le : forall u w y , length u <= length w ->
   length (Y u w y) <= length (Y w w y).

Definition I_e : BC :=
  comp 2 1 parity_e nil 
  [comp 2 1 Y_e 
    [comp 2 0 (succ true) nil [proj 2 0 0]; proj 2 0 1] 
    [proj 2 1 2] ].

Lemma I_correct (z w y : bs) :
  sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].

Lemma I_Y_property j z w y :
  length z < length w ->
  length w - S (length z) < length y ->  
  Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.

Global Opaque I_e. *)
(* BellantoniCook.BCUnary:
Require Import Bool Arith Euclid List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.BC BellantoniCook.BCLib.

Fixpoint unary_preserv (e : BC) : bool :=
  match e with
    | zero => true
    | proj n s j => true
    | succ b => b
    | pred => true
    | cond => true
    | rec g h0 h1 => unary_preserv g  &&
                     unary_preserv h0 && 
                     unary_preserv h1 
    | comp _ _ h nl sl => unary_preserv h && 
                          forallb unary_preserv nl &&
                          forallb unary_preserv sl
  end.

 Lemma preservation : forall (e : BC) (vnl vsl : list bs),
  unary_preserv e = true ->
  forallb unary vnl = true ->
  forallb unary vsl = true ->
  unary (sem e vnl vsl) = true.

Lemma zero_correct n s l1 l2: 
 length (sem (zero_e n s) l1 l2) = 0.

Definition one_e (n s:nat) : BC :=
  comp n s (comp 0 0 (succ true) nil (zero :: nil)) nil nil.

Lemma one_correct n s l1 l2: 
 length (sem (one_e n s) l1 l2) = 1.

Definition succ_e : BC := succ true.

Lemma succ_correct :
  forall n, length (sem succ_e nil [n]) = S (length n).

Fixpoint nat2BC (n s x:nat) : BC :=
  match x with
    | 0 => zero_e n s
    | S x' => comp n s succ_e nil [nat2BC n s x']
  end.

Lemma nat2BC_arities : forall n s x, arities (nat2BC n s x) = ok_arities n s.

Lemma nat2BC_correct :
  forall n s x nl sl, length (sem (nat2BC n s x) nl sl) = x.

Opaque succ_e.

Definition plus_e : BC :=
  rec (proj 0 1 0)
      (comp 1 2 succ_e nil ((proj 1 2 1) :: nil))
      (comp 1 2 succ_e nil ((proj 1 2 1) :: nil)).

Lemma plus_correct :
  forall m n, length (sem plus_e [m] [n]) = length m + length n.

Opaque plus_e.

Fixpoint plusl_e (n:nat)(el:list BC) : BC :=
  match el with
    | nil => zero_e n 0
    | e' :: el' => comp n 0 plus_e [e'] [plusl_e n el']
  end.

Lemma plusl_arities n el : 
  andl (fun e => arities e = ok_arities n 0) el ->
  arities (plusl_e n el) = ok_arities n 0.

Lemma plusl_correct :
  forall n nl el,
  length (sem (plusl_e n el) nl nil) = plusl (map (fun e => length (sem e nl nil)) el).

Notation or_e := plus_e (only parsing).

Lemma or_correct :
  forall b1 b2, bs2bool (sem or_e [bool2bs b1] [bool2bs b2]) = b1 || b2.

Definition mult_e : BC :=
  rec (zero_e 1 0)
      (comp 2 1 plus_e ((proj 2 0 1) :: nil) ((proj 2 1 2) :: nil))
      (comp 2 1 plus_e ((proj 2 0 1) :: nil) ((proj 2 1 2) :: nil)).

Lemma mult_correct :
  forall m n, length (sem mult_e [m; n] nil) = (length m) * (length n).

Opaque mult_e.

Notation and_e := mult_e (only parsing).

Lemma and_correct :
  forall b1 b2, bs2bool 
    (sem and_e [bool2bs b1; bool2bs b2] nil) = b1 && b2.

Definition minus_rev_e : BC :=
  rec (proj 0 1 0)
      (comp 1 2 pred nil ((proj 1 2 1) :: nil))
      (comp 1 2 pred nil ((proj 1 2 1) :: nil)).

Lemma minus_rev_correct :
  forall m n, length (sem minus_rev_e [n] [m]) = (length m) - (length n).

Opaque minus_rev_e.

Notation lt_e := minus_rev_e.

Lemma lt_correct v1 v2:
  bs2bool (sem lt_e [v1] [v2]) = true ->
  length v1 < length v2.

Lemma unary_tl l :
  unary l = true ->
  unary (tl l) = true.

Lemma lt_correct_conv_bool v1 v2:
  unary v2 = true ->
  length v1 < length v2 ->
  bs2bool (sem lt_e [v1] [v2]) = true.

Lemma lt_correct_conv v1 v2 :
  unary v1 = true ->
  unary v2 = true ->
  bs2bool (sem lt_e [v1] [v2]) = false ->
  length v2 <= length v1.

Lemma lt_correct_conv_nil v1 v2 :
  unary v1 = true ->
  unary v2 = true ->
  sem lt_e [v1] [v2] = nil ->
  length v2 <= length v1.

Definition le_e : BC :=
  comp 1 1 lt_e (proj 1 0 0 :: nil) (comp 1 1 succ_e nil (proj 1 1 1 :: nil) :: nil).

Lemma le_correct : forall v1 v2,
  bs2bool (sem le_e [v1] [v2]) = true ->
  length v1 <= length v2.

Lemma le_correct_conv v1 v2 :
  unary v1 = true ->
  unary v2 = true ->
  bs2bool (sem le_e [v1] [v2]) = false ->
  length v2 < length v1.

Lemma le_correct_conv_nil v1 v2 :
  unary v1 = true ->
  unary v2 = true ->
  sem le_e [v1] [v2] = nil ->
  S (length v2) <= length v1.
 
Opaque le_e.

Notation minus_e := (inv_e (from_11_to_20 minus_rev_e)) (only parsing).

Lemma minus_correct :
  forall m n, length (sem minus_e [n; m] nil) = (length n) - (length m).

Definition max_e : BC :=
  comp 2 0 (rec (proj 2 0 0) (proj 3 1 2) (proj 3 1 2) )
  [ P'_e; proj 2 0 0; proj 2 0 1] nil.

Lemma max_correct_l v1 v2 : length v2 <= length v1 ->
  sem max_e [v1; v2] nil = v1.

Lemma max_correct_r v1 v2 : length v1 < length v2 ->
  sem max_e [v1; v2] nil = v2.

Fixpoint div' (q y:nat)(x:nat) : nat :=
  match q with
  | 0 => 0
  | S q' => if leb (q' * y) x then q' else div' q' y x
  end.

Lemma div'_coq_correct : forall (q x y : nat) (Hy:y>0),
  (q > proj1_sig (quotient y Hy x) -> 
    div' q y x = proj1_sig (quotient y Hy x)) /\
  (q <= proj1_sig (quotient y Hy x) -> 
    div' q y x = Peano.pred q).

Definition div (x y:nat) : nat := div' (S x) y x.

Lemma div_coq_correct : forall (x y:nat) (Hy:y>0),
  div x y = proj1_sig (quotient y Hy x).

Definition div'_e : BC :=
  rec (zero_e 1 1)
  (comp 2 2 cond nil
    [comp 2 2 le_e [comp 2 0 mult_e [proj 2 0 0; proj 2 0 1] nil]
      [proj 2 2 3]; proj 2 2 2; proj 2 2 0; proj 2 2 2])
  (comp 2 2 cond nil
    [comp 2 2 le_e [comp 2 0 mult_e [proj 2 0 0; proj 2 0 1] nil]
      [proj 2 2 3]; proj 2 2 2; proj 2 2 0; proj 2 2 2]).

Lemma hd_cons l a l' :
  l = a :: l' ->
  bs2bool l = a.

Ltac elim_if :=  match goal with 
   | |- context [if ?c then ?c1 else ?c2]  => case_eq c
 end.

Lemma div'_correct v1 v2 v3 :
  unary v1 = true -> unary v2 = true -> unary v3 = true ->
  length (sem div'_e [v1;v2] [v3]) = 
  div' (length v1) (length v2) (length v3).

Opaque div'_e.

Definition div_e : BC :=
  comp 2 0 div'_e [comp 2 0 succ_e nil [proj 2 0 0]; proj 2 0 1] [proj 2 0 0].

Lemma div_correct v1 v2 :
  unary v1 = true -> unary v2 = true -> 
  length (sem div_e [v1; v2] nil) = div (length v1) (length v2).

Fixpoint scalar_e (a:nat)(n:nat)(e:BC) : BC :=
  match a with
  | 0 => zero_e n 0
  | S a' => comp n 0 plus_e [e] [scalar_e a' n e]
  end.

Lemma scalar_arities :
  forall a n e,
  arities e = ok_arities n 0 ->
  arities (scalar_e a n e) = ok_arities n 0.

Opaque plus_e.

Lemma scalar_correct :
  forall a n nl e,
  length (sem (scalar_e a n e) nl nil) = a * length (sem e nl nil).

Fixpoint multl_e (n:nat)(el:list BC) : BC :=
  match el with
    | nil => one_e n 0
    | e' :: el' => comp n 0 mult_e [e'; multl_e n el'] nil
  end.

Lemma multl_arities :
  forall el n,
  andl (fun e => arities e = ok_arities n 0) el ->
  arities (multl_e n el) = ok_arities n 0.

Opaque mult_e.

Lemma multl_correct :
  forall n nl el,
  length (sem (multl_e n el) nl nil) = multl (map (fun e => length (sem e nl nil)) el). *)

Definition BC_dummies (n n0 s s0 : nat)(e : BC) : BC :=
  comp (n+n0) (s+s0) e (map (proj (n+n0) 0)      (seq n        n0))
                       (map (proj (n+n0) (s+s0)) (seq (n+n0+s) s0)).

Lemma dummies_inf : forall e n n0 s s0,
  arities e = ok_arities n0 s0 ->
  arities (BC_dummies n n0 s s0 e) = ok_arities (n + n0) (s + s0).
Proof.
destruct n0 as [ | n0]; simpl.

intros s s0 H.
rewrite H; simpl.
rewrite map_length, seq_length, <- beq_nat_refl; simpl.
case_eq (forallb
      (fun se : BC => aeq (arities se) (ok_arities (n + 0) (s + s0)))
      (map (proj (n + 0) (s + s0)) (seq (n + 0 + s) s0))); intro H0; trivial.
rewrite forallb_forall_conv in H0.
destruct H0 as (e' & H1 & H2).
rewrite in_map_iff in H1.
destruct H1 as (i & H3 & H4).
rewrite in_seq_iff in H4.
rewrite <- H3 in H2.
contradict H2; simpl.
case_eq (n + 0 + (s + s0)).
omega.
intros n0 H5.
case_eq (leb i n0); intro H6; simpl.
do 2 rewrite <- beq_nat_refl.
simpl; congruence.
rewrite leb_iff_conv in H6; omega.

intros s [ | s0] H; simpl; rewrite H; simpl.
rewrite map_length, seq_length, <- beq_nat_refl.
simpl.
case_eq (n + S n0 + 0).
intro H0.
contradict H0.
omega.
intros n1 H0.
case_eq (leb n n1); intro H1.
simpl.
rewrite <- beq_nat_refl.
simpl.
rewrite leb_iff in H1.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities (n + S n0) 0))
      (map (proj (n + S n0) 0) (seq (S n) n0))); intro H2.
trivial.
rewrite forallb_forall_conv in H2.
destruct H2 as (e' & H3 & H4).
rewrite in_map_iff in H3.
destruct H3 as (i & H5 & H6).
rewrite in_seq_iff in H6.
rewrite <- H5 in H4.
contradict H4.
simpl.
case_eq (n + S n0 + 0).
congruence.
intros n2 H7.
case_eq (leb i n2).
intros _.
simpl.
rewrite <- beq_nat_refl.
simpl; congruence.
intro H8.
rewrite leb_iff_conv in H8.
omega.
rewrite leb_iff_conv in H1.
contradict H1.
omega.
do 2 rewrite map_length, seq_length, <- beq_nat_refl.
simpl.
case_eq (n + S n0 + 0).
intro H0.
contradict H0.
omega.
intros n1 H0.
case_eq (leb n n1).
intro H1.
rewrite leb_iff in H1.
case_eq (aeq (ok_arities (n + S n0) 0) (ok_arities (n + S n0) 0)).
intro H2.
case_eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities (n + S n0) 0))
      (map (proj (n + S n0) 0) (seq (S n) n0))).
intro H3.
simpl.
case_eq (n + S n0 + (s + S s0)).
intro H4.
contradict H4.
omega.
intros n2 H4.
case_eq (leb (n + S n0 + s) n2).
intro H5.
case_eq (aeq (ok_arities (n + S n0) (s + S s0)) (ok_arities (n + S n0) (s + S s0))).
intro H6.
case_eq (forallb
      (fun se : BC => aeq (arities se) (ok_arities (n + S n0) (s + S s0)))
      (map (proj (n + S n0) (s + S s0)) (seq (S (n + S n0 + s)) s0))).
intro H7.
simpl.
trivial.
intro H7.
rewrite forallb_forall_conv in H7.
destruct H7 as (e'  & H8 & H9).
rewrite in_map_iff in H8.
destruct H8 as (i & H10 & H11).
rewrite in_seq_iff in H11.
rewrite <- H10 in H9.
contradict H9.
simpl.
case_eq (n + S n0 + (s + S s0)).
congruence.
intros n3 H12.
case_eq (leb i n3).
congruence.
intro H13.
rewrite leb_iff_conv in H13.
omega.
intro H6.
contradict H6.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl; congruence.
intro H5.
rewrite leb_iff_conv in H5.
contradict H5.
omega.
intro H3.
rewrite forallb_forall_conv in H3.
destruct H3 as (e' & H4 & H5).
rewrite in_map_iff in H4.
destruct H4 as (i & H6 & H7).
rewrite in_seq_iff in H7.
rewrite <- H6 in H5.
contradict H5.
simpl.
case_eq (n + S n0 + 0).
congruence.
intros n2 H8.
case_eq (leb i n2).
congruence.
intro H9.
rewrite leb_iff_conv in H9.
omega.
intro H2.
contradict H2.
simpl.
rewrite <- beq_nat_refl.
simpl; congruence.
intro H1.
rewrite leb_iff_conv in H1.
contradict H1.
omega.
Qed.

Lemma BC_dummies_correct : forall e n n0 s s0 nl sl,
  length nl = n + n0 ->
  length sl = s + s0 ->
  sem (BC_dummies n n0 s s0 e) nl sl = sem e (skipn n nl) (skipn s sl).
Proof.
intros e n n0 s s0 nl sl Hnl Hsl.
unfold BC_dummies.
simpl.
do 2 rewrite map_map.
f_equal.

erewrite <- map_nth_seq.
instantiate (1:=n0).
induction (seq n n0).
simpl; trivial.
do 2 rewrite map_cons.
rewrite IHl.
f_equal.
simpl.
case_eq (n+n0).
intro H0.
rewrite H0 in Hnl.
apply length_nil in Hnl.
subst nl.
simpl.
replace (a-0) with a by omega.
case a.
trivial.
trivial.
intros n1 H0.
case_eq (leb a n1); intro H1.
trivial.
rewrite leb_iff_conv in H1.
case_eq (a - S n1).
intro H2.
rewrite nth_overflow.
trivial.
omega.
intros n2 H2.
rewrite nth_overflow.
trivial.
omega.
omega.

transitivity (skipn (n+n0+s) (nl++sl)).
erewrite <- map_nth_seq.
instantiate (1:=s0).
induction (seq (n + n0 + s) s0).
simpl; trivial.
do 2 rewrite map_cons.
rewrite IHl.
f_equal.
simpl.
case_eq (n+n0).
intro H0.
rewrite H0 in Hnl.
apply length_nil in Hnl.
subst nl.
simpl.
replace (a-0) with a by omega.
trivial.
intros n1 H0.
case_eq (leb a n1); intro H1.
rewrite leb_iff in H1.
rewrite app_nth1.
trivial.
omega.
rewrite leb_iff_conv in H1.
rewrite app_nth2.
congruence.
omega.
rewrite app_length.
omega.
rewrite plus_comm, skipn_plus, <- Hnl, skipn_app.
trivial.
Qed.

Opaque BC_dummies.

Fixpoint rec_simulation sl (e : Cobham) : pol :=
  match e with
    | Zero => pcst sl 0
    | Proj i n => pcst sl 0
    | Succ b => pcst sl 0
    | Smash => (pplus (pplus (pproj sl 1) (pproj sl 1))
        (pplus (pcst sl 16) (pplus (pproj sl 0) (pcst sl 2)))) 
    | Rec g h0 h1 j => 
       let bf := poly_Cobham j in
        let ph := pplus (rec_simulation (S sl) h0)  (rec_simulation (S sl) h1) in
          let pg := rec_simulation (sl - 1) g in
            pplus (pcomp ph (pproj sl 0 :: bf :: (map (pproj sl) (seq 1 (sl - 1)))))
            (pplus (pshift pg) (pplus (pproj sl 0) (pcst sl 2)))
    | Comp n h l => 
      pplus (pcst sl 0)
      (pplus (pcomp (rec_simulation (length l) h)
        (map poly_Cobham l)) (pplusl (map (rec_simulation sl) l)))
  end.

  Lemma rec_simulation_arity : forall (e : Cobham) n,
    arity e = ok_arity n ->
    parity (rec_simulation n e) = n.
  Proof.
    apply Cobham_ind_inf; simpl; intros; trivial.
    erewrite parity_poly_Cobham; eauto.
    rewrite <- minus_n_O, H3.
    repeat rewrite Nat.max_idempotent.
    rewrite max_r; trivial.
    rewrite max_l; trivial.
    rewrite max_l; trivial.
    apply maxl_map; intros.
    apply in_map_iff in H7.
    destruct H7 as (? & ? & ?); subst x.
    rewrite parity_pproj; trivial.
    rewrite max_l; trivial.
    apply Nat.max_lub.
    apply maxl_map.
    intros.
    apply in_map_iff in H3.
    destruct H3 as (? & ? & ?); subst.
    eapply parity_poly_Cobham; auto.
    rewrite parity_pplusl.
    apply maxl_map.
    intros.
    apply in_map_iff in H3.
    destruct H3 as (? & ? & ?); subst.
    auto.
Qed.

Lemma pWF_rec_simulation : forall (e : Cobham) n,
  arity e = ok_arity n ->
  pWF (rec_simulation n e).
Proof.
  apply Cobham_ind_inf; simpl; intros; trivial; try pWF.
  simpl in H7; decompose [or] H7; subst; pWF.
  eapply pWF_poly_Cobham; eauto.
  apply in_map_iff in H9.
  destruct H9 as (? & ? & ?); subst; pWF.
  apply in_seq_iff in H9; omega.
  rewrite <- minus_n_O; trivial.
  apply in_map_iff in H3.
  destruct H3 as (? & ? & ?); subst; pWF.
  eapply pWF_poly_Cobham; simpl; auto.
  apply in_map_iff in H3.
  destruct H3 as (? & ? & ?); subst.
  eapply H2; trivial.
Qed.

Section PredicativeNotationRecursion.

  Variable sl : nat. 

  Hypothesis sl_not_zero : sl <> 0.

  Definition comp2n h ln ls := comp 2 0 h ln ls.
  Definition comp2s h ln ls := comp 2 sl h ln ls.
  Definition comp2Ss h ln ls := comp 2 (S sl) h ln ls.
  Definition comp2SSs h ln ls := comp 2 (S (S sl)) h ln ls.
  Definition proj2n i := proj 2 0 i.
  Definition proj2s i := proj 2 sl i.
  Definition proj2Ss i := proj 2 (S sl) i.
  Definition proj2SSs i := proj 2 (S (S sl)) i.

 Definition f'_cond := comp2Ss Y_e
   [comp2n (succ true) nil [proj2n 0];
     proj2n 1]
   [proj2Ss 3].

 Lemma f'_cond_inf : arities f'_cond = ok_arities 2 (S sl).
 Proof.
  simpl.
  destruct sl.
  elim sl_not_zero; trivial.
  simpl; repeat (rewrite <- beq_nat_refl; simpl).
  trivial.
 Qed.

 Opaque f'_cond.

  Variables g : BC.

  Hypothesis g_inf  : arities g = ok_arities 1 (sl - 1).

 Definition f'_nil := BC_dummies 1 1 2 (sl - 1) g.

 Lemma f'_nil_inf : arities f'_nil = ok_arities 2 (S sl).
 Proof.
   unfold f'_nil.
   erewrite dummies_inf; eauto.
   simpl.
   destruct sl.
   elim sl_not_zero; trivial.
   simpl.
   f_equal.
   omega.
 Qed.

 Opaque f'_nil.

 Variable h0 h1 : BC.

  Hypothesis h0_inf : arities h0 = ok_arities 1 (S sl).
  Hypothesis h1_inf : arities h1 = ok_arities 1 (S sl).  
 
 Definition f'_then :=
   comp2Ss h1 [proj2n 1]
     ([comp2Ss Y_e [proj2n 0; proj2n 1] [proj2Ss 3];
       proj2Ss 2 ] ++ (map (proj 2 (S sl)) (seq 4 (sl - 1)))).

Transparent P_e Y_e.

 Lemma f'_then_inf : arities f'_then = ok_arities 2 (S sl).
 Proof.
   simpl.
   rewrite h1_inf; simpl.
   rewrite map_length, seq_length.
   destruct sl.
   elim sl_not_zero; trivial.
   simpl.
   rewrite <- minus_n_O.
   repeat (rewrite <- beq_nat_refl; simpl).
   case_eq ( forallb (fun se : BC => aeq (arities se) (ok_arities 2 (S (S n))))
          (map (proj 2 (S (S n))) (seq 4 n))); intros; simpl; trivial.
   elimtype False.
   apply eq_true_false_abs in H; trivial.
   eapply forallb_forall; intros.
    apply in_map_iff in H0.
    destruct H0 as (? & ? & ?).
    subst.
    simpl.
    apply in_seq_iff in H1.
    rewrite leb_correct; simpl.
    rewrite <- beq_nat_refl; trivial.
    omega.
  Qed.

  Opaque f'_then.    

  Definition f'_else :=
   comp2Ss h0 [proj2n 1]
     ([comp2Ss Y_e [proj2n 0; proj2n 1] [proj2Ss 3];
       proj2Ss 2 ] ++ (map (proj 2 (S sl)) (seq 4 (sl - 1)))).
 
 Lemma f'_else_inf : arities f'_else = ok_arities 2 (S sl).
 Proof.
   simpl.
   rewrite h0_inf; simpl.
   rewrite map_length, seq_length.
   destruct sl.
   elim sl_not_zero; trivial.
   simpl.
   rewrite <- minus_n_O.
   repeat (rewrite <- beq_nat_refl; simpl).
   case_eq ( forallb (fun se : BC => aeq (arities se) (ok_arities 2 (S (S n))))
          (map (proj 2 (S (S n))) (seq 4 n))); intros; simpl; trivial.
   elimtype False.
   apply eq_true_false_abs in H; trivial.
   eapply forallb_forall; intros.
    apply in_map_iff in H0.
    destruct H0 as (? & ? & ?).
    subst.
    simpl.
    apply in_seq_iff in H1.
    rewrite leb_correct; simpl.
    rewrite <- beq_nat_refl; trivial.
    omega.
  Qed.

  Opaque f'_else.    

  Definition f' : BC :=
    rec2 (BC_dummies 0 1 1 (sl - 1) g)
    (comp2Ss cond nil [f'_cond; f'_nil; f'_then; f'_else] ).

  Lemma cond_simpl: forall (n s : nat) (fn fc ft ff : BC) (l1 l2 : list bs),
    sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 =
    match sem fc l1 l2 with
      | nil => sem fn l1 l2
      | true :: _ => sem ft l1 l2
      | false :: _ => sem ff l1 l2
    end.
  Proof.
    intros; simpl; auto.
  Qed.

  Lemma f'_inf : arities f' = ok_arities 2 sl.
  Proof.
    simpl.
    rewrite dummies_inf; trivial.
    rewrite f'_cond_inf.
    rewrite f'_nil_inf.
    rewrite f'_then_inf.
    rewrite f'_else_inf.
    simpl.
    repeat (rewrite <- beq_nat_refl; simpl).
    destruct sl.
    elim sl_not_zero; trivial.
    simpl.
    rewrite <- minus_n_O.
    rewrite <- beq_nat_refl; simpl.
    trivial.
  Qed.

  Definition f : BC :=
    comp 1 sl f' [proj 1 0 0; proj 1 0 0]
    (map (proj 1 sl) (seq 1 sl)).

  Opaque f'.

  Lemma f_inf : arities f = ok_arities 1 sl.
  Proof.
    simpl.
    rewrite f'_inf.
    rewrite map_length, seq_length.
    repeat (rewrite <- beq_nat_refl; simpl).
    case_eq (forallb (fun se : BC => aeq (arities se) (ok_arities 1 sl))
         (map (proj 1 sl) (seq 1 sl))); intros.
    trivial.
    elimtype False.
    apply eq_true_false_abs in H; trivial.
    eapply forallb_forall; intros.
    apply in_map_iff in H0.
    destruct H0 as (? & ? & ?).
    subst.
    simpl.
    apply in_seq_iff in H1.
    rewrite leb_correct; simpl.
    rewrite <- beq_nat_refl; trivial.
    omega.
  Qed.

  Variables g' h0' h1' cj : Cobham.

  Hypothesis g'_inf : arity g' = ok_arity (sl - 1).
  Hypothesis h0'_inf : arity h0' = ok_arity (S sl).
  Hypothesis h1'_inf : arity h1' = ok_arity (S sl).
  Hypothesis cj'_inf : arity cj = ok_arity sl.

  Hypothesis g_correct  : forall w xl, 
    length xl = (sl - 1) -> 
    peval (rec_simulation (sl - 1) g') (map (@length _) xl) <= length w ->
    Sem g' xl  = sem g [w] xl.

  Hypothesis h0_correct : forall w xl, 
    length xl = (S sl) -> 
    peval (rec_simulation (S sl) h0') (map (@length _) xl) <= length w ->
    Sem h0' xl = sem h0 [w] xl.

  Hypothesis h1_correct : forall w xl, 
    length xl = (S sl) -> 
    peval (rec_simulation (S sl) h1') (map (@length _) xl) <= length w ->
    Sem h1' xl = sem h1 [w] xl.

  Transparent f'_then f'_else f'_cond f' .

 Lemma f_correct : forall (w y u : bs) xl,
   peval
   (pcomp (pplus (rec_simulation (S sl) h0') (rec_simulation (S sl) h1'))
     (pproj (length (y :: xl)) 0
       :: poly_Cobham (Rec g' h0' h1' cj)
       :: map (pproj (length (y :: xl)))
       (seq 1 (length (y :: xl) - 1))))
   (map (@length _) (y :: xl)) +
   (peval (pshift (rec_simulation (sl - 1) g')) (map (@length _) (y :: xl)) +
     (nth 0 (map (@length _) (y :: xl)) 0 + 2)) <= length w ->
   rec_bounded (Rec g' h0' h1' cj) ->
   S (length xl) = sl ->
   length u <= length w ->
   length w - length u <= length y ->
   Sem (Rec g' h0' h1' cj) (Y u w y :: xl) =
   sem f' [u; w] (y :: xl).
Proof.
 simpl length in *; intros.
 simpl in H.

 assert (S (length y) < length w).
 eapply le_trans; [ | apply H].
 simpl; omega.

 assert (1 < length w - length y) by omega.

 induction u as [ | j z]; intros; simpl length in *.

 rewrite Y_skipn, skipn_nil; simpl; try omega.

 apply le_lt_eq_dec in H3; destruct H3.

 unfold f' in *.

 rewrite rec2_simpl,  <- rec2_sem_rec, <- IHz, I_Y_property; try omega; clear IHz.
 simpl Sem; unfold f'_then, f'_else, comp2Ss.
 rewrite cond_simpl_notnil.
 Opaque Y_e.
 simpl.
 rewrite Y_correct.
 rewrite I_Y_property; try omega.
 rewrite <- H1.

 simpl.
 rewrite <- minus_n_O.

 case_eq (nth (length w - S (length z)) y false); intros.

 rewrite Y_correct; simpl; trivial; try omega.
 erewrite h1_correct; trivial.
 do 3 f_equal.
 rewrite map_map.
 clear H H1; induction xl; simpl; trivial.
 f_equal.
 rewrite IHxl at 1; simpl.
 rewrite <- seq_shift with (start := 4), map_map.
 apply map_ext2; intros.
 apply in_seq_iff in H.
 rewrite leb_correct_conv;[ simpl | omega].
 do 4 (destruct a0; simpl;[ elimtype False; omega | ]); trivial.
 rewrite <- H1; simpl; trivial.
 eapply le_trans; [ | apply H ].
 rewrite pcomp_correct, pplus_correct.
 apply le_trans with (peval (rec_simulation (S sl) h1')
     (map (fun p : pol => peval p (length y :: map (@length _) xl))
        (pproj (S (length xl)) 0
         :: poly_Cobham cj
            :: map (pproj (S (length xl))) (seq 1 (length xl - 0)))));[ | omega ].
 apply peval_monotonic; simpl; intros.
 destruct i.
 rewrite pproj_correct; simpl.
 eapply le_trans.
 apply Y_le; omega.
 rewrite Y_refl; trivial.
 destruct i.
 rewrite <- map_cons.
 apply le_trans with (peval (poly_Cobham (Rec g' h0' h1' cj)) (map (@length _) ((Y z w y) :: xl))).
 eapply le_trans.
 2: apply poly_Cobham_correct.
 simpl; trivial.
 simpl in *; trivial.

 apply peval_monotonic; intros; simpl.
 destruct i; trivial.
 eapply le_trans.
 apply Y_le; omega.
 rewrite Y_refl; trivial.
 rewrite map_map.
 match goal with [ |- ?a <= ?b] => assert (a = b) end.
 f_equal.
 rewrite <- minus_n_O.
 clear H H1.
 induction xl; simpl; trivial.
 rewrite pproj_correct; simpl.
 f_equal.
 rewrite IHxl, <- seq_shift with (start := 1), map_map.
 apply map_ext2; intros.
 apply in_seq_iff in H.
 repeat rewrite pproj_correct; simpl.
 destruct a0; simpl.
 elimtype False; omega.
 rewrite IHxl at 1; trivial.
 rewrite H6; trivial.

 rewrite Y_correct; simpl; trivial; try omega.
 erewrite h0_correct; trivial.
 do 3 f_equal.
 rewrite map_map.
 clear H H1; induction xl; simpl; trivial.
 f_equal.
 rewrite IHxl at 1; simpl.
 rewrite <- seq_shift with (start := 4), map_map.
 apply map_ext2; intros.
 apply in_seq_iff in H.
 rewrite leb_correct_conv;[ simpl | omega].
 do 4 (destruct a0; simpl;[ elimtype False; omega | ]); trivial.
 rewrite <- H1; simpl; trivial.
 eapply le_trans; [ | apply H ].
 rewrite pcomp_correct, pplus_correct.
 apply le_trans with (peval (rec_simulation (S sl) h0')
     (map (fun p : pol => peval p (length y :: map (@length _) xl))
        (pproj (S (length xl)) 0
         :: poly_Cobham cj
            :: map (pproj (S (length xl))) (seq 1 (length xl - 0)))));[ | omega ].
 apply peval_monotonic; simpl; intros.
 destruct i.
 rewrite pproj_correct; simpl.
 eapply le_trans.
 apply Y_le; omega.
 rewrite Y_refl; trivial.
 destruct i.
 rewrite <- map_cons.
 apply le_trans with (peval (poly_Cobham (Rec g' h0' h1' cj)) (map (@length _) ((Y z w y) :: xl))).
 eapply le_trans.
 2: apply poly_Cobham_correct.
 simpl; trivial.
 simpl in *; trivial.

 apply peval_monotonic; intros; simpl.
 destruct i; trivial.
 eapply le_trans.
 apply Y_le; omega.
 rewrite Y_refl; trivial.
 rewrite map_map.
 match goal with [ |- ?a <= ?b] => assert (a = b) end.
 f_equal.
 rewrite <- minus_n_O.
 clear H H1.
 induction xl; simpl; trivial.
 rewrite pproj_correct; simpl.
 f_equal.
 rewrite IHxl, <- seq_shift with (start := 1), map_map.
 apply map_ext2; intros.
 apply in_seq_iff in H.
 repeat rewrite pproj_correct; simpl.
 destruct a0; simpl.
 elimtype False; omega.
 rewrite IHxl at 1; trivial.
 rewrite H6; trivial.

 unfold f'_cond.
 Opaque lt_e P'_e.
 simpl.
 rewrite Y_correct.
 unfold Y, P.
 rewrite skipn_length.
 case_eq (skipn (length w - length (true :: z)) y); intros.
 apply skipn_nil_length in H3.
 apply lt_not_le in l.
 simpl in *; omega.
 case b; intro; discriminate.

 rewrite Y_skipn.
 rewrite skipn_nil.
 2: simpl in *; omega.
 simpl Sem.
 unfold f'.

 rewrite rec2_simpl.
 unfold comp2Ss.
 rewrite cond_simpl.
 unfold f'_cond.
 Opaque Y_e f'_then f'_else.
 simpl.
 rewrite Y_correct.
 unfold Y, P; rewrite skipn_length; trivial.
 simpl.
 rewrite skipn_nil.
 2:  simpl in *; omega.
 Transparent f'_nil.
 unfold f'_nil.
 rewrite BC_dummies_correct; simpl; auto.
 eapply g_correct; simpl ; trivial.
 rewrite <- H1; omega.
 eapply le_trans; [ | apply H].
 rewrite pshift_correct; simpl; omega.
 rewrite <- H1; omega.  
Qed.

Opaque f'.

Lemma f'_eq_f w xl :
  length xl = sl ->
  sem f' [w;w] xl = sem f [w] xl.
Proof.
  simpl; intros.
  f_equal.
  rewrite map_map.
  rewrite <- H; clear H.
  induction xl; simpl; trivial.
  f_equal.
  rewrite IHxl at 1.
  rewrite <- seq_shift with (start := 1).
  rewrite map_map.
  apply map_ext2.
  intros.
  apply in_seq_iff in H.
  rewrite leb_correct_conv;[ | omega].
  simpl.
  destruct a0; simpl.
  elimtype False; omega.
  f_equal; omega.
Qed.

End PredicativeNotationRecursion.

Definition f_smash' :=
  f 2 (proj 1 1 1)
  (comp 1 3 (succ false) nil [proj 1 3 2])
  (comp 1 3 (succ false) nil [proj 1 3 2]).

Lemma f_smash_inf : arities f_smash' = ok_arities 1 2.
Proof.
  unfold f_smash'.
  erewrite f_inf; trivial.
  omega.
Qed.

Opaque f_smash'.

  Fixpoint Cobham_to_BC' sl (e : Cobham) : BC :=
    match e with
      | Zero => comp 1 sl zero nil nil
      | Proj n i => proj 1 sl (S i)
      | Succ b => comp 1 sl (succ b) nil [proj 1 sl 1]
      | Smash => f sl (one_e 1 1) 
        (BC_dummies 0 1 1 2 (comp 1 2 f_smash' [proj 1 0 0] [proj 1 2 2; proj 1 2 1]))
        (BC_dummies 0 1 1 2 (comp 1 2 f_smash' [proj 1 0 0] [proj 1 2 2; proj 1 2 1]))
      | Rec g' h0' h1' _ => 
        let g  := Cobham_to_BC' (sl - 1) g' in
          let h0 := Cobham_to_BC' (S sl) h0' in
            let h1 := Cobham_to_BC' (S sl) h1' in
              f sl g h0 h1
      | Comp n h l => comp 1 sl (Cobham_to_BC' (length l) h) 
        [proj 1 0 0] (map (Cobham_to_BC' sl) l)
    end.

  Opaque f.

  Lemma Cobham_to_BC'_inf : forall e sl,
    arity e = ok_arity sl ->     
    arities (Cobham_to_BC' sl e) = ok_arities 1 sl.
  Proof.
    apply Cobham_ind_inf; simpl; intros; trivial.
    destruct n.
    contradict H; omega.
    case_eq (leb i n); intros; trivial.
    rewrite leb_iff_conv in H0.
    contradict H; omega.
    erewrite f_inf; trivial; eauto.
    simpl; rewrite <- minus_n_O; trivial.

    rewrite H1.
    rewrite map_length.
    repeat (rewrite <- beq_nat_refl; simpl).
    case_eq (forallb (fun se : BC => aeq (arities se) 
      (ok_arities 1 n)) (map (Cobham_to_BC' n) rl)); intros; trivial.
    elimtype False.
    apply eq_true_false_abs in H3; trivial.
    eapply forallb_forall; intros.
    apply in_map_iff in H4.
    destruct H4 as (? & ? & ?); subst.
    rewrite H2; simpl; trivial.
    rewrite <- beq_nat_refl; auto.
  Qed.

Opaque f'.

Definition smash'_e : BC :=
  rec2 (proj 0 1 0) (comp 1 2 (succ false) nil [proj 1 2 1]).

Lemma smash'_correct x y :
  sem smash'_e [x] [y] = smash' x y.
Proof.
 induction x; simpl in *; intros; trivial.
 case a; rewrite IHx; clear IHx; trivial.
Qed.

Opaque smash'_e.

Definition smash_e : BC :=
  rec2 (comp 1 0 (succ true) nil [zero_e 1 0])
       (comp 2 1 smash'_e [proj 2 0 1] [proj 2 1 2]).

Lemma smash_correct x y :
  sem smash_e [x;y] nil = smash_bs x y.
Proof.
 induction x; simpl in *; intros; trivial.
 case a; rewrite IHx; clear IHx; apply smash'_correct.
Qed.

Transparent f.

Opaque Mult_e.
Opaque Plus_e.
Opaque App_e.
 
Lemma rec_simulation_correct : forall (e : Cobham) n,
  arity e = ok_arity n ->
  forall xl w,
  rec_bounded e ->
  length xl = n ->
  peval (rec_simulation n e) (map (@length _) xl) <= length w -> 
  Sem e xl = sem (Cobham_to_BC' n e) [w] xl.
Proof.
  refine (Cobham_ind_inf 
    (fun n e => forall (xl : list bs) (w : bs),
      rec_bounded e ->
      length xl = n ->
      peval (rec_simulation n e) (map (@length _) xl) <= length w ->
      Sem e xl = sem (Cobham_to_BC' n e) [w] xl) _ _ _ _ _ _ ); simpl; intros; trivial.

  rewrite <- minus_n_O; trivial.
  rewrite hd_nth_0; trivial.

 rewrite <- f_correct with
   (g' := Comp 1 (Succ true) nil)
   (h0' := Comp 3 (Rec (Proj 1 0) (Comp 3 (Succ false) [Proj 3 1]) (Comp 3 (Succ false) [Proj 3 1])
     App_e) [Proj 3 2; Proj 3 1] )
   (h1' := Comp 3 (Rec (Proj 1 0) (Comp 3 (Succ false) [Proj 3 1]) (Comp 3 (Succ false) [Proj 3 1])
     App_e) [Proj 3 2; Proj 3 1] )
   (cj := Comp 2 (Succ true) [Mult_e]); try discriminate.
 simpl.
 rewrite Y_refl, hd_nth_0, hd_nth_1.

 induction (nth 0 xl nil); simpl; trivial.

 case a.
 rewrite <- IHl; clear IHl.
 generalize (smash_bs l (nth 1 xl nil)).
 induction (nth 1 xl nil); simpl; trivial; intros.
 rewrite <- IHl0.
 case a0; trivial.
 rewrite <- IHl; clear IHl.
 generalize (smash_bs l (nth 1 xl nil)).
 induction (nth 1 xl nil); simpl; trivial; intros.
 rewrite <- IHl0.
 case a0; trivial.

 intros; simpl; trivial.
 intros; simpl; trivial.
 destruct xl0 as [ | y xl0].
 simpl in H1; discriminate.
 destruct xl0 as [ | x0 xl0].
 simpl in H1; discriminate.
 destruct xl0 as [ | x1 xl0].
 simpl in H1; discriminate.
 simpl.
 rewrite BC_dummies_correct; simpl; trivial.
 Transparent f_smash'.
 unfold f_smash'.
 rewrite <- f'_eq_f; try discriminate.
 Opaque App_e.
 rewrite <- f_correct with 
 (g' := Proj 1 0)
 (h0' := Comp 3 (Succ false) [Proj 3 1])
 (h1' := Comp 3 (Succ false) [Proj 3 1])
 (cj := App_e); try discriminate.
 simpl; eauto; try omega.
 rewrite Y_refl; simpl; trivial.
 intros; simpl; trivial.
 intros; simpl; trivial.
 intros; simpl; trivial.
 simpl in *.
 repeat rewrite pplus_correct in H3.
 repeat rewrite pcst_correct in H3.
 repeat rewrite pcomp_correct in H3.
 repeat rewrite pplus_correct in H3.
 repeat rewrite pshift_correct in H3.
 repeat rewrite pcst_correct in H3.
 repeat rewrite pproj_correct in H3.
 repeat rewrite pcomp_correct in H3.
 repeat rewrite pplus_correct in H3.
 repeat rewrite pcst_correct in H3.
 repeat rewrite pcomp_correct in H3.
 repeat rewrite pcst_correct in H3.
 simpl in H3.
 repeat rewrite pproj_correct in H3.
 simpl in H3.
 omega.
 repeat (split; trivial).
 simpl; intros. 
 intros.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 rewrite nth_S_tl.
 rewrite length_smash'.
 simpl; omega.
 case a; simpl.
 rewrite length_smash'.
 simpl.
 omega.
 rewrite length_smash'.
 simpl.
 omega.
 intros.
 destruct l; simpl.
 omega.
 induction l; simpl.
 rewrite App_correct.
 simpl.
 rewrite hd_nth_0; trivial.
 case a; simpl.
 rewrite App_correct in *.
 simpl in *.
 omega.
 rewrite App_correct in *.
 simpl in *.
 omega.
 simpl; trivial.
 trivial.
 omega.
 simpl; trivial.
 intros; simpl; trivial.
 destruct xl0 as [ | y xl0].
 simpl in H1; discriminate.
 destruct xl0 as [ | x0 xl0].
 simpl in H1; discriminate.
 destruct xl0 as [ | x1 xl0].
 simpl in H1; discriminate.
 simpl.
 rewrite BC_dummies_correct; simpl; trivial.
 Transparent f_smash'.
 unfold f_smash'.
 Opaque App_e.
 rewrite <- f_correct with 
 (g' := Proj 1 0)
 (h0' := Comp 3 (Succ false) [Proj 3 1])
 (h1' := Comp 3 (Succ false) [Proj 3 1])
 (cj := App_e); try discriminate.
 simpl; eauto; try omega.
 rewrite Y_refl; simpl; trivial.
 intros; simpl; trivial.
 intros; simpl; trivial.
 intros; simpl; trivial.
 simpl in *.
 repeat rewrite pplus_correct in H3.
 repeat rewrite pcst_correct in H3.
 repeat rewrite pcomp_correct in H3.
 repeat rewrite pplus_correct in H3.
 repeat rewrite pshift_correct in H3.
 repeat rewrite pcst_correct in H3.
 repeat rewrite pproj_correct in H3.
 repeat rewrite pcomp_correct in H3.
 repeat rewrite pplus_correct in H3.
 repeat rewrite pcst_correct in H3.
 repeat rewrite pcomp_correct in H3.
 repeat rewrite pcst_correct in H3.
 simpl in H3.
 repeat rewrite pproj_correct in H3.
 simpl in H3.
 omega.
 repeat (split; trivial).
 simpl; intros. 
 intros.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 rewrite nth_S_tl.
 rewrite length_smash'.
 simpl; omega.
 case a; simpl.
 rewrite length_smash'.
 simpl.
 omega.
 rewrite length_smash'.
 simpl.
 omega.
 intros.
 destruct l; simpl.
 omega.
 induction l; simpl.
 rewrite App_correct.
 simpl.
 rewrite hd_nth_0; trivial.
 case a; simpl.
 rewrite App_correct in *.
 simpl in *.
 omega.
 rewrite App_correct in *.
 simpl in *.
 omega.
 simpl; trivial.
 trivial.
 omega.

 repeat rewrite pcomp_correct.
 repeat rewrite pplus_correct.
 simpl peval.
 repeat rewrite pplus_correct.
 repeat rewrite pcst_correct.
 repeat rewrite pcomp_correct.
 repeat rewrite pplus_correct.
 repeat rewrite pcomp_correct.
 repeat rewrite pplus_correct.
 repeat rewrite pcst_correct.
 repeat rewrite pcomp_correct.
 repeat rewrite pcst_correct.
 repeat rewrite pshift_correct.
 repeat rewrite pcst_correct.
 repeat rewrite pproj_correct.
 simpl.
 repeat rewrite pproj_correct.
 simpl.
 eapply le_trans with (2 := H1).
 repeat rewrite pplus_correct.
 repeat rewrite pcomp_correct.
 repeat rewrite pplus_correct.
 repeat rewrite pshift_correct.
 repeat rewrite pcst_correct.
 repeat rewrite pproj_correct.
 simpl.
 repeat rewrite pproj_correct.
 erewrite map_nth2.
 instantiate (1:=nil).
 erewrite map_nth2.
 instantiate (1:=nil).
 omega.
 simpl; trivial.
 simpl; trivial.

 repeat (split; trivial).

 intros; simpl.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 rewrite length_smash'.
 rewrite nth_S_tl.
 simpl; omega.
 case a; simpl.
 rewrite length_smash'.
 simpl.
 omega.
 rewrite length_smash'.
 simpl.
 omega.
 
 intros.
 rewrite App_correct.
 simpl.
 rewrite app_length.
 rewrite length_smash'.
 rewrite hd_nth_0; trivial.
 rewrite length_smash.
 simpl.
 rewrite hd_nth_1.
 destruct l; simpl.
 omega.
 destruct l0; simpl.
 omega.
 rewrite plus_n_Sm.
 rewrite plus_comm.
 apply plus_le_compat_l.
 apply le_trans with ( S (S (length l * 1))).
 omega.
 apply le_n_S.
 apply le_n_S.
 apply mult_le_compat_l.
 omega.
 
 simpl.
 intros.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 rewrite length_smash'.
 rewrite length_smash'.
 simpl; omega.
 case a; simpl.
 rewrite length_smash'.
 rewrite length_smash'.
 simpl.
 rewrite nth_S_tl.
 rewrite App_correct.
 simpl.
 rewrite app_length.
 rewrite length_smash'.
 rewrite length_smash.
 simpl.
 eapply le_trans.
 apply plus_le_compat_r.
 apply IHl0.
 rewrite length_smash'.
 rewrite length_smash'.
 rewrite length_smash.
 simpl.
 omega.
 rewrite length_smash'.
 rewrite length_smash'.
 simpl.
 rewrite nth_S_tl.
 rewrite App_correct.
 simpl.
 rewrite app_length.
 rewrite length_smash'.
 rewrite length_smash.
 simpl.
 eapply le_trans.
 apply plus_le_compat_r.
 apply IHl0.
 rewrite length_smash'.
 rewrite length_smash'.
 rewrite length_smash.
 simpl.
 omega.

 intros.
 simpl.
 rewrite length_smash'.
 rewrite length_smash.
 simpl.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 rewrite nth_S_tl.
 omega.
 case a; simpl.
 omega.
 omega.

 intros.
 simpl.
 rewrite App_correct.
 rewrite app_length.
 induction (hd nil l); simpl.
 rewrite hd_nth_0; trivial.
 case a; simpl; omega.

 intros.
 simpl.
 rewrite length_smash'.
 rewrite length_smash.
 simpl.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 rewrite nth_S_tl.
 omega.
 case a; simpl.
 omega.
 omega.

 intros.
 simpl.
 rewrite App_correct.
 rewrite app_length.
 rewrite hd_nth_1.
 induction (hd nil l); simpl.
 rewrite nth_S_tl.
 trivial.
 case a; simpl; omega.

 intros.
 simpl.
 rewrite Mult_correct.
 rewrite hd_nth_1.
 rewrite hd_nth_0.
 induction (nth 0 l nil); simpl.
 trivial.
 case a.
 rewrite nth_S_tl.
 rewrite plus_n_Sm.
 eapply le_trans.
 2: apply plus_le_compat_l.
 2: apply IHl0.
 clear IHl0.
 induction (nth 1 l nil); simpl; trivial.
 case a0; simpl; omega.
 rewrite nth_S_tl.
 rewrite plus_n_Sm.
 eapply le_trans.
 2: apply plus_le_compat_l.
 2: apply IHl0.
 clear IHl0.
 induction (nth 1 l nil); simpl; trivial.
 case a0; simpl; omega.
 simpl; trivial.
 omega.
 omega.

 destruct xl as [ | y xl].
 simpl in H9; discriminate.
 simpl hd; simpl tl.

 repeat rewrite pplus_correct in H9; 
   repeat rewrite pcst_correct in H9; 
     repeat rewrite pproj_correct in H9.

 assert (S (length y) < length w).
 eapply le_trans; [ | eauto].
 simpl; omega.

 assert (1 < length w - length y) by omega.
 simpl length.

 pattern y at 1.
 rewrite <- Y_refl with (x := w) (y := y).

 assert ( forall u, length u <= length w ->
   length (Y u w y) <= length (Y w w y)).
 intros.
 repeat rewrite Y_skipn.
 repeat rewrite skipn_length.
 omega.

 intros; rewrite <- minus_n_O in *.

 simpl.
 erewrite <- f_correct; simpl; eauto; try omega.
 f_equal.
 rewrite map_map; simpl.
 rewrite <- seq_shift.
 rewrite map_map.
 simpl.
 rewrite <- seq_shift.
 rewrite map_map.
 simpl.
 rewrite map_nth_seq.
 simpl.
 trivial.
 simpl in H8; omega.
 
 intros; rewrite <- minus_n_O in *.
 apply H3; auto; tauto.
 intros; apply H4; auto; tauto.
 intros; apply H5; auto; tauto.

 simpl in *.

 eapply le_trans.
 2: apply H9.

 repeat rewrite pcomp_correct.
 repeat rewrite pplus_correct.

 injection H8; clear H8; intros; subst.
 apply plus_le_compat.
 apply plus_le_compat.

 apply peval_monotonic.
 intros; simpl.
 destruct i.
 repeat rewrite pproj_correct.
 rewrite map_map; simpl; trivial.
 destruct i.
 apply peval_monotonic.
 intros; simpl.
 destruct i.
 trivial.
 rewrite map_map; simpl; trivial.
 rewrite map_map; simpl; trivial.
 rewrite <- seq_shift.
 rewrite map_map.
 simpl.
 rewrite <- seq_shift.
 rewrite map_map.
 simpl.
 match goal with [ |- ?a <= ?b] => assert (a = b) end. 
 f_equal.
 clear.
 induction xl; simpl; trivial.
 f_equal.
 rewrite <- IHxl.
 rewrite <- seq_shift.
 rewrite map_map.
 trivial.
 rewrite H8; auto.
 match goal with [ |- ?a <= ?b] => assert (a = b) end. 
 f_equal.
 rewrite map_map; simpl.
 repeat rewrite <- seq_shift.
 repeat rewrite map_map; simpl.
 repeat rewrite <- minus_n_O.
 rewrite map_nth_seq.
 simpl.
 apply map_ext.
 intros.
 repeat rewrite pproj_correct.
 simpl.
 clear.
 revert a.
 induction xl; simpl; intros.
 trivial.
 destruct a0; trivial.
 rewrite <- seq_shift.
 rewrite map_map.
 apply IHxl.
 omega.
 rewrite H8; auto.
 apply peval_monotonic.
 intros; simpl.
 destruct i.
 repeat rewrite pproj_correct.
 rewrite map_map; simpl; trivial.
 destruct i.
 apply peval_monotonic.
 intros; simpl.
 destruct i.
 trivial.
 rewrite map_map; simpl; trivial.
 rewrite map_map; simpl; trivial.
 rewrite <- seq_shift.
 rewrite map_map.
 simpl.
 rewrite <- seq_shift.
 rewrite map_map.
 simpl.
 match goal with [ |- ?a <= ?b] => assert (a = b) end. 
 f_equal.
 clear.
 induction xl; simpl.
 trivial.
 f_equal.
 rewrite <- IHxl.
 rewrite <- seq_shift.
 rewrite map_map.
 trivial.
 rewrite H8; auto.
 match goal with [ |- ?a <= ?b] => assert (a = b) end. 
 f_equal.
 rewrite map_map; simpl.
 repeat rewrite <- seq_shift.
 repeat rewrite map_map; simpl.
 repeat rewrite <- minus_n_O.
 rewrite map_nth_seq.
 simpl.
 apply map_ext.
 intros.
 repeat rewrite pproj_correct.
 simpl.
 clear.
 revert a.
 induction xl; simpl; intros.
 trivial.
 destruct a0; trivial.
 rewrite <- seq_shift.
 rewrite map_map.
 apply IHxl.
 omega.
 rewrite H8; auto.
 rewrite pshift_correct.
 rewrite pshift_correct.
 apply plus_le_compat_r.
 rewrite <- minus_n_O.
 apply peval_monotonic.
 intros; simpl.
 match goal with [ |- ?a <= ?b] => assert (a = b) end. 
 f_equal.
 rewrite map_map; simpl.
 repeat rewrite <- seq_shift.
 repeat rewrite map_map; simpl.
 clear.
 induction xl; simpl; intros.
 trivial.
 f_equal.
 rewrite <- seq_shift.
 rewrite map_map.
 trivial.
 rewrite <- H8.
 trivial.
 rewrite map_map.
 rewrite map_length.
 rewrite seq_length.
 trivial.

 destruct H3.
 erewrite H1; eauto.
 f_equal.
 rewrite map_map.
 apply map_ext2.
 intros.
 eapply H2; trivial.
 rewrite <- forall_andl in H6; auto.
 eapply le_trans with (2 := H5); simpl.
 repeat rewrite pplus_correct.
 repeat rewrite pcomp_correct.
 subst.
 eapply le_trans with (peval 
   (pplusl (map (rec_simulation (length xl)) rl)) (map (@length _) xl));[ | omega].
 rewrite pplusl_correct. 
 rewrite map_map.
 revert H7.
 clear.
 induction rl; simpl in *; intros.
 elim H7.
 destruct H7.
 subst.
 omega.
 eapply le_trans.
 apply IHrl; trivial.
 omega.
 rewrite map_length; trivial.
 eapply le_trans with (2 := H5); simpl.
 do 2 rewrite pplus_correct.
 rewrite pcomp_correct.
 rewrite pcst_correct.
 simpl.
 rewrite map_map.
 rewrite map_map.
 apply le_plus_trans.
 apply peval_monotonic.
 intros.
 rewrite map_nth2 with (d := Zero).
 rewrite map_nth2 with (d := Zero).
 apply poly_Cobham_correct.
 revert H6; clear.
 revert i.
 induction rl; simpl; intros.
 case i; simpl; trivial.
 case i; simpl; intros.
 tauto.
 apply IHrl; tauto.
 simpl.
 trivial.
 trivial.
Qed.

Definition concat := smash'_e.

Definition poly_BC_pow (ar:nat)(xn:pow) : BC :=
  multl_e ar (repeat (snd xn) (proj ar 0 (fst xn))).

Lemma poly_BC_pow_arities :
  forall ar xn, pWF_pow ar xn -> arities (poly_BC_pow ar xn) = ok_arities ar 0.
Proof.
unfold poly_BC_pow.
intros ar [x n] Hwf.
simpl.
induction n as [ | n IH].
trivial.
apply multl_arities.
rewrite <- forall_andl.
intros e H.
apply in_repeat_eq in H.
subst e.
rewrite proj_arities.
trivial.
auto with arith.
Qed.

Lemma poly_BC_pow_correct :
  forall ar xn nl, pWF_pow ar xn ->
  length (sem (poly_BC_pow ar xn) nl nil) = peval_pow xn (map (@length _) nl).
Proof.
unfold poly_BC_pow, peval_pow, pWF_pow.
intros ar [x n] nl Hwf.
simpl.
rewrite multl_correct.
rewrite map_repeat.
rewrite multl_repeat_power.
f_equal.
simpl.
destruct ar as [ | ar].
omega.
case_eq (leb x ar); intro H0.
apply leb_complete in H0.
erewrite map_nth2.
trivial.
trivial.
apply leb_complete_conv in H0.
simpl in Hwf.
omega.
Qed.

Opaque poly_BC_pow.

Definition poly_BC_mon (ar:nat)(m:mon) : BC :=
  multl_e ar (nat2BC ar 0 (fst m) :: map (poly_BC_pow ar) (snd m)).

Lemma poly_BC_mon_arities :
  forall ar xn, pWF_mon ar xn -> arities (poly_BC_mon ar xn) = ok_arities ar 0.
Proof.
unfold poly_BC_mon, pWF_mon.
intros ar [x n] Hwf.
rewrite multl_arities.
trivial.
simpl in *.
split.
apply nat2BC_arities.
rewrite <- forall_andl in *.
intros e He.
rewrite in_map_iff in He.
destruct He as [xn [H1 H2] ].
subst e.
apply poly_BC_pow_arities.
apply Hwf.
exact H2.
Qed.

Lemma poly_BC_mon_correct :
    forall ar m nl, pWF_mon ar m ->
  length (sem (poly_BC_mon ar m) nl nil) = peval_mon m (map (@length _) nl).
Proof.
unfold poly_BC_mon, peval_mon, pWF_mon.
intros ar [ar' xnl] nl H.
rewrite multl_correct.
simpl in *.
induction xnl as [ | xn xnl IH ]; simpl.
rewrite nat2BC_correct.
trivial.
simpl in H.
rewrite nat2BC_correct, poly_BC_pow_correct.
rewrite nat2BC_correct in IH.
rewrite (mult_comm (peval_pow _ _)).
rewrite mult_assoc.
rewrite IH.
ring.
tauto.
tauto.
Qed.

Definition poly_BC (p : pol) : BC :=
  plusl_e (fst p) (map (poly_BC_mon (fst p)) (snd p)).

Lemma poly_BC_arities :
  forall p, pWF p -> arities (poly_BC p) = ok_arities (parity p) 0.
Proof.
unfold poly_BC, pWF, pWF'.
intros [ar ml] Hwf.
simpl in *.
rewrite plusl_arities.
trivial.
rewrite <- forall_andl in Hwf.
rewrite <- forall_andl.
intros e He.
rewrite in_map_iff in He.
destruct He as [m [H1 H2] ].
subst e.
apply poly_BC_mon_arities.
apply Hwf.
exact H2.
Qed.

Lemma poly_BC_correct :
  forall p nl, pWF p ->
    length (sem (poly_BC p) nl nil) = peval p (map (@length _) nl).
Proof.
  unfold poly_BC, pWF, pWF'.
  intros [ar ml] nl Hwf.
  induction ml as [ | m ml IH].
  trivial.
  generalize plusl_correct.
  intros.
  rewrite H in *.
  rewrite map_map in *.
  simpl fst in *.
  simpl snd in *.
  simpl in Hwf.
  rewrite map_cons, plusl_cons, IH.
  generalize  poly_BC_mon_correct.
  intros; rewrite H0.
  trivial.
  tauto.
  tauto.
Qed.

Definition Cobham_to_BC'' n e :=
  comp n n (Cobham_to_BC' n e) [poly_BC (rec_simulation n e)] 
  (map (proj n n) (seq n n)).

Lemma Cobham_to_BC''_inf : forall e n,
  arity e = ok_arity n ->
  arities (Cobham_to_BC'' n e) = ok_arities n n.
Proof.
 intros; simpl.
 erewrite Cobham_to_BC'_inf; simpl; trivial.
 rewrite map_length.
 rewrite seq_length.
 rewrite <- beq_nat_refl; simpl.
 erewrite poly_BC_arities.
 rewrite rec_simulation_arity; trivial.
 simpl.
 rewrite <- beq_nat_refl; simpl.
 case_eq ( forallb (fun se : BC => aeq (arities se) (ok_arities n n))
         (map (proj n n) (seq n n)) ); intros.
 trivial.
 elimtype False; apply eq_true_false_abs with (2 := H0).
 rewrite forallb_forall; intros.
 apply in_map_iff in H1.
 destruct H1 as (? & ? & ?).
 subst.
 simpl; trivial.
 apply in_seq_iff in H2.
 case_eq (n + n); intros.
 elimtype False; omega.
 rewrite leb_correct; simpl.
 rewrite <- beq_nat_refl; simpl; trivial.
 omega.
 apply pWF_rec_simulation; trivial.
Qed.

Lemma seq_map : forall A len start (f : nat -> A),
  map (fun x => f x) (seq start len) = map (fun x => f (x + start)) (seq 0 len).
Proof.
 induction len; simpl; intros.
 trivial.
 f_equal.
 repeat rewrite <- seq_shift.
 repeat rewrite map_map.
 apply IHlen.
Qed.

Lemma Cobham_to_BC''_correct : forall e xl n,
  rec_bounded e ->
  arity e = ok_arity n ->
  length xl = n ->
  Sem e xl = sem (Cobham_to_BC'' n e) xl xl.
Proof.
 intros; unfold Cobham_to_BC''; simpl.
 erewrite rec_simulation_correct; eauto.
 f_equal.
 rewrite map_map.
 rewrite seq_map.
 assert (forall k, n <= k -> sem (proj n n k) xl xl =  nth (k - n) xl nil) .
 simpl.
 intros.
 destruct n.
 trivial.
 rewrite leb_correct_conv.
 trivial.
 omega.
 transitivity ( map (fun x : nat => nth x xl nil) (seq 0 n) ).
 rewrite map_nth_seq.
 simpl; trivial.
 omega.
 apply map_ext2; intros.
 rewrite H2.
 f_equal.
 omega.
 apply in_seq_iff in H3; omega.
 rewrite poly_BC_correct; trivial.
 apply pWF_rec_simulation; trivial.
Qed.

Opaque Cobham_to_BC''.

Definition Cobham_to_BC n e :=
  comp n 0 (Cobham_to_BC'' n e) 
  (map (proj n 0) (seq 0 n))
  (map (proj n 0) (seq 0 n)).

Lemma Cobham_to_BC_inf : forall e n,
  arity e = ok_arity n ->
  arities (Cobham_to_BC n e) = ok_arities n 0.
Proof.
 intros; simpl.
 erewrite Cobham_to_BC''_inf; simpl; trivial.
 rewrite map_length.
 rewrite seq_length.
 rewrite <- beq_nat_refl; simpl.
 case_eq (  forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0))
         (map (proj n 0) (seq 0 n)) ); intros; simpl; trivial.
 elimtype False; apply eq_true_false_abs with (2 := H0).
 rewrite forallb_forall; intros.
 apply in_map_iff in H1.
 destruct H1 as (? & ? & ?).
 subst.
 simpl; trivial.
 apply in_seq_iff in H2.
 case_eq (n + 0); intros.
 elimtype False; omega.
 rewrite leb_correct; simpl.
 rewrite <- beq_nat_refl; simpl; trivial.
 omega.
Qed.

Lemma Cobham_to_BC_correct : forall e xl n,
  rec_bounded e ->
  arity e = ok_arity n ->
  length xl = n ->
  Sem e xl = sem (Cobham_to_BC n e) xl nil.
Proof.
 intros; unfold Cobham_to_BC; simpl.
 subst.
 etransitivity.
 apply Cobham_to_BC''_correct; try trivial; try rewrite Nat.add_0_r; trivial.
 try rewrite Nat.add_0_r;f_equal.
 rewrite map_map.
 transitivity ( map (fun x : nat => nth x xl nil) (seq 0 (length xl)) ).
 rewrite map_nth_seq.
 simpl; trivial.
 omega.
 apply map_ext2; intros.
 simpl.
 destruct (length xl).
 simpl in H1; elim H1.
 rewrite leb_correct; trivial.
 apply in_seq_iff in H1; omega.
 rewrite map_map.
 transitivity ( map (fun x : nat => nth x xl nil) (seq 0 (length xl)) ).
 rewrite map_nth_seq.
 simpl; trivial.
 omega.
 apply map_ext2; intros.
 simpl.
 destruct (length xl).
 simpl in H1; elim H1.
 rewrite leb_correct; trivial.
 apply in_seq_iff in H1; omega.
Qed.
