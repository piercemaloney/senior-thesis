
Require Import Bool Arith Even List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.BC.
(* BellantoniCook.Lib:
Require Import Bool Arith Div2 List Permutation.
Require Export Omega.

Global Obligation Tactic := idtac.

Notation "[ x ; .. ; y ]" := (cons x .. (cons y nil) .. ).

Lemma length_nil : forall A (l : list A),
  length l = 0 -> l = nil.

Lemma length_tail A l : length (@tail A l) = length l - 1.

Lemma hd_nth_0 A (l : list A) d :
  hd d l = nth 0 l d.

Lemma hd_nth_1 A (l : list A) d :
  hd d (tl l) = nth 1 l d.

Lemma In_hd (A : Type)(d:A)(l : list A)(n : nat)(H : length l = S n) :
  In (hd d l) l.

Lemma map_hd : forall A B (f:A->B) d l, f (hd d l) = hd (f d) (map f l).

Lemma map_tl : forall A B (f:A->B) l, map f (tl l) = tl (map f l).

Lemma map_eq_hd :
  forall A B (f:A->B) d l1 l2,
  map f l1 = map f l2 -> f (hd d l1) = f (hd d l2).

Lemma firstn_nil {A} n : firstn n (@nil A) = nil.

Lemma skipn_nil : forall {A} n (x : list A),
  length x <= n -> skipn n x = nil.

Lemma nth_firstn : forall A i j (l:list A) d,
  i < j -> nth i (firstn j l) d = nth i l d.

Lemma nth_skipn A i j (l:list A) d : 
  nth i (skipn j l) d = nth (j+i) l d.

Lemma length_skipn : forall A n (y : list A),
  length (skipn n y) = length y - n.

Lemma skipn_length : forall {A} n (l:list A), 
  length (skipn n l) = length l - n.

Lemma cons_skipn :
  forall A d i (l:list A),
  i < length l ->
  nth i l d :: skipn (S i) l = skipn i l.

Lemma skipn_plus :
  forall A j i (l:list A), skipn (i+j) l = skipn i (skipn j l).

Lemma skipn_hd : forall {A} n y (d:A), 
  n < length y -> 
  skipn n y = nth n y d :: skipn (S n) y.

Lemma firstn_app {A} (l l' : list A) : 
  firstn (length l) (l ++ l') = l.

Lemma skipn_app {A} (l l' : list A) : 
  skipn (length l) (l ++ l') = l'.

Lemma map_cons : forall A B (f:A->B) a l, map f (a::l) = f a :: map f l.

Lemma map_firstn : forall A B (f:A->B) n l,
  map f (firstn n l) = firstn n (map f l).

Lemma map_skipn : forall A B (f:A->B) n l,
  map f (skipn n l) = skipn n (map f l).

Lemma map_nth_seq : forall A (l:list A) len n d,
  length l = len + n ->
  map (fun x : nat => nth x l d) (seq n len) = (skipn n l).

Lemma skipn_nil_length : forall A n (l : list A),
  skipn n l = nil -> length l <= n.

Lemma firstn_map_nth :
  forall A d n m (l:list A),
  m+n <= length l ->
  firstn n (skipn m l) = map (fun i => nth i l d) (seq m n).

Lemma firstn_seq n start len :
  firstn n (seq start len) = seq start (min n len).

Lemma skipn_seq n start len :
  skipn n (seq start len) = seq (start+n) (len-n).

Lemma in_seq_iff : forall x len start,
  In x (seq start len) <-> start <= x < start+len.

Lemma nth_map_cst :
  forall {A B} (l:list A) n (d:B), nth n (map (fun _ => d) l) d = d.

Lemma nth_S_tl A (l : list A) d n :
  nth n (tl l) d = nth (S n) l d.

Lemma map_ext2 : forall {A B} (f g : A -> B) l,
  (forall a : A, In a l -> f a = g a) -> map f l = map g l.

Lemma map_nth2
  (A B : Type) (f : A -> B) (l : list A) b d n :
  (f d) = b ->
  nth n (map f l) b = f (nth n l d).

Lemma length_plus_ex {A} n1 n2 (l : list A):
  length l = n1 + n2 ->
  exists l1, exists l2,
    length l1 = n1 /\ length l2 = n2 /\ l = l1 ++ l2.

Lemma tl_app : forall A (l1 l2 : list A),
  l1 <> nil ->
  tl (l1 ++ l2) = tl l1 ++ l2.

Lemma map_seq_nth : forall A B (l : list A) (g : A -> B) d, 
 map (fun n => g (nth n l d)) (seq 0 (length l)) = map g l.

Lemma map_seq_shift : forall A m (f : nat -> A) n,
n <> 0 ->
map f (seq 0 m) = map (fun x => f (x - n)%nat) (seq n m).

Lemma map_seq_nth_safe : forall A B (l : list A) (g : A -> B) d m, 
 map (fun n => g (nth (n - m) l d)) (seq m (length l)) = map g l.

Lemma seq_app : forall x y z,
  seq x y ++ seq (x + y) z = seq x (y + z).

Definition andl {A} (P:A->Prop)(l:list A) : Prop :=
  fold_right (fun a res => P a /\ res) True l.

Lemma forall_andl A (P:A->Prop) l :
  (forall x, In x l -> P x) <-> andl P l.

Fixpoint fun_power {A:Type}(n:nat)(f:A->A)(x:A) : A :=
  match n with
  | 0 => x
  | S n' => f (fun_power n' f x)
  end.

Lemma fun_power_minus_S : forall A (f:A->A) x m n,
  m < n -> f (fun_power (n - S m) f x) = fun_power (n - m) f x.

Definition mod2 (n : nat) : nat :=
  n - 2 * div2 n.

Fixpoint power (m n:nat) : nat :=
 match n with
 | 0 => 1
 | S n' => m * power m n'
 end.

Lemma power_le_l : forall a b n, a <= b -> power a n <= power b n.

Definition plusl (l:list nat) : nat :=
  fold_right plus 0 l.

Lemma plusl_cons : forall x l, plusl (x :: l) = x + plusl l.

Lemma plusl_app l1 l2 :
  plusl (l1++l2) = plusl l1 + plusl l2.

Lemma plusl_compat : forall A (l : list A) f g,
  (forall x, In x l -> f x <= g x) ->
  plusl (map f l) <= plusl (map g l).

Definition multl (l:list nat) : nat :=
  fold_right mult 1 l.

Lemma multl_app l1 l2 :
  multl (l1++l2) = multl l1 * multl l2.

Lemma multl_plus_distr_l n l :
  n * plusl l = plusl (map (fun m => n * m) l).

Fixpoint maxl l := 
  match l with
    | nil => 0
    | a :: l' => max a (maxl l')
  end.

Lemma in_le_maxl x l : In x l -> x <= maxl l.

Lemma maxl_map A l (f : A -> nat) n :
  (forall x, In x l -> f x = n) ->
  maxl (map f l) <= n.

Lemma maxl_le l e :
  maxl l <= e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le l e :
  maxl l = e ->
  (forall x, In x l -> x <= e).

Lemma maxl_eq_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] = e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_le3 e1 e2 e3 e :
  maxl [e1; e2; e3] <= e ->
  e1 <= e /\ e2 <= e /\ e3 <= e.

Lemma maxl_bound e1 e2 e3 e :
  e1 <= e -> e2 <= e -> e3 <= e ->
  maxl [e1; e2; e3] <= e.

Lemma maxl_bound_in l e :
  (forall e', In e' l -> e' <= e) -> maxl l <= e.

Lemma maxl_cons l n : n <= maxl (n :: l).

Lemma le_maxl_cons l m n :
 n <= maxl l -> n <= maxl (m :: l).

Lemma nth_maxl_bound : forall A (l : list A) (m:A->nat) d i,
  m d = 0 -> m (nth i l d) <= maxl (map m l).

Lemma length_hd_app A (l1 l2 : list (list A)) :
  length (hd nil l1) <= length (hd nil (l1 ++ l2)).

Lemma length_nth_app A (l1 l2 : list (list A)) i :
  length (nth i l1 nil) <= length (nth i (l1 ++ l2) nil).

Lemma maxl_nth l :
  exists i, maxl l = nth i l 0.

Lemma maxl_map_0 A l (f : A -> nat)  :
  (forall x, In x l -> (f x) = 0) ->
  maxl (map f l) = 0.

Lemma maxl_le_plusl : forall l, maxl l <= plusl l.

Lemma forallb_forall_conv :
  forall A f (l:list A), forallb f l = false <-> (exists x, In x l /\ f x = false).

Lemma forallb_nth : forall A (l : list A) (p : A -> bool) n d,
  p d = true ->
  forallb p l = true ->
  p (nth n l d) = true.

Lemma forallb_hd : forall A (l : list A) (p : A -> bool) d,
  forallb p l = true ->
  p d = true ->
  p (hd d l) = true.

Lemma forallb_tl : forall A (l : list A) (p : A -> bool),
  forallb p l = true ->
  forallb p (tail l) = true.

Lemma forallb_map : forall A B (l : list A) (p : B -> bool) (f : A -> B),
  (forall x, In x l -> p (f x) = true) ->
  forallb p (map f l) = true.

Fixpoint repeat {A:Type}(n:nat)(x:A) : list A :=
  match n with
  | 0 => nil
  | S n' => x :: repeat n' x
  end.

Lemma firstn_repeat_le :
  forall A (x:A) m n,
  m <= n ->
  firstn m (repeat n x) = repeat m x.

Lemma in_repeat_eq : forall A (x y:A) n, In x (repeat n y) -> x=y.

Lemma map_repeat : forall A B (f:A->B) n x, map f (repeat n x) = repeat n (f x).

Lemma multl_repeat_power : forall n x, multl (repeat n x) = power x n.

Lemma length_repeat : forall A n (x:A), length (repeat n x) = n.

Lemma nth_repeat :
  forall A n (x:A) d i, i < n ->
  nth i (repeat n x) d = x.

Definition move_forward {A}(i j:nat)(l:list A)(d:A) : list A :=
  firstn i l ++ firstn j (skipn (S i) l) ++ (nth i l d :: skipn (S (i+j)) l).

Lemma move_forward_map A B d1 d2 i j (f:A->B) l :
  f d1 = d2 ->
  move_forward i j (map f l) d2 = map f (move_forward i j l d1).

Lemma length_move_forward :
  forall A i j (l:list A) d, i+j < length l -> length (move_forward i j l d) = length l.

Lemma in_move_forward_iff :
  forall A x i j d (l:list A), i < length l -> (In x (move_forward i j l d) <-> In x l).

Lemma firstn_simpl : forall A B (l : list A) (l2 : list B),
 length l2 = length l ->
 firstn (length l2) l = l.

Lemma firstn_app2 : forall (A : Type) (l l' : list A) n, 
 length l = n -> firstn n (l ++ l') = l .

Lemma firstn_firstn : forall A n (l : list A),
 firstn n (firstn n l) = firstn n l.

Lemma In_firstn : forall A n a (l : list A),
  In a (firstn n l) -> In a l. *)
(* BellantoniCook.Bitstring:
Require Import Bool Arith Div2 List.
Require Import BellantoniCook.Lib.

Notation bs := (list bool).

Definition unary (v : bs) := forallb id v.

Definition bs2bool (v:bs) : bool := hd false v.

Definition bool2bs (b:bool) : bs :=
  if b then true::nil else nil.

Lemma bs_nat2bool_true : forall v,
  bs2bool v = true -> length v <> 0.

Lemma bs_nat2bool_true_conv : forall v,
  unary v = true ->
  length v <> 0 -> bs2bool v = true.

Lemma bs_nat2bool_false v :
  unary v = true ->
  bs2bool v = false -> length v = 0.

Lemma bs_nat2bool_false_conv v :
  length v = 0 ->
  bs2bool v = false.

Fixpoint bs2nat (v:bs) : nat :=
  match v with
  | nil => 0
  | false :: v' => 2 * bs2nat v'
  | true  :: v' => S (2 * bs2nat v')
  end.

Fixpoint succ_bs (v : bs) : bs :=
  match v with
    | nil => [true]
    | false :: v' => true :: v'
    | true :: v' => false :: succ_bs v'
  end.

Lemma succ_bs_correct v : bs2nat (succ_bs v) = bs2nat v + 1.

Fixpoint nat2bs (n:nat) : bs :=
  match n with
  | 0 => nil
  | S n' => succ_bs (nat2bs n')
  end.

Lemma bs2nat_nil :
  bs2nat nil = 0.

Lemma bs2nat_false v :
  bs2nat (false :: v) = 2 * bs2nat v.

Lemma bs2nat_true v :
  bs2nat (true :: v) = 1 + 2 * bs2nat v.

Lemma bs2nat_tl : forall v, bs2nat (tl v) = div2 (bs2nat v).

Lemma bs2nat_nat2bs : forall n, bs2nat (nat2bs n) = n. *)
(* BellantoniCook.BC:
Require Import Bool Arith List.
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.MultiPoly.

Inductive BC : Set :=
| zero : BC
| proj : nat -> nat -> nat -> BC
| succ : bool -> BC
| pred : BC
| cond : BC
| rec : BC -> BC -> BC -> BC
| comp : nat -> nat -> BC -> list BC -> list BC -> BC.  

Lemma BC_ind2' :
  forall P : BC -> Prop,
  forall Q : list BC -> Prop,
  Q nil ->
  (forall e l, P e -> Q l -> Q (e :: l)) ->
  P zero ->
  (forall n s i, P (proj n s i)) ->
  (forall b, P (succ b)) ->
  P pred ->
  P cond ->
  (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) ->
  (forall n s h rl tl, P h -> Q rl -> Q tl ->
    P (comp n s h rl tl)) ->
  forall e, P e.

Lemma BC_ind2 :
  forall P : BC -> Prop,
  P zero ->
  (forall n s i, P (proj n s i)) ->
  (forall b, P (succ b)) ->
  P pred ->
  P cond ->
  (forall g h0 h1, P g -> P h0 -> P h1 -> P (rec g h0 h1)) ->
  (forall n s h rl tl, P h -> (forall r, In r rl -> P r) -> 
    (forall s, In s tl -> P s) ->
    P (comp n s h rl tl)) ->
  forall e, P e.

Inductive Arities : Set :=
| error_rec : Arities -> Arities -> Arities -> Arities
| error_comp : Arities -> list Arities -> list Arities -> Arities
| error_proj : nat -> nat -> nat -> Arities
| ok_arities : nat -> nat -> Arities.

Definition aeq (x y:Arities) : bool :=
  match x, y with
  | ok_arities xn xs, ok_arities yn ys => beq_nat xn yn && beq_nat xs ys
  | _, _ => false
  end.

Lemma aeq_eq (x y : Arities) :
  aeq x y = true -> x = y.

Lemma aeq_eq_conv xn yn xs ys :
  aeq (ok_arities xn xs) (ok_arities yn ys) = false -> xn <> yn \/ xs <> ys.

Fixpoint arities (e:BC) : Arities :=
  match e with
  | zero => ok_arities 0 0
  | proj n s i => 
    if leb (S i) (n + s) then ok_arities n s
      else error_proj n s i
  | succ _ => ok_arities 0 1
  | pred => ok_arities 0 1
  | cond => ok_arities 0 4
  | rec g h0 h1 =>
      match arities g, arities h0, arities h1 
        with | ok_arities gn gs, ok_arities h0n h0s, ok_arities h1n h1s =>
          if beq_nat (S gn) h0n && beq_nat h0n h1n &&
            beq_nat (S gs) h0s && beq_nat h0s h1s 
          then ok_arities h0n gs 
            else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s)
        | e1, e2, e3 => error_rec e1 e2 e3
      end
    | comp n s h nl sl =>
      match arities h, map arities nl, map arities sl with
      | ok_arities hn hs, anl, asl =>
        if beq_nat hn (length nl) && beq_nat hs (length sl) && 
          forallb (fun ne => aeq (arities ne) (ok_arities n 0)) nl &&
          forallb (fun se => aeq (arities se) (ok_arities n s)) sl
          then ok_arities n s
          else error_comp (ok_arities hn hs) anl asl 
      | e , anl, asl => error_comp e anl asl
      end
  end.

Definition arities2 e :=
  match arities e with
    | ok_arities n s => (n, s)
    | _ => (0, 0)
  end.

Lemma proj_arities : forall n s i, 
  i < n+s -> 
  arities (proj n s i) = ok_arities n s.

Lemma comp_arities : forall n s e nel sel,
  arities e = ok_arities (length nel) (length sel) ->
  andl (fun ne => arities ne = ok_arities n 0) nel ->
  andl (fun se => arities se = ok_arities n s) sel ->
  arities (comp n s e nel sel) = ok_arities n s.

Lemma arities_nth :
  forall l i e n s,
  (forall e, In e l -> arities e = ok_arities n s) ->
  arities e = ok_arities n s ->
  arities (nth i l e) = ok_arities n s.

Lemma BC_ind_inf' :
  forall (P : nat -> nat -> BC -> Prop),
  forall Q : nat -> nat -> list BC -> Prop,
  (forall n s, Q n s nil) ->
  (forall e n s l, P n s e -> Q n s l -> Q n s (e :: l)) ->
  P 0 0 zero ->
  (forall n s i, i < n + s ->  P n s (proj n s i)) ->
  (forall b, P 0 1 (succ b)) ->
  P 0 1 pred ->
  P 0 4 cond ->
  (forall n s g h0 h1, 
    arities g = ok_arities n s ->
    arities h0 = ok_arities (S n) (S s) ->
    arities h1 = ok_arities (S n) (S s) ->
    P n s g -> 
    P (S n) (S s) h0 -> 
    P (S n) (S s) h1 -> 
    P (S n) s (rec g h0 h1)) ->
  (forall n s h rl tl, 
    arities h = ok_arities (length rl) (length tl) ->
    (forall e, In e rl -> arities e = ok_arities n 0) ->
    (forall e, In e tl -> arities e = ok_arities n s) ->
    P (length rl) (length tl) h -> 
    Q n 0 rl -> 
    Q n s tl ->
    P n s (comp n s h rl tl)) ->
  forall e n s , arities e = ok_arities n s -> P n s e.

Lemma BC_ind_inf :
  forall (P : nat -> nat -> BC -> Prop),
  P 0 0 zero ->
  (forall n s i, i < n + s ->  P n s (proj n s i)) ->
  (forall b, P 0 1 (succ b)) ->
  P 0 1 pred ->
  P 0 4 cond ->
  (forall n s g h0 h1, 
    arities g = ok_arities n s ->
    arities h0 = ok_arities (S n) (S s) ->
    arities h1 = ok_arities (S n) (S s) ->
    P n s g -> 
    P (S n) (S s) h0 -> 
    P (S n) (S s) h1 -> 
    P (S n) s (rec g h0 h1)) ->
  (forall n s h rl tl, 
    arities h = ok_arities (length rl) (length tl) ->
    (forall e, In e rl -> arities e = ok_arities n 0) ->
    (forall e, In e tl -> arities e = ok_arities n s) ->
    P (length rl) (length tl) h -> 
    (forall r, In r rl -> P n 0 r) ->
    (forall r, In r tl -> P n s r) ->
    P n s (comp n s h rl tl)) ->
  forall e n s , arities e = ok_arities n s -> P n s e.

Fixpoint sem_rec (sem_g sem_h0 sem_h1:list bs->list bs->bs)(v:bs)(vnl vsl:list bs) :=
  match v with
    | nil => sem_g vnl vsl
    | b::v' =>
      if b then sem_h1 (v'::vnl) (sem_rec sem_g sem_h0 sem_h1 v' vnl vsl :: vsl)
      else sem_h0 (v'::vnl) (sem_rec sem_g sem_h0 sem_h1 v' vnl vsl :: vsl)
  end.

Fixpoint sem (e:BC)(vnl vsl:list bs) : bs :=
  match e with
  | zero => nil
  | proj n s j => 
    if leb (S j) n then
      nth j vnl nil
      else nth (j-n) vsl nil
  | succ b => b :: hd nil vsl
  | pred => tail (hd nil vsl)
  | cond =>
      match vsl with
      | a :: b :: c :: d :: _ => 
        match a with 
          | nil => b
          | true :: _ => c
          | false :: _ => d
        end
      | a :: b :: c :: _ => 
        match a with 
          | nil => b
          | true :: _ => c
          | false :: _ => nil
        end
      | a :: b :: _ => 
        match a with 
          | nil => b
          | _ => nil
        end
      | _ => nil
      end
  | rec g h0 h1 => sem_rec (sem g) (sem h0) (sem h1) (hd nil vnl) (tail vnl) vsl
  | comp _ _ h nl sl => 
    sem h (List.map (fun ne => sem ne vnl nil) nl) 
          (List.map (fun se => sem se vnl vsl) sl)
  end.

Lemma sem_comp :
  forall n s f nel sel nl sl, 
  sem (comp n s f nel sel) nl sl =
  sem f (map (fun ne => sem ne nl nil) nel) (map (fun se => sem se nl sl) sel).

Lemma cond_simpl_nil n s fn fc ff ft l1 l2 :
  sem fc l1 l2 = nil ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem fn l1 l2.

Lemma cond_simpl_notnil n s fn fc ft ff l1 l2 :
  sem fc l1 l2 <> nil ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = 
  match sem fc l1 l2 with
    | nil => nil 
    | true :: _ => sem ft l1 l2 
    | false :: _ => sem ff l1 l2
  end.

Lemma cond_simpl_true n s fn fc ff ft l1 l2 :
  hd false (sem fc l1 l2) = true ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ft l1 l2.

Lemma cond_simpl_false n s fn fc ff ft l1 l2 l :
  sem fc l1 l2 = false :: l ->
  sem (comp n s cond nil [fc; fn; ft; ff]) l1 l2 = sem ff l1 l2.

Lemma sem_nth :
  forall i start len f d vnl vsl,
  0 <= i < len ->
  sem (nth i (map f (seq start len)) d) vnl vsl = sem (f (i+start)) vnl vsl.

Lemma map_sem_nth :
  forall i f1 f2 vnl vsl d,
  map (fun f => sem f vnl vsl) f1 = map (fun f => sem f vnl vsl) f2 ->
  sem (nth i f1 d) vnl vsl = sem (nth i f2 d) vnl vsl.

Lemma sem_proj_S_normal :
  forall n s i f vsl vnl,
  i < n ->
  sem (proj (S n) s (S i)) (f::vnl) vsl =
  sem (proj n s i) vnl vsl.

Lemma sem_proj_S_safe :
  forall n s i f vsl vnl,
  n <= i ->
  sem (proj n (S s) (S i)) vnl (f::vsl) =
  sem (proj n s i) vnl vsl.

Lemma sem_firstn_safe :
  forall f n s vnl vsl,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f vnl (firstn s vsl).

Lemma sem_firstn_normal :
  forall f n s vnl vsl,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f (firstn n vnl) vsl.

Lemma sem_firstn :
  forall f n s vnl vsl,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f (firstn n vnl) (firstn s vsl).

Lemma sem_repeat :
  forall f vnl vsl n s,
  arities f = ok_arities n s ->
  sem f vnl vsl = sem f (vnl ++ repeat (n - length vnl) nil) (vsl ++ repeat (s - length vsl) nil).

Lemma map_sem_repeat :
  forall fl vnl vsl n s,
  (forall f, In f fl -> arities f = ok_arities n s) ->
  map (fun f => sem f vnl vsl) fl =
  map (
    fun f =>
      sem f
        (vnl ++ repeat (n - length vnl) nil)
        (vsl ++ repeat (s - length vsl) nil)
  ) fl.

Lemma map_proj_seq_normal_gen :
  forall n i vnl,
  n+i <= length vnl ->
  map (fun f : BC => sem f vnl nil) (map (proj (n+i) 0) (seq i n)) =
  firstn n (skipn i vnl).

Lemma map_proj_seq_normal :
  forall n vnl,
  map (fun f : BC => sem f vnl nil) (map (proj n 0) (seq 0 n)) =
  firstn n vnl ++ repeat (n - length vnl) nil.

Lemma map_proj_seq_safe_gen :
  forall n s i vnl vsl,
  s+i <= length vsl ->
  map (fun f : BC => sem f vnl vsl) (map (proj n (s+i)) (seq (n+i) s)) =
  firstn s (skipn i vsl).

Lemma map_proj_seq_safe :
  forall n s vnl vsl,
  map (fun f : BC => sem f vnl vsl) (map (proj n s) (seq n s)) =
  firstn s vsl ++ repeat (s - length vsl) nil.

Definition zero_e (n s:nat) : BC :=
  comp n s zero nil nil.

Lemma sem_comp_proj_normal : forall n1 n2 f1 vnl i,
n2 <> 0 -> i < n2 ->
sem (comp n1 0 (proj n2 0 i) f1 nil) vnl nil =
sem (nth i f1 (zero_e n1 0)) vnl nil.

Lemma sem_comp_proj_safe : forall n1 s1 n2 s2 f1 f2 vnl vsl i,
n2 <= i ->
sem (comp n1 s1 (proj n2 s2 i) f1 f2) vnl vsl =
sem (nth (i - n2) f2 (zero_e n1 s1)) vnl vsl.

Fixpoint poly_BC n (e : BC) : pol :=
  match e with 
    | zero => pcst 0 0
    | proj n s i => if (leb (S i) n) then pproj n i else (pcst n 0)
    | succ b => pcst 0 1
    | pred => pcst 0 0
    | cond => pcst 0 0
    | rec g h0 h1 =>
        pplus (pshift (poly_BC (n - 1) g)) 
        (pmult (pproj n 0) (pplus (poly_BC n h0) (poly_BC n h1)))
    | comp n s h rl tl =>
      (pplus (pcst n 0)
        (pplus (pcomp (poly_BC (length rl) h) (map (poly_BC n) rl ))
          (pplusl (map (poly_BC n) tl))))
  end.

Lemma arity_poly_BC : forall e n s,
  arities e = ok_arities n s ->
  parity (poly_BC n e) = n.

Lemma pWF_poly_BC : forall e n s,
  arities e = ok_arities n s -> pWF (poly_BC n e).
  
Lemma polymax_bounding : forall (e : BC) xl yl n s,
  arities e = ok_arities n s ->
  length (sem e xl yl) <= 
  peval (poly_BC n e) (map (@length _) xl) + maxl (map (@length _) yl).

Lemma proj_seq_shift_safe : forall n m ln ls d,
 map (fun x : BC => sem x ln (d :: ls)) (map (proj n (S m)) (seq (S n) m)) =
 map (fun x : BC => sem x ln ls) (map (proj n m) (seq n m)).

Lemma proj_seq_shift_normal : forall n ln ls d,
 map (fun x : BC => sem x (d :: ln) ls) (map (proj (S n) 0) (seq 1 n)) =
 map (fun x : BC => sem x ln ls) (map (proj n 0) (seq 0 n)).

Section TIME.

  Variable ptime_zero_cost ptime_succ_cost ptime_pred_cost ptime_cond_cost: nat.
  Variable ptime_proj_cost : nat -> nat -> nat -> nat.

  Fixpoint sem_cost_rec (sem_g sem_h0 sem_h1:list bs->list bs->bs*nat)(v:bs)(vnl vsl:list bs) :
    bs * nat :=
    match v with
      | nil => sem_g vnl vsl
      | b::v' =>
        if b
          then
            let sem_cost := sem_cost_rec sem_g sem_h0 sem_h1 v' vnl vsl in
              let sem_cost_h := sem_h1 (v'::vnl) (fst sem_cost :: vsl) in
                (fst sem_cost_h, snd sem_cost + snd sem_cost_h)
          else
            let sem_cost := sem_cost_rec sem_g sem_h0 sem_h1 v' vnl vsl in
              let sem_cost_h := sem_h0 (v'::vnl) (fst sem_cost :: vsl) in
                (fst sem_cost_h, snd sem_cost + snd sem_cost_h)
    end.

Fixpoint sem_cost (e:BC)(vnl vsl:list bs) : bs*nat :=
 match e with
 | zero => (nil, ptime_zero_cost)
 | proj n s j => (
   if leb (S j) n then
     nth j vnl nil
     else nth (j-n) vsl nil, ptime_proj_cost n s j
   )
 | succ b => (b :: hd nil vsl, ptime_succ_cost)
 | pred => (tail (hd nil vsl), ptime_pred_cost)
 | cond => (
     match vsl with
     | a :: b :: c :: d :: _ =>
       match a with
         | nil => b
         | true :: _ => c
         | false :: _ => d
       end
     | a :: b :: c :: _ =>
       match a with
         | nil => b
         | true :: _ => c
         | false :: _ => nil
       end
     | a :: b :: _ =>
       match a with
         | nil => b
         | _ => nil
       end
     | _ => nil
     end, ptime_cond_cost
   )
 | rec g h0 h1 =>
     sem_cost_rec (sem_cost g) (sem_cost h0) (sem_cost h1) (hd nil vnl) (tail vnl) vsl
 | comp _ _ h nl sl =>
   let sem_cost_nl := List.map (fun ne => sem_cost ne vnl nil) nl in
   let sem_cost_sl := List.map (fun se => sem_cost se vnl vsl) sl in
   let sem_nl := List.map (@fst _ _) sem_cost_nl in
   let sem_sl := List.map (@fst _ _) sem_cost_sl in
   let cost_nl := List.map (@snd _ _) sem_cost_nl in
   let cost_sl := List.map (@snd _ _) sem_cost_sl in
   let sem_cost_h := sem_cost h sem_nl sem_sl in
   (fst sem_cost_h, snd sem_cost_h + plusl cost_nl + plusl cost_sl)
 end.

Lemma sem_cost_correct :
 forall e n s,
 arities e = ok_arities n s ->
 forall vnl vsl,
 fst (sem_cost e vnl vsl) = sem e vnl vsl.

  Variable ptime_zero ptime_succ ptime_pred ptime_cond: pol.
  Variable ptime_proj : nat -> nat -> nat -> pol.

  Hypothesis ptime_zero_spec : 
    snd (sem_cost zero nil nil) <= peval ptime_zero nil.

  Hypothesis ptime_zero_wf : pWF ptime_zero.

  Hypothesis ptime_zero_arity : parity ptime_zero = 0.

  Hypothesis ptime_succ_spec : forall b,
    snd (sem_cost (succ b) nil nil) <= peval ptime_succ nil.

  Hypothesis ptime_succ_wf : pWF ptime_succ.

  Hypothesis ptime_succ_arity : parity ptime_succ = 0.

  Hypothesis ptime_proj_spec : forall n s i l,
    length l = n ->
    snd (sem_cost (proj n s i) l nil) <= peval (ptime_proj n s i) (map (@length _) l).

  Hypothesis ptime_proj_wf : forall n s i, pWF (ptime_proj n s i).

  Hypothesis ptime_proj_arity : forall n s i, parity (ptime_proj n s i) = n.

  Hypothesis ptime_cond_spec : 
    snd (sem_cost cond nil nil) <= peval ptime_cond nil.

  Hypothesis ptime_cond_wf : pWF ptime_cond.

  Hypothesis ptime_cond_arity : parity ptime_cond = 0.

  Hypothesis ptime_pred_spec : 
    snd (sem_cost pred nil nil) <= peval ptime_pred nil.

  Hypothesis ptime_pred_wf : pWF ptime_pred.

  Hypothesis ptime_pred_arity : parity ptime_pred = 0.

Fixpoint poly_time n (e:BC) : pol :=
  match e with
    | zero => ptime_zero
    | succ _ => ptime_succ
    | pred => ptime_pred
    | cond  => ptime_cond
    | proj n s i => ptime_proj n s i
    | rec g h0 h1 => 
      pplus (pshift (poly_time (n - 1) g))
      (pmult (pproj n 0) (pplus (poly_time n h0) (poly_time n h1)))
    | comp n0 s h rl tl =>
      pplus (pplus (pcst n0 0) (pcomp (poly_time (length rl) h) (map (poly_BC n0) rl)))
      (pplus (pplusl (map (poly_time n0) rl)) (pplusl (map (poly_time n0) tl)))
  end.
 
Lemma poly_time_WF : forall e n s, arities e = ok_arities n s -> pWF (poly_time n e).

Lemma arity_poly_time : forall e n s,
  arities e = ok_arities n s ->
  parity (poly_time n e) = n.

Lemma sem_cost_bounded : forall e n s,
 arities e = ok_arities n s ->
 (forall vnl vsl,
   length vnl = n -> 
   length vsl = s -> 
   snd (sem_cost e vnl vsl) <=
   peval (poly_time n e) (List.map (@length _) vnl)).

End TIME. *)

Definition inv_e (e : BC) : BC :=
  comp 2 0 e (proj 2 0 1 :: proj 2 0 0 :: nil) nil.

Definition from_11_to_20 (e : BC) : BC :=
  comp 2 0 e (proj 2 0 0 :: nil) (proj 2 0 1 :: nil).

Lemma from_11_to_20_correct e v1 v2 :
  sem e [v1] [v2] = sem (from_11_to_20 e) [v1 ; v2] nil.
Proof.
 intros; simpl; trivial.
Qed.

Definition app_e : BC :=
  rec (proj 0 1 0)
      (comp 1 2 (succ false) nil ((proj 1 2 1) :: nil))
      (comp 1 2 (succ true) nil ((proj 1 2 1) :: nil)).

Lemma app_correct v1 v2 :
  sem app_e [v1] [v2] = v1 ++ v2.
Proof.
 induction v1; simpl in *; trivial.
 intros; rewrite IHv1.
 case a; trivial.
Qed.

Program Fixpoint constant (v:bs) : { e : BC | arities e = ok_arities 0 0 /\ sem e nil nil = v } :=
  match v with
  | nil => BC.zero
  | b :: v' => BC.comp 0 0 (BC.succ b) nil [constant v']
  end.

Next Obligation.
simpl.
tauto.
Qed.

Next Obligation.
simpl.
intros bs_to_BC v b v' Hv.
subst v.
destruct (bs_to_BC v') as [e [H1 H2] ].
simpl.
rewrite H1, H2.
tauto.
Defined.

Definition rec2 g h := rec g h h.

Lemma rec2_correct v1 v2 g h0 h1 :
  unary (hd nil v1) = true ->
  sem (rec g h0 h1) v1 v2 = sem (rec2 g h1) v1 v2.
Proof.
 intros; simpl; revert H.
 induction (hd nil v1); simpl; trivial; intros.
 rewrite andb_true_iff in H.
 decompose [and] H; clear H.
 destruct a.
 rewrite IHl; trivial; tauto.
 unfold id in H0; discriminate.
Qed.

Lemma rec2_simpl g h i z l1 l2 :
  sem (rec2 g h) ((i :: z) :: l1) l2 = sem h (z :: l1) (sem_rec (sem g) (sem h) (sem h) z l1 l2 :: l2).
Proof. intros; simpl; case i; trivial. Qed. 

Lemma rec2_sem_rec g h z l1 l2 :
  sem (rec2 g h) (z :: l1) l2 = sem_rec (sem g) (sem h) (sem h) z l1 l2.
Proof.  intros; simpl; trivial. Qed. 

Definition cond2 n s x g h0 h1 : BC :=
  comp n s
    cond nil [
      x;
      g;
      comp n s h0
        (map (proj n 0) (seq 0 n))
        (comp n s pred nil [x] :: map (proj n s) (seq n s));
      comp n s h1
        (map (proj n 0) (seq 0 n))
        (comp n s pred nil [x] :: map (proj n s) (seq n s))
    ].

Lemma arities_cond2 n s x g h0 h1
  (Hx : arities x = ok_arities n s)
  (Hg : arities g = ok_arities n s)
  (Hh0 : arities h0 = ok_arities n (S s))
  (Hh1 : arities h1 = ok_arities n (S s)) :
  arities (cond2 n s x g h0 h1) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh0, Hh1.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1
end.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H2
end.
simpl.
do 2 rewrite <- beq_nat_refl.
reflexivity.
rewrite forallb_forall_conv in H2.
destruct H2 as [e [H2 H3] ].
rewrite in_map_iff in H2.
destruct H2 as [p [H2 H4] ].
rewrite in_seq_iff in H4.
subst e.
simpl in H3.
case_eq (n + s).
intro H5.
contradict H5.
omega.
intros q H5.
rewrite H5 in H3.
case_eq (leb p q); intro H6.
rewrite H6 in H3.
simpl in H3.
do 2 rewrite <- beq_nat_refl in H3.
discriminate H3.
rewrite leb_iff_conv in H6.
contradict H6.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [p [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (n + 0).
intro H4.
contradict H4.
omega.
intros q H4.
rewrite H4 in H2.
case_eq (leb p q); intro H5.
rewrite H5 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H5.
contradict H5.
omega.
Qed.

Definition cond2_correct n s x g h0 h1 vnl vsl :
  length vnl = n ->
  length vsl = s ->
  sem (cond2 n s x g h0 h1) vnl vsl =
  match sem x vnl vsl with
  | nil => sem g vnl vsl
  | true  :: _ => sem h0 vnl (tl (sem x vnl vsl) :: vsl)
  | false :: _ => sem h1 vnl (tl (sem x vnl vsl) :: vsl)
  end.
Proof.
intros Hn Hs.
simpl.
destruct (sem x vnl vsl) as [ | [ | ] v]; simpl.
reflexivity.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vnl) at 2.
apply firstn_app.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.
apply firstn_app.
rewrite map_proj_seq_normal.
rewrite map_proj_seq_safe.
f_equal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vnl) at 2.
apply firstn_app.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.
apply firstn_app.
Qed.

Definition rec1 n s g h :=
  rec
    g
    (comp (S n) (S s) h
      (comp (S n) 0 (succ false) nil [proj (S n) 0 0] ::
       map (proj (S n) 0)     (seq 1     n))
      (map (proj (S n) (S s)) (seq (S n) (S s))))
    (comp (S n) (S s) h
      (comp (S n) 0 (succ true) nil [proj (S n) 0 0] ::
       map (proj (S n) 0)     (seq 1     n))
      (map (proj (S n) (S s)) (seq (S n) (S s)))).

Lemma sem_rec_false g h0 h1 vnl vsl v :
  sem (rec g h0 h1) ((false :: v) :: vnl) vsl =
  sem h0 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
Proof.
reflexivity.
Qed.

Lemma sem_rec_true g h0 h1 vnl vsl v :
  sem (rec g h0 h1) ((true :: v) :: vnl) vsl =
  sem h1 (v :: vnl) (sem (rec g h0 h1) (v :: vnl) vsl :: vsl).
Proof.
reflexivity.
Qed.

Lemma rec1_arities n s g h
  (Hg : arities g = ok_arities n s)
  (Hh : arities h = ok_arities (S n) (S s)) :
  arities (rec1 n s g h) = ok_arities (S n) s.
Proof.
simpl.
rewrite Hg, Hh.
simpl.
do 2 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1
end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4
end.
do 4 rewrite <- beq_nat_refl.
simpl.
reflexivity.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (leb q (n + S s)); intro H7.
rewrite H7 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H7.
contradict H7.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.
contradict H4.
omega.
Qed.

Fixpoint sem_rec1
  (g h:BC)(v : bs)(vnl vsl : list bs) {struct v} :=
  match v with
    | nil => sem g vnl vsl
    | _::v' => sem h (v::vnl) (sem_rec1 g h v' vnl vsl :: vsl)
  end.

Lemma rec1_correct n s g h vnl vsl :
  length vnl = S n ->
  length vsl = s ->
  sem (rec1 n s g h) vnl vsl =
  sem_rec1 g h (hd nil vnl) (tl vnl) vsl.
Proof.
intros Hn Hs.
destruct vnl as [ | v vnl].
reflexivity.
simpl in Hn.
induction v as [ | b v IH].
reflexivity.
simpl sem_rec1.
simpl hd in IH.
simpl tl in IH.
rewrite <- IH.
clear IH.
unfold rec1.
case b.
rewrite sem_rec_true.
match goal with
| |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] =>
    set (e0 := sem (rec g h0 h1) vnl vsl)
end.
rewrite sem_comp, map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen by (simpl; omega).
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift, map_map; simpl.
apply map_nth_seq.
omega.
rewrite <- (
  map_map
    (proj (S n) (S s))
    (fun e => sem e (v :: vnl) (e0 :: vsl))
);rewrite map_proj_seq_safe; simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.
apply firstn_app.
rewrite sem_rec_false.
match goal with
| |- context [sem (rec ?g ?h0 ?h1) ?vnl ?vsl] =>
    set (e0 := sem (rec g h0 h1) vnl vsl)
end.
rewrite sem_comp, map_map.
f_equal.
rewrite map_cons.
f_equal.
replace (S n) with (n+1) by omega.
rewrite map_proj_seq_normal_gen by (simpl; omega).
erewrite firstn_map_nth by (simpl; omega).
instantiate (1:=nil).
rewrite <- seq_shift, map_map; simpl.
apply map_nth_seq.
omega.
rewrite <- (
  map_map
    (proj (S n) (S s))
    (fun e => sem e (v :: vnl) (e0 :: vsl))
);rewrite map_proj_seq_safe; simpl.
f_equal.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.
apply firstn_app.
Qed.

Definition rec3 n s x g h : BC :=
  comp n s
    (rec1 n s g h)
    (x ::
     map (proj n 0) (seq 0 n))
    (map (proj n s) (seq n s)).

Lemma arities_rec3 n s x g h
  (Hx : arities x = ok_arities n 0)
  (Hg : arities g = ok_arities n s)
  (Hh : arities h = ok_arities (S n) (S s)) :
  arities (rec3 n s x g h) = ok_arities n s.
Proof.
simpl.
rewrite Hx, Hg, Hh.
simpl.
do 4 rewrite map_length, seq_length.
do 2 rewrite <- beq_nat_refl.
simpl.
rewrite <- beq_nat_refl.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H1
end.
simpl.
case_eq (n + S s).
intro H2.
contradict H2.
omega.
intros p H2.
case_eq (leb n p); intro H3.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H4
end.
do 4 rewrite <- beq_nat_refl.
simpl.
do 2 rewrite <- beq_nat_refl.
simpl.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H5
end.
match goal with
| |- context [forallb ?P ?l] => case_eq (forallb P l); intro H6
end.
simpl.
reflexivity.
rewrite forallb_forall_conv in H6.
destruct H6 as [e [H6 H7] ].
rewrite in_map_iff in H6.
destruct H6 as [q [H6 H8] ].
rewrite in_seq_iff in H8.
subst e.
simpl in H7.
case_eq (n+s).
intro H9.
contradict H8.
omega.
intros r H9.
rewrite H9 in H7.
case_eq (leb q r); intro H10.
rewrite H10 in H7.
simpl in H7.
do 2 rewrite <- beq_nat_refl in H7.
discriminate H7.
rewrite leb_iff_conv in H10.
contradict H10.
omega.
rewrite forallb_forall_conv in H5.
destruct H5 as [e [H5 H6] ].
rewrite in_map_iff in H5.
destruct H5 as [q [H5 H7] ].
rewrite in_seq_iff in H7.
subst e.
simpl in H6.
case_eq (n+0).
intro H8.
contradict H7.
omega.
intros r H8.
rewrite H8 in H6.
case_eq (leb q r); intro H9.
rewrite H9 in H6.
simpl in H6.
rewrite <- beq_nat_refl in H6.
discriminate H6.
rewrite leb_iff_conv in H9.
contradict H9.
omega.
rewrite forallb_forall_conv in H4.
destruct H4 as [e [H4 H5] ].
rewrite in_map_iff in H4.
destruct H4 as [q [H4 H6] ].
rewrite in_seq_iff in H6.
subst e.
simpl in H5.
case_eq (n+S s).
intro H7.
contradict H6.
omega.
intros r H7.
rewrite H7 in H5.
case_eq (leb q (S r)); intro H8.
rewrite H8 in H5.
simpl in H5.
do 2 rewrite <- beq_nat_refl in H5.
discriminate H5.
rewrite leb_iff_conv in H8.
contradict H8.
omega.
rewrite leb_iff_conv in H3.
contradict H3.
omega.
rewrite forallb_forall_conv in H1.
destruct H1 as [e [H1 H2] ].
rewrite in_map_iff in H1.
destruct H1 as [q [H1 H3] ].
rewrite in_seq_iff in H3.
subst e.
simpl in H2.
case_eq (leb q (n+0)); intro H4.
rewrite H4 in H2.
simpl in H2.
rewrite <- beq_nat_refl in H2.
discriminate H2.
rewrite leb_iff_conv in H4.
contradict H4.
omega.
Qed.

Lemma rec3_correct n s x g h vnl vsl :
  length vnl = n ->
  length vsl = s ->
  sem (rec3 n s x g h) vnl vsl =
  sem_rec1 g h (sem x vnl nil) vnl vsl.
Proof.
intros Hn Hs.
unfold rec3.
rewrite sem_comp, rec1_correct; simpl.
f_equal.
rewrite map_proj_seq_normal.
subst n.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vnl) at 2.
apply firstn_app.
rewrite map_proj_seq_safe.
subst s.
rewrite minus_diag.
simpl.
rewrite app_nil_r.
rewrite <- (app_nil_r vsl) at 2.
apply firstn_app.
rewrite map_length, map_length, seq_length; reflexivity.
rewrite map_length, map_length, seq_length; reflexivity.
Qed.

Definition true_e (n s:nat) : BC :=
  comp n s (comp 0 0 (succ true) nil (zero :: nil)) nil nil.

Lemma true_correct n s l1 l2: 
 bs2bool (sem (true_e n s) l1 l2) = true.
Proof.
 intros; simpl; trivial.
Qed.

Lemma true_correct_nat n s l1 l2: 
 bs2nat (sem (true_e n s) l1 l2) = 1.
Proof.
 intros; simpl; trivial.
Qed.

Definition false_e (n s:nat) : BC :=
  comp n s (comp 0 0 (succ false) nil (zero :: nil)) nil nil.

Lemma false_correct n s l1 l2: 
 bs2bool (sem (false_e n s) l1 l2) = false.
Proof.
 intros; simpl; trivial.
Qed.

Lemma false_correct_nat n s l1 l2: 
 bs2nat (sem (false_e n s) l1 l2) = 0.
Proof.
 intros; simpl; trivial.
Qed.

Definition parity_e : BC := 
  comp 0 1 cond nil [proj 0 1 0; false_e 0 1; true_e 0 1; false_e 0 1].

Lemma parity_correct_even v :
  bs2bool (sem parity_e nil [v]) = false ->
  even (bs2nat v).
Proof.
  destruct v; simpl; intros.
  apply even_O.
  destruct b; simpl in *.
  discriminate.
  cutrewrite (bs2nat v + (bs2nat v + 0) = 2 * (bs2nat v)).
  auto with arith.
  ring.
Qed.

Lemma parity_correct_odd v :
  bs2bool (sem parity_e nil [v]) = true ->
  odd (bs2nat v).
Proof.
  destruct v; simpl; intros.
  discriminate.
  cutrewrite (bs2nat v + (bs2nat v + 0) = (2 * (bs2nat v))).
  destruct b.
  apply odd_S.
  auto with arith.
  simpl in H; discriminate.
  omega.
Qed.

Definition P (x:bs)(y:bs) : bs := skipn (length x) y.

Lemma P_nil : forall x, P x nil = nil.
Proof.
 intro x; case x; trivial.
Qed.

Definition P_e : BC :=
  rec (proj 0 1 0)
      (comp 1 2 pred nil [proj 1 2 1])
      (comp 1 2 pred nil [proj 1 2 1]).

Lemma P_correct x y :
  sem P_e [x] [y] = P x y.
Proof.
 unfold P; induction x; simpl in *; trivial.
 intros; case a.
 rewrite IHx; clear IHx. 
 induction (length x); simpl; trivial.
 rewrite <- IHn; clear IHn.
 revert y.
 induction n; simpl; trivial; intros.
 case y; simpl; trivial.
 case y; simpl; trivial; intros.
 rewrite IHx; clear IHx. 
 induction (length x); simpl; trivial.
 rewrite <- IHn; clear IHn.
 revert y.
 induction n; simpl; trivial; intros.
 case y; simpl; trivial.
 case y; simpl; trivial; intros.
Qed.

Global Opaque P_e.

Definition P'_e := from_11_to_20 P_e.

Definition Y (z w y:bs) : bs :=
  P (P z w) y. 

Definition Y_e : BC :=
  comp 2 1 P_e 
  [comp 2 0 P'_e [proj 2 0 0; proj 2 0 1] nil] 
  [proj 2 1 2].

Lemma Y_correct z w y :
  sem Y_e [z;w] [y] = Y z w y.
Proof.
 intros; simpl.
 rewrite P_correct, P_correct.
 trivial.
Qed.

Lemma Y_skipn z w y :
  Y z w y = skipn (length w - length z) y.
Proof.
 unfold Y, P; intros.
 rewrite length_skipn.
 trivial.
Qed.

Global Opaque Y_e.

Lemma Y_nth x y z :
 hd false (Y x y z) = nth (length y - length x) z false.
Proof.
 unfold Y, P; intros.
 rewrite length_skipn.
 remember (length y - length x) as n.
 revert x y z Heqn.
 induction n; simpl; intros.
 case z; trivial.
 destruct z; simpl in *; trivial.
 apply IHn with (x:=true::x) (y:=y).
 simpl.
 omega.
Qed.

Lemma Y_nil x y : Y x y nil = nil.
Proof.
  intros; unfold Y, P.
  case (length (skipn (length x) y)); simpl; trivial.
Qed.

Lemma Y_refl x y : Y x x y = y.
Proof.
 intros; unfold Y, P.
 rewrite length_skipn, minus_diag; simpl; trivial.
Qed.

Lemma Y_nil_length x y z :
  Y x y z = nil ->
  length z <= length y - length x.
Proof.
 intros.
 unfold Y, P in H.
 rewrite length_skipn in H.
 apply skipn_nil_length; trivial.
Qed.

Lemma Y_hd_same x y z i1 i2: Y (i1 :: x) y z = Y (i2 :: x) y z.
Proof.
 intros; unfold Y, P.
 simpl; trivial.
Qed.

Lemma Y_le : forall u w y , length u <= length w ->
   length (Y u w y) <= length (Y w w y).
 intros.
 repeat rewrite Y_skipn.
 repeat rewrite skipn_length.
 omega.
Qed.

Definition I_e : BC :=
  comp 2 1 parity_e nil 
  [comp 2 1 Y_e 
    [comp 2 0 (succ true) nil [proj 2 0 0]; proj 2 0 1] 
    [proj 2 1 2] ].

Lemma I_correct (z w y : bs) :
  sem I_e [z;w] [y] = [nth (length w - S (length z)) y false].
Proof.
 simpl; intros.
 rewrite Y_correct.
 case_eq (Y (true :: z) w y); intros.
 apply Y_nil_length in H; simpl in H.
 rewrite nth_overflow; trivial.
 replace (S (length z)) with (length (true :: z)).
 rewrite <- Y_nth.
 rewrite H; simpl; trivial.
 destruct b; trivial.
 simpl; trivial.
Qed.

Lemma I_Y_property j z w y :
  length z < length w ->
  length w - S (length z) < length y ->  
  Y (j :: z) w y = [nth (length w - S (length z)) y false] ++ Y z w y.
Proof.
 intros; simpl.
 rewrite Y_skipn.
 rewrite Y_skipn.
 simpl.
 rewrite skipn_hd with (d := false).
 f_equal.
 f_equal.
 omega.
 trivial.
Qed.

Global Opaque I_e.
