
Require Import Bool.
Require Import Arith.
Require Import Compare_dec.
Require Import Peano_dec.
Require Import General.
(* General:
Require Export Bool.
Require Export Arith.
Require Export Compare_dec.
Require Export Peano_dec.
Require Export MyList.
Require Export MyRelations.

Set Implicit Arguments.
Unset Strict Implicit.

  Definition max_nat (n m : nat) :=
    match le_gt_dec n m with
    | left _ => m
    | right _ => n
    end.

  Lemma least_upper_bound_max_nat :
   forall n m p : nat, n <= p -> m <= p -> max_nat n m <= p.

Require Export Relation_Definitions.

  Definition decide (P : Prop) := {P} + {~ P}.

  Hint Unfold decide: core.

  Inductive Acc3 (A B C : Set) (R : relation (A * (B * C))) :
  A -> B -> C -> Prop :=
      Acc3_intro :
        forall (x : A) (x0 : B) (x1 : C),
        (forall (y : A) (y0 : B) (y1 : C),
         R (y, (y0, y1)) (x, (x0, x1)) -> Acc3 R y y0 y1) -> 
        Acc3 R x x0 x1.

  Lemma Acc3_rec :
   forall (A B C : Set) (R : relation (A * (B * C))) (P : A -> B -> C -> Set),
   (forall (x : A) (x0 : B) (x1 : C),
    (forall (y : A) (y0 : B) (y1 : C),
     R (y, (y0, y1)) (x, (x0, x1)) -> P y y0 y1) -> 
    P x x0 x1) ->
   forall (x : A) (x0 : B) (x1 : C), Acc3 R x x0 x1 -> P x x0 x1.

  Lemma Acc_Acc3 :
   forall (A B C : Set) (R : relation (A * (B * C))) (x : A) (y : B) (z : C),
   Acc R (x, (y, z)) -> Acc3 R x y z. 

Section Principal.

  Variables (A : Set) (P : A -> Prop) (R : A -> A -> Prop).

  Record ppal (x : A) : Prop := Pp_intro
    {pp_ok : P x; pp_least : forall y : A, P y -> R x y}.

  Definition ppal_dec : Set := {x : A | ppal x} + {(forall x : A, ~ P x)}.

End Principal. *)
Require Import MyList.
(* MyList:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export List.

Section Listes.

  Variable A : Set.

  Let List := list A.

  Inductive item (x : A) : List -> nat -> Prop :=
    | item_hd : forall l : List, item x (x :: l) 0
    | item_tl :
        forall (l : List) (n : nat) (y : A),
        item x l n -> item x (y :: l) (S n).

  Lemma fun_item :
   forall (u v : A) (e : List) (n : nat), item u e n -> item v e n -> u = v.

  Lemma list_item :
   forall e n, {t : _ | item t e n} + {(forall t, ~ item t e n)}.

  Inductive trunc : nat -> List -> List -> Prop :=
    | trunc_O : forall e : List, trunc 0 e e
    | trunc_S :
        forall (k : nat) (e f : List) (x : A),
        trunc k e f -> trunc (S k) (x :: e) f.

  Lemma item_trunc :
   forall (n : nat) (e : List) (t : A),
   item t e n -> exists f : List, trunc (S n) e f.

End Listes.

  Hint Resolve item_hd item_tl trunc_O trunc_S: core. *)
Require Import MyRelations.
(* MyRelations:
Require Export Relation_Definitions.
Require Export Relation_Operators.
Require Export Operators_Properties.

Require Export Inclusion.
Require Export Transitive_Closure.
Require Export Union.
Require Export Inverse_Image.
Require Export Lexicographic_Product.

Hint Resolve rt_step rt_refl rst_step rst_refl t_step: core.
Hint Unfold transp union reflexive transitive: core.
Hint Immediate rst_sym: core.

  Lemma clos_refl_trans_ind_right :
   forall (A : Set) (R : relation A) (M : A) (P : A -> Prop),
   P M ->
   (forall P0 N : A, R N P0 -> clos_refl_trans A R P0 M -> P P0 -> P N) ->
   forall a : A, clos_refl_trans A R a M -> P a.

  Hint Resolve left_sym right_sym sp_swap sp_noswap: core. *)

Require Export Main.
(* Main:
Require Import General.

Unset Standard Proposition Elimination Names.

Section PTS_modulaire.

  Variable sort : Set.
  Hypothesis eq_sort_dec : forall s s' : sort, decide (s = s').

  Load "Ltermes".
  Load "Ltyping".
  Load "Lrules".
  Load "Lcumul".
  Load "Llambda".

End PTS_modulaire. *)
Require Export SortECC.
(* SortECC:
Require Import General.
Require Export Relations.

Unset Standard Proposition Elimination Names.

Section SortsOfECC.

  Inductive calc : Set :=
    | Pos : calc
    | Neg : calc.

  Inductive srt_ecc : Set :=
    | Sprop : calc -> srt_ecc
    | Stype : calc -> nat -> srt_ecc.

  Inductive axiom_ecc : srt_ecc -> srt_ecc -> Prop :=
    | ax_prop : forall (c : calc) (n : nat), axiom_ecc (Sprop c) (Stype c n)
    | ax_type :
        forall (c : calc) (n m : nat),
        n < m -> axiom_ecc (Stype c n) (Stype c m).

  Inductive rules_ecc : srt_ecc -> srt_ecc -> srt_ecc -> Prop :=
    | rule_prop_l : forall (c : calc) (s : srt_ecc), rules_ecc (Sprop c) s s
    | rule_prop_r :
        forall (c : calc) (s : srt_ecc), rules_ecc s (Sprop c) (Sprop c)
    | rule_type :
        forall (c1 c2 : calc) (n m p : nat),
        n <= p -> m <= p -> rules_ecc (Stype c1 n) (Stype c2 m) (Stype c2 p).

  Inductive univ_ecc : srt_ecc -> srt_ecc -> Prop :=
      univ_type :
        forall (c : calc) (n m : nat),
        n <= m -> univ_ecc (Stype c n) (Stype c m).

  Definition univ : relation srt_ecc := clos_refl_trans _ univ_ecc.

  Hint Resolve ax_prop ax_type rule_prop_l rule_prop_r rule_type univ_type:
    pts.
  Hint Unfold univ: pts.

  Let univ_trans : forall x y z : srt_ecc, univ x y -> univ y z -> univ x z.
Proof rt_trans srt_ecc univ_ecc.

  Inductive inv_univ : srt_ecc -> srt_ecc -> Prop :=
    | iu_prop : forall c : calc, inv_univ (Sprop c) (Sprop c)
    | iu_type :
        forall (c : calc) (n m : nat),
        n <= m -> inv_univ (Stype c n) (Stype c m).

  Hint Resolve iu_prop iu_type: pts.

  Lemma inv_univ_trans :
   forall x y z : srt_ecc, inv_univ x y -> inv_univ y z -> inv_univ x z.

  Lemma univ_inv :
   forall s s' : srt_ecc,
   univ s s' -> forall P : Prop, (inv_univ s s' -> P) -> P.

  Lemma calc_dec : forall c c' : calc, decide (c = c').

  Lemma ecc_sort_dec : forall s s' : srt_ecc, decide (s = s').

  Lemma univ_ecc_dec : forall s s' : srt_ecc, decide (univ s s').

  Lemma ecc_inf_axiom :
   forall s : srt_ecc, {sp : srt_ecc | ppal (axiom_ecc s) univ sp}.

  Lemma ecc_inf_rule :
   forall x1 x2 : srt_ecc,
   {x3 : srt_ecc | rules_ecc x1 x2 x3 & 
   forall s1 s2 s3 : srt_ecc,
   rules_ecc s1 s2 s3 -> univ x1 s1 -> univ x2 s2 -> univ x3 s3}.

End SortsOfECC.

Require Export GenericSort.

  Definition sort_of_gen (gs : gen_sort) : Exc srt_ecc :=
    match gs with
    | Gprop => value (Sprop Neg)
    | Gset => value (Sprop Pos)
    | Gtype n => value (Stype Neg n)
    | Gtypeset n => value (Stype Pos n)
    end.

  Definition gen_of_sort (s : srt_ecc) : gen_sort :=
    match s with
    | Sprop Neg => Gprop
    | Sprop Pos => Gset
    | Stype Neg n => Gtype n
    | Stype Pos n => Gtypeset n
    end. *)

Section ECC.

  Definition trm_ecc := term srt_ecc.
  Definition env_ecc := env srt_ecc.

  Definition ecc : CTS_spec srt_ecc :=
    Build_CTS_spec _ axiom_ecc rules_ecc univ_ecc (beta_delta_rule _).

  Definition ecc_pts : PTS_sub_spec srt_ecc := cts_pts_functor _ ecc.
  Definition le_type : red_rule srt_ecc :=
    Rule _ (Le_type _ (pts_le_type _ ecc_pts)).

  Definition typ_ecc : env_ecc -> trm_ecc -> trm_ecc -> Prop := typ _ ecc_pts.
  Definition wft_ecc : env_ecc -> trm_ecc -> Prop := wf_type _ ecc_pts.
  Definition wf_ecc : env_ecc -> Prop := wf _ ecc_pts.
  Definition ecc_sn := sn srt_ecc (ctxt _ (Rule _ (head_reduct _ ecc))).

  Hint Unfold le_type typ_ecc wft_ecc wf_ecc ecc_sn: pts.

  Lemma whnf :
   forall (e : env_ecc) (t : trm_ecc),
   ecc_sn e t ->
   {u : trm_ecc | red _ (beta_delta _) e t u & 
   head_normal _ (beta_delta _) e u}.
Proof beta_delta_whnf srt_ecc.

  Lemma bd_conv_hnf :
   forall (e : env_ecc) (x y : trm_ecc),
   ecc_sn e x ->
   ecc_sn e y -> decide (conv_hn_inv _ (beta_delta_rule _) e x y).
Proof
  CR_WHNF_convert_hn srt_ecc ecc_sort_dec (beta_delta_rule srt_ecc)
    (church_rosser_beta_delta srt_ecc) whnf.

  Theorem ecc_is_subtype_dec : subtype_dec_CTS _ ecc.
apply Build_subtype_dec_CTS.
exact (church_rosser_beta_delta srt_ecc).

exact (bd_hn_sort srt_ecc).

exact (bd_hn_prod srt_ecc).

exact whnf.

exact bd_conv_hnf.

exact univ_ecc_dec.
Qed.

  Axiom
    ecc_normalise :
      forall (e : env_ecc) (t T : trm_ecc), typ_ecc e t T -> ecc_sn e t.

  Lemma sound_ecc_bd : rule_sound _ ecc_pts (beta_delta _).
unfold beta_delta in |- *.
simpl in |- *.
unfold union in |- *.
apply union_sound.
apply beta_sound; auto with arith pts.
simpl in |- *.
apply cumul_inv_prod.
exact ecc_is_subtype_dec.

apply delta_sound.
Qed.

  Lemma ecc_is_norm_sound : norm_sound_CTS _ ecc.
Proof.
refine (Build_norm_sound_CTS srt_ecc ecc sound_ecc_bd ecc_normalise _ _ _).
left.
apply ecc_inf_axiom.

exact ecc_inf_rule.

intros.
elim ecc_inf_axiom with s1; intros.
split with x.
apply (pp_ok p).
Qed.

  Theorem ecc_algorithms : PTS_TC _ ecc_pts.
  Proof
    full_cts_type_checker srt_ecc ecc ecc_is_subtype_dec ecc_is_norm_sound.

  Lemma infer_type :
   forall (e : env_ecc) (t : trm_ecc),
   wf_ecc e -> infer_ppal_type _ ecc_pts e t.
Proof ptc_inf_ppal_type _ _ ecc_algorithms.

  Lemma check_wf_type :
   forall (e : env_ecc) (t : trm_ecc), wf_ecc e -> wft_dec _ ecc_pts e t.
Proof ptc_chk_wft _ _ ecc_algorithms.

  Lemma check_type :
   forall (e : env_ecc) (t T : trm_ecc),
   wf_ecc e -> check_dec _ ecc_pts e t T.
Proof ptc_chk_typ _ _ ecc_algorithms.

  Lemma add_type :
   forall (e : env_ecc) (t : trm_ecc),
   wf_ecc e -> decl_dec _ ecc_pts e (Ax _ t).
Proof ptc_add_typ _ _ ecc_algorithms.

  Lemma add_def :
   forall (e : env_ecc) (t T : trm_ecc),
   wf_ecc e -> decl_dec _ ecc_pts e (Def _ t T).
Proof ptc_add_def _ _ ecc_algorithms.

End ECC.