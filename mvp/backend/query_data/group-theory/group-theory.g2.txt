
Require Import Ensembles.
Require Import Laws.
(* Laws:
Require Import Ensembles.
Section Basic_laws.
Variable U : Type.
Variable op : U -> U -> U.

Definition commutative := forall x y : U, op x y = op y x.

Definition associative := forall x y z : U, op x (op y z) = op (op x y) z.

Definition left_neutral (e : U) := forall x : U, op e x = x.

Definition right_neutral (e : U) := forall x : U, op x e = x.

Definition left_inverse (inv : U -> U) (e : U) :=
  forall x : U, op (inv x) x = e.

Definition right_inverse (inv : U -> U) (e : U) :=
  forall x : U, op x (inv x) = e.
Variable D : Ensemble U.

Definition endo_function (f : U -> U) :=
  forall x : U, In U D x -> In U D (f x).

Definition endo_operation (op : U -> U -> U) :=
  forall x y : U, In U D x -> In U D y -> In U D (op x y).
End Basic_laws.
Hint Unfold endo_function endo_operation commutative associative left_neutral
  right_neutral left_inverse right_inverse. *)
Require Import Group_definitions.
(* Group_definitions:
Require Import Ensembles.
Require Import Laws.
Section group_definition.
Variable U : Type.

Record Group : Type := group
  {G_ : Ensemble U;
   star_ : U -> U -> U;
   inv_ : U -> U;
   e_ : U;
   G0_ : endo_operation U G_ star_;
   G1_ : associative U star_;
   G2a_ : In U G_ e_;
   G2b_ : left_neutral U star_ e_;
   G2c_ : right_neutral U star_ e_;
   G3a_ : endo_function U G_ inv_;
   G3b_ : right_inverse U star_ inv_ e_;
   G3c_ : left_inverse U star_ inv_ e_}.

Inductive subgroup (g1 g2 : Group) : Prop :=
    Definition_of_subgroup :
      Included U (G_ g1) (G_ g2) -> star_ g1 = star_ g2 -> subgroup g1 g2.

Definition Setsubgroup (E : Ensemble U) (Gr : Group) : Prop :=
  ex (fun g : Group => subgroup g Gr /\ G_ g = E).
End group_definition. *)
Require Import gr.
(* gr:
Require Import Ensembles.
Require Import Laws.
Require Import Group_definitions.
Section group_trivialities.
Variable U : Type.
Variable Gr : Group U.

Let G : Ensemble U := G_ U Gr.

Let star : U -> U -> U := star_ U Gr.

Let inv : U -> U := inv_ U Gr.

Let e : U := e_ U Gr.

Definition G0 : forall a b : U, In U G a -> In U G b -> In U G (star a b) :=
  G0_ U Gr.

Definition G1 : forall a b c : U, star a (star b c) = star (star a b) c :=
  G1_ U Gr.

Definition G2a : In U G e := G2a_ U Gr.

Definition G2b : forall a : U, star e a = a := G2b_ U Gr.

Definition G2c : forall a : U, star a e = a := G2c_ U Gr.

Definition G3a : forall a : U, In U G a -> In U G (inv a) := G3a_ U Gr.

Definition G3b : forall a : U, star a (inv a) = e := G3b_ U Gr.

Definition G3c : forall a : U, star (inv a) a = e := G3c_ U Gr.
Hint Resolve G1.
Hint Resolve G2a G2b G2c.
Hint Resolve G3a G3b G3c.
Hint Resolve G0.

Theorem triv1 : forall a b : U, star (inv a) (star a b) = b.

Theorem triv2 : forall a b : U, star (star b a) (inv a) = b.

Theorem resolve : forall a b : U, star b a = e -> b = inv a.

Theorem self_inv : e = inv e.

Theorem inv_star : forall a b : U, star (inv b) (inv a) = inv (star a b).

Theorem cancellation : forall a b : U, star a b = a -> b = e.

Theorem inv_involution : forall a : U, a = inv (inv a).
End group_trivialities.
Hint Resolve G1.
Hint Resolve G2a G2b G2c.
Hint Resolve G3a G3b G3c.
Hint Resolve G0.
Hint Resolve triv1 triv2 resolve self_inv inv_star inv_involution. *)
Require Import g1.
(* g1:
Require Import Ensembles.
Require Import Laws.
Require Import Group_definitions.
Require Import gr.
Parameter U : Type.
Parameter Gr : Group U.

Definition G : Ensemble U := G_ U Gr.

Definition star : U -> U -> U := star_ U Gr.

Definition inv : U -> U := inv_ U Gr.

Definition e : U := e_ U Gr.

Definition G0' : forall a b : U, In U G a -> In U G b -> In U G (star a b) :=
  G0 U Gr.

Definition G1' : forall a b c : U, star a (star b c) = star (star a b) c :=
  G1 U Gr.

Definition G2a' : In U G e := G2a U Gr.

Definition G2b' : forall a : U, star e a = a := G2b U Gr.

Definition G2c' : forall a : U, star a e = a := G2c U Gr.

Definition G3a' : forall a : U, In U G a -> In U G (inv a) := G3a U Gr.

Definition G3b' : forall a : U, star a (inv a) = e := G3b U Gr.

Definition G3c' : forall a : U, star (inv a) a = e := G3c U Gr.
Hint Resolve G1'.
Hint Resolve G2a' G2b' G2c'.
Hint Resolve G3a' G3b' G3c'.
Hint Resolve G0'.

Definition triv1' : forall a b : U, star (inv a) (star a b) = b := triv1 U Gr.

Definition triv2' : forall a b : U, star (star b a) (inv a) = b := triv2 U Gr.

Definition resolve' : forall a b : U, star b a = e -> b = inv a :=
  resolve U Gr.

Definition self_inv' : e = inv e := self_inv U Gr.

Definition inv_star' :
  forall a b : U, star (inv b) (inv a) = inv (star a b) := 
  inv_star U Gr.

Definition cancellation' : forall a b : U, star a b = a -> b = e :=
  cancellation U Gr.

Definition inv_involution' : forall a : U, a = inv (inv a) :=
  inv_involution U Gr.
Hint Resolve triv1' triv2' inv_star' resolve' inv_involution'.

Section Elements.
Variable H : Group U.
Variable sub : subgroup U H Gr.

Lemma l1 : Included U (G_ U H) G.
Hint Resolve l1.

Lemma eH_in_G : In U G (e_ U H).
Hint Resolve eH_in_G.

Lemma starH_is_star : star_ U H = star.
Hint Resolve starH_is_star.

Lemma eh_is_e : e_ U H = e.
Hint Resolve eh_is_e.

Theorem invH_is_inv : forall a : U, In U (G_ U H) a -> inv_ U H a = inv a.

Theorem Subgroup_inhabited : Inhabited U (G_ U H).

Theorem star_endo : endo_operation U (G_ U H) star.

Theorem inv_endo : endo_function U (G_ U H) inv.

End Elements.

Section Premier.

Variable H : Ensemble U.
Variable witness : U.
Variable inhabited : In U H witness.
Variable subset : Included U H G.
Variable hstar : endo_operation U H star.
Variable hinv : endo_function U H inv.
Hint Resolve inhabited subset hstar hinv.

Let assoc : associative U star.
Hint Resolve assoc.

Let eH : U := star (inv witness) witness.

Let eH_in_H : In U H eH.

Let eH_left_neutral : left_neutral U star eH.

Let eH_right_neutral : right_neutral U star eH.

Let inv_left_inverse : left_inverse U star inv eH.

Let inv_right_inverse : right_inverse U star inv eH.

Let GrH : Group U :=
  group U H star inv eH hstar assoc eH_in_H eH_left_neutral eH_right_neutral
    hinv inv_right_inverse inv_left_inverse.
Hint Resolve Definition_of_subgroup.

Theorem T_1_6_2 : Setsubgroup U H Gr.

End Premier.

Require Import Zbase.
Require Import Z_succ_pred.
Require Import Zadd.

Definition exp : Z -> U -> U.

Theorem exp_endo : forall (a : U) (n : Z), In U G a -> In U G (exp n a).
Hint Resolve exp_endo.

Lemma exp_unfold_pos :
 forall (a : U) (n : nat),
 In U G a -> exp (pos (S n)) a = star a (exp (pos n) a).

Lemma exp_unfold_neg :
 forall (a : U) (n : nat),
 In U G a -> exp (neg (S n)) a = star (inv a) (exp (neg n) a).

Lemma exp_l1 :
 forall (a : U) (n : nat),
 In U G a -> star a (exp (neg (S n)) a) = exp (neg n) a.
Hint Resolve exp_l1.

Lemma exp_l2 :
 forall (a : U) (n : Z), In U G a -> star a (exp n a) = exp (succZ n) a.

Lemma exp_l2' :
 forall (a : U) (n : Z), In U G a -> star (inv a) (exp n a) = exp (predZ n) a.
Hint Resolve exp_l2 exp_l2' exp_unfold_pos exp_unfold_neg.
Hint Immediate sym_eq.

Theorem add_exponents :
 forall (a : U) (m n : Z),
 In U G a -> star (exp m a) (exp n a) = exp (addZ m n) a.

Lemma exp_commut1 :
 forall (a : U) (m : Z), In U G a -> star (exp m a) a = star a (exp m a).

Lemma tech_opp_pos_negZ1 : forall n : nat, oppZ (pos n) = neg n.

Lemma tech_opp_pos_negZ2 : forall n : nat, oppZ (neg n) = pos n.

Theorem change_exponent_sign :
 forall (a : U) (m : Z), In U G a -> inv (exp m a) = exp (oppZ m) a.

Inductive powers (a : U) : Ensemble U :=
    In_powers : forall (m : Z) (x : U), x = exp m a -> In U (powers a) x.

Theorem powers_of_one_element :
 forall a : U, In U G a -> Setsubgroup U (powers a) Gr.

Section Second.

Variable H : Ensemble U.
Variable witness : U.
Variable h0 : In U H witness.
Variable h1 : Included U H G.
Variable h2 : forall a b : U, In U H a -> In U H b -> In U H (star a (inv b)).

Let eH : U := star witness (inv witness).

Theorem T_1_6_3 : Setsubgroup U H Gr.

End Second.

Theorem Ex1 : Setsubgroup U (Singleton U e) Gr.

Theorem Ex2 : Setsubgroup U (Singleton U e) Gr.

Lemma Ex3 : forall n : Z, exp n e = e.

Lemma Ex4 : powers e = Singleton U e.

Theorem Ex5 : Setsubgroup U (Singleton U e) Gr. *)

Theorem auxsub :
 forall (H : Group U) (x : U), subgroup U H Gr -> In U (G_ U H) x -> In U G x.
Proof.
intros H x H'; elim H'; auto with sets.
Qed.

Section Trois.

Variable H K : Group U.
Variable subH : subgroup U H Gr.
Variable subK : subgroup U K Gr.

Inductive Prod : Ensemble U :=
    Definition_of_Prod :
      forall x y z : U,
      In U (G_ U H) x -> In U (G_ U K) y -> star x y = z -> In U Prod z.
End Trois.

Section Quatre.
Variable H K : Group U.
Variable subH : subgroup U H Gr.
Variable subK : subgroup U K Gr.

Theorem T4 : Same_set U (Prod H K) (Prod K H) -> Setsubgroup U (Prod H K) Gr.
Proof.
generalize (auxsub H); intro tH; generalize (auxsub K); intro tK.
intro H'.
apply T_1_6_3 with (witness := e); auto with sets.
rewrite <- (G2c' e); auto with sets.
apply Definition_of_Prod with (x := e) (y := e); auto with sets.
rewrite <- (eh_is_e H); auto with sets.
rewrite <- (eh_is_e K); auto with sets.
red in |- *.
intros x H'0; elim H'0.
intros x0 y z H'1 H'2 H'3; rewrite <- H'3; auto with sets.
intros a b H'0 H'1.
generalize H'1; clear H'1.
elim H'0.
intros x y z H'1 H'2 H'3; rewrite <- H'3.
intro H'4; elim H'4.
intros x0 y0 z0 H'5 H'6 H'7; rewrite <- H'7.
rewrite <- (inv_star' x0 y0); auto with sets.
rewrite <- (G1' x y (star (inv y0) (inv x0))); auto with sets.
red in H'.
elim H'; intros H'8 H'9; red in H'9; clear H'.
rewrite (G1' y (inv y0) (inv x0)); auto with sets.
lapply (H'9 (star (star y (inv y0)) (inv x0)));
 [ intro H'10; elim H'10 | idtac ].
intros x1 y1 z1 H' H'11 H'12; rewrite <- H'12.
rewrite (G1' x x1 y1); auto with sets.
apply Definition_of_Prod with (x := star x x1) (y := y1); auto with sets.
rewrite <- (starH_is_star H); auto with sets.
apply Definition_of_Prod with (x := star y (inv y0)) (y := inv x0).
rewrite <- (starH_is_star K); auto with sets.
rewrite <- (invH_is_inv K); auto with sets.
rewrite <- (invH_is_inv H); auto with sets.
trivial with sets.
Qed.

Theorem T4R : Setsubgroup U (Prod H K) Gr -> Included U (Prod H K) (Prod K H).
Proof.
generalize (auxsub H); intro tH; generalize (auxsub K); intro tK.
intro H'; elim H'.
intros x H'0; red in |- *.
intros x0 H'1.
elim H'0; intros L1 L2; clear H'0.
generalize (auxsub x); intro tx.
cut (exists t : U, In U (Prod H K) t /\ t = inv x0).
intro H'2; elim H'2.
intros x1 H'3; elim H'3; intros H'4 H'5; try exact H'4; clear H'3.
generalize H'5.
elim H'4.
intros x2 y z H'3 H'6 H'7; rewrite <- H'7.
intro H'8.
rewrite (inv_involution' x0); auto with sets.
rewrite <- H'8.
rewrite <- (inv_star' x2 y); auto with sets.
apply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.
rewrite <- (invH_is_inv K subK y); auto with sets.
rewrite <- (invH_is_inv H subH x2); auto with sets.
generalize H'1.
rewrite <- L2; auto with sets.
intro H'0.
apply ex_intro with (x := inv x0).
split; [ idtac | trivial with sets ].
rewrite <- (invH_is_inv x L1 x0); auto with sets.
Qed.

Theorem T4R1 :
 Setsubgroup U (Prod H K) Gr -> Included U (Prod K H) (Prod H K).
Proof.
generalize (auxsub H); intro tH; generalize (auxsub K); intro tK.
intro H'; elim H'.
intros x H'0; red in |- *.
intros x0 H'1.
elim H'0; intros L1 L2; clear H'0.
generalize (auxsub x); intro tx.
cut (exists t : U, In U (Prod K H) t /\ t = inv (inv x0)).
intro H'0; elim H'0.
intros x1 H'2.
elim H'2; intros H'3 H'4; generalize H'4; clear H'2.
elim H'3.
intros x2 y z H'2 H'5 H'6; rewrite <- H'6.
intro H'7.
rewrite (inv_involution' x0).
rewrite <- H'7.
rewrite (inv_involution' (star x2 y)).
rewrite <- (inv_star' x2 y).
rewrite <- (invH_is_inv x L1 (star (inv y) (inv x2))).
rewrite <- L2; auto with sets.
elim L1; simpl in |- *; auto with sets.
intros H'15 H'16; apply (G3a_ U x); auto with sets.
rewrite L2.
apply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.
rewrite <- (invH_is_inv H subH y); auto with sets.
rewrite <- (invH_is_inv K subK x2); auto with sets.
rewrite L2.
apply Definition_of_Prod with (x := inv y) (y := inv x2); auto with sets.
rewrite <- (invH_is_inv H subH y); auto with sets.
rewrite <- (invH_is_inv K subK x2); auto with sets.
elim H'1; intros x3 y0 z0 H'8 H'9 H'10; rewrite <- H'10.
apply ex_intro with (x := star x3 y0).
split; [ idtac | auto with sets ].
apply Definition_of_Prod with (x := x3) (y := y0); trivial with sets.
Qed.
Hint Resolve T4 T4R T4R1.

Theorem T_1_6_8 :
 Same_set U (Prod H K) (Prod K H) <-> Setsubgroup U (Prod H K) Gr.
Proof.
red in |- *; auto with sets.
Qed.
End Quatre.
