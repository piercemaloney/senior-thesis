

Require Import Ensembles.

Require Import Zbase.
(* Zbase:
Inductive Z : Set :=
  | OZ : Z
  | pos : nat -> Z
  | neg : nat -> Z.

Definition IZ := pos 0.

Definition is_posn (x y : Z) :=
  match x, y with
  | pos n, pos m => n = m
  | _, _ => False
  end.

Lemma tech_pos_not_posZ : forall n m : nat, n <> m -> pos n <> pos m.

Lemma eq_OZ_dec : forall x : Z, {x = OZ} + {x <> OZ}.

Definition posOZ (n : nat) :=
  match n return Z with
  | O => OZ
  | S n' => pos n'
  end.

Definition negOZ (n : nat) :=
  match n return Z with
  | O => OZ
  | S n' => neg n'
  end.

Definition absZ (x : Z) :=
  match x return Z with
  | OZ => OZ
  | pos n => pos n
  | neg n => pos n
  end.

Definition sgnZ (x : Z) :=
  match x return Z with
  | OZ => OZ
  | pos n => pos 0
  | neg n => neg 0
  end. *)

Require Import Z_succ_pred.
(* Z_succ_pred:
Require Import Arith.
Require Import Zbase.

Definition succZ (x : Z) :=
  match x return Z with
  | OZ => IZ
  | pos n => pos (S n)
  | neg n => match n return Z with
             | O => OZ
             | S m => neg m
             end
  end.

Definition predZ (x : Z) :=
  match x return Z with
  | OZ => neg 0
  | pos n => match n return Z with
             | O => OZ
             | S m => pos m
             end
  | neg n => neg (S n)
  end.

Lemma pred_succZ : forall x : Z, predZ (succZ x) = x.

Lemma succ_predZ : forall x : Z, succZ (predZ x) = x.

Lemma succ_pred_pred_succZ : forall x : Z, succZ (predZ x) = predZ (succZ x).

Lemma tech_pred_posZ : forall n : nat, 0 < n -> predZ (pos n) = pos (pred n).

Lemma tech_succ_posOZ : forall n : nat, succZ (posOZ n) = pos n. *)

Require Import Zadd.
(* Zadd:
Require Import Arith.
Require Import Nat_complements.
Require Import Zbase.
Require Import Z_succ_pred.

Fixpoint add1 (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => succZ x2
  | S n0 => succZ (add1 x2 n0)
  end
 
 with add2 (x2 : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => predZ x2
  | S n0 => predZ (add2 x2 n0)
  end.

Definition addZ (x1 x2 : Z) : Z :=
  match x1 with
  | OZ => x2
  | pos n => add1 x2 n
  | neg n => add2 x2 n
  end.

Lemma addZ_eq1 : forall y : Z, addZ OZ y = y. 

Lemma addZ_eq2 : forall y : Z, addZ (pos 0) y = succZ y.

Lemma addZ_eq3 :
 forall (n1 : nat) (y : Z), addZ (pos (S n1)) y = succZ (addZ (pos n1) y).

Lemma addZ_eq4 : forall y : Z, addZ (neg 0) y = predZ y.

Lemma addZ_eq5 :
 forall (n1 : nat) (y : Z), addZ (neg (S n1)) y = predZ (addZ (neg n1) y).

Lemma succ_addZ_l : forall x y : Z, addZ (succZ x) y = succZ (addZ x y).

Lemma pred_addZ_l : forall x y : Z, addZ (predZ x) y = predZ (addZ x y).

Lemma tech_add_pos_succZ :
 forall (x : nat) (y : Z), addZ (pos (S x)) y = succZ (addZ (pos x) y).
Proof addZ_eq3.

Lemma tech_add_neg_predZ :
 forall (x : nat) (y : Z), addZ (neg (S x)) y = predZ (addZ (neg x) y).
Proof addZ_eq5.

Lemma succ_addZ_r : forall x y : Z, addZ x (succZ y) = succZ (addZ x y).

Lemma pred_addZ_r : forall x y : Z, addZ x (predZ y) = predZ (addZ x y).

Lemma add_OZ : forall x : Z, addZ x OZ = x.

Lemma add_IZ_succZ : forall x : Z, addZ x IZ = succZ x.

Lemma add_mIZ_predZ : forall x : Z, addZ x (neg 0) = predZ x.

Definition commutative (U : Set) (op : U -> U -> U) :=
  forall x y : U, op x y = op y x.

Theorem addZ_commutativity : commutative Z addZ.

Lemma tech_add_pos_neg_posZ :
 forall n1 n2 : nat, n2 < n1 -> addZ (pos n1) (neg n2) = pos (n1 - S n2).

Definition associative (U : Set) (op : U -> U -> U) :=
  forall x y z : U, op x (op y z) = op (op x y) z.

Theorem addZ_associativity : associative Z addZ.

Definition IdZ (x : Z) := True.

Definition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) 
  (O : S) := G O /\ (forall x : S, G x -> Add x O = x /\ Add O x = x).

Theorem addZ_neutral : neutral Z IdZ addZ OZ.

Definition oppZ (x : Z) :=
  match x return Z with
  | OZ => OZ
  | pos n => neg n
  | neg n => pos n
  end.

Lemma opp_succZ : forall x : Z, oppZ (succZ x) = predZ (oppZ x).

Lemma opp_predZ : forall x : Z, oppZ (predZ x) = succZ (oppZ x).

Lemma tech_add_pos_negZ : forall n : nat, addZ (pos n) (neg n) = OZ.

Lemma tech_add_neg_posZ : forall n : nat, addZ (neg n) (pos n) = OZ.

Lemma tech_add_pos_posZ :
 forall n m : nat, addZ (pos n) (pos m) = pos (S (n + m)).

Lemma tech_add_neg_negZ :
 forall n m : nat, addZ (neg n) (neg m) = neg (S (n + m)).

Theorem abs_eq_or_oppZ : forall x : Z, {absZ x = x} + {absZ x = oppZ x}.

Lemma tech_opp_pos_negZ :
 forall n : nat, oppZ (pos n) = neg n /\ oppZ (neg n) = pos n. *)

Require Import Zle.
(* Zle:
Require Import Arith.
Require Import Zbase.
Require Import Z_succ_pred.
Require Import Zadd.

Definition leZ (x y : Z) :=
  match x return Prop with
  | OZ =>
      match y return Prop with
      | OZ => True
      | pos n => True
      | neg n => False
      end
  | pos n =>
      match y return Prop with
      | OZ => False
      | pos m => n <= m
      | neg m => False
      end
  | neg n =>
      match y return Prop with
      | OZ => True
      | pos m => True
      | neg m => m <= n
      end
  end.

Lemma sign_absZ : forall x : Z, leZ OZ (absZ x).

Lemma tech_le_pos_abs : forall x : Z, leZ OZ x -> absZ x = x.

Theorem leZ_antisymmetric : forall x y : Z, leZ x y -> leZ y x -> x = y.

Definition ltZ (x y : Z) := leZ (succZ x) y.

Definition lt_absZ (x y : Z) := ltZ (absZ x) (absZ y).

Lemma tech_lt_abs_OZ : forall x : Z, lt_absZ x (pos 0) -> x = OZ.

Lemma tech_posOZ_pos : forall n : nat, leZ OZ (posOZ n).

Lemma le_opp_OZ_l : forall x : Z, leZ OZ x -> leZ (oppZ x) OZ.

Lemma le_opp_OZ :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = OZ.

Let opp_inv : forall x y : Z, x = oppZ y -> y = oppZ x.

Lemma le_opp_OZ2 :
 forall x y : Z, x = oppZ y -> leZ OZ x -> leZ OZ y -> x = y. *)

Require Import Classical_Prop.

Require Import Relations_1.

Require Import Relations_1_facts.

Require Import Partial_Order.

Require Import Cpo.

Require Import Powerset.

Require Import Powerset_facts.

Require Import Gt.

Require Import Lt.

Require Import Compare.

Require Import Arith.

Require Import Finite_sets.

Require Import Finite_sets_facts.

Require Import Image.

Require Import Infinite_sets.

Require Import Integers.

Require Import Laws.
(* Laws:
Require Import Ensembles.
Section Basic_laws.
Variable U : Type.
Variable op : U -> U -> U.

Definition commutative := forall x y : U, op x y = op y x.

Definition associative := forall x y z : U, op x (op y z) = op (op x y) z.

Definition left_neutral (e : U) := forall x : U, op e x = x.

Definition right_neutral (e : U) := forall x : U, op x e = x.

Definition left_inverse (inv : U -> U) (e : U) :=
  forall x : U, op (inv x) x = e.

Definition right_inverse (inv : U -> U) (e : U) :=
  forall x : U, op x (inv x) = e.
Variable D : Ensemble U.

Definition endo_function (f : U -> U) :=
  forall x : U, In U D x -> In U D (f x).

Definition endo_operation (op : U -> U -> U) :=
  forall x y : U, In U D x -> In U D y -> In U D (op x y).
End Basic_laws.
Hint Unfold endo_function endo_operation commutative associative left_neutral
  right_neutral left_inverse right_inverse. *)

Require Import Group_definitions.
(* Group_definitions:
Require Import Ensembles.
Require Import Laws.
Section group_definition.
Variable U : Type.

Record Group : Type := group
  {G_ : Ensemble U;
   star_ : U -> U -> U;
   inv_ : U -> U;
   e_ : U;
   G0_ : endo_operation U G_ star_;
   G1_ : associative U star_;
   G2a_ : In U G_ e_;
   G2b_ : left_neutral U star_ e_;
   G2c_ : right_neutral U star_ e_;
   G3a_ : endo_function U G_ inv_;
   G3b_ : right_inverse U star_ inv_ e_;
   G3c_ : left_inverse U star_ inv_ e_}.

Inductive subgroup (g1 g2 : Group) : Prop :=
    Definition_of_subgroup :
      Included U (G_ g1) (G_ g2) -> star_ g1 = star_ g2 -> subgroup g1 g2.

Definition Setsubgroup (E : Ensemble U) (Gr : Group) : Prop :=
  ex (fun g : Group => subgroup g Gr /\ G_ g = E).
End group_definition. *)

Require Export gr.

Require Export g1.



Section Cinq.

Variable H : Ensemble U.

Variable H_inhabited : Inhabited U H.

Variable H_included_in_G : Included U H G.

Variable stability : endo_operation U H star.

Variable H_Finite : Finite U H.



Let h : forall x y : U, In U H x -> In U H y -> In U H (star x y).

Proof.

auto.

Qed.

Hint Resolve h.



Definition phi (a : U) (n : nat) : U := exp (pos n) a.



Lemma phi_unfold :

 forall (a : U) (n : nat), In U G a -> phi a (S n) = star a (phi a n).

Proof.

unfold phi in |- *; auto.

Qed.



Lemma positive_powers :

 forall (a : U) (n : nat), In U H a -> In U H (phi a n).

Proof.

intros a n; elim n; auto.

intros n0 H' H'0.

rewrite (phi_unfold a n0); auto.

Qed.



Lemma tech_exp :

 forall (a : U) (n : nat), In U G a -> star (phi a n) a = phi a (S n).

Proof.

intros a n; elim n; auto.

intros n0 H' H'0.

rewrite (phi_unfold a n0); auto.

rewrite <- (G1' a (phi a n0) a).

rewrite H'; auto.

Qed.



Lemma tech_exp' : forall n : nat, phi e n = e.

Proof.

intro n; elim n; auto.

intros n0 H'.

rewrite <- (tech_exp e n0); auto.

rewrite H'; auto.

Qed.



Lemma phi_exp :

 forall (a : U) (n m : nat),

 In U G a -> star (phi a n) (phi a m) = phi a (S (n + m)).

Proof.

unfold phi in |- *.

intros a n m H'.

rewrite (add_exponents a (pos n) (pos m)); trivial.

rewrite (tech_add_pos_posZ n m); trivial.

Qed.



Lemma powers_repeat :

 forall (a : U) (n m : nat),

 In U G a -> phi a n = phi a (S (S (n + m))) -> phi a m = inv a.

Proof.

intros a n m H' H'0.

apply resolve'.

apply cancellation' with (a := phi a n).

rewrite (tech_exp a m); trivial.

rewrite (phi_exp a n (S m)); trivial.

rewrite <- (plus_n_Sm n m); auto.

Qed.



Definition psi := phi.



Lemma psi_not_inj : forall a : U, In U H a -> ~ injective nat U (psi a).

Proof.

intros a H'; try assumption.

apply Pigeonhole_bis with (A := Integers).

exact Integers_infinite.

apply Finite_downward_closed with (A := H); auto.

red in |- *.

intros x H'0; elim H'0.

intro x0.

intros H'1 y H'2; rewrite H'2.

unfold psi at 1 in |- *; simpl in |- *.

apply positive_powers; auto.

Qed.



Theorem remaining :

 forall a : U,

 In U H a ->

 exists r : nat, (exists m : nat, phi a r = phi a (S (S (r + m)))).

Proof.

intros a ainH.

lapply (not_injective_elim nat U (psi a));

 [ intro H'2 | apply psi_not_inj; auto ].

elim H'2; clear H'2.

intros x H'.

elim H'; clear H'.

intros x0 H'0; elim H'0; clear H'0.

intros H'0 H'1.

unfold psi in H'0; simpl in H'0.

cut (x0 <> x).

2: red in |- *; intro H'4; apply H'1; rewrite <- H'4; auto.

intro H'.

elim (nat_total_order x0 x).

clear H'1 H'.

intro H'.

lapply (discrete_nat x0 x); [ intro H'4 | assumption ].

elim H'4; intro H'1; clear H'4.

exists x0; exists 0.

generalize H'0.

rewrite <- H'1.

rewrite <- (tech_exp a x0).

intro H'3.

lapply (sym_eq (x:=phi a x0) (y:=star (phi a x0) a));

 [ intro H'9 | rewrite H'3; auto ].

lapply (cancellation' (phi a x0) a); [ intro H'8 | assumption ].

rewrite H'8.

rewrite (tech_exp' x0).

rewrite (tech_exp' (S (S (x0 + 0)))); auto.

auto.

elim H'1; intros r E; clear H'1.

exists x0; exists r.

rewrite <- E; auto.

clear H'1 H'.

intro H'.

lapply (discrete_nat x x0); [ intro H'4 | assumption ].

elim H'4; intro H'1; clear H'4.

exists x; exists 0.

generalize H'0.

rewrite <- H'1.

rewrite <- (tech_exp a x).

intro H'3.

lapply (cancellation' (phi a x) a); [ intro H'8 | rewrite <- H'3; auto ].

rewrite H'8.

rewrite (tech_exp' x).

rewrite (tech_exp' (S (S (x + 0)))); auto.

auto.

elim H'1; intros r E; clear H'1.

exists x; exists r.

rewrite <- E; auto.

auto.

Qed.



Theorem T_1_6_4 : Setsubgroup U H Gr.

Proof.

elim H_inhabited.

intros witness inH.

apply T_1_6_2 with (witness := witness); trivial.

red in |- *.

intros a H'.

cut (exists n : nat, inv a = phi a n).

intro H'0; elim H'0; intros n E; rewrite E; clear H'0.

apply positive_powers; trivial.

cut (exists r : nat, ex (fun m : nat => phi a r = phi a (S (S (r + m))))).

intro H'0; elim H'0; intros r E; elim E; intros m E0; try exact E0;

 clear E H'0.

cut (inv a = phi a m).

intro H'0; rewrite H'0.

exists m; trivial.

symmetry  in |- *.

apply powers_repeat with (n := r); trivial.

apply H_included_in_G; auto.

apply remaining; auto.

Qed.



End Cinq.



