
Set Implicit Arguments.
Unset Strict Implicit. 
Require Export arb_intersections.
(* arb_intersections:
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Parts2.
Require Export Classical_Pred_Type.
Section MAIN.
Section indexed_int.

Variable A : Setoid.
Variable I : Setoid.
Variable f : MAP I (part_set A). 
 
Definition indexed_intersection : part_set A.

Lemma indexed_intersection_included_in_subsets :
 forall i : I, included indexed_intersection (f i).

Lemma in_indexed_intersection_then_in_subsets :
 forall a : A,
 in_part a indexed_intersection -> forall i : I, in_part a (f i).

Lemma in_subsets_then_in_indexed_intersection :
 forall a : A,
 (forall i : I, in_part a (f i)) -> in_part a indexed_intersection.

Lemma not_in_part_then_not_in_indexed_intersection :
 forall a : A,
 (exists i : I, ~ in_part a (f i)) -> ~ in_part a indexed_intersection.

Lemma not_in_indexed_intersection_then_not_in_part :
 forall a : A,
 ~ in_part a indexed_intersection -> exists i : I, ~ in_part a (f i).

Lemma subset_included_then_indexed_intersection_included :
 forall B : part_set A,
 (exists i : I, included (f i) B) -> included indexed_intersection B.

End indexed_int.

Let range (A B : Setoid) (f : MAP A B) := image f (full A).

Section Compatibility_of_indexed_intersections.
Variable A : Setoid.
Variable I : Setoid.

Lemma indexed_intersection_comp :
 forall f g : MAP I (part_set A),
 Equal f g -> Equal (indexed_intersection f) (indexed_intersection g).

Variable J : Setoid.
Lemma indexed_intersection_indep_of_indexing :
 forall (f : MAP I (part_set A)) (g : MAP J (part_set A)),
 Equal (range f) (range g) ->
 Equal (indexed_intersection f) (indexed_intersection g).
End Compatibility_of_indexed_intersections.

Lemma empty_indexed_intersection_gives_full_set :
 forall (A : Setoid) (f : MAP (empty A) (part_set A)),
 Equal (indexed_intersection f) (full A).

Definition intersection :
  forall A : Setoid, part_set (part_set A) -> part_set A.

Section intersection_v_indexed_intersection.

Lemma intersection_to_indexed_intersection :
 forall (A I : Setoid) (f : MAP I (part_set A)),
 Equal (intersection (range f)) (indexed_intersection f).

End intersection_v_indexed_intersection.
End MAIN. *)
Require Export conshdtl.
(* conshdtl:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
From Algebra Require Export Parts.

Section MAIN.

Definition conseq :
  forall (A : Setoid) (n : Nat) (a : A) (v : seq n A), seq (S n) A.

Notation "a ;; b" := (conseq a b) (at level 60, right associativity).

Variables (A : Setoid) (n : Nat) (a : A).

Lemma cons_comp :
 forall (a' : A) (v v' : seq n A),
 a =' a' in _ -> v =' v' in _ -> a;; v =' a';; v' in _.

Hint Resolve cons_comp: algebra.

Lemma cons_first_element :
 forall (v : seq n A) (H : 0 < S n), (a;; v) (Build_finiteT H) =' a in _.

Definition head (A : Setoid) (n : Nat) (v : seq (S n) A) :=
  v (Build_finiteT (lt_O_Sn n)).

Lemma head_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq (S n) A),
 v =' v' in _ -> head v =' head v' in _.

Hint Resolve head_comp cons_first_element: algebra.

Lemma head_unfolding1 :
 forall v : seq (S n) A,
 v (Build_finiteT (lt_O_Sn n)) =' a in _ -> head v =' a in _.

Lemma head_unfolding2 :
 forall v : seq (S n) A,
 a =' v (Build_finiteT (lt_O_Sn n)) in _ -> a =' head v in _.

Hint Resolve head_unfolding1 head_unfolding2: algebra.
Hint Extern 0 (head _ =' _ in _) => unfold head in |- *: algebra.
Hint Extern 0 (_ =' head _ in _) => unfold head in |- *: algebra.

Lemma head_cons_inv : forall v : seq n A, head (a;; v) =' a in _.

Hint Resolve head_cons_inv: algebra.

Lemma seq_S_O_contains_single_elt :
 forall (A : Setoid) (v : seq 1 A) (i : fin 1), v i =' head v in _.

Hint Resolve seq_S_O_contains_single_elt: algebra.

Lemma seq_S_O_head_fixes_everything :
 forall (A : Setoid) (v v' : seq 1 A), head v =' head v' in _ -> v =' v' in _.

Hint Resolve seq_S_O_head_fixes_everything: algebra.

Lemma cons_later_elements :
 forall (v : seq n A) (i : Nat) (Hi : S i < S n) (Hi' : i < n),
 (a;; v) (Build_finiteT Hi) =' v (Build_finiteT Hi') in _.

Hint Resolve cons_later_elements: algebra.

Definition Seqtl : forall n : Nat, seq n A -> seq (pred n) A. 

Lemma Seqtl_comp :
 forall v v' : seq n A, v =' v' in _ -> Seqtl v =' Seqtl v' in _.

Hint Resolve Seqtl_comp: algebra.

Definition hdtl (v : seq (S n) A) := head v;; Seqtl v:seq (S n) A.

Lemma conseq_hdtl :
 forall (v : seq (S n) A) (H : 0 < S n),
 v =' v (Build_finiteT H);; Seqtl v in _.

Hint Resolve conseq_hdtl: algebra.

Lemma hdtl_x_is_x : forall v : seq (S n) A, v =' hdtl v in _.

Hint Resolve hdtl_x_is_x: algebra.
Hint Extern 0 (head _;; Seqtl _ =' _ in _) =>
  fold hdtl in |- *; apply Sym; apply hdtl_x_is_x: algebra.
Hint Extern 0 (_ =' head _;; Seqtl _ in _) =>
  fold hdtl in |- *; apply hdtl_x_is_x: algebra.

Lemma cons_lemma_nice :
 forall P : Predicate (seq (S n) A),
 (forall (a : A) (v : seq n A), Pred_fun P (a;; v)) ->
 forall w : seq (S n) A, Pred_fun P w.

Lemma cons_lemma_verynice :
 forall (P : Predicate (seq (S n) A)) (H : 0 < S n) (w : seq (S n) A),
 Pred_fun P (w (Build_finiteT H);; Seqtl w) -> Pred_fun P w.

Lemma Seqtl_cons_inv : forall v : seq n A, Seqtl (a;; v) =' v in _.

Hint Resolve Seqtl_cons_inv: algebra.

Lemma Seqtl_to_seq :
 forall (v : seq (S n) A) (i : Nat) (Hi : i < n) (HSi : S i < S n),
 Seqtl v (Build_finiteT Hi) =' v (Build_finiteT HSi) in _.

Hint Resolve Seqtl_to_seq: algebra.

Lemma split_hd_tl_equality :
 forall v w : seq (S n) A,
 head v =' head w in _ -> Seqtl v =' Seqtl w in _ -> v =' w in _.

Hint Resolve split_hd_tl_equality: algebra.
End MAIN.

Notation "a ;; b" := (conseq a b) (at level 60, right associativity).

Hint Resolve cons_comp: algebra.
Hint Resolve head_comp cons_first_element: algebra.
Hint Resolve head_unfolding1 head_unfolding2: algebra.
Hint Extern 0 (head _ =' _ in _) => unfold head in |- *: algebra.
Hint Extern 0 (_ =' head _ in _) => unfold head in |- *: algebra.
Hint Resolve head_cons_inv: algebra.
Hint Resolve cons_later_elements: algebra.
Hint Resolve Seqtl_comp: algebra.
Hint Resolve conseq_hdtl: algebra.
Hint Resolve hdtl_x_is_x: algebra.
Hint Extern 0 (head _;; Seqtl _ =' _ in _) =>
  fold hdtl in |- *; apply Sym; apply hdtl_x_is_x: algebra.
Hint Extern 0 (_ =' head _;; Seqtl _ in _) =>
  fold hdtl in |- *; apply hdtl_x_is_x: algebra.
Hint Resolve Seqtl_cons_inv: algebra.
Hint Resolve Seqtl_to_seq: algebra.
Hint Resolve split_hd_tl_equality: algebra.
Hint Resolve seq_S_O_contains_single_elt: algebra.
Hint Resolve seq_S_O_head_fixes_everything: algebra. *)
From Algebra Require Export Inter.

Fixpoint repeated_inter (A : Setoid) (n : nat) {struct n} :
 seq n (part_set A) -> part_set A :=
  match n return (seq n (part_set A) -> part_set A) with
  | O => fun v : seq 0 _ => full A
  | S n' => fun v : seq (S n') _ => inter (head v) (repeated_inter (Seqtl v))
  end.

Lemma indexed_intersection_as_repeated_inter :
 forall (n : nat) (A : Setoid) (f : seq n (part_set A)),
 indexed_intersection f =' repeated_inter f in _.
intros.
induction n.
assert (Map (empty A) (part_set A)).
assert (empty A -> part_set A).
intro x; destruct x; simpl in subtype_prf; contradiction.
apply Build_Map with X.
red in |- *.
intro x; destruct x; simpl in subtype_prf; contradiction.
apply Trans with (indexed_intersection X); auto with algebra.
apply indexed_intersection_indep_of_indexing.
simpl in |- *.
red in |- *; simpl in |- *.
split; intro H; inversion_clear H.
destruct x0.
inversion_clear in_range_prf.
destruct x0.
simpl in subtype_prf.
contradiction.
simpl in |- *.
apply empty_indexed_intersection_gives_full_set.
split; intros.
split.
unfold head in |- *; auto.
elim (IHn (Seqtl f)) with x.
intros.
apply H0.
simpl in H; simpl in |- *.
destruct i; auto.
assert (in_part x (inter (head f) (repeated_inter (Seqtl f)))).
auto.
simpl in |- *.
intros.
destruct i.
destruct index as [| n0].
elim H0; intros H1 _.
unfold head in H1.
apply in_part_comp_r with (f (Build_finiteT (lt_O_Sn n))); auto with algebra.
apply in_part_comp_r with (Seqtl f (Build_finiteT (lt_S_n _ _ in_range_prf)));
 auto with algebra.
elim H0; intros _ H1.
assert (in_part x (indexed_intersection (Seqtl f))).
elim (IHn (Seqtl f)) with x.
auto.
simpl in H2; simpl in |- *.
generalize (H2 (Build_finiteT (lt_S_n _ _ in_range_prf))).
auto.
Qed.
