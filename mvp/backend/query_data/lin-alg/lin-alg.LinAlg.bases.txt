
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
(* lin_dependence:
Set Implicit Arguments.
Unset Strict Implicit.
Section MAIN.
From Algebra Require Export Union.
Require Export subspaces.
Require Export cast_between_subsets.
Require Export mult_by_scalars.
Require Export sums.
Require Export seq_set_seq.
Require Export distinct.
Require Export const.

Section defs.
Variable F : field.
Variable V : vectorspace F.

Definition lin_dep (X : part_set V) :=
  exists n : Nat,
    (exists a : seq (S n) F,
       (exists v : seq (S n) X,
          distinct v /\
          ~ a =' const_seq (S n) (zero F) in _ /\
          sum (mult_by_scalars a (Map_embed v)) =' (zero V) in _)).

Definition lin_indep (X : part_set V) := ~ lin_dep X.

Definition lin_indep' (X : part_set V) :=
  forall (n : Nat) (a : seq (S n) F) (v : seq (S n) X),
  distinct v ->
  ~ a =' const_seq (S n) (zero F) in _ ->
  ~ sum (mult_by_scalars a (Map_embed v)) =' (zero V) in _.

Lemma lin_dep_comp :
 forall X Y : part_set V, X =' Y in _ -> lin_dep X -> lin_dep Y.

Lemma lin_indep_comp :
 forall X Y : part_set V, X =' Y in _ -> lin_indep X -> lin_indep Y.

Lemma lin_dep_defs_eqv : forall X : part_set V, lin_indep X <-> lin_indep' X.
End defs.

Section unexpected_true_results.

Lemma zero_imp_lin_dep :
 forall (F : field) (V : vectorspace F) (X : part_set V),
 in_part (zero V) X -> lin_dep X.

Lemma empty_lin_indep :
 forall (F : field) (V : vectorspace F), lin_indep (empty V).
End unexpected_true_results.

Section more.
Variable F : field.
Variable V : vectorspace F.

Lemma lin_dep_include :
 forall S1 S2 : part_set V, included S1 S2 -> lin_dep S1 -> lin_dep S2.

Lemma lin_indep_include :
 forall S1 S2 : part_set V, included S1 S2 -> lin_indep S2 -> lin_indep S1.

Lemma lin_indep_prop :
 forall (n : Nat) (a : seq n F) (v : seq n V),
 distinct v ->
 lin_indep (seq_set v) ->
 sum (mult_by_scalars a v) =' (zero V) in _ -> a =' const_seq n (zero F) in _.

Lemma lin_indep_doesn't_contain_zero :
 forall X : part_set V, lin_indep X -> ~ in_part (zero V) X.

Lemma inject_subsets_lin_dep :
 forall (W : subspace V) (X : part_set W),
 lin_dep X <-> lin_dep (inject_subsets X).
End more.

Definition max_lin_indep (F : field) (V : vectorspace F)
  (X Y : part_set V) :=
  included X Y /\
  lin_indep X /\
  (forall y : V, in_part y Y -> ~ in_part y X -> lin_dep (union X (single y))).

End MAIN. *)
Require Export spans.
(* spans:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export lin_combinations.
Require Export subspaces.

Section spans.
Variable F : field.
Variable V : vectorspace F.
Definition span_set (S : part_set V) : part_set V := is_lin_comb_pred S.

Definition span : part_set V -> subspace V.

Lemma span_comp :
 forall S S' : part_set V, S =' S' in _ -> span S =' span S' in part_set V.

Lemma span_is_subspace : forall S : part_set V, is_subspace (span S).
End spans.

Hint Resolve span_comp: algebra.

Section spans_inductively_defined.
Variable F : field.
Variable V : vectorspace F.
Variable S : part_set V.

Inductive span_ind_formal : Type :=
  | Zerovector : span_ind_formal
  | Immediately : S -> span_ind_formal
  | Plusvector : span_ind_formal -> span_ind_formal -> span_ind_formal
  | Multvector : F -> span_ind_formal -> span_ind_formal.

Fixpoint span_ind_injection (X : span_ind_formal) : V :=
  match X with
  | Zerovector => zero V
  | Immediately s => subtype_elt s
  | Plusvector x y => span_ind_injection x +' span_ind_injection y
  | Multvector a x => a mX span_ind_injection x
  end.

Definition span_ind_set : part_set V.

Definition span_ind : subspace V.

Definition lin_comb_ind (v : V) : Prop := in_part v span_ind.
End spans_inductively_defined.

Section spans_eqv.

Variable F : field.
Variable V : vectorspace F.

Lemma span_ind_eqv_span :
 forall (S : part_set V) (v : V), is_lin_comb v S <-> lin_comb_ind S v.

Lemma span_is_span_ind :
 forall S : part_set V, span S =' span_ind S in part_set V.

Lemma span_ind_comp :
 forall S S' : part_set V,
 S =' S' in _ -> span_ind S =' span_ind S' in part_set V.

End spans_eqv.

Hint Resolve span_is_span_ind span_ind_comp: algebra.

Section a_nice_fact_on_spans.

Lemma span_smallest_subspace_containing_subset :
 forall (F : field) (V : vectorspace F) (W : subspace V) (S : part_set V),
 included S W -> included (span S) W.

Lemma set_included_in_its_span :
 forall (F : field) (V : vectorspace F) (S : part_set V), included S (span S).

End a_nice_fact_on_spans.

Hint Resolve set_included_in_its_span: algebra.

Definition generates (F : field) (V : vectorspace F) 
  (S W : part_set V) := span S =' W in part_set V.

Lemma generates_comp :
 forall (F : field) (V : vectorspace F) (S S' W W' : part_set V),
 S =' S' in _ -> W =' W' in _ -> generates S W -> generates S' W'.

Lemma generated_subsets_are_subspaces :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> is_subspace W.

Lemma is_lin_comb_from_generates :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> forall x : V, in_part x W -> is_lin_comb x S.

Lemma generates_then_is_lin_comb :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> forall x : V, in_part x W -> is_lin_comb x S.

Lemma is_lin_comb_from_generates' :
 forall (F : field) (V : vectorspace F) (S : part_set V) (W : subspace V),
 generates S W -> forall x : W, is_lin_comb (subtype_elt x) S. *)
Require Export random_facts.
(* random_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Section MAIN.
Require Export concat_facts.
Require Export sums2.
Require Export mult_by_scalars.
Require Export vecspace_Fn.

Lemma inject_map_embed_seq_set :
 forall (A : Setoid) (B : part_set A) (n : Nat) (v : seq n B),
 inject_subsets (seq_set v) =' seq_set (Map_embed v) in _.

Section concat_const_seq.
Variable A : Setoid.
Let eqa : forall a : A, Predicate A.

Lemma concat_const_seq :
 forall (n m : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ ->
 const_seq n a ++ const_seq m a' =' const_seq (n + m) a'' in _.
End concat_const_seq.

Section mult_facts.
Variable F : field.
Variable V : vectorspace F.
Lemma mult_const_Zero :
 forall (n : Nat) (v : seq n V),
 mult_by_scalars (const_seq n (zero F)) v =' const_seq n (zero V) in seq _ _.

Lemma mult_const_zero :
 forall (n : Nat) (a : seq n F),
 mult_by_scalars a (const_seq n (zero V)) =' const_seq n (zero V) in seq _ _.
End mult_facts.

Hint Resolve mult_const_Zero mult_const_Zero: algebra.

Section proj_via_mult_by_scalars.

Let basisvec0prop :
  forall (F : field) (n : Nat) (H : 0 < S n),
  Seqtl (Basisvec_Fn F H) =' const_seq n (zero F) in _.

Let basisvecprop2 :
  forall (F : field) (n i : Nat) (H : i < n) (HS : S i < S n),
  Seqtl (Basisvec_Fn F HS) =' Basisvec_Fn F H in _.

Lemma projection_via_mult_by_scalars :
 forall (F : field) (M : module F) (n i : Nat) (Hi Hi' : i < n) (v : seq n M),
 v (Build_finiteT Hi) =' sum (mult_by_scalars (Basisvec_Fn F Hi') v) in _.

End proj_via_mult_by_scalars.

Lemma sum_of_sums :
 forall (n : Nat) (M : abelian_monoid) (v v' : seq n M),
 sum (pointwise (sgroup_law_map M) v v') =' sum v +' sum v' in _.

End MAIN. *)

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Section Defs.

Definition is_basis (X : part_set V) : Prop :=
  generates X (full V) /\ lin_indep X.

Lemma is_basis_comp :
 forall X Y : part_set V, X =' Y in _ -> is_basis X -> is_basis Y.
intros.
red in |- *; red in H0.
inversion_clear H0; split.
apply generates_comp with X (full V); auto with algebra.
apply lin_indep_comp with X; auto with algebra.
Qed.

Record basis : Type := 
  {basis_carrier :> Predicate V; is_basis_prf : is_basis basis_carrier}.
End Defs.

Lemma basis_prop : forall (X : basis) (x : V), is_lin_comb x X.
intros.
red in |- *.
elim X.
clear X.
intros X H.
red in H.
inversion_clear H.
red in H0.
unfold span in H0.
unfold is_lin_comb in H0.
simpl in H0.
red in H0.
simpl in H0.
generalize (H0 x).
clear H0.
unfold is_lin_comb in |- *.
intros (H', H0).
apply H0; auto with algebra.
Qed.

Lemma basis_prop_strong :
 forall (n : Nat) (v : seq n V),
 is_basis (seq_set v) ->
 forall x : V, exists a : seq n F, sum (mult_by_scalars a v) =' x in _.
intros.
generalize (basis_prop (Build_basis H) x).
intro.
generalize (span_ind_eqv_span (seq_set v) x).
intros.
inversion_clear H1.
generalize (H2 H0).
clear H0 H2 H3; intro H'.
inversion_clear H'.
generalize H0; clear H0.
generalize x; clear x.
elim x0.
intros.
exists (const_seq n (zero F)).
simpl in H0.
apply Trans with (zero V); auto with algebra.
apply sum_of_zeros; intro; simpl in |- *; auto with algebra arith.
intro c.
simpl in c.
elim c.
simpl in |- *.
intros.
inversion_clear subtype_prf.
generalize H1; clear H1.
elim x1.
intros x2 y H1.
exists (Basisvec_Fn F y).
apply Trans with subtype_elt; auto with algebra.
apply Trans with (v (Build_finiteT y)); auto with algebra.
apply Sym.
apply projection_via_mult_by_scalars.
intros.
generalize (H0 (span_ind_injection s) (Refl (span_ind_injection s))).
generalize (H1 (span_ind_injection s0) (Refl (span_ind_injection s0))).
intros.
clear H0 H1.
inversion_clear H3.
inversion_clear H4.
exists (pointwise (sgroup_law_map F:Map _ _) x1 x2).
simpl in H2.
apply
 Trans
  with
    (sum
       (pointwise (sgroup_law_map V) (mult_by_scalars x1 v)
          (mult_by_scalars x2 v))).
apply sum_comp.
simpl in |- *.
red in |- *.
intro.
simpl in |- *.
apply Trans with ((x1 x3 +' x2 x3) mX v x3); auto with algebra.
apply Trans with (x1 x3 mX v x3 +' x2 x3 mX v x3); auto with algebra.
apply Trans with (sum (mult_by_scalars x1 v) +' sum (mult_by_scalars x2 v)).
generalize sum_of_sums.
intro.
generalize (H3 n V (mult_by_scalars x1 v) (mult_by_scalars x2 v)).
intros.
simpl in H4.
apply H4.
apply Trans with (span_ind_injection s0 +' span_ind_injection s);
 auto with algebra.
apply Trans with (span_ind_injection s +' span_ind_injection s0);
 auto with algebra.
intros.
generalize (H0 (span_ind_injection s) (Refl (span_ind_injection s))).
intro.
clear H0.
inversion_clear H2.
exists (pointwise (uncurry (RING_comp (R:=F))) (const_seq n c) x1).
apply
 Trans with (sum (mult_by_scalars (const_seq n c) (mult_by_scalars x1 v))).
apply sum_comp.
simpl in |- *.
red in |- *.
intro.
simpl in |- *.
auto with algebra.
apply Trans with (c mX sum (mult_by_scalars x1 v)); auto with algebra.
simpl in H1.
apply Trans with (c mX span_ind_injection s); auto with algebra.
Qed.

Section Nice_basis_properties.

Variable x : V.
Variable n : Nat.
Variable b : seq n V.
Variable Db : distinct b.
Variable Bb : is_basis (seq_set b).

Let difference_seq : forall (G : group) (a a' : seq n G), seq n G.
intros.
apply (Build_Map (Ap:=fun i : fin n => a i +' (min a' i))); auto with algebra.
red in |- *.
intros.
apply SGROUP_comp; auto with algebra.
Defined.

Lemma basis_expansion_uniqueness :
 forall a a' : seq n F,
 sum (mult_by_scalars a b) =' x in _ ->
 sum (mult_by_scalars a' b) =' x in _ -> a =' a' in _.
intros.
cut (sum (mult_by_scalars (difference_seq a a') b) =' (zero V) in _).
intro.
cut (forall i : fin n, a i +' (min a' i) =' (zero F) in _).
intro.
cut (forall i : fin n, a i =' a' i in _).
simpl in |- *.
red in |- *.
auto.
intro.
apply min_inj; auto with algebra.
unfold is_basis in Bb.
inversion_clear Bb.
generalize (lin_indep_prop Db H3 H1).
auto.
apply Trans with (x +' (min x)); auto with algebra.
apply
 Trans with (sum (mult_by_scalars a b) +' (min sum (mult_by_scalars a' b)));
 auto with algebra.
apply
 Trans
  with (sum (mult_by_scalars a b) +' (min one) mX sum (mult_by_scalars a' b)).
apply
 Trans
  with
    (sum (mult_by_scalars a b) +'
     sum (mult_by_scalars (const_seq _ (min one)) (mult_by_scalars a' b))).
apply
 Trans
  with
    (sum
       (pointwise (sgroup_law_map V) (mult_by_scalars a b)
          (mult_by_scalars (const_seq _ (min one)) (mult_by_scalars a' b)))).
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
intro.
apply Trans with (a x0 mX b x0 +' (min one) mX a' x0 mX b x0);
 auto with algebra.
apply Trans with (a x0 mX b x0 +' ((min one) rX a' x0) mX b x0);
 auto with algebra.
apply Trans with ((a x0 +' (min one) rX a' x0) mX b x0); auto with algebra.
apply Trans with ((a x0 +' (min a' x0)) mX b x0); auto with algebra.
apply MODULE_comp; auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Trans with (min one rX a' x0); auto with algebra.
apply
 (sum_of_sums (n:=n) (M:=V) (mult_by_scalars a b)
    (mult_by_scalars (const_seq n (min one)) (mult_by_scalars a' b)));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Trans with (min one mX sum (mult_by_scalars a' b)); auto with algebra.
Qed.

End Nice_basis_properties.

End MAIN.