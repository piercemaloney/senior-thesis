
Set Implicit Arguments.
Unset Strict Implicit.
Require Export empty.
(* empty:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_set.

Definition empty_seq : forall A : Setoid, seq 0 A.

Lemma seq_O_is_empty :
 forall (A : Setoid) (v : seq 0 A), v =' empty_seq A in _.

Hint Resolve seq_O_is_empty: algebra.

Lemma seq_set_empty_seq_is_empty :
 forall (A : Setoid) (v : seq 0 A), seq_set v =' empty A in _.

Hint Resolve seq_set_empty_seq_is_empty: algebra.

Lemma no_seq_n_empty :
 forall (n : Nat) (A : Setoid) (W : part_set A),
 W =' empty A in _ -> seq n W -> n =' 0 in _. *)
Require Export conshdtl.
(* conshdtl:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
From Algebra Require Export Parts.

Section MAIN.

Definition conseq :
  forall (A : Setoid) (n : Nat) (a : A) (v : seq n A), seq (S n) A.

Notation "a ;; b" := (conseq a b) (at level 60, right associativity).

Variables (A : Setoid) (n : Nat) (a : A).

Lemma cons_comp :
 forall (a' : A) (v v' : seq n A),
 a =' a' in _ -> v =' v' in _ -> a;; v =' a';; v' in _.

Hint Resolve cons_comp: algebra.

Lemma cons_first_element :
 forall (v : seq n A) (H : 0 < S n), (a;; v) (Build_finiteT H) =' a in _.

Definition head (A : Setoid) (n : Nat) (v : seq (S n) A) :=
  v (Build_finiteT (lt_O_Sn n)).

Lemma head_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq (S n) A),
 v =' v' in _ -> head v =' head v' in _.

Hint Resolve head_comp cons_first_element: algebra.

Lemma head_unfolding1 :
 forall v : seq (S n) A,
 v (Build_finiteT (lt_O_Sn n)) =' a in _ -> head v =' a in _.

Lemma head_unfolding2 :
 forall v : seq (S n) A,
 a =' v (Build_finiteT (lt_O_Sn n)) in _ -> a =' head v in _.

Hint Resolve head_unfolding1 head_unfolding2: algebra.
Hint Extern 0 (head _ =' _ in _) => unfold head in |- *: algebra.
Hint Extern 0 (_ =' head _ in _) => unfold head in |- *: algebra.

Lemma head_cons_inv : forall v : seq n A, head (a;; v) =' a in _.

Hint Resolve head_cons_inv: algebra.

Lemma seq_S_O_contains_single_elt :
 forall (A : Setoid) (v : seq 1 A) (i : fin 1), v i =' head v in _.

Hint Resolve seq_S_O_contains_single_elt: algebra.

Lemma seq_S_O_head_fixes_everything :
 forall (A : Setoid) (v v' : seq 1 A), head v =' head v' in _ -> v =' v' in _.

Hint Resolve seq_S_O_head_fixes_everything: algebra.

Lemma cons_later_elements :
 forall (v : seq n A) (i : Nat) (Hi : S i < S n) (Hi' : i < n),
 (a;; v) (Build_finiteT Hi) =' v (Build_finiteT Hi') in _.

Hint Resolve cons_later_elements: algebra.

Definition Seqtl : forall n : Nat, seq n A -> seq (pred n) A. 

Lemma Seqtl_comp :
 forall v v' : seq n A, v =' v' in _ -> Seqtl v =' Seqtl v' in _.

Hint Resolve Seqtl_comp: algebra.

Definition hdtl (v : seq (S n) A) := head v;; Seqtl v:seq (S n) A.

Lemma conseq_hdtl :
 forall (v : seq (S n) A) (H : 0 < S n),
 v =' v (Build_finiteT H);; Seqtl v in _.

Hint Resolve conseq_hdtl: algebra.

Lemma hdtl_x_is_x : forall v : seq (S n) A, v =' hdtl v in _.

Hint Resolve hdtl_x_is_x: algebra.
Hint Extern 0 (head _;; Seqtl _ =' _ in _) =>
  fold hdtl in |- *; apply Sym; apply hdtl_x_is_x: algebra.
Hint Extern 0 (_ =' head _;; Seqtl _ in _) =>
  fold hdtl in |- *; apply hdtl_x_is_x: algebra.

Lemma cons_lemma_nice :
 forall P : Predicate (seq (S n) A),
 (forall (a : A) (v : seq n A), Pred_fun P (a;; v)) ->
 forall w : seq (S n) A, Pred_fun P w.

Lemma cons_lemma_verynice :
 forall (P : Predicate (seq (S n) A)) (H : 0 < S n) (w : seq (S n) A),
 Pred_fun P (w (Build_finiteT H);; Seqtl w) -> Pred_fun P w.

Lemma Seqtl_cons_inv : forall v : seq n A, Seqtl (a;; v) =' v in _.

Hint Resolve Seqtl_cons_inv: algebra.

Lemma Seqtl_to_seq :
 forall (v : seq (S n) A) (i : Nat) (Hi : i < n) (HSi : S i < S n),
 Seqtl v (Build_finiteT Hi) =' v (Build_finiteT HSi) in _.

Hint Resolve Seqtl_to_seq: algebra.

Lemma split_hd_tl_equality :
 forall v w : seq (S n) A,
 head v =' head w in _ -> Seqtl v =' Seqtl w in _ -> v =' w in _.

Hint Resolve split_hd_tl_equality: algebra.
End MAIN.

Notation "a ;; b" := (conseq a b) (at level 60, right associativity).

Hint Resolve cons_comp: algebra.
Hint Resolve head_comp cons_first_element: algebra.
Hint Resolve head_unfolding1 head_unfolding2: algebra.
Hint Extern 0 (head _ =' _ in _) => unfold head in |- *: algebra.
Hint Extern 0 (_ =' head _ in _) => unfold head in |- *: algebra.
Hint Resolve head_cons_inv: algebra.
Hint Resolve cons_later_elements: algebra.
Hint Resolve Seqtl_comp: algebra.
Hint Resolve conseq_hdtl: algebra.
Hint Resolve hdtl_x_is_x: algebra.
Hint Extern 0 (head _;; Seqtl _ =' _ in _) =>
  fold hdtl in |- *; apply Sym; apply hdtl_x_is_x: algebra.
Hint Extern 0 (_ =' head _;; Seqtl _ in _) =>
  fold hdtl in |- *; apply hdtl_x_is_x: algebra.
Hint Resolve Seqtl_cons_inv: algebra.
Hint Resolve Seqtl_to_seq: algebra.
Hint Resolve split_hd_tl_equality: algebra.
Hint Resolve seq_S_O_contains_single_elt: algebra.
Hint Resolve seq_S_O_head_fixes_everything: algebra. *)

Section list_seq.

Inductive SList (A : Setoid) : Type :=
  | Snil : SList A
  | Scons : A -> SList A -> SList A.

Fixpoint Length (A : Setoid) (L : SList A) {struct L} : nat :=
  match L with
  | Snil => 0
  | Scons _ L' => S (Length L')
  end.

Fixpoint SList2fun (A : Setoid) (L : SList A) {struct L} :
 seq (Length L) A :=
  match L return (seq (Length L) A:Type) with
  | Snil => empty_seq A
  | Scons a L' => a;; SList2fun L'
  end.

Definition SList2seq : forall (A : Setoid) (L : SList A), seq (Length L) A.
intros.
red in |- *.
apply (Build_Map (Ap:=SList2fun L)).
red in |- *.
intros k k'.
elim k.
simple induction index.
elim k'.
simple induction index0.
intros.
apply Ap_comp; auto with algebra.
intros.
inversion H0.
elim k'.
simple induction index0.
simpl in |- *.
intros.
inversion H0.
intros.
apply Ap_comp; auto with algebra.
Defined.

Fixpoint Seq2SList (A : Setoid) (n : nat) {struct n} : 
 seq n A -> SList A :=
  match n return (seq n A -> SList A) with
  | O => fun b : seq 0 A => Snil A
  | S m =>
      fun b : seq (S m) A =>
      Scons (b (Build_finiteT (le_lt_n_Sm _ _ (le_O_n m))))
        (Seq2SList (Seqtl b))
  end.
End list_seq.

Section other.

Definition reverse_seq : forall n : nat, seq n (fin n).
simple induction n.

apply (Build_Map (Ap:=fun nonexistent_thingy : fin 0 => nonexistent_thingy)).
red in |- *.
auto with algebra.

intros.

apply
 (Build_Map
    (Ap:=fun finelt : fin (S n0) =>
         match finelt return (fin (S n0)) with
         | Build_finiteT x x0 =>
             match x as x1 return (x1 < S n0 -> fin (S n0)) with
             | O => fun _ : 0 < S n0 => Build_finiteT (lt_n_Sn n0)
             | S m =>
                 fun HSm : S m < S n0 =>
                 Build_finiteT
                   (lt_S (index (X (Build_finiteT (lt_S_n m n0 HSm)))) n0
                      (in_range_prf (X (Build_finiteT (lt_S_n m n0 HSm)))))
             end x0
         end)).
red in |- *.

intro x.
case x.
intro x0.
case x0.
intros l y.
case y.
intro x1.
case x1. 

simpl in |- *.
tauto.
simpl in |- *.
intros.
inversion H.
simpl in |- *.
intros n1 l y.
case y.
intro x1.
case x1.
intros.
inversion H.

intros.
inversion H.
elim X.
intros.
simpl in |- *.
red in Map_compatible_prf.
simpl in Map_compatible_prf.
apply Map_compatible_prf; auto with algebra.
Defined.

Definition reverse (n : nat) (X : Setoid) (f : seq n X) :=
  comp_map_map f (reverse_seq n):seq n X.

Definition consr :
  forall (X : Setoid) (n : nat) (x : X) (f : seq n X), seq (S n) X.
intros.
exact (reverse (x;; reverse f)).
Defined.
End other.