
Set Implicit Arguments.
Unset Strict Implicit.
Section MAIN.
Require Export concat_facts.
(* concat_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export concat.
Require Export empty.

Section MAIN.
Variable A : Setoid.
Variable n m : Nat.
Variable v : seq n A.
Variable w : seq m A.

Lemma concat_first_part :
 forall (i : Nat) (Hi : i < n) (Hi' : i < n + m),
 (v ++ w) (Build_finiteT Hi') =' v (Build_finiteT Hi) in _.

Hint Resolve concat_first_part: algebra.

Lemma concat_second_part :
 forall (i : Nat) (Hi : i < m) (Hi' : n + i < n + m),
 (v ++ w) (Build_finiteT Hi') =' w (Build_finiteT Hi) in _.

Hint Resolve concat_second_part: algebra.

Lemma concat_prop_per_part :
 forall P : Predicate A,
 (forall (i : Nat) (Hi : i < n), Pred_fun P (v (Build_finiteT Hi))) ->
 (forall (j : nat) (Hj : j < m), Pred_fun P (w (Build_finiteT Hj))) ->
 forall (k : nat) (Hk : k < n + m), Pred_fun P ((v ++ w) (Build_finiteT Hk)).

Lemma concat_prop_per_element :
 forall P : Predicate A,
 (forall (i : Nat) (Hi : i < n) (Hi' : i < n + m),
  Pred_fun P ((v ++ w) (Build_finiteT Hi'))) ->
 (forall (j : Nat) (Hj : j < m) (Hj' : n + j < n + m),
  Pred_fun P ((v ++ w) (Build_finiteT Hj'))) ->
 forall (k : Nat) (Hk : k < n + m), Pred_fun P ((v ++ w) (Build_finiteT Hk)).

Lemma split_to_concat :
 forall vw : seq (n + m) A, sigT (fun a => sigT (fun b => vw =' a ++ b in _)).
End MAIN.

Hint Resolve concat_first_part: algebra.
Hint Resolve concat_second_part: algebra. *)
Require Export sums2.
(* sums2:
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Abelian_group_facts.
Require Export sums.
Require Export omit.
Require Export modify_seq.
Require Export const.

Lemma sum_omit_zeros :
 forall (M : monoid) (n : Nat) (v : seq n M) (i : fin n),
 v i =' (zero M) in _ -> sum v =' sum (omit v i) in _.

Lemma sum_modify :
 forall (AG : abelian_group) (n : Nat) (v : seq n AG) (i : fin n) (a : AG),
 sum (modify_seq v i a) =' sum v +' (min v i) +' a in _.

Lemma sum_of_zeros :
 forall (M : monoid) (n : Nat) (v : seq n M),
 v =' const_seq n (zero M) in _ -> sum v =' (zero M) in _.

Hint Resolve sum_omit_zeros sum_modify sum_of_zeros: algebra. *)
Require Export mult_by_scalars.
(* mult_by_scalars:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export pointwise.
Require Export modify_seq.
Require Export vecspaces_verybasic.

Definition mult_by_scalars (R : ring) (V : module R) 
  (N : Nat) (a : Map (fin N) R) (v : Map (fin N) V) : 
  MAP (fin N) V := pointwise (uncurry (MODULE_comp (Mod:=V))) a v.

Lemma mult_by_scalars_comp :
 forall (R : ring) (V : module R) (N : Nat) (a b : MAP (fin N) R)
   (v w : MAP (fin N) V),
 a =' b in _ ->
 v =' w in _ -> mult_by_scalars a v =' mult_by_scalars b w in _.

Lemma mult_by_scalars_fun2_compatible :
 forall (R : ring) (V : module R) (N : Nat),
 fun2_compatible
   (mult_by_scalars (V:=V) (N:=N):MAP _ _ -> MAP _ _ -> MAP _ _).

Hint Resolve mult_by_scalars_fun2_compatible mult_by_scalars_comp: algebra.

Lemma mult_by_scalars_Seqtl :
 forall (R : ring) (V : module R) (N : Nat) (a : Map (fin N) R)
   (v : Map (fin N) V),
 mult_by_scalars (Seqtl a) (Seqtl v) =' Seqtl (mult_by_scalars a v) in _.

Hint Resolve mult_by_scalars_Seqtl: algebra.

Lemma mult_by_scalars_concat :
 forall (R : ring) (V : module R) (N M : Nat) (a : Map (fin N) R)
   (b : Map (fin M) R) (v : Map (fin N) V) (w : Map (fin M) V),
 mult_by_scalars (a ++ b) (v ++ w) ='
 mult_by_scalars a v ++ mult_by_scalars b w in _.

Hint Resolve mult_by_scalars_concat: algebra.

Lemma mult_by_scalars_modify_seq :
 forall (F : field) (V : vectorspace F) (n : Nat) (p : seq n F) 
   (k : seq n V) (i : fin n) (q : F),
 mult_by_scalars (modify_seq p i q) k ='
 modify_seq (mult_by_scalars p k) i (q mX k i) in seq _ _.

Hint Resolve mult_by_scalars_modify_seq: algebra. *)
Require Export vecspace_Fn.
(* vecspace_Fn:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.

Section Fn_vectors.

Require Export vecspaces_verybasic.
Require Export finite.

Definition Fn_set (F : Setoid) (n : Nat) : SET := seq n F.

Let Fn_plus_fun :
  forall (F : sgroup) (n : Nat), Fn_set F n -> Fn_set F n -> Fn_set F n.

Definition Fn_plus :
  forall (F : sgroup) (n : Nat), law_of_composition (Fn_set F n).

Lemma Fn_plus_associative :
 forall (F : sgroup) (n : Nat), associative (Fn_plus F n).

Definition Fn_sgroup (F : sgroup) (n : Nat) : SGROUP :=
  Build_sgroup (Build_sgroup_on (Fn_plus_associative (F:=F) (n:=n))).

Lemma Fn_plus_commutative :
 forall (F : abelian_sgroup) (n : Nat), commutative (Fn_plus F n).

Definition Fn_absgp (F : abelian_sgroup) (n : Nat) : ABELIAN_SGROUP :=
  Build_abelian_sgroup
    (Build_abelian_sgroup_on (A:=Fn_sgroup F n)
       (Fn_plus_commutative (F:=F) (n:=n))).

Definition Fn_zero : forall (F : monoid) (n : Nat), Fn_sgroup F n.

Lemma Fn_zero_is_r_unit :
 forall (F : monoid) (n : Nat),
 unit_r (sgroup_law_map (Fn_sgroup F n)) (Fn_zero F n).

Lemma Fn_zero_is_l_unit :
 forall (F : monoid) (n : Nat),
 unit_l (sgroup_law_map (Fn_sgroup F n)) (Fn_zero F n).

Definition Fn_monoid (F : monoid) (n : Nat) : MONOID :=
  Build_monoid
    (Build_monoid_on (A:=Fn_sgroup F n) (monoid_unit:=
       Fn_zero F n) (Fn_zero_is_r_unit (F:=F) (n:=n))
       (Fn_zero_is_l_unit (F:=F) (n:=n))).

Lemma Fn_monoid_is_abelian :
 forall (F : abelian_monoid) (n : Nat), abelian_monoid_on (Fn_monoid F n).

Definition Fn_abmon (F : abelian_monoid) (n : Nat) : ABELIAN_MONOID :=
  Build_abelian_monoid (Fn_monoid_is_abelian F n).

Let Fn_inv_fun : forall (F : group) (n : Nat), Fn_monoid F n -> Fn_monoid F n.

Definition Fn_inv :
  forall (F : group) (n : Nat), Map (Fn_monoid F n) (Fn_monoid F n).

Lemma Fn_inv_is_r_inverse :
 forall (F : group) (n : Nat),
 inverse_r (Fn_plus F n) (Fn_zero F n) (Fn_inv F n).

Lemma Fn_inv_is_l_inverse :
 forall (F : group) (n : Nat),
 inverse_l (Fn_plus F n) (Fn_zero F n) (Fn_inv F n).

Definition Fn_group (F : group) (n : Nat) : GROUP :=
  Build_group
    (Build_group_on (group_inverse_map:=Fn_inv F n)
       (Fn_inv_is_r_inverse (F:=F) (n:=n))
       (Fn_inv_is_l_inverse (F:=F) (n:=n))).

Lemma Fn_group_is_abelian :
 forall (F : abelian_group) (n : Nat), abelian_group_on (Fn_group F n).

Definition Fn_abgp (F : abelian_group) (n : Nat) : ABELIAN_GROUP :=
  Build_abelian_group (Fn_group_is_abelian F n).

Definition Fn_scmult_fun :
  forall (F : ring) (n : Nat), F -> Fn_set F n -> Fn_set F n.

Lemma Fn_scmult_fun_comp :
 forall (F : ring) (n : Nat) (c c' : F) (v v' : Fn_set F n),
 c =' c' in _ ->
 v =' v' in _ -> Fn_scmult_fun c v =' Fn_scmult_fun c' v' in _.

Section necessary_module_stuff.

Let Fn_scmult_fun_map :
  forall (F : ring) (n : Nat), F -> MAP (Fn_set F n) (Fn_set F n).

Let Fn_scmult_F_to_EndoSet :
  forall (F : ring) (n : Nat),
  Map (Build_monoid (ring_monoid F)) (Endo_SET (Fn_set F n)).

Let Fn_scmult_sgroup_hom :
  forall (F : ring) (n : Nat),
  sgroup_hom (Build_monoid (ring_monoid F)) (Endo_SET (Fn_set F n)).

Let Fn_scmult_monoid_hom :
  forall (F : ring) (n : Nat),
  monoid_hom (Build_monoid (ring_monoid F)) (Endo_SET (Fn_set F n)).

Definition Fn_scmult :
  forall (F : ring) (n : Nat),
  operation (Build_monoid (ring_monoid F)) (Fn_abgp F n).

End necessary_module_stuff.

Lemma Fn_scmult_l_lin :
 forall (F : ring) (n : Nat), op_lin_left (Fn_scmult F n).

Lemma Fn_scmult_r_lin :
 forall (F : ring) (n : Nat), op_lin_right (Fn_scmult F n).

Definition Fn_mod (F : ring) (n : Nat) : MODULE F :=
  Build_module
    (Build_module_on (Fn_scmult_l_lin (F:=F) (n:=n))
       (Fn_scmult_r_lin (F:=F) (n:=n))).

Definition Fn (F : field) (n : Nat) : VECSP F := Fn_mod F n:vectorspace F.

End Fn_vectors.

Section Basis_vectors.

Fixpoint Kronecker (A : Setoid) (t f : A) (n m : Nat) {struct m} : A :=
  match n, m with
  | O, O => t
  | S n', O => f
  | O, S m' => f
  | S n', S m' => Kronecker t f n' m'
  end.

Lemma Kronecker_case_equal :
 forall (A : Setoid) (t f : A) (n m : Nat),
 n =' m in _ -> Kronecker t f n m =' t in _.

Lemma Kronecker_case_unequal :
 forall (A : Setoid) (t f : A) (n m : Nat),
 ~ n =' m in _ -> Kronecker t f n m =' f in _.

Definition Basisvec_Fn :
  forall (F : field) (n i : Nat) (H : i < n), Fn F n:Type.
End Basis_vectors. *)

Lemma inject_map_embed_seq_set :
 forall (A : Setoid) (B : part_set A) (n : Nat) (v : seq n B),
 inject_subsets (seq_set v) =' seq_set (Map_embed v) in _.
simpl in |- *.
red in |- *.
split; intros.
rename x into a.
simpl in |- *.
simpl in H.
inversion_clear H.
destruct x.
rename subtype_elt into b.
rename subtype_prf into Hb.
simpl in Hb.
inversion_clear Hb.
rename x into i.
exists i.
red in H.
simpl in H0.
apply Trans with (subtype_elt b); auto with algebra.

simpl in |- *.
rename x into a.
assert (in_part a B).
simpl in H.
inversion_clear H.
apply in_part_comp_l with (subtype_elt (v x)); auto with algebra.
red in H0.
set (b := Build_subtype H0:B) in *.
assert (in_part b (seq_set v)).
simpl in |- *.
simpl in H.
inversion_clear H.
rename x into i.
exists i.
red in |- *.
apply Trans with a; auto with algebra.
red in H1.
exists (Build_subtype H1).
simpl in |- *.
auto with algebra.
Qed.

Section concat_const_seq.
Variable A : Setoid.
Let eqa : forall a : A, Predicate A.
intro; apply Build_Predicate with (fun a' => a' =' a in _).
red in |- *; simpl in |- *.
intros; apply Trans with x; auto with algebra.
Defined.

Lemma concat_const_seq :
 forall (n m : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ ->
 const_seq n a ++ const_seq m a' =' const_seq (n + m) a'' in _.
intros.
intro.
apply Trans with a; auto with algebra.
2: simpl in |- *.
2: apply Trans with a'; auto with algebra.
generalize
 (concat_prop_per_part (A:=A) (n:=n) (m:=m) (v:=const_seq n a)
    (w:=const_seq m a') (P:=eqa a)); intro.
simpl in H1.
destruct x.
apply H1; auto with algebra.
Qed.
End concat_const_seq.

Section mult_facts.
Variable F : field.
Variable V : vectorspace F.
Lemma mult_const_Zero :
 forall (n : Nat) (v : seq n V),
 mult_by_scalars (const_seq n (zero F)) v =' const_seq n (zero V) in seq _ _.
simple induction n.
simpl in |- *.
red in |- *.
intros.
inversion x.
inversion in_range_prf.
intros.
simpl in |- *.
red in |- *.
intro x; elim x; intro i; case i.
simpl in |- *.
intro.
apply Zero_times_a_vector_gives_zero; auto with algebra.
simpl in |- *.
intros.
apply Zero_times_a_vector_gives_zero; auto with algebra.
Qed.

Lemma mult_const_zero :
 forall (n : Nat) (a : seq n F),
 mult_by_scalars a (const_seq n (zero V)) =' const_seq n (zero V) in seq _ _.
intros.
simpl in |- *.
red in |- *.
intro x.
simpl in |- *.
apply a_scalar_times_zero_gives_zero; auto with algebra.
Qed.
End mult_facts.

Hint Resolve mult_const_Zero mult_const_Zero: algebra.

Section proj_via_mult_by_scalars.

Let basisvec0prop :
  forall (F : field) (n : Nat) (H : 0 < S n),
  Seqtl (Basisvec_Fn F H) =' const_seq n (zero F) in _.
intros.
simpl in |- *.
red in |- *.
simpl in |- *.
intro.
case x.
auto with algebra.
Qed.

Let basisvecprop2 :
  forall (F : field) (n i : Nat) (H : i < n) (HS : S i < S n),
  Seqtl (Basisvec_Fn F HS) =' Basisvec_Fn F H in _.
intros.
simpl in |- *.
red in |- *.
intro x; case x.
intros.
apply Ap_comp; auto with algebra.
Qed.

Lemma projection_via_mult_by_scalars :
 forall (F : field) (M : module F) (n i : Nat) (Hi Hi' : i < n) (v : seq n M),
 v (Build_finiteT Hi) =' sum (mult_by_scalars (Basisvec_Fn F Hi') v) in _.
intros F M n. 
induction  n as [| n Hrecn].
intros.
inversion Hi.
intros.
apply Trans with (sum (hdtl (mult_by_scalars (Basisvec_Fn F Hi) v)));
 auto with algebra.
unfold hdtl in |- *.
generalize Hi; clear Hi.
generalize Hi'; clear Hi'.
elim i.
intros Hi' Hi.
apply Trans with (head (mult_by_scalars (Basisvec_Fn F Hi) v) +' (zero M)).
apply Trans with (head (mult_by_scalars (Basisvec_Fn F Hi) v));
 auto with algebra.
simpl in |- *.
apply Trans with (head v); auto with algebra.
apply
 Trans
  with
    (head (mult_by_scalars (Basisvec_Fn F Hi) v) +'
     sum (Seqtl (mult_by_scalars (Basisvec_Fn F Hi) v))); 
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Trans with (sum (const_seq n (zero M))).
apply Sym.
apply sum_of_zeros; auto with algebra.
apply sum_comp.
apply Trans with (mult_by_scalars (Seqtl (Basisvec_Fn F Hi)) (Seqtl v)).
apply
 Trans
  with
    (mult_by_scalars (R:=F) (V:=M) (N:=n) (const_seq n (zero F):Map _ _)
       (Seqtl v:Map _ _)); auto with algebra.
unfold mult_by_scalars in |- *.
apply pointwise_Seqtl; auto with algebra.

intros.
apply Trans with (hdtl v (Build_finiteT Hi)).
apply Ap_comp; auto with algebra.
apply
 Trans with (sum ((zero M);; Seqtl (mult_by_scalars (Basisvec_Fn F Hi) v))).
apply
 Trans with ((zero M) +' sum (Seqtl (mult_by_scalars (Basisvec_Fn F Hi) v)));
 auto with algebra.
apply Trans with (sum (Seqtl (mult_by_scalars (Basisvec_Fn F Hi) v)));
 auto with algebra.
unfold hdtl in |- *.
apply Trans with (Seqtl v (Build_finiteT (lt_S_n _ _ Hi))); auto with algebra.
apply Trans with (sum (mult_by_scalars (Seqtl (Basisvec_Fn F Hi)) (Seqtl v))).
apply
 Trans with (sum (mult_by_scalars (Basisvec_Fn F (lt_S_n _ _ Hi)) (Seqtl v)));
 auto with algebra.
2: apply sum_comp.
2: simpl in |- *.
2: red in |- *.
2: auto with algebra.
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
intro x; case x.
auto with algebra.
Qed.

End proj_via_mult_by_scalars.

Lemma sum_of_sums :
 forall (n : Nat) (M : abelian_monoid) (v v' : seq n M),
 sum (pointwise (sgroup_law_map M) v v') =' sum v +' sum v' in _.
simple induction n.
intros.
simpl in |- *.
auto with algebra.
intros.
apply Trans with (sum (hdtl v) +' sum (hdtl v')); auto with algebra.
apply Trans with (sum (pointwise (sgroup_law_map M) (hdtl v) (hdtl v'))).
apply sum_comp.
apply toMap.
apply pointwise_comp; auto with algebra.
unfold hdtl in |- *.
apply Trans with (head v +' sum (Seqtl v) +' (head v' +' sum (Seqtl v')));
 auto with algebra.
apply
 Trans
  with
    (sum
       (sgroup_law_map (E:=M) M (couple (head v) (head v'));;
        pointwise (sgroup_law_map M) (Seqtl v) (Seqtl v')));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law_map M (couple (head v) (head v')) +'
     sum (pointwise (sgroup_law_map M) (Seqtl v) (Seqtl v')));
 auto with algebra.
apply
 Trans
  with
    (sgroup_law_map M (couple (head v) (head v')) +'
     sgroup_law M (sum (Seqtl v)) (sum (Seqtl v'))); 
 auto with algebra.
apply Trans with (head v +' head v' +' (sum (Seqtl v) +' sum (Seqtl v')));
 auto with algebra.
Qed.

End MAIN.