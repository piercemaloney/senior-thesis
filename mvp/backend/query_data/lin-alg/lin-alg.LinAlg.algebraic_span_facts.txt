
Set Implicit Arguments.
Unset Strict Implicit.
Require Export spans.
(* spans:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export lin_combinations.
Require Export subspaces.

Section spans.
Variable F : field.
Variable V : vectorspace F.
Definition span_set (S : part_set V) : part_set V := is_lin_comb_pred S.

Definition span : part_set V -> subspace V.

Lemma span_comp :
 forall S S' : part_set V, S =' S' in _ -> span S =' span S' in part_set V.

Lemma span_is_subspace : forall S : part_set V, is_subspace (span S).
End spans.

Hint Resolve span_comp: algebra.

Section spans_inductively_defined.
Variable F : field.
Variable V : vectorspace F.
Variable S : part_set V.

Inductive span_ind_formal : Type :=
  | Zerovector : span_ind_formal
  | Immediately : S -> span_ind_formal
  | Plusvector : span_ind_formal -> span_ind_formal -> span_ind_formal
  | Multvector : F -> span_ind_formal -> span_ind_formal.

Fixpoint span_ind_injection (X : span_ind_formal) : V :=
  match X with
  | Zerovector => zero V
  | Immediately s => subtype_elt s
  | Plusvector x y => span_ind_injection x +' span_ind_injection y
  | Multvector a x => a mX span_ind_injection x
  end.

Definition span_ind_set : part_set V.

Definition span_ind : subspace V.

Definition lin_comb_ind (v : V) : Prop := in_part v span_ind.
End spans_inductively_defined.

Section spans_eqv.

Variable F : field.
Variable V : vectorspace F.

Lemma span_ind_eqv_span :
 forall (S : part_set V) (v : V), is_lin_comb v S <-> lin_comb_ind S v.

Lemma span_is_span_ind :
 forall S : part_set V, span S =' span_ind S in part_set V.

Lemma span_ind_comp :
 forall S S' : part_set V,
 S =' S' in _ -> span_ind S =' span_ind S' in part_set V.

End spans_eqv.

Hint Resolve span_is_span_ind span_ind_comp: algebra.

Section a_nice_fact_on_spans.

Lemma span_smallest_subspace_containing_subset :
 forall (F : field) (V : vectorspace F) (W : subspace V) (S : part_set V),
 included S W -> included (span S) W.

Lemma set_included_in_its_span :
 forall (F : field) (V : vectorspace F) (S : part_set V), included S (span S).

End a_nice_fact_on_spans.

Hint Resolve set_included_in_its_span: algebra.

Definition generates (F : field) (V : vectorspace F) 
  (S W : part_set V) := span S =' W in part_set V.

Lemma generates_comp :
 forall (F : field) (V : vectorspace F) (S S' W W' : part_set V),
 S =' S' in _ -> W =' W' in _ -> generates S W -> generates S' W'.

Lemma generated_subsets_are_subspaces :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> is_subspace W.

Lemma is_lin_comb_from_generates :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> forall x : V, in_part x W -> is_lin_comb x S.

Lemma generates_then_is_lin_comb :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> forall x : V, in_part x W -> is_lin_comb x S.

Lemma is_lin_comb_from_generates' :
 forall (F : field) (V : vectorspace F) (S : part_set V) (W : subspace V),
 generates S W -> forall x : W, is_lin_comb (subtype_elt x) S. *)
From Algebra Require Export Inter.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Lemma span_idempotent :
 forall S : part_set V, span S =' span (span S) in part_set V.
simpl in |- *.
red in |- *.
split; intro.
apply in_part_comp_r with (span_ind (span S):part_set V); auto with algebra.
change (Pred_fun (span S) x) in H.
simpl in |- *.
exists (Immediately (Build_subtype H)).
simpl in |- *.
apply Refl.
apply Trans with (span (span S):part_set V); auto with algebra.

assert (in_part x (span_ind (span S))).
apply in_part_comp_r with (span (span S):part_set V); auto with algebra.
elim H0.
intro.
generalize x.
elim x0.
simpl in |- *.
intros.
red in |- *.
exists 0.
exists (empty_seq F).
exists (empty_seq S).
simpl in |- *.
auto.

simpl in |- *.
intro.
elim c.
intros c0 cp.
elim cp.
intros x1 H1.
inversion H1.
inversion H2.
intros.
red in |- *.
exists x1.
exists x2.
exists x3.
apply Trans with c0; auto with algebra.

intros.
clear H0 H x x0.
simpl in H3.
simpl in |- *.
red in |- *.
generalize (H1 (span_ind_injection s) (Refl _)).
generalize (H2 (span_ind_injection s0) (Refl _)).
intros.
clear H1 H2.
simpl in H, H0.
red in H, H0.
inversion H.
inversion H0.
exists (x0 + x).
inversion H1.
inversion H2.
exists (x3 ++ x2).
inversion H4.
inversion H5.
exists (x5 ++ x4).
apply
 Trans
  with
    (sum (mult_by_scalars x3 (Map_embed x5)) +'
     sum (mult_by_scalars x2 (Map_embed x4))).
apply Trans with (span_ind_injection s +' span_ind_injection s0);
 auto with algebra.
apply
 Trans
  with
    (sum
       (mult_by_scalars x3 (Map_embed x5) ++
        mult_by_scalars x2 (Map_embed x4))).
apply Sym.
apply sum_concat; auto with algebra.
apply
 Trans with (sum (mult_by_scalars (x3 ++ x2) (Map_embed x5 ++ Map_embed x4))).
unfold mult_by_scalars in |- *.
apply sum_comp; auto with algebra.
unfold mult_by_scalars in |- *.
apply sum_comp.
apply toMap.
apply pointwise_comp; auto with algebra.
intros.
clear x0 H0 H x.
simpl in H2.
generalize (H1 (span_ind_injection s) (Refl _)).
simpl in |- *. 
unfold is_lin_comb in |- *.
intro.
inversion H.
inversion H0.
inversion H3.
exists x.
exists (pointwise (uncurry (RING_comp (R:=F))) (const_seq x c) x0).
exists x2.
apply Trans with (c mX span_ind_injection s); auto with algebra.
apply Trans with (c mX sum (mult_by_scalars x0 (Map_embed x2)));
 auto with algebra.
apply
 Trans
  with
    (sum
       (mult_by_scalars (const_seq x c) (mult_by_scalars x0 (Map_embed x2))));
 auto with algebra.
Qed.

Lemma span_preserves_inclusion :
 forall S S' : part_set V, included S S' -> included (span S) (span S').
intros.
red in |- *.
intros.
simpl in H0.
red in H0.
elim H0; intros.
elim H1; intros.
elim H2; intro.
simpl in |- *.
red in |- *.
exists x0.
exists x1.
exists (Map_include_map _ H x2).
apply Trans with (sum (mult_by_scalars x1 (Map_embed x2))); auto with algebra.
Qed.

Hint Resolve span_preserves_inclusion: algebra.

Lemma span_of_union :
 forall S S' : part_set V,
 span (union S S') =' span (union (span S) (span S')) in part_set V.
intros.
apply included_antisym.
apply span_smallest_subspace_containing_subset; auto with algebra.
apply included2_union; auto with algebra.
apply included_trans with (union (span S) (span S')); auto with algebra.
apply included_trans with (span S:part_set V); auto with algebra.
apply included_trans with (union (span S) (span S')); auto with algebra.
apply included_trans with (span S':part_set V); auto with algebra.
apply span_smallest_subspace_containing_subset; auto with algebra.
Qed.

Lemma inclusion_generates :
 forall S S' : part_set V,
 included S S' -> generates S (full V) -> generates S' (full V).
intros.
red in H0.
red in |- *.
apply Trans with (span S:part_set _); auto with algebra.
apply included_antisym; auto with algebra.
apply included_trans with (full V); auto with algebra.
Qed.

Lemma subspace_span_characterisation :
 forall W : part_set V, is_subspace W <-> span W =' W in part_set V.
intro.
split.

intros.
apply Trans with (span_ind W:part_set V); auto with algebra.
simpl in |- *.
red in |- *.
split.
intro.
red in H.
inversion_clear H.
inversion_clear H2.
simpl in H0.
inversion_clear H0.
generalize H2.
generalize x.
clear H2.
induction x0 as [| c| x1 IHx1 x2 IHx2| c x0 IHx0].
simpl in |- *.
intros.
apply in_part_comp_l with (zero V); auto with algebra.
simpl in |- *.
intros.
apply in_part_comp_l with (subtype_elt c); auto with algebra.
simpl in |- *.
intros.
apply in_part_comp_l with (span_ind_injection x1 +' span_ind_injection x2);
 auto with algebra.
intros.
simpl in H2.
apply in_part_comp_l with (c mX span_ind_injection x0); auto with algebra.

intro.
simpl in |- *.
red in H0.
exists (Immediately (Build_subtype H0)).
simpl in |- *.
apply Refl.

intro.
apply is_subspace_comp with (span W:part_set V); auto with algebra.
apply span_is_subspace; auto with algebra.
Qed.

Lemma subspace_contains_all_lin_combs :
 forall (W : subspace V) (x : V), is_lin_comb x W -> in_part x W.
intros.
assert (in_part x (span W)).
simpl in |- *.
auto.
apply in_part_comp_r with (span W:part_set V).
auto.
elim (subspace_span_characterisation W).
intros.
apply H1.
apply is_subspace_OK.
Qed.

Lemma span_intersect :
 forall S S' : part_set V,
 included (span (inter S S')) (inter (span S) (span S')).
intros.
red in |- *.
intros.
simpl in H.
red in H.
inversion_clear H.
inversion_clear H0.
inversion_clear H.
simpl in |- *.
split.
red in |- *.
exists x0.
exists x1.
assert (included (inter S S') S); auto with algebra.
exists (Map_include_map _ H x2).
apply Trans with (sum (mult_by_scalars x1 (Map_embed x2))); auto with algebra.
red in |- *.
exists x0.
exists x1.
assert (included (inter S S') S'); auto with algebra.
exists (Map_include_map _ H x2).
apply Trans with (sum (mult_by_scalars x1 (Map_embed x2))); auto with algebra.
Qed.

End MAIN.
