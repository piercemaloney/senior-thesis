
Set Implicit Arguments.
Unset Strict Implicit.
Require Export mult_by_scalars.
(* mult_by_scalars:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export pointwise.
Require Export modify_seq.
Require Export vecspaces_verybasic.

Definition mult_by_scalars (R : ring) (V : module R) 
  (N : Nat) (a : Map (fin N) R) (v : Map (fin N) V) : 
  MAP (fin N) V := pointwise (uncurry (MODULE_comp (Mod:=V))) a v.

Lemma mult_by_scalars_comp :
 forall (R : ring) (V : module R) (N : Nat) (a b : MAP (fin N) R)
   (v w : MAP (fin N) V),
 a =' b in _ ->
 v =' w in _ -> mult_by_scalars a v =' mult_by_scalars b w in _.

Lemma mult_by_scalars_fun2_compatible :
 forall (R : ring) (V : module R) (N : Nat),
 fun2_compatible
   (mult_by_scalars (V:=V) (N:=N):MAP _ _ -> MAP _ _ -> MAP _ _).

Hint Resolve mult_by_scalars_fun2_compatible mult_by_scalars_comp: algebra.

Lemma mult_by_scalars_Seqtl :
 forall (R : ring) (V : module R) (N : Nat) (a : Map (fin N) R)
   (v : Map (fin N) V),
 mult_by_scalars (Seqtl a) (Seqtl v) =' Seqtl (mult_by_scalars a v) in _.

Hint Resolve mult_by_scalars_Seqtl: algebra.

Lemma mult_by_scalars_concat :
 forall (R : ring) (V : module R) (N M : Nat) (a : Map (fin N) R)
   (b : Map (fin M) R) (v : Map (fin N) V) (w : Map (fin M) V),
 mult_by_scalars (a ++ b) (v ++ w) ='
 mult_by_scalars a v ++ mult_by_scalars b w in _.

Hint Resolve mult_by_scalars_concat: algebra.

Lemma mult_by_scalars_modify_seq :
 forall (F : field) (V : vectorspace F) (n : Nat) (p : seq n F) 
   (k : seq n V) (i : fin n) (q : F),
 mult_by_scalars (modify_seq p i q) k ='
 modify_seq (mult_by_scalars p k) i (q mX k i) in seq _ _.

Hint Resolve mult_by_scalars_modify_seq: algebra. *)
Require Export sums.
(* sums:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.
From Algebra Require Export Sub_monoid.
Require Export more_syntax.

Fixpoint sum (V : monoid) (n : Nat) {struct n} : seq n V -> V :=
  match n return (seq n V -> V) with
  | O => fun x : seq 0 V => zero V
  | S m => fun x : seq (S m) V => head x +' sum (Seqtl x)
  end.

Lemma sum_comp :
 forall (M : monoid) (n : Nat) (f f' : seq n M),
 f =' f' in _ -> sum f =' sum f' in _.

Hint Resolve sum_comp: algebra.

Lemma sum_cons :
 forall (M : monoid) (m : M) (n : Nat) (f : seq n M),
 sum (m;; f) =' m +' sum f in _.

Hint Resolve sum_cons: algebra.

Lemma sum_concat :
 forall (n m : Nat) (G : monoid) (a : seq n G) (b : seq m G),
 sum (a ++ b) =' sum a +' sum b in _.

Hint Resolve sum_concat: algebra.

Lemma subtype_sum :
 forall (n : nat) (A : monoid) (B : submonoid A) (c : seq n B),
 subtype_elt (sum c) =' sum (Map_embed c) in _. *)

Variable F : field.
Variable V W : vectorspace F.

Record lin_trafo_on (T : Map V W) : Type := 
  {preserve_plus : forall x y : V, T (x +' y) =' T x +' T y in _;
   preserve_mX : forall (c : F) (x : V), T (c mX x) =' c mX T x in _}.

Record lin_trafo : Type := 
  {lin_trafo_map :> Map V W; lin_trafo_on_def : lin_trafo_on lin_trafo_map}.

Fact zerovec_preserving : forall T : lin_trafo, T (zero V) =' (zero W) in _.
intro.
destruct T.
rename lin_trafo_map0 into T.
destruct lin_trafo_on_def0.
simpl in |- *.
apply Trans with (T ((zero V) +' (min (zero V)))); auto with algebra.
apply Trans with (T (zero V) +' T (min (zero V))); auto with algebra.
apply Trans with (T (zero V) +' (min T (zero V))); auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Trans with (T (min one mX (zero V))); auto with algebra.
apply Trans with (T ((min one) mX (zero V))); auto with algebra.
apply Trans with (min one mX T (zero V)); auto with algebra.
apply Trans with ((min one) mX T (zero V)); auto with algebra.
Qed.

Hint Resolve zerovec_preserving: algebra.

Fact lin_trafo_equation :
 forall T : Map V W,
 lin_trafo_on T ->
 forall (a : F) (x y : V), T (a mX x +' y) =' a mX T x +' T y in _.
intros T H a x y.
destruct H.
apply Trans with (T (a mX x) +' T y); auto with algebra.
Qed.

Hint Resolve lin_trafo_equation: algebra.

Fact lin_trafo_equation' :
 forall T : Map V W,
 (forall (a : F) (x y : V), T (a mX x +' y) =' a mX T x +' T y in _) ->
 lin_trafo_on T.
intros.
constructor.
intros.
apply Trans with (one mX T x +' T y); auto with algebra.
apply Trans with (T (one mX x +' y)); auto with algebra.
intros.
apply Trans with (c mX T x +' (zero W)); auto with algebra.
apply Trans with (c mX T x +' T (zero V)); auto with algebra.
apply Trans with (T (c mX x +' (zero V))); auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Trans with (T ((min one) mX (zero V) +' (zero V))); auto with algebra.
apply Ap_comp; auto with algebra.
apply Trans with ((min one mX (zero V)) +' (zero V)); auto with algebra.
apply Trans with ((min (zero V)) +' (zero V)); auto with algebra.
apply Trans with ((min one) mX T (zero V) +' T (zero V)); auto with algebra.
apply Trans with ((min one mX T (zero V)) +' T (zero V)); auto with algebra.
apply Trans with ((min T (zero V)) +' T (zero V)); auto with algebra.
Qed.

Hint Resolve lin_trafo_equation': algebra.

Fact lin_trafo_of_lin_comb :
 forall T : Map V W,
 lin_trafo_on T ->
 forall (n : Nat) (a : seq n F) (v : seq n V),
 T (sum (mult_by_scalars a v)) =' sum (mult_by_scalars a (comp_map_map T v))
 in _.
intros T H; intros.
induction n.
simpl in |- *.
apply Trans with (Build_lin_trafo H (zero V)); auto with algebra.
apply Trans with (T (sum (mult_by_scalars (hdtl a) (hdtl v)))).
apply Ap_comp; auto with algebra.
apply
 Trans
  with (T (sum (head a mX head v;; mult_by_scalars (Seqtl a) (Seqtl v)))).
unfold hdtl in |- *.
apply Ap_comp; auto with algebra.
apply
 Trans
  with (T (head a mX head v +' sum (mult_by_scalars (Seqtl a) (Seqtl v))));
 auto with algebra.
destruct H.
apply
 Trans
  with
    (T (head a mX head v) +' T (sum (mult_by_scalars (Seqtl a) (Seqtl v))));
 auto with algebra.
apply Trans with (sum (mult_by_scalars (hdtl a) (hdtl (comp_map_map T v))));
 auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with
    (sum
       (uncurry (MODULE_comp (R:=F) (Mod:=W))
          (couple (head a) (head (comp_map_map T v)));;
        pointwise (uncurry (MODULE_comp (R:=F) (Mod:=W))) 
          (Seqtl a) (Seqtl (comp_map_map T v)))).
apply
 Trans
  with
    (head a mX head (comp_map_map T v) +'
     sum
       (pointwise (uncurry (MODULE_comp (R:=F) (Mod:=W))) 
          (Seqtl a) (Seqtl (comp_map_map T v)))); auto with algebra.
apply SGROUP_comp.
apply Trans with (head a mX T (head v)); auto with algebra.
fold (mult_by_scalars (Seqtl a) (Seqtl (comp_map_map T v))) in |- *.
apply Trans with (sum (mult_by_scalars (Seqtl a) (comp_map_map T (Seqtl v))));
 auto with algebra.
apply sum_comp; auto with algebra.
apply toMap.
apply mult_by_scalars_comp; auto with algebra.
intro.
simpl in |- *.
destruct x.
unfold comp_map_fun in |- *.
apply Ap_comp; auto with algebra.
apply sum_comp; auto with algebra.
Qed.
