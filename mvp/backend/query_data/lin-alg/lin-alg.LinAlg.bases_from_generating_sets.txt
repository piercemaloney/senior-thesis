
Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases.
(* bases:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
Require Export spans.
Require Export random_facts.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Section Defs.

Definition is_basis (X : part_set V) : Prop :=
  generates X (full V) /\ lin_indep X.

Lemma is_basis_comp :
 forall X Y : part_set V, X =' Y in _ -> is_basis X -> is_basis Y.

Record basis : Type := 
  {basis_carrier :> Predicate V; is_basis_prf : is_basis basis_carrier}.
End Defs.

Lemma basis_prop : forall (X : basis) (x : V), is_lin_comb x X.

Lemma basis_prop_strong :
 forall (n : Nat) (v : seq n V),
 is_basis (seq_set v) ->
 forall x : V, exists a : seq n F, sum (mult_by_scalars a v) =' x in _.

Section Nice_basis_properties.

Variable x : V.
Variable n : Nat.
Variable b : seq n V.
Variable Db : distinct b.
Variable Bb : is_basis (seq_set b).

Let difference_seq : forall (G : group) (a a' : seq n G), seq n G.

Lemma basis_expansion_uniqueness :
 forall a a' : seq n F,
 sum (mult_by_scalars a b) =' x in _ ->
 sum (mult_by_scalars a' b) =' x in _ -> a =' a' in _.

End Nice_basis_properties.

End MAIN. *)
Require Export finite_subsets.
(* finite_subsets:
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Diff.
From Algebra Require Export Singleton.
Require Export cast_between_subsets.
Require Export empty.
Require Export Classical_Prop.

Definition is_finite_set (A : Setoid) :=
  exists n : Nat, (exists v : seq n A, full A =' seq_set v in _).

Definition is_finite_subset (A : Setoid) (B : part_set A) :=
  exists n : Nat, (exists v : seq n A, B =' seq_set v in _).

Lemma is_finite_subset_comp :
 forall (A : Setoid) (B C : part_set A),
 B =' C in _ -> is_finite_subset B -> is_finite_subset C.

Hint Resolve is_finite_subset_comp: algebra.

Lemma is_finite_subset_then_is_finite :
 forall (A : Setoid) (B : part_set A), is_finite_subset B -> is_finite_set B.

Lemma is_finite_set_then_is_finite_subset :
 forall (A : Setoid) (B : part_set A), is_finite_set B -> is_finite_subset B.

Lemma seq_set_is_finite_subset :
 forall (A : Setoid) (n : Nat) (v : seq n A), is_finite_subset (seq_set v).

Lemma included_reflects_is_finite_subset :
 forall (A : Setoid) (B C : part_set A),
 is_finite_subset C -> included B C -> is_finite_subset B. *)
Require Export lin_dep_facts.
(* lin_dep_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
Require Export lin_comb_facts.
Require Export subseqs.
Require Export seq_set_facts.
Require Export distinct_facts.

Lemma rewrite_lin_comb_term :
 forall (F : field) (V : vectorspace F) (n : Nat) (a : seq (S n) F)
   (v : seq (S n) V) (i : fin (S n)),
 ~ a i =' (zero F) in _ ->
 sum (mult_by_scalars a v) =' (zero V) in _ ->
 v i =' field_inverse (a i) mX (min sum (omit (mult_by_scalars a v) i)) in _.

Lemma another_small_lemma :
 forall (V : Setoid) (W : part_set V) (x : V),
 let Wx := union W (single x) in
 forall y : Wx, ~ subtype_elt y =' x in _ -> in_part (subtype_elt y) W.

Lemma lin_dep_vs_span_lemma :
 forall (F : field) (V : vectorspace F) (s : part_set V),
 lin_indep s ->
 forall x : V,
 ~ in_part x s -> (lin_dep (union s (single x)) <-> in_part x (span s)).  

Lemma max_lin_indep_subset_generates_set :
 forall (F : field) (V : vectorspace F) (W W' : part_set V),
 max_lin_indep W' W -> forall w : W, is_lin_comb (subtype_elt w) W'.

Lemma max_lin_indep_subset_has_same_span :
 forall (F : field) (V : vectorspace F) (W W' : part_set V),
 max_lin_indep W' W -> span W =' span W' in part_set V.

Lemma seq_has_max_lin_indep_subseq :
 forall (F : field) (V : vectorspace F) (n : Nat) (v : seq n V),
 exists k : Nat,
   (exists w : seq k V,
      is_subseq w v /\ max_lin_indep (seq_set w) (seq_set v)). *)

Section MAIN.
Variable F : field.
Variable V : vectorspace F.
Variable W0 : part_set V.
Variable H : is_finite_subset W0.
Variable H0 : generates W0 (full V).

Lemma every_finite_generating_set_has_a_subset_that_is_a_basis :
 exists W : part_set W0, is_basis (inject_subsets W).
inversion_clear H.
inversion_clear H1.
assert
 (exists k : Nat,
    (exists v : seq k V,
       is_subseq v x0 /\ max_lin_indep (seq_set v) (seq_set x0))).
apply seq_has_max_lin_indep_subseq; auto with algebra.
inversion_clear H1.
inversion_clear H2.
inversion_clear H1.
assert (forall i : fin x1, in_part (x2 i) W0).
intro.
apply in_part_comp_r with (seq_set x0); auto with algebra.
simpl in |- *.
change (exists i0 : fin x, x2 i =' x0 i0 in _) in |- *.
apply subseq_has_right_elements; auto with algebra.
exists (seq_set (cast_map_to_subset H1)).
red in |- *.
split.
red in |- *.
red in H0.
apply Trans with (span W0:part_set V); auto with algebra.
apply Trans with (span (seq_set x0):part_set V); auto with algebra.
apply Trans with (span (seq_set x2):part_set V).
apply span_comp; auto with algebra.
unfold inject_subsets in |- *.
simpl in |- *.
red in |- *.
simpl in |- *.
split; intros.
inversion_clear H4.
destruct x4.
simpl in H5.
generalize subtype_elt subtype_prf H5; clear H5 subtype_prf subtype_elt. 
intros w wp H5.
inversion_clear wp.
exists x4.
apply Trans with (subtype_elt w); auto with algebra.
apply Trans with (subtype_elt (cast_map_to_subset H1 x4)); auto with algebra.

inversion_clear H4.
generalize (H1 x4); intro.
red in H4.
assert (in_part (Build_subtype H4:W0) (seq_set (cast_map_to_subset H1))).
simpl in |- *.
exists x4.
red in |- *.
simpl in |- *.
unfold cast_to_subset_fun in |- *.
destruct x2.
simpl in |- *.
auto with algebra.
red in H6.
exists (Build_subtype H6).
simpl in |- *.
auto with algebra.

apply Sym.
apply max_lin_indep_subset_has_same_span; auto with algebra.
inversion_clear H3.
inversion_clear H5.
apply lin_indep_comp with (seq_set x2); auto with algebra.
apply Sym.
unfold inject_subsets in |- *.
simpl in |- *.
red in |- *.
simpl in |- *.
split; intros.
inversion_clear H5.
destruct x4.
simpl in H7.
generalize subtype_elt subtype_prf H7; clear H7 subtype_prf subtype_elt. 
intros w wp H7.
inversion_clear wp.
exists x4.
apply Trans with (subtype_elt w); auto with algebra.
apply Trans with (subtype_elt (cast_map_to_subset H1 x4)); auto with algebra.

inversion_clear H5.
generalize (H1 x4); intro.
red in H5.
assert (in_part (Build_subtype H5:W0) (seq_set (cast_map_to_subset H1))).
simpl in |- *.
exists x4.
red in |- *.
simpl in |- *.
unfold cast_to_subset_fun in |- *.
destruct x2.
simpl in |- *.
auto with algebra.
red in H8.
exists (Build_subtype H8).
simpl in |- *.
auto with algebra.
Qed.

Lemma every_finite_generating_set_includes_a_basis :
 exists W : basis V, included W W0.
elim every_finite_generating_set_has_a_subset_that_is_a_basis;
 auto with algebra.
intros.
exists (Build_basis H1).
simpl in |- *.
red in |- *; simpl in |- *.
intros.
inversion_clear H2.
apply in_part_comp_l with (subtype_elt (subtype_elt x1)); auto with algebra.
Qed.

Lemma every_finitely_generated_vectorspace_has_a_finite_basis :
 exists W : part_set V, is_finite_subset W /\ is_basis W.
intros.
assert (exists W : part_set W0, is_basis (inject_subsets W)).
apply every_finite_generating_set_has_a_subset_that_is_a_basis;
 auto with algebra.
inversion_clear H1.
exists (inject_subsets x).
split; auto.
apply included_reflects_is_finite_subset with W0; auto with algebra.
Qed.
End MAIN.