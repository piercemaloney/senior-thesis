
Set Implicit Arguments.
Unset Strict Implicit.

Require Export pointwise.
(* pointwise:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export concat.
From Algebra Require Export Cartesian.

Definition pointwise :
  forall (A B C D : Setoid) (op : Map (cart B C) D) 
    (f : Map A B) (g : Map A C), MAP A D.

Lemma pointwise_comp_general :
 forall (A B C D : Setoid) (op op' : Map (cart B C) D) 
   (f f' : Map A B) (g g' : Map A C),
 op =' op' in MAP _ _ ->
 f =' f' in MAP _ _ ->
 g =' g' in MAP _ _ -> pointwise op f g =' pointwise op' f' g' in _.

Lemma pointwise_comp :
 forall (n : Nat) (B C D : Setoid) (op op' : Map (cart B C) D)
   (f f' : seq n B) (g g' : seq n C),
 op =' op' in MAP _ _ ->
 f =' f' in _ -> g =' g' in _ -> pointwise op f g =' pointwise op' f' g' in _.

Hint Resolve pointwise_comp: algebra.

Lemma pointwise_hd :
 forall (A B C : Setoid) (n : Nat) (v : seq (S n) A) 
   (w : seq (S n) B) (op : Map (cart A B) C) (H : 0 < S n),
 pointwise op v w (Build_finiteT H) ='
 op (couple (v (Build_finiteT H)) (w (Build_finiteT H))) in _.

Hint Resolve pointwise_hd: algebra.

Lemma pointwise_cons :
 forall (A B C : Setoid) (a : A) (b : B) (n : Nat) 
   (v : seq n A) (w : seq n B) (op : Map (cart A B) C),
 pointwise op (a;; v) (b;; w) =' op (couple a b);; pointwise op v w
 in seq _ _.

Hint Resolve pointwise_cons: algebra.

Lemma pointwise_hd_tl :
 forall (A B C : Setoid) (n : Nat) (v : seq (S n) A) 
   (w : seq (S n) B) (op : Map (cart A B) C),
 pointwise op v w ='
 op (couple (head v) (head w));; pointwise op (Seqtl v) (Seqtl w) in 
 seq _ _.

Hint Resolve pointwise_hd_tl: algebra.

Lemma pointwise_Seqtl :
 forall (A B C : Setoid) (n : Nat) (v : seq n A) (w : seq n B)
   (op : Map (cart A B) C),
 pointwise op (Seqtl v) (Seqtl w) =' Seqtl (pointwise op v w) in seq _ _.

Hint Resolve pointwise_Seqtl: algebra.

Lemma pointwise_concat :
 forall (A B C : Setoid) (n m : Nat) (v : seq n A) 
   (w : seq m A) (x : seq n B) (y : seq m B) (op : MAP (cart A B) C),
 pointwise op (v ++ w) (x ++ y) =' pointwise op v x ++ pointwise op w y
 in seq _ _.

Hint Resolve pointwise_concat: algebra. *)
Require Export modify_seq.
(* modify_seq:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Definition modify_seq :
  forall (A : Setoid) (n : Nat), seq n A -> fin n -> A -> seq n A.

Lemma modify_comp :
 forall (A : Setoid) (n : Nat) (a a' : A) (v v' : seq n A) (i i' : fin n),
 a =' a' in _ ->
 v =' v' in _ -> i =' i' in _ -> modify_seq v i a =' modify_seq v' i' a' in _.

Hint Resolve modify_comp: algebra.

Lemma modify_hd_hd :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (H : 0 < S n) (a : A),
 head (modify_seq v (Build_finiteT H) a) =' a in _.

Hint Resolve modify_hd_hd: algebra.

Lemma modify_hd_tl :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (H : 0 < S n) (a : A),
 Seqtl (modify_seq v (Build_finiteT H) a) =' Seqtl v in _.

Hint Resolve modify_hd_tl: algebra.

Lemma modify_tl_hd :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (m : Nat) 
   (H : S m < S n) (a : A),
 head (modify_seq v (Build_finiteT H) a) =' head v in _.

Hint Resolve modify_tl_hd: algebra.

Lemma modify_tl_tl :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (m : Nat) 
   (HS : S m < S n) (H : m < n) (a : A),
 Seqtl (modify_seq v (Build_finiteT HS) a) ='
 modify_seq (Seqtl v) (Build_finiteT H) a in _.

Hint Resolve modify_tl_tl: algebra.

Lemma Seqtl_modify_seq :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (a : A) (H : 0 < S n),
 modify_seq v (Build_finiteT H) a =' a;; Seqtl v in _.

Hint Resolve Seqtl_modify_seq.

Lemma modify_seq_defprop :
 forall (A : Setoid) (n : Nat) (v : seq n A) (i : fin n) (a : A),
 modify_seq v i a i =' a in _.

Hint Resolve modify_seq_defprop: algebra.

Lemma modify_seq_modifies_one_elt :
 forall (A : Setoid) (n : Nat) (v : seq n A) (i : fin n) (a : A) (j : fin n),
 ~ j =' i in _ -> modify_seq v i a j =' v j in _.

Hint Resolve modify_seq_modifies_one_elt: algebra. *)
Require Export vecspaces_verybasic.
(* vecspaces_verybasic:
Section MAIN.
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Field_facts.
Require Export equal_syntax.
Require Export more_syntax.
From Algebra Require Export Module_facts.

Section vecfielddef.

Definition vectorspace (F : field) : Type := MODULE F.
Definition VECSP (F : field) : category :=
  full_subcat (fun V : vectorspace F => V:MODULE F).

End vecfielddef.

Section jargon.
Variable F : field.
Variable V : vectorspace F.
Definition carrier := module_carrier.
Definition scalar_mult (a : F) (x : V) : V := a mX x.

Definition scalar_mult_comp :
  forall (x x' : F) (y y' : carrier V),
  x =' x' in _ -> y =' y' in _ -> x mX y =' x' mX y' in _ :=
  MODULE_comp (R:=F) (Mod:=V).
Definition one_acts_as_unit : forall x : carrier V, one mX x =' x in _ :=
  MODULE_unit_l (R:=F) (Mod:=V).
Definition quasi_associativity :
  forall (a b : F) (x : carrier V), (a rX b) mX x =' a mX b mX x in _ :=
  MODULE_assoc (R:=F) (Mod:=V).
Definition distributivity :
  forall (a : F) (x y : carrier V), a mX (x +' y) =' a mX x +' a mX y in _ :=
  MODULE_dist_l (R:=F) (Mod:=V).
Definition distributivity' :
  forall (a b : F) (x : carrier V), (a +' b) mX x =' a mX x +' b mX x in _ :=
  MODULE_dist_r (R:=F) (Mod:=V).
End jargon.

Variable F : field.
Variable V : vectorspace F.
Hint Unfold carrier module_carrier.
Hint Resolve scalar_mult_comp distributivity distributivity': algebra.

Section Lemmas1.

Lemma vector_cancellation :
 forall x y z : V, x +' z =' y +' z in _ -> x =' y in _.

Lemma Zero_times_a_vector_gives_zero :
 forall v : V, (zero F) mX v =' (zero V) in _.

Lemma a_scalar_times_zero_gives_zero :
 forall f : F, f mX (zero V) =' (zero V) in _.
 
Section Lemmas1_2.

Lemma Mince_minus1 :
 forall (f : F) (v : V), (min f) mX v =' (min f mX v) in _.
 
Lemma Mince_minus2 :
 forall (f : F) (v : V), (min f mX v) =' f mX (min v) in _.
 
Lemma Mince_minus3 :
 forall (f : F) (v : V), (min f) mX v =' f mX (min v) in _.

Lemma vecspace_op_reg_l :
 forall (f : F) (v : V),
 ~ f =' (zero F) in _ -> f mX v =' (zero V) in _ -> v =' (zero V) in _.

End Lemmas1_2.
End Lemmas1.

End MAIN.

Hint Resolve vector_cancellation Zero_times_a_vector_gives_zero
  a_scalar_times_zero_gives_zero Mince_minus1 Mince_minus2 Mince_minus3:
  algebra. *)

Definition mult_by_scalars (R : ring) (V : module R) 
  (N : Nat) (a : Map (fin N) R) (v : Map (fin N) V) : 
  MAP (fin N) V := pointwise (uncurry (MODULE_comp (Mod:=V))) a v.

Lemma mult_by_scalars_comp :
 forall (R : ring) (V : module R) (N : Nat) (a b : MAP (fin N) R)
   (v w : MAP (fin N) V),
 a =' b in _ ->
 v =' w in _ -> mult_by_scalars a v =' mult_by_scalars b w in _.
intros.
unfold mult_by_scalars in |- *.
apply (pointwise_comp_general (A:=fin N) (B:=R) (C:=V) (D:=V));
 auto with algebra.
Qed.

Lemma mult_by_scalars_fun2_compatible :
 forall (R : ring) (V : module R) (N : Nat),
 fun2_compatible
   (mult_by_scalars (V:=V) (N:=N):MAP _ _ -> MAP _ _ -> MAP _ _).
exact mult_by_scalars_comp.
Qed.

Hint Resolve mult_by_scalars_fun2_compatible mult_by_scalars_comp: algebra.

Lemma mult_by_scalars_Seqtl :
 forall (R : ring) (V : module R) (N : Nat) (a : Map (fin N) R)
   (v : Map (fin N) V),
 mult_by_scalars (Seqtl a) (Seqtl v) =' Seqtl (mult_by_scalars a v) in _.
intros.
unfold mult_by_scalars in |- *.
apply Sym; auto with algebra.
Qed.

Hint Resolve mult_by_scalars_Seqtl: algebra.

Lemma mult_by_scalars_concat :
 forall (R : ring) (V : module R) (N M : Nat) (a : Map (fin N) R)
   (b : Map (fin M) R) (v : Map (fin N) V) (w : Map (fin M) V),
 mult_by_scalars (a ++ b) (v ++ w) ='
 mult_by_scalars a v ++ mult_by_scalars b w in _.
intros.
unfold mult_by_scalars in |- *.
auto with algebra.
Qed.

Hint Resolve mult_by_scalars_concat: algebra.

Lemma mult_by_scalars_modify_seq :
 forall (F : field) (V : vectorspace F) (n : Nat) (p : seq n F) 
   (k : seq n V) (i : fin n) (q : F),
 mult_by_scalars (modify_seq p i q) k ='
 modify_seq (mult_by_scalars p k) i (q mX k i) in seq _ _.
simple induction n.
intros; inversion i; inversion in_range_prf.
intros.
case i.
intro; case index.
intros.
apply Trans with (mult_by_scalars (q;; Seqtl p) k); auto with algebra.
apply Trans with (mult_by_scalars (q;; Seqtl p) (head k;; Seqtl k)).
unfold mult_by_scalars in |- *.
apply toMap; apply pointwise_comp; auto with algebra.
apply Trans with (q mX head k;; mult_by_scalars (Seqtl p) (Seqtl k)).
unfold mult_by_scalars in |- *.
apply
 Trans
  with
    (uncurry (MODULE_comp (Mod:=V)) (couple q (head k));;
     pointwise (uncurry (MODULE_comp (R:=F) (Mod:=V))) (Seqtl p) (Seqtl k));
 auto with algebra.
apply Trans with (q mX head k;; Seqtl (mult_by_scalars p k)).
apply cons_comp; auto with algebra.
unfold mult_by_scalars in |- *.
apply
 Trans
  with (q mX k (Build_finiteT in_range_prf);; Seqtl (mult_by_scalars p k));
 auto with algebra.
apply cons_comp; auto with algebra.

intros m Hm.
set (Hm' := lt_S_n _ _ Hm) in *.
apply
 Trans with (hdtl (mult_by_scalars (modify_seq p (Build_finiteT Hm) q) k));
 auto with algebra.
apply
 Trans
  with
    (hdtl
       (modify_seq (mult_by_scalars p k) (Build_finiteT Hm)
          (q mX k (Build_finiteT Hm)))); auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with
    (head (mult_by_scalars p k);;
     Seqtl
       (modify_seq (mult_by_scalars p k) (Build_finiteT Hm)
          (q mX k (Build_finiteT Hm)))); auto with algebra.
apply
 Trans
  with
    (head (mult_by_scalars (modify_seq p (Build_finiteT Hm) q) k);;
     mult_by_scalars (Seqtl (modify_seq p (Build_finiteT Hm) q)) (Seqtl k)).
auto with algebra.
apply
 Trans
  with
    (head (mult_by_scalars (modify_seq p (Build_finiteT Hm) q) k);;
     mult_by_scalars (modify_seq (Seqtl p) (Build_finiteT Hm') q) (Seqtl k)).
apply cons_comp; auto with algebra.
apply cons_comp; auto with algebra.
apply
 Trans
  with
    (mult_by_scalars (Seqtl (modify_seq p (Build_finiteT Hm) q)) (Seqtl k));
 auto with algebra.
apply
 Trans
  with
    (modify_seq (Seqtl (mult_by_scalars p k)) (Build_finiteT Hm')
       (q mX k (Build_finiteT Hm))); auto with algebra.
apply
 Trans
  with
    (modify_seq (mult_by_scalars (Seqtl p) (Seqtl k)) 
       (Build_finiteT Hm') (q mX k (Build_finiteT Hm))); 
 auto with algebra.
apply
 Trans
  with
    (mult_by_scalars (modify_seq (Seqtl p) (Build_finiteT Hm') q) (Seqtl k)).
apply toMap; apply mult_by_scalars_comp; auto with algebra.
apply
 Trans
  with
    (modify_seq (mult_by_scalars (Seqtl p) (Seqtl k)) 
       (Build_finiteT Hm') (q mX Seqtl k (Build_finiteT Hm')));
 auto with algebra.
Qed.

Hint Resolve mult_by_scalars_modify_seq: algebra.