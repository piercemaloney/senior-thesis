
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
(* finite:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Arith.
Require Export equal_syntax.

Definition Nat : Setoid.

Record finiteT (N : Nat) : Type :=  {index : nat; in_range_prf : index < N}.

Definition fin : Nat -> Setoid.

Lemma fin_equation :
 forall (n i j : nat) (Hi : i < n) (Hj : j < n),
 i = j -> Build_finiteT Hi =' Build_finiteT Hj in fin n.

Hint Resolve fin_equation: algebra.

Lemma fin_decidable :
 forall (n : Nat) (i i' : fin n), i =' i' in _ \/ ~ i =' i' in _.

Lemma fin_O_nonexistent : fin 0 -> False.

Hint Resolve fin_O_nonexistent: algebra.

Lemma fin_S_O_unique : forall i j : fin 1, i =' j in _.

Hint Resolve fin_S_O_unique: algebra.

Definition seq (n : Nat) (A : Setoid) := MAP (fin n) A.

Lemma toSeq :
 forall (A : Setoid) (n : Nat) (v v' : Map (fin n) A),
 v =' v' in seq _ _ -> v =' v' in MAP _ _.

Lemma toMap :
 forall (A : Setoid) (n : Nat) (v v' : Map (fin n) A),
 v =' v' in MAP _ _ -> v =' v' in seq _ _.

Hint Resolve toSeq toMap: algebra. *)
From Algebra Require Export Parts.

Section MAIN.

Definition seq_set : forall (A : Setoid) (n : Nat) (v : seq n A), part_set A.
intros.
simpl in |- *.
apply
 (Build_Predicate (Pred_fun:=fun a : A => exists i : fin n, a =' v i in _)).
red in |- *.
intros.
inversion H.
exists x0.
apply Trans with x; auto with algebra.
Defined.

Variable A : Setoid.
Variable n : Nat.

Lemma seq_set_comp :
 forall v v' : seq n A, v =' v' in _ -> seq_set v =' seq_set v' in _.
intros.
simpl in |- *.
red in |- *.
split.
simpl in |- *.
simpl in H.
red in H.
intro P; inversion_clear P.
exists x0.
apply Trans with (v x0); auto with algebra.
simpl in |- *.
simpl in H.
red in H.
intro P; inversion_clear P.
exists x0.
apply Trans with (v' x0); auto with algebra.
Qed.

End MAIN.
Hint Resolve seq_set_comp: algebra.
