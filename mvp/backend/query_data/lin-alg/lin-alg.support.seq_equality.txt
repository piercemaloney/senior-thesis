
Set Implicit Arguments.
Unset Strict Implicit.
Require Export cast_seq_lengths.
(* cast_seq_lengths:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.

Section MAIN.
Lemma lt_comp : forall m n n' : Nat, m < n -> n =' n' in _ -> m < n'.

Definition cast_fin : forall n n' : Nat, fin n -> n =' n' in _ -> fin n'.

Lemma cast_fin_comp :
 forall (n n' : Nat) (i i' : fin n) (H H' : n =' n' in _),
 i =' i' in _ -> cast_fin i H =' cast_fin i' H' in _.

Hint Resolve cast_fin_comp: algebra.

Variable A : Setoid.

Definition cast_seq : forall n n' : Nat, seq n A -> n =' n' in _ -> seq n' A.

Lemma cast_seq_comp :
 forall (n n' : Nat) (v v' : seq n A) (H H' : n =' n' in _),
 v =' v' in _ -> cast_seq v H =' cast_seq v' H' in _.

Hint Resolve cast_seq_comp: algebra.

Variable n n' : Nat.
Variable v : seq n A.

Lemma cast_seq_cast_fin :
 forall (i : fin n) (H H' : n =' n' in _),
 v i =' cast_seq v H (cast_fin i H') in _.

Lemma cast_seq_cast_fin' :
 forall (i : fin n') (H : n =' n' in _) (H' : n' =' n in _),
 cast_seq v H i =' v (cast_fin i H') in _.

Hint Resolve cast_seq_cast_fin cast_seq_cast_fin': algebra.
End MAIN.
Hint Resolve cast_fin_comp: algebra.
Hint Resolve cast_seq_comp: algebra.
Hint Resolve cast_seq_cast_fin cast_seq_cast_fin': algebra. *)

Definition seq_equal (A : Setoid) (n m : Nat) (v : seq n A) 
  (w : seq m A) :=
  forall i : Nat,
  (exists p : i < n,
     (exists q : i < m, v (Build_finiteT p) =' w (Build_finiteT q) in _)) \/
  n <= i /\ m <= i.

Lemma Map_eq_seq_equal :
 forall (A : Setoid) (n : Nat) (v w : seq n A), v =' w in _ -> seq_equal v w.
intros.
red in |- *.
intro.
generalize (le_or_lt n i).
intro p; inversion_clear p.
right; split; auto.
left.
repeat exists H0.
simpl in H; red in H; simpl in H; apply H.
Qed.

Lemma seq_equal_map_equal :
 forall (A : Setoid) (n : Nat) (v w : seq n A), seq_equal v w -> v =' w in _.
intros.
simpl in |- *.
red in |- *.
intro.
red in H.
destruct x.
rename index into i.
generalize (H i); clear H; intro.
inversion_clear H.
inversion_clear H0.
inversion_clear H.
apply Trans with (v (Build_finiteT x)).
apply Ap_comp; auto with algebra; simpl in |- *; auto.
apply Trans with (w (Build_finiteT x0)); auto with algebra.
apply Ap_comp; auto with algebra; simpl in |- *; auto.
inversion_clear H0; (apply False_ind; auto with algebra).
apply (le_not_lt n i); auto with algebra.
Qed.

Hint Resolve seq_equal_map_equal: algebra.

Lemma seq_equal_refl :
 forall (A : Setoid) (n : Nat) (v : seq n A), seq_equal v v.
intros.
apply Map_eq_seq_equal; auto with algebra.
Qed.

Hint Resolve seq_equal_refl: algebra.

Lemma seq_equal_symm :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A),
 seq_equal v w -> seq_equal w v.
intros.
red in |- *; red in H; intro; generalize (H i); clear H; intro.
inversion_clear H.
left.
inversion_clear H0.
inversion_clear H.
exists x0.
exists x.
apply Sym; auto with algebra.
right.
inversion_clear H0; split; trivial.
Qed.

Hint Immediate seq_equal_symm: algebra.

Lemma seq_equal_trans :
 forall (A : Setoid) (n m l : Nat) (v : seq n A) (w : seq m A) (u : seq l A),
 seq_equal v w -> seq_equal w u -> seq_equal v u.
intros.
red in H, H0.
red in |- *; intro.
generalize (H i) (H0 i); clear H H0; intros.
inversion_clear H; inversion_clear H0.
left.
inversion_clear H1; inversion_clear H.
exists x.
inversion_clear H0; inversion_clear H1.
exists x2.
apply Trans with (w (Build_finiteT x1)); auto with algebra.
apply Trans with (w (Build_finiteT x0)); auto with algebra.
inversion_clear H1; inversion_clear H.
inversion_clear H0.
apply False_ind; auto with algebra.
generalize (lt_not_le i m); intro p; red in p.
auto.
inversion_clear H1; inversion_clear H.
apply False_ind; auto with algebra.
generalize (lt_not_le i m); intro p; red in p.
auto.
right.
inversion_clear H; inversion_clear H1; split; auto.
Qed.

Hint Resolve seq_equal_trans: algebra.

Lemma cast_seq_preserves_seq_equal :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (H : n =' m in _),
 seq_equal v (cast_seq v H).
red in |- *; intros.
generalize (le_or_lt n i).
intro p; inversion_clear p.
right.
split; try trivial.
rewrite <- H.
trivial.
left.
exists H0.
exists (lt_comp H0 H).
apply Trans with (cast_seq v H (cast_fin (Build_finiteT H0) H)).
apply cast_seq_cast_fin; auto with algebra.
unfold cast_fin in |- *.
auto with algebra.
Qed.

Hint Resolve cast_seq_preserves_seq_equal: algebra.