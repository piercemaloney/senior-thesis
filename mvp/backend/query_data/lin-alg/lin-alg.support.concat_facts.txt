
Set Implicit Arguments.
Unset Strict Implicit.
Require Export concat.
(* concat:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Section MAIN.
Variable A : Setoid.

Definition concat :
  forall (n m : Nat) (f : seq n A) (g : seq m A), seq (n + m) A.

Infix "++" := concat (at level 60, right associativity).

Lemma concat_comp :
 forall (n m : Nat) (f f' : seq n A) (g g' : seq m A),
 f =' f' in _ -> g =' g' in _ -> f ++ g =' f' ++ g' in _.

Hint Resolve concat_comp: algebra.

Variable n m : Nat.

Lemma cons_concat :
 forall (a a' : A) (v v' : seq n A) (w w' : seq m A),
 a =' a' in _ ->
 v =' v' in _ -> w =' w' in _ -> a;; v ++ w =' (a';; v') ++ w' in _.

Hint Resolve cons_concat: algebra.

Lemma concat_cons :
 forall (a a' : A) (v v' : seq n A) (w w' : seq m A),
 a =' a' in _ ->
 v =' v' in _ -> w =' w' in _ -> (a';; v') ++ w' =' a;; v ++ w in _.

Hint Resolve concat_cons: algebra.

Lemma cons_concat_special :
 forall (a : A) (v : seq n A) (v' : seq m A),
 a;; v ++ v' =' (a;; v) ++ v' in _. 

Lemma concat_first_element :
 forall (v : seq (S n) A) (w : seq m A) (Hnm : 0 < S (n + m)) (Hn : 0 < S n),
 (v ++ w) (Build_finiteT Hnm) =' v (Build_finiteT Hn) in _.

Lemma head_eats_concat :
 forall (v : seq (S n) A) (w : seq m A), head (v ++ w) =' head v in _.

Lemma Seqtl_concat :
 forall (v : seq (S n) A) (w : seq m A), Seqtl (v ++ w) =' Seqtl v ++ w in _.

Lemma concat_Seqtl :
 forall (v : seq (S n) A) (w : seq m A), Seqtl v ++ w =' Seqtl (v ++ w) in _.

End MAIN.

Infix "++" := concat (at level 60, right associativity).
Hint Resolve concat_comp: algebra.
Hint Resolve cons_concat concat_cons: algebra.
Hint Resolve concat_first_element head_eats_concat: algebra.
Hint Resolve Seqtl_concat concat_Seqtl: algebra.
Hint Resolve cons_concat_special: algebra. *)
Require Export empty.
(* empty:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_set.

Definition empty_seq : forall A : Setoid, seq 0 A.

Lemma seq_O_is_empty :
 forall (A : Setoid) (v : seq 0 A), v =' empty_seq A in _.

Hint Resolve seq_O_is_empty: algebra.

Lemma seq_set_empty_seq_is_empty :
 forall (A : Setoid) (v : seq 0 A), seq_set v =' empty A in _.

Hint Resolve seq_set_empty_seq_is_empty: algebra.

Lemma no_seq_n_empty :
 forall (n : Nat) (A : Setoid) (W : part_set A),
 W =' empty A in _ -> seq n W -> n =' 0 in _. *)

Section MAIN.
Variable A : Setoid.
Variable n m : Nat.
Variable v : seq n A.
Variable w : seq m A.

Lemma concat_first_part :
 forall (i : Nat) (Hi : i < n) (Hi' : i < n + m),
 (v ++ w) (Build_finiteT Hi') =' v (Build_finiteT Hi) in _.
induction n.
intros.
inversion Hi.
intro.
case i.
unfold concat in |- *.
unfold nat_rect in |- *.
simpl in |- *.
intros.
apply Ap_comp; auto with algebra.
intros.
apply Trans with (hdtl v (Build_finiteT Hi)).
apply Trans with ((hdtl v ++ w) (Build_finiteT Hi')).
apply concat_comp; auto with algebra.
2: apply Ap_comp; auto with algebra.
unfold hdtl in |- *.
apply Trans with ((head v;; Seqtl v ++ w) (Build_finiteT Hi'));
 auto with algebra.
apply Trans with (Seqtl v (Build_finiteT (lt_S_n _ _ Hi))); auto with algebra.
apply Trans with ((Seqtl v ++ w) (Build_finiteT (lt_S_n _ _ Hi')));
 auto with algebra.
Qed.

Hint Resolve concat_first_part: algebra.

Lemma concat_second_part :
 forall (i : Nat) (Hi : i < m) (Hi' : n + i < n + m),
 (v ++ w) (Build_finiteT Hi') =' w (Build_finiteT Hi) in _.
induction n.
intros.
unfold concat in |- *.
unfold nat_rect in |- *.
apply Ap_comp; auto with algebra.
intros.
apply Trans with ((hdtl v ++ w) (Build_finiteT Hi')); auto with algebra.
unfold hdtl in |- *.
apply Trans with ((head v;; Seqtl v ++ w) (Build_finiteT Hi'));
 auto with algebra.
cut (S (c + i) < S (c + m)).
intro.
apply Trans with ((Seqtl v ++ w) (Build_finiteT (lt_S_n _ _ H)));
 auto with algebra.
apply Trans with ((head v;; Seqtl v ++ w) (Build_finiteT H));
 auto with algebra.
replace (S (c + i)) with (S c + i).
assumption.
auto.
Qed.

Hint Resolve concat_second_part: algebra.

Lemma concat_prop_per_part :
 forall P : Predicate A,
 (forall (i : Nat) (Hi : i < n), Pred_fun P (v (Build_finiteT Hi))) ->
 (forall (j : nat) (Hj : j < m), Pred_fun P (w (Build_finiteT Hj))) ->
 forall (k : nat) (Hk : k < n + m), Pred_fun P ((v ++ w) (Build_finiteT Hk)).
induction n.
intros.
unfold concat in |- *; unfold nat_rect in |- *.
apply H0.
intros.
generalize Hk; clear Hk; case k; [ intro Hk | intros k0 Hk0 ].
generalize (lt_O_Sn c); intro Hk'.
apply (Pred_compatible_prf (p:=P)) with (v (Build_finiteT Hk'));
 auto with algebra.
simpl in |- *.
apply Ap_comp; auto with algebra.
generalize (lt_S_n _ _ Hk0); intro Hk0'.
fold (c + m) in Hk0'.
apply (Pred_compatible_prf (p:=P)) with ((Seqtl v ++ w) (Build_finiteT Hk0')).
apply IHc; auto with algebra.
clear Hk0' Hk0 k0 k.
intros.
apply (Pred_compatible_prf (p:=P)) with (v (Build_finiteT (lt_n_S _ _ Hi)));
 auto with algebra.

apply Trans with (Seqtl (v ++ w) (Build_finiteT Hk0')).
apply Sym.
generalize Seqtl_to_seq.
intros.
apply (H1 _ _ (v ++ w) _ Hk0' Hk0).
generalize Seqtl_concat.
intro p.
apply Ap_comp; auto with algebra.
Qed.

Lemma concat_prop_per_element :
 forall P : Predicate A,
 (forall (i : Nat) (Hi : i < n) (Hi' : i < n + m),
  Pred_fun P ((v ++ w) (Build_finiteT Hi'))) ->
 (forall (j : Nat) (Hj : j < m) (Hj' : n + j < n + m),
  Pred_fun P ((v ++ w) (Build_finiteT Hj'))) ->
 forall (k : Nat) (Hk : k < n + m), Pred_fun P ((v ++ w) (Build_finiteT Hk)).
intros.
apply concat_prop_per_part.
intros.
generalize (H i Hi); intro.
apply
 (Pred_compatible_prf (p:=P))
  with ((v ++ w) (Build_finiteT (lt_plus_trans _ _ m Hi))).
apply H1.
apply Sym.
apply concat_first_part.
intros.
cut (n + j < n + m).
intro Hj'.
apply (Pred_compatible_prf (p:=P)) with ((v ++ w) (Build_finiteT Hj'));
 auto with algebra.
auto with arith.
Qed.

Lemma split_to_concat :
 forall vw : seq (n + m) A, sigT (fun a => sigT (fun b => vw =' a ++ b in _)).
clear v w.
induction n.
intros.
exists (empty_seq A).
simpl in vw.
exists vw.
simpl in |- *.
red in |- *.
auto with algebra.

clear n; intros.
generalize (IHc (Seqtl vw)).
intros.
inversion_clear X.
exists (head vw;; x).
inversion_clear X0.
exists x0.
apply Trans with (hdtl vw); auto with algebra.
change (vw =' hdtl vw in seq (S (c + m)) A) in |- *.
apply hdtl_x_is_x.
unfold hdtl in |- *.
apply Trans with (head vw;; x ++ x0); auto with algebra.
change (head vw;; Seqtl vw =' head vw;; (x ++ x0:seq (c + m) A) in _) in |- *.
apply cons_comp; auto with algebra.
apply cons_concat_special with (a := head vw) (v := x) (v' := x0).
Qed.
End MAIN.

Hint Resolve concat_first_part: algebra.
Hint Resolve concat_second_part: algebra.