
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
(* Map_embed:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export concat.

Definition Map_embed :
  forall (X E : Setoid) (A : part_set E) (f : Map X A), MAP X E.

Lemma Map_embed_comp :
 forall (X E : Setoid) (A : part_set E) (f g : Map X A),
 f =' g in MAP _ _ -> Map_embed f =' Map_embed g in _.

Hint Resolve Map_embed_comp: algebra.

Lemma Map_embed_cons :
 forall (E : Setoid) (A : part_set E) (a : A) (n : Nat) (f : seq n A),
 Map_embed (a;; f) =' subtype_elt a;; Map_embed f in seq _ _.

Hint Resolve Map_embed_cons: algebra.

Lemma cons_Map_embed :
 forall (E : Setoid) (A : part_set E) (a : A) (n : Nat) (f : seq n A),
 subtype_elt a;; Map_embed f =' Map_embed (a;; f) in seq _ _.

Hint Resolve cons_Map_embed: algebra.

Lemma Map_embed_Seqtl :
 forall (E : Setoid) (A : part_set E) (n : Nat) (f : seq n A),
 Map_embed (Seqtl f) =' Seqtl (Map_embed f) in seq _ _.

Hint Resolve Map_embed_Seqtl: algebra.

Lemma Seqtl_Map_embed :
 forall (E : Setoid) (A : part_set E) (n : Nat) (f : seq n A),
 Seqtl (Map_embed f) =' Map_embed (Seqtl f) in seq _ _.

Hint Resolve Seqtl_Map_embed: algebra.

Lemma Map_embed_concat :
 forall (E : Setoid) (A : part_set E) (n m : Nat) (f : seq n A) (g : seq m A),
 Map_embed (f ++ g) =' Map_embed f ++ Map_embed g in seq _ _.

Hint Resolve Map_embed_concat: algebra.

Lemma concat_Map_embed :
 forall (E : Setoid) (A : part_set E) (n m : Nat) (f : seq n A) (g : seq m A),
 Map_embed f ++ Map_embed g =' Map_embed (f ++ g) in seq _ _.

Hint Resolve concat_Map_embed.

Lemma Map_embed_prop :
 forall (A D : Setoid) (B : part_set A) (v : MAP D B) (i : D),
 in_part (Map_embed v i) B. *)
Require Export algebra_omissions.
(* algebra_omissions:
From Algebra Require Export Group_facts.
Set Implicit Arguments.
Unset Strict Implicit.

Lemma group_inverse_inj :
 forall (G : GROUP) (g g' : G),
 Equal (group_inverse _ g) (group_inverse _ g') -> Equal g g'.

Definition min_inj := group_inverse_inj.

Lemma subtype_elt_comp :
 forall (A : Setoid) (B : part_set A) (b b' : B),
 Equal b b' -> Equal (subtype_elt b) (subtype_elt b').

Lemma subtype_elt_inj :
 forall (A : Setoid) (B : part_set A) (b b' : B),
 Equal (subtype_elt b) (subtype_elt b') -> Equal b b'.

Hint Resolve subtype_elt_comp: algebra.

Lemma in_part_subtype_elt :
 forall (A : Setoid) (B : part_set A) (b : B), in_part (subtype_elt b) B.

Hint Resolve in_part_subtype_elt: algebra.

Definition inject_subsets :
  forall (A : Setoid) (B : part_set A), part_set B -> part_set A.

Lemma inject_subsets_comp :
 forall (A : Setoid) (B : part_set A) (C C' : part_set B),
 Equal C C' -> Equal (inject_subsets C) (inject_subsets C').

Hint Resolve inject_subsets_comp: algebra.

Lemma inject_subsets_of_part_set_included :
 forall (A : Setoid) (B : part_set A) (C : part_set B),
 included (inject_subsets C) B.

Hint Resolve inject_subsets_of_part_set_included: algebra.

Lemma inject_subsets_full_inv :
 forall (A : Setoid) (B : part_set A), Equal (inject_subsets (full B)) B.

Hint Resolve inject_subsets_full_inv: algebra.

Definition inject_subsetsify :
  forall (A : Setoid) (B : part_set A) (C : part_set B),
  C -> inject_subsets C.

Lemma inject_subsetsify_comp :
 forall (A : Setoid) (B : part_set A) (C : part_set B) (c c' : C),
 Equal c c' -> Equal (inject_subsetsify c) (inject_subsetsify c').

Definition uninject_subsetsify :
  forall (A : Setoid) (B : part_set A) (C : part_set B),
  inject_subsets C -> C.

Lemma uninject_subsetsify_comp :
 forall (A : Setoid) (B : part_set A) (C : part_set B),
 fun_compatible (uninject_subsetsify (A:=A) (B:=B) (C:=C)).

Lemma in_part_included :
 forall (A : Setoid) (B C : part_set A) (a : A),
 in_part a B -> included B C -> in_part a C.

Lemma exists_difference :
 forall n m : nat, n <= m -> exists q : nat, m = n + q. *)
From Algebra Require Export Sub_monoid.
Require Export more_syntax.
(* more_syntax:
From Algebra Require Export Module_cat.

Notation "a +' b" := (sgroup_law _ a b) (at level 50, left associativity).

Notation "'zero' a" := (monoid_unit a) (at level 100).

Notation one := (ring_unit _).

Notation "a 'mX' b" := (module_mult a b) (at level 42, right associativity).

Notation "a 'rX' b" := (ring_mult a b) (at level 42, right associativity).

Notation "'min' a" := (group_inverse _ a) (at level 100). *)

Fixpoint sum (V : monoid) (n : Nat) {struct n} : seq n V -> V :=
  match n return (seq n V -> V) with
  | O => fun x : seq 0 V => zero V
  | S m => fun x : seq (S m) V => head x +' sum (Seqtl x)
  end.

Lemma sum_comp :
 forall (M : monoid) (n : Nat) (f f' : seq n M),
 f =' f' in _ -> sum f =' sum f' in _.
induction n.
intros.
simpl in |- *.
apply Refl.
intros.
unfold sum in |- *.
apply SGROUP_comp; auto with algebra.
apply IHn.
change (Seqtl f =' Seqtl f' in _) in |- *.
apply Seqtl_comp; auto with algebra.
Qed.

Hint Resolve sum_comp: algebra.

Lemma sum_cons :
 forall (M : monoid) (m : M) (n : Nat) (f : seq n M),
 sum (m;; f) =' m +' sum f in _.
intros.
induction  n as [| n Hrecn].
simpl in |- *.
apply Refl.
unfold sum at 1 in |- *.
apply SGROUP_comp; auto with algebra.
apply sum_comp.
generalize dependent (Seqtl_cons_inv m f); intro p.
apply p.
Qed.

Hint Resolve sum_cons: algebra.

Lemma sum_concat :
 forall (n m : Nat) (G : monoid) (a : seq n G) (b : seq m G),
 sum (a ++ b) =' sum a +' sum b in _.
induction n.
intros.
apply Trans with ((zero G) +' sum b); auto with algebra.
intros.
apply Trans with (sum (hdtl a) +' sum b); auto with algebra.
apply Trans with (sum (hdtl a ++ b)); auto with algebra.
apply Trans with (sum (head a;; Seqtl a ++ b)).
unfold hdtl in |- *.
apply sum_comp; auto with algebra.
unfold hdtl in |- *.
apply Trans with (head a +' sum (Seqtl a ++ b)); auto with algebra.
apply Trans with (head a +' sum (Seqtl a) +' sum b); auto with algebra.
apply Trans with (head a +' (sum (Seqtl a) +' sum b)); auto with algebra.
Qed.

Hint Resolve sum_concat: algebra.

Lemma subtype_sum :
 forall (n : nat) (A : monoid) (B : submonoid A) (c : seq n B),
 subtype_elt (sum c) =' sum (Map_embed c) in _.
intros.
apply Sym.
induction n.
simpl in |- *.
auto with algebra.
apply Trans with (head (Map_embed c) +' sum (Seqtl (Map_embed c)));
 auto with algebra.
apply Trans with (subtype_elt (head c +' sum (Seqtl c))).
apply Trans with (subtype_elt (head c) +' subtype_elt (sum (Seqtl c)));
 auto with algebra.
apply Trans with (head (Map_embed c) +' sum (Map_embed (Seqtl c)));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply sum_comp; auto with algebra.
apply Sym; auto with algebra.
generalize Map_embed_Seqtl.
intro p.
apply (p _ _ _ (c:seq _ _)).
apply subtype_elt_comp.
apply Sym; auto with algebra.
Qed.
