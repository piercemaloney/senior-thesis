
Set Nested Proofs Allowed.
Require Export Matrices. 
(* Matrices:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map2.
Require Export vecspace_Fn.

Definition Matrix_general_type (A : Setoid) (n m : Nat) :=
  MAP2 (fin n) (fin m) A.

Definition matrix (F : field) := Matrix_general_type F.

Section add.
Let matrix_addition_fun (F : field) (m n : Nat) (M N : matrix F m n) :
  matrix F m n.

Definition matrix_addition (F : field) (m n : Nat) :
  MAP2 (matrix F m n) (matrix F m n) (matrix F m n).
End add.

Section mult.
Definition matrix_scmult_fun (F : field) (m n : Nat) 
  (c : F) (M : matrix F m n) : matrix F m n.

Definition matrix_scmult (F : field) (m n : Nat) :
  MAP2 F (matrix F m n) (matrix F m n).
End mult.

Section transpose.
Definition transpose :
  forall (F : field) (m n : Nat), matrix F m n -> matrix F n m.

Definition transpose_map :
  forall (F : field) (m n : Nat), MAP (matrix F m n) (matrix F n m).

Lemma transpose_defprop :
 forall (F : field) (m n : Nat) (M : matrix F m n) (i : fin n) (j : fin m),
 transpose M i j =' M j i in _.
End transpose.
Hint Resolve transpose_defprop: algebra.

Definition zero_matrix : forall (F : field) (n m : Nat), matrix F n m.

Definition is_square (F : field) (n m : Nat) (M : matrix F n m) :=
  n =' m in _.

Definition is_diagonal (F : field) (n : Nat) (M : matrix F n n) :=
  forall i j : fin n, index i <> index j -> M i j =' (zero F) in _.

Definition identity_matrix : forall (F : field) (n : Nat), matrix F n n.

Lemma id_is_square :
 forall (F : field) (n : Nat), is_square (identity_matrix F n).

Definition row (F : field) :
  forall m n : Nat, matrix F m n -> fin m -> Fn F n :=
  fun n m M i => Ap2_Map M i.

Definition col (F : field) :
  forall m n : Nat, matrix F m n -> fin n -> Fn F m :=
  fun n m M j => Ap2_Map' M j.

Lemma row_transpose_col :
 forall (F : field) (m n : Nat) (M : matrix F m n) (i : fin m),
 row M i =' col (transpose M) i in _.

Lemma row_comp :
 forall (F : field) (m n : Nat) (M M' : matrix F m n) (i i' : fin m),
 M =' M' in _ -> i =' i' in _ -> row M i =' row M' i' in _.

Lemma col_comp :
 forall (F : field) (m n : Nat) (M M' : matrix F m n) (i i' : fin n),
 M =' M' in _ -> i =' i' in _ -> col M i =' col M' i' in _.

Hint Resolve row_comp col_comp: algebra. *)
From Algebra Require Export Algebra.

Require Export vecspace_Mmn.
(* vecspace_Mmn:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Matrices.

Section Vectorspace.
Variable F : field.
Variable m n : Nat.

Definition Mmn_set : SET.

Let add_law : law_of_composition Mmn_set.

Definition Mmn_sgp : SGROUP.

Definition Mmn_mon : MONOID.

Section group.
Let minmatrix : Mmn_mon -> Mmn_mon.

Let minmatrixmap : Map Mmn_mon Mmn_mon.

Definition Mmn_gp : GROUP.
End group.

Definition Mmn_abgp : ABELIAN_GROUP.

Section module.
Let scmult_sgp_fun : F -> Endo_SET Mmn_abgp.

Let scmult_sgp_map : Map (Build_monoid (ring_monoid F)) (Endo_SET Mmn_abgp).

Let scmult_sgp_hom :
  sgroup_hom (Build_monoid (ring_monoid F)) (Endo_SET Mmn_abgp).

Let scmult_mon_hom :
  monoid_hom (Build_monoid (ring_monoid F)) (Endo_SET Mmn_abgp).

Definition Mmn : VECSP F.
End module.
End Vectorspace.

Definition row_Map2 :
  forall (F : field) (m n : Nat), MAP2 (Mmn F m n) (fin m) (Fn F n).

Definition col_Map2 :
  forall (F : field) (m n : Nat), MAP2 (Mmn F m n) (fin n) (Fn F m). *)
From Algebra Require Export Cfield_facts.
Variable F : cfield.
Definition Mmn_alg (n : nat) : algebra F.
intros.
apply Build_algebra with (Mmn F n n).
apply Build_algebra_on.
simpl in |- *.
Require Export Matrix_multiplication.
(* Matrix_multiplication:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export vecspace_Mmn.
Require Export pointwise.
Require Export sums.

Section matrix_x_vector.
Definition mat_vec_mult_fun :
  forall (F : field) (m n : Nat), Mmn F m n -> Fn F n -> Fn F m.

Definition matXvec :
  forall (F : field) (m n : Nat), Map2 (Mmn F m n) (Fn F n) (Fn F m).
End matrix_x_vector.

Section matrix_x_matrix.
Definition mat_mat_mult_fun :
  forall (F : field) (m n p : Nat), Mmn F m n -> Mmn F n p -> Mmn F m p.

Definition matXmat :
  forall (F : field) (m n p : Nat), Map2 (Mmn F m n) (Mmn F n p) (Mmn F m p).
End matrix_x_matrix.

Section facts.
Variable F : field.
Variable n m p : Nat.
Variable M : Mmn F m n.
Variable N : Mmn F n p.
Lemma matXmat_col :
 forall i : fin p,
 col (matXmat _ _ _ _ M N) i =' matXvec _ _ _ M (col N i) in _.
End facts.

Section morefacts.
From Algebra Require Export Cfield_facts.
Variable F : cfield.
Variable n m p : Nat.
Variable M : Mmn F m n.
Variable N : Mmn F n p.
Lemma matXmat_row :
 forall i : fin m,
 row (matXmat _ _ _ _ M N) i =' matXvec _ _ _ (transpose N) (row M i) in _.
End morefacts. *)

Let mult_arr :
  forall n : nat, Mmn F n n -> sgroup_hom (Mmn F n n) (Mmn F n n).
intros.
apply Build_sgroup_hom with (Ap2_Map (matXmat F n n n) X).
red in |- *.
intros.
simpl in |- *.
intros.
apply
 Trans
  with
    (sum
       (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col x j +' col y j)));
 auto with algebra.
apply
 Trans
  with
    (sum (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col x j)) +'
     sum (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col y j))).
Require Export random_facts.
(* random_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Section MAIN.
Require Export concat_facts.
Require Export sums2.
Require Export mult_by_scalars.
Require Export vecspace_Fn.

Lemma inject_map_embed_seq_set :
 forall (A : Setoid) (B : part_set A) (n : Nat) (v : seq n B),
 inject_subsets (seq_set v) =' seq_set (Map_embed v) in _.

Section concat_const_seq.
Variable A : Setoid.
Let eqa : forall a : A, Predicate A.

Lemma concat_const_seq :
 forall (n m : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ ->
 const_seq n a ++ const_seq m a' =' const_seq (n + m) a'' in _.
End concat_const_seq.

Section mult_facts.
Variable F : field.
Variable V : vectorspace F.
Lemma mult_const_Zero :
 forall (n : Nat) (v : seq n V),
 mult_by_scalars (const_seq n (zero F)) v =' const_seq n (zero V) in seq _ _.

Lemma mult_const_zero :
 forall (n : Nat) (a : seq n F),
 mult_by_scalars a (const_seq n (zero V)) =' const_seq n (zero V) in seq _ _.
End mult_facts.

Hint Resolve mult_const_Zero mult_const_Zero: algebra.

Section proj_via_mult_by_scalars.

Let basisvec0prop :
  forall (F : field) (n : Nat) (H : 0 < S n),
  Seqtl (Basisvec_Fn F H) =' const_seq n (zero F) in _.

Let basisvecprop2 :
  forall (F : field) (n i : Nat) (H : i < n) (HS : S i < S n),
  Seqtl (Basisvec_Fn F HS) =' Basisvec_Fn F H in _.

Lemma projection_via_mult_by_scalars :
 forall (F : field) (M : module F) (n i : Nat) (Hi Hi' : i < n) (v : seq n M),
 v (Build_finiteT Hi) =' sum (mult_by_scalars (Basisvec_Fn F Hi') v) in _.

End proj_via_mult_by_scalars.

Lemma sum_of_sums :
 forall (n : Nat) (M : abelian_monoid) (v v' : seq n M),
 sum (pointwise (sgroup_law_map M) v v') =' sum v +' sum v' in _.

End MAIN. *)
apply
 Trans
  with
    (sum
       (pointwise (sgroup_law_map F)
          (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col x j))
          (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col y j)))).
2: apply
    (sum_of_sums (n:=n) (M:=F)
       (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col x j))
       (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col y j)));
    auto with algebra.
apply sum_comp; auto with algebra.
simpl in |- *.
red in |- *.
intros.
simpl in |- *.
apply Trans with (X i x0 rX x x0 j +' X i x0 rX y x0 j); auto with algebra.
generalize row_comp; intro Hr; simpl in Hr.
generalize col_comp; intro Hc; simpl in Hc.
apply SGROUP_comp.
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
destruct x; destruct X.
intro.
simpl in |- *.
apply RING_comp.
red in Ap2_comp_proof0.
auto with algebra.
red in Ap2_comp_proof.
auto with algebra.
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
destruct y; destruct X.
intro.
simpl in |- *.
apply RING_comp.
red in Ap2_comp_proof0.
auto with algebra.
red in Ap2_comp_proof.
auto with algebra.
Defined.

Let mult_arr_mon :
  forall n : nat, Mmn F n n -> monoid_hom (Mmn F n n) (Mmn F n n).
intros.
apply Build_monoid_hom with (mult_arr n X).
red in |- *.
simpl in |- *.
intros.
apply Trans with (sum (const_seq n (zero F))); auto with algebra.
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
auto with algebra.
Defined.

Let mult_arr_mod :
  forall n : nat, Mmn F n n -> module_hom (Mmn F n n) (Mmn F n n).
intros.
apply Build_module_hom with (mult_arr_mon n X).
red in |- *.
intros.
simpl in |- *.
intros.
apply
 Trans
  with
    (a rX sum (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col x j))).
2: apply RING_comp; auto with algebra.
2: apply sum_comp.
2: simpl in |- *.
2: red in |- *.
2: simpl in |- *.
2: intro.
2: apply RING_comp; auto with algebra.
2: destruct X.
2: simpl in |- *.
2: red in Ap2_comp_proof.
2: auto with algebra.
2: destruct x.
2: simpl in |- *.
2: red in Ap2_comp_proof.
2: auto with algebra.
apply
 Trans
  with
    (sum
       (pointwise (uncurry (RING_comp (R:=F))) (const_seq n a)
          (pointwise (uncurry (RING_comp (R:=F))) (row X i) (col x j)))).
apply sum_comp.
simpl in |- *.
red in |- *.
intro.
simpl in |- *.
auto with algebra.
apply Sym.
Require Export distribution_lemmas.
(* distribution_lemmas:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export mult_by_scalars.
Require Export const.
Require Export sums.

Lemma RING_sum_mult_dist_l :
 forall (R : ring) (n : Nat) (r : R) (a : seq n R),
 r rX sum a =' sum (pointwise (uncurry (RING_comp (R:=R))) (const_seq n r) a)
 in _.

Lemma MODULE_sum_mult_dist_l :
 forall (R : ring) (M : module R) (n : Nat) (r : R) (a : seq n M),
 r mX sum a =' sum (mult_by_scalars (const_seq n r) a) in _.

Hint Resolve RING_sum_mult_dist_l MODULE_sum_mult_dist_l: algebra.

Lemma pointwise_module_assoc :
 forall (R : ring) (M : module R) (n : Nat) (r r' : seq n R) (m : seq n M),
 let rmult := uncurry (RING_comp (R:=R)) in
 mult_by_scalars r (mult_by_scalars r' m) ='
 mult_by_scalars (pointwise rmult r r') m in _.

Hint Resolve pointwise_module_assoc: algebra. *)
apply RING_sum_mult_dist_l.
Defined.

Let mult_map_mod :
  forall n : nat, Map (Mmn F n n) (Hom_module (Mmn F n n) (Mmn F n n)).
intros.
apply Build_Map with (mult_arr_mod n).
red in |- *.
intros; simpl in |- *.
simpl in H.
red in |- *; simpl in |- *.
intros.
apply sum_comp.
simpl in |- *.
red in |- *.
intro.
simpl in |- *.
destruct x0.
simpl in |- *.
red in Ap2_comp_proof.
apply RING_comp; auto with algebra.
Defined.

Let mult_sgp_mod :
  forall n : nat, sgroup_hom (Mmn F n n) (Hom_module (Mmn F n n) (Mmn F n n)).
intros.
apply Build_sgroup_hom with (mult_map_mod n).
red in |- *.
intros; simpl in |- *.
red in |- *; intros.
simpl in |- *.
intros.
apply
 Trans
  with
    (sum
       (pointwise (uncurry (RING_comp (R:=F))) (row (x +' y) i') (col x0 j')));
 auto with algebra.
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
intro.
destruct x; destruct y; destruct x0; simpl in |- *.
red in Ap2_comp_proof, Ap2_comp_proof0, Ap2_comp_proof1.
apply RING_comp; auto with algebra.
apply
 Trans
  with
    (sum
       (pointwise (sgroup_law_map F)
          (pointwise (uncurry (RING_comp (R:=F))) (row x i') (col x0 j'))
          (pointwise (uncurry (RING_comp (R:=F))) (row y i') (col x0 j')))).
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
intro.
apply Trans with (x i' x1 rX x0 x1 j' +' y i' x1 rX x0 x1 j');
 auto with algebra.
generalize sum_of_sums.
intros.
apply
 (H1 n F (pointwise (uncurry (RING_comp (R:=F))) (row x i') (col x0 j'))
    (pointwise (uncurry (RING_comp (R:=F))) (row y i') (col x0 j'))).
Defined.

Let mult_mon_mod :
  forall n : nat, monoid_hom (Mmn F n n) (Hom_module (Mmn F n n) (Mmn F n n)).
intros.
apply Build_monoid_hom with (mult_sgp_mod n).
red in |- *.
simpl in |- *.
red in |- *.
intro.
simpl in |- *.
intros.
apply Trans with (sum (const_seq n (zero F))).
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
auto with algebra.
apply sum_of_zeros; auto with algebra.
Defined.

apply Build_module_hom with (mult_mon_mod n).
red in |- *.
intros; simpl in |- *.
red in |- *.
intro; simpl in |- *.
intros.
apply
 Trans
  with
    (sum
       (pointwise (uncurry (RING_comp (R:=F))) (const_seq n a)
          (pointwise (uncurry (RING_comp (R:=F))) (row x i') (col x0 j')))).
apply sum_comp.
simpl in |- *.
red in |- *.
simpl in |- *.
intro.
apply Trans with ((a rX x i' x1) rX x0 x1 j'); auto with algebra.
apply RING_comp; auto with algebra.
apply RING_comp; auto with algebra.
destruct x; red in Ap2_comp_proof; simpl in |- *; auto with algebra.
destruct x0; red in Ap2_comp_proof; simpl in |- *; auto with algebra.
apply Sym.
auto with algebra.
Defined.

