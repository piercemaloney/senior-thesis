
Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases.
(* bases:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
Require Export spans.
Require Export random_facts.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Section Defs.

Definition is_basis (X : part_set V) : Prop :=
  generates X (full V) /\ lin_indep X.

Lemma is_basis_comp :
 forall X Y : part_set V, X =' Y in _ -> is_basis X -> is_basis Y.

Record basis : Type := 
  {basis_carrier :> Predicate V; is_basis_prf : is_basis basis_carrier}.
End Defs.

Lemma basis_prop : forall (X : basis) (x : V), is_lin_comb x X.

Lemma basis_prop_strong :
 forall (n : Nat) (v : seq n V),
 is_basis (seq_set v) ->
 forall x : V, exists a : seq n F, sum (mult_by_scalars a v) =' x in _.

Section Nice_basis_properties.

Variable x : V.
Variable n : Nat.
Variable b : seq n V.
Variable Db : distinct b.
Variable Bb : is_basis (seq_set b).

Let difference_seq : forall (G : group) (a a' : seq n G), seq n G.

Lemma basis_expansion_uniqueness :
 forall a a' : seq n F,
 sum (mult_by_scalars a b) =' x in _ ->
 sum (mult_by_scalars a' b) =' x in _ -> a =' a' in _.

End Nice_basis_properties.

End MAIN. *)
Require Export subspace_dim.
(* subspace_dim:
Local Unset Standard Proposition Elimination Names.

Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases_finite_dim.

Fixpoint span_ind_uninject (F : field) (V : vectorspace F) 
 (W : subspace V) (X : part_set W) (x : span_ind_formal (inject_subsets X))
 {struct x} : span_ind_formal X :=
  match x with
  | Zerovector => Zerovector _
  | Immediately c => Immediately (S:=X) (uninject_subsetsify c)
  | Plusvector x1 x2 =>
      Plusvector (span_ind_uninject x1) (span_ind_uninject x2)
  | Multvector f x1 => Multvector f (span_ind_uninject x1)
  end.

Lemma span_ind_uninject_prop :
 forall (F : field) (V : vectorspace F) (W : subspace V) 
   (X : part_set W) (x : span_ind_formal (inject_subsets X)),
 span_ind_injection x ='
 subtype_elt (span_ind_injection (span_ind_uninject x)) in _.
Unset Virtual Machine.

Section prelim.
Variable F : field.
Variable V : vectorspace F.

Lemma not_generates_then_leaves_over :
 forall S : part_set V,
 ~ generates S (full V) -> exists v : V, ~ in_part v (span_set S).

Axiom
  AC' :
    forall S : part_set V,
    (exists v : V, in_part v S) -> sigT (fun v : V => in_part v S).

Lemma ACcomplement :
 forall S : part_set V,
 (exists v : V, ~ in_part v S) -> sigT (fun v : V => ~ in_part v S).

Axiom
  dec_gen :
    forall S : part_set V, {generates S (full V)} + {~ generates S (full V)}.

Definition try_extend :
  forall (k : Nat) (v : seq k V),
  lin_indep (seq_set v) /\ distinct v ->
  sigT
    (fun i : Nat =>
     sigT (fun w : seq i V => lin_indep (seq_set w) /\ distinct w)).

Lemma extend_prop :
 forall (k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 match try_extend H with
 | existT i _ =>
     (i =' k in _ <-> span (seq_set v) =' full V in part_set V) /\
     (i =' S k in _ <-> ~ span (seq_set v) =' full V in part_set V)
 end.

Lemma extend_prop2 :
 forall (k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 match try_extend H with
 | existT i (existT w H') =>
     (i =' k in _ <-> seq_equal v w) /\
     (i =' S k in _ -> seq_equal v (Seqtl w))
 end.

Fixpoint rep_ext (n : nat) (k : Nat) (v : seq k V)
 (H : lin_indep (seq_set v) /\ distinct v) {struct n} :
 sigT
   (fun i : Nat =>
    sigT (fun w : seq i V => lin_indep (seq_set w) /\ distinct w)) :=
  match n with
  | O => existT (fun i : Nat => _) k (existT (fun w : seq k V => _) v H)
  | S m =>
      match rep_ext m H with
      | existT i (existT w H') => try_extend H'
      end
  end.

Lemma preserve_lin_indep :
 forall (n k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 match rep_ext n H with
 | existT i (existT w H') => lin_indep (seq_set w) /\ distinct w
 end.

Lemma grow_nr_elts :
 forall (n k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 has_n_elements k (seq_set v) ->
 match rep_ext n H with
 | existT i (existT w H') => has_n_elements i (seq_set w)
 end.
End prelim.

Section MAIN.
Variable F : field.
Variable V : findimvecsp F.

Variable W : subspace V.

Let H : lin_indep (seq_set (empty_seq W)) /\ distinct (empty_seq W).

Lemma grow_bound :
 forall n : nat,
 match rep_ext n H with
 | existT i (existT w H') => i <= n
 end.

Let n := the_dim V.

Lemma subspace_preserves_findimvecsp : sigT (fun m => m <= n /\ has_dim m W).
End MAIN. *)

Lemma generates_inject_subsets :
 forall (F : field) (V : vectorspace F) (W : subspace V) (S X : part_set W),
 generates S X -> generates (inject_subsets S) (inject_subsets X).
intros.
red in |- *; red in H.
apply Trans with (span_ind (inject_subsets S):part_set V); auto with algebra.
assert (X =' span_ind S in part_set W).
apply Trans with (span S:part_set W); auto with algebra.
split; intros.
simpl in H1.
inversion_clear H1.
simpl in |- *.
clear H.
simpl in H0.
red in H0.
set (x0S := span_ind_uninject x0) in *.
set (xW := span_ind_injection x0S) in *.
elim (H0 xW).
intros.
cut (in_part xW (span_ind_set (V:=W) S)).
intro.
generalize dependent (H1 H3); intro p; red in p.
exists (Build_subtype p).
simpl in |- *.
unfold xW, x0S in |- *.
apply Trans with (span_ind_injection x0); auto with algebra.
apply span_ind_uninject_prop.
simpl in |- *.
exists x0S.
red in |- *.
unfold xW, x0S in |- *.
auto with algebra.

simpl in H1.
inversion_clear H1.
simpl in |- *.
clear H.
elim (H0 (subtype_elt x0)).
intros.
assert (in_part (subtype_elt x0) X); auto with algebra.
generalize dependent (H H3); intro.
simpl in H4.
inversion_clear H4.
clear H H1 H3.
red in H5.
generalize dependent x0.
generalize dependent x.
induction x1 as [| c| x0 IHx0 x2 IHx2| c x1 IHx1]; intros.

exists (Zerovector (inject_subsets S)).
apply Trans with (subtype_elt (subtype_elt x0)); auto with algebra.

exists (Immediately (inject_subsetsify c)).
apply Trans with (subtype_elt (subtype_elt x0)); auto with algebra.

set (x0V := subtype_elt (span_ind_injection x0)) in *.
elim (H0 (span_ind_injection x0)); intros.
assert (in_part (span_ind_injection x0) (span_ind (V:=W) S)).
simpl in |- *.
exists x0.
red in |- *; auto with algebra.
generalize dependent (H1 H3); intro p; red in p.
generalize dependent (IHx0 x0V (Build_subtype p)).
intro.
cut (x0V =' subtype_elt (subtype_elt (Build_subtype p)) in _).
intro q; generalize dependent (H4 q); clear H4 q; intro H4.
cut (subtype_elt (subtype_elt (Build_subtype p)) =' x0V in _).
intro q; generalize dependent (H4 q); clear H4 q; intro H4.
inversion_clear H4.
clear p H3 H1 H.

set (x2V := subtype_elt (span_ind_injection x2)) in *.
elim (H0 (span_ind_injection x2)); intros.
assert (in_part (span_ind_injection x2) (span_ind (V:=W) S)).
simpl in |- *.
exists x2.
red in |- *; auto with algebra.
generalize dependent (H1 H3); intro p; red in p.
generalize dependent (IHx2 x2V (Build_subtype p)).
intro.
cut (x2V =' subtype_elt (subtype_elt (Build_subtype p)) in _).
intro q; generalize dependent (H4 q); clear H4 q; intro H4.
cut (subtype_elt (subtype_elt (Build_subtype p)) =' x2V in _).
intro q; generalize dependent (H4 q); clear H4 q; intro H4.
inversion_clear H4.
clear p H3 H1 H.
exists (Plusvector x3 x4).
apply Trans with (subtype_elt (subtype_elt x1)); auto with algebra.
apply Trans with (subtype_elt (span_ind_injection (Plusvector x0 x2)));
 auto with algebra.

apply
 Trans with (subtype_elt (span_ind_injection x0 +' span_ind_injection x2));
 [ apply subtype_elt_comp; simpl in |- *; red in |- *; apply Refl | idtac ].
apply Trans with (span_ind_injection x3 +' span_ind_injection x4);
 [ idtac | simpl in |- *; red in |- *; apply Refl ].
apply
 Trans
  with
    (subtype_elt (span_ind_injection x0) +'
     subtype_elt (span_ind_injection x2)).
simpl in |- *.
apply Refl.
fold x0V in |- *.
fold x2V in |- *.
apply SGROUP_comp; auto with algebra.
simpl in |- *.
apply Refl.
simpl in |- *; apply Refl.
simpl in |- *; apply Refl.
simpl in |- *; apply Refl.

set (x1V := subtype_elt (span_ind_injection x1)) in *.
elim (H0 (span_ind_injection x1)); intros.
assert (in_part (span_ind_injection x1) (span_ind (V:=W) S)).
simpl in |- *.
exists x1.
red in |- *; auto with algebra.
generalize dependent (H1 H3); intro p; red in p.
generalize dependent (IHx1 x1V (Build_subtype p)).
intro.
cut (x1V =' subtype_elt (subtype_elt (Build_subtype p)) in _).
intro q; generalize dependent (H4 q); clear H4 q; intro H4.
cut (subtype_elt (subtype_elt (Build_subtype p)) =' x1V in _).
intro q; generalize dependent (H4 q); clear H4 q; intro H4.
inversion_clear H4.
clear p H3 H1 H.
exists (Multvector c x2).
apply Trans with (subtype_elt (subtype_elt x0)); auto with algebra.
apply Trans with (subtype_elt (span_ind_injection (Multvector c x1)));
 auto with algebra.
simpl in |- *.
apply MODULE_comp; auto with algebra.
simpl in |- *.
apply Refl.
simpl in |- *; apply Refl.
Set Virtual Machine.
Qed.
Unset Virtual Machine.

Lemma bases_equal_then_subspace_equal :
 forall (F : field) (V : vectorspace F) (W1 W2 : subspace V) 
   (b1 : basis W1) (b2 : basis W2),
 inject_subsets b1 =' inject_subsets b2 in _ -> W1 =' W2 in part_set V.
intros.
destruct b1; destruct b2.
rename basis_carrier into b1.
rename basis_carrier0 into b2.
simpl in H.
inversion_clear is_basis_prf; inversion_clear is_basis_prf0.

assert (generates (inject_subsets b1) W1).
apply generates_comp with (inject_subsets b1) (inject_subsets (full W1));
 auto with algebra.
apply (inject_subsets_full_inv W1).
apply generates_inject_subsets.
auto.

assert (generates (inject_subsets b2) W2).
apply generates_comp with (inject_subsets b2) (inject_subsets (full W2));
 auto with algebra.
apply (inject_subsets_full_inv W2).
apply generates_inject_subsets.
auto.

split; intro.
generalize dependent is_lin_comb_from_generates.
intro.

red in H5.
elim (H5 x); intros.
apply H8.
simpl in |- *.

apply H7 with (W1:part_set V); auto with algebra.
apply generates_comp with (inject_subsets b1) (W1:part_set V);
 auto with algebra.

generalize dependent is_lin_comb_from_generates.
intro.

red in H4.
elim (H4 x); intros.
apply H8.
simpl in |- *.

apply H7 with (W2:part_set V); auto with algebra.
apply generates_comp with (inject_subsets b2) (W2:part_set V);
 auto with algebra.
Qed.
