
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
(* finite:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Arith.
Require Export equal_syntax.

Definition Nat : Setoid.

Record finiteT (N : Nat) : Type :=  {index : nat; in_range_prf : index < N}.

Definition fin : Nat -> Setoid.

Lemma fin_equation :
 forall (n i j : nat) (Hi : i < n) (Hj : j < n),
 i = j -> Build_finiteT Hi =' Build_finiteT Hj in fin n.

Hint Resolve fin_equation: algebra.

Lemma fin_decidable :
 forall (n : Nat) (i i' : fin n), i =' i' in _ \/ ~ i =' i' in _.

Lemma fin_O_nonexistent : fin 0 -> False.

Hint Resolve fin_O_nonexistent: algebra.

Lemma fin_S_O_unique : forall i j : fin 1, i =' j in _.

Hint Resolve fin_S_O_unique: algebra.

Definition seq (n : Nat) (A : Setoid) := MAP (fin n) A.

Lemma toSeq :
 forall (A : Setoid) (n : Nat) (v v' : Map (fin n) A),
 v =' v' in seq _ _ -> v =' v' in MAP _ _.

Lemma toMap :
 forall (A : Setoid) (n : Nat) (v v' : Map (fin n) A),
 v =' v' in MAP _ _ -> v =' v' in seq _ _.

Hint Resolve toSeq toMap: algebra. *)

Section MAIN.
Lemma lt_comp : forall m n n' : Nat, m < n -> n =' n' in _ -> m < n'.
intros.
rewrite <- H0.
auto.
Qed.

Definition cast_fin : forall n n' : Nat, fin n -> n =' n' in _ -> fin n'.
intros.
destruct X.
exact (Build_finiteT (lt_comp in_range_prf H)).
Defined.

Lemma cast_fin_comp :
 forall (n n' : Nat) (i i' : fin n) (H H' : n =' n' in _),
 i =' i' in _ -> cast_fin i H =' cast_fin i' H' in _.
intros until H'.
unfold cast_fin in |- *.
case i; case i'.
simpl in |- *.
auto.
Qed.

Hint Resolve cast_fin_comp: algebra.

Variable A : Setoid.

Definition cast_seq : forall n n' : Nat, seq n A -> n =' n' in _ -> seq n' A.
intros.
destruct X.
set (Ap' := fun i : fin n' => Ap (cast_fin i (sym_eq H))) in *.
assert (Mcp' : fun_compatible Ap').
red in |- *; red in Map_compatible_prf.
unfold Ap' in |- *.
intros.
apply Map_compatible_prf; auto with algebra.
exact (Build_Map Mcp').
Defined.

Lemma cast_seq_comp :
 forall (n n' : Nat) (v v' : seq n A) (H H' : n =' n' in _),
 v =' v' in _ -> cast_seq v H =' cast_seq v' H' in _.
unfold cast_seq in |- *.
intros until H'.
case v; case v'.
simpl in |- *.
red in |- *.
simpl in |- *.
intros.
red in H0.
simpl in H0.
apply Trans with (Ap0 (cast_fin x (sym_eq H'))); auto with algebra.
Qed.

Hint Resolve cast_seq_comp: algebra.

Variable n n' : Nat.
Variable v : seq n A.

Lemma cast_seq_cast_fin :
 forall (i : fin n) (H H' : n =' n' in _),
 v i =' cast_seq v H (cast_fin i H') in _.
intros.
unfold cast_seq, cast_fin in |- *.
destruct v.
simpl in |- *.
destruct i.
apply Map_compatible_prf; auto with algebra.
Qed.

Lemma cast_seq_cast_fin' :
 forall (i : fin n') (H : n =' n' in _) (H' : n' =' n in _),
 cast_seq v H i =' v (cast_fin i H') in _.
intros.
unfold cast_seq, cast_fin in |- *.
destruct v.
simpl in |- *.
destruct i.
apply Map_compatible_prf; auto with algebra.
Qed.

Hint Resolve cast_seq_cast_fin cast_seq_cast_fin': algebra.
End MAIN.
Hint Resolve cast_fin_comp: algebra.
Hint Resolve cast_seq_comp: algebra.
Hint Resolve cast_seq_cast_fin cast_seq_cast_fin': algebra.