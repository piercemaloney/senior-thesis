
Section MAIN.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export vecspaces_verybasic.
(* vecspaces_verybasic:
Section MAIN.
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Field_facts.
Require Export equal_syntax.
Require Export more_syntax.
From Algebra Require Export Module_facts.

Section vecfielddef.

Definition vectorspace (F : field) : Type := MODULE F.
Definition VECSP (F : field) : category :=
  full_subcat (fun V : vectorspace F => V:MODULE F).

End vecfielddef.

Section jargon.
Variable F : field.
Variable V : vectorspace F.
Definition carrier := module_carrier.
Definition scalar_mult (a : F) (x : V) : V := a mX x.

Definition scalar_mult_comp :
  forall (x x' : F) (y y' : carrier V),
  x =' x' in _ -> y =' y' in _ -> x mX y =' x' mX y' in _ :=
  MODULE_comp (R:=F) (Mod:=V).
Definition one_acts_as_unit : forall x : carrier V, one mX x =' x in _ :=
  MODULE_unit_l (R:=F) (Mod:=V).
Definition quasi_associativity :
  forall (a b : F) (x : carrier V), (a rX b) mX x =' a mX b mX x in _ :=
  MODULE_assoc (R:=F) (Mod:=V).
Definition distributivity :
  forall (a : F) (x y : carrier V), a mX (x +' y) =' a mX x +' a mX y in _ :=
  MODULE_dist_l (R:=F) (Mod:=V).
Definition distributivity' :
  forall (a b : F) (x : carrier V), (a +' b) mX x =' a mX x +' b mX x in _ :=
  MODULE_dist_r (R:=F) (Mod:=V).
End jargon.

Variable F : field.
Variable V : vectorspace F.
Hint Unfold carrier module_carrier.
Hint Resolve scalar_mult_comp distributivity distributivity': algebra.

Section Lemmas1.

Lemma vector_cancellation :
 forall x y z : V, x +' z =' y +' z in _ -> x =' y in _.

Lemma Zero_times_a_vector_gives_zero :
 forall v : V, (zero F) mX v =' (zero V) in _.

Lemma a_scalar_times_zero_gives_zero :
 forall f : F, f mX (zero V) =' (zero V) in _.
 
Section Lemmas1_2.

Lemma Mince_minus1 :
 forall (f : F) (v : V), (min f) mX v =' (min f mX v) in _.
 
Lemma Mince_minus2 :
 forall (f : F) (v : V), (min f mX v) =' f mX (min v) in _.
 
Lemma Mince_minus3 :
 forall (f : F) (v : V), (min f) mX v =' f mX (min v) in _.

Lemma vecspace_op_reg_l :
 forall (f : F) (v : V),
 ~ f =' (zero F) in _ -> f mX v =' (zero V) in _ -> v =' (zero V) in _.

End Lemmas1_2.
End Lemmas1.

End MAIN.

Hint Resolve vector_cancellation Zero_times_a_vector_gives_zero
  a_scalar_times_zero_gives_zero Mince_minus1 Mince_minus2 Mince_minus3:
  algebra. *)
Require Export arb_intersections.
(* arb_intersections:
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Parts2.
Require Export Classical_Pred_Type.
Section MAIN.
Section indexed_int.

Variable A : Setoid.
Variable I : Setoid.
Variable f : MAP I (part_set A). 
 
Definition indexed_intersection : part_set A.

Lemma indexed_intersection_included_in_subsets :
 forall i : I, included indexed_intersection (f i).

Lemma in_indexed_intersection_then_in_subsets :
 forall a : A,
 in_part a indexed_intersection -> forall i : I, in_part a (f i).

Lemma in_subsets_then_in_indexed_intersection :
 forall a : A,
 (forall i : I, in_part a (f i)) -> in_part a indexed_intersection.

Lemma not_in_part_then_not_in_indexed_intersection :
 forall a : A,
 (exists i : I, ~ in_part a (f i)) -> ~ in_part a indexed_intersection.

Lemma not_in_indexed_intersection_then_not_in_part :
 forall a : A,
 ~ in_part a indexed_intersection -> exists i : I, ~ in_part a (f i).

Lemma subset_included_then_indexed_intersection_included :
 forall B : part_set A,
 (exists i : I, included (f i) B) -> included indexed_intersection B.

End indexed_int.

Let range (A B : Setoid) (f : MAP A B) := image f (full A).

Section Compatibility_of_indexed_intersections.
Variable A : Setoid.
Variable I : Setoid.

Lemma indexed_intersection_comp :
 forall f g : MAP I (part_set A),
 Equal f g -> Equal (indexed_intersection f) (indexed_intersection g).

Variable J : Setoid.
Lemma indexed_intersection_indep_of_indexing :
 forall (f : MAP I (part_set A)) (g : MAP J (part_set A)),
 Equal (range f) (range g) ->
 Equal (indexed_intersection f) (indexed_intersection g).
End Compatibility_of_indexed_intersections.

Lemma empty_indexed_intersection_gives_full_set :
 forall (A : Setoid) (f : MAP (empty A) (part_set A)),
 Equal (indexed_intersection f) (full A).

Definition intersection :
  forall A : Setoid, part_set (part_set A) -> part_set A.

Section intersection_v_indexed_intersection.

Lemma intersection_to_indexed_intersection :
 forall (A I : Setoid) (f : MAP I (part_set A)),
 Equal (intersection (range f)) (indexed_intersection f).

End intersection_v_indexed_intersection.
End MAIN. *)
From Algebra Require Export Sub_module.
From Algebra Require Export Singleton.
Require Export algebra_omissions.
(* algebra_omissions:
From Algebra Require Export Group_facts.
Set Implicit Arguments.
Unset Strict Implicit.

Lemma group_inverse_inj :
 forall (G : GROUP) (g g' : G),
 Equal (group_inverse _ g) (group_inverse _ g') -> Equal g g'.

Definition min_inj := group_inverse_inj.

Lemma subtype_elt_comp :
 forall (A : Setoid) (B : part_set A) (b b' : B),
 Equal b b' -> Equal (subtype_elt b) (subtype_elt b').

Lemma subtype_elt_inj :
 forall (A : Setoid) (B : part_set A) (b b' : B),
 Equal (subtype_elt b) (subtype_elt b') -> Equal b b'.

Hint Resolve subtype_elt_comp: algebra.

Lemma in_part_subtype_elt :
 forall (A : Setoid) (B : part_set A) (b : B), in_part (subtype_elt b) B.

Hint Resolve in_part_subtype_elt: algebra.

Definition inject_subsets :
  forall (A : Setoid) (B : part_set A), part_set B -> part_set A.

Lemma inject_subsets_comp :
 forall (A : Setoid) (B : part_set A) (C C' : part_set B),
 Equal C C' -> Equal (inject_subsets C) (inject_subsets C').

Hint Resolve inject_subsets_comp: algebra.

Lemma inject_subsets_of_part_set_included :
 forall (A : Setoid) (B : part_set A) (C : part_set B),
 included (inject_subsets C) B.

Hint Resolve inject_subsets_of_part_set_included: algebra.

Lemma inject_subsets_full_inv :
 forall (A : Setoid) (B : part_set A), Equal (inject_subsets (full B)) B.

Hint Resolve inject_subsets_full_inv: algebra.

Definition inject_subsetsify :
  forall (A : Setoid) (B : part_set A) (C : part_set B),
  C -> inject_subsets C.

Lemma inject_subsetsify_comp :
 forall (A : Setoid) (B : part_set A) (C : part_set B) (c c' : C),
 Equal c c' -> Equal (inject_subsetsify c) (inject_subsetsify c').

Definition uninject_subsetsify :
  forall (A : Setoid) (B : part_set A) (C : part_set B),
  inject_subsets C -> C.

Lemma uninject_subsetsify_comp :
 forall (A : Setoid) (B : part_set A) (C : part_set B),
 fun_compatible (uninject_subsetsify (A:=A) (B:=B) (C:=C)).

Lemma in_part_included :
 forall (A : Setoid) (B C : part_set A) (a : A),
 in_part a B -> included B C -> in_part a C.

Lemma exists_difference :
 forall n m : nat, n <= m -> exists q : nat, m = n + q. *)

Variable F : field.
Variable V : vectorspace F.
Section Subspace_def.

Definition subspace (F : field) (V : vectorspace F) := submodule V.

Variable W : subspace V.
Definition inj_subspace : Hom (W:VECSP F) V.
apply
 (BUILD_HOM_MODULE (R:=F) (Mod:=W:VECSP F) (Mod':=V)
    (ff:=fun x : W => subtype_elt x)); auto with algebra.
Defined.

Lemma inj_subspace_injective : injective inj_subspace.
red in |- *.
auto with algebra.
Qed.

Lemma mult_inherited :
 forall (c : F) (x : W), inj_subspace (c mX x) =' c mX inj_subspace x in _.
intros.
case inj_subspace.
intros.
simpl in |- *.
apply module_hom_prf.
Qed.
End Subspace_def.

Section subspace_awkward_utils.

Definition is_subspace (W : part_set V) : Prop :=
  in_part (zero V) W /\
  (forall x y : V, in_part x W -> in_part y W -> in_part (x +' y) W) /\
  (forall (c : F) (x : V), in_part x W -> in_part (c mX x) W).

Lemma is_subspace_comp :
 forall S S' : part_set V, S =' S' in _ -> is_subspace S -> is_subspace S'.
intros.
red in |- *.
red in H0.
inversion_clear H0.
inversion_clear H2.
split.
apply in_part_comp_r with S; auto with algebra.
split.
intros.
apply in_part_comp_r with S; auto with algebra.
apply H0; auto with algebra.
apply in_part_comp_r with S'; auto with algebra.
apply in_part_comp_r with S'; auto with algebra.
intros.
apply in_part_comp_r with S; auto with algebra.
apply H3; auto with algebra.
apply in_part_comp_r with S'; auto with algebra.
Qed.

Definition subspace_construction :
  forall Ws : part_set V,
  is_subspace Ws -> sigT (fun W : subspace V => W =' Ws in part_set V).
unfold is_subspace in |- *.
intros Ws (H1, (H2, H3)).
cut (sigT (fun Wmod : submodule V => Wmod =' Ws in part_set V)).
intro.
inversion_clear X.
exists x.
assumption.
cut (sigT (fun Wgp : subgroup V => Wgp =' Ws in part_set V)).
intro.
inversion_clear X.
exists
 (Build_submodule
    (fun (a : F) (v : V) (Hyp : in_part v (x:part_set V)) =>
     in_part_comp_r (H3 a v (in_part_comp_r Hyp H)) (Sym H))).
simpl in |- *.
assumption.
cut (sigT (fun Wmon : submonoid V => Wmon =' Ws in part_set V)).
intro.
inversion X.
cut (forall v : V, (min one) mX v =' (min v) in _).
intro.
exists
 (Build_subgroup
    (fun (v : V) (Hyp : in_part v (x:part_set V)) =>
     in_part_comp_r
       (in_part_comp_l (H3 (min one) v (in_part_comp_r Hyp H)) (Sym (H0 v)))
       (Sym H))).
simpl in |- *.
assumption.
intro.
apply Trans with (min one mX v); auto with algebra.
cut (sigT (fun Wsgp : subsgroup V => Wsgp =' Ws in part_set V)).
intro.
inversion_clear X.
exists (Build_submonoid (in_part_comp_r H1 (Sym H))).
simpl in |- *.
assumption.
exists
 (Build_subsgroup
    (fun (x y : V) (Hx : in_part x Ws) (Hy : in_part y Ws) => H2 x y Hx Hy)).
simpl in |- *.
exact
 (fun x : V =>
  conj (fun Hx : in_part x Ws => Hx) (fun Hx : in_part x Ws => Hx)).
Defined.

Definition alt_Build_subspace (W : part_set V) (H : is_subspace W) :
  subspace V := let (w, _) := subspace_construction H in w.

Lemma alt_Build_subspace_OK :
 forall (W : part_set V) (HW : is_subspace W),
 W =' alt_Build_subspace HW in _.
intros.
unfold alt_Build_subspace in |- *.
case (subspace_construction HW).
auto with algebra.
Qed.

Lemma is_subspace_OK : forall W : subspace V, is_subspace W.
intro.
split; try split; auto with algebra.
Qed.

Lemma subspace_alt_characterization :
 forall Ws : part_set V,
 in_part (zero V) Ws /\
 (forall x y : V, in_part x Ws -> in_part y Ws -> in_part (x +' y) Ws) /\
 (forall (c : F) (x : V), in_part x Ws -> in_part (c mX x) Ws) <->
 (exists W : subspace V, W =' Ws in part_set V).
split. 
intros.
elim (subspace_construction H).
intros.
exists x; auto.
intro; inversion_clear H.
generalize (is_subspace_OK x).
intro H; red in H; split; try split; intuition;
 (apply in_part_comp_r with (x:part_set V); auto with algebra).
apply H; auto with algebra; (apply in_part_comp_r with Ws; auto with algebra).
apply H3; auto with algebra;
 (apply in_part_comp_r with Ws; auto with algebra).
Qed.

Definition Set_of_subspaces : part_set (part_set V).
apply (Build_Predicate (Pred_fun:=fun W => is_subspace W)).
red in |- *.
intros.
red in |- *; red in H.
inversion_clear H.
inversion_clear H2.
split; try split.
apply in_part_comp_r with x; auto with algebra.
intros; (apply in_part_comp_r with x; auto with algebra).
apply H; auto with algebra.
apply in_part_comp_r with y; auto with algebra.
apply in_part_comp_r with y; auto with algebra.
intros.
apply in_part_comp_r with x; auto with algebra.
apply H3; auto with algebra; (apply in_part_comp_r with y; auto with algebra).
Defined.

Lemma Set_of_subspaces_closed_under_intersection :
 forall WS : part_set Set_of_subspaces,
 is_subspace (intersection (inject_subsets WS)).
red in |- *.
repeat split.
simpl in |- *.
intros; inversion_clear H.
destruct x.
rename subtype_elt into S.
simpl in H0.
destruct S.
simpl in H0, subtype_prf, subtype_prf0.
apply in_part_comp_r with subtype_elt.
red in subtype_prf0.
inversion_clear subtype_prf0.
auto.
auto with algebra.

simpl in |- *.
intros.
generalize dependent (H p H1); generalize dependent (H0 p H1).
inversion_clear H1.
destruct x0.
destruct subtype_elt.
simpl in H2.
intros; simpl in subtype_prf0.
red in subtype_prf0.
inversion_clear subtype_prf0.
inversion_clear H5.
apply in_part_comp_r with subtype_elt; auto with algebra.
apply H6; apply in_part_comp_r with p; auto with algebra.
intros.
simpl in |- *.
intros; simpl in H.
generalize dependent (H p H0).
inversion_clear H0.
destruct x0.
destruct subtype_elt.
simpl in H1, subtype_prf0.
red in subtype_prf0.
inversion_clear subtype_prf0.
inversion_clear H2.
intro; apply in_part_comp_r with subtype_elt; auto with algebra.
apply H4; apply in_part_comp_r with p; auto with algebra.
Qed.
End subspace_awkward_utils.

End MAIN.

Section Examples.
Variable F : field.
Variable V : vectorspace F.

Lemma singleton_zero_is_subspace : is_subspace (single (zero V)).
intros.
repeat split.
simpl in |- *.
apply Refl.
intros.
simpl in H, H0.
apply in_part_comp_l with ((zero V) +' (zero V)); simpl in |- *;
 auto with algebra.
intros.
simpl in H.
apply in_part_comp_l with (c mX (zero V)); simpl in |- *; auto with algebra.
Qed.

Definition triv_subspace : subspace V.
apply alt_Build_subspace with (single (zero V)).
apply singleton_zero_is_subspace.
Defined.

Definition full_subspace : subspace V.
apply alt_Build_subspace with (full V).
repeat split.
Defined.
End Examples.
