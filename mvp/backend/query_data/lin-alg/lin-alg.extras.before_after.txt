
Set Implicit Arguments.
Unset Strict Implicit.
Require Export omit_facts.
(* omit_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_equality_facts.
Require Export sums.
Require Export mult_by_scalars.

Lemma omit_head_is_seqtl :
 forall (n : Nat) (M : Setoid) (s : seq n M) (H0 : 0 < n),
 omit s (Build_finiteT H0) =' Seqtl s in _.

Hint Resolve omit_head_is_seqtl: algebra.

Lemma omit_tlelt :
 forall (n : Nat) (A : Setoid) (v : seq (S (S n)) A) 
   (m : Nat) (HS : S m < S (S n)) (H : m < S n),
 omit v (Build_finiteT HS) =' head v;; omit (Seqtl v) (Build_finiteT H) in _.

Hint Resolve omit_tlelt: algebra.

Lemma omit_tlelt' :
 forall (n : Nat) (A : Setoid) (v : seq (S n) A) (m : Nat) 
   (HS : S m < S n) (H : m < n) (Heq : S (pred n) = n),
 omit v (Build_finiteT HS) ='
 cast_seq (head v;; omit (Seqtl v) (Build_finiteT H)) Heq in _.

Hint Resolve omit_tlelt': algebra.

Lemma omit_tlelt'' :
 forall (n : Nat) (A : Setoid) (v : seq (S n) A) (m : Nat) 
   (HS : S m < S n) (H : m < n) (Heq : S (pred n) = n),
 seq_equal (omit v (Build_finiteT HS))
   (head v;; omit (Seqtl v) (Build_finiteT H)).

Hint Resolve omit_tlelt'': algebra.

Lemma omit_concat_first_part :
 forall (n m : Nat) (A : Setoid) (v : seq (S n) A) 
   (w : seq m A) (i : Nat) (Hi : i < S n) (Hi' : i < S n + m),
 omit (v ++ w) (Build_finiteT Hi') =' omit v (Build_finiteT Hi) ++ w in _.

Hint Resolve omit_concat_first_part: algebra.

Lemma omit_concat_second_part' :
 forall (n m : Nat) (A : Setoid) (v : seq n A) (w : seq m A) 
   (i : Nat) (Hi : i < m) (Hi' : n + i < n + m)
   (H : n + pred m = pred (n + m)),
 seq_equal (omit (v ++ w) (Build_finiteT Hi'))
   (v ++ omit w (Build_finiteT Hi)).

Lemma omit_concat_second_part :
 forall (n m : Nat) (A : Setoid) (v : seq n A) (w : seq m A) 
   (i : Nat) (Hi : i < m) (Hi' : n + i < n + m)
   (H : n + pred m = pred (n + m)),
 omit (v ++ w) (Build_finiteT Hi') ='
 cast_seq (v ++ omit w (Build_finiteT Hi)) H in _.

Lemma omit_seq_in_seq_set :
 forall (n : Nat) (A : Setoid) (v : seq n A) (i : fin n) (j : fin (pred n)),
 in_part (omit v i j) (seq_set v).

Lemma seqsum_is_elt_plus_omitseq :
 forall (n : Nat) (M : abelian_monoid) (s : seq n M) (i : fin n),
 sum s =' s i +' sum (omit s i) in _.

Lemma seqsum_min_elt_is_omitseq :
 forall (n : Nat) (AG : abelian_group) (s : seq n AG) (i : fin n),
 sum s +' (min s i) =' sum (omit s i) in _.

Hint Resolve omit_head_is_seqtl omit_tlelt seqsum_is_elt_plus_omitseq
  seqsum_min_elt_is_omitseq: algebra.

Lemma omit_mult_by_scalars :
 forall (n : Nat) (F : ring) (V : module F) (a : seq n F) 
   (v : seq n V) (i : fin n),
 omit (mult_by_scalars a v) i =' mult_by_scalars (omit a i) (omit v i) in _.

Hint Resolve omit_mult_by_scalars: algebra.

Lemma omit_Map_embed :
 forall (n : Nat) (F : ring) (V : module F) (s : part_set V) 
   (v : seq n s) (i : fin n),
 omit (Map_embed v) i =' Map_embed (omit v i) in _.
Hint Resolve omit_Map_embed: algebra. *)

Definition before (N N' : nat) (i : fin N) (j : fin N') := index i < index j.
Definition after (N N' : nat) (i : fin N) (j : fin N') := index i > index j.

Definition notbefore (N N' : nat) (i : fin N) (j : fin N') :=
  index i = index j \/ after i j.
Definition notafter (N N' : nat) (i : fin N) (j : fin N') :=
  before i j \/ index i = index j.

Lemma decide_fin :
 forall (N N' : nat) (i : fin N) (i' : fin N'),
 before i i' \/ index i = index i' \/ after i i'.
simpl in |- *.
unfold before, after in |- *.
intros.
case i; case i'.
simpl in |- *.
intros x l x0 l0.
clear l0 l i' i N N'.
induction  x as [| x Hrecx]; induction  x0 as [| x0 Hrecx0];
 unfold gt in |- *; auto with arith.
case Hrecx.
auto with arith.
intro.
unfold gt in |- *; case H.
intro; left.
rewrite H0.
auto.
unfold gt in |- *.
intro.
right.
case H0.
auto.
intros.
cut (S x < S m \/ S x = S m).
intro.
case H2.
auto.
auto.
left.
auto with arith.
Qed.

Lemma decide_before :
 forall (N N' : nat) (i : fin N) (j : fin N'), before i j \/ notbefore i j. 
unfold notbefore in |- *.
apply decide_fin.
Qed.

Lemma decide_after :
 forall (N N' : nat) (i : fin N) (j : fin N'), after i j \/ notafter i j.  
unfold notafter in |- *.
intros.
case (decide_before i j).
auto.
unfold notbefore in |- *.
tauto.
Qed.

Lemma seq_properties_split_before_eq_after :
 forall (A : Setoid) (n : nat) (v : seq n A) (i : fin n) (P : Predicate A),
 (forall j : fin n, before j i -> Pred_fun P (v j)) ->
 Pred_fun P (v i) ->
 (forall j : fin n, after j i -> Pred_fun P (v j)) ->
 forall j : fin n, Pred_fun P (v j).
intros.
case (decide_fin j i); auto.
intro.
case H2; auto.
generalize H0.
elim P.
simpl in |- *.
unfold pred_compatible in |- *.
intros.
apply Pred_compatible_prf with (v i); auto with algebra.
Qed.

Lemma predicate_split_seq_before_notbefore :
 forall (A : Setoid) (n : nat) (v : seq n A) (i : fin n) (P : Predicate A),
 (forall j : fin n, before j i -> Pred_fun P (v j)) ->
 (forall j : fin n, notbefore j i -> Pred_fun P (v j)) ->
 forall j : fin n, Pred_fun P (v j).
intros.
case (decide_before j i); auto.
Qed.

Lemma predicate_split_seq_after_notafter :
 forall (A : Setoid) (n : nat) (v : seq n A) (i : fin n) (P : Predicate A),
 (forall j : fin n, after j i -> Pred_fun P (v j)) ->
 (forall j : fin n, notafter j i -> Pred_fun P (v j)) ->
 forall j : fin n, Pred_fun P (v j).
intros.
case (decide_after j i); auto.
Qed.

Lemma seq_properties_split_before_notbefore :
 forall (A : Setoid) (n : nat) (v : seq n A) (i : fin n) (P : A -> Prop),
 (forall j : fin n, before j i -> P (v j)) ->
 (forall j : fin n, notbefore j i -> P (v j)) -> forall j : fin n, P (v j).
intros.
case (decide_before j i); auto.
Qed.

Lemma seq_properties_split_after_notafter :
 forall (A : Setoid) (n : nat) (v : seq n A) (i : fin n) (P : A -> Prop),
 (forall j : fin n, after j i -> P (v j)) ->
 (forall j : fin n, notafter j i -> P (v j)) -> forall j : fin n, P (v j).
intros.
case (decide_after j i); auto.
Qed.

Definition next (n : nat) (i : fin n) : fin (S n) :=
  match i with
  | Build_finiteT ni Hi => Build_finiteT (lt_n_S _ _ Hi)
  end.
Definition prev :
  forall (n : nat) (i : fin (S n)),
  ~ i =' Build_finiteT (lt_O_Sn n) in _ -> fin n.
intros n i; case i.
intro x; case x.
simpl in |- *.
intros.
absurd (0 = 0); auto.
intros.
exact (Build_finiteT (lt_S_n _ _ in_range_prf)).
Defined.