
Set Implicit Arguments.
Unset Strict Implicit.
Require Export algebraic_span_facts.
(* algebraic_span_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export spans.
From Algebra Require Export Inter.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Lemma span_idempotent :
 forall S : part_set V, span S =' span (span S) in part_set V.

Lemma span_preserves_inclusion :
 forall S S' : part_set V, included S S' -> included (span S) (span S').

Hint Resolve span_preserves_inclusion: algebra.

Lemma span_of_union :
 forall S S' : part_set V,
 span (union S S') =' span (union (span S) (span S')) in part_set V.

Lemma inclusion_generates :
 forall S S' : part_set V,
 included S S' -> generates S (full V) -> generates S' (full V).

Lemma subspace_span_characterisation :
 forall W : part_set V, is_subspace W <-> span W =' W in part_set V.

Lemma subspace_contains_all_lin_combs :
 forall (W : subspace V) (x : V), is_lin_comb x W -> in_part x W.

Lemma span_intersect :
 forall S S' : part_set V,
 included (span (inter S S')) (inter (span S) (span S')).

End MAIN. *)
Require Export seq_set_seq.
(* seq_set_seq:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_set.

Let seq_set_fun :
  forall (A : Setoid) (n : Nat) (v : seq n A), fin n -> (seq_set v:Type).

Definition seq_set_seq :
  forall (A : Setoid) (n : Nat) (v : seq n A), seq n (seq_set v). *)

Lemma lin_comb_casting :
 forall (F : field) (V : vectorspace F) (W W' : part_set V) (x : V),
 is_lin_comb x W ->
 (forall w : W, is_lin_comb (subtype_elt w) W') -> is_lin_comb x W'.
intros.
change (in_part x (span W')) in |- *.
elim (span_idempotent W' x).
intros.
apply H2; auto with algebra; clear H1 H2.
simpl in |- *.
assert (forall w : W, in_part (subtype_elt w) (span_set W')).
auto.
clear H0.
inversion_clear H.
inversion_clear H0.
inversion_clear H.
red in |- *.
exists x0.
exists x1.
assert (forall i : fin x0, in_part (Map_embed x2 i) (span_set W')).
intro i.
change (in_part (subtype_elt (x2 i)) (span_set W')) in |- *.
auto.
exists (cast_map_to_subset H).
apply Trans with (sum (mult_by_scalars x1 (Map_embed x2))); auto with algebra.
Qed.

Lemma span_casting :
 forall (F : field) (V : vectorspace F) (W W' : part_set V),
 (forall w : W, is_lin_comb (subtype_elt w) W') ->
 included (span W) (span W').
intros; simpl in |- *.
red in |- *; simpl in |- *.
intros.
apply lin_comb_casting with W; auto with algebra.
Qed.

Lemma lin_comb_scalar_multiplied :
 forall (F : field) (V : vectorspace F) (x : V) (n : Nat) 
   (a : seq n F) (v : seq n V) (c : F),
 x =' c mX sum (mult_by_scalars a v) in _ -> is_lin_comb x (seq_set v).
intros.
red in |- *.
exists n.
set (axc_fun := fun i : fin n => c rX a i) in *.
assert (axc_comp : fun_compatible axc_fun).
red in |- *.
intros.
unfold axc_fun in |- *.
apply RING_comp; auto with algebra.
set (axc := Build_Map axc_comp:seq _ _) in *.
exists axc.
exists (seq_set_seq v).
apply Trans with (sum (mult_by_scalars axc v)).
apply Trans with (c mX sum (mult_by_scalars a v)); auto with algebra.
apply
 Trans with (sum (mult_by_scalars (const_seq n c) (mult_by_scalars a v)));
 auto with algebra.
apply sum_comp; auto with algebra.
simpl in |- *.
red in |- *; intros.
unfold mult_by_scalars, axc in |- *.
simpl in |- *.
unfold axc_fun in |- *.
auto with algebra.
apply sum_comp; auto with algebra.
Qed.

Lemma lin_comb_omit :
 forall (F : field) (V : vectorspace F) (x : V) (n : Nat) 
   (a : seq n F) (v : seq n V) (i : fin n),
 x =' sum (omit (mult_by_scalars a v) i) in _ -> is_lin_comb x (seq_set v).
intros.
red in |- *.
exists n.
exists (modify_seq a i (zero F)).
exists (seq_set_seq v).
apply Trans with (sum (mult_by_scalars (modify_seq a i (zero F)) v)).
2: apply sum_comp; auto with algebra.
apply Trans with (sum (modify_seq (mult_by_scalars a v) i ((zero F) mX v i))).
2: apply sum_comp; auto with algebra.

apply
 Trans
  with
    (sum (mult_by_scalars a v) +' (min mult_by_scalars a v i) +'
     (zero F) mX v i); auto with algebra.

apply
 Trans
  with (sum (mult_by_scalars a v) +' (min mult_by_scalars a v i) +' (zero V));
 auto with algebra.
apply Trans with (sum (mult_by_scalars a v) +' (min mult_by_scalars a v i));
 auto with algebra.
apply Trans with (sum (omit (mult_by_scalars a v) i)); auto with algebra.
Qed.