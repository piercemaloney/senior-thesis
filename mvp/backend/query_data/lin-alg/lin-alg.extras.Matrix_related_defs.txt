
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Matrices.
(* Matrices:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map2.
Require Export vecspace_Fn.

Definition Matrix_general_type (A : Setoid) (n m : Nat) :=
  MAP2 (fin n) (fin m) A.

Definition matrix (F : field) := Matrix_general_type F.

Section add.
Let matrix_addition_fun (F : field) (m n : Nat) (M N : matrix F m n) :
  matrix F m n.

Definition matrix_addition (F : field) (m n : Nat) :
  MAP2 (matrix F m n) (matrix F m n) (matrix F m n).
End add.

Section mult.
Definition matrix_scmult_fun (F : field) (m n : Nat) 
  (c : F) (M : matrix F m n) : matrix F m n.

Definition matrix_scmult (F : field) (m n : Nat) :
  MAP2 F (matrix F m n) (matrix F m n).
End mult.

Section transpose.
Definition transpose :
  forall (F : field) (m n : Nat), matrix F m n -> matrix F n m.

Definition transpose_map :
  forall (F : field) (m n : Nat), MAP (matrix F m n) (matrix F n m).

Lemma transpose_defprop :
 forall (F : field) (m n : Nat) (M : matrix F m n) (i : fin n) (j : fin m),
 transpose M i j =' M j i in _.
End transpose.
Hint Resolve transpose_defprop: algebra.

Definition zero_matrix : forall (F : field) (n m : Nat), matrix F n m.

Definition is_square (F : field) (n m : Nat) (M : matrix F n m) :=
  n =' m in _.

Definition is_diagonal (F : field) (n : Nat) (M : matrix F n n) :=
  forall i j : fin n, index i <> index j -> M i j =' (zero F) in _.

Definition identity_matrix : forall (F : field) (n : Nat), matrix F n n.

Lemma id_is_square :
 forall (F : field) (n : Nat), is_square (identity_matrix F n).

Definition row (F : field) :
  forall m n : Nat, matrix F m n -> fin m -> Fn F n :=
  fun n m M i => Ap2_Map M i.

Definition col (F : field) :
  forall m n : Nat, matrix F m n -> fin n -> Fn F m :=
  fun n m M j => Ap2_Map' M j.

Lemma row_transpose_col :
 forall (F : field) (m n : Nat) (M : matrix F m n) (i : fin m),
 row M i =' col (transpose M) i in _.

Lemma row_comp :
 forall (F : field) (m n : Nat) (M M' : matrix F m n) (i i' : fin m),
 M =' M' in _ -> i =' i' in _ -> row M i =' row M' i' in _.

Lemma col_comp :
 forall (F : field) (m n : Nat) (M M' : matrix F m n) (i i' : fin n),
 M =' M' in _ -> i =' i' in _ -> col M i =' col M' i' in _.

Hint Resolve row_comp col_comp: algebra. *)
Require Export sums.
(* sums:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.
From Algebra Require Export Sub_monoid.
Require Export more_syntax.

Fixpoint sum (V : monoid) (n : Nat) {struct n} : seq n V -> V :=
  match n return (seq n V -> V) with
  | O => fun x : seq 0 V => zero V
  | S m => fun x : seq (S m) V => head x +' sum (Seqtl x)
  end.

Lemma sum_comp :
 forall (M : monoid) (n : Nat) (f f' : seq n M),
 f =' f' in _ -> sum f =' sum f' in _.

Hint Resolve sum_comp: algebra.

Lemma sum_cons :
 forall (M : monoid) (m : M) (n : Nat) (f : seq n M),
 sum (m;; f) =' m +' sum f in _.

Hint Resolve sum_cons: algebra.

Lemma sum_concat :
 forall (n m : Nat) (G : monoid) (a : seq n G) (b : seq m G),
 sum (a ++ b) =' sum a +' sum b in _.

Hint Resolve sum_concat: algebra.

Lemma subtype_sum :
 forall (n : nat) (A : monoid) (B : submonoid A) (c : seq n B),
 subtype_elt (sum c) =' sum (Map_embed c) in _. *)

Section defs.
Variable F : field.
Variable n : Nat.
Variable M : matrix F n n.

Definition the_diagonal : seq n F.
apply (Build_Map (Ap:=fun i : fin n => M i i)).
red in |- *.
intros.
destruct M.
simpl in |- *.
apply Ap2_comp_proof; auto with algebra.
Defined.

Definition trace := sum the_diagonal.
End defs.