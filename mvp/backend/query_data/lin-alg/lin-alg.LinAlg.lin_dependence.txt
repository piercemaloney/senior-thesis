
Set Implicit Arguments.
Unset Strict Implicit.
Section MAIN.
From Algebra Require Export Union.
Require Export subspaces.
(* subspaces:
Section MAIN.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export vecspaces_verybasic.
Require Export arb_intersections.
From Algebra Require Export Sub_module.
From Algebra Require Export Singleton.
Require Export algebra_omissions.

Variable F : field.
Variable V : vectorspace F.
Section Subspace_def.

Definition subspace (F : field) (V : vectorspace F) := submodule V.

Variable W : subspace V.
Definition inj_subspace : Hom (W:VECSP F) V.

Lemma inj_subspace_injective : injective inj_subspace.

Lemma mult_inherited :
 forall (c : F) (x : W), inj_subspace (c mX x) =' c mX inj_subspace x in _.
End Subspace_def.

Section subspace_awkward_utils.

Definition is_subspace (W : part_set V) : Prop :=
  in_part (zero V) W /\
  (forall x y : V, in_part x W -> in_part y W -> in_part (x +' y) W) /\
  (forall (c : F) (x : V), in_part x W -> in_part (c mX x) W).

Lemma is_subspace_comp :
 forall S S' : part_set V, S =' S' in _ -> is_subspace S -> is_subspace S'.

Definition subspace_construction :
  forall Ws : part_set V,
  is_subspace Ws -> sigT (fun W : subspace V => W =' Ws in part_set V).

Definition alt_Build_subspace (W : part_set V) (H : is_subspace W) :
  subspace V := let (w, _) := subspace_construction H in w.

Lemma alt_Build_subspace_OK :
 forall (W : part_set V) (HW : is_subspace W),
 W =' alt_Build_subspace HW in _.

Lemma is_subspace_OK : forall W : subspace V, is_subspace W.

Lemma subspace_alt_characterization :
 forall Ws : part_set V,
 in_part (zero V) Ws /\
 (forall x y : V, in_part x Ws -> in_part y Ws -> in_part (x +' y) Ws) /\
 (forall (c : F) (x : V), in_part x Ws -> in_part (c mX x) Ws) <->
 (exists W : subspace V, W =' Ws in part_set V).

Definition Set_of_subspaces : part_set (part_set V).

Lemma Set_of_subspaces_closed_under_intersection :
 forall WS : part_set Set_of_subspaces,
 is_subspace (intersection (inject_subsets WS)).
End subspace_awkward_utils.

End MAIN.

Section Examples.
Variable F : field.
Variable V : vectorspace F.

Lemma singleton_zero_is_subspace : is_subspace (single (zero V)).

Definition triv_subspace : subspace V.

Definition full_subspace : subspace V.
End Examples. *)
Require Export cast_between_subsets.
(* cast_between_subsets:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.

Definition map_between_equal_subsets :
  forall (A : Setoid) (X Y : part_set A), X =' Y in _ -> X -> Y.

Lemma subtype_elt_eats_map_between_equal_subsets :
 forall (A : Setoid) (X Y : part_set A) (H : X =' Y in _) (x : X),
 subtype_elt (map_between_equal_subsets H x) =' subtype_elt x in _.

Hint Resolve subtype_elt_eats_map_between_equal_subsets: algebra.

Lemma map_between_equal_subsets_inj :
 forall (A : Setoid) (X Y : part_set A) (H H' : X =' Y in _) (x x' : X),
 map_between_equal_subsets H x =' map_between_equal_subsets H' x' in _ ->
 x =' x' in _.

Definition Map_to_equal_subsets :
  forall (A B : Setoid) (X Y : part_set A), X =' Y in _ -> MAP B X -> MAP B Y.

Lemma subtype_elt_eats_Map_to_equal_subsets :
 forall (A B : Setoid) (X Y : part_set A) (H : X =' Y in _) 
   (b : B) (M : Map B X),
 subtype_elt (Map_to_equal_subsets H M b) =' subtype_elt (M b) in _.

Hint Resolve subtype_elt_eats_Map_to_equal_subsets: algebra.

Lemma Map_embed_eats_Map_to_equal_subsets :
 forall (A B : Setoid) (X Y : part_set A) (H : X =' Y in _) (M : Map B X),
 Map_embed (Map_to_equal_subsets H M) =' Map_embed M in _.

Hint Resolve Map_embed_eats_Map_to_equal_subsets: algebra.

Lemma Map_to_equal_subsets_inj :
 forall (A B : Setoid) (X Y : part_set A) (H H' : X =' Y in _)
   (f g : Map B X),
 Map_to_equal_subsets H f =' Map_to_equal_subsets H' g in _ ->
 f =' g in MAP _ _.

Definition cast_to_subset_fun :
  forall (A B : Setoid) (v : MAP B A) (W : part_set A),
  (forall i : B, in_part (v i) W) -> (B -> W:Type).

Lemma cast_doesn't_change :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W) (i : B),
 subtype_elt (cast_to_subset_fun H i) =' v i in _.

Hint Resolve cast_doesn't_change: algebra.

Definition cast_map_to_subset :
  forall (A B : Setoid) (v : MAP B A) (W : part_set A),
  (forall i : B, in_part (v i) W) -> MAP B W.

Lemma cast_map_to_subset_doesn't_change :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W) (i : B),
 subtype_elt (cast_map_to_subset H i) =' v i in _.

Hint Resolve cast_map_to_subset_doesn't_change: algebra.

Lemma Map_embed_cast_map_to_subset_inv :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W),
 Map_embed (cast_map_to_subset H) =' v in _.

Hint Resolve Map_embed_cast_map_to_subset_inv: algebra.

Lemma Map_embed_eats_cast_map_to_subset :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B)
   (H : forall i : D, in_part (Map_embed v i) C),
 Map_embed (cast_map_to_subset H) =' Map_embed v in _.

Hint Resolve Map_embed_eats_cast_map_to_subset: algebra.

Lemma seq_castable :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A),
 (forall i : B, in_part (v i) W) -> exists w : MAP B W, Map_embed w =' v in _.

Hint Resolve seq_castable: algebra.

Lemma subset_seq_castable :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B)
   (H : forall i : D, in_part (Map_embed v i) C),
 exists w : MAP D C, Map_embed w =' Map_embed v in _.

Hint Resolve subset_seq_castable: algebra.

Lemma cast_seq_nice :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W) (P : Predicate (MAP B A)),
 Pred_fun P v -> Pred_fun P (Map_embed (cast_map_to_subset H)).

Hint Resolve cast_seq_nice: algebra.

Lemma cast_subset_seq_nice :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B)
   (H : forall i : D, in_part (Map_embed v i) C) (P : Predicate (MAP D A)),
 Pred_fun P (Map_embed v) -> Pred_fun P (Map_embed (cast_map_to_subset H)).

Hint Resolve cast_subset_seq_nice: algebra.

Lemma cast_respects_predicates_per_elt :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B) 
   (P : Predicate A) (H : forall i : D, in_part (Map_embed v i) C) 
   (i : D),
 Pred_fun P (Map_embed v i) ->
 Pred_fun P (Map_embed (cast_map_to_subset H) i).

Lemma cast_respects_all_elt_predicates :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B) 
   (P : Predicate A) (H : forall i : D, in_part (Map_embed v i) C),
 (forall i : D, Pred_fun P (Map_embed v i)) ->
 forall j : D, Pred_fun P (Map_embed (cast_map_to_subset H) j).

Hint Resolve cast_respects_predicates_per_elt
  cast_respects_all_elt_predicates: algebra.

Definition Map_include :
  forall (A D : Setoid) (B C : part_set A),
  included B C -> MAP D B -> MAP D C.

Definition Map_include_map :
  forall (A D : Setoid) (B C : part_set A),
  included B C -> MAP (MAP D B) (MAP D C). *)
Require Export mult_by_scalars.
(* mult_by_scalars:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export pointwise.
Require Export modify_seq.
Require Export vecspaces_verybasic.

Definition mult_by_scalars (R : ring) (V : module R) 
  (N : Nat) (a : Map (fin N) R) (v : Map (fin N) V) : 
  MAP (fin N) V := pointwise (uncurry (MODULE_comp (Mod:=V))) a v.

Lemma mult_by_scalars_comp :
 forall (R : ring) (V : module R) (N : Nat) (a b : MAP (fin N) R)
   (v w : MAP (fin N) V),
 a =' b in _ ->
 v =' w in _ -> mult_by_scalars a v =' mult_by_scalars b w in _.

Lemma mult_by_scalars_fun2_compatible :
 forall (R : ring) (V : module R) (N : Nat),
 fun2_compatible
   (mult_by_scalars (V:=V) (N:=N):MAP _ _ -> MAP _ _ -> MAP _ _).

Hint Resolve mult_by_scalars_fun2_compatible mult_by_scalars_comp: algebra.

Lemma mult_by_scalars_Seqtl :
 forall (R : ring) (V : module R) (N : Nat) (a : Map (fin N) R)
   (v : Map (fin N) V),
 mult_by_scalars (Seqtl a) (Seqtl v) =' Seqtl (mult_by_scalars a v) in _.

Hint Resolve mult_by_scalars_Seqtl: algebra.

Lemma mult_by_scalars_concat :
 forall (R : ring) (V : module R) (N M : Nat) (a : Map (fin N) R)
   (b : Map (fin M) R) (v : Map (fin N) V) (w : Map (fin M) V),
 mult_by_scalars (a ++ b) (v ++ w) ='
 mult_by_scalars a v ++ mult_by_scalars b w in _.

Hint Resolve mult_by_scalars_concat: algebra.

Lemma mult_by_scalars_modify_seq :
 forall (F : field) (V : vectorspace F) (n : Nat) (p : seq n F) 
   (k : seq n V) (i : fin n) (q : F),
 mult_by_scalars (modify_seq p i q) k ='
 modify_seq (mult_by_scalars p k) i (q mX k i) in seq _ _.

Hint Resolve mult_by_scalars_modify_seq: algebra. *)
Require Export sums.
(* sums:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.
From Algebra Require Export Sub_monoid.
Require Export more_syntax.

Fixpoint sum (V : monoid) (n : Nat) {struct n} : seq n V -> V :=
  match n return (seq n V -> V) with
  | O => fun x : seq 0 V => zero V
  | S m => fun x : seq (S m) V => head x +' sum (Seqtl x)
  end.

Lemma sum_comp :
 forall (M : monoid) (n : Nat) (f f' : seq n M),
 f =' f' in _ -> sum f =' sum f' in _.

Hint Resolve sum_comp: algebra.

Lemma sum_cons :
 forall (M : monoid) (m : M) (n : Nat) (f : seq n M),
 sum (m;; f) =' m +' sum f in _.

Hint Resolve sum_cons: algebra.

Lemma sum_concat :
 forall (n m : Nat) (G : monoid) (a : seq n G) (b : seq m G),
 sum (a ++ b) =' sum a +' sum b in _.

Hint Resolve sum_concat: algebra.

Lemma subtype_sum :
 forall (n : nat) (A : monoid) (B : submonoid A) (c : seq n B),
 subtype_elt (sum c) =' sum (Map_embed c) in _. *)
Require Export seq_set_seq.
(* seq_set_seq:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_set.

Let seq_set_fun :
  forall (A : Setoid) (n : Nat) (v : seq n A), fin n -> (seq_set v:Type).

Definition seq_set_seq :
  forall (A : Setoid) (n : Nat) (v : seq n A), seq n (seq_set v). *)
Require Export distinct.
(* distinct:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
From Algebra Require Export Parts.

Definition distinct (A : Setoid) (n : Nat) (v : seq n A) :=
  forall i j : fin n, ~ i =' j in _ -> ~ v i =' v j in _.

Lemma distinct_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq n A),
 distinct v -> v =' v' in _ -> distinct v'.

Hint Resolve distinct_comp: algebra.

Definition distinct_pred (A : Setoid) (n : Nat) : Predicate (seq n A). *)
Require Export const.
(* const:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Section MAIN.
Variable A : Setoid.

Definition const_map : forall (X Y : Setoid) (y : Y), MAP X Y.

Definition const_seq : forall (n : Nat) (a : A), seq n A.

Lemma seq_S_O_constseq : forall v : seq 1 A, v =' const_seq 1 (head v) in _.

Lemma Seqtl_const_seq :
 forall (n : Nat) (a : A), Seqtl (const_seq n a) =' const_seq (pred n) a in _.

Lemma cons_const_seq :
 forall (n : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ -> a;; const_seq n a' =' const_seq (S n) a'' in _.

End MAIN. *)

Section defs.
Variable F : field.
Variable V : vectorspace F.

Definition lin_dep (X : part_set V) :=
  exists n : Nat,
    (exists a : seq (S n) F,
       (exists v : seq (S n) X,
          distinct v /\
          ~ a =' const_seq (S n) (zero F) in _ /\
          sum (mult_by_scalars a (Map_embed v)) =' (zero V) in _)).

Definition lin_indep (X : part_set V) := ~ lin_dep X.

Definition lin_indep' (X : part_set V) :=
  forall (n : Nat) (a : seq (S n) F) (v : seq (S n) X),
  distinct v ->
  ~ a =' const_seq (S n) (zero F) in _ ->
  ~ sum (mult_by_scalars a (Map_embed v)) =' (zero V) in _.

Lemma lin_dep_comp :
 forall X Y : part_set V, X =' Y in _ -> lin_dep X -> lin_dep Y.
intros.
red in |- *.
red in H0.
inversion_clear H0.
exists x.
inversion_clear H1.
exists x0.
inversion_clear H0.
exists (Map_to_equal_subsets H x1).
split.
inversion_clear H1.
repeat red in H0.
repeat red in |- *.
intros.
apply (H0 i j); auto with algebra.
simpl in |- *.
red in |- *.
simpl in H3.
red in H3.
apply Trans with (subtype_elt (x1 i)); auto with algebra.
apply Trans with (subtype_elt (Map_to_equal_subsets H x1 i));
 auto with algebra. 
apply Trans with (subtype_elt (x1 j)); auto with algebra.
apply Trans with (subtype_elt (Map_to_equal_subsets H x1 j));
 auto with algebra. 
split.
inversion_clear H1.
inversion_clear H2.
auto.
inversion_clear H1.
inversion_clear H2.
apply Trans with (sum (mult_by_scalars x0 (Map_embed x1))); auto with algebra. 
Qed.

Lemma lin_indep_comp :
 forall X Y : part_set V, X =' Y in _ -> lin_indep X -> lin_indep Y.
intros.
red in |- *.
red in |- *.
red in H0.
red in H0.
intro.
apply H0.
apply lin_dep_comp with Y; auto with algebra.
Qed.

Lemma lin_dep_defs_eqv : forall X : part_set V, lin_indep X <-> lin_indep' X.
unfold lin_indep in |- *.
unfold lin_indep' in |- *.
unfold lin_dep in |- *.
split.
unfold not in |- *.
intros.
apply H.
exists n.
exists a.
exists v.
split.
assumption.
split.
assumption.
assumption.
unfold not in |- *.
intros.
inversion_clear H0.
inversion_clear H1.
inversion_clear H0.
apply (H x x0 x1).
inversion_clear H1.
assumption.
inversion_clear H1.
inversion_clear H2.
assumption.
inversion_clear H1.
inversion_clear H2.
assumption.
Qed.
End defs.

Section unexpected_true_results.

Lemma zero_imp_lin_dep :
 forall (F : field) (V : vectorspace F) (X : part_set V),
 in_part (zero V) X -> lin_dep X.
intros.
unfold lin_dep in |- *.
exists 0.
exists (const_seq 1 (ring_unit F)).
red in H.
exists (const_seq 1 (Build_subtype H:X)).
split.
red in |- *.
intros i j.
generalize fin_S_O_unique.
intros.
absurd (i =' j in _); auto.
split.
cut (~ one =' (zero F) in _).
unfold not in |- *.
intros.
apply H0.
simpl in H1.
red in H1.
simpl in H1.
apply H1.
exact (Build_finiteT (lt_O_Sn 0)).
exact (field_unit_non_zero F).
simpl in |- *.
apply Trans with ((zero V) +' (zero V)); auto with algebra.
Qed.

Lemma empty_lin_indep :
 forall (F : field) (V : vectorspace F), lin_indep (empty V).
intros.
unfold empty in |- *.
red in |- *.
red in |- *.
unfold lin_dep in |- *.
intro.
inversion_clear H.
inversion_clear H0.
inversion_clear H.
set (h := head x1) in *.
case h.
simpl in |- *.
auto.
Qed.
End unexpected_true_results.

Section more.
Variable F : field.
Variable V : vectorspace F.

Lemma lin_dep_include :
 forall S1 S2 : part_set V, included S1 S2 -> lin_dep S1 -> lin_dep S2.
unfold lin_dep in |- *.
intros.
inversion_clear H0.
exists x.
inversion_clear H1.
exists x0.
inversion_clear H0.
exists (Map_include_map _ H x1).
split.
red in |- *.
inversion_clear H1.
inversion_clear H2.
red in H0.
unfold not in |- *.
intros.
unfold not in H0.
apply (H0 i j); auto with algebra.
split.
inversion_clear H1.
inversion_clear H2.
assumption.
inversion_clear H1.
inversion_clear H2.
apply Trans with (sum (mult_by_scalars x0 (Map_embed x1))); auto with algebra.
Qed.

Lemma lin_indep_include :
 forall S1 S2 : part_set V, included S1 S2 -> lin_indep S2 -> lin_indep S1.
intros S1 S2 H.
unfold lin_indep in |- *.
unfold not in |- *.
intros.
apply H0.
apply (lin_dep_include H).
assumption.
Qed.

Lemma lin_indep_prop :
 forall (n : Nat) (a : seq n F) (v : seq n V),
 distinct v ->
 lin_indep (seq_set v) ->
 sum (mult_by_scalars a v) =' (zero V) in _ -> a =' const_seq n (zero F) in _.
intro n; case n.
intros.
simpl in |- *.
red in |- *.
intro.
inversion x.
inversion in_range_prf.
intros.
elim (lin_dep_defs_eqv (seq_set v)).
intros.
generalize (H2 H0); clear H3 H2 H0.
intro.
unfold lin_indep' in H0.
generalize (H0 _ a (seq_set_seq v)).
intro; clear H0.
cut (distinct (seq_set_seq v)); auto.
intro.
generalize (H2 H0).
clear H2 H0.
intro.
apply NNPP.
unfold not in |- *; intros.
unfold not in H0.
apply H0.
auto.
apply Trans with (sum (mult_by_scalars a v)); auto with algebra.
Qed.

Lemma lin_indep_doesn't_contain_zero :
 forall X : part_set V, lin_indep X -> ~ in_part (zero V) X.
intros; red in |- *; red in H; intro.
red in H; (apply H; auto with algebra).
apply zero_imp_lin_dep; auto with algebra.
Qed.

Lemma inject_subsets_lin_dep :
 forall (W : subspace V) (X : part_set W),
 lin_dep X <-> lin_dep (inject_subsets X).
split; intros.
red in |- *; red in H.
inversion_clear H; inversion_clear H0; inversion_clear H; inversion_clear H0;
 inversion_clear H1.
exists x; exists x0.
exists (comp_map_map (Build_Map (inject_subsetsify_comp (C:=X)):MAP _ _) x1).
split; try split.
2: auto.
red in |- *; red in H.
intros.
simpl in |- *.
intro; red in H3.
red in H; (apply (H _ _ H1); auto with algebra).
clear H0 H.
apply Trans with (subtype_elt (zero W)); auto with algebra.
apply Trans with (subtype_elt (sum (mult_by_scalars x0 (Map_embed x1))));
 auto with algebra.
apply Trans with (sum (Map_embed (mult_by_scalars x0 (Map_embed x1))));
 auto with algebra.
generalize (mult_by_scalars x0 (Map_embed x1)).
generalize (S x).
intros.
induction n.
simpl in |- *.
auto with algebra.
apply Trans with (head (Map_embed c) +' sum (Seqtl (Map_embed c)));
 auto with algebra.
apply Trans with (subtype_elt (head c +' sum (Seqtl c))).
apply Trans with (subtype_elt (head c) +' subtype_elt (sum (Seqtl c)));
 auto with algebra.
apply Trans with (head (Map_embed c) +' sum (Map_embed (Seqtl c)));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply sum_comp; auto with algebra.
apply Sym; auto with algebra.
generalize Map_embed_Seqtl.
intro p.
apply (p _ _ _ (c:seq _ _)).
apply subtype_elt_comp.
apply Sym; auto with algebra.

red in |- *; red in H.
inversion_clear H; inversion_clear H0; inversion_clear H; inversion_clear H0;
 inversion_clear H1.
exists x; exists x0.
exists
 (comp_map_map (Build_Map (uninject_subsetsify_comp (C:=X)):MAP _ _) x1).
split; try split.
2: auto.
red in |- *; red in H.
intros.
simpl in |- *.
generalize (H _ _ H1).
case (x1 i); case (x1 j).
simpl in |- *.
unfold subtype_image_equal in |- *.
simpl in |- *.
auto with algebra.
clear H0 H.
simpl in |- *.
red in |- *.
apply Trans with (zero V); auto with algebra.
apply
 Trans
  with
    (subtype_elt
       (sum
          (mult_by_scalars x0
             (Map_embed
                (comp_map_map
                   (Build_Map (uninject_subsetsify_comp (A:=V) (B:=W) (C:=X))
                    :Map _ _) x1)
              :Map _ W)))).

simpl in |- *.
apply SGROUP_comp; auto with algebra.
apply Trans with (sum (mult_by_scalars x0 (Map_embed x1))); auto with algebra. 
apply
 Trans
  with
    (sum
       (Map_embed
          (mult_by_scalars x0
             (Map_embed
                (comp_map_map
                   (Build_Map (uninject_subsetsify_comp (A:=V) (B:=W) (C:=X))
                    :Map _ _) x1)
              :Map _ W)))).
generalize
 (mult_by_scalars x0
    (Map_embed
       (comp_map_map
          (Build_Map (uninject_subsetsify_comp (A:=V) (B:=W) (C:=X))) x1)
     :Map _ W)).
generalize (S x).
intros.
apply Sym; auto with algebra.
induction n.
simpl in |- *.
auto with algebra.
apply Trans with (head (Map_embed c) +' sum (Seqtl (Map_embed c)));
 auto with algebra.
apply Trans with (subtype_elt (head c +' sum (Seqtl c))).
apply Trans with (subtype_elt (head c) +' subtype_elt (sum (Seqtl c)));
 auto with algebra.
apply Trans with (head (Map_embed c) +' sum (Map_embed (Seqtl c)));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply sum_comp; auto with algebra.
apply Sym; auto with algebra.
generalize Map_embed_Seqtl.
intro p.
apply (p _ _ _ (c:seq _ _)).
apply subtype_elt_comp.
apply Sym; auto with algebra.
apply sum_comp.
simpl in |- *; red in |- *; simpl in |- *.
intro.
apply MODULE_comp; auto with algebra.
unfold uninject_subsetsify in |- *.
case (x1 x2).
simpl in |- *.
auto with algebra.
Qed.
End more.

Definition max_lin_indep (F : field) (V : vectorspace F)
  (X Y : part_set V) :=
  included X Y /\
  lin_indep X /\
  (forall y : V, in_part y Y -> ~ in_part y X -> lin_dep (union X (single y))).

End MAIN.
