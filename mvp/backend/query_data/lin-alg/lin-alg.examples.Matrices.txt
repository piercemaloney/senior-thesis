
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map2.
(* Map2:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export equal_syntax.
From Algebra Require Export Cartesian.

Record Map2 (A B C : Setoid) : Type := 
  {Ap2 :> A -> B -> C; Ap2_comp_proof : fun2_compatible Ap2}.

Definition Map2_Mapcart :
  forall A B C : Setoid, Map2 A B C -> Map (cart A B) C.

Definition Mapcart_Map2 :
  forall A B C : Setoid, Map (cart A B) C -> Map2 A B C.

Definition MAP2 (A B C : Setoid) : Setoid.

Definition Map2_ap_Map : forall A B C : Setoid, Map2 A B C -> A -> MAP B C.

Definition Ap2_Map : forall A B C : Setoid, Map2 A B C -> Map A (MAP B C).

Definition Map2_ap'_Map : forall A B C : Setoid, Map2 A B C -> B -> MAP A C.

Definition Ap2_Map' : forall A B C : Setoid, Map2 A B C -> Map B (MAP A C). *)
Require Export vecspace_Fn.
(* vecspace_Fn:
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.

Section Fn_vectors.

Require Export vecspaces_verybasic.
Require Export finite.

Definition Fn_set (F : Setoid) (n : Nat) : SET := seq n F.

Let Fn_plus_fun :
  forall (F : sgroup) (n : Nat), Fn_set F n -> Fn_set F n -> Fn_set F n.

Definition Fn_plus :
  forall (F : sgroup) (n : Nat), law_of_composition (Fn_set F n).

Lemma Fn_plus_associative :
 forall (F : sgroup) (n : Nat), associative (Fn_plus F n).

Definition Fn_sgroup (F : sgroup) (n : Nat) : SGROUP :=
  Build_sgroup (Build_sgroup_on (Fn_plus_associative (F:=F) (n:=n))).

Lemma Fn_plus_commutative :
 forall (F : abelian_sgroup) (n : Nat), commutative (Fn_plus F n).

Definition Fn_absgp (F : abelian_sgroup) (n : Nat) : ABELIAN_SGROUP :=
  Build_abelian_sgroup
    (Build_abelian_sgroup_on (A:=Fn_sgroup F n)
       (Fn_plus_commutative (F:=F) (n:=n))).

Definition Fn_zero : forall (F : monoid) (n : Nat), Fn_sgroup F n.

Lemma Fn_zero_is_r_unit :
 forall (F : monoid) (n : Nat),
 unit_r (sgroup_law_map (Fn_sgroup F n)) (Fn_zero F n).

Lemma Fn_zero_is_l_unit :
 forall (F : monoid) (n : Nat),
 unit_l (sgroup_law_map (Fn_sgroup F n)) (Fn_zero F n).

Definition Fn_monoid (F : monoid) (n : Nat) : MONOID :=
  Build_monoid
    (Build_monoid_on (A:=Fn_sgroup F n) (monoid_unit:=
       Fn_zero F n) (Fn_zero_is_r_unit (F:=F) (n:=n))
       (Fn_zero_is_l_unit (F:=F) (n:=n))).

Lemma Fn_monoid_is_abelian :
 forall (F : abelian_monoid) (n : Nat), abelian_monoid_on (Fn_monoid F n).

Definition Fn_abmon (F : abelian_monoid) (n : Nat) : ABELIAN_MONOID :=
  Build_abelian_monoid (Fn_monoid_is_abelian F n).

Let Fn_inv_fun : forall (F : group) (n : Nat), Fn_monoid F n -> Fn_monoid F n.

Definition Fn_inv :
  forall (F : group) (n : Nat), Map (Fn_monoid F n) (Fn_monoid F n).

Lemma Fn_inv_is_r_inverse :
 forall (F : group) (n : Nat),
 inverse_r (Fn_plus F n) (Fn_zero F n) (Fn_inv F n).

Lemma Fn_inv_is_l_inverse :
 forall (F : group) (n : Nat),
 inverse_l (Fn_plus F n) (Fn_zero F n) (Fn_inv F n).

Definition Fn_group (F : group) (n : Nat) : GROUP :=
  Build_group
    (Build_group_on (group_inverse_map:=Fn_inv F n)
       (Fn_inv_is_r_inverse (F:=F) (n:=n))
       (Fn_inv_is_l_inverse (F:=F) (n:=n))).

Lemma Fn_group_is_abelian :
 forall (F : abelian_group) (n : Nat), abelian_group_on (Fn_group F n).

Definition Fn_abgp (F : abelian_group) (n : Nat) : ABELIAN_GROUP :=
  Build_abelian_group (Fn_group_is_abelian F n).

Definition Fn_scmult_fun :
  forall (F : ring) (n : Nat), F -> Fn_set F n -> Fn_set F n.

Lemma Fn_scmult_fun_comp :
 forall (F : ring) (n : Nat) (c c' : F) (v v' : Fn_set F n),
 c =' c' in _ ->
 v =' v' in _ -> Fn_scmult_fun c v =' Fn_scmult_fun c' v' in _.

Section necessary_module_stuff.

Let Fn_scmult_fun_map :
  forall (F : ring) (n : Nat), F -> MAP (Fn_set F n) (Fn_set F n).

Let Fn_scmult_F_to_EndoSet :
  forall (F : ring) (n : Nat),
  Map (Build_monoid (ring_monoid F)) (Endo_SET (Fn_set F n)).

Let Fn_scmult_sgroup_hom :
  forall (F : ring) (n : Nat),
  sgroup_hom (Build_monoid (ring_monoid F)) (Endo_SET (Fn_set F n)).

Let Fn_scmult_monoid_hom :
  forall (F : ring) (n : Nat),
  monoid_hom (Build_monoid (ring_monoid F)) (Endo_SET (Fn_set F n)).

Definition Fn_scmult :
  forall (F : ring) (n : Nat),
  operation (Build_monoid (ring_monoid F)) (Fn_abgp F n).

End necessary_module_stuff.

Lemma Fn_scmult_l_lin :
 forall (F : ring) (n : Nat), op_lin_left (Fn_scmult F n).

Lemma Fn_scmult_r_lin :
 forall (F : ring) (n : Nat), op_lin_right (Fn_scmult F n).

Definition Fn_mod (F : ring) (n : Nat) : MODULE F :=
  Build_module
    (Build_module_on (Fn_scmult_l_lin (F:=F) (n:=n))
       (Fn_scmult_r_lin (F:=F) (n:=n))).

Definition Fn (F : field) (n : Nat) : VECSP F := Fn_mod F n:vectorspace F.

End Fn_vectors.

Section Basis_vectors.

Fixpoint Kronecker (A : Setoid) (t f : A) (n m : Nat) {struct m} : A :=
  match n, m with
  | O, O => t
  | S n', O => f
  | O, S m' => f
  | S n', S m' => Kronecker t f n' m'
  end.

Lemma Kronecker_case_equal :
 forall (A : Setoid) (t f : A) (n m : Nat),
 n =' m in _ -> Kronecker t f n m =' t in _.

Lemma Kronecker_case_unequal :
 forall (A : Setoid) (t f : A) (n m : Nat),
 ~ n =' m in _ -> Kronecker t f n m =' f in _.

Definition Basisvec_Fn :
  forall (F : field) (n i : Nat) (H : i < n), Fn F n:Type.
End Basis_vectors. *)

Definition Matrix_general_type (A : Setoid) (n m : Nat) :=
  MAP2 (fin n) (fin m) A.

Definition matrix (F : field) := Matrix_general_type F.

Section add.
Let matrix_addition_fun (F : field) (m n : Nat) (M N : matrix F m n) :
  matrix F m n.
intros.
apply (Build_Map2 (Ap2:=fun i j => M i j +' N i j)).
red in |- *.
intros.
apply SGROUP_comp; auto with algebra.
apply (Ap2_comp_proof M); auto with algebra.
apply (Ap2_comp_proof N); auto with algebra.
Defined.

Definition matrix_addition (F : field) (m n : Nat) :
  MAP2 (matrix F m n) (matrix F m n) (matrix F m n).
intros.
apply (Build_Map2 (Ap2:=matrix_addition_fun (F:=F) (m:=m) (n:=n))).
red in |- *.
simpl in |- *; intros.
apply SGROUP_comp; auto with algebra.
Defined.
End add.

Section mult.
Definition matrix_scmult_fun (F : field) (m n : Nat) 
  (c : F) (M : matrix F m n) : matrix F m n.
intros.
apply (Build_Map2 (Ap2:=fun i j => c rX M i j)).
red in |- *.
intros.
apply RING_comp; auto with algebra.
apply (Ap2_comp_proof M); auto with algebra.
Defined.

Definition matrix_scmult (F : field) (m n : Nat) :
  MAP2 F (matrix F m n) (matrix F m n).
intros.
apply (Build_Map2 (Ap2:=matrix_scmult_fun (F:=F) (m:=m) (n:=n))).
red in |- *.
simpl in |- *; intros.
apply RING_comp; auto with algebra.
Defined.
End mult.

Section transpose.
Definition transpose :
  forall (F : field) (m n : Nat), matrix F m n -> matrix F n m.
intros.
red in |- *.
red in |- *.
red in X; red in X.
destruct X.
apply (Build_Map2 (Ap2:=fun i j => Ap2 j i)); auto with algebra.
red in Ap2_comp_proof; red in |- *.
intros.
auto with algebra.
Defined.

Definition transpose_map :
  forall (F : field) (m n : Nat), MAP (matrix F m n) (matrix F n m).
intros.
apply (Build_Map (Ap:=transpose (F:=F) (m:=m) (n:=n))).
red in |- *.
unfold transpose in |- *.
intros; destruct x; destruct y.
simpl in |- *.
auto with algebra.
Defined.

Lemma transpose_defprop :
 forall (F : field) (m n : Nat) (M : matrix F m n) (i : fin n) (j : fin m),
 transpose M i j =' M j i in _.
intros.
unfold transpose in |- *; destruct M; simpl in |- *.
apply Refl.
Qed.
End transpose.
Hint Resolve transpose_defprop: algebra.

Definition zero_matrix : forall (F : field) (n m : Nat), matrix F n m.
intros.
apply (Build_Map2 (Ap2:=fun (i : fin n) (j : fin m) => zero F)).
red in |- *.
auto with algebra.
Defined.

Definition is_square (F : field) (n m : Nat) (M : matrix F n m) :=
  n =' m in _.

Definition is_diagonal (F : field) (n : Nat) (M : matrix F n n) :=
  forall i j : fin n, index i <> index j -> M i j =' (zero F) in _.

Definition identity_matrix : forall (F : field) (n : Nat), matrix F n n.
intros.
apply
 (Build_Map2
    (Ap2:=fun i j : fin n => Kronecker one (zero F) (index i) (index j))).
red in |- *.
unfold Kronecker in |- *.
intros; destruct x; destruct x'; destruct y; destruct y'.
simpl in |- *.
simpl in H, H0.
rewrite H.
rewrite H0.
auto with algebra.
Defined.

Lemma id_is_square :
 forall (F : field) (n : Nat), is_square (identity_matrix F n).
red in |- *.
simpl in |- *.
auto.
Qed.

Definition row (F : field) :
  forall m n : Nat, matrix F m n -> fin m -> Fn F n :=
  fun n m M i => Ap2_Map M i.

Definition col (F : field) :
  forall m n : Nat, matrix F m n -> fin n -> Fn F m :=
  fun n m M j => Ap2_Map' M j.

Lemma row_transpose_col :
 forall (F : field) (m n : Nat) (M : matrix F m n) (i : fin m),
 row M i =' col (transpose M) i in _.
intros; simpl in |- *.
red in |- *; simpl in |- *.
intros; (apply Sym; auto with algebra).
Qed.

Lemma row_comp :
 forall (F : field) (m n : Nat) (M M' : matrix F m n) (i i' : fin m),
 M =' M' in _ -> i =' i' in _ -> row M i =' row M' i' in _.
intros.
simpl in |- *.
red in |- *; simpl in |- *.
intros.
destruct M; destruct M'; simpl in |- *.
simpl in H.
apply Trans with (Ap2 i' x); auto with algebra.
Qed.

Lemma col_comp :
 forall (F : field) (m n : Nat) (M M' : matrix F m n) (i i' : fin n),
 M =' M' in _ -> i =' i' in _ -> col M i =' col M' i' in _.
intros.
simpl in |- *.
red in |- *; simpl in |- *.
intros.
destruct M; destruct M'; simpl in |- *.
simpl in H.
apply Trans with (Ap2 x i'); auto with algebra.
Qed.

Hint Resolve row_comp col_comp: algebra.