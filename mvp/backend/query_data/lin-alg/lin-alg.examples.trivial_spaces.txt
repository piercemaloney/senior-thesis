
Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases_finite_dim.
(* bases_finite_dim:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases_from_generating_sets.
Require Export replacement_corollaries.

Definition is_finite_dimensional (F : field) (V : vectorspace F) :=
  exists beta : basis V, (exists n : Nat, has_n_elements n beta).

Definition is_infinite_dimensional (F : field) (V : vectorspace F) :=
  forall (beta : basis V) (n : Nat), ~ has_n_elements n beta.

Definition has_dim (F : field) (n : Nat) (V : vectorspace F) :=
  exists beta : basis V, has_n_elements n beta.

Lemma finite_dim_vecsp_has_dim :
 forall (F : field) (V : vectorspace F),
 is_finite_dimensional V -> exists n : Nat, has_dim n V.

Lemma has_dim_inj :
 forall (F : field) (V : vectorspace F) (n m : Nat),
 has_dim n V -> has_dim m V -> n =' m in _.

Lemma has_dim_easy :
 forall (F : field) (V : vectorspace F) (b : part_set V),
 is_basis b -> forall n : nat, has_n_elements n b -> has_dim n V.

Section Part_3.

Lemma dimension_bounds_generating_set_size :
 forall (F : field) (V : vectorspace F) (n : Nat),
 has_dim n V ->
 forall S : part_set V,
 generates S (full V) ->
 has_at_most_n_elements n S -> is_basis S /\ has_n_elements n S.

Lemma every_lin_indep_set_can_be_extended_to_a_basis :
 forall (F : field) (V : vectorspace F),
 is_finite_dimensional V ->
 forall (beta : basis V) (Sset : part_set V),
 lin_indep Sset ->
 exists S1 : part_set V, included S1 beta /\ is_basis (union Sset S1).

Lemma has_dim_zero_then_trivial :
 forall (F : field) (V : vectorspace F),
 has_dim 0 V -> full V =' single (zero V) in _.

End Part_3.

Record findimvecsp (F : field) : Type := 
  {the_dim : nat;
   the_vectorspace :>
    module F
    
   ;
   dim_prf : has_dim the_dim the_vectorspace}. *)
From Algebra Require Export Singleton.
Require Export alt_build_vecsp.
(* alt_build_vecsp:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export vecspaces_verybasic.
Require Export Map2.

Section MAIN.
Variable V : Setoid.
Variable F : field.
Variable add : Map2 V V V.
Variable mlt : Map2 F V V.
Variable zer : V.
Variable mns : Map V V.
Definition VS1 := forall x y : V, add x y =' add y x in _.
Definition VS2 := forall x y z : V, add (add x y) z =' add x (add y z) in _.
Definition VS3 := forall x : V, add x zer =' x in _.
Definition VS4 := forall x : V, add x (mns x) =' zer in _.
Definition VS5 := forall x : V, mlt one x =' x in _.
Definition VS6 :=
  forall (a b : F) (x : V), mlt (a rX b) x =' mlt a (mlt b x) in _.
Definition VS7 :=
  forall (a : F) (x y : V), mlt a (add x y) =' add (mlt a x) (mlt a y) in _.
Definition VS8 :=
  forall (a b : F) (x : V), mlt (a +' b) x =' add (mlt a x) (mlt b x) in _.

Let Vsg_on : VS2 -> sgroup_on V.

Let Vsg : VS2 -> sgroup.

Let Vmon_on : VS1 -> forall VS2p : VS2, VS3 -> monoid_on (Vsg VS2p).

Let Vmon : VS1 -> VS2 -> VS3 -> monoid.

Let Vgp_on :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3),
  VS4 -> group_on (Vmon VS1p VS2p VS3p).

Let Vgp : VS1 -> VS2 -> VS3 -> VS4 -> group.

Let Vabgp_on :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  abelian_group_on (Vgp VS1p VS2p VS3p VS4p).

Let Vabgp : VS1 -> VS2 -> VS3 -> VS4 -> abelian_group.

Let F_act_map :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  Map (Build_monoid (ring_monoid F)) (Endo_SET (Vabgp VS1p VS2p VS3p VS4p)).

Let F_sgp_hom :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  VS6 ->
  sgroup_hom (Build_monoid (ring_monoid F))
    (Endo_SET (Vabgp VS1p VS2p VS3p VS4p)).

Let F_op :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  VS5 ->
  VS6 -> operation (Build_monoid (ring_monoid F)) (Vabgp VS1p VS2p VS3p VS4p).

Let Vmod_on :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  VS5 -> VS6 -> VS7 -> VS8 -> module_on F (Vabgp VS1p VS2p VS3p VS4p).

Definition alt_Build_vectorspace :
  VS1 -> VS2 -> VS3 -> VS4 -> VS5 -> VS6 -> VS7 -> VS8 -> vectorspace F.

Definition vectorspace_construction :
  VS1 ->
  VS2 ->
  VS3 ->
  VS4 ->
  VS5 -> VS6 -> VS7 -> VS8 -> sigT (fun VV : vectorspace F => Carrier VV = V).
End MAIN. *)

Section MAIN.
Variable A : Setoid.
Variable a : A.

Let T := single a.

Definition Tplus : Map2 T T T.
apply
 Build_Map2
  with (fun t t' : single a => Build_subtype (Refl a:Pred_fun (single a) a)).
red in |- *.
intros.
auto with algebra.
Defined.

Definition Tzero : T := Build_subtype (Refl a:Pred_fun (single a) a).

Definition Tminus : Map T T.
apply Build_Map with (fun t : T => t).
red in |- *.
auto.
Defined.

Variable F : field.

Definition Tmult : Map2 F T T.
apply Build_Map2 with (fun (f : F) (t : T) => t).
red in |- *.
auto.
Defined.

Definition trivvecsp : vectorspace F.
apply alt_Build_vectorspace with T Tplus Tmult Tzero Tminus; red in |- *;
 auto with algebra.
simpl in |- *.
red in |- *.
intro; destruct x.
simpl in subtype_prf.
simpl in |- *.
auto with algebra.
simpl in |- *.
red in |- *.
simpl in |- *.
intros; destruct x; simpl in subtype_prf; simpl in |- *; auto with algebra.
Defined.
End MAIN.

Section basis.
Variable F : field.
Require Export bases.
(* bases:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
Require Export spans.
Require Export random_facts.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Section Defs.

Definition is_basis (X : part_set V) : Prop :=
  generates X (full V) /\ lin_indep X.

Lemma is_basis_comp :
 forall X Y : part_set V, X =' Y in _ -> is_basis X -> is_basis Y.

Record basis : Type := 
  {basis_carrier :> Predicate V; is_basis_prf : is_basis basis_carrier}.
End Defs.

Lemma basis_prop : forall (X : basis) (x : V), is_lin_comb x X.

Lemma basis_prop_strong :
 forall (n : Nat) (v : seq n V),
 is_basis (seq_set v) ->
 forall x : V, exists a : seq n F, sum (mult_by_scalars a v) =' x in _.

Section Nice_basis_properties.

Variable x : V.
Variable n : Nat.
Variable b : seq n V.
Variable Db : distinct b.
Variable Bb : is_basis (seq_set b).

Let difference_seq : forall (G : group) (a a' : seq n G), seq n G.

Lemma basis_expansion_uniqueness :
 forall a a' : seq n F,
 sum (mult_by_scalars a b) =' x in _ ->
 sum (mult_by_scalars a' b) =' x in _ -> a =' a' in _.

End Nice_basis_properties.

End MAIN. *)
Variable A : Setoid.
Variable a : A.
Definition triv_basis : basis (trivvecsp a F).
apply Build_basis with (empty (trivvecsp a F)).
red in |- *.
split.
red in |- *.
cbn - [trivvecsp].
red in |- *.
cbn - [trivvecsp].
Opaque trivvecsp.
split; auto; intros _.
Transparent trivvecsp.
red in |- *.
exists 0.
exists (empty_seq F).
Transparent trivvecsp.
exists (empty_seq (empty (single a))).
cbn - [trivvecsp].
unfold trivvecsp in x.
repeat red in x.
destruct x.
red in |- *.
simpl in subtype_prf.
auto.
apply empty_lin_indep.
Defined.

Definition trivial_basis :
  forall V : vectorspace F, full V =' single (zero V) in _ -> basis V.
intros.
apply Build_basis with (empty V).
red in |- *.
split.
2: apply empty_lin_indep.
red in |- *.
apply Trans with (single (zero V)); auto with algebra.
simpl in |- *.
red in |- *.
simpl in |- *.
split; intros.
red in H0.
inversion_clear H0.
inversion_clear H1.
inversion_clear H0.
assert (x0 =' 0 in _).
generalize no_seq_n_empty; intro p.
apply (p _ V (empty V) (Refl (empty V)) x2).
simpl in H0.
move H0 after x1.
generalize dependent x0.
intros x0 H0.
rewrite H0.
clear H0 x0.
simpl in |- *.
auto.

apply is_lin_comb_comp with (zero V) (empty V); auto with algebra.
red in |- *.
exists 0.
simpl in |- *.
exists (empty_seq F).
exists (empty_seq (empty V)).
auto with algebra.
Defined.

Lemma trivial_then_has_dim_zero :
 forall V : vectorspace F, full V =' single (zero V) in _ -> has_dim 0 V.
intros.
red in |- *.
exists (trivial_basis H).
simpl in |- *.
apply empty_then_has_zero_elements; auto with algebra.
Qed.

Lemma trivvecsp_has_dim_zero : has_dim 0 (trivvecsp a F).
red in |- *.
exists triv_basis.
apply has_n_elements_comp with 0 (empty (trivvecsp a F)); auto with algebra.
Qed.
End basis.
