
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Abelian_group_facts.
Require Export sums.
(* sums:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.
From Algebra Require Export Sub_monoid.
Require Export more_syntax.

Fixpoint sum (V : monoid) (n : Nat) {struct n} : seq n V -> V :=
  match n return (seq n V -> V) with
  | O => fun x : seq 0 V => zero V
  | S m => fun x : seq (S m) V => head x +' sum (Seqtl x)
  end.

Lemma sum_comp :
 forall (M : monoid) (n : Nat) (f f' : seq n M),
 f =' f' in _ -> sum f =' sum f' in _.

Hint Resolve sum_comp: algebra.

Lemma sum_cons :
 forall (M : monoid) (m : M) (n : Nat) (f : seq n M),
 sum (m;; f) =' m +' sum f in _.

Hint Resolve sum_cons: algebra.

Lemma sum_concat :
 forall (n m : Nat) (G : monoid) (a : seq n G) (b : seq m G),
 sum (a ++ b) =' sum a +' sum b in _.

Hint Resolve sum_concat: algebra.

Lemma subtype_sum :
 forall (n : nat) (A : monoid) (B : submonoid A) (c : seq n B),
 subtype_elt (sum c) =' sum (Map_embed c) in _. *)
Require Export omit.
(* omit:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export empty.
Require Export conshdtl.

Definition omit :
  forall (A : Setoid) (n : Nat), seq n A -> fin n -> seq (pred n) A.

Lemma omit_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq n A) (i i' : fin n),
 v =' v' in _ -> i =' i' in _ -> omit v i =' omit v' i' in _.

Hint Resolve omit_comp: algebra.

Lemma omit_removes :
 forall (n : Nat) (A : Setoid) (v : seq n A) (i : fin n) (j : fin (pred n)),
 sigT (fun i' => v i' =' omit v i j in _).

Lemma omit_removes' :
 forall (n : Nat) (A : Setoid) (v : seq n A) (i j : fin n),
 ~ i =' j in _ -> sigT (fun j' => v j =' omit v i j' in _). *)
Require Export modify_seq.
(* modify_seq:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Definition modify_seq :
  forall (A : Setoid) (n : Nat), seq n A -> fin n -> A -> seq n A.

Lemma modify_comp :
 forall (A : Setoid) (n : Nat) (a a' : A) (v v' : seq n A) (i i' : fin n),
 a =' a' in _ ->
 v =' v' in _ -> i =' i' in _ -> modify_seq v i a =' modify_seq v' i' a' in _.

Hint Resolve modify_comp: algebra.

Lemma modify_hd_hd :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (H : 0 < S n) (a : A),
 head (modify_seq v (Build_finiteT H) a) =' a in _.

Hint Resolve modify_hd_hd: algebra.

Lemma modify_hd_tl :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (H : 0 < S n) (a : A),
 Seqtl (modify_seq v (Build_finiteT H) a) =' Seqtl v in _.

Hint Resolve modify_hd_tl: algebra.

Lemma modify_tl_hd :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (m : Nat) 
   (H : S m < S n) (a : A),
 head (modify_seq v (Build_finiteT H) a) =' head v in _.

Hint Resolve modify_tl_hd: algebra.

Lemma modify_tl_tl :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (m : Nat) 
   (HS : S m < S n) (H : m < n) (a : A),
 Seqtl (modify_seq v (Build_finiteT HS) a) ='
 modify_seq (Seqtl v) (Build_finiteT H) a in _.

Hint Resolve modify_tl_tl: algebra.

Lemma Seqtl_modify_seq :
 forall (A : Setoid) (n : Nat) (v : seq (S n) A) (a : A) (H : 0 < S n),
 modify_seq v (Build_finiteT H) a =' a;; Seqtl v in _.

Hint Resolve Seqtl_modify_seq.

Lemma modify_seq_defprop :
 forall (A : Setoid) (n : Nat) (v : seq n A) (i : fin n) (a : A),
 modify_seq v i a i =' a in _.

Hint Resolve modify_seq_defprop: algebra.

Lemma modify_seq_modifies_one_elt :
 forall (A : Setoid) (n : Nat) (v : seq n A) (i : fin n) (a : A) (j : fin n),
 ~ j =' i in _ -> modify_seq v i a j =' v j in _.

Hint Resolve modify_seq_modifies_one_elt: algebra. *)
Require Export const.
(* const:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Section MAIN.
Variable A : Setoid.

Definition const_map : forall (X Y : Setoid) (y : Y), MAP X Y.

Definition const_seq : forall (n : Nat) (a : A), seq n A.

Lemma seq_S_O_constseq : forall v : seq 1 A, v =' const_seq 1 (head v) in _.

Lemma Seqtl_const_seq :
 forall (n : Nat) (a : A), Seqtl (const_seq n a) =' const_seq (pred n) a in _.

Lemma cons_const_seq :
 forall (n : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ -> a;; const_seq n a' =' const_seq (S n) a'' in _.

End MAIN. *)

Lemma sum_omit_zeros :
 forall (M : monoid) (n : Nat) (v : seq n M) (i : fin n),
 v i =' (zero M) in _ -> sum v =' sum (omit v i) in _.
destruct n.
auto with algebra.

induction  n as [| n Hrecn].
intros.
simpl in |- *.
generalize H.
unfold head in |- *.
elim i.
intro x; case x.
intros.
apply Trans with (v (Build_finiteT (lt_O_Sn 0))); auto with algebra.
apply Trans with (v (Build_finiteT in_range_prf)); auto with algebra.
intros.
inversion in_range_prf.
inversion H2.
intros.
generalize H; clear H.
case i.
intro x; case x.
intros.
apply Trans with (sum (hdtl v)); auto with algebra.
unfold hdtl in |- *.
unfold head in |- *.
apply Trans with ((zero M) +' sum (Seqtl v)); auto with algebra.
apply Trans with (v (Build_finiteT (lt_O_Sn (S n))) +' sum (Seqtl v));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Trans with (v (Build_finiteT in_range_prf)); auto with algebra.
intros.
apply Trans with (sum (hdtl v)); auto with algebra.
apply
 Trans
  with
    (sum (head v;; omit (Seqtl v) (Build_finiteT (lt_S_n _ _ in_range_prf))));
 auto with algebra.
unfold hdtl in |- *.
apply Trans with (head v +' sum (Seqtl v)); auto with algebra.
apply
 Trans
  with
    (head v +' sum (omit (Seqtl v) (Build_finiteT (lt_S_n _ _ in_range_prf))));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
apply Hrecn; auto with algebra.
apply Trans with (v (Build_finiteT in_range_prf)); auto with algebra.
generalize Seqtl_to_seq.
intro.
apply (H0 M (S n) v n0 (lt_S_n n0 (S n) in_range_prf) in_range_prf).
Qed.

Lemma sum_modify :
 forall (AG : abelian_group) (n : Nat) (v : seq n AG) (i : fin n) (a : AG),
 sum (modify_seq v i a) =' sum v +' (min v i) +' a in _.
simple induction n.
intros.
inversion i.
inversion in_range_prf.
intros.
destruct i.
destruct index as [| n1].
apply Trans with (sum (a;; Seqtl v)); auto with algebra.
apply Trans with (sum (hdtl v) +' (min head v) +' a).
apply Trans with (a +' sum (Seqtl v)); auto with algebra.
apply Trans with (sum (Seqtl v) +' a); auto with algebra.
apply SGROUP_comp; auto with algebra.
unfold hdtl in |- *.
apply Trans with (head v +' sum (Seqtl v) +' (min head v)); auto with algebra.
apply Trans with (sum (Seqtl v) +' head v +' (min head v)); auto with algebra.
apply Trans with (sum (Seqtl v) +' (head v +' (min head v)));
 auto with algebra.
apply Trans with (sum (Seqtl v) +' (zero AG)); auto with algebra.

apply SGROUP_comp; auto with algebra.
apply SGROUP_comp; auto with algebra.

apply Trans with (sum (hdtl (modify_seq v (Build_finiteT in_range_prf) a)));
 auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with
    (head (modify_seq v (Build_finiteT in_range_prf) a) +'
     sum (Seqtl (modify_seq v (Build_finiteT in_range_prf) a)));
 auto with algebra.
apply
 Trans
  with (head v +' sum (Seqtl (modify_seq v (Build_finiteT in_range_prf) a)));
 auto with algebra.
apply Trans with (sum (hdtl v) +' (min v (Build_finiteT in_range_prf)) +' a);
 auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with (head v +' sum (Seqtl v) +' (min v (Build_finiteT in_range_prf)) +' a);
 auto with algebra.
apply
 Trans
  with
    (head v +' (sum (Seqtl v) +' (min v (Build_finiteT in_range_prf)) +' a)).
apply SGROUP_comp; auto with algebra.
apply
 Trans
  with
    (sum (modify_seq (Seqtl v) (Build_finiteT (lt_S_n _ _ in_range_prf)) a));
 auto with algebra.

apply
 Trans
  with
    (sum (Seqtl v) +' (min Seqtl v (Build_finiteT (lt_S_n _ _ in_range_prf))) +'
     a); auto with algebra.
apply
 Trans
  with
    (head v +' (sum (Seqtl v) +' (min v (Build_finiteT in_range_prf))) +' a);
 auto with algebra.
Qed.

Lemma sum_of_zeros :
 forall (M : monoid) (n : Nat) (v : seq n M),
 v =' const_seq n (zero M) in _ -> sum v =' (zero M) in _.
simple induction n; intros.
simpl in |- *.
apply Refl.
apply Trans with (sum (hdtl v)); auto with algebra.
unfold hdtl in |- *.
apply Trans with (head v +' sum (Seqtl v)); auto with algebra.
apply Trans with ((zero M) +' sum (Seqtl v)).
apply SGROUP_comp; auto with algebra.
unfold head in |- *.
simpl in H0.
red in H0.
apply Trans with (const_seq (S n0) (zero M) (Build_finiteT (lt_O_Sn n0)));
 auto with algebra.
apply Trans with ((zero M) +' (zero M)); auto with algebra.
apply SGROUP_comp; auto with algebra.
apply H; auto with algebra.
simpl in |- *; simpl in H0.
red in |- *; red in H0.
simpl in |- *; simpl in H0.
intro.
destruct x.
auto with algebra.
Qed.

Hint Resolve sum_omit_zeros sum_modify sum_of_zeros: algebra.
