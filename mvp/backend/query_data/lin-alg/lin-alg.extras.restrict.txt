
Set Implicit Arguments.
Unset Strict Implicit.
Require Export const.
(* const:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Section MAIN.
Variable A : Setoid.

Definition const_map : forall (X Y : Setoid) (y : Y), MAP X Y.

Definition const_seq : forall (n : Nat) (a : A), seq n A.

Lemma seq_S_O_constseq : forall v : seq 1 A, v =' const_seq 1 (head v) in _.

Lemma Seqtl_const_seq :
 forall (n : Nat) (a : A), Seqtl (const_seq n a) =' const_seq (pred n) a in _.

Lemma cons_const_seq :
 forall (n : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ -> a;; const_seq n a' =' const_seq (S n) a'' in _.

End MAIN. *)
Require Export pointwise.
(* pointwise:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export concat.
From Algebra Require Export Cartesian.

Definition pointwise :
  forall (A B C D : Setoid) (op : Map (cart B C) D) 
    (f : Map A B) (g : Map A C), MAP A D.

Lemma pointwise_comp_general :
 forall (A B C D : Setoid) (op op' : Map (cart B C) D) 
   (f f' : Map A B) (g g' : Map A C),
 op =' op' in MAP _ _ ->
 f =' f' in MAP _ _ ->
 g =' g' in MAP _ _ -> pointwise op f g =' pointwise op' f' g' in _.

Lemma pointwise_comp :
 forall (n : Nat) (B C D : Setoid) (op op' : Map (cart B C) D)
   (f f' : seq n B) (g g' : seq n C),
 op =' op' in MAP _ _ ->
 f =' f' in _ -> g =' g' in _ -> pointwise op f g =' pointwise op' f' g' in _.

Hint Resolve pointwise_comp: algebra.

Lemma pointwise_hd :
 forall (A B C : Setoid) (n : Nat) (v : seq (S n) A) 
   (w : seq (S n) B) (op : Map (cart A B) C) (H : 0 < S n),
 pointwise op v w (Build_finiteT H) ='
 op (couple (v (Build_finiteT H)) (w (Build_finiteT H))) in _.

Hint Resolve pointwise_hd: algebra.

Lemma pointwise_cons :
 forall (A B C : Setoid) (a : A) (b : B) (n : Nat) 
   (v : seq n A) (w : seq n B) (op : Map (cart A B) C),
 pointwise op (a;; v) (b;; w) =' op (couple a b);; pointwise op v w
 in seq _ _.

Hint Resolve pointwise_cons: algebra.

Lemma pointwise_hd_tl :
 forall (A B C : Setoid) (n : Nat) (v : seq (S n) A) 
   (w : seq (S n) B) (op : Map (cart A B) C),
 pointwise op v w ='
 op (couple (head v) (head w));; pointwise op (Seqtl v) (Seqtl w) in 
 seq _ _.

Hint Resolve pointwise_hd_tl: algebra.

Lemma pointwise_Seqtl :
 forall (A B C : Setoid) (n : Nat) (v : seq n A) (w : seq n B)
   (op : Map (cart A B) C),
 pointwise op (Seqtl v) (Seqtl w) =' Seqtl (pointwise op v w) in seq _ _.

Hint Resolve pointwise_Seqtl: algebra.

Lemma pointwise_concat :
 forall (A B C : Setoid) (n m : Nat) (v : seq n A) 
   (w : seq m A) (x : seq n B) (y : seq m B) (op : MAP (cart A B) C),
 pointwise op (v ++ w) (x ++ y) =' pointwise op v x ++ pointwise op w y
 in seq _ _.

Hint Resolve pointwise_concat: algebra. *)
Require Export distinct.
(* distinct:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
From Algebra Require Export Parts.

Definition distinct (A : Setoid) (n : Nat) (v : seq n A) :=
  forall i j : fin n, ~ i =' j in _ -> ~ v i =' v j in _.

Lemma distinct_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq n A),
 distinct v -> v =' v' in _ -> distinct v'.

Hint Resolve distinct_comp: algebra.

Definition distinct_pred (A : Setoid) (n : Nat) : Predicate (seq n A). *)

Definition restricted_seq :
  forall (S : Setoid) (N : Nat) (f : seq N S) (M : Nat) (leMN : M <= N),
  seq M S.
intros.
simpl in |- *.
apply
 (Build_Map
    (Ap:=fun mM : fin M =>
         f
           match mM with
           | Build_finiteT m ltmM =>
               Build_finiteT (lt_le_trans _ _ _ ltmM leMN)
           end)).
red in |- *.
intros.
destruct x.
destruct y.
apply Ap_comp; auto with algebra.
Defined.

Lemma restricted_comp :
 forall (S : Setoid) (N : Nat) (f f' : seq N S) (M : Nat)
   (leMN leMN' : M <= N),
 f =' f' in _ -> restricted_seq f leMN =' restricted_seq f' leMN' in _.
intros.
simpl in |- *.
red in |- *.
simpl in |- *.
destruct x.
apply Ap_comp; auto with algebra.
Qed.

Hint Resolve restricted_comp: algebra.

Lemma const_map_restricted :
 forall (n N : Nat) (H : n <= N) (Y : Setoid) (y : Y),
 restricted_seq (const_seq N y) H =' const_seq n y in _.
intros.
simpl in |- *.
red in |- *.
intro i.
unfold restricted_seq in |- *.
unfold const_map in |- *.
simpl in |- *.
apply Refl.
Qed.

Hint Resolve const_map_restricted: algebra.

Lemma restricted_seq_preserves_distinct :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (H : m <= n),
 distinct v -> distinct (restricted_seq v H).
unfold distinct in |- *.
simpl in |- *.
intros.
destruct i; destruct j.
apply
 (H0 (Build_finiteT (lt_le_trans index m n in_range_prf H))
    (Build_finiteT (lt_le_trans index0 m n in_range_prf0 H))).
simpl in |- *; simpl in H1.
auto.
Qed.

Hint Resolve restricted_seq_preserves_distinct: algebra.

Lemma pointwise_restricted :
 forall (n N : Nat) (H : n <= N) (B C D : Setoid) (op : Map (cart B C) D)
   (f : seq N B) (g : seq N C),
 restricted_seq (pointwise op f g) H ='
 pointwise op (restricted_seq f H) (restricted_seq g H) in _. 
intros.
unfold pointwise in |- *.
unfold restricted_seq in |- *.
simpl in |- *.
red in |- *.
intro i.
simpl in |- *.
apply Refl.
Qed.

Hint Resolve pointwise_restricted: algebra.