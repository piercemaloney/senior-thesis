
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
(* finite:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Arith.
Require Export equal_syntax.

Definition Nat : Setoid.

Record finiteT (N : Nat) : Type :=  {index : nat; in_range_prf : index < N}.

Definition fin : Nat -> Setoid.

Lemma fin_equation :
 forall (n i j : nat) (Hi : i < n) (Hj : j < n),
 i = j -> Build_finiteT Hi =' Build_finiteT Hj in fin n.

Hint Resolve fin_equation: algebra.

Lemma fin_decidable :
 forall (n : Nat) (i i' : fin n), i =' i' in _ \/ ~ i =' i' in _.

Lemma fin_O_nonexistent : fin 0 -> False.

Hint Resolve fin_O_nonexistent: algebra.

Lemma fin_S_O_unique : forall i j : fin 1, i =' j in _.

Hint Resolve fin_S_O_unique: algebra.

Definition seq (n : Nat) (A : Setoid) := MAP (fin n) A.

Lemma toSeq :
 forall (A : Setoid) (n : Nat) (v v' : Map (fin n) A),
 v =' v' in seq _ _ -> v =' v' in MAP _ _.

Lemma toMap :
 forall (A : Setoid) (n : Nat) (v v' : Map (fin n) A),
 v =' v' in MAP _ _ -> v =' v' in seq _ _.

Hint Resolve toSeq toMap: algebra. *)
From Algebra Require Export Parts.

Definition distinct (A : Setoid) (n : Nat) (v : seq n A) :=
  forall i j : fin n, ~ i =' j in _ -> ~ v i =' v j in _.

Lemma distinct_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq n A),
 distinct v -> v =' v' in _ -> distinct v'.
unfold distinct in |- *.
intros.
simpl in H0; red in H0.
red in H; red in |- *; intro.
apply H with i j; auto with algebra.
apply Trans with (v' i); auto with algebra.
apply Trans with (v' j); auto with algebra.
Qed.

Hint Resolve distinct_comp: algebra.

Definition distinct_pred (A : Setoid) (n : Nat) : Predicate (seq n A). 
intros.
apply (Build_Predicate (Pred_fun:=distinct (A:=A) (n:=n))); auto with algebra.
red in |- *.
intros.
apply distinct_comp with x; auto with algebra.
Defined.
