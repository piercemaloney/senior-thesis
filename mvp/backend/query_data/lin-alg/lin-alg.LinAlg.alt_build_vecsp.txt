
Set Implicit Arguments.
Unset Strict Implicit.
Require Export vecspaces_verybasic.
(* vecspaces_verybasic:
Section MAIN.
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Field_facts.
Require Export equal_syntax.
Require Export more_syntax.
From Algebra Require Export Module_facts.

Section vecfielddef.

Definition vectorspace (F : field) : Type := MODULE F.
Definition VECSP (F : field) : category :=
  full_subcat (fun V : vectorspace F => V:MODULE F).

End vecfielddef.

Section jargon.
Variable F : field.
Variable V : vectorspace F.
Definition carrier := module_carrier.
Definition scalar_mult (a : F) (x : V) : V := a mX x.

Definition scalar_mult_comp :
  forall (x x' : F) (y y' : carrier V),
  x =' x' in _ -> y =' y' in _ -> x mX y =' x' mX y' in _ :=
  MODULE_comp (R:=F) (Mod:=V).
Definition one_acts_as_unit : forall x : carrier V, one mX x =' x in _ :=
  MODULE_unit_l (R:=F) (Mod:=V).
Definition quasi_associativity :
  forall (a b : F) (x : carrier V), (a rX b) mX x =' a mX b mX x in _ :=
  MODULE_assoc (R:=F) (Mod:=V).
Definition distributivity :
  forall (a : F) (x y : carrier V), a mX (x +' y) =' a mX x +' a mX y in _ :=
  MODULE_dist_l (R:=F) (Mod:=V).
Definition distributivity' :
  forall (a b : F) (x : carrier V), (a +' b) mX x =' a mX x +' b mX x in _ :=
  MODULE_dist_r (R:=F) (Mod:=V).
End jargon.

Variable F : field.
Variable V : vectorspace F.
Hint Unfold carrier module_carrier.
Hint Resolve scalar_mult_comp distributivity distributivity': algebra.

Section Lemmas1.

Lemma vector_cancellation :
 forall x y z : V, x +' z =' y +' z in _ -> x =' y in _.

Lemma Zero_times_a_vector_gives_zero :
 forall v : V, (zero F) mX v =' (zero V) in _.

Lemma a_scalar_times_zero_gives_zero :
 forall f : F, f mX (zero V) =' (zero V) in _.
 
Section Lemmas1_2.

Lemma Mince_minus1 :
 forall (f : F) (v : V), (min f) mX v =' (min f mX v) in _.
 
Lemma Mince_minus2 :
 forall (f : F) (v : V), (min f mX v) =' f mX (min v) in _.
 
Lemma Mince_minus3 :
 forall (f : F) (v : V), (min f) mX v =' f mX (min v) in _.

Lemma vecspace_op_reg_l :
 forall (f : F) (v : V),
 ~ f =' (zero F) in _ -> f mX v =' (zero V) in _ -> v =' (zero V) in _.

End Lemmas1_2.
End Lemmas1.

End MAIN.

Hint Resolve vector_cancellation Zero_times_a_vector_gives_zero
  a_scalar_times_zero_gives_zero Mince_minus1 Mince_minus2 Mince_minus3:
  algebra. *)
Require Export Map2.
(* Map2:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export equal_syntax.
From Algebra Require Export Cartesian.

Record Map2 (A B C : Setoid) : Type := 
  {Ap2 :> A -> B -> C; Ap2_comp_proof : fun2_compatible Ap2}.

Definition Map2_Mapcart :
  forall A B C : Setoid, Map2 A B C -> Map (cart A B) C.

Definition Mapcart_Map2 :
  forall A B C : Setoid, Map (cart A B) C -> Map2 A B C.

Definition MAP2 (A B C : Setoid) : Setoid.

Definition Map2_ap_Map : forall A B C : Setoid, Map2 A B C -> A -> MAP B C.

Definition Ap2_Map : forall A B C : Setoid, Map2 A B C -> Map A (MAP B C).

Definition Map2_ap'_Map : forall A B C : Setoid, Map2 A B C -> B -> MAP A C.

Definition Ap2_Map' : forall A B C : Setoid, Map2 A B C -> Map B (MAP A C). *)

Section MAIN.
Variable V : Setoid.
Variable F : field.
Variable add : Map2 V V V.
Variable mlt : Map2 F V V.
Variable zer : V.
Variable mns : Map V V.
Definition VS1 := forall x y : V, add x y =' add y x in _.
Definition VS2 := forall x y z : V, add (add x y) z =' add x (add y z) in _.
Definition VS3 := forall x : V, add x zer =' x in _.
Definition VS4 := forall x : V, add x (mns x) =' zer in _.
Definition VS5 := forall x : V, mlt one x =' x in _.
Definition VS6 :=
  forall (a b : F) (x : V), mlt (a rX b) x =' mlt a (mlt b x) in _.
Definition VS7 :=
  forall (a : F) (x y : V), mlt a (add x y) =' add (mlt a x) (mlt a y) in _.
Definition VS8 :=
  forall (a b : F) (x : V), mlt (a +' b) x =' add (mlt a x) (mlt b x) in _.

Let Vsg_on : VS2 -> sgroup_on V.
intro VS2p.
apply (Build_sgroup_on (sgroup_law_map:=Map2_Mapcart add)).
red in |- *.
intros.
simpl in |- *.
auto with algebra.
Defined.

Let Vsg : VS2 -> sgroup.
intro VS2p.
apply (Build_sgroup (Vsg_on VS2p)).
Defined.

Let Vmon_on : VS1 -> forall VS2p : VS2, VS3 -> monoid_on (Vsg VS2p).
intros VS1p VS2p VS3p.
apply (Build_monoid_on (monoid_unit:=zer:Vsg VS2p)).
red in |- *; simpl in |- *.
auto.
red in |- *; simpl in |- *; intro.
apply Trans with (add x (zer:Vsg VS2p)); auto with algebra.
Defined.

Let Vmon : VS1 -> VS2 -> VS3 -> monoid.
intros VS1p VS2p VS3p.
apply (Build_monoid (Vmon_on VS1p VS2p VS3p)).
Defined.

Let Vgp_on :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3),
  VS4 -> group_on (Vmon VS1p VS2p VS3p).
intros.
set (VMON := Vmon VS1p VS2p VS3p) in *.
apply (Build_group_on (group_inverse_map:=mns:Map VMON VMON)).
red in |- *; simpl in |- *.
auto with algebra.
red in |- *; simpl in |- *.
intro.
apply Trans with (add x (mns x)); auto with algebra.
Defined.

Let Vgp : VS1 -> VS2 -> VS3 -> VS4 -> group.
intros VS1p VS2p VS3p VS4p.
apply (Build_group (Vgp_on VS1p VS2p VS3p VS4p)).
Defined.

Let Vabgp_on :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  abelian_group_on (Vgp VS1p VS2p VS3p VS4p).
intros.
apply Build_abelian_group_on.
apply Build_abelian_monoid_on.
apply Build_abelian_sgroup_on.
red in |- *; simpl in |- *.
auto.
Defined.

Let Vabgp : VS1 -> VS2 -> VS3 -> VS4 -> abelian_group.
intros VS1p VS2p VS3p VS4p.
apply (Build_abelian_group (Vabgp_on VS1p VS2p VS3p VS4p)).
Defined.

Let F_act_map :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  Map (Build_monoid (ring_monoid F)) (Endo_SET (Vabgp VS1p VS2p VS3p VS4p)).
intros VS1p VS2p VS3p VS4p.
simpl in |- *.
apply (Build_Map (Ap:=fun c : F => Ap2_Map mlt c)).
red in |- *.
intros; destruct mlt; simpl in |- *.
red in |- *; simpl in |- *.
intro; auto with algebra.
Defined.

Let F_sgp_hom :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  VS6 ->
  sgroup_hom (Build_monoid (ring_monoid F))
    (Endo_SET (Vabgp VS1p VS2p VS3p VS4p)).
intros VS1p VS2p VS3p VS4p VS6p.
apply (Build_sgroup_hom (sgroup_map:=F_act_map VS1p VS2p VS3p VS4p)).
red in |- *.
intros; simpl in |- *.
red in |- *; simpl in |- *.
intro.
apply Trans with (mlt (x rX y) x0); auto with algebra.
Defined.

Let F_op :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  VS5 ->
  VS6 -> operation (Build_monoid (ring_monoid F)) (Vabgp VS1p VS2p VS3p VS4p).
intros VS1p VS2p VS3p VS4p VS5p VS6p.
apply
 (Build_monoid_hom (monoid_sgroup_hom:=F_sgp_hom VS1p VS2p VS3p VS4p VS6p)).
red in |- *.
simpl in |- *.
red in |- *.
intro; simpl in |- *.
apply Trans with (mlt one x); auto with algebra.
Defined.

Let Vmod_on :
  forall (VS1p : VS1) (VS2p : VS2) (VS3p : VS3) (VS4p : VS4),
  VS5 -> VS6 -> VS7 -> VS8 -> module_on F (Vabgp VS1p VS2p VS3p VS4p).
intros VS1p VS2p VS3p VS4p VS5p VS6p VS7p VS8p.
apply (Build_module_on (module_op:=F_op VS1p VS2p VS3p VS4p VS5p VS6p)).
red in |- *; simpl in |- *.
auto with algebra.
red in |- *.
intros.
simpl in |- *.
red in VS7p.
apply Trans with (mlt a (add x y)); auto with algebra.
apply Trans with (add (mlt a x) (mlt a y)); auto with algebra.
Defined.

Definition alt_Build_vectorspace :
  VS1 -> VS2 -> VS3 -> VS4 -> VS5 -> VS6 -> VS7 -> VS8 -> vectorspace F.
intros VS1p VS2p VS3p VS4p VS5p VS6p VS7p VS8p.
red in |- *.
simpl in |- *.
apply (Build_module (Vmod_on VS1p VS2p VS3p VS4p VS5p VS6p VS7p VS8p)).
Defined.

Definition vectorspace_construction :
  VS1 ->
  VS2 ->
  VS3 ->
  VS4 ->
  VS5 -> VS6 -> VS7 -> VS8 -> sigT (fun VV : vectorspace F => Carrier VV = V).
intros.
exists (alt_Build_vectorspace H H0 H1 H2 H3 H4 H5 H6).
simpl in |- *.
auto.
Defined.
End MAIN.