
Set Implicit Arguments.
Unset Strict Implicit.
Require Export mult_by_scalars.
(* mult_by_scalars:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export pointwise.
Require Export modify_seq.
Require Export vecspaces_verybasic.

Definition mult_by_scalars (R : ring) (V : module R) 
  (N : Nat) (a : Map (fin N) R) (v : Map (fin N) V) : 
  MAP (fin N) V := pointwise (uncurry (MODULE_comp (Mod:=V))) a v.

Lemma mult_by_scalars_comp :
 forall (R : ring) (V : module R) (N : Nat) (a b : MAP (fin N) R)
   (v w : MAP (fin N) V),
 a =' b in _ ->
 v =' w in _ -> mult_by_scalars a v =' mult_by_scalars b w in _.

Lemma mult_by_scalars_fun2_compatible :
 forall (R : ring) (V : module R) (N : Nat),
 fun2_compatible
   (mult_by_scalars (V:=V) (N:=N):MAP _ _ -> MAP _ _ -> MAP _ _).

Hint Resolve mult_by_scalars_fun2_compatible mult_by_scalars_comp: algebra.

Lemma mult_by_scalars_Seqtl :
 forall (R : ring) (V : module R) (N : Nat) (a : Map (fin N) R)
   (v : Map (fin N) V),
 mult_by_scalars (Seqtl a) (Seqtl v) =' Seqtl (mult_by_scalars a v) in _.

Hint Resolve mult_by_scalars_Seqtl: algebra.

Lemma mult_by_scalars_concat :
 forall (R : ring) (V : module R) (N M : Nat) (a : Map (fin N) R)
   (b : Map (fin M) R) (v : Map (fin N) V) (w : Map (fin M) V),
 mult_by_scalars (a ++ b) (v ++ w) ='
 mult_by_scalars a v ++ mult_by_scalars b w in _.

Hint Resolve mult_by_scalars_concat: algebra.

Lemma mult_by_scalars_modify_seq :
 forall (F : field) (V : vectorspace F) (n : Nat) (p : seq n F) 
   (k : seq n V) (i : fin n) (q : F),
 mult_by_scalars (modify_seq p i q) k ='
 modify_seq (mult_by_scalars p k) i (q mX k i) in seq _ _.

Hint Resolve mult_by_scalars_modify_seq: algebra. *)
Require Export const.
(* const:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export conshdtl.

Section MAIN.
Variable A : Setoid.

Definition const_map : forall (X Y : Setoid) (y : Y), MAP X Y.

Definition const_seq : forall (n : Nat) (a : A), seq n A.

Lemma seq_S_O_constseq : forall v : seq 1 A, v =' const_seq 1 (head v) in _.

Lemma Seqtl_const_seq :
 forall (n : Nat) (a : A), Seqtl (const_seq n a) =' const_seq (pred n) a in _.

Lemma cons_const_seq :
 forall (n : Nat) (a a' a'' : A),
 a =' a' in _ ->
 a' =' a'' in _ -> a;; const_seq n a' =' const_seq (S n) a'' in _.

End MAIN. *)
Require Export sums.
(* sums:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.
From Algebra Require Export Sub_monoid.
Require Export more_syntax.

Fixpoint sum (V : monoid) (n : Nat) {struct n} : seq n V -> V :=
  match n return (seq n V -> V) with
  | O => fun x : seq 0 V => zero V
  | S m => fun x : seq (S m) V => head x +' sum (Seqtl x)
  end.

Lemma sum_comp :
 forall (M : monoid) (n : Nat) (f f' : seq n M),
 f =' f' in _ -> sum f =' sum f' in _.

Hint Resolve sum_comp: algebra.

Lemma sum_cons :
 forall (M : monoid) (m : M) (n : Nat) (f : seq n M),
 sum (m;; f) =' m +' sum f in _.

Hint Resolve sum_cons: algebra.

Lemma sum_concat :
 forall (n m : Nat) (G : monoid) (a : seq n G) (b : seq m G),
 sum (a ++ b) =' sum a +' sum b in _.

Hint Resolve sum_concat: algebra.

Lemma subtype_sum :
 forall (n : nat) (A : monoid) (B : submonoid A) (c : seq n B),
 subtype_elt (sum c) =' sum (Map_embed c) in _. *)

Lemma RING_sum_mult_dist_l :
 forall (R : ring) (n : Nat) (r : R) (a : seq n R),
 r rX sum a =' sum (pointwise (uncurry (RING_comp (R:=R))) (const_seq n r) a)
 in _.
simple induction n.
simpl in |- *.
auto with algebra.
intros.
apply Trans with (r rX sum (hdtl a)); auto with algebra; unfold hdtl in |- *.
apply Trans with (r rX (head a +' sum (Seqtl a))); auto with algebra.
apply Trans with (r rX head a +' r rX sum (Seqtl a)); auto with algebra.
apply
 Trans
  with
    (r rX head a +'
     sum
       (pointwise (uncurry (RING_comp (R:=R))) (Seqtl (const_seq (S n0) r))
          (Seqtl a))).
apply SGROUP_comp; auto with algebra.
apply
 Trans
  with
    (sum (pointwise (uncurry (RING_comp (R:=R))) (const_seq n0 r) (Seqtl a)));
 auto with algebra.
apply sum_comp.
apply toMap.
apply pointwise_comp; auto with algebra.
apply Sym.
change (Seqtl (const_seq (S n0) r) =' const_seq (pred (S n0)) r in _) in |- *.
apply Seqtl_const_seq.
apply Sym.
apply
 Trans
  with
    (sum
       (hdtl (pointwise (uncurry (RING_comp (R:=R))) (const_seq (S n0) r) a)));
 auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with
    (head (pointwise (uncurry (RING_comp (R:=R))) (const_seq (S n0) r) a) +'
     sum
       (pointwise (uncurry (RING_comp (R:=R))) (Seqtl (const_seq (S n0) r))
          (Seqtl a))); auto with algebra.
apply
 Trans
  with
    (head (pointwise (uncurry (RING_comp (R:=R))) (const_seq (S n0) r) a) +'
     sum
       (Seqtl (pointwise (uncurry (RING_comp (R:=R))) (const_seq (S n0) r) a)));
 auto with algebra.
Qed.

Lemma MODULE_sum_mult_dist_l :
 forall (R : ring) (M : module R) (n : Nat) (r : R) (a : seq n M),
 r mX sum a =' sum (mult_by_scalars (const_seq n r) a) in _.
simple induction n.
simpl in |- *.
auto with algebra.
intros.
apply Trans with (r mX sum (hdtl a)); auto with algebra; unfold hdtl in |- *.
apply Trans with (r mX (head a +' sum (Seqtl a))); auto with algebra.
apply Trans with (r mX head a +' r mX sum (Seqtl a)); auto with algebra.
apply
 Trans
  with
    (r mX head a +'
     sum (mult_by_scalars (Seqtl (const_seq (S n0) r)) (Seqtl a))).
apply SGROUP_comp; auto with algebra.
apply Trans with (sum (mult_by_scalars (const_seq n0 r) (Seqtl a)));
 auto with algebra.
apply sum_comp.
apply toMap.
apply mult_by_scalars_comp; auto with algebra.
apply Sym.
change (Seqtl (const_seq (S n0) r) =' const_seq (pred (S n0)) r in _) in |- *.
apply Seqtl_const_seq.
apply Trans with (sum (hdtl (mult_by_scalars (const_seq (S n0) r) a)));
 auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with
    (head (mult_by_scalars (const_seq (S n0) r) a) +'
     sum (mult_by_scalars (Seqtl (const_seq (S n0) r)) (Seqtl a)));
 auto with algebra.
apply
 Trans
  with
    (head (mult_by_scalars (const_seq (S n0) r) a) +'
     sum (Seqtl (mult_by_scalars (const_seq (S n0) r) a))); 
 auto with algebra.
Qed.

Hint Resolve RING_sum_mult_dist_l MODULE_sum_mult_dist_l: algebra.

Lemma pointwise_module_assoc :
 forall (R : ring) (M : module R) (n : Nat) (r r' : seq n R) (m : seq n M),
 let rmult := uncurry (RING_comp (R:=R)) in
 mult_by_scalars r (mult_by_scalars r' m) ='
 mult_by_scalars (pointwise rmult r r') m in _.
intros.
intro i; simpl in |- *.
auto with algebra.
Qed.

Hint Resolve pointwise_module_assoc: algebra.