
Set Implicit Arguments.
Unset Strict Implicit.

Section SECTION_1_2.

Require Export vecspaces_verybasic.
(* vecspaces_verybasic:
Section MAIN.
Set Automatic Coercions Import.
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Field_facts.
Require Export equal_syntax.
Require Export more_syntax.
From Algebra Require Export Module_facts.

Section vecfielddef.

Definition vectorspace (F : field) : Type := MODULE F.
Definition VECSP (F : field) : category :=
  full_subcat (fun V : vectorspace F => V:MODULE F).

End vecfielddef.

Section jargon.
Variable F : field.
Variable V : vectorspace F.
Definition carrier := module_carrier.
Definition scalar_mult (a : F) (x : V) : V := a mX x.

Definition scalar_mult_comp :
  forall (x x' : F) (y y' : carrier V),
  x =' x' in _ -> y =' y' in _ -> x mX y =' x' mX y' in _ :=
  MODULE_comp (R:=F) (Mod:=V).
Definition one_acts_as_unit : forall x : carrier V, one mX x =' x in _ :=
  MODULE_unit_l (R:=F) (Mod:=V).
Definition quasi_associativity :
  forall (a b : F) (x : carrier V), (a rX b) mX x =' a mX b mX x in _ :=
  MODULE_assoc (R:=F) (Mod:=V).
Definition distributivity :
  forall (a : F) (x y : carrier V), a mX (x +' y) =' a mX x +' a mX y in _ :=
  MODULE_dist_l (R:=F) (Mod:=V).
Definition distributivity' :
  forall (a b : F) (x : carrier V), (a +' b) mX x =' a mX x +' b mX x in _ :=
  MODULE_dist_r (R:=F) (Mod:=V).
End jargon.

Variable F : field.
Variable V : vectorspace F.
Hint Unfold carrier module_carrier.
Hint Resolve scalar_mult_comp distributivity distributivity': algebra.

Section Lemmas1.

Lemma vector_cancellation :
 forall x y z : V, x +' z =' y +' z in _ -> x =' y in _.

Lemma Zero_times_a_vector_gives_zero :
 forall v : V, (zero F) mX v =' (zero V) in _.

Lemma a_scalar_times_zero_gives_zero :
 forall f : F, f mX (zero V) =' (zero V) in _.
 
Section Lemmas1_2.

Lemma Mince_minus1 :
 forall (f : F) (v : V), (min f) mX v =' (min f mX v) in _.
 
Lemma Mince_minus2 :
 forall (f : F) (v : V), (min f mX v) =' f mX (min v) in _.
 
Lemma Mince_minus3 :
 forall (f : F) (v : V), (min f) mX v =' f mX (min v) in _.

Lemma vecspace_op_reg_l :
 forall (f : F) (v : V),
 ~ f =' (zero F) in _ -> f mX v =' (zero V) in _ -> v =' (zero V) in _.

End Lemmas1_2.
End Lemmas1.

End MAIN.

Hint Resolve vector_cancellation Zero_times_a_vector_gives_zero
  a_scalar_times_zero_gives_zero Mince_minus1 Mince_minus2 Mince_minus3:
  algebra. *)

Variable F : field.
Variable V : vectorspace F.

Definition VS1 : forall x y : V, x +' y =' y +' x in _.
  exact (ABELIAN_SGROUP_com (S:=V)).
  Qed.

Definition VS2 : forall x y z : V, x +' y +' z =' x +' (y +' z) in _.
  exact (SGROUP_assoc (E:=V)).
  Qed.

Definition VS3 :
  exists zerovector : V, (forall x : V, x +' zerovector =' x in _).
  exists (zero V); auto with algebra.
  Qed.

Definition VS4 : forall x : V, exists y : V, x +' y =' (zero V) in _.
  intro; exists (min x); auto with algebra.
  Qed.

Definition VS5 : forall x : V, one mX x =' x in _.
  intro; exact (MODULE_unit_l x).
  Qed.

Definition VS6 : forall (a b : F) (x : V), (a rX b) mX x =' a mX b mX x in _.
  intros; exact (MODULE_assoc a b x).
  Qed.

Definition VS7 :
  forall (a : F) (x y : V), a mX (x +' y) =' a mX x +' a mX y in _.
  intros; exact (MODULE_dist_l a x y).
  Qed.

Definition VS8 :
  forall (a b : F) (x : V), (a +' b) mX x =' a mX x +' b mX x in _.
  intros; exact (MODULE_dist_r a b x).
  Qed.

Definition Proposition_1_1 :
  forall x y z : V, x +' z =' y +' z in _ -> x =' y in _.
  exact (vector_cancellation (V:=V)).
  Qed.

Definition Proposition_1_2a : forall x : V, (zero F) mX x =' (zero V) in _.
  exact (Zero_times_a_vector_gives_zero (V:=V)).
  Qed.

Definition Proposition_1_2b1 :
  forall (a : F) (x : V), (min a) mX x =' (min a mX x) in _.
  exact (Mince_minus1 (V:=V)).
  Qed.

Definition Proposition_1_2b2 :
  forall (a : F) (x : V), (min a mX x) =' a mX (min x) in _.
  exact (Mince_minus2 (V:=V)).
  Qed.

Definition Proposition_1_2b3 :
  forall (a : F) (x : V), (min a) mX x =' a mX (min x) in _.
  exact (Mince_minus3 (V:=V)).
  Qed.

Definition Proposition_1_2c : forall a : F, a mX (zero V) =' (zero V) in _.
  exact (a_scalar_times_zero_gives_zero V).
  Qed.

End SECTION_1_2.

Section SECTION_1_3.

Require Export subspaces.
(* subspaces:
Section MAIN.
Set Implicit Arguments.
Unset Strict Implicit.
Require Export vecspaces_verybasic.
Require Export arb_intersections.
From Algebra Require Export Sub_module.
From Algebra Require Export Singleton.
Require Export algebra_omissions.

Variable F : field.
Variable V : vectorspace F.
Section Subspace_def.

Definition subspace (F : field) (V : vectorspace F) := submodule V.

Variable W : subspace V.
Definition inj_subspace : Hom (W:VECSP F) V.

Lemma inj_subspace_injective : injective inj_subspace.

Lemma mult_inherited :
 forall (c : F) (x : W), inj_subspace (c mX x) =' c mX inj_subspace x in _.
End Subspace_def.

Section subspace_awkward_utils.

Definition is_subspace (W : part_set V) : Prop :=
  in_part (zero V) W /\
  (forall x y : V, in_part x W -> in_part y W -> in_part (x +' y) W) /\
  (forall (c : F) (x : V), in_part x W -> in_part (c mX x) W).

Lemma is_subspace_comp :
 forall S S' : part_set V, S =' S' in _ -> is_subspace S -> is_subspace S'.

Definition subspace_construction :
  forall Ws : part_set V,
  is_subspace Ws -> sigT (fun W : subspace V => W =' Ws in part_set V).

Definition alt_Build_subspace (W : part_set V) (H : is_subspace W) :
  subspace V := let (w, _) := subspace_construction H in w.

Lemma alt_Build_subspace_OK :
 forall (W : part_set V) (HW : is_subspace W),
 W =' alt_Build_subspace HW in _.

Lemma is_subspace_OK : forall W : subspace V, is_subspace W.

Lemma subspace_alt_characterization :
 forall Ws : part_set V,
 in_part (zero V) Ws /\
 (forall x y : V, in_part x Ws -> in_part y Ws -> in_part (x +' y) Ws) /\
 (forall (c : F) (x : V), in_part x Ws -> in_part (c mX x) Ws) <->
 (exists W : subspace V, W =' Ws in part_set V).

Definition Set_of_subspaces : part_set (part_set V).

Lemma Set_of_subspaces_closed_under_intersection :
 forall WS : part_set Set_of_subspaces,
 is_subspace (intersection (inject_subsets WS)).
End subspace_awkward_utils.

End MAIN.

Section Examples.
Variable F : field.
Variable V : vectorspace F.

Lemma singleton_zero_is_subspace : is_subspace (single (zero V)).

Definition triv_subspace : subspace V.

Definition full_subspace : subspace V.
End Examples. *)

Definition Theorem_1_3 :
  forall (F : field) (V : vectorspace F) (Ws : part_set V),
  in_part (zero V) Ws /\
  (forall x y : V, in_part x Ws -> in_part y Ws -> in_part (x +' y) Ws) /\
  (forall (c : F) (x : V), in_part x Ws -> in_part (c mX x) Ws) <->
  (exists W : subspace V, W =' Ws in part_set V).
  exact subspace_alt_characterization.
Qed.

Definition Theorem_1_4 :
  forall (F : field) (V : vectorspace F) (f : part_set (Set_of_subspaces V)),
  is_subspace (intersection (inject_subsets f)).
  exact Set_of_subspaces_closed_under_intersection.
  Qed.

Require Export direct_sum.
(* direct_sum:
Local Unset Standard Proposition Elimination Names.

Set Implicit Arguments.
Unset Strict Implicit.
Require Export algebraic_span_facts.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Definition sum_set (S1 S2 : part_set V) : part_set V.

Lemma subspace_sum_set :
 forall W1 W2 : part_set V,
 is_subspace W1 -> is_subspace W2 -> is_subspace (sum_set W1 W2).

Definition form_direct_sum (W1 W2 : subspace V) : Prop :=
  inter W1 W2 =' single (zero V) in _ /\ sum_set W1 W2 =' full V in _.
End MAIN.

Section Example.
Require Import symmetric_matrices.
Require Import antisymmetric_matrices.

Lemma matrixspace_sym_antisym :
 forall (n : nat) (F : field),
 ~ one +' one =' (zero F) in _ ->
 form_direct_sum (symm_subspace n F) (antisym_subspace n F).
End Example. *)

End SECTION_1_3.

Section SECTION_1_4.

Require Export lin_combinations.
(* lin_combinations:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export distinct.
Require Export distribution_lemmas.
Require Export sums2.
Require Export omit_facts.
Require Export cast_between_subsets.

Section lin_dep_def.

Definition is_lin_comb (F : field) (V : vectorspace F) 
  (x : V) (S : part_set V) :=
  exists n : Nat,
    (exists a : seq n F,
       (exists v : seq n S, x =' sum (mult_by_scalars a (Map_embed v)) in _)).

Lemma is_lin_comb_comp :
 forall (F : field) (V : vectorspace F) (x y : V) (S T : part_set V),
 S =' T in _ -> x =' y in _ -> is_lin_comb x S -> is_lin_comb y T.

Hint Resolve is_lin_comb_comp: algebra.

Definition is_lin_comb_pred :
  forall (F : field) (V : vectorspace F), part_set V -> Predicate V.
End lin_dep_def.

Section condensing.

Lemma lin_comb_with_distinct_vectors :
 forall (F : field) (V : vectorspace F) (x : V) (B : part_set V),
 is_lin_comb x B ->
 exists n : Nat,
   (exists a : seq n F,
      (exists v : seq n B,
         x =' sum (mult_by_scalars a (Map_embed v)) in _ /\ distinct v)).

Lemma lin_comb_condensed :
 forall (F : field) (V : vectorspace F) (B : part_set V) 
   (n : Nat) (b : seq n V),
 B =' seq_set b in _ ->
 forall x : V,
 is_lin_comb x B -> exists a : seq n F, x =' sum (mult_by_scalars a b) in _.

End condensing. *)

Require Export spans.
(* spans:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export lin_combinations.
Require Export subspaces.

Section spans.
Variable F : field.
Variable V : vectorspace F.
Definition span_set (S : part_set V) : part_set V := is_lin_comb_pred S.

Definition span : part_set V -> subspace V.

Lemma span_comp :
 forall S S' : part_set V, S =' S' in _ -> span S =' span S' in part_set V.

Lemma span_is_subspace : forall S : part_set V, is_subspace (span S).
End spans.

Hint Resolve span_comp: algebra.

Section spans_inductively_defined.
Variable F : field.
Variable V : vectorspace F.
Variable S : part_set V.

Inductive span_ind_formal : Type :=
  | Zerovector : span_ind_formal
  | Immediately : S -> span_ind_formal
  | Plusvector : span_ind_formal -> span_ind_formal -> span_ind_formal
  | Multvector : F -> span_ind_formal -> span_ind_formal.

Fixpoint span_ind_injection (X : span_ind_formal) : V :=
  match X with
  | Zerovector => zero V
  | Immediately s => subtype_elt s
  | Plusvector x y => span_ind_injection x +' span_ind_injection y
  | Multvector a x => a mX span_ind_injection x
  end.

Definition span_ind_set : part_set V.

Definition span_ind : subspace V.

Definition lin_comb_ind (v : V) : Prop := in_part v span_ind.
End spans_inductively_defined.

Section spans_eqv.

Variable F : field.
Variable V : vectorspace F.

Lemma span_ind_eqv_span :
 forall (S : part_set V) (v : V), is_lin_comb v S <-> lin_comb_ind S v.

Lemma span_is_span_ind :
 forall S : part_set V, span S =' span_ind S in part_set V.

Lemma span_ind_comp :
 forall S S' : part_set V,
 S =' S' in _ -> span_ind S =' span_ind S' in part_set V.

End spans_eqv.

Hint Resolve span_is_span_ind span_ind_comp: algebra.

Section a_nice_fact_on_spans.

Lemma span_smallest_subspace_containing_subset :
 forall (F : field) (V : vectorspace F) (W : subspace V) (S : part_set V),
 included S W -> included (span S) W.

Lemma set_included_in_its_span :
 forall (F : field) (V : vectorspace F) (S : part_set V), included S (span S).

End a_nice_fact_on_spans.

Hint Resolve set_included_in_its_span: algebra.

Definition generates (F : field) (V : vectorspace F) 
  (S W : part_set V) := span S =' W in part_set V.

Lemma generates_comp :
 forall (F : field) (V : vectorspace F) (S S' W W' : part_set V),
 S =' S' in _ -> W =' W' in _ -> generates S W -> generates S' W'.

Lemma generated_subsets_are_subspaces :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> is_subspace W.

Lemma is_lin_comb_from_generates :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> forall x : V, in_part x W -> is_lin_comb x S.

Lemma generates_then_is_lin_comb :
 forall (F : field) (V : vectorspace F) (S W : part_set V),
 generates S W -> forall x : V, in_part x W -> is_lin_comb x S.

Lemma is_lin_comb_from_generates' :
 forall (F : field) (V : vectorspace F) (S : part_set V) (W : subspace V),
 generates S W -> forall x : W, is_lin_comb (subtype_elt x) S. *)

Definition Theorem_1_5a :
  forall (F : field) (V : vectorspace F) (S : part_set V),
  is_subspace (span S).
  exact span_is_subspace.
  Qed.

Definition Theorem_1_5b :
  forall (F : field) (V : vectorspace F) (W : subspace V) (S : part_set V),
  included S W -> included (span S) W.
  exact span_smallest_subspace_containing_subset.
  Qed.

End SECTION_1_4.

Section SECTION_1_5.

Require Export lin_dependence.
(* lin_dependence:
Set Implicit Arguments.
Unset Strict Implicit.
Section MAIN.
From Algebra Require Export Union.
Require Export subspaces.
Require Export cast_between_subsets.
Require Export mult_by_scalars.
Require Export sums.
Require Export seq_set_seq.
Require Export distinct.
Require Export const.

Section defs.
Variable F : field.
Variable V : vectorspace F.

Definition lin_dep (X : part_set V) :=
  exists n : Nat,
    (exists a : seq (S n) F,
       (exists v : seq (S n) X,
          distinct v /\
          ~ a =' const_seq (S n) (zero F) in _ /\
          sum (mult_by_scalars a (Map_embed v)) =' (zero V) in _)).

Definition lin_indep (X : part_set V) := ~ lin_dep X.

Definition lin_indep' (X : part_set V) :=
  forall (n : Nat) (a : seq (S n) F) (v : seq (S n) X),
  distinct v ->
  ~ a =' const_seq (S n) (zero F) in _ ->
  ~ sum (mult_by_scalars a (Map_embed v)) =' (zero V) in _.

Lemma lin_dep_comp :
 forall X Y : part_set V, X =' Y in _ -> lin_dep X -> lin_dep Y.

Lemma lin_indep_comp :
 forall X Y : part_set V, X =' Y in _ -> lin_indep X -> lin_indep Y.

Lemma lin_dep_defs_eqv : forall X : part_set V, lin_indep X <-> lin_indep' X.
End defs.

Section unexpected_true_results.

Lemma zero_imp_lin_dep :
 forall (F : field) (V : vectorspace F) (X : part_set V),
 in_part (zero V) X -> lin_dep X.

Lemma empty_lin_indep :
 forall (F : field) (V : vectorspace F), lin_indep (empty V).
End unexpected_true_results.

Section more.
Variable F : field.
Variable V : vectorspace F.

Lemma lin_dep_include :
 forall S1 S2 : part_set V, included S1 S2 -> lin_dep S1 -> lin_dep S2.

Lemma lin_indep_include :
 forall S1 S2 : part_set V, included S1 S2 -> lin_indep S2 -> lin_indep S1.

Lemma lin_indep_prop :
 forall (n : Nat) (a : seq n F) (v : seq n V),
 distinct v ->
 lin_indep (seq_set v) ->
 sum (mult_by_scalars a v) =' (zero V) in _ -> a =' const_seq n (zero F) in _.

Lemma lin_indep_doesn't_contain_zero :
 forall X : part_set V, lin_indep X -> ~ in_part (zero V) X.

Lemma inject_subsets_lin_dep :
 forall (W : subspace V) (X : part_set W),
 lin_dep X <-> lin_dep (inject_subsets X).
End more.

Definition max_lin_indep (F : field) (V : vectorspace F)
  (X Y : part_set V) :=
  included X Y /\
  lin_indep X /\
  (forall y : V, in_part y Y -> ~ in_part y X -> lin_dep (union X (single y))).

End MAIN. *)

Definition Theorem_1_6 :
  forall (F : field) (V : vectorspace F) (S1 S2 : part_set V),
  included S1 S2 -> lin_dep S1 -> lin_dep S2.
  exact lin_dep_include.
  Qed.

Definition Corollary_to_1_6 :
  forall (F : field) (V : vectorspace F) (S1 S2 : part_set V),
  included S1 S2 -> lin_indep S2 -> lin_indep S1.
  exact lin_indep_include.
  Qed.

End SECTION_1_5.

Section SECTION_1_6.

Require Export bases.
(* bases:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
Require Export spans.
Require Export random_facts.

Section MAIN.
Variable F : field.
Variable V : vectorspace F.

Section Defs.

Definition is_basis (X : part_set V) : Prop :=
  generates X (full V) /\ lin_indep X.

Lemma is_basis_comp :
 forall X Y : part_set V, X =' Y in _ -> is_basis X -> is_basis Y.

Record basis : Type := 
  {basis_carrier :> Predicate V; is_basis_prf : is_basis basis_carrier}.
End Defs.

Lemma basis_prop : forall (X : basis) (x : V), is_lin_comb x X.

Lemma basis_prop_strong :
 forall (n : Nat) (v : seq n V),
 is_basis (seq_set v) ->
 forall x : V, exists a : seq n F, sum (mult_by_scalars a v) =' x in _.

Section Nice_basis_properties.

Variable x : V.
Variable n : Nat.
Variable b : seq n V.
Variable Db : distinct b.
Variable Bb : is_basis (seq_set b).

Let difference_seq : forall (G : group) (a a' : seq n G), seq n G.

Lemma basis_expansion_uniqueness :
 forall a a' : seq n F,
 sum (mult_by_scalars a b) =' x in _ ->
 sum (mult_by_scalars a' b) =' x in _ -> a =' a' in _.

End Nice_basis_properties.

End MAIN. *)

Variable F : field.
Variable V : vectorspace F.
Variable x : V.
Variable n : Nat.

Variable b : seq n V.
Variable Hb : distinct b.
Variable Hb2 : is_basis (seq_set b).

Definition Theorem_1_7 :
  forall a a' : seq n F,
  sum (mult_by_scalars a b) =' x in _ ->
  sum (mult_by_scalars a' b) =' x in _ -> a =' a' in _.
  exact (basis_expansion_uniqueness Hb Hb2).
  Qed.

Require Export lin_dep_facts.
(* lin_dep_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export lin_dependence.
Require Export lin_comb_facts.
Require Export subseqs.
Require Export seq_set_facts.
Require Export distinct_facts.

Lemma rewrite_lin_comb_term :
 forall (F : field) (V : vectorspace F) (n : Nat) (a : seq (S n) F)
   (v : seq (S n) V) (i : fin (S n)),
 ~ a i =' (zero F) in _ ->
 sum (mult_by_scalars a v) =' (zero V) in _ ->
 v i =' field_inverse (a i) mX (min sum (omit (mult_by_scalars a v) i)) in _.

Lemma another_small_lemma :
 forall (V : Setoid) (W : part_set V) (x : V),
 let Wx := union W (single x) in
 forall y : Wx, ~ subtype_elt y =' x in _ -> in_part (subtype_elt y) W.

Lemma lin_dep_vs_span_lemma :
 forall (F : field) (V : vectorspace F) (s : part_set V),
 lin_indep s ->
 forall x : V,
 ~ in_part x s -> (lin_dep (union s (single x)) <-> in_part x (span s)).  

Lemma max_lin_indep_subset_generates_set :
 forall (F : field) (V : vectorspace F) (W W' : part_set V),
 max_lin_indep W' W -> forall w : W, is_lin_comb (subtype_elt w) W'.

Lemma max_lin_indep_subset_has_same_span :
 forall (F : field) (V : vectorspace F) (W W' : part_set V),
 max_lin_indep W' W -> span W =' span W' in part_set V.

Lemma seq_has_max_lin_indep_subseq :
 forall (F : field) (V : vectorspace F) (n : Nat) (v : seq n V),
 exists k : Nat,
   (exists w : seq k V,
      is_subseq w v /\ max_lin_indep (seq_set w) (seq_set v)). *)

Definition Theorem_1_8 :
  forall s : part_set V,
  lin_indep s ->
  ~ in_part x s -> (lin_dep (union s (single x)) <-> in_part x (span s)). 
  intros.
  exact (lin_dep_vs_span_lemma H H0).
  Qed.

Require Export bases_finite_dim.
(* bases_finite_dim:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases_from_generating_sets.
Require Export replacement_corollaries.

Definition is_finite_dimensional (F : field) (V : vectorspace F) :=
  exists beta : basis V, (exists n : Nat, has_n_elements n beta).

Definition is_infinite_dimensional (F : field) (V : vectorspace F) :=
  forall (beta : basis V) (n : Nat), ~ has_n_elements n beta.

Definition has_dim (F : field) (n : Nat) (V : vectorspace F) :=
  exists beta : basis V, has_n_elements n beta.

Lemma finite_dim_vecsp_has_dim :
 forall (F : field) (V : vectorspace F),
 is_finite_dimensional V -> exists n : Nat, has_dim n V.

Lemma has_dim_inj :
 forall (F : field) (V : vectorspace F) (n m : Nat),
 has_dim n V -> has_dim m V -> n =' m in _.

Lemma has_dim_easy :
 forall (F : field) (V : vectorspace F) (b : part_set V),
 is_basis b -> forall n : nat, has_n_elements n b -> has_dim n V.

Section Part_3.

Lemma dimension_bounds_generating_set_size :
 forall (F : field) (V : vectorspace F) (n : Nat),
 has_dim n V ->
 forall S : part_set V,
 generates S (full V) ->
 has_at_most_n_elements n S -> is_basis S /\ has_n_elements n S.

Lemma every_lin_indep_set_can_be_extended_to_a_basis :
 forall (F : field) (V : vectorspace F),
 is_finite_dimensional V ->
 forall (beta : basis V) (Sset : part_set V),
 lin_indep Sset ->
 exists S1 : part_set V, included S1 beta /\ is_basis (union Sset S1).

Lemma has_dim_zero_then_trivial :
 forall (F : field) (V : vectorspace F),
 has_dim 0 V -> full V =' single (zero V) in _.

End Part_3.

Record findimvecsp (F : field) : Type := 
  {the_dim : nat;
   the_vectorspace :>
    module F
    
   ;
   dim_prf : has_dim the_dim the_vectorspace}. *)

Definition Theorem_1_9 :
  forall W0 : part_set V,
  is_finite_subset W0 ->
  generates W0 (full V) ->
  exists W : part_set W0, is_basis (inject_subsets W).
  exact (every_finite_generating_set_has_a_subset_that_is_a_basis (V:=V)).
  Qed.

Require Export replacement_theorem.
(* replacement_theorem:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export has_n_elements.
Require Export bases.
Require Export lin_dep_facts.

Lemma replacement_theorem :
 forall (F : field) (V : vectorspace F) (beta : basis V) (n : Nat),
 has_n_elements n beta ->
 forall Sset : part_set V,
 lin_indep Sset ->
 forall m : Nat,
 m <= n ->
 has_n_elements m Sset ->
 exists S1 : part_set beta,
   has_n_elements (n - m) S1 /\
   generates (union Sset (inject_subsets S1)) (full V). *)

Definition Theorem_1_10 :
  forall (beta : basis V) (n : Nat),
  has_n_elements n beta ->
  forall Sset : part_set V,
  lin_indep Sset ->
  forall m : Nat,
  m <= n ->
  has_n_elements m Sset ->
  exists S1 : part_set beta,
    has_n_elements (n - m) S1 /\
    generates (union Sset (inject_subsets S1)) (full V).
  exact (replacement_theorem (V:=V)).
  Qed.

Definition Corollary_1_to_1_10 :
  forall (n : Nat) (beta : basis V),
  has_n_elements n beta ->
  forall Sset : part_set V,
  lin_indep Sset -> has_n_elements n Sset -> is_basis Sset.
  exact (finite_bases_always_equally_big (V:=V)).
  Qed.

Definition Corollary_2_to_1_10 :
  forall (n : Nat) (beta : basis V),
  has_n_elements n beta ->
  forall Sset : part_set V,
  has_at_least_n_elements (S n) Sset -> lin_dep Sset.
  exact (finite_basis_bounds_lin_indep_set_size (V:=V)).
  Qed.

Definition Corollary_2_to_1_10_conversely :
  forall (n : Nat) (beta : basis V),
  has_n_elements n beta ->
  forall Sset : part_set V, lin_indep Sset -> has_at_most_n_elements n Sset.
  exact (finite_basis_bounds_lin_indep_set_size' (V:=V)).
  Qed.

Definition Corollary_3_to_1_10 :
  forall (n : Nat) (beta : basis V),
  has_n_elements n beta -> forall Sset : basis V, has_n_elements n Sset.
  exact (all_finite_bases_equally_big (V:=V)).
  Qed.

Definition Corollary_4_to_1_10 :
  forall n : Nat,
  has_dim n V ->
  forall S : part_set V,
  generates S (full V) ->
  has_at_most_n_elements n S -> is_basis S /\ has_n_elements n S.
  exact (dimension_bounds_generating_set_size (V:=V)).
  Qed.

Definition Corollary_5_to_1_10 :
  is_finite_dimensional V ->
  forall (beta : basis V) (Sset : part_set V),
  lin_indep Sset ->
  exists S1 : part_set V, included S1 beta /\ is_basis (union Sset S1).
  exact (every_lin_indep_set_can_be_extended_to_a_basis (V:=V)).
  Qed.

Require Export subspace_dim.
(* subspace_dim:
Local Unset Standard Proposition Elimination Names.

Set Implicit Arguments.
Unset Strict Implicit.
Require Export bases_finite_dim.

Fixpoint span_ind_uninject (F : field) (V : vectorspace F) 
 (W : subspace V) (X : part_set W) (x : span_ind_formal (inject_subsets X))
 {struct x} : span_ind_formal X :=
  match x with
  | Zerovector => Zerovector _
  | Immediately c => Immediately (S:=X) (uninject_subsetsify c)
  | Plusvector x1 x2 =>
      Plusvector (span_ind_uninject x1) (span_ind_uninject x2)
  | Multvector f x1 => Multvector f (span_ind_uninject x1)
  end.

Lemma span_ind_uninject_prop :
 forall (F : field) (V : vectorspace F) (W : subspace V) 
   (X : part_set W) (x : span_ind_formal (inject_subsets X)),
 span_ind_injection x ='
 subtype_elt (span_ind_injection (span_ind_uninject x)) in _.
Unset Virtual Machine.

Section prelim.
Variable F : field.
Variable V : vectorspace F.

Lemma not_generates_then_leaves_over :
 forall S : part_set V,
 ~ generates S (full V) -> exists v : V, ~ in_part v (span_set S).

Axiom
  AC' :
    forall S : part_set V,
    (exists v : V, in_part v S) -> sigT (fun v : V => in_part v S).

Lemma ACcomplement :
 forall S : part_set V,
 (exists v : V, ~ in_part v S) -> sigT (fun v : V => ~ in_part v S).

Axiom
  dec_gen :
    forall S : part_set V, {generates S (full V)} + {~ generates S (full V)}.

Definition try_extend :
  forall (k : Nat) (v : seq k V),
  lin_indep (seq_set v) /\ distinct v ->
  sigT
    (fun i : Nat =>
     sigT (fun w : seq i V => lin_indep (seq_set w) /\ distinct w)).

Lemma extend_prop :
 forall (k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 match try_extend H with
 | existT i _ =>
     (i =' k in _ <-> span (seq_set v) =' full V in part_set V) /\
     (i =' S k in _ <-> ~ span (seq_set v) =' full V in part_set V)
 end.

Lemma extend_prop2 :
 forall (k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 match try_extend H with
 | existT i (existT w H') =>
     (i =' k in _ <-> seq_equal v w) /\
     (i =' S k in _ -> seq_equal v (Seqtl w))
 end.

Fixpoint rep_ext (n : nat) (k : Nat) (v : seq k V)
 (H : lin_indep (seq_set v) /\ distinct v) {struct n} :
 sigT
   (fun i : Nat =>
    sigT (fun w : seq i V => lin_indep (seq_set w) /\ distinct w)) :=
  match n with
  | O => existT (fun i : Nat => _) k (existT (fun w : seq k V => _) v H)
  | S m =>
      match rep_ext m H with
      | existT i (existT w H') => try_extend H'
      end
  end.

Lemma preserve_lin_indep :
 forall (n k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 match rep_ext n H with
 | existT i (existT w H') => lin_indep (seq_set w) /\ distinct w
 end.

Lemma grow_nr_elts :
 forall (n k : Nat) (v : seq k V) (H : lin_indep (seq_set v) /\ distinct v),
 has_n_elements k (seq_set v) ->
 match rep_ext n H with
 | existT i (existT w H') => has_n_elements i (seq_set w)
 end.
End prelim.

Section MAIN.
Variable F : field.
Variable V : findimvecsp F.

Variable W : subspace V.

Let H : lin_indep (seq_set (empty_seq W)) /\ distinct (empty_seq W).

Lemma grow_bound :
 forall n : nat,
 match rep_ext n H with
 | existT i (existT w H') => i <= n
 end.

Let n := the_dim V.

Lemma subspace_preserves_findimvecsp : sigT (fun m => m <= n /\ has_dim m W).
End MAIN. *)
Definition Theorem_1_11 :
  forall (V : findimvecsp F) (W : subspace V),
  sigT (fun m => m <= the_dim V /\ has_dim m W).
  exact (subspace_preserves_findimvecsp (F:=F)).
  Qed.
End SECTION_1_6.

Section SECTION_1_7.
Require Export maxlinindepsubsets.
(* maxlinindepsubsets:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export bases.
Require Export lin_dep_facts.

Section defs.
Variable X : Setoid.

Definition maximal (F : part_set (part_set X)) (A : part_set X) :=
  in_part A F /\
  ~ (exists B : part_set X, in_part B F /\ included A B /\ ~ A =' B in _).

Definition is_chain (F : part_set (part_set X)) :=
  forall A B : part_set X,
  in_part A F -> in_part B F -> included A B \/ included B A.

Axiom
  MAXIMAL_PRINCIPLE :
    forall F : part_set (part_set X),
    (forall C : part_set (part_set X),
     is_chain C ->
     included C F ->
     exists A : part_set X,
       in_part A F /\ (forall B : part_set X, in_part B C -> included B A)) ->
    exists A : part_set X, maximal F A.
End defs.

Lemma max_lin_indep_subsets_of_generating_sets_are_bases :
 forall (F : field) (V : vectorspace F) (W : part_set V),
 generates W (full V) ->
 forall beta : part_set V, max_lin_indep beta W -> is_basis beta.

Lemma basis_iff_max_lin_indep :
 forall (F : field) (V : vectorspace F) (beta : part_set V),
 is_basis beta <-> max_lin_indep beta (full V).

Lemma basis_is_max_lin_indep :
 forall (F : field) (V : vectorspace F) (beta : basis V),
 max_lin_indep beta (full V).

Lemma max_lin_indep_subset_generated :
 forall (F : field) (V : vectorspace F) (W : part_set V),
 lin_indep W ->
 exists W' : part_set V, max_lin_indep W' (full V) /\ included W W'.

Lemma every_vecsp_has_a_basis :
 forall (F : field) (V : vectorspace F),
 exists beta : part_set V, is_basis beta. *)

Require Export maxlinindepsubsets.
(* maxlinindepsubsets:
Set Implicit Arguments.
Unset Strict Implicit.

Require Export bases.
Require Export lin_dep_facts.

Section defs.
Variable X : Setoid.

Definition maximal (F : part_set (part_set X)) (A : part_set X) :=
  in_part A F /\
  ~ (exists B : part_set X, in_part B F /\ included A B /\ ~ A =' B in _).

Definition is_chain (F : part_set (part_set X)) :=
  forall A B : part_set X,
  in_part A F -> in_part B F -> included A B \/ included B A.

Axiom
  MAXIMAL_PRINCIPLE :
    forall F : part_set (part_set X),
    (forall C : part_set (part_set X),
     is_chain C ->
     included C F ->
     exists A : part_set X,
       in_part A F /\ (forall B : part_set X, in_part B C -> included B A)) ->
    exists A : part_set X, maximal F A.
End defs.

Lemma max_lin_indep_subsets_of_generating_sets_are_bases :
 forall (F : field) (V : vectorspace F) (W : part_set V),
 generates W (full V) ->
 forall beta : part_set V, max_lin_indep beta W -> is_basis beta.

Lemma basis_iff_max_lin_indep :
 forall (F : field) (V : vectorspace F) (beta : part_set V),
 is_basis beta <-> max_lin_indep beta (full V).

Lemma basis_is_max_lin_indep :
 forall (F : field) (V : vectorspace F) (beta : basis V),
 max_lin_indep beta (full V).

Lemma max_lin_indep_subset_generated :
 forall (F : field) (V : vectorspace F) (W : part_set V),
 lin_indep W ->
 exists W' : part_set V, max_lin_indep W' (full V) /\ included W W'.

Lemma every_vecsp_has_a_basis :
 forall (F : field) (V : vectorspace F),
 exists beta : part_set V, is_basis beta. *)
Definition Theorem_1_12 :
  forall (F : field) (V : vectorspace F) (W : part_set V),
  generates W (full V) ->
  forall beta : part_set V, max_lin_indep beta W -> is_basis beta.
  exact max_lin_indep_subsets_of_generating_sets_are_bases.
  Qed.

Definition Corollary_to_1_12 :
  forall (F : field) (V : vectorspace F) (beta : part_set V),
  is_basis beta <-> max_lin_indep beta (full V).
  exact basis_iff_max_lin_indep.
  Qed.

Definition Theorem_1_13 :
  forall (F : field) (V : vectorspace F) (W : part_set V),
  lin_indep W ->
  exists W' : part_set V, max_lin_indep W' (full V) /\ included W W'.
  exact max_lin_indep_subset_generated.
  Qed.

Definition Corollary_to_1_13 :
  forall (F : field) (V : vectorspace F),
  exists beta : part_set V, is_basis beta.
  exact every_vecsp_has_a_basis.
  Qed.

End SECTION_1_7.