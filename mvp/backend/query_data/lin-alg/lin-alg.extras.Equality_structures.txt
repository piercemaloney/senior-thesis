
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_equality_facts.
(* seq_equality_facts:
Set Implicit Arguments.
Unset Strict Implicit. 
Require Export seq_equality.
Require Export concat_facts.
Require Export omit.
Require Export Classical_Prop.

Lemma seq_equal_length_equal :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A),
 seq_equal v w -> n =' m in _.

Hint Resolve seq_equal_length_equal: algebra.

Lemma seq_equal_equal_elements :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A),
 seq_equal v w ->
 forall (i : fin n) (j : fin m), index i = index j -> v i =' w j in _.

Hint Resolve seq_equal_equal_elements: algebra.

Lemma seq_equal_head :
 forall (A : Setoid) (n m : Nat) (v : seq (S n) A) (w : seq (S m) A),
 seq_equal v w -> head v =' head w in _.

Hint Resolve seq_equal_head: algebra.

Lemma seq_equal_seqtl :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A),
 seq_equal v w -> seq_equal (Seqtl v) (Seqtl w).

Hint Resolve seq_equal_seqtl: algebra.

Lemma seq_equal_cons :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A) (a b : A),
 seq_equal v w -> a =' b in _ -> seq_equal (a;; v) (b;; w).

Hint Resolve seq_equal_cons: algebra.

Lemma seq_equal_concat :
 forall (A : Setoid) (n m p q : Nat) (v : seq n A) 
   (w : seq m A) (a : seq p A) (b : seq q A),
 seq_equal v w -> seq_equal a b -> seq_equal (v ++ a) (w ++ b).

Hint Resolve seq_equal_concat: algebra.

Lemma seq_equal_seq_set :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A),
 seq_equal v w -> seq_set v =' seq_set w in _.

Lemma seq_equal_omit :
 forall (A : Setoid) (n m : Nat) (v : seq n A) (w : seq m A) 
   (i : fin n) (j : fin m),
 index i = index j -> seq_equal v w -> seq_equal (omit v i) (omit w j). *)

Section defs.
Variable A : Setoid.
Variable I : A -> Setoid.
Definition StrEqType := forall a b : A, I a -> I b -> Prop.
Record EqStructure : Type := 
  {StrEq :> forall a b : A, I a -> I b -> Prop;
   StrEqRefl : forall (a : A) (x : I a), StrEq x x;
   StrEqSym :
    forall (a b : A) (x : I a) (y : I b), StrEq x y -> StrEq y x;
   StrEqTrans :
    forall (a b c : A) (x : I a) (y : I b) (z : I c),
    StrEq x y -> StrEq y z -> StrEq x z;
   StrEqRestr : forall (a : A) (x y : I a), StrEq x y -> x =' y in I a;
   StrEqExtend : forall (a : A) (x y : I a), x =' y in I a -> StrEq x y;
   StrEqIndex :
    forall (a b : A) (x : I a) (y : I b), StrEq x y -> a =' b in A}.
End defs.

Definition seq_eq_str (A : Setoid) : EqStructure (fun n : Nat => seq n A).
apply
 (Build_EqStructure (I:=fun n : Nat => seq n A)
    (StrEq:=fun (n m : Nat) (v : seq n A) (w : seq m A) => seq_equal v w));
 auto with algebra.
intros.
apply seq_equal_trans with (w := y); auto with algebra.
2: intros.
2: simpl in |- *.
2: apply seq_equal_length_equal with (v := x) (w := y); auto with algebra.
simpl in |- *.
intros; red in H; red in |- *; simpl in H; simpl in |- *.
intros.
elim (le_or_lt a i).
right.
auto.
left.
exists H0; exists H0.
auto.
Defined.

Definition fin_eq_str : EqStructure (fun n : Nat => fin n).
apply
 (Build_EqStructure (I:=fun n : Nat => fin n)
    (StrEq:=fun n m (i : fin n) (j : fin m) => n = m /\ index i = index j));
 auto with algebra.
intros.
intuition.
intuition.
transitivity b; auto.
transitivity (index y); auto.
intros.
simpl in |- *.
inversion_clear H.
auto.
intros.
simpl in |- *.
inversion_clear H.
rewrite H0.
auto.
Defined.

Definition fin_eq := StrEq fin_eq_str.

Lemma test1 : forall (n : nat) (i : fin n), fin_eq i i.
intros.
red in |- *.
simpl in |- *.
split; auto.
Qed.

Definition seq_eq (A : Setoid) := StrEq (seq_eq_str A).

Lemma test2 :
 forall (A : Setoid) (n m : nat) (v : seq n A) (w : seq m A),
 seq_eq v w -> seq_eq w v.
intros.
red in |- *.
simpl in |- *.
red in H; simpl in H.
auto with algebra.
Qed.

