
Set Implicit Arguments.
Unset Strict Implicit.
Require Export distinct.
(* distinct:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export finite.
From Algebra Require Export Parts.

Definition distinct (A : Setoid) (n : Nat) (v : seq n A) :=
  forall i j : fin n, ~ i =' j in _ -> ~ v i =' v j in _.

Lemma distinct_comp :
 forall (A : Setoid) (n : Nat) (v v' : seq n A),
 distinct v -> v =' v' in _ -> distinct v'.

Hint Resolve distinct_comp: algebra.

Definition distinct_pred (A : Setoid) (n : Nat) : Predicate (seq n A). *)
Require Export distribution_lemmas.
(* distribution_lemmas:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export mult_by_scalars.
Require Export const.
Require Export sums.

Lemma RING_sum_mult_dist_l :
 forall (R : ring) (n : Nat) (r : R) (a : seq n R),
 r rX sum a =' sum (pointwise (uncurry (RING_comp (R:=R))) (const_seq n r) a)
 in _.

Lemma MODULE_sum_mult_dist_l :
 forall (R : ring) (M : module R) (n : Nat) (r : R) (a : seq n M),
 r mX sum a =' sum (mult_by_scalars (const_seq n r) a) in _.

Hint Resolve RING_sum_mult_dist_l MODULE_sum_mult_dist_l: algebra.

Lemma pointwise_module_assoc :
 forall (R : ring) (M : module R) (n : Nat) (r r' : seq n R) (m : seq n M),
 let rmult := uncurry (RING_comp (R:=R)) in
 mult_by_scalars r (mult_by_scalars r' m) ='
 mult_by_scalars (pointwise rmult r r') m in _.

Hint Resolve pointwise_module_assoc: algebra. *)
Require Export sums2.
(* sums2:
Set Implicit Arguments.
Unset Strict Implicit.
From Algebra Require Export Abelian_group_facts.
Require Export sums.
Require Export omit.
Require Export modify_seq.
Require Export const.

Lemma sum_omit_zeros :
 forall (M : monoid) (n : Nat) (v : seq n M) (i : fin n),
 v i =' (zero M) in _ -> sum v =' sum (omit v i) in _.

Lemma sum_modify :
 forall (AG : abelian_group) (n : Nat) (v : seq n AG) (i : fin n) (a : AG),
 sum (modify_seq v i a) =' sum v +' (min v i) +' a in _.

Lemma sum_of_zeros :
 forall (M : monoid) (n : Nat) (v : seq n M),
 v =' const_seq n (zero M) in _ -> sum v =' (zero M) in _.

Hint Resolve sum_omit_zeros sum_modify sum_of_zeros: algebra. *)
Require Export omit_facts.
(* omit_facts:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export seq_equality_facts.
Require Export sums.
Require Export mult_by_scalars.

Lemma omit_head_is_seqtl :
 forall (n : Nat) (M : Setoid) (s : seq n M) (H0 : 0 < n),
 omit s (Build_finiteT H0) =' Seqtl s in _.

Hint Resolve omit_head_is_seqtl: algebra.

Lemma omit_tlelt :
 forall (n : Nat) (A : Setoid) (v : seq (S (S n)) A) 
   (m : Nat) (HS : S m < S (S n)) (H : m < S n),
 omit v (Build_finiteT HS) =' head v;; omit (Seqtl v) (Build_finiteT H) in _.

Hint Resolve omit_tlelt: algebra.

Lemma omit_tlelt' :
 forall (n : Nat) (A : Setoid) (v : seq (S n) A) (m : Nat) 
   (HS : S m < S n) (H : m < n) (Heq : S (pred n) = n),
 omit v (Build_finiteT HS) ='
 cast_seq (head v;; omit (Seqtl v) (Build_finiteT H)) Heq in _.

Hint Resolve omit_tlelt': algebra.

Lemma omit_tlelt'' :
 forall (n : Nat) (A : Setoid) (v : seq (S n) A) (m : Nat) 
   (HS : S m < S n) (H : m < n) (Heq : S (pred n) = n),
 seq_equal (omit v (Build_finiteT HS))
   (head v;; omit (Seqtl v) (Build_finiteT H)).

Hint Resolve omit_tlelt'': algebra.

Lemma omit_concat_first_part :
 forall (n m : Nat) (A : Setoid) (v : seq (S n) A) 
   (w : seq m A) (i : Nat) (Hi : i < S n) (Hi' : i < S n + m),
 omit (v ++ w) (Build_finiteT Hi') =' omit v (Build_finiteT Hi) ++ w in _.

Hint Resolve omit_concat_first_part: algebra.

Lemma omit_concat_second_part' :
 forall (n m : Nat) (A : Setoid) (v : seq n A) (w : seq m A) 
   (i : Nat) (Hi : i < m) (Hi' : n + i < n + m)
   (H : n + pred m = pred (n + m)),
 seq_equal (omit (v ++ w) (Build_finiteT Hi'))
   (v ++ omit w (Build_finiteT Hi)).

Lemma omit_concat_second_part :
 forall (n m : Nat) (A : Setoid) (v : seq n A) (w : seq m A) 
   (i : Nat) (Hi : i < m) (Hi' : n + i < n + m)
   (H : n + pred m = pred (n + m)),
 omit (v ++ w) (Build_finiteT Hi') ='
 cast_seq (v ++ omit w (Build_finiteT Hi)) H in _.

Lemma omit_seq_in_seq_set :
 forall (n : Nat) (A : Setoid) (v : seq n A) (i : fin n) (j : fin (pred n)),
 in_part (omit v i j) (seq_set v).

Lemma seqsum_is_elt_plus_omitseq :
 forall (n : Nat) (M : abelian_monoid) (s : seq n M) (i : fin n),
 sum s =' s i +' sum (omit s i) in _.

Lemma seqsum_min_elt_is_omitseq :
 forall (n : Nat) (AG : abelian_group) (s : seq n AG) (i : fin n),
 sum s +' (min s i) =' sum (omit s i) in _.

Hint Resolve omit_head_is_seqtl omit_tlelt seqsum_is_elt_plus_omitseq
  seqsum_min_elt_is_omitseq: algebra.

Lemma omit_mult_by_scalars :
 forall (n : Nat) (F : ring) (V : module F) (a : seq n F) 
   (v : seq n V) (i : fin n),
 omit (mult_by_scalars a v) i =' mult_by_scalars (omit a i) (omit v i) in _.

Hint Resolve omit_mult_by_scalars: algebra.

Lemma omit_Map_embed :
 forall (n : Nat) (F : ring) (V : module F) (s : part_set V) 
   (v : seq n s) (i : fin n),
 omit (Map_embed v) i =' Map_embed (omit v i) in _.
Hint Resolve omit_Map_embed: algebra. *)
Require Export cast_between_subsets.
(* cast_between_subsets:
Set Implicit Arguments.
Unset Strict Implicit.
Require Export Map_embed.
Require Export algebra_omissions.

Definition map_between_equal_subsets :
  forall (A : Setoid) (X Y : part_set A), X =' Y in _ -> X -> Y.

Lemma subtype_elt_eats_map_between_equal_subsets :
 forall (A : Setoid) (X Y : part_set A) (H : X =' Y in _) (x : X),
 subtype_elt (map_between_equal_subsets H x) =' subtype_elt x in _.

Hint Resolve subtype_elt_eats_map_between_equal_subsets: algebra.

Lemma map_between_equal_subsets_inj :
 forall (A : Setoid) (X Y : part_set A) (H H' : X =' Y in _) (x x' : X),
 map_between_equal_subsets H x =' map_between_equal_subsets H' x' in _ ->
 x =' x' in _.

Definition Map_to_equal_subsets :
  forall (A B : Setoid) (X Y : part_set A), X =' Y in _ -> MAP B X -> MAP B Y.

Lemma subtype_elt_eats_Map_to_equal_subsets :
 forall (A B : Setoid) (X Y : part_set A) (H : X =' Y in _) 
   (b : B) (M : Map B X),
 subtype_elt (Map_to_equal_subsets H M b) =' subtype_elt (M b) in _.

Hint Resolve subtype_elt_eats_Map_to_equal_subsets: algebra.

Lemma Map_embed_eats_Map_to_equal_subsets :
 forall (A B : Setoid) (X Y : part_set A) (H : X =' Y in _) (M : Map B X),
 Map_embed (Map_to_equal_subsets H M) =' Map_embed M in _.

Hint Resolve Map_embed_eats_Map_to_equal_subsets: algebra.

Lemma Map_to_equal_subsets_inj :
 forall (A B : Setoid) (X Y : part_set A) (H H' : X =' Y in _)
   (f g : Map B X),
 Map_to_equal_subsets H f =' Map_to_equal_subsets H' g in _ ->
 f =' g in MAP _ _.

Definition cast_to_subset_fun :
  forall (A B : Setoid) (v : MAP B A) (W : part_set A),
  (forall i : B, in_part (v i) W) -> (B -> W:Type).

Lemma cast_doesn't_change :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W) (i : B),
 subtype_elt (cast_to_subset_fun H i) =' v i in _.

Hint Resolve cast_doesn't_change: algebra.

Definition cast_map_to_subset :
  forall (A B : Setoid) (v : MAP B A) (W : part_set A),
  (forall i : B, in_part (v i) W) -> MAP B W.

Lemma cast_map_to_subset_doesn't_change :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W) (i : B),
 subtype_elt (cast_map_to_subset H i) =' v i in _.

Hint Resolve cast_map_to_subset_doesn't_change: algebra.

Lemma Map_embed_cast_map_to_subset_inv :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W),
 Map_embed (cast_map_to_subset H) =' v in _.

Hint Resolve Map_embed_cast_map_to_subset_inv: algebra.

Lemma Map_embed_eats_cast_map_to_subset :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B)
   (H : forall i : D, in_part (Map_embed v i) C),
 Map_embed (cast_map_to_subset H) =' Map_embed v in _.

Hint Resolve Map_embed_eats_cast_map_to_subset: algebra.

Lemma seq_castable :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A),
 (forall i : B, in_part (v i) W) -> exists w : MAP B W, Map_embed w =' v in _.

Hint Resolve seq_castable: algebra.

Lemma subset_seq_castable :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B)
   (H : forall i : D, in_part (Map_embed v i) C),
 exists w : MAP D C, Map_embed w =' Map_embed v in _.

Hint Resolve subset_seq_castable: algebra.

Lemma cast_seq_nice :
 forall (A B : Setoid) (v : MAP B A) (W : part_set A)
   (H : forall i : B, in_part (v i) W) (P : Predicate (MAP B A)),
 Pred_fun P v -> Pred_fun P (Map_embed (cast_map_to_subset H)).

Hint Resolve cast_seq_nice: algebra.

Lemma cast_subset_seq_nice :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B)
   (H : forall i : D, in_part (Map_embed v i) C) (P : Predicate (MAP D A)),
 Pred_fun P (Map_embed v) -> Pred_fun P (Map_embed (cast_map_to_subset H)).

Hint Resolve cast_subset_seq_nice: algebra.

Lemma cast_respects_predicates_per_elt :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B) 
   (P : Predicate A) (H : forall i : D, in_part (Map_embed v i) C) 
   (i : D),
 Pred_fun P (Map_embed v i) ->
 Pred_fun P (Map_embed (cast_map_to_subset H) i).

Lemma cast_respects_all_elt_predicates :
 forall (A D : Setoid) (B C : part_set A) (v : MAP D B) 
   (P : Predicate A) (H : forall i : D, in_part (Map_embed v i) C),
 (forall i : D, Pred_fun P (Map_embed v i)) ->
 forall j : D, Pred_fun P (Map_embed (cast_map_to_subset H) j).

Hint Resolve cast_respects_predicates_per_elt
  cast_respects_all_elt_predicates: algebra.

Definition Map_include :
  forall (A D : Setoid) (B C : part_set A),
  included B C -> MAP D B -> MAP D C.

Definition Map_include_map :
  forall (A D : Setoid) (B C : part_set A),
  included B C -> MAP (MAP D B) (MAP D C). *)

Section lin_dep_def.

Definition is_lin_comb (F : field) (V : vectorspace F) 
  (x : V) (S : part_set V) :=
  exists n : Nat,
    (exists a : seq n F,
       (exists v : seq n S, x =' sum (mult_by_scalars a (Map_embed v)) in _)).

Lemma is_lin_comb_comp :
 forall (F : field) (V : vectorspace F) (x y : V) (S T : part_set V),
 S =' T in _ -> x =' y in _ -> is_lin_comb x S -> is_lin_comb y T.
intros.
assert (is_lin_comb x T).
red in |- *; red in H1.
inversion_clear H1.
exists x0.
inversion_clear H2.
exists x1.
inversion_clear H1.
exists (Map_to_equal_subsets H x2).
apply Trans with (sum (mult_by_scalars x1 (Map_embed x2))); auto with algebra.
red in |- *.
red in H2.
inversion H2.
inversion H3.
inversion H4.
exists x0.
exists x1.
exists x2.
apply Trans with x; auto with algebra.
Qed.

Hint Resolve is_lin_comb_comp: algebra.

Definition is_lin_comb_pred :
  forall (F : field) (V : vectorspace F), part_set V -> Predicate V.
intros.
apply (Build_Predicate (Pred_fun:=fun x : V => is_lin_comb x X)).
red in |- *.
intros.
apply is_lin_comb_comp with x X; auto with algebra.
Defined.
End lin_dep_def.

Section condensing.

Lemma lin_comb_with_distinct_vectors :
 forall (F : field) (V : vectorspace F) (x : V) (B : part_set V),
 is_lin_comb x B ->
 exists n : Nat,
   (exists a : seq n F,
      (exists v : seq n B,
         x =' sum (mult_by_scalars a (Map_embed v)) in _ /\ distinct v)).
intros.
red in H.
inversion_clear H.
generalize x0 H0; clear H0 x0.
intro n; induction  n as [| n Hrecn].
intros.
inversion_clear H0.
inversion_clear H.
exists 0.
exists x0.
exists x1.
split.
auto.
red in |- *.
intros.
apply False_ind; auto with algebra.
intros.
inversion_clear H0.
inversion_clear H.
assert (distinct x1 \/ ~ distinct x1).
apply classic.
case H.
intro.
exists (S n).
exists x0; exists x1; split; auto.
intro.
unfold distinct in H1.
assert
 (exists i : fin (S n),
    (exists j : fin (S n), ~ i =' j in _ /\ x1 i =' x1 j in _)).
apply NNPP.
red in |- *.
red in H1.
intros; apply H1.
intros.
red in |- *; red in H2.
intro; apply H2.
exists i; exists j; auto.
inversion_clear H2; inversion_clear H3.
inversion_clear H2.
apply Hrecn.
exists (omit (modify_seq x0 x2 (x0 x2 +' x0 x3)) x3).
exists (omit x1 x3).
apply
 Trans
  with
    (sum
       (mult_by_scalars (omit (modify_seq x0 x2 (x0 x2 +' x0 x3)) x3)
          (omit (Map_embed x1) x3))).
apply
 Trans
  with
    (sum
       (omit
          (mult_by_scalars (modify_seq x0 x2 (x0 x2 +' x0 x3)) (Map_embed x1))
          x3)); auto with algebra.
apply
 Trans
  with
    (sum (mult_by_scalars (modify_seq x0 x2 (x0 x2 +' x0 x3)) (Map_embed x1)) +'
     (min mult_by_scalars (modify_seq x0 x2 (x0 x2 +' x0 x3)) 
            (Map_embed x1) x3)); auto with algebra.
apply
 Trans
  with
    (sum (mult_by_scalars (modify_seq x0 x2 (x0 x2 +' x0 x3)) (Map_embed x1)) +'
     (min x0 x3 mX Map_embed x1 x3)).
apply
 Trans
  with
    (sum
       (modify_seq (mult_by_scalars x0 (Map_embed x1)) x2
          ((x0 x2 +' x0 x3) mX Map_embed x1 x2)) +'
     (min x0 x3 mX Map_embed x1 x3)); auto with algebra.

apply
 Trans
  with
    (sum (mult_by_scalars x0 (Map_embed x1)) +'
     (min mult_by_scalars x0 (Map_embed x1) x2) +'
     (x0 x2 +' x0 x3) mX Map_embed x1 x2 +' (min x0 x3 mX Map_embed x1 x3));
 auto with algebra.

apply
 Trans
  with
    (sum (mult_by_scalars x0 (Map_embed x1)) +'
     ((min mult_by_scalars x0 (Map_embed x1) x2) +'
      (x0 x2 +' x0 x3) mX Map_embed x1 x2 +' (min x0 x3 mX Map_embed x1 x3))).
2: apply
    Trans
     with
       (sum (mult_by_scalars x0 (Map_embed x1)) +'
        ((min mult_by_scalars x0 (Map_embed x1) x2) +'
         (x0 x2 +' x0 x3) mX Map_embed x1 x2) +'
        (min x0 x3 mX Map_embed x1 x3)); auto with algebra.

apply Trans with (sum (mult_by_scalars x0 (Map_embed x1))); auto with algebra.
apply Trans with (sum (mult_by_scalars x0 (Map_embed x1)) +' (zero V));
 auto with algebra.
apply SGROUP_comp; auto with algebra.
unfold mult_by_scalars in |- *.
simpl in |- *.
apply GROUP_reg_right with (x0 x3 mX subtype_elt (x1 x3)).
apply Trans with (x0 x3 mX subtype_elt (x1 x3)); auto with algebra.
apply
 Trans
  with
    ((min x0 x2 mX subtype_elt (x1 x2)) +'
     (x0 x2 +' x0 x3) mX subtype_elt (x1 x2) +'
     ((min x0 x3 mX subtype_elt (x1 x3)) +' x0 x3 mX subtype_elt (x1 x3)));
 auto with algebra.
apply
 Trans
  with
    ((min x0 x2 mX subtype_elt (x1 x2)) +'
     (x0 x2 +' x0 x3) mX subtype_elt (x1 x2) +' (zero V)); 
 auto with algebra.
apply
 Trans
  with
    ((min x0 x2 mX subtype_elt (x1 x2)) +'
     (x0 x2 +' x0 x3) mX subtype_elt (x1 x2)); auto with algebra.

apply Trans with (x0 x3 mX subtype_elt (x1 x2)); auto with algebra.
apply
 Trans
  with
    ((min x0 x2) mX subtype_elt (x1 x2) +'
     (x0 x2 +' x0 x3) mX subtype_elt (x1 x2)); auto with algebra.
apply Trans with (((min x0 x2) +' (x0 x2 +' x0 x3)) mX subtype_elt (x1 x2));
 auto with algebra.
apply MODULE_comp; auto with algebra.
apply Trans with ((min x0 x2) +' x0 x2 +' x0 x3); auto with algebra.
apply Trans with ((zero F) +' x0 x3); auto with algebra.

apply SGROUP_comp; auto with algebra.
apply GROUP_comp; auto with algebra.
unfold mult_by_scalars in |- *.
apply Trans with (modify_seq x0 x2 (x0 x2 +' x0 x3) x3 mX Map_embed x1 x3);
 auto with algebra.
apply MODULE_comp; auto with algebra.
apply Sym.
apply modify_seq_modifies_one_elt; auto with algebra.

unfold mult_by_scalars in |- *.
apply sum_comp.
apply toMap.
apply pointwise_comp; auto with algebra.
change (omit (Map_embed x1) x3 =' Map_embed (omit x1 x3) in _) in |- *.
apply omit_Map_embed.
Qed.

Lemma lin_comb_condensed :
 forall (F : field) (V : vectorspace F) (B : part_set V) 
   (n : Nat) (b : seq n V),
 B =' seq_set b in _ ->
 forall x : V,
 is_lin_comb x B -> exists a : seq n F, x =' sum (mult_by_scalars a b) in _.
intros.
red in H0.
inversion_clear H0.
generalize x H1; clear H1 x.
induction x0.
intros.
exists (const_seq n (zero F)).
inversion_clear H1.
inversion_clear H0.
simpl in H1.
apply Trans with (zero V); auto with algebra.
apply Trans with (sum (const_seq n (zero V))); auto with algebra.
apply Sym.
apply sum_of_zeros; auto with algebra.
unfold const_seq in |- *.
apply sum_comp.
intro; simpl in |- *; auto with algebra.

intros.
inversion_clear H1.
inversion_clear H0.
assert (exists i : fin n, B (head x2) =' b i in _).
simpl in H.
red in H.
simpl in H.
generalize (H (B (head x2))); intros (p, q).
apply p; auto with algebra.
apply in_part_comp_l with (subtype_elt (head x2)); auto with algebra.
inversion_clear H0.
assert
 (x ='
  head x1 mX B (head x2) +'
  sum (mult_by_scalars (Seqtl x1) (Map_embed (Seqtl x2))) in _).
apply Trans with (sum (mult_by_scalars x1 (Map_embed x2))); auto with algebra.
apply Trans with (sum (mult_by_scalars (hdtl x1) (Map_embed (hdtl x2)))).
unfold hdtl, mult_by_scalars in |- *.
apply sum_comp.
unfold head in |- *.
apply toMap.
apply pointwise_comp; auto with algebra.
unfold hdtl in |- *.
apply
 Trans
  with
    (sum
       (uncurry (MODULE_comp (Mod:=V)) (couple (head x1) (B (head x2)));;
        mult_by_scalars (Seqtl x1) (Map_embed (Seqtl x2))));
 auto with algebra.

assert
 (exists a : seq x0 F,
    (exists v : seq x0 B,
       x +' (min head x1 mX B (head x2)) ='
       sum (mult_by_scalars a (Map_embed v)) in _)).
exists (Seqtl x1).
exists (Seqtl x2).
apply
 Trans
  with
    (head x1 mX B (head x2) +'
     sum (mult_by_scalars (Seqtl x1) (Map_embed (Seqtl x2))) +'
     (min head x1 mX B (head x2))); auto with algebra.
apply
 Trans
  with
    (sum (mult_by_scalars (Seqtl x1) (Map_embed (Seqtl x2))) +'
     head x1 mX B (head x2) +' (min head x1 mX B (head x2)));
 auto with algebra.
apply
 Trans
  with
    (sum (mult_by_scalars (Seqtl x1) (Map_embed (Seqtl x2))) +'
     (head x1 mX B (head x2) +' (min head x1 mX B (head x2))));
 auto with algebra.
apply
 Trans
  with (sum (mult_by_scalars (Seqtl x1) (Map_embed (Seqtl x2))) +' (zero V));
 auto with algebra.
generalize (IHx0 _ H3).
intro.
inversion_clear H4.
exists (modify_seq x4 x3 (x4 x3 +' head x1)).
apply
 Trans
  with
    (sum (modify_seq (mult_by_scalars x4 b) x3 ((x4 x3 +' head x1) mX b x3)));
 auto with algebra.
apply
 Trans
  with
    (sum (mult_by_scalars x4 b) +' (min mult_by_scalars x4 b x3) +'
     (x4 x3 +' head x1) mX b x3).
2: apply Sym; auto with algebra.

apply
 Trans
  with
    (x +' (min head x1 mX B (head x2)) +' (min mult_by_scalars x4 b x3) +'
     (x4 x3 +' head x1) mX b x3); auto with algebra.
unfold mult_by_scalars in |- *.
simpl in |- *.
apply
 Trans
  with
    (x +' (min head x1 mX subtype_elt (head x2)) +' (min x4 x3 mX b x3) +'
     (x4 x3 mX b x3 +' head x1 mX b x3)); auto with algebra.
apply
 Trans
  with
    (x +' (min head x1 mX subtype_elt (head x2)) +'
     ((min x4 x3 mX b x3) +' (x4 x3 mX b x3 +' head x1 mX b x3)));
 auto with algebra.
apply
 Trans
  with
    (x +' (min head x1 mX subtype_elt (head x2)) +'
     ((min x4 x3 mX b x3) +' x4 x3 mX b x3 +' head x1 mX b x3));
 auto with algebra.
apply
 Trans
  with
    (x +' (min head x1 mX subtype_elt (head x2)) +'
     ((zero V) +' head x1 mX b x3)); auto with algebra.
apply
 Trans with (x +' (min head x1 mX subtype_elt (head x2)) +' head x1 mX b x3);
 auto with algebra.
apply
 Trans
  with
    (x +' (min head x1 mX subtype_elt (head x2)) +'
     head x1 mX subtype_elt (head x2)); auto with algebra.
apply
 Trans
  with
    (x +'
     ((min head x1 mX subtype_elt (head x2)) +'
      head x1 mX subtype_elt (head x2))); auto with algebra.
apply Trans with (x +' (zero V)); auto with algebra.
Qed.

End condensing.
