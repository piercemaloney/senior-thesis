Require Export RelDefinitions.
(* RelDefinitions:
Require Export Coq.Program.Basics.
Require Export Coq.Relations.Relation_Definitions.
Require Export Coq.Classes.Morphisms.
Require Setoid.
Require Export Delay.

Class NotEvar {A} (x: A).

Hint Extern 1 (NotEvar ?x) =>
  not_evar x; constructor : typeclass_instances.

Class Unconvertible {A B} (a: A) (b: B) := unconvertible : unit.

Ltac unconvertible a b :=
  first
    [ unify a b with typeclass_instances; fail 1
    | exact tt ].

Hint Extern 1 (Unconvertible ?a ?b) =>
  unconvertible a b : typeclass_instances.

Class Convertible {A} (x y: A) :=
  convertible: x = y.

Hint Extern 1 (Convertible ?x ?y) =>
  eapply eq_refl : typeclass_instances.

Class Once P := once : P.

Hint Extern 1 (Once ?P) =>
  red; once typeclasses eauto : typeclass_instances.

Definition rel (A1 A2: Type) := A1 -> A2 -> Prop.

Delimit Scope rel_scope with rel.
Bind Scope rel_scope with rel.

Bind Scope rel_scope with Relation_Definitions.relation.

Class RStep (P Q: Prop) :=
  rstep: P -> Q.

Ltac rstep :=
  lazymatch goal with
    | |- ?Q =>
      apply (rstep (Q := Q));
      Delay.split_conjunction
  end.

Class RAuto (Q: Prop) :=
  rauto : Q.

Ltac rauto :=
  lazymatch goal with
    | |- ?Q =>
      apply (rauto (Q := Q));
      Delay.split_conjunction
  end.

Class RAutoSubgoals (P: Prop) :=
  rauto_subgoals : P.

Global Instance rauto_rstep P Q:
  Once (RStep P Q) ->
  RAutoSubgoals P ->
  RAuto Q.

Ltac rauto_split :=
  red;
  Delay.split_conjunction;
  lazymatch goal with
    | |- ?Q => change (RAuto Q)
  end.

Hint Extern 1 (RAutoSubgoals _) =>
  rauto_split : typeclass_instances.

Hint Extern 1000 (RAuto _) =>
  red; solve [ delay ] : typeclass_instances.

Class RIntro {A B} (P: Prop) (R: rel A B) (m: A) (n: B): Prop :=
  rintro: P -> R m n.

Arguments RIntro {A%type B%type} P%type R%rel m n.

Ltac rintro :=
  lazymatch goal with
    | |- ?R ?m ?n =>
      apply (rintro (R:=R) (m:=m) (n:=n));
      Delay.split_conjunction
  end.

Global Instance rintro_rstep:
  forall `(RIntro), RStep P (R m n) | 10.

Class RExists {A B} (P: Prop) (R: rel A B) (m: A) (n: B): Prop :=
  rexists: P -> R m n.

Arguments RExists {A%type B%type} P%type R%rel m n.

Ltac reexists :=
  lazymatch goal with
    | |- ?R ?m ?n =>
      apply (rexists (R:=R) (m:=m) (n:=n));
      Delay.split_conjunction
  end.

Global Instance rexists_rstep {A B} P R (m:A) (n:B):
  RExists P R m n ->
  NonDelayed (RAutoSubgoals P) ->
  RStep True (R m n) | 70.

Class RElim {A B} (R: rel A B) (m: A) (n: B) (P Q: Prop): Prop :=
  relim: R m n -> P -> Q.

Arguments RElim {A%type B%type} R%rel m n P%type Q%type.

Ltac relim H :=
  lazymatch goal with
    | |- ?Q =>
      apply (relim (Q:=Q) H)
  end.

Global Instance relim_base {A B} (R: rel A B) m n:
  RElim R m n True (R m n) | 10.

Class RDestruct {A B: Type} (R: rel A B) (T: rel A B -> Prop) :=
  rdestruct m n: R m n -> forall P, T P -> P m n.

Class Related {A B} (f: A) (g: B) (R: rel A B) :=
  related: R f g.

Arguments Related {A%type B%type} _ _ R%rel.

Notation "'@' 'Monotonic' T m R" := (@Related T T m m R%rel)
  (at level 10, T at next level, R at next level, m at next level).

Notation Monotonic m R := (Related m m R%rel).

Lemma unfold_monotonic_rstep {A B} (R: rel A B) m n:
  RStep (R m n) (Related m n R).

Hint Extern 1 (RStep _ (Related _ _ _)) =>
  eapply unfold_monotonic_rstep : typeclass_instances.

Definition subrel {A B}: rel (rel A B) (rel A B) :=
  fun R1 R2 => forall x y, R1 x y -> R2 x y.

Arguments subrel {A%type B%type} R1%rel R2%rel.

Global Instance subrel_preorder A B:
  @PreOrder (rel A B) subrel.

Global Instance eq_subrel {A} (R: rel A A):
  Reflexive R ->
  Related eq R subrel.

Definition arrow_rel {A1 A2 B1 B2}:
  rel A1 A2 -> rel B1 B2 -> rel (A1 -> B1) (A2 -> B2) :=
    fun RA RB f g => forall x y, RA x y -> RB (f x) (g y).

Arguments arrow_rel {A1%type A2%type B1%type B2%type} RA%rel RB%rel _ _.

Notation "RA ==> RB" := (arrow_rel RA RB)
  (at level 55, right associativity) : rel_scope.

Notation "RA ++> RB" := (arrow_rel RA RB)
  (at level 55, right associativity) : rel_scope.

Notation "RA --> RB" := (arrow_rel (flip RA) RB)
  (at level 55, right associativity) : rel_scope.

Global Instance arrow_subrel {A1 A2 B1 B2}:
  Monotonic (@arrow_rel A1 A2 B1 B2) (subrel --> subrel ++> subrel).

Global Instance arrow_subrel_params:
  Params (@arrow_rel) 4.

Lemma arrow_rintro {A1 A2 B1 B2} (RA: rel A1 A2) (RB: rel B1 B2) f g:
  RIntro (forall x y, RA x y -> RB (f x) (g y)) (RA ++> RB) f g.

Hint Extern 0 (RIntro _ (_ ++> _) _ _) =>
  eapply arrow_rintro : typeclass_instances.

Lemma arrow_relim {A1 A2 B1 B2} RA RB f g m n P Q:
  @RElim B1 B2 RB (f m) (g n) P Q ->
  @RElim (A1 -> B1) (A2 -> B2) (RA ++> RB) f g (RA m n /\ P) Q.

Hint Extern 1 (RElim (_ ++> _) _ _ _ _) =>
  eapply arrow_relim : typeclass_instances.

Definition forall_rel {V1 V2} {E: V1->V2->Type} {FV1: V1->Type} {FV2: V2->Type}:
    (forall v1 v2, E v1 v2 -> rel (FV1 v1) (FV2 v2)) ->
    rel (forall v1, FV1 v1) (forall v2, FV2 v2) :=
  fun FE f g =>
    forall v1 v2 (e: E v1 v2), FE v1 v2 e (f v1) (g v2).

Arguments forall_rel {V1%type V2%type E%type FV1%type FV2%type} FE%rel _ _.

Notation "'forallr' e @ v1 v2 : E , R" :=
  (forall_rel (E := E) (fun v1 v2 e => R))
  (at level 200, e ident, v1 ident, v2 ident, right associativity) : rel_scope.

Notation "'forallr' e @ v1 v2 , R" :=
  (forall_rel (fun v1 v2 e => R))
  (at level 200, e ident, v1 ident, v2 ident, right associativity) : rel_scope.

Notation "'forallr' e : E , R" :=
  (forall_rel (E := E) (fun _ _ e => R))
  (at level 200, e ident, right associativity) : rel_scope.

Notation "'forallr' e , R" :=
  (forall_rel (fun _ _ e => R))
  (at level 200, e ident, right associativity) : rel_scope.

Lemma forall_rintro {V1 V2 E F1 F2} (FE: forall x y, _ -> rel _ _) f g:
  RIntro
    (forall u v e, FE u v e (f u) (g v))
    (@forall_rel V1 V2 E F1 F2 FE) f g.

Hint Extern 0 (RIntro _ (forall_rel _) _ _) =>
  eapply forall_rintro : typeclass_instances.

Lemma forall_relim {V1 V2 E FV1 FV2} R f g v1 v2 e P Q:
  RElim (R v1 v2 e) (f v1) (g v2) P Q ->
  RElim (@forall_rel V1 V2 E FV1 FV2 R) f g P Q.

Hint Extern 1 (RElim (forall_rel _) _ _ _ _) =>
  eapply forall_relim : typeclass_instances.

Global Instance flip_subrel {A B}:
  Monotonic (@flip A B Prop) (subrel ++> subrel).

Global Instance flip_subrel_params:
  Params (@flip) 3.

Lemma flip_rintro {A B} (R: rel A B) m n:
  RIntro (R n m) (flip R) m n.

Hint Extern 1 (RIntro _ (flip _) _ _) =>
  eapply flip_rintro : typeclass_instances.

Lemma flip_relim {A B} (R: rel A B) m n P Q:
  RElim R n m P Q ->
  RElim (flip R) m n P Q.

Hint Extern 1 (RElim (flip _) _ _ _ _) =>
  eapply flip_relim : typeclass_instances.

Lemma flip_rdestruct {A B} (R: rel A B) T:
  RDestruct R T ->
  RDestruct (flip R) (fun P => T (flip P)).

Hint Extern 1 (RDestruct (flip _) _) =>
  eapply flip_rdestruct : typeclass_instances. *)
Require Import RelClasses.
(* RelClasses:
Require Export Coq.Classes.RelationClasses.
Require Export RelDefinitions.

Class Coreflexive {A} (R: relation A) :=
  coreflexivity: forall x y, R x y -> x = y.

Global Instance eq_corefl {A}:
  Coreflexive (@eq A).

Global Instance subrel_eq {A} (R: relation A):
  Coreflexive R ->
  Related R eq subrel.

Class RCompose {A B C} (RAB : rel A B) (RBC : rel B C) (RAC : rel A C) :=
  rcompose : forall x y z, RAB x y -> RBC y z -> RAC x z.

Ltac rcompose b :=
  lazymatch goal with
    | |- ?R ?a ?c =>
      apply (rcompose a b c)
  end.

Ltac ercompose :=
  eapply rcompose.

Global Instance rcompose_transitive {A} (R : relation A) :
  RCompose R R R -> Transitive R.

Lemma transitive_rcompose `(Transitive) :
  RCompose R R R.

Hint Immediate transitive_rcompose : typeclass_instances.

Class RDecompose {A B C} (RAB : rel A B) (RBC : rel B C) (RAC : rel A C) :=
  rdecompose : forall x z, RAC x z -> exists y, RAB x y /\ RBC y z.

Tactic Notation "rdecompose" constr(H) "as" simple_intropattern(p) :=
  lazymatch type of H with
    | ?R ?a ?b =>
      destruct (rdecompose a b H) as p
    | _ =>
      fail "Not an applied relation"
  end.

Tactic Notation "rdecompose" hyp(H) "as" simple_intropattern(p) :=
  lazymatch type of H with
    | ?R ?a ?b =>
      apply rdecompose in H; destruct H as p
    | _ =>
      fail "Not an applied relation"
  end.

Tactic Notation "rdecompose" constr(H) :=
  rdecompose H as (? & ? & ?).

Tactic Notation "rdecompose" hyp(H) :=
  rdecompose H as (? & ? & ?).

Global Instance arrow_refl {A B} (RA : relation A) (RB : relation B) :
  Coreflexive RA ->
  Reflexive RB ->
  Reflexive (RA ++> RB).

Global Instance arrow_corefl {A B} (RA : relation A) (RB : relation B) :
  Reflexive RA ->
  Coreflexive RB ->
  Coreflexive (RA ++> RB).
Proof.
  
Abort.

Section ARROW_REL_COMPOSE.
  Context {A1 A2 A3} (RA12 : rel A1 A2) (RA23 : rel A2 A3) (RA13 : rel A1 A3).
  Context {B1 B2 B3} (RB12 : rel B1 B2) (RB23 : rel B2 B3) (RB13 : rel B1 B3).

  Global Instance arrow_rcompose :
    RDecompose RA12 RA23 RA13 ->
    RCompose RB12 RB23 RB13 ->
    RCompose (RA12 ++> RB12) (RA23 ++> RB23) (RA13 ++> RB13).

  Global Instance arrow_rdecompose :
    RCompose RA12 RA23 RA13 ->
    RDecompose RB12 RB23 RB13 ->
    RDecompose (RA12 ++> RB12) (RA23 ++> RB23) (RA13 ++> RB13).
  Proof.
    
  Abort.
End ARROW_REL_COMPOSE. *)
Require Import Coq.Lists.List.

Definition arrow_pointwise_rel A {B1 B2}:
  rel B1 B2 -> rel (A -> B1) (A -> B2) :=
    fun RB f g => forall a, RB (f a) (g a).

Arguments arrow_pointwise_rel A%type {B1%type B2%type} RB%rel _ _.

Notation "- ==> R" := (arrow_pointwise_rel _ R)
  (at level 55, right associativity) : rel_scope.

Global Instance arrow_pointwise_subrel {A B1 B2}:
  Monotonic (@arrow_pointwise_rel A B1 B2) (subrel ++> subrel).
Proof.
  firstorder.
Qed.

Global Instance arrow_pointwise_subrel_params:
  Params (@arrow_pointwise_rel) 3.

Lemma arrow_pointwise_rintro {A B1 B2} (R: rel B1 B2) f g:
  RIntro (forall x: A, R (f x) (g x)) (- ==> R) f g.
Proof.
  firstorder.
Qed.

Hint Extern 0 (RIntro _ (- ==> _) _ _) =>
  eapply arrow_pointwise_rintro : typeclass_instances.

Lemma arrow_pointwise_relim {A B1 B2} (R: rel B1 B2) f g (m n: A) P Q:
  RElim R (f m) (g n) P Q ->
  RElim (- ==> R) f g (m = n /\ P) Q.
Proof.
  intros HPQ Hfg [Hab HP].
  subst.
  firstorder.
Qed.

Hint Extern 1 (RElim (- ==> _) _ _ _ _) =>
  eapply arrow_pointwise_relim : typeclass_instances.

Lemma arrow_pointwise_refl {T} `(Reflexive) :
  @Reflexive (T -> A) (- ==> R).
Proof.
  firstorder.
Qed.

Hint Extern 1 (Reflexive (- ==> _)) =>
  eapply arrow_pointwise_refl : typeclass_instances.

Global Instance arrow_pointwise_rel_compose {T} `(RCompose) :
  RCompose (A := T -> A) (- ==> RAB) (- ==> RBC) (- ==> RAC).
Proof.
  firstorder.
Qed.

Definition forall_pointwise_rel {V: Type} {FV1 FV2: V -> Type}:
    (forall v, rel (FV1 v) (FV2 v)) ->
    rel (forall v, FV1 v) (forall v, FV2 v) :=
  fun FE f g =>
    forall v, FE v (f v) (g v).

Arguments forall_pointwise_rel {V%type FV1%type FV2%type} FE%rel _ _.

Notation "'forallr' - @ v : V , FE" :=
  (forall_pointwise_rel (V := V) (fun v => FE))
  (v ident, at level 200).

Notation "'forallr' - @ v , FE" :=
  (forall_pointwise_rel (fun v => FE))
  (v ident, at level 200).

Notation "'forallr' - : V , FE" :=
  (forall_pointwise_rel (V := V) (fun _ => FE))
  (at level 200).

Notation "'forallr' - , FE" :=
  (forall_pointwise_rel (fun _ => FE))
  (at level 200).

Lemma forall_pointwise_rintro {V FV1 FV2} (FE: forall v, rel _ _) f g:
  RIntro
    (forall v, FE v (f v) (g v))
    (@forall_pointwise_rel V FV1 FV2 FE) f g.
Proof.
  firstorder.
Qed.

Hint Extern 0 (RIntro _ (forall_pointwise_rel _) _ _) =>
  eapply forall_pointwise_rintro : typeclass_instances.

Lemma forall_pointwise_relim {V FV1 FV2} R f g v P Q:
  RElim (R v) (f v) (g v) P Q ->
  RElim (@forall_pointwise_rel V FV1 FV2 R) f g P Q.
Proof.
  firstorder.
Qed.

Hint Extern 1 (RElim (forall_pointwise_rel _) _ _ _ _) =>
  eapply forall_pointwise_relim : typeclass_instances.

Definition forallp_rel {V1 V2} (E: rel V1 V2) {FV1: V1->Type} {FV2: V2->Type}:
    (forall v1 v2, rel (FV1 v1) (FV2 v2)) ->
    rel (forall v1, FV1 v1) (forall v2, FV2 v2) :=
  fun FE f g =>
    forall v1 v2, E v1 v2 -> FE v1 v2 (f v1) (g v2).

Arguments forallp_rel {V1%type V2%type} E%rel {FV1%type FV2%type} FE%rel _ _.

Notation "'forallr' v1 v2 : E , R" :=
  (forallp_rel E (fun v1 v2 => R))
  (at level 200, v1 ident, v2 ident, right associativity)
  : rel_scope.

Lemma forallp_rintro {V1 V2} {E: rel V1 V2} {F1 F2} (FE: forall v1 v2, rel _ _) f g:
  RIntro
    (forall v1 v2, E v1 v2 -> FE v1 v2 (f v1) (g v2))
    (@forallp_rel V1 V2 E F1 F2 FE) f g.
Proof.
  firstorder.
Qed.

Hint Extern 0 (RIntro _ (forallp_rel _ _) _ _) =>
  eapply forallp_rintro : typeclass_instances.

Lemma forallp_relim {V1 V2 E FV1 FV2} R f g v1 v2 P Q:
  RElim (R v1 v2) (f v1) (g v2) P Q ->
  RElim (@forallp_rel V1 V2 E FV1 FV2 R) f g (E v1 v2 /\ P) Q.
Proof.
  firstorder.
Qed.

Hint Extern 1 (RElim (forallp_rel _ _) _ _ _ _) =>
  eapply forallp_relim : typeclass_instances.

Definition set_le {A B} (R: rel A B): rel (A -> Prop) (B -> Prop) :=
  fun sA sB => forall a, sA a -> exists b, sB b /\ R a b.

Global Instance set_le_subrel {A B}:
  Monotonic (@set_le A B) (subrel ++> subrel).
Proof.
  intros R1 R2 HR sA sB Hs.
  intros x Hx.
  destruct (Hs x) as (y & Hy & Hxy); eauto.
Qed.

Global Instance set_le_subrel_params:
  Params (@set_le) 3.

Lemma set_le_refl {A} (R : relation A) :
  Reflexive R ->
  Reflexive (set_le R).
Proof.
  firstorder.
Qed.

Hint Extern 1 (Reflexive (set_le _)) =>
  eapply set_le_refl : typeclass_instances.

Global Instance set_le_compose `(RCompose) :
  RCompose (set_le RAB) (set_le RBC) (set_le RAC).
Proof.
  intros sa sb sc Hsab Hsbc a Ha.
  edestruct Hsab as (b & Hb & Hab); eauto.
  edestruct Hsbc as (c & Hc & Hbc); eauto.
Qed.

Definition set_ge {A B} (R: rel A B): rel (A -> Prop) (B -> Prop) :=
  fun sA sB => forall b, sB b -> exists a, sA a /\ R a b.

Global Instance set_ge_subrel {A B}:
  Monotonic (@set_ge A B) (subrel ++> subrel).
Proof.
  firstorder.
Qed.

Global Instance set_ge_subrel_params:
  Params (@set_ge) 3.

Lemma set_ge_refl {A} (R : relation A) :
  Reflexive R ->
  Reflexive (set_ge R).
Proof.
  firstorder.
Qed.

Hint Extern 1 (Reflexive (set_ge _)) =>
  eapply set_ge_refl : typeclass_instances.

Global Instance set_ge_compose `(RCompose) :
  RCompose (set_ge RAB) (set_ge RBC) (set_ge RAC).
Proof.
  intros sa sb sc Hsab Hsbc c Hc.
  edestruct Hsbc as (b & Hb & Hbc); eauto.
  edestruct Hsab as (a & Ha & Hab); eauto.
Qed.

Inductive Empty_set_rel: rel Empty_set Empty_set := .

Inductive unit_rel: rel unit unit :=
  tt_rel: Proper unit_rel tt.

Global Existing Instance tt_rel.

Inductive sum_rel {A1 A2 B1 B2} RA RB: rel (A1 + B1)%type (A2 + B2)%type :=
  | inl_rel_def: (RA ++> sum_rel RA RB)%rel (@inl A1 B1) (@inl A2 B2)
  | inr_rel_def: (RB ++> sum_rel RA RB)%rel (@inr A1 B1) (@inr A2 B2).

Infix "+" := sum_rel : rel_scope.

Global Instance inl_rel:
  Monotonic (@inl) (forallr RA, forallr RB, RA ++> RA + RB).
Proof.
  repeat intro; apply inl_rel_def; assumption.
Qed.

Global Instance inr_rel:
  Monotonic (@inr) (forallr RA, forallr RB, RB ++> RA + RB).
Proof.
  repeat intro; apply inr_rel_def; assumption.
Qed.

Global Instance sum_subrel {A1 A2 B1 B2}:
  Monotonic (@sum_rel A1 A2 B1 B2) (subrel ++> subrel ++> subrel).
Proof.
  intros RA1 RA2 HRA RB1 RB2 HRB.
  intros x1 x2 Hx.
  destruct Hx; constructor; eauto.
Qed.

Global Instance sum_subrel_params:
  Params (@sum) 4.

Lemma sum_rel_refl {A B} (R1: rel A A) (R2: rel B B):
  Reflexive R1 -> Reflexive R2 -> Reflexive (R1 + R2).
Proof.
  intros H1 H2 x.
  destruct x; constructor; reflexivity.
Qed.

Hint Extern 2 (Reflexive (_ + _)) =>
  eapply sum_rel_refl : typeclass_instances.

Lemma sum_rel_corefl {A B} (R1: rel A A) (R2: rel B B):
  Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 + R2).
Proof.
  intros H1 H2 _ _ [x y H | x y H];
  f_equal;
  eauto using coreflexivity.
Qed.

Hint Extern 2 (Coreflexive (_ + _)) =>
  eapply sum_rel_corefl : typeclass_instances.

Lemma sum_rel_trans {A B} (R1: rel A A) (R2: rel B B):
  Transitive R1 -> Transitive R2 -> Transitive (R1 + R2).
Proof.
  intros H1 H2 x y z Hxy Hyz.
  destruct Hxy; inversion Hyz; constructor; etransitivity; eassumption.
Qed.

Hint Extern 2 (Transitive (_ + _)) =>
  eapply sum_rel_trans : typeclass_instances.

Lemma sum_rel_sym {A B} (R1: rel A A) (R2: rel B B):
  Symmetric R1 -> Symmetric R2 -> Symmetric (R1 + R2).
Proof.
  intros H1 H2 x y Hxy.
  destruct Hxy; constructor; symmetry; eassumption.
Qed.

Hint Extern 2 (Symmetric (_ + _)) =>
  eapply sum_rel_sym : typeclass_instances.

Lemma sum_rel_preorder {A B} (R1: rel A A) (R2: rel B B):
  PreOrder R1 -> PreOrder R2 -> PreOrder (R1 + R2).
Proof.
  split; typeclasses eauto.
Qed.

Hint Extern 2 (PreOrder (_ + _)) =>
  eapply sum_rel_preorder : typeclass_instances.

Definition prod_rel {A1 A2 B1 B2} RA RB: rel (A1 * B1)%type (A2 * B2)%type :=
  fun x1 x2 => RA (fst x1) (fst x2) /\ RB (snd x1) (snd x2).

Infix "*" := prod_rel : rel_scope.

Global Instance pair_rel:
  Monotonic (@pair) (forallr RA, forallr RB, RA ++> RB ++> RA * RB).
Proof.
  intros A1 A2 RA B1 B2 RB a1 a2 Ha b1 b2 Hb.
  red.
  eauto.
Qed.

Global Instance fst_rel:
  Monotonic (@fst) (forallr RA, forallr RB, RA * RB ==> RA).
Proof.
  intros A1 A2 RA B1 B2 RB.
  intros x1 x2 [Ha Hb].
  assumption.
Qed.

Global Instance snd_rel:
  Monotonic (@snd) (forallr RA, forallr RB, RA * RB ==> RB).
Proof.
  intros A1 A2 RA B1 B2 RB.
  intros x1 x2 [Ha Hb].
  assumption.
Qed.

Global Instance prod_subrel {A1 A2 B1 B2}:
  Monotonic (@prod_rel A1 A2 B1 B2) (subrel ++> subrel ++> subrel).
Proof.
  firstorder.
Qed.

Global Instance prod_subrel_params:
  Params (@prod_rel) 4.

Global Instance prod_rdestruct {A1 B1 A2 B2} (RA: rel A1 A2) (RB: rel B1 B2):
  RDestruct
    (RA * RB)%rel
    (fun P => forall a1 a2 b1 b2, RA a1 a2 -> RB b1 b2 -> P (a1, b1) (a2, b2)).
Proof.
  intros [a1 b1] [a2 b2] [Ha Hb] P HP.
  firstorder.
Qed.

Lemma prod_rel_refl {A B} (R1: rel A A) (R2: rel B B):
  Reflexive R1 -> Reflexive R2 -> Reflexive (R1 * R2).
Proof.
  intros H1 H2 x.
  destruct x; constructor; reflexivity.
Qed.

Hint Extern 2 (Reflexive (_ * _)) =>
  eapply prod_rel_refl : typeclass_instances.

Lemma prod_rel_corefl {A B} (R1: rel A A) (R2: rel B B):
  Coreflexive R1 -> Coreflexive R2 -> Coreflexive (R1 * R2).
Proof.
  intros H1 H2 [a1 b1] [a2 b2] [Ha Hb].
  f_equal; eauto using coreflexivity.
Qed.

Hint Extern 2 (Coreflexive (_ * _)) =>
  eapply prod_rel_corefl : typeclass_instances.

Lemma prod_rel_trans {A B} (R1: rel A A) (R2: rel B B):
  Transitive R1 -> Transitive R2 -> Transitive (R1 * R2).
Proof.
  intros H1 H2 x y z Hxy Hyz.
  destruct Hxy; inversion Hyz; constructor; etransitivity; eassumption.
Qed.

Hint Extern 2 (Transitive (_ * _)) =>
  eapply prod_rel_trans : typeclass_instances.

Lemma prod_rel_sym {A B} (R1: rel A A) (R2: rel B B):
  Symmetric R1 -> Symmetric R2 -> Symmetric (R1 * R2).
Proof.
  intros H1 H2 x y Hxy.
  destruct Hxy; constructor; symmetry; eassumption.
Qed.

Hint Extern 2 (Symmetric (_ * _)) =>
  eapply prod_rel_sym : typeclass_instances.

Lemma prod_rel_preorder {A B} (R1: rel A A) (R2: rel B B):
  PreOrder R1 -> PreOrder R2 -> PreOrder (R1 * R2).
Proof.
  split; typeclasses eauto.
Qed.

Hint Extern 2 (PreOrder (_ * _)) =>
  eapply prod_rel_preorder : typeclass_instances.

Inductive option_rel {A1 A2} (RA: rel A1 A2): rel (option A1) (option A2) :=
  | Some_rel_def: (RA ++> option_rel RA)%rel (@Some A1) (@Some A2)
  | None_rel_def: option_rel RA (@None A1) (@None A2).

Global Instance Some_rel:
  Monotonic (@Some) (forallr R @ A1 A2 : rel, R ++> option_rel R).
Proof.
  exact @Some_rel_def.
Qed.

Global Instance None_rel:
  Monotonic (@None) (forallr R, option_rel R).
Proof.
  exact @None_rel_def.
Qed.

Global Instance option_subrel {A1 A2}:
  Monotonic (@option_rel A1 A2) (subrel ++> subrel).
Proof.
  intros RA1 RA2 HRA.
  intros x1 x2 Hx.
  destruct Hx; constructor; eauto.
Qed.

Global Instance option_subrel_params:
  Params (@option_rel) 3.

Lemma option_rel_refl `(HR: Reflexive):
  Reflexive (option_rel R).
Proof.
  intros [x | ]; constructor; reflexivity.
Qed.

Hint Extern 1 (Reflexive (option_rel _)) =>
  eapply option_rel_refl : typeclass_instances.

Global Instance option_map_rel:
  Monotonic
    (@option_map)
    (forallr RA, forallr RB, (RA ++> RB) ++> option_rel RA ++> option_rel RB).
Proof.
  intros A1 A2 RA B1 B2 RB f g Hfg x y Hxy.
  destruct Hxy; constructor; eauto.
Qed.

Lemma option_rel_some_inv A B (R: rel A B) (x: option A) (y: option B) (a: A):
  option_rel R x y ->
  x = Some a ->
  exists b,
    y = Some b /\
    R a b.
Proof.
  destruct 1; inversion 1; subst; eauto.
Qed.

Inductive list_rel {A1 A2} (R: rel A1 A2): rel (list A1) (list A2) :=
  | nil_rel_def: (list_rel R) (@nil A1) (@nil A2)
  | cons_rel_def: (R ++> list_rel R ++> list_rel R)%rel (@cons A1) (@cons A2).

Global Instance nil_rel:
  Monotonic (@nil) (forallr R, list_rel R).
Proof.
  exact @nil_rel_def.
Qed.

Global Instance cons_rel:
  Monotonic (@cons) (forallr R, R ++> list_rel R ++> list_rel R).
Proof.
  exact @cons_rel_def.
Qed.

Global Instance list_subrel {A1 A2}:
  Monotonic (@list_rel A1 A2) (subrel ++> subrel).
Proof.
  intros R S HRS x y.
  red in HRS.
  induction 1; constructor; eauto.
Qed.

Global Instance list_subrel_params:
  Params (@list_rel) 3.

Lemma list_rel_refl `(HR: Reflexive):
  Reflexive (list_rel R).
Proof.
  intros l.
  induction l; constructor; eauto.
Qed.

Hint Extern 1 (Reflexive (list_rel _)) =>
  eapply list_rel_refl : typeclass_instances.

Lemma list_rel_corefl `(HR: Coreflexive):
  Coreflexive (list_rel R).
Proof.
  intros l1 l2 Hl.
  induction Hl as [ | x1 x2 Hx l1 l2 Hl IHl];
  f_equal; eauto using coreflexivity.
Qed.

Hint Extern 1 (Coreflexive (list_rel _)) =>
  eapply list_rel_corefl : typeclass_instances.

Lemma list_rel_sym `(HR: Symmetric):
  Symmetric (list_rel R).
Proof.
  intros l1 l2 Hl.
  induction Hl; constructor; eauto.
Qed.

Hint Extern 1 (Symmetric (list_rel _)) =>
  eapply list_rel_sym : typeclass_instances.

Lemma list_rel_trans `(HR: Transitive):
  Transitive (list_rel R).
Proof.
  intros l1 l2 l3 Hl12 Hl23.
  revert l3 Hl23.
  induction Hl12; inversion 1; constructor; eauto.
Qed.

Hint Extern 1 (Transitive (list_rel _)) =>
  eapply list_rel_trans : typeclass_instances.

Global Instance length_rel:
  Monotonic
    (@length)
    (forallr R : rel, list_rel R ++> eq).
Proof.
  induction 1; simpl; congruence.
Qed.

Global Instance app_rel:
  Monotonic
    (@app)
    (forallr R : rel, list_rel R ++> list_rel R ++> list_rel R).
Proof.
  intros A1 A2 R l1 l2 Hl.
  induction Hl as [ | x1 x2 Hx l1 l2 Hl IHl]; simpl.
  - firstorder.
  - constructor; eauto.
Qed.

Global Instance map_rel:
  Monotonic
    (@map)
    (forallr RA, forallr RB, (RA ++> RB) ++> list_rel RA ++> list_rel RB).
Proof.
  intros A1 A2 RA B1 B2 RB f g Hfg l1 l2 Hl.
  induction Hl; constructor; eauto.
Qed.

Global Instance fold_right_rel:
  Monotonic
    (@fold_right)
    (forallr RA, forallr RB, (RB ++> RA ++> RA) ++> RA ++> list_rel RB ++> RA).
Proof.
  intros A1 A2 RA B1 B2 RB f g Hfg a1 a2 Ha l1 l2 Hl.
  induction Hl; simpl; eauto.
  eapply Hfg; eauto.
Qed.

Global Instance fold_left_rel:
  Monotonic
    (@fold_left)
    (forallr RA, forallr RB, (RA ++> RB ++> RA) ++> list_rel RB ++> RA ++> RA).
Proof.
  intros A1 A2 RA B1 B2 RB f g Hfg l1 l2 Hl.
  induction Hl; simpl.
  - firstorder.
  - intros a1 a2 Ha.
    eapply IHHl.
    eapply Hfg; assumption.
Qed.

Lemma fold_impl_rstep (A B: Prop):
  RStep (impl A B) (A -> B).
Proof.
  firstorder.
Qed.

Hint Extern 1 (RStep _ (_ -> _)) =>
  eapply fold_impl_rstep : typeclass_instances.

Global Instance all_monotonic {A}:
  Monotonic (@all A) ((- ==> impl) ++> impl).
Proof.
  intros P Q HPQ H x.
  apply HPQ.
  apply H.
Qed.

Global Instance all_monotonic_params:
  Params (@all) 1.

Global Instance ex_monotonic A:
  Monotonic (@ex A) ((- ==> impl) ++> impl).
Proof.
  intros P Q HPQ [x Hx].
  exists x.
  apply HPQ.
  assumption.
Qed.

Global Instance ex_monotonic_params:
  Params (@ex) 1.

Global Instance and_monotonic:
  Monotonic (@and) (impl ++> impl ++> impl).
Proof.
  intros P1 P2 HP Q1 Q2 HQ [HP1 HQ1].
  eauto.
Qed.

Global Instance or_monotonic:
  Monotonic (@or) (impl ++> impl ++> impl).
Proof.
  intros P1 P2 HP Q1 Q2 HQ [HP1|HQ1];
  eauto.
Qed.
