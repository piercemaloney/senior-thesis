
Require Import Bool.
Require Import Omega.

Section registers.

Inductive register : nat -> Set :=
  | regO : register 0
  | regS : forall m : nat, bool -> register m -> register (S m).

Definition register_zero :=
  nat_rec register regO (fun m : nat => regS m false).
Definition register_max := nat_rec register regO (fun m : nat => regS m true).
Fixpoint is_register_zero (n : nat) (x : register n) {struct x} : bool :=
  match x with
  | regO => true
  | regS m b y => if b then false else is_register_zero m y
  end.
Definition is_register_max (n : nat) (x : register n) :=
  match x with
  | regO => true
  | regS m b y => if b then is_register_zero m y else false
  end.

Fixpoint entier_of_register (n : nat) (x : register n) {struct x} : N :=
  match x with
  | regO => 0%N
  | regS m b y =>
      if b
      then Ndouble_plus_one (entier_of_register m y)
      else Ndouble (entier_of_register m y)
  end.
Definition Z_of_register (n : nat) (x : register n) :=
  BinInt.Z_of_N (entier_of_register n x).

Definition sign_of (b : bool) := if b then 1%Z else (-1)%Z.

Fixpoint register_of_pos (n : nat) (x : positive) {struct x} : 
 register n :=
  match n as x return (register x) with
  | O => regO
  | S m =>
      match x with
      | xH => regS m true (register_zero m)
      | xI y => regS m true (register_of_pos m y)
      | xO y => regS m false (register_of_pos m y)
      end
  end.
Definition register_of_entier (n : nat) (x : N) :=
  match x return (register n) with
  | N0 => register_zero n
  | Npos p => register_of_pos n p
  end.
Definition register_of_Z (n : nat) (z : Z) : register n :=
  register_of_entier n (BinInt.Zabs_N z).

Lemma register_of_entier_bij2 :
 forall (n : nat) (x : register n),
 register_of_entier n (entier_of_register n x) = x.

simple induction x;
 [ reflexivity
 | intros m b r; elim b;
    [ simpl in |- *; unfold Ndouble_plus_one in |- *;
       elim (entier_of_register m r); intros; rewrite <- H; 
       reflexivity
    | simpl in |- *; unfold Ndouble in |- *; elim (entier_of_register m r);
       intros; rewrite <- H; reflexivity ] ].
Qed.

Fixpoint register_compare (n : nat) (x : register n) 
 (m : nat) (y : register m) {struct y} : Datatypes.comparison :=
  match x with
  | regO => if is_register_zero m y then Datatypes.Eq else Datatypes.Lt
  | regS n' b_x x' =>
      match y with
      | regO => if is_register_zero n x then Datatypes.Eq else Datatypes.Gt
      | regS m' b_y y' =>
          match register_compare n' x' m' y' with
          | Datatypes.Eq =>
              if b_x
              then if b_y then Datatypes.Eq else Datatypes.Gt
              else if b_y then Datatypes.Lt else Datatypes.Eq
          | Datatypes.Gt => Datatypes.Gt
          | Datatypes.Lt => Datatypes.Lt
          end
      end
  end.

Definition reg_compare (n : nat) (x y : register n) :=
  register_compare n x n y.

End registers.
