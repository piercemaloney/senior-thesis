
Require Import Omega.
Require Import Zcomplements.
Require Import Zpower.
Require Import Zlogarithm.
Require Import Diadic.
(* Diadic:
Require Import Omega.
Require Import Zcomplements.
Require Import Zpower.
Require Import Zlogarithm.
Require Import ZArithRing.

Section definitions.

Record diadic : Set := Diadic {Dnum : Z; Dexp : Z}.

Definition Dshift (n : Z) (x : diadic) := Diadic (Dnum x) (Dexp x + n).

Definition Dzero (x : Z) := Diadic 0 x.

Definition is_Dzero (x : diadic) := Dnum x = 0%Z.

Inductive rounding_mode : Set :=
  | Rounding_sup : rounding_mode
  | Rounding_inf : rounding_mode
  | Rounding_nearest : rounding_mode
  | Rounding_zero : rounding_mode.

Definition Rounding_mode_opp (m : rounding_mode) :=
  match m with
  | Rounding_sup => Rounding_inf
  | Rounding_inf => Rounding_sup
  | Rounding_nearest => Rounding_nearest
  | Rounding_zero => Rounding_zero
  end.

End definitions.

Section comparisons.

Definition Dcompare (x y : diadic) : Datatypes.comparison :=
  let nx := Dnum x in
  let ny := Dnum y in
  let ex := Dexp x in
  let ey := Dexp y in
  (two_p (ex - Zmin ex ey) * nx ?= two_p (ey - Zmin ex ey) * ny)%Z.

Definition Deq (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => True
  | Datatypes.Lt => False
  | Datatypes.Gt => False
  end.
Definition Dneq (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => False
  | Datatypes.Lt => True
  | Datatypes.Gt => True
  end.
Definition Dle (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => True
  | Datatypes.Lt => True
  | Datatypes.Gt => False
  end.
Definition Dlt (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => False
  | Datatypes.Lt => True
  | Datatypes.Gt => False
  end.
Definition Dge (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => True
  | Datatypes.Lt => False
  | Datatypes.Gt => True
  end.
Definition Dgt (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => False
  | Datatypes.Lt => False
  | Datatypes.Gt => True
  end.

Definition Deq_bool (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => true
  | Datatypes.Lt => false
  | Datatypes.Gt => false
  end.
Definition Dneq_bool (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => false
  | Datatypes.Lt => true
  | Datatypes.Gt => true
  end.
Definition Dle_bool (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => true
  | Datatypes.Lt => true
  | Datatypes.Gt => false
  end.
Definition Dlt_bool (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => false
  | Datatypes.Lt => true
  | Datatypes.Gt => false
  end.
Definition Dge_bool (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => true
  | Datatypes.Lt => false
  | Datatypes.Gt => true
  end.
Definition Dgt_bool (x y : diadic) :=
  match Dcompare x y with
  | Datatypes.Eq => false
  | Datatypes.Lt => false
  | Datatypes.Gt => true
  end.

Lemma Dcompare_shift :
 forall (x y : diadic) (n : Z),
 Dcompare (Dshift n x) (Dshift n y) = Dcompare x y. 

Lemma eq_Deq : forall x y : diadic, x = y -> Deq x y.

Lemma Dcompare_zero :
 forall (x : diadic) (n : Z), Dcompare x (Dzero n) = (Dnum x ?= 0)%Z.

Lemma Deq_shift :
 forall (x y : diadic) (n : Z), Deq x y -> Deq (Dshift n x) (Dshift n y).

Lemma Deq_x_shift_x :
 forall (x : diadic) (n : Z),
 (0 <= n)%Z -> Deq x (Diadic (Dnum x * two_p n) (Dexp x - n)).

Lemma Dle_Zle :
 forall n1 n2 d : Z, (n1 <= n2)%Z -> Dle (Diadic n1 d) (Diadic n2 d).

Lemma Dlt_Zlt :
 forall n1 n2 d : Z, (n1 < n2)%Z -> Dlt (Diadic n1 d) (Diadic n2 d).

Lemma Dge_Zge :
 forall n1 n2 d : Z, (n1 >= n2)%Z -> Dge (Diadic n1 d) (Diadic n2 d).

Lemma Dgt_Zgt :
 forall n1 n2 d : Z, (n1 > n2)%Z -> Dgt (Diadic n1 d) (Diadic n2 d).

Lemma Dle_refl : forall x y : diadic, Deq x y -> Dle x y.

End comparisons.

Section operations.

Definition Dsucc (x : diadic) := Diadic (Dnum x + 1) (Dexp x).
Definition Dpred (x : diadic) := Diadic (Dnum x - 1) (Dexp x).

Definition Dadd (x y : diadic) :=
  let nx := Dnum x in
  let ny := Dnum y in
  let ex := Dexp x in
  let ey := Dexp y in
  Diadic (two_p (ex - Zmin ex ey) * nx + two_p (ey - Zmin ex ey) * ny)
    (Zmin ex ey).

Definition Dopp (x : diadic) := Diadic (- Dnum x) (Dexp x).

Definition Dabs (x : diadic) := Diadic (Zabs (Dnum x)) (Dexp x).

Definition Dminus (x y : diadic) := Dadd x (Dopp y).

Definition Dmult (x y : diadic) := Diadic (Dnum x * Dnum y) (Dexp x + Dexp y).

Definition Dproj (m : rounding_mode) (x : diadic) (P : diadic -> Prop)
  (y : diadic) :=
  P y /\
  match m with
  | Rounding_sup => forall z : diadic, P z -> Dle x z -> Dle y z
  | Rounding_inf => forall z : diadic, P z -> Dle z x -> Dle z y
  | Rounding_nearest =>
      forall z : diadic, P z -> Dle (Dabs (Dminus x y)) (Dabs (Dminus x z))
  | Rounding_zero =>
      forall z : diadic,
      P z ->
      IF Dle (Dzero 0) x then Dle z x -> Dle z y else Dle z x -> Dle z y
  end.

Lemma ZROUND_inf_spec :
 forall (p : positive) (x : Z),
 {y : Z | (y * two_power_pos p <= x < Zsucc y * two_power_pos p)%Z}.

Definition ZROUND_inf (p : positive) (x : Z) :=
  let (x', p) := ZROUND_inf_spec p x in x'.

Lemma ZROUND_sup_spec :
 forall (p : positive) (x : Z),
 {y : Z | (Zpred y * two_power_pos p < x <= y * two_power_pos p)%Z}.

Definition ZROUND_sup (p : positive) (x : Z) :=
  let (x', p) := ZROUND_sup_spec p x in x'.

Lemma ZROUND_correct :
 forall (m : rounding_mode) (p : positive) (x : Z),
 {y : Z |
 match m with
 | Rounding_inf => (y * two_power_pos p <= x < Zsucc y * two_power_pos p)%Z
 | Rounding_sup => (Zpred y * two_power_pos p < x <= y * two_power_pos p)%Z
 | Rounding_nearest =>
     match (x - ZROUND_inf p x ?= ZROUND_sup p x - x)%Z with
     | Datatypes.Eq =>

Definition ZROUND (m : rounding_mode) (p : positive) 
  (x : Z) := let (x', p) := ZROUND_correct m p x in x'.

Definition POS_ROUND (m : rounding_mode) (p n : positive) :=
  BinInt.Zabs_N (ZROUND m p (Zpos n)).

Definition NEG_ROUND (m : rounding_mode) (p n : positive) :=
  BinInt.Zabs_N (- ZROUND m p (Zneg n)).

Definition Ddouble (d : diadic) := Dshift 1 d.

Axiom
  ROUND_spec :
    forall (m : rounding_mode) (p : Z) (x : diadic),
    {y : diadic |
    N_digits (Dexp y) = p /\
    match m with
    | Rounding_inf => Dle y x /\ Dlt x (Dsucc y)
    | Rounding_sup => Dlt (Dpred y) x /\ Dle x y
    | Rounding_nearest =>
        Dle (Dpred (Ddouble y)) (Ddouble x) /\
        Dle (Ddouble x) (Dsucc (Ddouble y))
    | Rounding_zero =>
        IF Dlt (Dzero 0) x then Dle y x /\ Dlt x (Dsucc y)
        else Dlt (Dpred y) x /\ Dle x y
    end}.

Definition ROUND (m : rounding_mode) (p : Z) (d : diadic) :=
  let (x, _) := ROUND_spec m p d in x.

Definition ANTIROUND (m : rounding_mode) (p : Z) (x : diadic) :=
  let nx := Dnum x in
  let ex := Dexp x in
  match (p - ex)%Z with
  | Zpos q => ZROUND m q nx
  | Zneg q => (nx * two_power_pos q)%Z
  | Z0 => nx
  end.

Parameter Ddiv : rounding_mode -> Z -> diadic -> diadic -> diadic.

Parameter Dsqrt : rounding_mode -> Z -> positive -> Z -> diadic.

End operations. *)
Require Import IEEE754_def.
(* IEEE754_def:
Require Import Omega.
Require Import Bool.
Require Import Zcomplements.
Require Import Zpower.
Require Import Zlogarithm.

Require Import Diadic.
Require Import Registers.

Section constants.

Inductive float_type : Set :=
  | Single : float_type
  | Single_ext : float_type
  | Double : float_type
  | Double_ext : float_type
  | Quad : float_type.

Definition dig_length (t : float_type) :=
  match t with
  | Single => 23%Z
  | Single_ext => 32%Z
  | Double => 52%Z
  | Double_ext => 74%Z
  | Quad => 112%Z
  end.

Definition exp_length (t : float_type) :=
  match t with
  | Single => 8%Z
  | Single_ext => 11%Z
  | Double => 11%Z
  | Double_ext => 15%Z
  | Quad => 15%Z
  end.

Definition dig_l (t : float_type) := Zabs_nat (dig_length t).
Definition exp_l (t : float_type) := Zabs_nat (exp_length t).

Definition Emax (t : float_type) :=
  match t with
  | Single => 127%Z
  | Single_ext => 1023%Z
  | Double => 1023%Z
  | Double_ext => 16383%Z
  | Quad => 16383%Z
  end.

Definition Emin (t : float_type) :=
  match t with
  | Single => (-126)%Z
  | Single_ext => (-1022)%Z
  | Double => (-1022)%Z
  | Double_ext => (-16382)%Z
  | Quad => (-16382)%Z
  end.

Definition Ebias := Emax.

Definition Ebias_adjust (t : float_type) :=
  match t with
  | Single => 192%Z
  | Single_ext => 1536%Z
  | Double => 1536%Z
  | Double_ext => 24576%Z
  | Quad => 24576%Z
  end.

Inductive extended_relation : Set :=
  | Ordered : Datatypes.comparison -> extended_relation
  | Unordered : extended_relation.

Inductive exception : Set :=
  | Invalid_operation : exception
  | Division_by_zero : exception
  | Overflow : exception
  | Underflow : exception
  | Inexact : exception
  | Inexact_underflow : exception
  | Inexact_overflow : exception
  | Nothing : exception.

Definition quiet := 1%positive.
Definition signaling_IE := 2%positive.

Definition trap_signal_order := exception -> bool.
Definition trap (tso : trap_signal_order) (e : exception) : exception :=
  if tso e then Nothing else e.

Definition tso_default (x : exception) := false.
Definition tso_max (x : exception) := true.

End constants.

Section definitions.

Variable t : float_type.

Inductive abstract_IEEE : Set :=
  | Normal : bool -> Z -> positive -> abstract_IEEE
  | Subnormal : bool -> positive -> abstract_IEEE
  | Zero : bool -> abstract_IEEE
  | Infty : bool -> abstract_IEEE
  | NaN : positive -> abstract_IEEE.

Record concrete_IEEE : Set := C_build
  {c_sign : bool; c_exp : register (exp_l t); c_dig : register (dig_l t)}.

Definition abstract_wf (x : abstract_IEEE) :=
  match x with
  | Normal b e m => (Emin t <= e <= Emax t)%Z /\ log_inf m = dig_length t
  | Subnormal b m => (Zpos m < two_p (dig_length t))%Z
  | _ => True
  end.

Definition max_abstract (b : bool) :=
  Normal b (Emax t) (iter (dig_length t) positive xI 1%positive).
Definition min_abstract (b : bool) := Subnormal b 1.

Definition abstract_of_diadic (m : rounding_mode) (x : diadic) :=
  let (nx, e1) := ROUND m (dig_length t) x in
  let ex := (e1 + dig_length t)%Z in
  match nx return abstract_IEEE with
  | Z0 => Zero true
  | Zpos p =>
      if Zbool.Zgt_bool ex (Emax t)
      then Infty true
      else
       match (ex - Emin t)%Z with
       | Zneg e =>
           match POS_ROUND m e p with
           | N0 => Zero true
           | Npos q =>
               if Zbool.Zge_bool (Zpos q) (two_p (Zsucc (dig_length t)))
               then Normal true (Emin t) q
               else Subnormal true q
           end
       | _ => Normal true ex p
       end
  | Zneg p =>
      if Zbool.Zgt_bool ex (Emax t)
      then Infty false
      else
       match (ex - Emin t)%Z with
       | Zneg e =>
           match NEG_ROUND m e p with
           | N0 => Zero false
           | Npos q =>
               if Zbool.Zge_bool (Zpos q) (two_p (Zsucc (dig_length t)))
               then Normal false (Emin t) q
               else Subnormal false q
           end
       | _ => Normal false ex p
       end
  end.

Definition abstract_of_diadic_s (m : rounding_mode) 
  (x : diadic) :=
  let (nx, e1) := ROUND m (dig_length t) x in
  let ex := (e1 + dig_length t)%Z in
  match nx return (abstract_IEEE * exception) with
  | Z0 => (Zero true, Nothing)
  | Zpos p =>
      if Zbool.Zgt_bool ex (Emax t)
      then (Infty true, Overflow)
      else
       match (ex - Emin t)%Z with
       | Zneg e =>
           match POS_ROUND m e p with
           | N0 => (Zero true, Inexact_underflow)
           | Npos q =>
               if Zbool.Zge_bool (Zpos q) (two_p (Zsucc (dig_length t)))
               then (Normal true (Emin t) q, Nothing)
               else (Subnormal true q, Underflow)
           end
       | _ => (Normal true ex p, Nothing)
       end
  | Zneg p =>
      if Zbool.Zgt_bool ex (Emax t)
      then (Infty false, Overflow)
      else
       match (ex - Emin t)%Z with
       | Zneg e =>
           match NEG_ROUND m e p with
           | N0 => (Zero false, Inexact_underflow)
           | Npos q =>
               if Zbool.Zge_bool (Zpos q) (two_p (Zsucc (dig_length t)))
               then (Normal false (Emin t) q, Nothing)
               else (Subnormal false q, Underflow)
           end
       | _ => (Normal false ex p, Nothing)
       end
  end.

Definition concrete_of_abstract (x : abstract_IEEE) :=
  match x with
  | Normal b e m =>
      C_build b (register_of_Z (exp_l t) (e + Ebias t))
        (register_of_pos (dig_l t) m)
  | Subnormal b m =>
      C_build b (register_zero (exp_l t)) (register_of_pos (dig_l t) m)
  | Zero b => C_build b (register_zero (exp_l t)) (register_zero (dig_l t))
  | Infty b => C_build b (register_max (exp_l t)) (register_zero (dig_l t))
  | NaN s =>
      C_build true (register_max (exp_l t)) (register_of_pos (dig_l t) s)
  end.

Definition concrete_of_diadic (m : rounding_mode) (x : diadic) :=
  concrete_of_abstract (abstract_of_diadic m x).

Definition abstract_of_concrete (x : concrete_IEEE) :=
  match x return abstract_IEEE with
  | C_build b e m =>
      match entier_of_register (dig_l t) m return abstract_IEEE with
      | N0 =>
          if is_register_zero (exp_l t) e
          then Zero b
          else
           if is_register_max (exp_l t) e
           then Infty b
           else
            Normal b (Z_of_register (exp_l t) e - Ebias t)
              (nat_rect _ 1%positive (fun _ => xO) (dig_l t) )
      | Npos p =>
          if is_register_zero (exp_l t) e
          then Subnormal b p
          else
           if is_register_max (exp_l t) e
           then NaN p
           else
            Normal b (Z_of_register (exp_l t) e - Ebias t)
              (nat_rect _ 1%positive (fun _ => xO) (dig_l t) + p)
      end
  end.

Definition diadic_of_abstract (x : abstract_IEEE) :=
  match x with
  | Normal b e m => Diadic (sign_of b * Zpos m) (e - dig_length t)
  | Subnormal b m => Diadic (sign_of b * Zpos m) (Emin t - dig_length t)
  | Zero b => Dzero 0
  | Infty b => Diadic (sign_of b) (Emax Quad + 1)
  | NaN s => Diadic (Zpos s) (Emax Quad + 2)
  end.

Definition diadic_of_concrete (x : concrete_IEEE) :=
  diadic_of_abstract (abstract_of_concrete x).

Definition abstract_compare (x y : abstract_IEEE)
  (tso : trap_signal_order) :=
  match x, y with
  | NaN _, NaN _ => (Ordered Datatypes.Eq, Nothing)
  | NaN _, _ => (Unordered, trap tso Invalid_operation)
  | _, NaN _ => (Unordered, trap tso Invalid_operation)
  | x1, y1 =>
      (Ordered (Dcompare (diadic_of_abstract x1) (diadic_of_abstract y1)),
      Nothing)
  end.

Definition abstract_add (m : rounding_mode) (x y : abstract_IEEE) :=
  match x, y return (abstract_IEEE * exception) with
  | NaN s1, _ => (NaN s1, Nothing)
  | _, NaN s2 => (NaN s2, Nothing)
  | Infty true, Infty false => (NaN quiet, Invalid_operation)
  | Infty false, Infty true => (NaN quiet, Invalid_operation)
  | Infty b1, _ => (Infty b1, Nothing)
  | _, Infty b2 => (Infty b2, Nothing)
  | _, _ =>
      abstract_of_diadic_s m
        (Dadd (diadic_of_abstract x) (diadic_of_abstract y))
  end.

Definition abstract_opp (x : abstract_IEEE) :=
  match x with
  | NaN s => NaN s
  | Infty b => Infty (negb b)
  | Zero b => Zero (negb b)
  | Normal b e m => Normal (negb b) e m
  | Subnormal b m => Subnormal (negb b) m
  end.

Definition abstract_sub (m : rounding_mode) (x y : abstract_IEEE) :=
  abstract_add m x (abstract_opp y).

Definition sign_of_mult (b1 b2 : bool) :=
  ifb b1 (ifb b2 true false) (ifb b2 false true).

Definition abstract_mult (m : rounding_mode) (x y : abstract_IEEE) :=
  match x, y return (abstract_IEEE * exception) with
  | NaN s1, _ => (NaN s1, Nothing)
  | _, NaN s2 => (NaN s2, Nothing)
  | Infty b1, Infty b2 => (Infty (sign_of_mult b1 b2), Nothing)
  | Infty b1, _ => (Infty b1, Nothing)
  | _, Infty b2 => (Infty b2, Nothing)
  | _, _ =>
      abstract_of_diadic_s m
        (Dmult (diadic_of_abstract x) (diadic_of_abstract y))
  end.

Definition abstract_div (m : rounding_mode) (x y : abstract_IEEE) :=
  match x, y return (abstract_IEEE * exception) with
  | NaN s1, _ => (NaN s1, Nothing)
  | _, NaN s2 => (NaN s2, Nothing)
  | Infty _, Infty _ => (NaN quiet, Invalid_operation)
  | Zero _, Zero _ => (NaN quiet, Invalid_operation)
  | Infty b1, Normal b2 _ _ => (Infty (sign_of_mult b1 b2), Nothing)
  | Infty b1, Subnormal b2 _ =>
      (Infty (sign_of_mult b1 b2), Nothing)
      
  | Zero b1, Infty b2 => (Zero (sign_of_mult b1 b2), Nothing)
  | Subnormal b1 _, Infty b2 => (Zero (sign_of_mult b1 b2), Nothing)
  | Normal b1 _ _, Infty b2 => (Zero (sign_of_mult b1 b2), Nothing)
  | Infty b1, Zero b2 => (Infty (sign_of_mult b1 b2), Division_by_zero)
  | Normal b1 _ _, Zero b2 => (Infty (sign_of_mult b1 b2), Division_by_zero)
  | Subnormal b1 _, Zero b2 => (Infty (sign_of_mult b1 b2), Division_by_zero)
  | _, _ =>
      abstract_of_diadic_s m
        (Ddiv m (dig_length t) (diadic_of_abstract x) (diadic_of_abstract y))
  end.

Definition sqrt_abstract (m : rounding_mode) (x : abstract_IEEE) :=
  match x return (abstract_IEEE * exception) with
  | NaN s => (NaN s, Nothing)
  | Infty b => (Infty b, Nothing)
  | _ =>
      match Dnum (diadic_of_abstract x) with
      | Z0 => (Zero true, Nothing)
      | Zpos p =>
          abstract_of_diadic_s m
            (Dsqrt m (dig_length t) p (Dexp (diadic_of_abstract x)))
      | Zneg _ => (NaN quiet, Invalid_operation)
      end
  end.

End definitions.

Notation "#+ m 'E' e" := (C_build _ true e m) (at level 25, only printing).
Notation "#- m 'E' e" := (C_build _ false e m) (at level 25, only printing).

Notation "0" := regO (only printing).
Notation "r 1" := (regS _ true r)
  (at level 24, left associativity, only printing).
Notation "r 0" := (regS _ false r)
  (at level 24, left associativity, only printing).

Check (C_build Single false
         (regS _ true (regS _ true (regS _ true (regS _ true (regS _ true (regS _ true (regS _ true (regS _ true regO))))))))
         (regS _ false (regS _ true (regS _ true (regS _ false (regS _ true (regS _ true (regS _ true (regS _ false (regS _ true (regS _ true (regS _ true (regS _ true (regS _ false (regS _ true (regS _ true (regS _ true (regS _ true (regS _ false (regS _ true (regS _ true (regS _ true (regS _ false (regS _ true regO)))))))))))))))))))))))). *)

Section basic_verifs.

Lemma max_abstract_wf :
 forall (b : bool) (t : float_type), abstract_wf t (max_abstract t b).
simple induction b; simple induction t; compute in |- *; split; split;
 trivial || discriminate.
Qed.

End basic_verifs.