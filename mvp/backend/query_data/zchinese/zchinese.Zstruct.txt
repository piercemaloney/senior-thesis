Require Export Lci.
(* Lci:
Section Internal.

Variable S : Set.
Variable G : S -> Prop.
Variable Add : S -> S -> S.
Variable O I : S.
Variable Opp Inv : S -> S.

Definition intern := forall x y : S, G x -> G y -> G (Add x y).

Definition commutativity := forall x y : S, Add x y = Add y x.

Definition associativity :=
  forall x y z : S, Add x (Add y z) = Add (Add x y) z :>S.

Definition neutral (S : Set) (G : S -> Prop) (Add : S -> S -> S) 
  (O : S) := G O /\ (forall x : S, G x -> Add x O = x /\ Add O x = x).

Lemma neutral_add : neutral S G Add O -> O = Add O O.

Definition is_opposite (x y : S) := G x /\ G y /\ Add x y = O /\ Add y x = O.

Lemma opp_com :
 commutativity ->
 forall x y : S, G x -> G y -> Add x y = O -> is_opposite x y.

Definition opposite := forall x : S, G x -> is_opposite x (Opp x).

Definition distributivity (S : Set) (Add Mult : S -> S -> S) :=
  forall x y z : S,
  Mult (Add x y) z = Add (Mult x z) (Mult y z) /\
  Mult x (Add y z) = Add (Mult x y) (Mult x z).

End Internal. *)
Require Export misc.
(* misc:
Require Export Lci.

Definition antisym (A : Set) (R : A -> A -> Prop) :=
  forall x y : A, R x y -> R y x -> x = y :>A.

Definition pi1 : forall (A : Set) (P : A -> Prop), {x : A | P x} -> A.

Lemma pi2 :
 forall (A : Set) (P : A -> Prop) (p : {x : A | P x}), P (pi1 A P p).

Definition inversible (S : Set) (Mult : S -> S -> S) 
  (I x : S) := exists y : S, Mult x y = I /\ Mult y x = I.

Lemma inv_com :
 forall (S : Set) (Mult : S -> S -> S) (I x : S),
 commutativity S Mult ->
 (exists y : S, Mult x y = I) -> inversible S Mult I x. *)
Require Export Arith.
Require Export groups.
(* groups:
Require Export Lci.
Require Export misc.

Section groups.

Variable S : Set.
Variable G : S -> Prop.
Variable Add : S -> S -> S.
Variable O : S.
Variable Opp : S -> S.

Definition is_group :=
  intern S G Add /\
  associativity S Add /\ neutral S G Add O /\ opposite S G Add O Opp. 

Lemma regular_l :
 is_group ->
 forall y z : S,
 G y -> G z -> forall x : S, G x -> Add x y = Add x z -> y = z.

Lemma add_add :
 commutativity S Add ->
 associativity S Add ->
 forall x1 y1 x2 y2 : S,
 Add (Add x1 y1) (Add x2 y2) = Add (Add x1 x2) (Add y1 y2).

Lemma opp_unicity :
 is_group -> forall x y : S, is_opposite S G Add O x y -> y = Opp x.

Lemma opp_opp : is_group -> forall x : S, G x -> x = Opp (Opp x).

Lemma opp_add :
 is_group ->
 commutativity S Add ->
 forall x y : S, G x -> G y -> Opp (Add x y) = Add (Opp x) (Opp y).

Lemma opp_neutral : is_group -> Opp O = O.

End groups. *)
Require Export rings.
(* rings:
Require Export Lci.
Require Export misc.
Require Export groups.
Require Export Compare_dec.

Section ring.

Variable S : Set.
Variable A : S -> Prop.
Variable Add Mult : S -> S -> S.
Variable O I : S.
Variable Opp : S -> S.
Variable v : S -> nat.

Definition is_ring :=
  commutativity S Add /\
  is_group S A Add O Opp /\
  intern S A Mult /\ associativity S Mult /\ distributivity S Add Mult.

Lemma mult_O : is_ring -> forall x : S, A x -> Mult x O = O /\ Mult O x = O.

Lemma mult_opp_r :
 is_ring -> forall x y : S, A x -> A y -> Mult x (Opp y) = Opp (Mult x y).

Lemma mult_opp_l :
 is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) y = Opp (Mult x y).

Lemma mult_opp_opp :
 is_ring -> forall x y : S, A x -> A y -> Mult (Opp x) (Opp y) = Mult x y.

Definition integrity := forall a b : S, Mult a b = O -> {a = O} + {b = O}.

Definition is_unitary_commutative_ring :=
  is_ring /\ commutativity S Mult /\ neutral S A Mult I.

Definition divide (a b : S) :=
  A a /\ A b /\ (b = O \/ a <> O /\ (exists q : S, A q /\ b = Mult a q)).

Theorem div_O_O : is_ring -> divide O O.

Theorem div_add :
 is_ring -> forall a b d : S, divide d a -> divide d b -> divide d (Add a b).

Theorem div_mult :
 is_ring -> forall a b d : S, divide d a -> A b -> divide d (Mult a b).

Theorem div_opp : is_ring -> forall a d : S, divide d a -> divide d (Opp a).

Definition is_gcd (a b d : S) :=
  divide d a /\
  divide d b /\ (forall q : S, divide q a -> divide q b -> divide q d).

Lemma gcd_null : forall a b : S, is_gcd a b O -> a = O /\ b = O.

Lemma gcd_null2 : is_ring -> forall d : S, is_gcd O O d -> d = O.

Lemma simplification_integrity :
 is_unitary_commutative_ring ->
 integrity -> forall a x : S, A a -> A x -> a <> O -> Mult a x = a -> x = I.

Lemma gcd_unicity_apart_unities :
 is_unitary_commutative_ring ->
 integrity ->
 forall a b d1 d2 : S,
 is_gcd a b d1 ->
 is_gcd a b d2 ->
 exists x : S, inversible S Mult I x /\ A x /\ d2 = Mult d1 x.

Lemma opp_O : is_ring -> forall x : S, A x -> Opp x = O -> x = O.

End ring. *)
Require Export ZArith.
Require Import Omega.

Definition IdZ (x : Z) := True.

Theorem Z_group : is_group Z IdZ Zplus 0%Z Zopp.
Proof.
split.
red in |- *; trivial.
split.
red in |- *; auto with zarith.
split; red in |- *.
split; auto with zarith.
unfold IdZ in |- *; trivial.
split; auto with zarith.
Qed.

Theorem Z_ring : is_ring Z IdZ Zplus Zmult 0%Z Zopp.
Proof.
unfold is_ring in |- *.
split.
red in |- *; auto with zarith.
split. exact Z_group.
split. unfold intern in |- *. intros. exact I.
split; red in |- *; auto with zarith.
Qed.

Theorem Z_unitary_commutative_ring :
 is_unitary_commutative_ring Z IdZ Zplus Zmult 0%Z 1%Z Zopp.
Proof.
unfold is_unitary_commutative_ring in |- *.
split. exact Z_ring.
split.
red in |- *; auto with zarith.
split.
unfold IdZ in |- *; trivial.
split; auto with zarith.
Qed.

Theorem integrityZ : integrity Z Zmult 0%Z.
Proof.
unfold integrity in |- *.
intros a b; elim a.

intros; left; reflexivity.

intros; right.
generalize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.

intros; right.
generalize H; clear H; simpl in |- *; case b; intros; inversion H; trivial.
Qed.

Lemma inversibleZ :
 forall x : Z, inversible Z Zmult 1%Z x -> x = 1%Z \/ x = (-1)%Z.
Proof.
unfold inversible in |- *.
intros.
inversion_clear H.
inversion_clear H0.
clear H1.
generalize H; clear H.

elim (Z_lt_ge_dec 0 x); intros. 
left.
elim (Z_le_lt_eq_dec 1 x); auto with zarith; intros.
cut (1 > x0)%Z; intros.
absurd (0 < x0)%Z; intros; auto with zarith.
apply Zgt_lt.
apply Zmult_gt_0_reg_l with x; auto with zarith.
apply Zmult_gt_reg_r with x; auto with zarith.
rewrite Zmult_1_l; rewrite Zmult_comm; auto with zarith.

elim (Z_le_lt_eq_dec x 0); auto with zarith; intros.
clear b.
right.
elim (Z_le_lt_eq_dec 1 (- x)); auto with zarith; intros.
cut (1 > - x0)%Z; intros.
absurd (0 < - x0)%Z; intros; auto with zarith.
apply Zgt_lt.
apply Zmult_gt_0_reg_l with (- x)%Z; auto with zarith.
rewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r;
 auto with zarith.
apply Zmult_gt_reg_r with (- x)%Z; auto with zarith.
rewrite Zmult_1_l; rewrite Zmult_comm.
rewrite Zopp_mult_distr_l_reverse; rewrite <- Zopp_mult_distr_r;
 auto with zarith.

rewrite b0 in H; simpl in H; inversion H.
Qed.
