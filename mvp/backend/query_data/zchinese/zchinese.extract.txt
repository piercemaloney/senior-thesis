Require Extraction.

Require Import Zgcd.
(* Zgcd:
Require Export misc.
Require Export Zstruct.
Require Export ZArith.
Require Import Omega.
Require Import ZArithRing.
Require Import Zcomplements.
Require Import Zdiv.

Unset Standard Proposition Elimination Names.

Lemma gcd_unicity_apart_sign :
 forall a b c d : Z,
 is_gcd Z IdZ Zmult 0%Z a b c ->
 is_gcd Z IdZ Zmult 0%Z a b d -> d = c \/ d = (- c)%Z.

Lemma gcd_OZ_absZ : forall b : Z, is_gcd Z IdZ Zmult 0%Z 0%Z b (Zabs b).

Inductive is_gcdZ : Z -> Z -> Z -> Prop :=
  | gcd_OZ : forall b : Z, is_gcdZ 0%Z b (Zabs b)
  | gcd_mod :
      forall b a d q r : Z,
      b <> 0%Z ->
      (0 <= r < Zabs b)%Z ->
      a = (b * q + r)%Z -> is_gcdZ r b d -> is_gcdZ b a d.

Definition have_gcdZ (a b : Z) := {d : Z | is_gcdZ a b d}.

Definition gcdZ_i (a b : Z) := exist (is_gcdZ a b).

Definition P (a : Z) := forall b : Z, have_gcdZ a b.

Lemma acc_P : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> P m) -> P n.

Lemma gcdZ_exists : forall a b : Z, have_gcdZ a b.

Lemma gcdZ_is_gcd :
 forall a b d : Z, is_gcdZ a b d -> is_gcd Z IdZ Zmult 0%Z a b d.

Definition gcdZ (a b : Z) := pi1 Z (is_gcdZ a b) (gcdZ_exists a b).

Theorem gcdZ_correct : forall a b : Z, is_gcdZ a b (gcdZ a b).

Lemma positive_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> (0 <= d)%Z.

Lemma unicity_is_gcdZ :
 forall a b c d : Z, is_gcdZ a b c -> is_gcdZ a b d -> d = c.

Lemma gcdZ_is_gcdZ : forall a b d : Z, is_gcdZ a b d -> d = gcdZ a b.

Lemma gcd_modZ :
 forall a b q r : Z,
 b <> 0%Z -> (0 <= r < Zabs b)%Z -> a = (b * q + r)%Z -> gcdZ r b = gcdZ b a. 

Inductive verify_BezoutZ (a b : Z) : Set :=
    Bezout_i :
      forall u v : Z, (a * u + b * v)%Z = gcdZ a b -> verify_BezoutZ a b.

Definition Q (a : Z) := forall b : Z, verify_BezoutZ a b.

Lemma acc_Q : forall n : Z, (forall m : Z, (Zabs m < Zabs n)%Z -> Q m) -> Q n.

Lemma Bezout_exists : forall a b : Z, verify_BezoutZ a b.

Definition congruentZ (x y n : Z) := divide Z IdZ Zmult 0%Z n (x + - y)%Z.

Lemma divide_selfZ : forall x : Z, divide Z IdZ Zmult 0%Z x x.

Theorem chinese_remaindering_theorem :
 forall a b x y : Z,
 gcdZ a b = 1%Z -> {z : Z | congruentZ z x a /\ congruentZ z y b}. *)



Axiom int : Set.

Axiom i2p : int -> positive.

Axiom p2i : positive -> int. 

Axiom i2z : int -> Z.

Axiom z2i : Z -> int. 



Extract Inlined Constant int => "int". 



Extract Constant i2p =>

 "  

  let rec i2p = function 

    1 -> XH 

  | n -> let n' = i2p (n/2) in if (n mod 2)=0 then XO n' else XI n'

  in i2p

".

 

Extract Constant p2i =>

 "

  let rec p2i = function 

    XH -> 1

  | XO p -> 2*(p2i p)

  | XI p -> 2*(p2i p)+1

  in p2i 

".



  Extract Constant i2z =>

   " function 

    0 -> Z0

  | n -> if n < 0 then Zneg (i2p (-n)) else Zpos (i2p n)

"

  

  .

  Extract Constant z2i =>

   "function

    Z0 -> 0 

  | Zpos p -> p2i p

  | Zneg p -> -(p2i p)

"

  .



Set Extraction AccessOpaque.

Extraction "chinese.ml" chinese_remaindering_theorem int i2p p2i z2i i2z.

