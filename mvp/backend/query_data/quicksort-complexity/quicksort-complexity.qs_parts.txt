Set Implicit Arguments.



Require Import util.
(* util:
Set Implicit Arguments.
Global Set Asymmetric Patterns.

Require Import Relations.
Require Export Basics.
Require Import Setoid.

Arguments eq {A}.
Arguments fst {A B}.

Hint Unfold compose.

Definition proj1_conj (A B: Prop) (c: A /\ B): A :=
  match c with conj x _ => x end.

Definition proj2_conj (A B: Prop) (c: A /\ B): B :=
  match c with conj _ x => x end.

Lemma eq_trans (X: Set) (a b c: X): a = b -> b = c -> a = c.

Definition cmp_cmp (x y: comparison): { x = y } + { x <> y } :=
  
  match x, y return { x = y } + { x <> y } with
  | Lt, Lt | Gt, Gt | Eq, Eq => left _ (refl_equal _)
  | a, b => right _ (
      match a, b
      return match a, b with Lt, Lt | Gt, Gt | Eq, Eq => True | _, _ => ~(a = b) end with
      | Lt, Lt | Gt, Gt | Eq, Eq => I
      | Lt, _ => fun q => match q in _ = Lt with refl_equal => I end
      | Gt, _ => fun q => match q in _ = Gt with refl_equal => I end
      | Eq, _ => fun q => match q in _ = Eq with refl_equal => I end
      end
    )
  end. 

Fixpoint nat_cmp (x y: nat) {struct x}: comparison :=
  match x, y with
  | 0, 0 => Eq
  | 0, S _ => Lt
  | S _, 0 => Gt
  | S x', S y' => nat_cmp x' y'
  end.

Ltac cset e := let v := fresh in set (v := e); clearbody v.
Ltac cset' e := let v := fresh in set (v := e) in *; clearbody v.

Ltac extro x := generalize x; clear x.

Definition unsum_bool (A B: Prop) (sb: sumbool A B): bool := if sb then true else false.

Definition decision (P: Prop): Set := { P } + { ~ P }.
Definition predDecider (T: Set) (P: T -> Prop): Type := forall t, decision (P t).

Lemma negb_inv (b b': bool): negb b = negb b' -> b = b'.

Lemma negb_negb (b: bool): negb (negb b) = b.

Definition id {X} (x: X): X := x.

Definition ext_eq {A B: Type} (f g: A -> B): Prop := forall x, f x = g x.

Lemma ext_eq_trans: forall A B, transitive _ (@ext_eq A B).

Lemma ext_eq_refl: forall A B, reflexive _ (@ext_eq A B).

Lemma ext_eq_sym: forall A B, symmetric _ (@ext_eq A B).

Add Parametric Relation X Y: (X -> Y) (@ext_eq X Y)
  reflexivity proved by (@ext_eq_refl X Y)
  symmetry proved by (@ext_eq_sym X Y)
  transitivity proved by (@ext_eq_trans X Y)
    as ext_eq_rel.

Lemma ext_eq_rw (A B: Type) (f g: A -> B): ext_eq f g -> forall x, f x = g x.

Notation " g ∘ f " := (compose g f) (at level 40, left associativity).

Lemma comp_apply (A B C: Set) (f: B -> C) (g: A -> B) (x: A): (f ∘ g) x = f (g x).

Lemma comp_ass (A B C D: Set) (f: A -> B) (g: B -> C) (h: C -> D): h ∘ (g ∘ f) = (h ∘ g) ∘ f.

Definition compose_lunit A B (f: A -> B): ext_eq (@id B ∘ f) f.

Definition compose_runit A B (f: A -> B): ext_eq (f ∘ @id A) f.

Definition map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): C * B := (fst p, f (snd p)).

Lemma fst_map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): fst (map_snd f p) = fst p.

Definition on {A B: Type} {C: B -> B -> Type} (g: A -> B) (f: forall b b', C b b') (x y: A): C (g x) (g y) := f (g x) (g y).

Definition unsumbool {A B}: { A } + { B } -> bool := fun x => if x then true else false.

Definition dep_flip {A B: Type} {C: A -> B -> Type} (f: forall a b, C a b) (b: B) (a: A): C a b := f a b.

Definition uncurry A B C (f: A -> B -> C) (ab: A * B): C := f (fst ab) (snd ab).

Section well_founded_pairs.

  Variables (A B: Type)
    (Ra: relation A) (Rb: relation B).

  Inductive pair_rel: relation (A * B) :=
    | pair_rel_l a a' b: Ra a a' -> pair_rel (a, b) (a', b)
    | pair_rel_r a b b': Rb b b' -> pair_rel (a, b) (a, b').

  Fixpoint acc_pairs a (Aa: Acc Ra a) {struct Aa}: forall b (Ab: Acc Rb b), Acc pair_rel (a, b) :=
    fix G b (Ab: Acc Rb b) {struct Ab}: Acc pair_rel _ := @Acc_intro _ pair_rel _
      match Aa, Ab with
      | Acc_intro x, Acc_intro y =>  fun z (za: pair_rel z (a, b)) =>
          match za in pair_rel z ab return
            (forall (p: A) (q: Ra p (fst ab)), Acc pair_rel (p, (snd ab))) -> (forall p, Rb p (snd ab) -> Acc pair_rel (fst ab, p)) -> Acc pair_rel z with
          | pair_rel_l v w c d => fun fr gr => fr _ d
          | pair_rel_r v w c d => fun fr gr => gr _ d
          end
          (fun (p: A) (q: Ra p (fst (a, b))) => @acc_pairs p (x p q) b Ab : Acc pair_rel (p, b))
          (fun (p: B) (q: Rb p (snd (a, b))) => @G p (y p q): Acc pair_rel (a, p))
      end.

   Lemma well_founded_pairs (Wa: well_founded Ra) (Wb: well_founded Rb): well_founded pair_rel.

End well_founded_pairs. *)

Require Import Le.

Require Import Plus.

Require Import Lt.

Require Import Arith.

Require Import monoid_expec.
(* monoid_expec:
Set Implicit Arguments.

Require Import expec.
Require Import monoid_monad_trans.
Require Import monoid_tree_monad.
Require Import Rdefinitions.
Require Import monads.
Require Import util.
Require Import Bool.
Require Import sums_and_averages.
Require Import List.
Require Import list_utils.
Require Import Rbase.
Require ne_tree_monad.

Arguments fst {A B}.

Definition map_fst (A B C: Set) (f: A -> B) (p: A * C): B * C := (f (fst p), snd p).

Section contents.

  Variables (m: Monoid) (ms: m -> nat).

  Definition monoid_expec {A: Set}:
    MonoidMonadTrans.M m ne_tree_monad.ext A -> R
      := expec (ms ∘ (fst (B:=_:Set))).

  Lemma monoid_expec_bind_leaf (X Y: Set) (f: X -> MonoidMonadTrans.M m ne_tree_monad.ext Y)

  Hypothesis mh: monoidHomo m NatAddMonoid ms.

  Definition monoid_expec_sum (T U: Set)
  (g: T -> MonoidMonadTrans.M m ne_tree_monad.ext U): list T -> R
    := Rsum ∘ map (monoid_expec ∘ g).

  Lemma monoid_expec_sum_ext (T U: Set)
    (f g: T -> MonoidMonadTrans.M m ne_tree_monad.ext U):

  Lemma monoid_expec_Node_map (A B: Set) (f: A -> MonoidMonadTrans.M m ne_tree_monad.ext B) (l: ne_list.L A):

  Lemma monoid_expec_ret (A: Set) (a: A): monoid_expec (ret a) = 0.

  Lemma monoid_expec_bind_leaf_plus (X Y: Set) (f: X -> MonoidMonadTrans.M m ne_tree_monad.ext Y)

  Lemma monoid_expec_bind_det (X: Set) (v: prod m X) (x: MonoidMonadTrans.M m ne_tree_monad.ext X):

  Hint Resolve ne_tree.In_head.

  Lemma monoid_expec_plus (A B: Set)
    (f: MonoidMonadTrans.M m ne_tree_monad.ext A)

  Lemma monoid_expec_map_fst_monoid_mult (A: Set) (g: m) (t: MonoidMonadTrans.M m ne_tree_monad.ext A):

  Lemma monoid_expec_bind_0_r (A B: Set)
    (g: A -> MonoidMonadTrans.M m ne_tree_monad.ext B)

End contents. *)

Require Import List.

Require Import monads.
(* monads:
Global Set Automatic Coercions Import.
Set Implicit Arguments.

Require Import List.
Require Import list_utils.
Require Import util.

Record Monad: Type :=
  { mon:> Set -> Set
  ; bind: forall a b, mon a -> (a -> mon b) -> mon b
  ; ret: forall (a: Set), a -> mon a
  
  ; mon_lunit: forall (a b: Set) (x: a) (f: a -> mon b), bind (ret x) f = f x
      
  ; mon_runit: forall (a: Set) (f: mon a), bind f (@ret a) = f
      
  ; mon_assoc: forall a b c (n: mon a) (f: a -> mon b) (g: b -> mon c),
      bind (bind n f) g =
      bind n (fun x => bind (f x) g)
      
  }.

Arguments bind [m a b].
Arguments ret {m a}.

Notation "x >>= y" := (bind x y) (at level 55).
Notation "x >> y" := (bind x (fun _ => y)) (at level 30, right associativity).
Notation "x <- y ; z" := (bind y (fun x : _ => z)) (at level 30, right associativity).

Record Functor: Type :=
  { func: Set -> Set
  ; func_map: forall (a b: Set) (f: a -> b), func a -> func b
  
  ; func_id: forall (X: Set), func_map (fun (x: X) => x) = (fun (x: func X) => x)
        
  ; func_assoc: forall (a b c: Set) (x: func a) (f: b -> c) (g: a -> b),
      func_map (f ∘ g) x = func_map f (func_map g x)
        
  }.

Arguments func_map [f a b].

Definition extMonad (M: Monad): Prop := forall (A B: Set) (f g: A -> M B), ext_eq f g -> forall x, bind x f = bind x g.

Lemma bind_eqq (M: Monad) (e: extMonad M) (A B: Set) (m n: M A) (f g: A -> M B):
  m = n -> ext_eq f g -> (m >>= f) = (n >>= g).

Definition extFlipped (M: Monad): extMonad M -> forall A (x: M A) (B: Set) (f g: A -> M B), ext_eq f g -> bind x f = bind x g.

Lemma mon_lunit_under_bind (M: Monad) (A B C: Set) (a: M A) (b: A -> B) (f: A -> B -> M C):
  extMonad M -> (x <- a ; (ret (b x) >>= f x)) = (x <- a ; f x (b x)).

Section MonadFunctor. 

  Variable M: Monad.

  Definition bind_map (a b: Set) (f: a -> b) (x: M a): M b :=
    xv <- x ;
    ret (f xv).

  Hypothesis f_ext_eq: forall A B (f g: A -> B), (forall x, f x = g x) -> f = g.

  Lemma eta A B (f: A -> B): (fun x => f x) = f.

  Definition MonadFunctor: Functor.

  Definition a_monad_isa_functor T (x: M T): func MonadFunctor T := x.
    End MonadFunctor.

Module IdMonad.

  Definition C (s: Set): Set := s. 

  Definition bind A B (x: C A) (y: A -> C B): C B := y x.
  Definition ret (A: Set) (x: A): C A := x.

  Definition M: Monad.

  Coercion id_isa_monad A (a: C A): M A := a.

  Lemma ext: extMonad M.

End IdMonad.

Unset Elimination Schemes.

Inductive Tree (A: Set): Set :=
  | Leaf: A -> Tree A
  | Node: list (Tree A) -> Tree A.

Set Elimination Schemes.

Definition Tree_ind
  : forall (A: Set) (P : Tree A -> Prop),
    (forall n : A, P (Leaf n)) ->
    (forall l : list (Tree A), (forall t, In t l -> P t) -> P (Node l)) ->
  forall t, P t.

Section MonadToys.

  Definition liftM (A B: Set) (f: A -> B) (M: Monad) (x: M A): M B :=
    xv <- x ; ret (f xv).

  Definition liftM2 (A B C: Set) (f: A -> B -> C) (M: Monad) (x: M A) (y: M B): M C :=
    xv <- x ; yv <- y ; ret (f xv yv).

  Fixpoint foldlM {A B: Set} {M: Monad} (f: A -> B -> M A) (x: A) (l: list B) {struct l}: M A :=
    match l with
    | nil => ret x
    | h :: t => fax <- f x h ; foldlM f fax t
    end. 

  Fixpoint foldrM {A B: Set} {M: Monad} (f: B -> A -> M A) (x: A) (l: list B) {struct l}: M A :=
    match l with
    | nil => ret x
    | h :: t => t' <- foldrM f x t; f h t'
    end. 

  Lemma foldlM_cons (A B: Set) (M: Monad) (f: A -> B -> M A) (x: A) (h: B) (t: list B):
    foldlM f x (h :: t) = fax <- f x h ; foldlM f fax t.

  Fixpoint filterM {A: Set} {M: Monad} (p: A -> M bool) (l: list A): M (list A) :=
    match l with
    | nil => ret nil
    | h :: t =>
      b <- p h ;
      t' <- filterM p t ;
      ret (if b then h :: t' else t')
    end. 

  Lemma filterM_id (A: Set) (p: A -> IdMonad.M bool) (l: list A): filter p l = filterM p l.

End MonadToys.

Arguments liftM [A B] _ [M].

Record MonadTrans: Type :=
  { transMonad: forall (m: Monad), extMonad m -> Monad
  ; lift: forall (m: Monad) (e: extMonad m) (A: Set), m A -> transMonad e A
  }. *)

Require Import list_utils.
(* list_utils:
Set Implicit Arguments.
Unset Standard Proposition Elimination Names.

Require Export List.

Require Import
  Program Omega Factorial
  Bool util Morphisms Relations RelationClasses Permutation.

Hint Resolve
  in_map Permutation_refl.

Hint Constructors NoDup.

Hint Constructors
  NoDup Permutation.

Arguments length {A}.
Arguments Permutation {A}.
Arguments map {A B}.
Arguments tail {A}.

Section count.

  Context {X: Type} (p: X -> bool).

  Fixpoint count (l: list X): nat :=
    match l with
    | nil => 0
    | h :: t => if p h then S (count t) else count t
    end.

  Lemma count_app l l': count (l ++ l') = count l + count l'.

  Lemma count_0 l: (forall x, In x l -> p x = false) -> count l = 0.

  Lemma count_le l: count l <= length l.

  Lemma count_filter_le (f: X -> bool) x: count (filter f x) <= count x.

  Hint Resolve count_le.

  Lemma count_lt v l: In v l -> p v = false -> count l < length l.

End count.

Hint Resolve @count_le.

Lemma NoDup_map_inv' A B (f: A -> B) (l: list A): NoDup (map f l) -> NoDup l.

Lemma length_filter X (p: X -> bool) (l: list X): length (filter p l) = count p l.

Lemma length_filter_le T (p: T -> bool) (l: list T): length (filter p l) <= length l.

Lemma filter_all X (p: X -> bool) (l: list X):
  (forall x, In x l -> p x = true) -> filter p l = l.

Lemma In_filter T (p: T -> bool) (t: T): p t = true -> forall l, In t l -> In t (filter p l).

Lemma incl_filter X (p: X -> bool) (l: list X): incl (filter p l) l.

Lemma incl_trans A (x y: list A): incl x y -> forall z, incl y z -> incl x z.

Hint Resolve incl_filter.

Lemma filter_preserves_incl X (p: X -> bool) (a b: list X): incl a b -> incl (filter p a) (filter p b).

Hint Resolve filter_preserves_incl.

Lemma In_inv_perm X (x: X) (l: list X):
  In x l -> exists l', Permutation (x :: l') l.

Lemma In_map_inv T U (f: T -> U) (l: list T) (y: U): In y (map f l) -> exists x, f x = y /\ In x l.

Hint Resolve incl_tran.

Lemma Permutation_incl X (a b: list X): Permutation a b -> incl a b.

Lemma pointwise_eq_refl A B (x: A -> B): pointwise_relation A eq x x.

Lemma complementary_filter_perm A (p: A -> bool) (l: list A):
  Permutation l (filter p l ++ filter (negb ∘ p) l).

Lemma filter_none X (p: X -> bool) (l: list X): (forall x, In x l -> p x = false) <-> filter p l = nil.

Lemma incl_map X Y (f: X -> Y) (a b: list X): incl a b -> incl (map f a) (map f b).

Lemma incl_in T (a b: list T): incl a b -> forall x, In x a -> In x b.

Lemma incl_In X (x: X) (l: list X): In x l -> forall l', incl l l' -> In x l'.

Lemma NoDup_filter T (p: T -> bool) (l: list T):
  NoDup l -> NoDup (filter p l).

Lemma length_excl_counts X (p: X -> bool) (l: list X):
  length l = count p l + count (negb ∘ p) l.

Lemma count_filtered X (p q: X -> bool):
  (forall x, q x = true -> p x = false) ->
  forall l, count p (filter q l) = 0.

Lemma app_nil_r T (l: list T): l ++ nil = l.

Hint Resolve Permutation_map.

Lemma map_cons T U (f: T -> U) (h: T) (l: list T): map f (h :: l) = f h :: map f l.

Definition concat {T}: list (list T) -> list T := fold_right (@app _) nil.

Lemma concat_app T (x y: list (list T)): concat (x ++ y) = concat x ++ concat y.

Lemma In_concat X (l: list (list X)) (s: list X) (x: X): In x s -> In s l -> In x (concat l).

Lemma In_concat_inv X (x: X) (l: list (list X)):
  In x (concat l) -> exists s, In x s /\ In s l.

Definition eq_count X (d: forall (x y: X), { x = y } + { x <> y }) (x: X): list X -> nat :=
 count (fun y => unsum_bool (d x y)).

Lemma eq_count_0 X (d: forall (x y: X), { x = y } + { x <> y }) (x: X) l:
  ~ In x l -> eq_count d x l = 0%nat.

Lemma eq_count_NoDup X (d: forall (x y: X), { x = y } + { x <> y }) (x: X) l:
  NoDup l -> eq_count d x l <= 1.

Lemma NoDup_incl_Permutation A (a b: list A):
  length a = length b -> NoDup a -> incl a b -> Permutation a b.

Lemma NoDup_map' A B (f: A -> B) (l: list A):
  (forall x y: A, In x l -> In y l -> x <> y -> f x <> f y) ->
  NoDup l -> NoDup (map f l).

Lemma NoDup_map A B (f: A -> B) l:
  (forall x y, In x l -> In y l -> f x = f y -> x = y) -> NoDup l -> NoDup (map f l).

Inductive InP (X: Type) (P: X -> Prop): list X -> Prop :=
  | InP_head x t: P x -> InP P (x :: t)
  | InP_tail x t: InP P t -> InP P (x :: t).

Inductive NoDupL (A: Type): list (list A) -> Prop :=
  | NoDupL_nil: NoDupL nil
  | NoDupL_cons (l: list A) (ll: list (list A)): NoDup l ->
      (forall x, In x l -> ~ InP (In x) ll) -> NoDupL ll -> NoDupL (l :: ll).

Hint Constructors NoDupL.

Lemma InP_In (X: Type) (l: list X) (ll: list (list X)): In l ll -> forall x, In x l -> InP (In x) ll.

Lemma InP_In_inv X (x: X) (ll: list (list X)):
  InP (In x) ll -> exists l, In x l /\ In l ll.

Arguments InP_In_inv [X x ll].

Lemma NoDup_concat A (l: list (list A)): NoDupL l -> NoDup (concat l).

Lemma In_filter_inv A (f: A -> bool) (x: A) (l: list A): In x (filter f l) -> In x l /\ f x = true.

Section Partitioning.

  Variable T: Set.

  Definition Partitioning: Set := comparison -> list T.

  Lemma partition_oblig c l h
    (H: {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) l}):
    Permutation
      ((if cmp_cmp c Eq then h :: proj1_sig H Eq else proj1_sig H Eq) ++
      (if cmp_cmp c Lt then h :: proj1_sig H Lt else proj1_sig H Lt) ++
      (if cmp_cmp c Gt then h :: proj1_sig H Gt else proj1_sig H Gt))
      (h :: l).

  Definition addToPartitioning (c: comparison) (l: list T) (h: T) (H: {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) l}): {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) (h :: l)} :=
    exist (fun p => Permutation (p Eq ++ p Lt ++ p Gt) (h :: l))
      (fun c' => if cmp_cmp c c' then h :: proj1_sig H c' else proj1_sig H c')
      (partition_oblig c h H).

  Definition emp: {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) nil} :=
    exist (fun p => Permutation (p Eq ++ p Lt ++ p Gt) nil) (fun _ => nil) (perm_nil T).

End Partitioning.

Fixpoint repeat T (n: nat) (x: T): list T :=
  match n with
  | 0 => nil
  | S n' => x :: repeat n' x
  end.

Lemma map_concat T U (l: list (list T)) (f: T -> U): map f (concat l) = concat (map (map f) l).

Lemma length_0_nil A (l: list A): length l = 0%nat <-> l = nil.

Lemma length_ne_0_ne_nil A (l: list A): length l <> 0%nat -> l <> nil.

Lemma elemsR_le_S a b: elemsR le a b -> elemsR le (map S a) (map S b).

Lemma elemsR_map A (R: relation A) f l:
  (forall x, In x l -> R (f x) x) -> elemsR R (map f l) l.

Lemma elemsR_map_map (X Y: Type) (f g: Y -> X) (l: list Y) (R: relation X): (forall x, In x l -> R (f x) (g x)) -> elemsR R (map f l) (map g l).

Lemma elemsR_impl A (R R' : relation A): (forall x y: A, R x y -> R' x y) -> forall l l', elemsR R l l' -> elemsR R' l l'.

Section Permuted.

  Context {A: Type} (R: relation A).

  Inductive Permuted: relation (list A) :=
    | permuted_nil : Permuted nil nil
    | permuted_skip : forall (x x': A), R x x' -> forall (l l' : list A), Permuted l l' -> Permuted (x :: l) (x' :: l')
    | permuted_swap : forall (x y: A) (l: list A), Permuted (y :: x :: l) (x :: y :: l)
    | permuted_trans : forall l l' l'' : list A, Permuted l l' -> Permuted l' l'' -> Permuted l l''.

  Hint Constructors Permuted.

  Context {Rrefl: Reflexive R}.

  Lemma permuted_refl l: Permuted l l.

  Hint Immediate permuted_refl.

  Lemma elemsR_permuted l l': elemsR R l l' -> Permuted l l'.

  Lemma alt_permuted_swap (x x' y y': A): R x x' -> R y y' ->
    forall (l l': list A), elemsR R l l' -> Permuted (y :: x :: l) (x' :: y' :: l').

End Permuted.

Hint Constructors Permuted.

Lemma map_map_comp A B C (f: A -> B) (g: B -> C) (l: list A):
  map g (map f l) = map (g ∘ f) l.

Lemma concat_map_singleton A (l: list A): concat (map (fun x => x :: nil) l) = l.

Lemma Permuted_sub A (R: relation A) x y: Permuted R x y -> forall (R': relation A), (forall x y, R x y -> R' x y) -> Permuted R' x y.

Lemma Permuted_map A B (R: relation B) (f: A -> B): Proper (Permuted (on f R) ==> Permuted R) (map f).

Definition add := fold_right plus (0%nat).

Lemma add_same c l: (forall x, In x l -> x = c) -> add l = length l * c.

Lemma length_concat T (l: list (list T)):
  length (concat l) = add (map (@length _) l).

Lemma concat_map_nil T U (l: list T): concat (map (fun _ => nil) l) = @nil U.

Definition product A B (aa: list A) (bb: list B): list (A * B) :=
  concat (map (fun a => map (pair a) bb) aa).

Lemma concat_map_singleton_f T A (f: A -> T) l: concat (map (fun x : A => (f x)::nil) l) = map f l.

Lemma map_concat_map T U V (g: T -> list U) (f: U -> V) l:
  map f (concat (map g l)) = concat (map (map f ∘ g) l).

Lemma concat_concat T (x: list (list (list T))):
  concat (concat x) = concat (map concat x).

Section two_lists_rect.

  Variables (T: Type) (P: list T -> list T -> Type)
    (Pnil_l: forall x, P nil x) (Pnil_r: forall x, P x nil)
    (Pcons: forall x x' y y', P x' (y :: y') -> P (x :: x') y' -> P (x :: x') (y :: y')).

  Let R: relation (list T * list T) := pair_rel (ltof (list T) (@length _)) (ltof (list T) (@length _)).

  Let wf_R: well_founded R.

  Lemma two_lists_rect_pre (p: list T * list T): P (fst p) (snd p).

  Definition two_lists_rect x y: P x y := two_lists_rect_pre (x, y).

Instance map_Permutation_mor T U (f: T -> U): Proper (Permutation ==> Permutation) (map f) :=
  Permutation_map f.

Lemma concatMap_concatMap' T U V (g: T -> list U) (f: U -> list V) l:
  concat (map f (concat (map g l))) = concat (map (concat ∘ map f ∘ g) l).

Lemma Permutation_concatMap T U (f g: T -> list U) l:
  (forall x, In x l -> Permutation (f x) (g x)) ->
  Permutation (concat (map f l)) (concat (map g l)).

Hint Resolve Permutation_concat.

Lemma Permutation_concat_map_app T A (f g: A -> list T) l:
  Permutation (concat (map (fun x => f x ++ g x) l)) (concat (map f l ++ map g l)).

Lemma concat_product T U V (f: U -> T -> list V) l l':
  Permutation
    (concat (map (fun x => concat (map (fun y => f y x) l')) l))
    (concat (map (fun x => concat (map (f x) l)) l')).

Section splits_and_perms.

  Context {T: Type}.

  Fixpoint splits (l: list T): list (T * list T) :=
    match l with
    | nil => nil
    | h :: t => (h, t) :: map (fun xy => (fst xy, h :: snd xy)) (splits t)
    end.

  Lemma length_splits l: length (splits l) = length l.

  Lemma splits_are_perms l p: In p (splits l) -> Permutation (fst p :: snd p) l.

  Lemma length_in_splits l p: In p (splits l) -> S (length (snd p)) = length l.

  Fixpoint insert_everywhere (x: T) (l: list T): list (list T) :=
    match l with
    | nil => (x :: nil) :: nil
    | h :: t => (x :: h :: t) :: map (cons h) (insert_everywhere x t)
    end.

  Lemma insert_everywhere_are_perms x l:
    forall y, In y (insert_everywhere x l) -> Permutation y (x :: l).

  Lemma length_insert_everywhere x l:
    length (insert_everywhere x l) = S (length l).

  Definition perms: list T -> list (list T)
    := fold_right (fun h => concat ∘ map (insert_everywhere h)) (nil :: nil).

  Lemma perms_are_perms l a: In a (perms l) -> Permutation a l.

  Lemma length_perms l: length (perms l) = fact (length l).

  Definition alt_perms l: list (list T) :=
    match l with
    | nil => nil :: nil
    | _ => concat (map (fun p => (map (cons (fst p)) (perms (snd p)))) (splits l))
    end.

  Lemma splits_permuted (l l': list T): Permutation l l' ->
    Permuted (fun x y => fst x = fst y /\ Permutation (snd x) (snd y)) (splits l) (splits l').

  Inductive merges_spec: list T -> list T -> list (list T) -> Prop :=
    | merges_left_nil x: merges_spec nil x (x :: nil)
    | merges_right_nil x: merges_spec x nil (x :: nil)
    | merges_cons x y h t r r':
      merges_spec y (h :: t) r ->
      merges_spec (x :: y) t r' ->
      merges_spec (x :: y) (h :: t) (map (cons x) r ++ map (cons h) r').

  Hint Constructors merges_spec.

  Lemma merges_uniq a b r:
    merges_spec a b r ->
    forall r', merges_spec a b r' -> r = r'.

  Lemma length_merges (F: nat -> nat -> nat) a b r:
    (forall n, F 0 n = 1) ->
    (forall n, F n 0 = 1) ->
    (forall n n', F n (S n') + F (S n) n' = F (S n) (S n')) ->
    merges_spec a b r -> length r = F (length a) (length b).

  Definition me (ab: list T * list T): nat := length (fst ab) + length (snd ab).

  Program Fixpoint merges_ex (ab: list T * list T) {measure (me ab)}: sig (merges_spec (fst ab) (snd ab)) :=
    match ab with
    | (nil, x) => x :: nil
    | (x, nil) => x :: nil
    | (x :: y, h :: t) => map (cons x) (merges_ex (y, h :: t)) ++ map (cons h) (merges_ex (x :: y, t))
    end.

  Definition merges (a b: list T): list (list T) := proj1_sig (merges_ex (a, b)).

  Lemma merges_real_eq a b: merges a b =
    match a, b with
    | nil, x => x :: nil
    | x, nil => x :: nil
    | x :: y, h :: t => map (cons x) (merges y (h :: t)) ++ map (cons h) (merges (x :: y) t)
    end.

  Lemma merges_nil_r a: merges a [] = [a].

  Hint Resolve Permutation_concat.

  Lemma product_app: forall T (a b c: list T), product (a ++ b) c = product a c ++ product b c.

  Lemma product_concat: forall T (a: list (list T)) (b: list T), product (concat a) b = concat (map (flip (@product _ _) b) a).

  Lemma concatMap_insert_everywhere_comm x y l: Permutation
    (concat (map (insert_everywhere x) (insert_everywhere y l)))
    (concat (map (insert_everywhere y) (insert_everywhere x l))).

  Lemma merges_insert_everywhere a l: insert_everywhere a l = merges (a :: nil) l.

  Lemma merges_insert_everywhere' a l: Permutation (insert_everywhere a l) (merges l (a :: nil)).

  Lemma insert_everywhere_merges_commute a x y: Permutation
    (concat (map (insert_everywhere a) (merges y x)))
    (concat (map (merges y) (insert_everywhere a x))).

  Lemma merges_sym x y: Permutation (merges x y) (merges y x).

  Hint Immediate merges_sym.

  Lemma perms_app (a b: list T): Permutation (perms (a ++ b)) (concat (map (uncurry merges) (product (perms a) (perms b)))).

  Lemma filter_merges p (x y: list T):
     (forall z, In z x -> p z = true) ->
     (forall z, In z y -> p z = false) ->
     forall r, In r (map (filter p) (merges x y)) -> r = x.

  Lemma merges_ne_nil x y: merges x y <> nil.

End splits_and_perms.

Existing Instance Permutation_perms.

Lemma map_repeat A B (f: A -> B) c (l: list A):
  (forall x, In x l -> f x = c) -> map f l = repeat (length l) c.

Lemma repeat_plus T (c: T) n m: repeat (n + m) c = repeat n c ++ repeat m c.

Lemma concat_repeat T n m (c: T): concat (repeat n (repeat m c)) = repeat (n * m) c.

Lemma filter_perms T p (l: list T):
  Permutation
    (map (filter p) (perms l))
    (concat (map (repeat (fact (length (filter (negb ∘ p) l)) * length (merges (filter p l) (filter (negb ∘ p) l)))) (perms (filter p l)))).

Instance Permutation_length_morphism T: Proper (Permutation ==> eq) (@length T) :=
  @Permutation_length T.

Lemma repeat_map_comm A B (f: A -> B) n: ext_eq (map f ∘ repeat n) (repeat n ∘ f).

Lemma length_repeat T (c: T) n: length (repeat n c) = n.

Lemma concat_nil X (l: list (list X)): (forall x, In x l -> x = nil) -> concat l = nil.

Lemma empty_nil X (x: list X): length x = 0%nat -> x = nil.

Lemma Permuted_Permutation_map T U (R: relation T) (f: T -> U):
  (forall x y, R x y -> f x = f y) -> forall a b,
  Permuted R a b ->
  Permutation (map f a) (map f b).

Lemma elemsR_length A (R: A -> A -> Prop) a b (H: elemsR R a b):
  length a = length b.

Lemma elemsRimpl A B (R: A -> B -> Prop) (l: list A): (forall x, In x l -> sig (R x)) -> sig (elemsR R l).

Lemma elemsRuniq A B (R: A -> B -> Prop) (l: list A):
  (forall x, In x l -> forall y, R x y -> forall y', R x y' -> y = y') -> forall r, elemsR R l r -> forall r', elemsR R l r' -> r = r'.

Definition triple0 A B C (t: A * B * C): A := fst (fst t).
Definition triple1 A B C (t: A * B * C): B := snd (fst t).
Definition triple2 A B C (t: A * B * C): C := snd t.

Fixpoint rsplits T (l: list T): list (list T * T * list T) :=
  match l with
  | nil => nil
  | h :: t => (nil, h, t) :: map (fun p => (h :: triple0 p, triple1 p, triple2 p)) (rsplits t)
  end.

Lemma splits_rsplits (T: Set) (l: list T): splits l = map (fun p => (triple1 p, triple0 p ++ triple2 p)) (rsplits l).

Lemma insert_everywhere_rsplits (T: Set) (x: T) (l: list T):
  insert_everywhere x l =
   map (fun x0 => triple0 x0 ++ x :: triple1 x0 :: triple2 x0) (rsplits l) ++ [l ++ [x]].

Lemma elemsR_map':
  forall (A B: Type) (Ra: relation A) (Rb: relation B) (f : A -> B)
    (fR: forall x y, Ra x y -> Rb (f x) (f y)) (l l': list A),
      elemsR Ra l l' -> elemsR Rb (map f l) (map f l').

Lemma concatMap_insert_everywhere T (x: T) (l: list (list T)):
  Permutation
    (concat (map (insert_everywhere x) l))
    (map (cons x) l ++ concat (map (tail ∘ insert_everywhere x) l)).

Lemma map_length_filter_permuted_splits T (l l': list T): Permutation l l' ->
  forall p,
  Permutation
    (map (fun x => length (filter (p (fst x)) (snd x))) (splits l))
    (map (fun x => length (filter (p (fst x)) (snd x))) (splits l')).

Lemma perms_alt_perms T (l: list T): Permutation (perms l) (alt_perms l).

Lemma map_single A B (f: A -> B) x: map f [x] = [f x]. *)

Require Import Coq.Program.Wf.

Require Import monoid_monad_trans.
(* monoid_monad_trans:
Set Implicit Arguments.

Require Import util.
Require list_utils.
Require Import List.
Require Import monads.

Record Monoid: Type :=
  { monoid_type:> Set
  ; monoid_zero: monoid_type
  ; monoid_mult: monoid_type -> monoid_type -> monoid_type
  ; monoid_lunit: forall x, monoid_mult monoid_zero x = x
  ; monoid_runit: forall x, monoid_mult x monoid_zero = x
  ; monoid_assoc: forall x y z, monoid_mult (monoid_mult x y) z = monoid_mult x (monoid_mult y z)
  }.

Record monoidHomo (m n: Monoid) (f: m -> n): Prop :=
  { monoidHomo_zero: f (monoid_zero m) = (monoid_zero n)
  ; monoidHomo_mult: forall x y, f (monoid_mult m x y) = monoid_mult n (f x) (f y)
  }.

Lemma monoidHomo_refl (m: Monoid): monoidHomo m m (fun x => x).

Module MonoidMonadTrans.
Section MonoidMonadTrans.

  Variable monoid: Monoid.

  Section NewMonad.

    Variable monad: Monad.
    Hypothesis ext: extMonad monad.

    Let C_MMT (T: Set): Set := monad (prod monoid T).

    Let bind_MMT (A B: Set) (a: C_MMT A) (ab: A -> C_MMT B): C_MMT B :=
      x <- a ; y <- ab (snd x) ;
      ret (monoid_mult monoid (fst x) (fst y), snd y).

    Let ret_MMT (T: Set): T -> C_MMT T := ret ∘ pair (monoid_zero monoid).

    Definition M: Monad.

    Lemma bind_toLower' (X V: Set) (f: M V) (g: V -> M X):
      f >>= g =
        x <- f: monad (prod monoid V);
        ((g (snd x): monad (prod monoid X)) >>=
          (ret ∘ (fun q => (monoid_mult monoid (fst x) (fst q), snd q)))).

    Lemma bind_toLower (X V: Set) (f: M V) (g: V -> M X):
      f >>= g =
        x <- f: monad (prod monoid V);
        y <- g (snd x): monad (prod monoid X);
        ret (m:=monad) (monoid_mult monoid (fst x) (fst y), snd y).

    Definition ret_toLower (X: Set) (x: X): @ret M X x = ret (m:=monad) (monoid_zero monoid, x).

    Lemma mon_toLower: forall X, M X = monad (prod monoid X).

    Lemma Mext: extMonad M.

    Definition lift (A: Set) (a: monad A): M A := a >>= (ret ∘ pair (monoid_zero monoid)).

  End NewMonad.

  Definition T: MonadTrans := Build_MonadTrans M lift.

End MonoidMonadTrans.
End MonoidMonadTrans.

Definition NatAddMonoid: Monoid.

Definition SimplyProfiled: Monad := MonoidMonadTrans.M NatAddMonoid IdMonad.ext.

Definition cost {X: Set}: prod nat X -> nat := @fst _ _.
Definition result X: SimplyProfiled X -> X := @snd _ _.

Lemma bind_cost (T U: Set) (a: SimplyProfiled T) (b: T -> SimplyProfiled U):
  cost (bind a b) = cost a + cost (b (result a)).

Lemma return_cost (T: Set) (x: T): cost (@ret SimplyProfiled T x) = 0.

Lemma SimplyProfiled_ext: extMonad SimplyProfiled.

Module ListMonoid.
Section ListMonoid.

  Variable T: Set.

  Definition M: Monoid :=
    Build_Monoid (@nil T) (@app T) (@refl_equal (list T)) (@list_utils.app_nil_r T) (@app_ass T).

End ListMonoid.
End ListMonoid. *)

Require Import nat_seqs.
(* nat_seqs:
Set Implicit Arguments.
Unset Automatic Introduction.

Require Import List.
Require Import Lt.
Require Import Le.
Require Import util.
Require Import list_utils.
Require Import Omega.
Require Import arith_lems.

Fixpoint nats (b: nat) (w: nat) {struct w}: list nat :=
  match w with
  | 0 => nil
  | S w' => b :: nats (S b) w'
  end.

Lemma nats_length (w b: nat): length (nats b w) = w.

Lemma In_nats (w x b: nat): b <= x -> x < b + w -> In x (nats b w).

Lemma In_nats_inv (w x b: nat): In x (nats b w) -> b <= x < b + w.

Lemma NoDup_nats (w b: nat): NoDup (nats b w).

Lemma nats_plus y x z: nats x (y + z) = nats x y ++ nats (y + x) z.

Lemma nats_Sw b w: nats b (S w) = b :: nats (S b) w.

Lemma nats_split (w b i: nat): i <= w -> nats b w = nats b i ++ nats (b + i) (w - i).

Lemma nats_Sw' w b: nats b (S w) = nats b w ++ (w + b :: nil).

Lemma split_pow2_range n:
  nats 1 (pow 2 n) = 1 :: concat (map (fun x => nats (pow 2 x + 1) (pow 2 x)) (nats 0 n)).

Lemma nats_Sb w b: nats (S b) w = map S (nats b w).

Require Import Relations.
Require vec.

Lemma filtered_sort (T: Set) (R: relation T) (P: preorder T R) (p: T -> T -> bool) (pc: forall x y, p y x = true -> ~ R y x) (l: list T): vec.sorted R l -> *)

Require Import monoid_tree_monad.
(* monoid_tree_monad:
Set Implicit Arguments.

Require Import List.
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import Arith.
Require Import monads.
Require Import util.
Require Import monoid_monad_trans.
Require Import sums_and_averages.
Require Import Rbase.
Require Import Fourier.
Require ne_tree_monad.

Section contents.

  Variable m: Monoid.
  Variable X: Set.

  Definition pick (l: ne_list.L X): MonoidMonadTrans.M m ne_tree_monad.ext X
    := lift (MonoidMonadTrans.T m) ne_tree_monad.ext X (ne_tree_monad.pick l).

  Lemma pick_toLower:
    ext_eq pick (@ne_tree_monad.pick _ ∘ ne_list.map (pair (monoid_zero m))).

  Lemma In_pick_inv (l: ne_list.L X) (r: prod m X):

End contents. *)

Require qs_definitions.

Require fix_measure_utils.

Require Import nat_below.
(* nat_below:
Global Set Automatic Coercions Import.
Set Implicit Arguments.

Require Import Arith.
Require Compare_dec.
Require EqNat.
Require Import Omega.

Fixpoint cond_eq (T: nat -> Set) n m {struct n}: forall c, T (c + n) -> T (c + m) -> Prop :=
  match n, m return forall c, T (c + n) -> T (c + m) -> Prop with
  | 0, 0 => fun c x y => x = y
  | S n', S m' => fun c x y => cond_eq T n' m' (S c)
      (eq_rec_r T x (plus_n_Sm c n'))
      (eq_rec_r T y (plus_n_Sm c m'))
  | _, _ => fun _ _ _ => True
  end.

Lemma cond_eq_eq (T: nat -> Set) n c (x y: T (c + n)): cond_eq T n n c x y = (x = y).

Lemma cond_eq_neq (T: nat -> Set) n m c (x: T (c + n)) (y: T (c + m)): n <> m -> cond_eq T n m c x y = True.

Inductive natBelow: nat -> Set := mkNatBelow (v p: nat): natBelow (S (v + p)).

Definition nb_val {n: nat} (nb: natBelow n): nat := match nb with mkNatBelow m _ => m end.

Coercion nb_val: natBelow >-> nat.

Lemma natBelow_unique n (x y: natBelow n): nb_val x = nb_val y -> x = y.

Lemma natBelow_uneq n (x y: natBelow n): nb_val x <> nb_val y -> x <> y.

Lemma natBelow_eq_dec n (x y: natBelow n): { x = y } + { x <> y }.

Definition nb0 n: natBelow (S n) := mkNatBelow 0 n.

Definition Snb n (nb: natBelow n): natBelow (S n) :=
  match nb in (natBelow n0) return (natBelow (S n0)) with
  | mkNatBelow v p => mkNatBelow (S v) p
  end. *)

Require Coq.Vectors.Vector.



Import qs_definitions.mon_nondet.



Set Shrink Obligations.



Section contents.



  Variable M: Monad.



  Variables (X: Set) (pick: forall T: Set, ne_list.L T -> M T) (cmp: X -> X -> M comparison).



  Definition lowRecPart n (t: Vector.t X (S n)) (i: natBelow (S n)) (part: {p: Partitioning X |

          Permutation.Permutation (p Eq ++ p Lt ++ p Gt) (vec.remove t i)}) :=

    low <- qs cmp pick (proj1_sig part Lt);

    upp <- qs cmp pick (proj1_sig part Gt);

    ret (low ++ vec.nth t i :: proj1_sig part Eq ++ upp).



  Definition partitionPart n (t: Vector.t X (S n)) (i: natBelow (S n))

    := partition M cmp (vec.nth t i) (vec.remove t i) >>= lowRecPart t i.



  Definition selectPivotPart n (t: Vector.t X (S n)) := pick (ne_list.from_vec (vec.nats 0 (S n))) >>= partitionPart t.



  Lemma selectPivotPart_eq n m (t: Vector.t X (S n)) (t': Vector.t X (S m)): vec.to_list t = vec.to_list t' ->

    selectPivotPart t = selectPivotPart t'.

  Proof with auto.

    intros.

    pose proof (vec.length t).

    rewrite H in H0.

    rewrite vec.length in H0.

    inversion H0.

    subst. clear H0.

    rewrite (vec.eq_as_lists t t')...

  Qed.



  Definition body n (v: Vector.t X n) :=

    match v with

    | Vector.nil => ret nil

    | l => selectPivotPart l

    end.



  Definition raw_body (l0: list X) (qs: {l': list X | length l' < length l0} -> M (list X)) :=

    match l0 as l1 return (l1 = l0 -> M (list X)) with

    | nil => fun _ => ret nil

    | h :: t => fun e =>

      i <- pick (ne_list.from_vec (vec.nats 0 (length (h :: t))));

      part <- partition M cmp (vec.nth (h :: t) i) (vec.remove (h :: t) i);

      low <- qs (exist (fun l': list X => length l' < length l0) (proj1_sig part Lt) (qs_definitions.mon_nondet.qs_obligation_1 M (fun l H => qs (exist _ l H)) e i part));

      upp <- qs (exist (fun l': list X => length l' < length l0) (proj1_sig part Gt) (qs_definitions.mon_nondet.qs_obligation_2 M (fun l H => qs (exist _ l H)) e i part));

      ret (low ++ vec.nth (h :: t) i :: proj1_sig part Eq ++ upp)

    end refl_equal.



  Variable e: extMonad M.



  Definition raw_body_ext (l: list X) (qs qs': {l': list X | length l' < length l} -> M (list X)):

    (forall x y, proj1_sig x = proj1_sig y -> qs x = qs' y) -> raw_body l qs = raw_body l qs'.

  Proof with auto.

    unfold raw_body.

    intros.

    destruct l...

    apply e. intro.

    apply e. intro.

    apply bind_eqq...

    intro.

    apply bind_eqq...

    intro...

  Qed.



  Lemma bodies x0:

    raw_body x0 (fun y: {y: list X | length y < length x0} => qs (M:=M) cmp pick (proj1_sig y)) = body x0.

  Proof.

    intros.

    unfold raw_body, body, selectPivotPart, partitionPart, lowRecPart.

    destruct x0; reflexivity.

  Qed.



  Lemma toBody (l: list X): qs cmp pick l = body l.

  Proof with auto.

    unfold qs.

    fold raw_body.

    rewrite fix_measure_utils.unfold.

      rewrite <- bodies.

      unfold qs. fold raw_body...

    intros.

    apply raw_body_ext.

    intros.

    destruct x. destruct y.

    simpl in H0.

    subst...

  Qed.



  Lemma toBody_cons (n: nat) (v: Vector.t X (S n)): body v = selectPivotPart v.

    intros.

    rewrite (vec.eq_cons v).

    simpl.

    reflexivity.

  Qed.



  Lemma rect (Q: list X -> M (list X) -> Type):

    (Q nil (ret nil)) ->

    (forall n (v: Vector.t X (S n)), (forall y, length y < S n -> Q y (qs cmp pick y)) -> Q v (selectPivotPart v)) ->

      forall x, Q x (qs cmp pick x).

  Proof with auto.

    intros. 

    unfold qs.

    match goal with 

      |- context C [Fix_sub ?A ?R ?P ?p ?f ?x] =>

        let folded := context C [ Fix_sub A R P p raw_body x ] in

          change folded

    end. 

    apply fix_measure_utils.rect.

      intros.

      apply raw_body_ext.

      intros.

      destruct x1. destruct y.

      simpl in H0.

      subst...

    intros.

    erewrite raw_body_ext.

      rewrite bodies.

      unfold body.

      destruct x0...

      simpl.

      rewrite <- (vec.list_round_trip (x0 :: x1)).

      apply X1.

      intros.

      unfold qs. fold raw_body...

    intros.

    unfold qs. fold raw_body.

    f_equal; assumption.

  Qed.



  Lemma rect_using_lists (Q: list X -> M (list X) -> Type):

    (Q nil (ret nil)) ->

    (forall h t, (forall y, length y <= length t -> Q y (qs cmp pick y)) -> Q (h::t) (selectPivotPart (h::t))) ->

      forall x, Q x (qs cmp pick x).

  Proof with auto with arith.

    intros.

    apply rect...

    intros.

    simpl in X1.

    rewrite (vec.eq_cons v).

    simpl.

    assert (forall y : list X, length y <= length (vec.to_list (vec.tail v)) -> Q y (qs cmp pick y)).

      intros.

      apply X2.

      rewrite vec.length in H...

    pose proof (X1 (vec.head v) (vec.tail v) X3).

    pose proof (selectPivotPart_eq (Vector.cons (vec.head v) (vec.from_list (vec.to_list (vec.tail v)))) (Vector.cons (vec.head v) (vec.tail v))).

    rewrite <- H...

    simpl.

    rewrite vec.list_round_trip...

  Qed.



End contents.

