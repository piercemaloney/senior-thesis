
Set Implicit Arguments.
Unset Automatic Introduction.

Require ne_list.
Require Import Setoid.
Require Import util.
(* util:
Set Implicit Arguments.
Global Set Asymmetric Patterns.

Require Import Relations.
Require Export Basics.
Require Import Setoid.

Arguments eq {A}.
Arguments fst {A B}.

Hint Unfold compose.

Definition proj1_conj (A B: Prop) (c: A /\ B): A :=
  match c with conj x _ => x end.

Definition proj2_conj (A B: Prop) (c: A /\ B): B :=
  match c with conj _ x => x end.

Lemma eq_trans (X: Set) (a b c: X): a = b -> b = c -> a = c.

Definition cmp_cmp (x y: comparison): { x = y } + { x <> y } :=
  
  match x, y return { x = y } + { x <> y } with
  | Lt, Lt | Gt, Gt | Eq, Eq => left _ (refl_equal _)
  | a, b => right _ (
      match a, b
      return match a, b with Lt, Lt | Gt, Gt | Eq, Eq => True | _, _ => ~(a = b) end with
      | Lt, Lt | Gt, Gt | Eq, Eq => I
      | Lt, _ => fun q => match q in _ = Lt with refl_equal => I end
      | Gt, _ => fun q => match q in _ = Gt with refl_equal => I end
      | Eq, _ => fun q => match q in _ = Eq with refl_equal => I end
      end
    )
  end. 

Fixpoint nat_cmp (x y: nat) {struct x}: comparison :=
  match x, y with
  | 0, 0 => Eq
  | 0, S _ => Lt
  | S _, 0 => Gt
  | S x', S y' => nat_cmp x' y'
  end.

Ltac cset e := let v := fresh in set (v := e); clearbody v.
Ltac cset' e := let v := fresh in set (v := e) in *; clearbody v.

Ltac extro x := generalize x; clear x.

Definition unsum_bool (A B: Prop) (sb: sumbool A B): bool := if sb then true else false.

Definition decision (P: Prop): Set := { P } + { ~ P }.
Definition predDecider (T: Set) (P: T -> Prop): Type := forall t, decision (P t).

Lemma negb_inv (b b': bool): negb b = negb b' -> b = b'.

Lemma negb_negb (b: bool): negb (negb b) = b.

Definition id {X} (x: X): X := x.

Definition ext_eq {A B: Type} (f g: A -> B): Prop := forall x, f x = g x.

Lemma ext_eq_trans: forall A B, transitive _ (@ext_eq A B).

Lemma ext_eq_refl: forall A B, reflexive _ (@ext_eq A B).

Lemma ext_eq_sym: forall A B, symmetric _ (@ext_eq A B).

Add Parametric Relation X Y: (X -> Y) (@ext_eq X Y)
  reflexivity proved by (@ext_eq_refl X Y)
  symmetry proved by (@ext_eq_sym X Y)
  transitivity proved by (@ext_eq_trans X Y)
    as ext_eq_rel.

Lemma ext_eq_rw (A B: Type) (f g: A -> B): ext_eq f g -> forall x, f x = g x.

Notation " g ∘ f " := (compose g f) (at level 40, left associativity).

Lemma comp_apply (A B C: Set) (f: B -> C) (g: A -> B) (x: A): (f ∘ g) x = f (g x).

Lemma comp_ass (A B C D: Set) (f: A -> B) (g: B -> C) (h: C -> D): h ∘ (g ∘ f) = (h ∘ g) ∘ f.

Definition compose_lunit A B (f: A -> B): ext_eq (@id B ∘ f) f.

Definition compose_runit A B (f: A -> B): ext_eq (f ∘ @id A) f.

Definition map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): C * B := (fst p, f (snd p)).

Lemma fst_map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): fst (map_snd f p) = fst p.

Definition on {A B: Type} {C: B -> B -> Type} (g: A -> B) (f: forall b b', C b b') (x y: A): C (g x) (g y) := f (g x) (g y).

Definition unsumbool {A B}: { A } + { B } -> bool := fun x => if x then true else false.

Definition dep_flip {A B: Type} {C: A -> B -> Type} (f: forall a b, C a b) (b: B) (a: A): C a b := f a b.

Definition uncurry A B C (f: A -> B -> C) (ab: A * B): C := f (fst ab) (snd ab).

Section well_founded_pairs.

  Variables (A B: Type)
    (Ra: relation A) (Rb: relation B).

  Inductive pair_rel: relation (A * B) :=
    | pair_rel_l a a' b: Ra a a' -> pair_rel (a, b) (a', b)
    | pair_rel_r a b b': Rb b b' -> pair_rel (a, b) (a, b').

  Fixpoint acc_pairs a (Aa: Acc Ra a) {struct Aa}: forall b (Ab: Acc Rb b), Acc pair_rel (a, b) :=
    fix G b (Ab: Acc Rb b) {struct Ab}: Acc pair_rel _ := @Acc_intro _ pair_rel _
      match Aa, Ab with
      | Acc_intro x, Acc_intro y =>  fun z (za: pair_rel z (a, b)) =>
          match za in pair_rel z ab return
            (forall (p: A) (q: Ra p (fst ab)), Acc pair_rel (p, (snd ab))) -> (forall p, Rb p (snd ab) -> Acc pair_rel (fst ab, p)) -> Acc pair_rel z with
          | pair_rel_l v w c d => fun fr gr => fr _ d
          | pair_rel_r v w c d => fun fr gr => gr _ d
          end
          (fun (p: A) (q: Ra p (fst (a, b))) => @acc_pairs p (x p q) b Ab : Acc pair_rel (p, b))
          (fun (p: B) (q: Rb p (snd (a, b))) => @G p (y p q): Acc pair_rel (a, p))
      end.

   Lemma well_founded_pairs (Wa: well_founded Ra) (Wb: well_founded Rb): well_founded pair_rel.

End well_founded_pairs. *)
Require List.

Section contents.

  Variable E: Set.

  Unset Elimination Schemes.

  Inductive T: Set :=
    | Leaf: E -> T
    | Node: ne_list.L T -> T.

  Set Elimination Schemes.

  Definition fold (Y: Set) (f: E -> Y) (g: ne_list.L Y -> Y): T -> Y :=
    fix F (t: T) :=
      match t with
      | Leaf e => f e
      | Node l => g (ne_list.map F l)
      end.

  Definition T_rect (P: T -> Type) (Pleaf: forall n, P (Leaf n)) (Pone: forall t, P t -> P (Node (ne_list.one t))) (Pcons: forall t l, P t -> P (Node l) -> P (Node (ne_list.cons t l))): forall t, P t :=
    fix F (t: T) :=
      match t return P t with
      | Leaf n => Pleaf n
      | Node l => (fix G (r: ne_list.L T) :=
        match r return P (Node r) with
        | ne_list.one x => Pone x (F x)
        | ne_list.cons x y => Pcons x y (F x) (G y)
        end) l
      end.

  Definition T_ind (P: T -> Prop) (Pleaf: forall n, P (Leaf n)) (Pone: forall t, P t -> P (Node (ne_list.one t))) (Pcons: forall t l, P t -> P (Node l) -> P (Node (ne_list.cons t l))): forall t, P t := T_rect P Pleaf Pone Pcons.

  Definition T_rec (P: T -> Set) (Pleaf: forall n, P (Leaf n)) (Pone: forall t, P t -> P (Node (ne_list.one t))) (Pcons: forall t l, P t -> P (Node l) -> P (Node (ne_list.cons t l))): forall t, P t := T_rect P Pleaf Pone Pcons.

  Definition alt_ind (P: T -> Prop) (Pleaf: forall n, P (Leaf n)) (Pnode: forall l:ne_list.L T, (forall t, List.In t l -> P t) -> P (Node l)) (t: T): P t .
  Proof with auto.
    intros P Hbase Hrcd.
    refine (fix IH (t:T) {struct t} : P t := _).
    destruct t.
      apply Hbase.
    apply Hrcd.
    induction l.
      simpl.
      intros.
      destruct H.
        rewrite <- H.
        apply IH.
      elimtype False.
      exact H.
    simpl.
    intros.
    destruct H.
      rewrite <- H.
      apply IH.
    apply IHl.
    assumption.
  Qed.

  Section alt_rect2.

    Variable P: T -> Type.
    Variable Q: ne_list.L T -> Type.
    Variable Pleaf: forall n, P (Leaf n).
    Variable Pnode: forall l, Q l -> P (Node l).
    Variable Qone: forall t, P t -> Q (ne_list.one t).
    Variable Qcons: forall t l, P t -> Q l -> Q (ne_list.cons t l).

    Fixpoint alt_rect2 (t: T): P t :=
      match t return P t with
      | Leaf x => Pleaf x
      | Node l => Pnode ((fix F (l: ne_list.L T) :=
        match l return Q l with
        | ne_list.one t => Qone (alt_rect2 t)
        | ne_list.cons x y => @Qcons x y (alt_rect2 x) (F y)
        end) l)
      end.

  End alt_rect2.

  Definition alt_ind2
    (P: T -> Prop) (Q: ne_list.L T -> Prop)
    (Pleaf: forall n, P (Leaf n))
    (Pnode: forall l, Q l -> P (Node l))
    (Qone: forall t, P t -> Q (ne_list.one t))
    (Qcons: forall t l, P t -> Q l -> Q (ne_list.cons t l)): forall t, P t
  := alt_rect2 P Q Pleaf Pnode Qone Qcons.

  Definition alt_rec2
    (P: T -> Set) (Q: ne_list.L T -> Set)
    (Pleaf: forall n, P (Leaf n))
    (Pnode: forall l, Q l -> P (Node l))
    (Qone: forall t, P t -> Q (ne_list.one t))
    (Qcons: forall t l, P t -> Q l -> Q (ne_list.cons t l)): forall t, P t
  := alt_rect2 P Q Pleaf Pnode Qone Qcons.

 Fixpoint head (t: T): E :=
    match t with
    | Leaf e => e
    | Node l => head (ne_list.head l)
    end.

  Inductive In (e: E): T -> Prop :=
    | InLeaf: In e (Leaf e)
    | InNode l: InL e l -> In e (Node l)
  with InL (e: E): ne_list.L T -> Prop :=
    | InOne t: In e t -> InL e (ne_list.one t)
    | InHead t l: In e t -> InL e (ne_list.cons t l)
    | InTail t l: InL e l -> InL e (ne_list.cons t l).

  Lemma InL_map_inv (Q: Set) (e: E) (f: Q -> T) (l: ne_list.L Q):
    InL e (ne_list.map f l) -> exists e', In e (f e') /\ List.In e' l.
  Proof with auto.
    intros Q e f.
    induction l.
      simpl.
      intros.
      inversion_clear H.
      exists t.
      split...
    simpl.
    intros.
    inversion_clear H.
      exists t.
      split...
    destruct (IHl H0).
    destruct H.
    exists x.
    split...
  Qed.

End contents.

Hint Constructors In.

Hint Resolve InLeaf.
Hint Resolve InNode.
Hint Resolve InOne.
Hint Resolve InHead.
Hint Resolve InTail.
  
Definition map (A B: Set) (f: A -> B): T A -> T B := fold (@Leaf _ ∘ f) (@Node _).

Add Parametric Morphism (A B: Set): (@map A B)
  with signature (@ext_eq A B) ==> (@ext_eq (T A) (T B))
  as map_ext_morph.
Proof with try reflexivity.
  unfold ext_eq.
  intros.
  induction x0; simpl.
      unfold compose.
      rewrite H...
    rewrite IHx0...
  rewrite IHx0...
  simpl in IHx1.
  inversion_clear IHx1...
Qed.

Lemma In_map_inv (A B: Set) (e: B) (f: A -> B) (t: T A):
  In e (map f t) -> exists e', e = f e' /\ In e' t.
Proof with auto.
  induction t.
      simpl.
      rewrite comp_apply.
      intros.
      inversion_clear H.
      eauto.
    simpl.
    intros.
    inversion_clear H.
    inversion_clear H0.
    destruct (IHt H).
    destruct H0.
    subst.
    eauto.
  simpl.
  intros.
  inversion_clear H.
  inversion_clear H0.
    destruct (IHt H).
    destruct H0.
    subst.
    eauto.
  simpl in IHt0.
  assert (In e (Node (ne_list.map (map f) l)))...
  destruct (IHt0 H0).
  destruct H1.
  subst.
  exists x.
  split...
  right.
  inversion_clear H2...
Qed.

Lemma map_ext (A B: Set) (f g: A -> B): ext_eq f g -> forall x, map f x = map g x.
Proof. intros. apply map_ext_morph. assumption. Qed.

Lemma map_map (A B C: Set) (f: A -> B) (g: B -> C) (t: T A):
  map g (map f t) = map (g ∘ f) t.
Proof with auto.
  induction t...
    simpl.
    rewrite IHt...
  simpl.
  rewrite IHt.
  simpl in IHt0.
  inversion_clear IHt0...
Qed.

Lemma map_map_ext (A B C: Set) (f: A -> B) (g: B -> C):
  ext_eq (map g ∘ map f) (map (g ∘ f)).
Proof. intros. intro. rewrite comp_apply. apply map_map. Qed.

Lemma map_id_ext (A: Set): ext_eq (map (@id A)) id.
Proof.
  intros. intro.
  induction x.
      simpl.
      auto.
    simpl.
    rewrite IHx.
    auto.
  simpl in *.
  unfold id at 2 in IHx0.
  inversion_clear IHx0.
  rewrite IHx. clear IHx.
  unfold id at 1.
  unfold id at 3.
  rewrite ne_list.map_map.
  do 2 f_equal.
  apply ne_list.map_ext.
  rewrite map_map_ext.
  reflexivity.
Qed.

Lemma In_head (X: Set) (t: T X): In (head t) t.
Proof. induction t; auto. Qed.

Lemma map_Node (X Y: Set) (f: X -> Y) l: map f (Node l) = Node (ne_list.map (map f) l).
Proof. auto. Qed.
