
Set Implicit Arguments.

Require Import Bool.
Require Import List.
Require Import Le.
Require Import Lt.
Require Import Arith.
Require Import Omega.
Require Import util.
(* util:
Set Implicit Arguments.
Global Set Asymmetric Patterns.

Require Import Relations.
Require Export Basics.
Require Import Setoid.

Arguments eq {A}.
Arguments fst {A B}.

Hint Unfold compose.

Definition proj1_conj (A B: Prop) (c: A /\ B): A :=
  match c with conj x _ => x end.

Definition proj2_conj (A B: Prop) (c: A /\ B): B :=
  match c with conj _ x => x end.

Lemma eq_trans (X: Set) (a b c: X): a = b -> b = c -> a = c.

Definition cmp_cmp (x y: comparison): { x = y } + { x <> y } :=
  
  match x, y return { x = y } + { x <> y } with
  | Lt, Lt | Gt, Gt | Eq, Eq => left _ (refl_equal _)
  | a, b => right _ (
      match a, b
      return match a, b with Lt, Lt | Gt, Gt | Eq, Eq => True | _, _ => ~(a = b) end with
      | Lt, Lt | Gt, Gt | Eq, Eq => I
      | Lt, _ => fun q => match q in _ = Lt with refl_equal => I end
      | Gt, _ => fun q => match q in _ = Gt with refl_equal => I end
      | Eq, _ => fun q => match q in _ = Eq with refl_equal => I end
      end
    )
  end. 

Fixpoint nat_cmp (x y: nat) {struct x}: comparison :=
  match x, y with
  | 0, 0 => Eq
  | 0, S _ => Lt
  | S _, 0 => Gt
  | S x', S y' => nat_cmp x' y'
  end.

Ltac cset e := let v := fresh in set (v := e); clearbody v.
Ltac cset' e := let v := fresh in set (v := e) in *; clearbody v.

Ltac extro x := generalize x; clear x.

Definition unsum_bool (A B: Prop) (sb: sumbool A B): bool := if sb then true else false.

Definition decision (P: Prop): Set := { P } + { ~ P }.
Definition predDecider (T: Set) (P: T -> Prop): Type := forall t, decision (P t).

Lemma negb_inv (b b': bool): negb b = negb b' -> b = b'.

Lemma negb_negb (b: bool): negb (negb b) = b.

Definition id {X} (x: X): X := x.

Definition ext_eq {A B: Type} (f g: A -> B): Prop := forall x, f x = g x.

Lemma ext_eq_trans: forall A B, transitive _ (@ext_eq A B).

Lemma ext_eq_refl: forall A B, reflexive _ (@ext_eq A B).

Lemma ext_eq_sym: forall A B, symmetric _ (@ext_eq A B).

Add Parametric Relation X Y: (X -> Y) (@ext_eq X Y)
  reflexivity proved by (@ext_eq_refl X Y)
  symmetry proved by (@ext_eq_sym X Y)
  transitivity proved by (@ext_eq_trans X Y)
    as ext_eq_rel.

Lemma ext_eq_rw (A B: Type) (f g: A -> B): ext_eq f g -> forall x, f x = g x.

Notation " g ∘ f " := (compose g f) (at level 40, left associativity).

Lemma comp_apply (A B C: Set) (f: B -> C) (g: A -> B) (x: A): (f ∘ g) x = f (g x).

Lemma comp_ass (A B C D: Set) (f: A -> B) (g: B -> C) (h: C -> D): h ∘ (g ∘ f) = (h ∘ g) ∘ f.

Definition compose_lunit A B (f: A -> B): ext_eq (@id B ∘ f) f.

Definition compose_runit A B (f: A -> B): ext_eq (f ∘ @id A) f.

Definition map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): C * B := (fst p, f (snd p)).

Lemma fst_map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): fst (map_snd f p) = fst p.

Definition on {A B: Type} {C: B -> B -> Type} (g: A -> B) (f: forall b b', C b b') (x y: A): C (g x) (g y) := f (g x) (g y).

Definition unsumbool {A B}: { A } + { B } -> bool := fun x => if x then true else false.

Definition dep_flip {A B: Type} {C: A -> B -> Type} (f: forall a b, C a b) (b: B) (a: A): C a b := f a b.

Definition uncurry A B C (f: A -> B -> C) (ab: A * B): C := f (fst ab) (snd ab).

Section well_founded_pairs.

  Variables (A B: Type)
    (Ra: relation A) (Rb: relation B).

  Inductive pair_rel: relation (A * B) :=
    | pair_rel_l a a' b: Ra a a' -> pair_rel (a, b) (a', b)
    | pair_rel_r a b b': Rb b b' -> pair_rel (a, b) (a, b').

  Fixpoint acc_pairs a (Aa: Acc Ra a) {struct Aa}: forall b (Ab: Acc Rb b), Acc pair_rel (a, b) :=
    fix G b (Ab: Acc Rb b) {struct Ab}: Acc pair_rel _ := @Acc_intro _ pair_rel _
      match Aa, Ab with
      | Acc_intro x, Acc_intro y =>  fun z (za: pair_rel z (a, b)) =>
          match za in pair_rel z ab return
            (forall (p: A) (q: Ra p (fst ab)), Acc pair_rel (p, (snd ab))) -> (forall p, Rb p (snd ab) -> Acc pair_rel (fst ab, p)) -> Acc pair_rel z with
          | pair_rel_l v w c d => fun fr gr => fr _ d
          | pair_rel_r v w c d => fun fr gr => gr _ d
          end
          (fun (p: A) (q: Ra p (fst (a, b))) => @acc_pairs p (x p q) b Ab : Acc pair_rel (p, b))
          (fun (p: B) (q: Rb p (snd (a, b))) => @G p (y p q): Acc pair_rel (a, p))
      end.

   Lemma well_founded_pairs (Wa: well_founded Ra) (Wb: well_founded Rb): well_founded pair_rel.

End well_founded_pairs. *)
Require Import arith_lems.
(* arith_lems:
Set Implicit Arguments.
Unset Standard Proposition Elimination Names.

Require Import util.
Require Import Le.
Require Import Lt.
Require Import Rbase.
Require Import Plus.
Require Import Mult.
Require Import Arith.
Require Import Omega.
Require Import Div2.
Require Import Recdef.
Require Import Rbase.
Require Import Morphisms.

Definition ltb (x y: nat): bool := negb (leb y x).
Definition geb (x y: nat): bool := leb y x.

Ltac subst_tac x y z := 
  match z with
  | x => y
  | ?l + ?r =>
      let l' := subst_tac x y l in
      let r' := subst_tac x y r in
        constr: (l' + r')
  | ?l * ?r =>
      let l' := subst_tac x y l in
      let r' := subst_tac x y r in
        constr: (l' * r')
  | _ => z
  end.

Ltac deep_le_trans h :=
  match type of h with
  | ?n <= ?u =>
    match goal with
    | |- ?l <= _ =>
      let q := subst_tac n u l
      in apply le_trans with q
    end
  end.

Instance Transitive_le: Transitive le := le_trans.

Lemma minus_plus_same (y x: nat): x <= x - y + y.

Lemma ltb_complete m n: ltb m n = true -> m < n.

Lemma ltb_complete_conv m n: ltb m n = false -> n <= m.

Lemma lt_0_mult x y: 0 < x -> 0 < y -> 0 < x * y.

Lemma mult_ne_0 a b: (a <> 0 -> b <> 0 -> mult a b <> 0)%nat.

Lemma weak_lt_S_n n m: S n < m -> n < m.

Lemma le_exists_plus (x y: nat) (p: x <= y): exists d, y = x + d.

Lemma lt_exists_plus (x y: nat) (p: x < y): exists d, y = S (x + d).

Lemma n_lt_n_plus_Sm n m: n < n + S m.

Lemma ne_le_impl_lt x y: x <> y -> x <= y -> x < y.

Hint Rewrite plus_0_r : arith_norm.
Hint Rewrite mult_plus_distr_r mult_plus_distr_l plus_assoc : arith_norm.

Lemma beq_nat_false x y: x <> y -> beq_nat x y = false.

Lemma minus_lt_compat_l x y z: (y <= x -> z < y -> x - y < x - z)%nat.

Lemma minus_eq_inv_r d x y: (x <= d -> y <= d -> (d - x = d - y) -> x = y)%nat.

Lemma le_ne_lt x y: x <= y -> x <> y -> x < y.

Lemma ne_nlt_lt x y: x <> y -> ~ x < y -> y < x.

Lemma lt_not_eq x y: (x < y -> x <> y)%nat.

Lemma lt_not_eq_sym x y: (y < x -> x <> y)%nat.

Hint Resolve lt_not_eq.
Hint Resolve lt_not_eq_sym.

Definition sqrd n := n * n.

Lemma sqrd_S n: sqrd (S n) = sqrd n + n + n + 1.

Lemma sqrd_plus x y: sqrd x + sqrd y <= sqrd (x + y).

Lemma sqrd_le x y: x <= y -> sqrd x <= sqrd y.

Hint Resolve sqrd_plus sqrd_le.

Lemma div2_preserves_le x y: x <= y -> div2 x <= div2 y.

Lemma Sdiv2_eq_div2SS x: S (div2 x) = div2 (S (S x)).

Lemma div2S_le_Sdiv2 x: div2 (S x) <= S (div2 x).

Lemma div2_x_plus_Sx b: div2 (b + S b) = b.

Lemma div2_x_plus_2y a b: div2 (a + 2 * b) = div2 a + b.

Lemma div2_sqrdSn n: div2 (sqrd n) + n <= div2 (sqrd (S n)).

Lemma le_div2 n: div2 n <= n.

Lemma div2_lt_inv0 x y: div2 x < div2 y -> x < y.

Lemma div2_lt_inv x y: div2 x < div2 y -> x <= y.

Lemma div2_le_div2_inv x y: div2 x <= div2 y -> x <= S y.

Lemma div2_cancel n: div2 (2 * n) = n.

Lemma div2_le_inv x n: div2 x <= n -> x <= S (2 * n).

Fixpoint pow (b e: nat) {struct e}: nat :=
  match e with
  | 0 => 1
  | S e' => b * pow b e'
  end.

Lemma pow_S x y: pow x (S y) = x * pow x y.

Lemma pow_min x: x <> 0%nat -> forall y, 0 < pow x y.

Lemma ceil_log2_S_def n: ceil_log2_S n =
  match n with
  | 0 => 0
  | S _ => S (ceil_log2_S (div2 n))
  end.

Definition log2ceil (n: nat): nat :=
  match n with
  | 0 => 0
  | S n' => ceil_log2_S n'
  end.

Lemma pow2_ceil_log2: forall n, S n <= pow 2 (ceil_log2_S n).

Lemma ceil_log2_Sn_le_n: forall n, ceil_log2_S n <= n.

Lemma log2ceil_lt: forall n, 0 < n -> log2ceil n < n.

Lemma log2ceil_le: forall n, log2ceil n <= n.

Lemma log2ceil_S_preserves_le x y: x <= y -> ceil_log2_S x <= ceil_log2_S y.

Lemma log2ceil_preserves_le x y: x <= y -> log2ceil x <= log2ceil y.

Lemma INR_S_ne_0 n: INR (S n) <> 0%R.

Hint Resolve INR_S_ne_0.

Lemma O_le_inv_INR_S n: (0 <= / INR (S n))%R.

Hint Resolve O_le_inv_INR_S.

Lemma INR_0_inv n: INR n = 0%R -> n = 0.

Lemma O_lt_INR_S n: (0 < INR (S n))%R.

Hint Resolve O_lt_INR_S.

Require Import Fourier.

Ltac deep_Rle_trans h :=
  match type of h with
  | ?n <= ?u =>
    match goal with
    | |- (?l <= _)%R =>
      let q := subst_tac n u l
      in apply Rle_trans with q
    | _ => assert (False)
    end
  end.

Lemma Rmult_eq_compat_r (r r1 r2: R): (r1 = r2 -> r1 * r = r2 * r)%R.

Lemma Rle_eq_trans x y z: (x <= y -> y = z -> x <= z)%R.

Lemma Req_ne_dec (x y: R): { x = y } + { x <> y }.

Lemma Rmult_0_inv (a b: R): (a * b)%R = 0%R -> (a = 0%R \/ b = 0%R).

Lemma Req_le_trans x y z: x = y -> y <= z -> x <= z.

Lemma Rle_plus_trans_l r a b c: a <= r -> r + b <= c -> a + b <= c.

Lemma Rne_nlt_lt x y: x <> y -> ~ x < y -> y < x.

Lemma Rdiv_le_1 a b: 0 < a -> a <= b -> 1 <= b / a.

Lemma Rdiv_lt_1 n m: 0 <= n -> n < m -> n / m < 1.

Lemma zero_le_2_div_Sn n: 0 <= (2 * / INR (S n))%R.

Hint Resolve zero_le_2_div_Sn.

Definition bigO (f g: nat -> R): Prop := exists c, exists n, forall x, (n <= x)%nat -> f x <= c * g x.

Definition measured_bigO (X: Set) (m: X -> nat) (f: X -> R) (g: nat -> R): Prop
  := exists c, exists n, forall x, (n <= m x)%nat -> f x <= c * g (m x).

Notation "'over' m , f =O( g )" := (measured_bigO m f g). *)
Require Import List.
Require Import monads.
(* monads:
Global Set Automatic Coercions Import.
Set Implicit Arguments.

Require Import List.
Require Import list_utils.
Require Import util.

Record Monad: Type :=
  { mon:> Set -> Set
  ; bind: forall a b, mon a -> (a -> mon b) -> mon b
  ; ret: forall (a: Set), a -> mon a
  
  ; mon_lunit: forall (a b: Set) (x: a) (f: a -> mon b), bind (ret x) f = f x
      
  ; mon_runit: forall (a: Set) (f: mon a), bind f (@ret a) = f
      
  ; mon_assoc: forall a b c (n: mon a) (f: a -> mon b) (g: b -> mon c),
      bind (bind n f) g =
      bind n (fun x => bind (f x) g)
      
  }.

Arguments bind [m a b].
Arguments ret {m a}.

Notation "x >>= y" := (bind x y) (at level 55).
Notation "x >> y" := (bind x (fun _ => y)) (at level 30, right associativity).
Notation "x <- y ; z" := (bind y (fun x : _ => z)) (at level 30, right associativity).

Record Functor: Type :=
  { func: Set -> Set
  ; func_map: forall (a b: Set) (f: a -> b), func a -> func b
  
  ; func_id: forall (X: Set), func_map (fun (x: X) => x) = (fun (x: func X) => x)
        
  ; func_assoc: forall (a b c: Set) (x: func a) (f: b -> c) (g: a -> b),
      func_map (f ∘ g) x = func_map f (func_map g x)
        
  }.

Arguments func_map [f a b].

Definition extMonad (M: Monad): Prop := forall (A B: Set) (f g: A -> M B), ext_eq f g -> forall x, bind x f = bind x g.

Lemma bind_eqq (M: Monad) (e: extMonad M) (A B: Set) (m n: M A) (f g: A -> M B):
  m = n -> ext_eq f g -> (m >>= f) = (n >>= g).

Definition extFlipped (M: Monad): extMonad M -> forall A (x: M A) (B: Set) (f g: A -> M B), ext_eq f g -> bind x f = bind x g.

Lemma mon_lunit_under_bind (M: Monad) (A B C: Set) (a: M A) (b: A -> B) (f: A -> B -> M C):
  extMonad M -> (x <- a ; (ret (b x) >>= f x)) = (x <- a ; f x (b x)).

Section MonadFunctor. 

  Variable M: Monad.

  Definition bind_map (a b: Set) (f: a -> b) (x: M a): M b :=
    xv <- x ;
    ret (f xv).

  Hypothesis f_ext_eq: forall A B (f g: A -> B), (forall x, f x = g x) -> f = g.

  Lemma eta A B (f: A -> B): (fun x => f x) = f.

  Definition MonadFunctor: Functor.

  Definition a_monad_isa_functor T (x: M T): func MonadFunctor T := x.
    End MonadFunctor.

Module IdMonad.

  Definition C (s: Set): Set := s. 

  Definition bind A B (x: C A) (y: A -> C B): C B := y x.
  Definition ret (A: Set) (x: A): C A := x.

  Definition M: Monad.

  Coercion id_isa_monad A (a: C A): M A := a.

  Lemma ext: extMonad M.

End IdMonad.

Unset Elimination Schemes.

Inductive Tree (A: Set): Set :=
  | Leaf: A -> Tree A
  | Node: list (Tree A) -> Tree A.

Set Elimination Schemes.

Definition Tree_ind
  : forall (A: Set) (P : Tree A -> Prop),
    (forall n : A, P (Leaf n)) ->
    (forall l : list (Tree A), (forall t, In t l -> P t) -> P (Node l)) ->
  forall t, P t.

Section MonadToys.

  Definition liftM (A B: Set) (f: A -> B) (M: Monad) (x: M A): M B :=
    xv <- x ; ret (f xv).

  Definition liftM2 (A B C: Set) (f: A -> B -> C) (M: Monad) (x: M A) (y: M B): M C :=
    xv <- x ; yv <- y ; ret (f xv yv).

  Fixpoint foldlM {A B: Set} {M: Monad} (f: A -> B -> M A) (x: A) (l: list B) {struct l}: M A :=
    match l with
    | nil => ret x
    | h :: t => fax <- f x h ; foldlM f fax t
    end. 

  Fixpoint foldrM {A B: Set} {M: Monad} (f: B -> A -> M A) (x: A) (l: list B) {struct l}: M A :=
    match l with
    | nil => ret x
    | h :: t => t' <- foldrM f x t; f h t'
    end. 

  Lemma foldlM_cons (A B: Set) (M: Monad) (f: A -> B -> M A) (x: A) (h: B) (t: list B):
    foldlM f x (h :: t) = fax <- f x h ; foldlM f fax t.

  Fixpoint filterM {A: Set} {M: Monad} (p: A -> M bool) (l: list A): M (list A) :=
    match l with
    | nil => ret nil
    | h :: t =>
      b <- p h ;
      t' <- filterM p t ;
      ret (if b then h :: t' else t')
    end. 

  Lemma filterM_id (A: Set) (p: A -> IdMonad.M bool) (l: list A): filter p l = filterM p l.

End MonadToys.

Arguments liftM [A B] _ [M].

Record MonadTrans: Type :=
  { transMonad: forall (m: Monad), extMonad m -> Monad
  ; lift: forall (m: Monad) (e: extMonad m) (A: Set), m A -> transMonad e A
  }. *)
Require Import monoid_monad_trans.
(* monoid_monad_trans:
Set Implicit Arguments.

Require Import util.
Require list_utils.
Require Import List.
Require Import monads.

Record Monoid: Type :=
  { monoid_type:> Set
  ; monoid_zero: monoid_type
  ; monoid_mult: monoid_type -> monoid_type -> monoid_type
  ; monoid_lunit: forall x, monoid_mult monoid_zero x = x
  ; monoid_runit: forall x, monoid_mult x monoid_zero = x
  ; monoid_assoc: forall x y z, monoid_mult (monoid_mult x y) z = monoid_mult x (monoid_mult y z)
  }.

Record monoidHomo (m n: Monoid) (f: m -> n): Prop :=
  { monoidHomo_zero: f (monoid_zero m) = (monoid_zero n)
  ; monoidHomo_mult: forall x y, f (monoid_mult m x y) = monoid_mult n (f x) (f y)
  }.

Lemma monoidHomo_refl (m: Monoid): monoidHomo m m (fun x => x).

Module MonoidMonadTrans.
Section MonoidMonadTrans.

  Variable monoid: Monoid.

  Section NewMonad.

    Variable monad: Monad.
    Hypothesis ext: extMonad monad.

    Let C_MMT (T: Set): Set := monad (prod monoid T).

    Let bind_MMT (A B: Set) (a: C_MMT A) (ab: A -> C_MMT B): C_MMT B :=
      x <- a ; y <- ab (snd x) ;
      ret (monoid_mult monoid (fst x) (fst y), snd y).

    Let ret_MMT (T: Set): T -> C_MMT T := ret ∘ pair (monoid_zero monoid).

    Definition M: Monad.

    Lemma bind_toLower' (X V: Set) (f: M V) (g: V -> M X):
      f >>= g =
        x <- f: monad (prod monoid V);
        ((g (snd x): monad (prod monoid X)) >>=
          (ret ∘ (fun q => (monoid_mult monoid (fst x) (fst q), snd q)))).

    Lemma bind_toLower (X V: Set) (f: M V) (g: V -> M X):
      f >>= g =
        x <- f: monad (prod monoid V);
        y <- g (snd x): monad (prod monoid X);
        ret (m:=monad) (monoid_mult monoid (fst x) (fst y), snd y).

    Definition ret_toLower (X: Set) (x: X): @ret M X x = ret (m:=monad) (monoid_zero monoid, x).

    Lemma mon_toLower: forall X, M X = monad (prod monoid X).

    Lemma Mext: extMonad M.

    Definition lift (A: Set) (a: monad A): M A := a >>= (ret ∘ pair (monoid_zero monoid)).

  End NewMonad.

  Definition T: MonadTrans := Build_MonadTrans M lift.

End MonoidMonadTrans.
End MonoidMonadTrans.

Definition NatAddMonoid: Monoid.

Definition SimplyProfiled: Monad := MonoidMonadTrans.M NatAddMonoid IdMonad.ext.

Definition cost {X: Set}: prod nat X -> nat := @fst _ _.
Definition result X: SimplyProfiled X -> X := @snd _ _.

Lemma bind_cost (T U: Set) (a: SimplyProfiled T) (b: T -> SimplyProfiled U):
  cost (bind a b) = cost a + cost (b (result a)).

Lemma return_cost (T: Set) (x: T): cost (@ret SimplyProfiled T x) = 0.

Lemma SimplyProfiled_ext: extMonad SimplyProfiled.

Module ListMonoid.
Section ListMonoid.

  Variable T: Set.

  Definition M: Monoid :=
    Build_Monoid (@nil T) (@app T) (@refl_equal (list T)) (@list_utils.app_nil_r T) (@app_ass T).

End ListMonoid.
End ListMonoid. *)
Require Import qs_definitions.
(* qs_definitions:
Set Implicit Arguments.

Require Import util.
Require Import List.
Require Import Le.
Require Import Lt.
Require Import Plus.
Require Import monads.
Require Import Coq.Program.Wf.
Require Import nat_seqs.
Require Import list_utils.
Require Import Bool.
Require Import Recdef.
Require Import monoid_monad_trans.
Require Import Compare_dec.
Require Coq.Program.Wf.
Require Import Wf_nat.
Require Import arith_lems.
Require ne_list.
Require Import Omega.
Require fix_measure_utils.

Set Shrink Obligations.

Definition numbers: list nat := 3 :: 1 :: 0 :: 4 :: 5 :: 2 :: nil.

Hint Resolve length_filter_le.

Module nonmonadic.
Section nonmonadic.

  Variables (T: Set) (le: T -> T -> bool).

  Definition gt (x y: T): bool := negb (le x y).

  Program Fixpoint qs (l: list T) {measure (length l) on lt}: list T :=
    match l with
    | nil => nil
    | pivot :: t => qs (filter (gt pivot) t) ++ (pivot :: nil) ++ qs (filter (le pivot) t)
    end.

  Definition body (l : list T) (qs0 : {l' : list T | length l' < length l} -> list T) :=
    match l as l0 return (l0 = l -> list T) with
    | nil => fun _ => nil
    | pivot :: t0 => fun Heq_l =>
      qs0 (exist (fun l' => length l' < length l) (filter (gt pivot) t0) (qs_obligation_1 (fun l H => qs0 (exist _ l H)) Heq_l)) ++
      (pivot :: nil) ++
      qs0 (exist (fun l' => length l' < length l) (filter (le pivot) t0) (qs_obligation_2 (fun l H => qs0 (exist _ l H)) Heq_l))
    end refl_equal.

  Lemma body_eq:
    forall (x0 : list T) (g h0 : {y : list T | length y < length x0} -> list T),
    (forall (x : list T) (p p' : length x < length x0),
    g (exist (fun y : list T => length y < length x0) x p) =
    h0 (exist (fun y : list T => length y < length x0) x p')) ->
    body x0 g = body x0 h0.

  Lemma unfold: forall l, qs l = Fix_sub (list T) (MR lt (fun l0 : list T => length l0)) qs_obligation_3 (fun _ : list T => list T) body l.

  Lemma qs_unfold (t: list T) (h: T): qs (h :: t) = qs (filter (gt h) t) ++ (h :: nil) ++ qs (filter (le h) t).

  Section rect.

    Variable P: list T -> list T -> Prop.

    Hypothesis Pnil: P nil nil.

    Hypothesis Pcons: forall h t,
      P (filter (gt h) t) (qs (filter (gt h) t)) ->
      P (filter (le h) t) (qs (filter (le h) t)) -> P (h :: t) (qs (filter (gt h) t) ++ h :: nil ++ qs (filter (le h) t)).

    Lemma qs_rect: forall l, P l (qs l).

  End rect.

End nonmonadic.
End nonmonadic.

Module mon_det. 
Section mon_det. 

  Variables (M: Monad) (T: Set).

  Definition filter (c: T -> M bool) (l: list T): M { l': list T | length l' <= length l }.

  Lemma hm (e: extMonad M) c l: forall U (f: list T -> M U) g,
    ext_eq g (f ∘ @proj1_sig _ _) -> filter c l >>= g = filterM c l >>= f.

  Fixpoint simple_filter (c: T -> M bool) (l: list T): M (list T) :=
    match l with
    | nil => ret nil
    | h :: t =>
      t' <- simple_filter c t ;
      b <- c h ;
      ret (if b then h :: t' else t')
    end.

  Definition fold_filter (c: T -> M bool): list T -> M (list T) :=
    foldrM (fun x l => b <- c x ; ret (if b then x :: l else l)) nil.

  Lemma simple_fold_filter: forall c l, simple_filter c l = fold_filter c l.

  Variable le: T -> T -> M bool.

  Definition gt (x y: T): M bool := liftM negb (le x y).

  Program Fixpoint qs (l: list T) {measure (length l) on lt}: M (list T) :=
    match l with
    | nil => ret nil
    | pivot :: t =>
        lower <- filter (gt pivot) t >>= (fun l => qs l);
        upper <- filter (le pivot) t >>= (fun l => qs l);
        ret (lower ++ pivot :: upper)
    end.
    
  Definition body (l: list T) (qs0: {l': list T | length l' < length l} -> M (list T)) :=
    match l as l1 return (l1 = l -> M (list T)) with
    | nil => fun _ => ret (m:=M) nil
    | pivot :: t => fun Heq_l =>
        lower <-
          x <- filter (gt pivot) t;
          qs0 (exist _ (proj1_sig x) (qs_obligation_1 (fun l H => qs0 (exist _ l H)) Heq_l x));
        upper <-
          x <- filter (le pivot) t;
          qs0 (exist _ (proj1_sig x) (qs_obligation_2 (fun l H => qs0 (exist _ l H)) Heq_l x));
        ret (m:=M) (lower ++ pivot :: upper)
    end refl_equal.

  Lemma unfold: forall l, qs l =
    Fix_sub (list T) (MR lt (fun l0 : list T => length l0)) qs_obligation_3 (fun _ : list T => M (list T)) body l.

  Variable e: extMonad M.

  Lemma body_eq:
    forall (x0 : list T)
     (g h : {y : list T | length y < length x0} -> M (list T)),
    (forall (x1 : list T) (p p' : length x1 < length x0),
     g (exist (fun y : list T => length y < length x0) x1 p) =
     h (exist (fun y : list T => length y < length x0) x1 p')) ->
    body x0 g = body x0 h.

  Lemma unfold' pivot t: qs (pivot :: t) =
    lower <- filterM (gt pivot) t >>= qs;
    upper <- filterM (le pivot) t >>= qs;
    ret (lower ++ pivot :: upper).

End mon_det.
End mon_det.

Arguments mon_det.qs [M T].

Lemma mon_det_nonmonadic_eq (X: Set) (Xle: X -> X -> Prop) (leb: X -> X -> IdMonad.M bool):

Definition profiled_leb (x y: nat): SimplyProfiled bool := (1, leb x y).
Eval vm_compute in mon_det.qs profiled_leb numbers.

Eval vm_compute in mon_det.qs (M:=IdMonad.M) leb numbers.

Module mon_det_partition. 
Section mon_det_partition.

  Variables (T: Set) (M: Monad) (cmp: T -> T -> M comparison).

  Fixpoint partition (pivot: T) (l: list T) :
      M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } :=
        
    match l return M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } with
    | nil => ret (@emp T)
    | h :: t =>
        b <- cmp h pivot;
        tt <- partition pivot t ;
        ret (addToPartitioning b h tt)
    end.

  Program Fixpoint qs (l: list T) {measure (length l) on lt}: M (list T) :=
    match l with
    | nil => ret nil
    | h :: t =>
        part <- partition h t;
        low <- qs (part Lt);
        upp <- qs (part Gt);
        ret (low ++ h :: part Eq ++ upp)
    end.

End mon_det_partition.
End mon_det_partition.

Module mon_nondet. 
Section mon_nondet.

  Variables (T: Set) (M: Monad) (cmp: T -> T -> M comparison).

  Fixpoint partition (pivot: T) (l: list T) :
      M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } :=
        
    match l return M { p: Partitioning T | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } with
    | nil => ret (@emp T)
    | h :: t =>
        b <- cmp h pivot;
        tt <- partition pivot t ;
        ret (addToPartitioning b h tt)
    end.

  Variable pick: forall (A: Set), ne_list.L A -> M A.

  Program Fixpoint qs (l: list T) {measure (length l) on lt}: M (list T) :=
    match l with
    | nil => ret nil
    | h :: t =>
        i <- pick (ne_list.from_vec (vec.nats 0 (length (h :: t))));

End mon_nondet.
End mon_nondet.

Require Import sort_order.

Fixpoint simplerPartition (e: E) (d: e) (l: list e) {struct l}: { p: Partitioning e | Permutation.Permutation (p Eq ++ p Lt ++ p Gt) l } :=

End nonmonadic_using_Function. *)
Import mon_det.
Require fix_measure_utils.

Set Shrink Obligations.

Variables (T: Set) (cmp: T -> T -> bool). 

Definition counted_cmp (x y: T): SimplyProfiled bool := (1, cmp x y). 

Lemma filter_cost (p: T -> SimplyProfiled bool):
  (forall t, cost (p t) = 1) -> forall (l: list T), cost (filter _ p l) = length l.
Proof with auto with arith.
  intros pd.
  induction l...
  simpl.
  destruct (filter SimplyProfiled p l)...
  destruct s...
  set (pd a).
  clearbody e.
  destruct (p a)...
  simpl in *.
  subst.
  omega.
Qed.

Lemma exclusive_filtering (T: Set) (p q: T -> SimplyProfiled bool)
  (ex: forall x, result (p x) = false \/ result (q x) = false) (l: list T):
    length (proj1_sig (result (filter SimplyProfiled p l))) +
    length (proj1_sig (result (filter SimplyProfiled q l))) <= length l.
Proof with auto with arith.
  induction l...
  simpl.
  destruct (filter SimplyProfiled p l).
  destruct (filter SimplyProfiled q l).
  destruct s.
  destruct s0.
  simpl in *.
  destruct (ex a); [destruct (p a) | destruct (q a)]; simpl in H; subst; simpl; [destruct (q a) | destruct (p a)]; destruct b; simpl; omega.
Qed.

Lemma counted_cmp_excl (n x: T):
  result (counted_cmp n x) = false \/ result (gt _ counted_cmp n x) = false.
Proof. simpl. intros. destruct (cmp n x); auto. Qed.

Lemma common_arith
  (n n3 n0 n1 n2: nat)
  (l0: n3 + n0 <= n)
  (p: n1 <= sqrd n3)
  (p0: n2 <= sqrd n0):
   n + n2 + n + n1 <= sqrd n + n + n + 1.
Proof with auto with arith.
  intros.
  apply le_trans with (n2 + n1 + (n + n)); try omega.
  apply le_trans with (sqrd n + 1 + (n + n)); try omega.
  apply plus_le_compat_r.
  deep_le_trans p...
  deep_le_trans p0...
  rewrite plus_comm in l0.
  apply le_trans with (sqrd (n0 + n3))...
Qed.

Lemma bind_eqq (M: Monad) (e: extMonad M) (A B: Set) (m n: M A) (f g: A -> M B): m = n -> ext_eq f g -> (m >>= f) = (n >>= g).
Proof.
  intros.
  subst.
  apply e.
  assumption.
Qed.

Hint Resolve SimplyProfiled_ext.

Definition qs_body (l: list T) (qs0: {l': list T | length l' < length l} -> SimplyProfiled (list T)) :=
  match l as l1 return (l1 = l -> SimplyProfiled (list T)) with
  | nil => fun _ => ret (m:=SimplyProfiled) nil
  | pivot :: t => fun Heq_l =>
      lower <-
        x <- filter SimplyProfiled (gt SimplyProfiled counted_cmp pivot) t;
        qs0 (exist _ (proj1_sig x) (qs_definitions.mon_det.qs_obligation_1 SimplyProfiled (fun l H => qs0 (exist _ l H)) Heq_l x));
      upper <-
        x <- filter SimplyProfiled (counted_cmp pivot) t;
        qs0 (exist _ (proj1_sig x) (qs_definitions.mon_det.qs_obligation_2 SimplyProfiled (fun l H => qs0 (exist _ l H)) Heq_l x));
      ret (m:=SimplyProfiled) (lower ++ pivot :: upper)
  end refl_equal.

Theorem qs_quadratic (l: list T): cost (qs counted_cmp l) <= sqrd (length l).
Proof with auto with arith.
  intros.
  set (P := fun (l: list T) (r: SimplyProfiled (list T)) => cost r <= sqrd (length l)).
  cut (P l (qs counted_cmp l))...
  unfold qs.
  fold qs_body.
  apply fix_measure_utils.rect; subst P; intros.
    unfold qs_body.
    destruct x0...
    repeat (try apply bind_eqq; try intro; auto).
  simpl.
  unfold qs_body.
  simpl proj1_sig.
  destruct x...
  repeat rewrite bind_cost.
  repeat rewrite return_cost.
  repeat rewrite filter_cost...
  fold qs_body.
  cset (exclusive_filtering (counted_cmp t) (gt SimplyProfiled counted_cmp t) (counted_cmp_excl t) x).
  destruct (result (filter SimplyProfiled (gt SimplyProfiled counted_cmp t) x)).
  destruct (result (filter SimplyProfiled (counted_cmp t) x)).
  simpl proj1_sig in *.
  assert (fix_measure_utils.MR lt (fun l: list T => length l) x0 (t :: x)). unfold fix_measure_utils.MR. simpl...
  assert (fix_measure_utils.MR lt (fun l: list T => length l) x1 (t :: x)). unfold fix_measure_utils.MR. simpl...
  unfold SimplyProfiled in H.
  simpl mon in H.
  deep_le_trans (H x0 H1)...
  deep_le_trans (H x1 H2)...
  simpl in *.
  rewrite sqrd_S.
  autorewrite with arith_norm.
  apply common_arith with (length x1) (length x0)...
Qed.
