Global Set Automatic Coercions Import.

Set Implicit Arguments.

Unset Standard Proposition Elimination Names.



Require Import nat_below.
(* nat_below:
Global Set Automatic Coercions Import.
Set Implicit Arguments.

Require Import Arith.
Require Compare_dec.
Require EqNat.
Require Import Omega.

Fixpoint cond_eq (T: nat -> Set) n m {struct n}: forall c, T (c + n) -> T (c + m) -> Prop :=
  match n, m return forall c, T (c + n) -> T (c + m) -> Prop with
  | 0, 0 => fun c x y => x = y
  | S n', S m' => fun c x y => cond_eq T n' m' (S c)
      (eq_rec_r T x (plus_n_Sm c n'))
      (eq_rec_r T y (plus_n_Sm c m'))
  | _, _ => fun _ _ _ => True
  end.

Lemma cond_eq_eq (T: nat -> Set) n c (x y: T (c + n)): cond_eq T n n c x y = (x = y).

Lemma cond_eq_neq (T: nat -> Set) n m c (x: T (c + n)) (y: T (c + m)): n <> m -> cond_eq T n m c x y = True.

Inductive natBelow: nat -> Set := mkNatBelow (v p: nat): natBelow (S (v + p)).

Definition nb_val {n: nat} (nb: natBelow n): nat := match nb with mkNatBelow m _ => m end.

Coercion nb_val: natBelow >-> nat.

Lemma natBelow_unique n (x y: natBelow n): nb_val x = nb_val y -> x = y.

Lemma natBelow_uneq n (x y: natBelow n): nb_val x <> nb_val y -> x <> y.

Lemma natBelow_eq_dec n (x y: natBelow n): { x = y } + { x <> y }.

Definition nb0 n: natBelow (S n) := mkNatBelow 0 n.

Definition Snb n (nb: natBelow n): natBelow (S n) :=
  match nb in (natBelow n0) return (natBelow (S n0)) with
  | mkNatBelow v p => mkNatBelow (S v) p
  end. *)

Require Import util.
(* util:
Set Implicit Arguments.
Global Set Asymmetric Patterns.

Require Import Relations.
Require Export Basics.
Require Import Setoid.

Arguments eq {A}.
Arguments fst {A B}.

Hint Unfold compose.

Definition proj1_conj (A B: Prop) (c: A /\ B): A :=
  match c with conj x _ => x end.

Definition proj2_conj (A B: Prop) (c: A /\ B): B :=
  match c with conj _ x => x end.

Lemma eq_trans (X: Set) (a b c: X): a = b -> b = c -> a = c.

Definition cmp_cmp (x y: comparison): { x = y } + { x <> y } :=
  
  match x, y return { x = y } + { x <> y } with
  | Lt, Lt | Gt, Gt | Eq, Eq => left _ (refl_equal _)
  | a, b => right _ (
      match a, b
      return match a, b with Lt, Lt | Gt, Gt | Eq, Eq => True | _, _ => ~(a = b) end with
      | Lt, Lt | Gt, Gt | Eq, Eq => I
      | Lt, _ => fun q => match q in _ = Lt with refl_equal => I end
      | Gt, _ => fun q => match q in _ = Gt with refl_equal => I end
      | Eq, _ => fun q => match q in _ = Eq with refl_equal => I end
      end
    )
  end. 

Fixpoint nat_cmp (x y: nat) {struct x}: comparison :=
  match x, y with
  | 0, 0 => Eq
  | 0, S _ => Lt
  | S _, 0 => Gt
  | S x', S y' => nat_cmp x' y'
  end.

Ltac cset e := let v := fresh in set (v := e); clearbody v.
Ltac cset' e := let v := fresh in set (v := e) in *; clearbody v.

Ltac extro x := generalize x; clear x.

Definition unsum_bool (A B: Prop) (sb: sumbool A B): bool := if sb then true else false.

Definition decision (P: Prop): Set := { P } + { ~ P }.
Definition predDecider (T: Set) (P: T -> Prop): Type := forall t, decision (P t).

Lemma negb_inv (b b': bool): negb b = negb b' -> b = b'.

Lemma negb_negb (b: bool): negb (negb b) = b.

Definition id {X} (x: X): X := x.

Definition ext_eq {A B: Type} (f g: A -> B): Prop := forall x, f x = g x.

Lemma ext_eq_trans: forall A B, transitive _ (@ext_eq A B).

Lemma ext_eq_refl: forall A B, reflexive _ (@ext_eq A B).

Lemma ext_eq_sym: forall A B, symmetric _ (@ext_eq A B).

Add Parametric Relation X Y: (X -> Y) (@ext_eq X Y)
  reflexivity proved by (@ext_eq_refl X Y)
  symmetry proved by (@ext_eq_sym X Y)
  transitivity proved by (@ext_eq_trans X Y)
    as ext_eq_rel.

Lemma ext_eq_rw (A B: Type) (f g: A -> B): ext_eq f g -> forall x, f x = g x.

Notation " g ∘ f " := (compose g f) (at level 40, left associativity).

Lemma comp_apply (A B C: Set) (f: B -> C) (g: A -> B) (x: A): (f ∘ g) x = f (g x).

Lemma comp_ass (A B C D: Set) (f: A -> B) (g: B -> C) (h: C -> D): h ∘ (g ∘ f) = (h ∘ g) ∘ f.

Definition compose_lunit A B (f: A -> B): ext_eq (@id B ∘ f) f.

Definition compose_runit A B (f: A -> B): ext_eq (f ∘ @id A) f.

Definition map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): C * B := (fst p, f (snd p)).

Lemma fst_map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): fst (map_snd f p) = fst p.

Definition on {A B: Type} {C: B -> B -> Type} (g: A -> B) (f: forall b b', C b b') (x y: A): C (g x) (g y) := f (g x) (g y).

Definition unsumbool {A B}: { A } + { B } -> bool := fun x => if x then true else false.

Definition dep_flip {A B: Type} {C: A -> B -> Type} (f: forall a b, C a b) (b: B) (a: A): C a b := f a b.

Definition uncurry A B C (f: A -> B -> C) (ab: A * B): C := f (fst ab) (snd ab).

Section well_founded_pairs.

  Variables (A B: Type)
    (Ra: relation A) (Rb: relation B).

  Inductive pair_rel: relation (A * B) :=
    | pair_rel_l a a' b: Ra a a' -> pair_rel (a, b) (a', b)
    | pair_rel_r a b b': Rb b b' -> pair_rel (a, b) (a, b').

  Fixpoint acc_pairs a (Aa: Acc Ra a) {struct Aa}: forall b (Ab: Acc Rb b), Acc pair_rel (a, b) :=
    fix G b (Ab: Acc Rb b) {struct Ab}: Acc pair_rel _ := @Acc_intro _ pair_rel _
      match Aa, Ab with
      | Acc_intro x, Acc_intro y =>  fun z (za: pair_rel z (a, b)) =>
          match za in pair_rel z ab return
            (forall (p: A) (q: Ra p (fst ab)), Acc pair_rel (p, (snd ab))) -> (forall p, Rb p (snd ab) -> Acc pair_rel (fst ab, p)) -> Acc pair_rel z with
          | pair_rel_l v w c d => fun fr gr => fr _ d
          | pair_rel_r v w c d => fun fr gr => gr _ d
          end
          (fun (p: A) (q: Ra p (fst (a, b))) => @acc_pairs p (x p q) b Ab : Acc pair_rel (p, b))
          (fun (p: B) (q: Rb p (snd (a, b))) => @G p (y p q): Acc pair_rel (a, p))
      end.

   Lemma well_founded_pairs (Wa: well_founded Ra) (Wb: well_founded Rb): well_founded pair_rel.

End well_founded_pairs. *)

Require Import list_utils.
(* list_utils:
Set Implicit Arguments.
Unset Standard Proposition Elimination Names.

Require Export List.

Require Import
  Program Omega Factorial
  Bool util Morphisms Relations RelationClasses Permutation.

Hint Resolve
  in_map Permutation_refl.

Hint Constructors NoDup.

Hint Constructors
  NoDup Permutation.

Arguments length {A}.
Arguments Permutation {A}.
Arguments map {A B}.
Arguments tail {A}.

Section count.

  Context {X: Type} (p: X -> bool).

  Fixpoint count (l: list X): nat :=
    match l with
    | nil => 0
    | h :: t => if p h then S (count t) else count t
    end.

  Lemma count_app l l': count (l ++ l') = count l + count l'.

  Lemma count_0 l: (forall x, In x l -> p x = false) -> count l = 0.

  Lemma count_le l: count l <= length l.

  Lemma count_filter_le (f: X -> bool) x: count (filter f x) <= count x.

  Hint Resolve count_le.

  Lemma count_lt v l: In v l -> p v = false -> count l < length l.

End count.

Hint Resolve @count_le.

Lemma NoDup_map_inv' A B (f: A -> B) (l: list A): NoDup (map f l) -> NoDup l.

Lemma length_filter X (p: X -> bool) (l: list X): length (filter p l) = count p l.

Lemma length_filter_le T (p: T -> bool) (l: list T): length (filter p l) <= length l.

Lemma filter_all X (p: X -> bool) (l: list X):
  (forall x, In x l -> p x = true) -> filter p l = l.

Lemma In_filter T (p: T -> bool) (t: T): p t = true -> forall l, In t l -> In t (filter p l).

Lemma incl_filter X (p: X -> bool) (l: list X): incl (filter p l) l.

Lemma incl_trans A (x y: list A): incl x y -> forall z, incl y z -> incl x z.

Hint Resolve incl_filter.

Lemma filter_preserves_incl X (p: X -> bool) (a b: list X): incl a b -> incl (filter p a) (filter p b).

Hint Resolve filter_preserves_incl.

Lemma In_inv_perm X (x: X) (l: list X):
  In x l -> exists l', Permutation (x :: l') l.

Lemma In_map_inv T U (f: T -> U) (l: list T) (y: U): In y (map f l) -> exists x, f x = y /\ In x l.

Hint Resolve incl_tran.

Lemma Permutation_incl X (a b: list X): Permutation a b -> incl a b.

Lemma pointwise_eq_refl A B (x: A -> B): pointwise_relation A eq x x.

Lemma complementary_filter_perm A (p: A -> bool) (l: list A):
  Permutation l (filter p l ++ filter (negb ∘ p) l).

Lemma filter_none X (p: X -> bool) (l: list X): (forall x, In x l -> p x = false) <-> filter p l = nil.

Lemma incl_map X Y (f: X -> Y) (a b: list X): incl a b -> incl (map f a) (map f b).

Lemma incl_in T (a b: list T): incl a b -> forall x, In x a -> In x b.

Lemma incl_In X (x: X) (l: list X): In x l -> forall l', incl l l' -> In x l'.

Lemma NoDup_filter T (p: T -> bool) (l: list T):
  NoDup l -> NoDup (filter p l).

Lemma length_excl_counts X (p: X -> bool) (l: list X):
  length l = count p l + count (negb ∘ p) l.

Lemma count_filtered X (p q: X -> bool):
  (forall x, q x = true -> p x = false) ->
  forall l, count p (filter q l) = 0.

Lemma app_nil_r T (l: list T): l ++ nil = l.

Hint Resolve Permutation_map.

Lemma map_cons T U (f: T -> U) (h: T) (l: list T): map f (h :: l) = f h :: map f l.

Definition concat {T}: list (list T) -> list T := fold_right (@app _) nil.

Lemma concat_app T (x y: list (list T)): concat (x ++ y) = concat x ++ concat y.

Lemma In_concat X (l: list (list X)) (s: list X) (x: X): In x s -> In s l -> In x (concat l).

Lemma In_concat_inv X (x: X) (l: list (list X)):
  In x (concat l) -> exists s, In x s /\ In s l.

Definition eq_count X (d: forall (x y: X), { x = y } + { x <> y }) (x: X): list X -> nat :=
 count (fun y => unsum_bool (d x y)).

Lemma eq_count_0 X (d: forall (x y: X), { x = y } + { x <> y }) (x: X) l:
  ~ In x l -> eq_count d x l = 0%nat.

Lemma eq_count_NoDup X (d: forall (x y: X), { x = y } + { x <> y }) (x: X) l:
  NoDup l -> eq_count d x l <= 1.

Lemma NoDup_incl_Permutation A (a b: list A):
  length a = length b -> NoDup a -> incl a b -> Permutation a b.

Lemma NoDup_map' A B (f: A -> B) (l: list A):
  (forall x y: A, In x l -> In y l -> x <> y -> f x <> f y) ->
  NoDup l -> NoDup (map f l).

Lemma NoDup_map A B (f: A -> B) l:
  (forall x y, In x l -> In y l -> f x = f y -> x = y) -> NoDup l -> NoDup (map f l).

Inductive InP (X: Type) (P: X -> Prop): list X -> Prop :=
  | InP_head x t: P x -> InP P (x :: t)
  | InP_tail x t: InP P t -> InP P (x :: t).

Inductive NoDupL (A: Type): list (list A) -> Prop :=
  | NoDupL_nil: NoDupL nil
  | NoDupL_cons (l: list A) (ll: list (list A)): NoDup l ->
      (forall x, In x l -> ~ InP (In x) ll) -> NoDupL ll -> NoDupL (l :: ll).

Hint Constructors NoDupL.

Lemma InP_In (X: Type) (l: list X) (ll: list (list X)): In l ll -> forall x, In x l -> InP (In x) ll.

Lemma InP_In_inv X (x: X) (ll: list (list X)):
  InP (In x) ll -> exists l, In x l /\ In l ll.

Arguments InP_In_inv [X x ll].

Lemma NoDup_concat A (l: list (list A)): NoDupL l -> NoDup (concat l).

Lemma In_filter_inv A (f: A -> bool) (x: A) (l: list A): In x (filter f l) -> In x l /\ f x = true.

Section Partitioning.

  Variable T: Set.

  Definition Partitioning: Set := comparison -> list T.

  Lemma partition_oblig c l h
    (H: {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) l}):
    Permutation
      ((if cmp_cmp c Eq then h :: proj1_sig H Eq else proj1_sig H Eq) ++
      (if cmp_cmp c Lt then h :: proj1_sig H Lt else proj1_sig H Lt) ++
      (if cmp_cmp c Gt then h :: proj1_sig H Gt else proj1_sig H Gt))
      (h :: l).

  Definition addToPartitioning (c: comparison) (l: list T) (h: T) (H: {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) l}): {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) (h :: l)} :=
    exist (fun p => Permutation (p Eq ++ p Lt ++ p Gt) (h :: l))
      (fun c' => if cmp_cmp c c' then h :: proj1_sig H c' else proj1_sig H c')
      (partition_oblig c h H).

  Definition emp: {p: Partitioning | Permutation (p Eq ++ p Lt ++ p Gt) nil} :=
    exist (fun p => Permutation (p Eq ++ p Lt ++ p Gt) nil) (fun _ => nil) (perm_nil T).

End Partitioning.

Fixpoint repeat T (n: nat) (x: T): list T :=
  match n with
  | 0 => nil
  | S n' => x :: repeat n' x
  end.

Lemma map_concat T U (l: list (list T)) (f: T -> U): map f (concat l) = concat (map (map f) l).

Lemma length_0_nil A (l: list A): length l = 0%nat <-> l = nil.

Lemma length_ne_0_ne_nil A (l: list A): length l <> 0%nat -> l <> nil.

Lemma elemsR_le_S a b: elemsR le a b -> elemsR le (map S a) (map S b).

Lemma elemsR_map A (R: relation A) f l:
  (forall x, In x l -> R (f x) x) -> elemsR R (map f l) l.

Lemma elemsR_map_map (X Y: Type) (f g: Y -> X) (l: list Y) (R: relation X): (forall x, In x l -> R (f x) (g x)) -> elemsR R (map f l) (map g l).

Lemma elemsR_impl A (R R' : relation A): (forall x y: A, R x y -> R' x y) -> forall l l', elemsR R l l' -> elemsR R' l l'.

Section Permuted.

  Context {A: Type} (R: relation A).

  Inductive Permuted: relation (list A) :=
    | permuted_nil : Permuted nil nil
    | permuted_skip : forall (x x': A), R x x' -> forall (l l' : list A), Permuted l l' -> Permuted (x :: l) (x' :: l')
    | permuted_swap : forall (x y: A) (l: list A), Permuted (y :: x :: l) (x :: y :: l)
    | permuted_trans : forall l l' l'' : list A, Permuted l l' -> Permuted l' l'' -> Permuted l l''.

  Hint Constructors Permuted.

  Context {Rrefl: Reflexive R}.

  Lemma permuted_refl l: Permuted l l.

  Hint Immediate permuted_refl.

  Lemma elemsR_permuted l l': elemsR R l l' -> Permuted l l'.

  Lemma alt_permuted_swap (x x' y y': A): R x x' -> R y y' ->
    forall (l l': list A), elemsR R l l' -> Permuted (y :: x :: l) (x' :: y' :: l').

End Permuted.

Hint Constructors Permuted.

Lemma map_map_comp A B C (f: A -> B) (g: B -> C) (l: list A):
  map g (map f l) = map (g ∘ f) l.

Lemma concat_map_singleton A (l: list A): concat (map (fun x => x :: nil) l) = l.

Lemma Permuted_sub A (R: relation A) x y: Permuted R x y -> forall (R': relation A), (forall x y, R x y -> R' x y) -> Permuted R' x y.

Lemma Permuted_map A B (R: relation B) (f: A -> B): Proper (Permuted (on f R) ==> Permuted R) (map f).

Definition add := fold_right plus (0%nat).

Lemma add_same c l: (forall x, In x l -> x = c) -> add l = length l * c.

Lemma length_concat T (l: list (list T)):
  length (concat l) = add (map (@length _) l).

Lemma concat_map_nil T U (l: list T): concat (map (fun _ => nil) l) = @nil U.

Definition product A B (aa: list A) (bb: list B): list (A * B) :=
  concat (map (fun a => map (pair a) bb) aa).

Lemma concat_map_singleton_f T A (f: A -> T) l: concat (map (fun x : A => (f x)::nil) l) = map f l.

Lemma map_concat_map T U V (g: T -> list U) (f: U -> V) l:
  map f (concat (map g l)) = concat (map (map f ∘ g) l).

Lemma concat_concat T (x: list (list (list T))):
  concat (concat x) = concat (map concat x).

Section two_lists_rect.

  Variables (T: Type) (P: list T -> list T -> Type)
    (Pnil_l: forall x, P nil x) (Pnil_r: forall x, P x nil)
    (Pcons: forall x x' y y', P x' (y :: y') -> P (x :: x') y' -> P (x :: x') (y :: y')).

  Let R: relation (list T * list T) := pair_rel (ltof (list T) (@length _)) (ltof (list T) (@length _)).

  Let wf_R: well_founded R.

  Lemma two_lists_rect_pre (p: list T * list T): P (fst p) (snd p).

  Definition two_lists_rect x y: P x y := two_lists_rect_pre (x, y).

Instance map_Permutation_mor T U (f: T -> U): Proper (Permutation ==> Permutation) (map f) :=
  Permutation_map f.

Lemma concatMap_concatMap' T U V (g: T -> list U) (f: U -> list V) l:
  concat (map f (concat (map g l))) = concat (map (concat ∘ map f ∘ g) l).

Lemma Permutation_concatMap T U (f g: T -> list U) l:
  (forall x, In x l -> Permutation (f x) (g x)) ->
  Permutation (concat (map f l)) (concat (map g l)).

Hint Resolve Permutation_concat.

Lemma Permutation_concat_map_app T A (f g: A -> list T) l:
  Permutation (concat (map (fun x => f x ++ g x) l)) (concat (map f l ++ map g l)).

Lemma concat_product T U V (f: U -> T -> list V) l l':
  Permutation
    (concat (map (fun x => concat (map (fun y => f y x) l')) l))
    (concat (map (fun x => concat (map (f x) l)) l')).

Section splits_and_perms.

  Context {T: Type}.

  Fixpoint splits (l: list T): list (T * list T) :=
    match l with
    | nil => nil
    | h :: t => (h, t) :: map (fun xy => (fst xy, h :: snd xy)) (splits t)
    end.

  Lemma length_splits l: length (splits l) = length l.

  Lemma splits_are_perms l p: In p (splits l) -> Permutation (fst p :: snd p) l.

  Lemma length_in_splits l p: In p (splits l) -> S (length (snd p)) = length l.

  Fixpoint insert_everywhere (x: T) (l: list T): list (list T) :=
    match l with
    | nil => (x :: nil) :: nil
    | h :: t => (x :: h :: t) :: map (cons h) (insert_everywhere x t)
    end.

  Lemma insert_everywhere_are_perms x l:
    forall y, In y (insert_everywhere x l) -> Permutation y (x :: l).

  Lemma length_insert_everywhere x l:
    length (insert_everywhere x l) = S (length l).

  Definition perms: list T -> list (list T)
    := fold_right (fun h => concat ∘ map (insert_everywhere h)) (nil :: nil).

  Lemma perms_are_perms l a: In a (perms l) -> Permutation a l.

  Lemma length_perms l: length (perms l) = fact (length l).

  Definition alt_perms l: list (list T) :=
    match l with
    | nil => nil :: nil
    | _ => concat (map (fun p => (map (cons (fst p)) (perms (snd p)))) (splits l))
    end.

  Lemma splits_permuted (l l': list T): Permutation l l' ->
    Permuted (fun x y => fst x = fst y /\ Permutation (snd x) (snd y)) (splits l) (splits l').

  Inductive merges_spec: list T -> list T -> list (list T) -> Prop :=
    | merges_left_nil x: merges_spec nil x (x :: nil)
    | merges_right_nil x: merges_spec x nil (x :: nil)
    | merges_cons x y h t r r':
      merges_spec y (h :: t) r ->
      merges_spec (x :: y) t r' ->
      merges_spec (x :: y) (h :: t) (map (cons x) r ++ map (cons h) r').

  Hint Constructors merges_spec.

  Lemma merges_uniq a b r:
    merges_spec a b r ->
    forall r', merges_spec a b r' -> r = r'.

  Lemma length_merges (F: nat -> nat -> nat) a b r:
    (forall n, F 0 n = 1) ->
    (forall n, F n 0 = 1) ->
    (forall n n', F n (S n') + F (S n) n' = F (S n) (S n')) ->
    merges_spec a b r -> length r = F (length a) (length b).

  Definition me (ab: list T * list T): nat := length (fst ab) + length (snd ab).

  Program Fixpoint merges_ex (ab: list T * list T) {measure (me ab)}: sig (merges_spec (fst ab) (snd ab)) :=
    match ab with
    | (nil, x) => x :: nil
    | (x, nil) => x :: nil
    | (x :: y, h :: t) => map (cons x) (merges_ex (y, h :: t)) ++ map (cons h) (merges_ex (x :: y, t))
    end.

  Definition merges (a b: list T): list (list T) := proj1_sig (merges_ex (a, b)).

  Lemma merges_real_eq a b: merges a b =
    match a, b with
    | nil, x => x :: nil
    | x, nil => x :: nil
    | x :: y, h :: t => map (cons x) (merges y (h :: t)) ++ map (cons h) (merges (x :: y) t)
    end.

  Lemma merges_nil_r a: merges a [] = [a].

  Hint Resolve Permutation_concat.

  Lemma product_app: forall T (a b c: list T), product (a ++ b) c = product a c ++ product b c.

  Lemma product_concat: forall T (a: list (list T)) (b: list T), product (concat a) b = concat (map (flip (@product _ _) b) a).

  Lemma concatMap_insert_everywhere_comm x y l: Permutation
    (concat (map (insert_everywhere x) (insert_everywhere y l)))
    (concat (map (insert_everywhere y) (insert_everywhere x l))).

  Lemma merges_insert_everywhere a l: insert_everywhere a l = merges (a :: nil) l.

  Lemma merges_insert_everywhere' a l: Permutation (insert_everywhere a l) (merges l (a :: nil)).

  Lemma insert_everywhere_merges_commute a x y: Permutation
    (concat (map (insert_everywhere a) (merges y x)))
    (concat (map (merges y) (insert_everywhere a x))).

  Lemma merges_sym x y: Permutation (merges x y) (merges y x).

  Hint Immediate merges_sym.

  Lemma perms_app (a b: list T): Permutation (perms (a ++ b)) (concat (map (uncurry merges) (product (perms a) (perms b)))).

  Lemma filter_merges p (x y: list T):
     (forall z, In z x -> p z = true) ->
     (forall z, In z y -> p z = false) ->
     forall r, In r (map (filter p) (merges x y)) -> r = x.

  Lemma merges_ne_nil x y: merges x y <> nil.

End splits_and_perms.

Existing Instance Permutation_perms.

Lemma map_repeat A B (f: A -> B) c (l: list A):
  (forall x, In x l -> f x = c) -> map f l = repeat (length l) c.

Lemma repeat_plus T (c: T) n m: repeat (n + m) c = repeat n c ++ repeat m c.

Lemma concat_repeat T n m (c: T): concat (repeat n (repeat m c)) = repeat (n * m) c.

Lemma filter_perms T p (l: list T):
  Permutation
    (map (filter p) (perms l))
    (concat (map (repeat (fact (length (filter (negb ∘ p) l)) * length (merges (filter p l) (filter (negb ∘ p) l)))) (perms (filter p l)))).

Instance Permutation_length_morphism T: Proper (Permutation ==> eq) (@length T) :=
  @Permutation_length T.

Lemma repeat_map_comm A B (f: A -> B) n: ext_eq (map f ∘ repeat n) (repeat n ∘ f).

Lemma length_repeat T (c: T) n: length (repeat n c) = n.

Lemma concat_nil X (l: list (list X)): (forall x, In x l -> x = nil) -> concat l = nil.

Lemma empty_nil X (x: list X): length x = 0%nat -> x = nil.

Lemma Permuted_Permutation_map T U (R: relation T) (f: T -> U):
  (forall x y, R x y -> f x = f y) -> forall a b,
  Permuted R a b ->
  Permutation (map f a) (map f b).

Lemma elemsR_length A (R: A -> A -> Prop) a b (H: elemsR R a b):
  length a = length b.

Lemma elemsRimpl A B (R: A -> B -> Prop) (l: list A): (forall x, In x l -> sig (R x)) -> sig (elemsR R l).

Lemma elemsRuniq A B (R: A -> B -> Prop) (l: list A):
  (forall x, In x l -> forall y, R x y -> forall y', R x y' -> y = y') -> forall r, elemsR R l r -> forall r', elemsR R l r' -> r = r'.

Definition triple0 A B C (t: A * B * C): A := fst (fst t).
Definition triple1 A B C (t: A * B * C): B := snd (fst t).
Definition triple2 A B C (t: A * B * C): C := snd t.

Fixpoint rsplits T (l: list T): list (list T * T * list T) :=
  match l with
  | nil => nil
  | h :: t => (nil, h, t) :: map (fun p => (h :: triple0 p, triple1 p, triple2 p)) (rsplits t)
  end.

Lemma splits_rsplits (T: Set) (l: list T): splits l = map (fun p => (triple1 p, triple0 p ++ triple2 p)) (rsplits l).

Lemma insert_everywhere_rsplits (T: Set) (x: T) (l: list T):
  insert_everywhere x l =
   map (fun x0 => triple0 x0 ++ x :: triple1 x0 :: triple2 x0) (rsplits l) ++ [l ++ [x]].

Lemma elemsR_map':
  forall (A B: Type) (Ra: relation A) (Rb: relation B) (f : A -> B)
    (fR: forall x y, Ra x y -> Rb (f x) (f y)) (l l': list A),
      elemsR Ra l l' -> elemsR Rb (map f l) (map f l').

Lemma concatMap_insert_everywhere T (x: T) (l: list (list T)):
  Permutation
    (concat (map (insert_everywhere x) l))
    (map (cons x) l ++ concat (map (tail ∘ insert_everywhere x) l)).

Lemma map_length_filter_permuted_splits T (l l': list T): Permutation l l' ->
  forall p,
  Permutation
    (map (fun x => length (filter (p (fst x)) (snd x))) (splits l))
    (map (fun x => length (filter (p (fst x)) (snd x))) (splits l')).

Lemma perms_alt_perms T (l: list T): Permutation (perms l) (alt_perms l).

Lemma map_single A B (f: A -> B) x: map f [x] = [f x]. *)

Require Import Le.

Require Import Plus.

Require Import Lt.

Require Import arith_lems.
(* arith_lems:
Set Implicit Arguments.
Unset Standard Proposition Elimination Names.

Require Import util.
Require Import Le.
Require Import Lt.
Require Import Rbase.
Require Import Plus.
Require Import Mult.
Require Import Arith.
Require Import Omega.
Require Import Div2.
Require Import Recdef.
Require Import Rbase.
Require Import Morphisms.

Definition ltb (x y: nat): bool := negb (leb y x).
Definition geb (x y: nat): bool := leb y x.

Ltac subst_tac x y z := 
  match z with
  | x => y
  | ?l + ?r =>
      let l' := subst_tac x y l in
      let r' := subst_tac x y r in
        constr: (l' + r')
  | ?l * ?r =>
      let l' := subst_tac x y l in
      let r' := subst_tac x y r in
        constr: (l' * r')
  | _ => z
  end.

Ltac deep_le_trans h :=
  match type of h with
  | ?n <= ?u =>
    match goal with
    | |- ?l <= _ =>
      let q := subst_tac n u l
      in apply le_trans with q
    end
  end.

Instance Transitive_le: Transitive le := le_trans.

Lemma minus_plus_same (y x: nat): x <= x - y + y.

Lemma ltb_complete m n: ltb m n = true -> m < n.

Lemma ltb_complete_conv m n: ltb m n = false -> n <= m.

Lemma lt_0_mult x y: 0 < x -> 0 < y -> 0 < x * y.

Lemma mult_ne_0 a b: (a <> 0 -> b <> 0 -> mult a b <> 0)%nat.

Lemma weak_lt_S_n n m: S n < m -> n < m.

Lemma le_exists_plus (x y: nat) (p: x <= y): exists d, y = x + d.

Lemma lt_exists_plus (x y: nat) (p: x < y): exists d, y = S (x + d).

Lemma n_lt_n_plus_Sm n m: n < n + S m.

Lemma ne_le_impl_lt x y: x <> y -> x <= y -> x < y.

Hint Rewrite plus_0_r : arith_norm.
Hint Rewrite mult_plus_distr_r mult_plus_distr_l plus_assoc : arith_norm.

Lemma beq_nat_false x y: x <> y -> beq_nat x y = false.

Lemma minus_lt_compat_l x y z: (y <= x -> z < y -> x - y < x - z)%nat.

Lemma minus_eq_inv_r d x y: (x <= d -> y <= d -> (d - x = d - y) -> x = y)%nat.

Lemma le_ne_lt x y: x <= y -> x <> y -> x < y.

Lemma ne_nlt_lt x y: x <> y -> ~ x < y -> y < x.

Lemma lt_not_eq x y: (x < y -> x <> y)%nat.

Lemma lt_not_eq_sym x y: (y < x -> x <> y)%nat.

Hint Resolve lt_not_eq.
Hint Resolve lt_not_eq_sym.

Definition sqrd n := n * n.

Lemma sqrd_S n: sqrd (S n) = sqrd n + n + n + 1.

Lemma sqrd_plus x y: sqrd x + sqrd y <= sqrd (x + y).

Lemma sqrd_le x y: x <= y -> sqrd x <= sqrd y.

Hint Resolve sqrd_plus sqrd_le.

Lemma div2_preserves_le x y: x <= y -> div2 x <= div2 y.

Lemma Sdiv2_eq_div2SS x: S (div2 x) = div2 (S (S x)).

Lemma div2S_le_Sdiv2 x: div2 (S x) <= S (div2 x).

Lemma div2_x_plus_Sx b: div2 (b + S b) = b.

Lemma div2_x_plus_2y a b: div2 (a + 2 * b) = div2 a + b.

Lemma div2_sqrdSn n: div2 (sqrd n) + n <= div2 (sqrd (S n)).

Lemma le_div2 n: div2 n <= n.

Lemma div2_lt_inv0 x y: div2 x < div2 y -> x < y.

Lemma div2_lt_inv x y: div2 x < div2 y -> x <= y.

Lemma div2_le_div2_inv x y: div2 x <= div2 y -> x <= S y.

Lemma div2_cancel n: div2 (2 * n) = n.

Lemma div2_le_inv x n: div2 x <= n -> x <= S (2 * n).

Fixpoint pow (b e: nat) {struct e}: nat :=
  match e with
  | 0 => 1
  | S e' => b * pow b e'
  end.

Lemma pow_S x y: pow x (S y) = x * pow x y.

Lemma pow_min x: x <> 0%nat -> forall y, 0 < pow x y.

Lemma ceil_log2_S_def n: ceil_log2_S n =
  match n with
  | 0 => 0
  | S _ => S (ceil_log2_S (div2 n))
  end.

Definition log2ceil (n: nat): nat :=
  match n with
  | 0 => 0
  | S n' => ceil_log2_S n'
  end.

Lemma pow2_ceil_log2: forall n, S n <= pow 2 (ceil_log2_S n).

Lemma ceil_log2_Sn_le_n: forall n, ceil_log2_S n <= n.

Lemma log2ceil_lt: forall n, 0 < n -> log2ceil n < n.

Lemma log2ceil_le: forall n, log2ceil n <= n.

Lemma log2ceil_S_preserves_le x y: x <= y -> ceil_log2_S x <= ceil_log2_S y.

Lemma log2ceil_preserves_le x y: x <= y -> log2ceil x <= log2ceil y.

Lemma INR_S_ne_0 n: INR (S n) <> 0%R.

Hint Resolve INR_S_ne_0.

Lemma O_le_inv_INR_S n: (0 <= / INR (S n))%R.

Hint Resolve O_le_inv_INR_S.

Lemma INR_0_inv n: INR n = 0%R -> n = 0.

Lemma O_lt_INR_S n: (0 < INR (S n))%R.

Hint Resolve O_lt_INR_S.

Require Import Fourier.

Ltac deep_Rle_trans h :=
  match type of h with
  | ?n <= ?u =>
    match goal with
    | |- (?l <= _)%R =>
      let q := subst_tac n u l
      in apply Rle_trans with q
    | _ => assert (False)
    end
  end.

Lemma Rmult_eq_compat_r (r r1 r2: R): (r1 = r2 -> r1 * r = r2 * r)%R.

Lemma Rle_eq_trans x y z: (x <= y -> y = z -> x <= z)%R.

Lemma Req_ne_dec (x y: R): { x = y } + { x <> y }.

Lemma Rmult_0_inv (a b: R): (a * b)%R = 0%R -> (a = 0%R \/ b = 0%R).

Lemma Req_le_trans x y z: x = y -> y <= z -> x <= z.

Lemma Rle_plus_trans_l r a b c: a <= r -> r + b <= c -> a + b <= c.

Lemma Rne_nlt_lt x y: x <> y -> ~ x < y -> y < x.

Lemma Rdiv_le_1 a b: 0 < a -> a <= b -> 1 <= b / a.

Lemma Rdiv_lt_1 n m: 0 <= n -> n < m -> n / m < 1.

Lemma zero_le_2_div_Sn n: 0 <= (2 * / INR (S n))%R.

Hint Resolve zero_le_2_div_Sn.

Definition bigO (f g: nat -> R): Prop := exists c, exists n, forall x, (n <= x)%nat -> f x <= c * g x.

Definition measured_bigO (X: Set) (m: X -> nat) (f: X -> R) (g: nat -> R): Prop
  := exists c, exists n, forall x, (n <= m x)%nat -> f x <= c * g (m x).

Notation "'over' m , f =O( g )" := (measured_bigO m f g). *)

Require Vector.

Require Import Relations.

Require List.

Require Import Omega.



Arguments Vector.cons [A] _ [n].

Arguments Vector.nil [A].



Definition head A n (v: Vector.t A (S n)): A :=

  match v with

  | Vector.nil => I | Vector.cons h _ _ => h

  end.



Definition tail n A (v: Vector.t A (S n)): Vector.t A n :=

  match v with

  | Vector.nil => I | Vector.cons _ _ t => t

  end.



Lemma eq_nil A (v: Vector.t A 0): v = Vector.nil.

Proof.

  cut (forall n (v: Vector.t A n), match n return Vector.t A n -> Prop with 0 => fun v => v = Vector.nil | _ => fun _ => True end v).

    intros.

    apply (H 0 v).

  clear v; destruct v; auto.

Qed.



Lemma eq_cons A n (v: Vector.t A (S n)): v = Vector.cons (head v) (tail v).

Proof.

  cut (forall n (v: Vector.t A n),

      match n return Vector.t A n -> Prop with

      | 0 => fun _ => True

      | S m' => fun w => w = Vector.cons (head w) (tail w)

      end v).

    intros.

    apply (H (S n) v).

  clear v; destruct v; auto.

Qed.



Lemma Vcons_eq A (h h': A) n (t t': Vector.t A n): h = h' -> t = t' -> Vector.cons h t = Vector.cons h' t'.

Proof. intros. subst. reflexivity. Qed.



Lemma Vcons_eq_inv A (h h': A) n (t t': Vector.t A n): Vector.cons h t = Vector.cons h' t' -> h = h' /\ t = t'.

Proof with auto.

  intros.

  split...

    replace h with (head (Vector.cons h t))...

    replace h' with (head (Vector.cons h' t'))...

    rewrite H...

  replace t with (tail (Vector.cons h t))...

  replace t' with (tail (Vector.cons h' t'))...

  rewrite H...

Qed.



Fixpoint to_list X (n: nat) (v: Vector.t X n) {struct v}: List.list X :=

  match v with

  | Vector.nil => List.nil | Vector.cons x _ v' => List.cons x (to_list v')

  end.



Fixpoint from_list A (l: List.list A): Vector.t A (List.length l) :=

  match l return Vector.t A (List.length l) with

  | List.nil => Vector.nil | List.cons h t => Vector.cons h (from_list t)

  end.



Coercion to_list: Vector.t >-> List.list.

Coercion from_list: List.list >-> Vector.t.



Lemma list_round_trip A (l: List.list A): to_list (from_list l) = l.

Proof with try reflexivity. induction l... simpl. rewrite IHl... Qed.



Lemma vec_round_trip (X T: Set) (n : nat) (v : Vector.t X n) (f: forall n, Vector.t X n -> T):

  (f _ (from_list (to_list v))) = f _ v.

Proof with auto.

  revert f.

  induction v...

  intros.

  simpl.

  apply (IHv (fun (m: nat) (w: Vector.t X m) => f (S m) (Vector.cons h w))).

Qed.



Lemma eq_as_lists X n (x y: Vector.t X n): to_list x = to_list y -> x = y.

Proof with auto.

  induction n; intros.

    rewrite (eq_nil x), (eq_nil y)...

  rewrite (eq_cons x), (eq_cons y) in *...

  inversion H.

  rewrite (IHn (tail x) (tail y))...

Qed.



Lemma eq_list A (l: List.list A) (v: Vector.t A (List.length l)): from_list l = v -> l = to_list v.

Proof with auto.

  induction l; simpl; intros.

    rewrite (eq_nil v)...

  rewrite <- H...

  simpl.

  rewrite list_round_trip...

Qed.



Lemma double_rect A B (P: forall n, Vector.t A n -> Vector.t B n -> Prop):

  P 0 Vector.nil Vector.nil ->

  (forall n (v: Vector.t A n) (w: Vector.t B n) (x: A) (y: B), P n v w -> P (S n) (Vector.cons x v) (Vector.cons y w)) ->

  forall n (v: Vector.t A n) (w: Vector.t B n), P n v w.

Proof.

  induction n; intros.

    rewrite (eq_nil v). rewrite (eq_nil w). auto.

  rewrite (eq_cons v). rewrite (eq_cons w). auto.

Qed.



Lemma length A n (l: Vector.t A n): List.length l = n.

Proof with auto. induction l... simpl. apply eq_S... Qed.



Fixpoint app A n: Vector.t A n -> forall m, Vector.t A m -> Vector.t A (n + m) :=

  match n return Vector.t A n -> forall m, Vector.t A m -> Vector.t A (n + m) with

  | 0 => fun _ _ w => w

  | S n' => fun v _ w => Vector.cons (head v) (app (tail v) w)

  end.



Fixpoint map X Y (f: X -> Y) (n: nat) (v: Vector.t X n): Vector.t Y n :=

  match v with

  | Vector.nil => @Vector.nil Y

  | Vector.cons h _ t => Vector.cons (f h) (map f t)

  end.



Lemma map_map X Y Z (f: X -> Y) (g: Y -> Z) (n: nat) (v: Vector.t X n):

  map g (map f v) = map (g ∘ f) v.

Proof with auto.

  induction v...

  simpl.

  rewrite IHv...

Qed.



Lemma map_ext X Y (f g: X -> Y) (e: ext_eq f g) (n: nat) (v: Vector.t X n):

  map f v = map g v.

Proof with auto.

  induction v...

  simpl.

  rewrite IHv.

  rewrite (e h)...

Qed. 



Lemma In_map A B (f: A -> B) (a: A) n (v: Vector.t A n): List.In a v -> List.In (f a) (map f v).

Proof. induction v; intros; inversion_clear H; [left; subst | right]; auto. Qed.



Lemma List_map A B n (l: Vector.t A n) (f: A -> B): List.map f l = to_list (map f l).

Proof with auto.

  induction l...

  simpl.

  intros.

  rewrite IHl...

Qed.



Lemma natBelow0_rect: natBelow 0 -> forall T, T.

Proof. intros. inversion H. Qed.



Definition nof (n: nat) (_: natBelow n): nat := n.



Section mine.



Variable P: forall n: nat, natBelow n -> Type.

Variable Pz: forall p, P (mkNatBelow 0 p).

Variable Ps: forall v p, P (mkNatBelow v p) -> P (mkNatBelow (S v) p).



Fixpoint natBelow_rect (n: nat): forall nb: natBelow n, P nb :=

  match n with

  | 0 => fun nb => natBelow0_rect nb _

  | S x => fun nb =>

    match nb return (forall nb: natBelow (pred (nof nb)), P nb) -> P nb with

    | mkNatBelow 0 y => fun _ => Pz y

    | mkNatBelow (S z) y => fun U => Ps (U (mkNatBelow z y))

    end (@natBelow_rect x)

  end.



End mine.



Section another.



Variable P: forall n: nat, natBelow (S n) -> Type.

Variable Pz: forall p, P (mkNatBelow 0 p).

Variable Ps: forall v p, P (mkNatBelow v p) -> P (mkNatBelow (S v) p).



Definition R (n: nat): natBelow n -> Type :=

  match n with

  | 0 => fun _ => False

  | S _ => @P _

  end.



Definition natBelow_rect_S (n: nat) (nb: natBelow (S n)): P nb := natBelow_rect R Pz Ps nb.



End another.



Lemma val_Snb n (x: natBelow n): nb_val (Snb x) = S (nb_val x).

Proof. destruct x. reflexivity. Qed.



Lemma val_nb0 n: nb_val (nb0 n) = 0.

Proof. reflexivity. Qed.



Lemma natBelow_S_inv (n: nat) (nb: natBelow (S n)): { nb': natBelow n | nb = Snb nb' } + { nb = nb0 n }.

Proof with reflexivity.

  pattern n, nb.

  apply natBelow_rect_S.

    simpl.

    right...

  intros.

  left.

  destruct H.

    destruct s.

    exists (Snb x).

    rewrite <- e...

  exists (nb0 (v + p)).

  rewrite <- e...

Qed.



Definition natBelow_S_bla (T: Type) (n: nat) (b: natBelow n): T -> (natBelow (pred n) -> T) -> T :=

  match b with

  | mkNatBelow 0 _ => fun z s => z

  | mkNatBelow (S i) p => fun z s => s (mkNatBelow i p)

  end.



Lemma natBelow_S_inv' (n: nat) (P: natBelow (S n) -> Type):

  P (nb0 n) -> (forall m, P (Snb m)) -> forall x, P x.

Proof. intros. destruct (natBelow_S_inv x); [destruct s | idtac]; subst; auto. Qed.

  

Fixpoint nth X (n: nat) (v: Vector.t X n): natBelow n -> X :=

  match v with

  | Vector.nil => fun nb => natBelow0_rect nb _

  | Vector.cons h k t => fun nb => natBelow_S_bla nb h (nth t)

  end.



Lemma nth_0 A n (v: Vector.t A (S n)):

  nth v (nb0 n) = head v.

Proof. intros. rewrite (eq_cons v). reflexivity. Qed.



Lemma nth_S A p (v: Vector.t A (S p)) (n: natBelow p):

  nth v (Snb n) = nth (tail v) n.

Proof.

  intros.

  rewrite (eq_cons v).

  simpl.

  unfold Snb.

  destruct n.

  reflexivity.

Qed.



Lemma nth_map A B (f: A -> B) n i (v: Vector.t A n):

  nth (map f v) i = f (nth v i).

Proof with auto.

  induction v.

    inversion i.

  simpl.

  destruct (natBelow_S_inv i).

    destruct s.

    subst.

    simpl.

    unfold natBelow_S_bla.

    unfold Snb.

    simpl.

    destruct x.

    apply IHv.

  subst...

Qed.



Lemma nb1 (n: natBelow 1): n = mkNatBelow 0 0.

Proof.

  intros.

  apply natBelow_unique.

  simpl.

  dependent simple inversion n.

  simpl.

  omega.

Qed.



Lemma ext_nth A n (x y: Vector.t A n): ext_eq (nth x) (nth y) -> x = y.

Proof with auto.

  revert n x y.

  apply (double_rect (fun n (x y: Vector.t A n) => ext_eq (nth x) (nth y) -> x = y))...

  intros.

  cset (H0 (nb0 n)).

  simpl in H1.

  subst.

  rewrite H...

  intro.

  cset (H0 (Snb x)).

  repeat rewrite nth_S in H1...

Qed.



Lemma In_nth A n i (v: Vector.t A n): List.In (nth v i) v.

Proof with auto.

  induction i using natBelow_rect in v |- *.

    simpl.

    intros.

    rewrite (eq_cons v).

    simpl head.

    left...

  intros.

  rewrite (eq_cons v).

  right.

  simpl plus.

  fold (Snb (mkNatBelow v0 p)).

  rewrite nth_S...

Qed.



Lemma to_list_app A n (v: Vector.t A n) m (w: Vector.t A m):

  to_list (app v w) = List.app (to_list v) (to_list w).

Proof with auto.

  induction n.

    intros.

    rewrite (eq_nil v)...

  intros.

  rewrite (eq_cons v).

  simpl.

  rewrite IHn...

Qed.



Lemma In_vec_inv A a n (v: Vector.t A n): List.In a v -> exists i, a = nth v i.

Proof with auto.

  induction v.

    intros.

    inversion H.

  intros.

  inversion_clear H.

    exists (nb0 n).

    simpl...

  destruct (IHv H0).

  exists (Snb x).

  rewrite nth_S...

Qed.



Lemma nb_val_eq_rec_r (k u: nat) (n: natBelow u) (h: k = u):

  nb_val (eq_rec_r natBelow n h) = nb_val n.

Proof. intros. unfold eq_rec_r, eq_rec, eq_rect. case (sym_eq h). auto. Qed.



Fixpoint take A n: forall m, Vector.t A (n + m) -> Vector.t A n :=

  match n return forall m, Vector.t A (n + m) -> Vector.t A n with

  | 0 => fun _ _ => Vector.nil

  | S n' => fun m v => Vector.cons (head v) (take n' m (tail v))

  end.



Fixpoint drop A n: forall m, Vector.t A (n + m) -> Vector.t A m :=

  match n return forall m, Vector.t A (n + m) -> Vector.t A m with

  | 0 => fun m v => v

  | S n' => fun m v => drop n' m (tail v)

  end.



Lemma split A n m (v: Vector.t A (n + m)): v = app (take n m v) (drop n m v).

Proof with auto.

  induction n...

  intros.

  simpl.

  rewrite <- IHn.

  apply eq_cons.

Qed.



Lemma eq_app_inv A n m (a b: Vector.t A n) (c d: Vector.t A m): app a c = app b d -> a = b /\ c = d.

Proof with auto.

  induction n in m, a, b, c, d |- *; simpl; intros.

    rewrite (eq_nil a).

    rewrite (eq_nil b)...

  destruct (Vcons_eq_inv H).

  destruct (IHn _ _ _ _ _ H1).

  split...

  rewrite (eq_cons a).

  rewrite (eq_cons b).

  rewrite H0.

  rewrite H2...

Qed.



Definition remove (T: Set) (n: nat) (v: Vector.t T (S n)) (nb: natBelow (S n)): Vector.t T n :=

  natBelow_rect_S

    (fun (n0: nat) (_: natBelow (S n0)) => Vector.t T (S n0) -> Vector.t T n0)

    (fun p => @tail p _)

    (fun v p H v0 => Vector.cons (head v0) (H (tail v0))) nb v.



Inductive Permutation (A: Type): forall n, Vector.t A n -> Vector.t A n -> Prop :=

  | perm_nil: Permutation Vector.nil Vector.nil

  | perm_skip (x: A) n (v v': Vector.t A n): Permutation v v' -> Permutation (Vector.cons x v) (Vector.cons x v')

  | perm_swap (x y: A) n (l: Vector.t A n): Permutation (Vector.cons y (Vector.cons x l)) (Vector.cons x (Vector.cons y l))

  | perm_trans n (l l' l'': Vector.t A n): Permutation l l' -> Permutation l' l'' -> Permutation l l''.



Hint Resolve perm_nil.

Hint Resolve perm_skip.

Hint Resolve perm_swap.



Lemma perm_sym (X: Set) n (a b: Vector.t X n): Permutation a b -> Permutation b a.

Proof with auto. intros p. induction p... apply perm_trans with l'... Qed.



Lemma perm_refl (X: Set) n (v: Vector.t X n): Permutation v v.

Proof. induction v; auto. Qed.



Lemma List_Permutation (X: Set) n (a b: Vector.t X n): Permutation a b -> Permutation.Permutation a b.

Proof with eauto.

  intros p.

  induction p; simpl...

Qed.



Lemma remove_head (T: Set) p (v: Vector.t T (S p)):

  remove v (mkNatBelow 0 p) = tail v.

Proof. reflexivity. Qed.



Lemma remove_tail (T: Set) n p (v: Vector.t T (S (S (n + p)))):

  remove v (mkNatBelow (S n) p) = Vector.cons (head v) (remove (tail v) (mkNatBelow n p)).

Proof. reflexivity. Qed.



Lemma in_remove (T: Set) x n (i: natBelow (S n)) (v: Vector.t T (S n)):

  List.In x v -> x <> nth v i -> List.In x (remove v i).

Proof with auto.

  revert v.

  pattern n, i.

  apply natBelow_rect_S.

    intros.

    rewrite remove_head.

    rewrite (eq_cons v) in H.

    simpl in H.

    destruct H...

    elimtype False.

    apply H0.

    fold (nb0 p).

    rewrite nth_0...

  intros.

  simpl plus.

  rewrite remove_tail.

  rewrite (eq_cons v0) in H0.

  destruct H0.

    left.

    assumption.

  right.

  apply H...

  clear H0.

  rewrite (eq_cons v0) in H1.

  simpl in H1...

Qed.



Lemma remove_map (A B: Set) (f: A -> B) n (i: natBelow (S n)) (v: Vector.t A (S n)):

  remove (map f v) i = map f (remove v i).

Proof with reflexivity.

  revert v.

  pattern n, i.

  apply natBelow_rect_S.

    simpl.

    intros.

    rewrite (eq_cons v).

    simpl.

    do 2 rewrite remove_head...

  intros.

  simpl plus.

  cset remove_tail.

  simpl plus in *.

  rewrite H0.

  rewrite H0.

  simpl.

  rewrite <- H.

  rewrite (eq_cons v0).

  reflexivity.

Qed.



Lemma remove_perm (T: Set) n (nb: natBelow (S n)) (v: Vector.t T (S n)):

  Permutation (Vector.cons (nth v nb) (remove v nb)) v.

Proof with auto.

  revert v.

  pattern n, nb.

  apply natBelow_rect_S.

    simpl.

    intros.

    rewrite remove_head.

    rewrite (eq_cons v).

    simpl.

    apply perm_refl.

  intros.

  simpl plus.

  rewrite remove_tail.

  cset (H (tail v0)).

  clear H.

  simpl plus in *.

  cset' (remove (tail v0) (mkNatBelow v p)).

  fold (Snb (mkNatBelow v p)).

  rewrite nth_S.

  cut (Permutation (Vector.cons (nth (tail v0) (mkNatBelow v p)) (Vector.cons (head v0) H)) (Vector.cons (head v0) (tail v0))).

    rewrite <- eq_cons.

    intros...

  apply perm_trans with (Vector.cons (head v0) (Vector.cons (nth (tail v0) (mkNatBelow v p)) H))...

Qed.



Require Import skip_list.
(* skip_list:
Set Implicit Arguments.

Require Import List.

Section contents.

  Variable T: Set.

  Inductive SkipList: list T -> list T -> Prop :=
    | SkipList_head (x: T) l l': SkipList l l' -> SkipList (x :: l) (x :: l')
    | SkipList_tail (x: T) l l': SkipList l l' -> SkipList l (x :: l')
    | SkipList_nil l: SkipList nil l.

  Hint Constructors SkipList.

  Lemma SkipList_refl (l: list T): SkipList l l.

  Lemma SkipList_filter (p: T -> bool) (l: list T): SkipList (filter p l) l.

  Hint Immediate SkipList_filter.

  Lemma SkipList_incl (y x: list T): SkipList x y -> incl x y.

  Lemma NoDup_SkipList (l: list T): NoDup l -> forall l', SkipList l' l -> NoDup l'.

  Lemma SkipList_trans (y x: list T): SkipList x y -> forall z, SkipList y z -> SkipList x z.

End contents.

Hint Constructors SkipList.
Hint Resolve SkipList_refl.

Lemma SkipList_map (A: Set) (x y: list A): SkipList x y -> forall (B: Set) (f: A -> B), SkipList (map f x) (map f y). *)



Lemma SkipList_tail (A: Set) n (v: Vector.t A (S n)): SkipList (tail v) v.

Proof.

  intros.

  rewrite (eq_cons v).

  simpl.

  apply SkipList_tail.

  apply SkipList_refl.

Qed.



Lemma SkipList_remove (A: Set) n (nb: natBelow (S n)) (l: Vector.t A (S n)):

  SkipList (remove l nb) l.

Proof.

  revert l.

  pattern n, nb.

  apply natBelow_rect_S.

    simpl.

    intros.

    rewrite remove_head.

    apply SkipList_tail.

  intros.

  destruct v.

    simpl.

    rewrite (eq_cons l).

    simpl.

    apply SkipList_head.

    apply SkipList_tail.

  cset (remove_tail (S v) p l).

  simpl plus in *.

  rewrite H0.

  cset (H (tail l)).

  apply SkipList_trans with (List.cons (head l) (tail l)).

    simpl.

    apply SkipList_head.

    assumption.

  rewrite (eq_cons l).

  simpl.

  apply SkipList_refl.

Qed.



Definition remove_In (X: Set) n (v: Vector.t X (S n)) x i (p: List.In x (remove v i)): List.In x v

  := incl_In x p (SkipList_incl (SkipList_remove i v)).



Lemma trans_plus_n_Sm n m: n + S m = S (n + m).

Proof.

  induction n; simpl.

    reflexivity.

  intros.

  apply eq_S.

  apply IHn.

Defined.



Fixpoint nats (x n: nat) {struct n}: Vector.t (natBelow (x + n)) n :=

  match n as n0 return Vector.t (natBelow (x + n0)) n0 with

  | 0 => Vector.nil

  | S n0 => map (fun d => eq_rec_r natBelow d (trans_plus_n_Sm x n0))

    (Vector.cons (mkNatBelow x n0) (nats (S x) n0))

  end.



Definition nb_nats (x n: nat): Vector.t nat n := map nb_val (nats x n).



Lemma nats_S (x n: nat): nats x (S n) =

  map (fun d => eq_rec_r natBelow d (trans_plus_n_Sm x n)) (Vector.cons (mkNatBelow x n) (nats (S x) n)).

Proof. reflexivity. Qed.



Lemma nb_nats_S (x n: nat): nb_nats x (S n) = Vector.cons x (nb_nats (S x) n).

Proof with reflexivity.

  unfold nb_nats.

  intros.

  simpl.

  apply Vcons_eq.

    rewrite nb_val_eq_rec_r...

  rewrite map_map.

  apply map_ext.

  intro.

  unfold compose.

  rewrite nb_val_eq_rec_r...

Qed.



Lemma In_nats_S v u w: List.In w (nats u v) -> List.In (Snb w) (nats (S u) v).

Proof with auto. 

  induction v in u, w |- *...

  simpl.

  intros.

  destruct H.

    left.

    subst.

    apply natBelow_unique.

    rewrite val_Snb.

    rewrite nb_val_eq_rec_r.

    rewrite nb_val_eq_rec_r...

  right.

  rewrite <- List_map in H.

  destruct (In_map_inv H). clear H.

  destruct H0.

  subst.

  set (fun d: natBelow (S (S (u + v))) => eq_rec_r natBelow d (eq_S (u + S v) (S (u + v)) (trans_plus_n_Sm u v))).

  replace (Snb (eq_rec_r natBelow x (trans_plus_n_Sm u v))) with (n (Snb x)).

    rewrite <- List_map.

    apply List.in_map.

    apply (IHv (S u))...

  apply natBelow_unique.

  subst n.

  simpl.

  rewrite val_Snb.

  repeat rewrite nb_val_eq_rec_r.

  rewrite val_Snb...

Qed.



Lemma In_nb_nats v n m: List.In (v + m) (nb_nats m (S (v + n))).

Proof with auto.

  induction v in n, m |- *.

    simpl.

    intros.

    left.

    rewrite nb_val_eq_rec_r...

  simpl.

  intros.

  repeat rewrite nb_val_eq_rec_r.

  simpl.

  cset (IHv n m).

  simpl in H.

  rewrite nb_val_eq_rec_r in H.

  destruct H.

    right.

    left.

    simpl.

    simpl in H.

    apply eq_S...

  rewrite map_map in H.

  rewrite <- List_map in H.

  destruct (In_map_inv H). clear H.

  destruct H0.

  unfold compose in H.

  rewrite nb_val_eq_rec_r in H.

  simpl.

  right.

  right.

  rewrite map_map.

  rewrite map_map.

  unfold compose.

  assert (ext_eq (fun x1: natBelow (S (S (m + (v + n)))) => nb_val (eq_rec_r natBelow (eq_rec_r natBelow x1 (eq_S (m + S (v + n)) (S (m + (v + n))) (trans_plus_n_Sm m (v + n)))) (trans_plus_n_Sm m (S (v + n))))) nb_val).

    intro.

    repeat rewrite nb_val_eq_rec_r...

  rewrite (map_ext H1).

  replace (S (v + m)) with (nb_val (Snb x)).

    rewrite <- List_map.

    apply List.in_map.

    apply (In_nats_S (v + n) (S m))...

  clear H1 H0.

  destruct x.

  simpl in *.

  apply eq_S...

Qed.



Lemma In_nb_nats' x m n: m <= x -> x < m + n -> List.In x (nb_nats m n).

Proof with auto.

  intros.

  destruct (le_exists_plus H).

  subst.

  assert (x0 < n) by omega.

  destruct (lt_exists_plus H1).

  subst.

  rewrite plus_comm.

  apply In_nb_nats.

Qed.



Lemma In_as_nb_val n (x: natBelow n) m (l: Vector.t (natBelow n) m):

  List.In (nb_val x) (map nb_val l) -> List.In x l.

Proof with auto.

  intros.

  rewrite <- List_map in H.

  destruct (In_map_inv H). clear H.

  destruct H0.

  rewrite <- (natBelow_unique _ _ H)...

Qed.



Lemma In_nats_0 n x: List.In x (nats 0 n).

Proof.

  intros.

  apply In_as_nb_val.

  simpl in x.

  dependent inversion_clear x.

  simpl @nb_val.

  cset (In_nb_nats v p 0).

  rewrite plus_0_r in H.

  assumption.

Qed.



Lemma S_rect A n (P: Vector.t A (S n) -> Type):

  (forall h t, P (Vector.cons h t)) -> forall v, P v.

Proof. intros. rewrite (eq_cons v). apply X. Qed.



Lemma In_inv_perm (X: Set) (x: X) n (v: Vector.t X (S n)):

  List.In x v -> exists v': Vector.t X n, Permutation (Vector.cons x v') v.

Proof with auto.

  induction n in v |- *.

    rewrite (eq_cons v).

    rewrite (eq_nil (tail v)).

    intros.

    destruct H.

      subst.

      exists (tail v).

      rewrite (eq_nil (tail v)).

      apply perm_refl.

    elimtype False...

  pattern v. apply S_rect. clear v.

  intros h t. pattern t. apply S_rect. clear t.

  intros.

  simpl in H.

  destruct H.

    subst.

    exists (Vector.cons h0 t).

    apply perm_refl.

  destruct (IHn (Vector.cons h0 t) H).

  exists (Vector.cons h x0).

  apply perm_trans with (Vector.cons h (Vector.cons x x0)).

    apply perm_swap.

  apply perm_skip...

Qed.



Lemma NoDup_incl_Permutation (A: Set) n (a b: Vector.t A n):

  List.NoDup a -> List.incl a b -> Permutation a b.

Proof with auto.

  induction n.

    intros.

    rewrite (eq_nil a).

    rewrite (eq_nil b).

    apply perm_nil.

  pattern a. apply S_rect. clear a. intros ha ta.

  pattern b. apply S_rect. clear b. intros hb tb.

  intros.

  assert (List.In ha (Vector.cons hb tb)).

    apply H0.

    left...

  destruct (In_inv_perm ha (Vector.cons hb tb) H1).

  apply perm_trans with (Vector.cons ha x)...

  apply perm_skip.

  apply IHn.

    inversion_clear H...

  cut (List.incl ta (Vector.cons ha x)).

    intros.

    simpl in H3.

    do 2 intro.

    destruct (H3 _ H4)...

    subst.

    inversion_clear H.

    elimtype False...

  apply List.incl_tran with (to_list (Vector.cons hb tb)).

    do 2 intro.

    apply H0.

    right...

  apply Permutation_incl.

  apply Permutation.Permutation_sym.

  apply List_Permutation...

Qed.



Lemma In_nats_inv z y (x: natBelow (y + z)): List.In x (nats y z) -> y <= x < z + y.

Proof with auto.

  induction z in y, x |- *.

    intros.

    elimtype False...

  simpl.

  rewrite <- List_map.

  intro.

  destruct H.

    subst.

    rewrite nb_val_eq_rec_r.

    simpl.

    omega.

  destruct (In_map_inv H). clear H.

  destruct H0.

  subst.

  rewrite nb_val_eq_rec_r.

  destruct (IHz (S y) x0 H0).

  split.

    apply le_Sn_le...

  rewrite <- plus_n_Sm in H1...

Qed.



Lemma In_nb_nats_inv z y x: List.In x (nb_nats y z) -> y <= x < z + y.

Proof.

  unfold nb_nats.

  intros.

  rewrite <- List_map in H.

  destruct (In_map_inv H). clear H.

  destruct H0.

  subst.

  apply In_nats_inv.

  assumption.

Qed.



Lemma NoDup_nats y x: List.NoDup (nats x y).

Proof with auto. 

  induction y in x |- *.

    simpl...

  simpl.

  intros.

  apply List.NoDup_cons.

    intro.

    rewrite <- List_map in H.

    destruct (In_map_inv H). clear H.

    destruct H0.

    destruct (In_nats_inv y (S x) x0 H0).

    assert (nb_val x0 = x).

      replace x with (nb_val (eq_rec_r natBelow (mkNatBelow x y) (trans_plus_n_Sm x y))).

        rewrite <- H.

        rewrite nb_val_eq_rec_r...

      rewrite nb_val_eq_rec_r...

    apply le_Sn_n with x.

    simpl in H1.

    rewrite H3 in H1...

  rewrite <- List_map.

  apply NoDup_map.

    intros.

    apply natBelow_unique.

    rewrite <- (nb_val_eq_rec_r x0 (trans_plus_n_Sm x y)).

    rewrite <- (nb_val_eq_rec_r y0 (trans_plus_n_Sm x y)).

    rewrite H1...

  apply (IHy (S x)).

Qed.



Lemma tail_map (A B: Set) (f: A -> B) n (l: Vector.t A (S n)):

  tail (map f l) = map f (tail l).

Proof. intros. rewrite (eq_cons l). reflexivity. Qed.



Lemma tail_cons (A: Set) (a: A) n (l: Vector.t A n): tail (Vector.cons a l) = l.

Proof. reflexivity. Qed.



Lemma nth_nats m (i: natBelow m) n: nb_val (nth (nats n m) i) = n + i.

Proof with auto.

  revert n.

  pattern m, i.

  apply natBelow_rect.

    simpl.

    intros.

    rewrite nb_val_eq_rec_r.

    simpl.

    symmetry.

    apply plus_0_r.

  intros.

  simpl plus in *.

  fold (Snb (mkNatBelow v p)).

  rewrite nth_S.

  rewrite nats_S.

  rewrite tail_map.

  rewrite tail_cons.

  rewrite nth_map.

  rewrite nb_val_eq_rec_r.

  rewrite <- plus_n_Sm.

  apply (H (S n)).

Qed.



Lemma nth_nats3 m i n: nth (nats (S n) m) i = Snb (nth (nats n m) i).

Proof with auto.

  revert n.

  pattern m, i.

  apply natBelow_rect.

    simpl.

    intros.

    

    apply natBelow_unique.

    rewrite val_Snb.

    do 2 rewrite nb_val_eq_rec_r...

  intros.

  apply natBelow_unique.

  simpl plus.

  rewrite (val_Snb (nth (nats n (S (S (v + p)))) (mkNatBelow (S v) p))).

  rewrite nth_nats.

  cset (nth_nats (mkNatBelow (S v) p) (S n)).

  simpl plus in H0.

  rewrite H0.

  simpl...

Qed. 



Lemma nth_nats_0 n i: nth (nats 0 n) i = i.

Proof. intros. apply natBelow_unique. rewrite nth_nats. reflexivity. Qed.



Definition plusnb (y x: nat) (nb: natBelow x): natBelow (x + y) :=

  match nb in natBelow x' return natBelow (x' + y) with

  | mkNatBelow a b => eq_rec_r natBelow (mkNatBelow a (b + y)) (eq_S _ _ (plus_assoc_reverse a b y))

  end.



Lemma val_plusnb y x (nb: natBelow x): nb_val (plusnb y nb) = nb_val nb.

Proof.

  intros.

  dependent inversion nb.

  simpl.

  rewrite nb_val_eq_rec_r.

  reflexivity.

Qed.



Lemma map_app (A B: Type) (f: A -> B) n (v: Vector.t A n) m (w: Vector.t A m):

  map f (app v w) = app (map f v) (map f w).

Proof with reflexivity.

  induction n; intros.

    rewrite (eq_nil v)...

  rewrite (eq_cons v).

  simpl.

  rewrite IHn...

Qed.



Lemma app_eq A m (x x': Vector.t A m) n (y y': Vector.t A n): x = x' -> y = y' -> app x y = app x' y'.

Proof. intros. subst. reflexivity. Qed.



Lemma nats_plus x n y:

  nats n (x + y) =

  map (fun nb => eq_rec_r natBelow nb (plus_assoc n x y)) (app (map (@plusnb y _) (nats n x)) (nats (n + x) y)).

Proof with auto.

  induction x in n, y |- *.

    simpl.

    intros.

    apply ext_nth.

    intro.

    rewrite nth_map.

    apply natBelow_unique.

    rewrite nth_nats.

    rewrite nb_val_eq_rec_r.

    rewrite nth_nats...

  simpl.

  intros.

  apply Vcons_eq.

    apply natBelow_unique.

    do 2 rewrite nb_val_eq_rec_r.

    rewrite val_plusnb.

    rewrite nb_val_eq_rec_r.

    simpl...

  rewrite IHx.

  repeat rewrite map_app.

  apply app_eq.

    repeat rewrite map_map.

    apply map_ext.

    intro.

    unfold compose.

    apply natBelow_unique.

    repeat rewrite nb_val_eq_rec_r.

    do 2 rewrite val_plusnb.

    rewrite nb_val_eq_rec_r...

  rewrite map_map.

  apply ext_nth.

  intro.

  do 2 rewrite nth_map.

  unfold compose.

  apply natBelow_unique.

  repeat rewrite nb_val_eq_rec_r.

  simpl.

  rewrite trans_plus_n_Sm...

Qed.



Lemma nb_nats_plus x n y: nb_nats n (x + y) = app (nb_nats n x) (nb_nats (n + x) y).

Proof with auto.

  unfold nb_nats.

  intros.

  rewrite nats_plus.

  rewrite map_map.

  rewrite (@map_ext _ _ (nb_val ∘ (fun nb => eq_rec_r natBelow nb (plus_assoc n x y))) nb_val).

    rewrite map_app.

    rewrite map_map.

    rewrite (@map_ext _ _ (nb_val ∘ plusnb y (x:=n + x)) nb_val)...

    intro. unfold compose.

    apply val_plusnb.

  intro. unfold compose.

  apply nb_val_eq_rec_r.

Qed.



Lemma map_cons A B (f: A -> B) (h: A) n (t: Vector.t A n): map f (Vector.cons h t) = Vector.cons (f h) (map f t).

Proof. reflexivity. Qed.



Lemma Permutation_mapping (X: Set) n (a b: Vector.t X n): Permutation a b ->

  exists l: Vector.t (natBelow n) n, (forall x, List.In x l) /\ map (nth b) l = a.

Proof with auto with arith.

  intros p.

  induction p.

        exists Vector.nil.

        split...

        intros.

        inversion x.

      destruct IHp.

      destruct H.

      exists (Vector.cons (nb0 n) (map (@Snb _) x0)).

      split.

        intros.

        destruct (natBelow_S_inv x1).

          destruct s.

          subst.

          right.

          rewrite <- List_map.

          apply List.in_map...

        subst.

        left...

      subst.

      rewrite map_cons.

      f_equal.

      rewrite map_map.

      apply map_ext.

      intro.

      unfold compose.

      rewrite nth_S...

    exists (Vector.cons (Snb (nb0 n)) (Vector.cons (nb0 (S n)) (nats 2 n))).

    split.

      intros.

      simpl.

      destruct (natBelow_S_inv x0).

        destruct s.

        subst.

        destruct (natBelow_S_inv x1).

          destruct s.

          subst.

          right.

          right.

          apply (In_nats_S n 1).

          apply (In_nats_S n 0).

          apply In_nats_0.

        subst...

      subst...

    repeat rewrite map_cons.

    f_equal.

    apply (f_equal (@Vector.cons _ x n)).

    apply ext_nth.

    intro.

    rewrite nth_map.

    cset (nth_nats3 x0 1).

    simpl in H.

    rewrite H.

    cset (nth_nats3 x0 0).

    simpl in H0. rewrite H0.

    repeat rewrite nth_S.

    cset (nth_nats_0 x0).

    simpl in *.

    rewrite H1.

    reflexivity.

  destruct IHp1.

  destruct IHp2.

  destruct H.

  destruct H0.

  exists (map (nth x0) x).

  split.

    intros.

    destruct (In_vec_inv _ _ (H0 x1)).

    subst.

    rewrite <- List_map.

    apply List.in_map...

  apply ext_nth.

  intro.

  subst.

  repeat rewrite nth_map...

Qed. 



Section contents.



  Variable X: Set.

  Variable Xle: X -> X -> Prop.

  Hypothesis XO: preorder X Xle.



  Definition Xlt (x y: X): Prop := Xle x y /\ ~ Xle y x.



  Lemma Xle_nlt: forall x y, Xle x y -> ~ Xlt y x.

  Proof. firstorder. Qed.



  Lemma Xlt_irrefl x: ~ Xlt x x.

  Proof. intro. set (preord_refl _ _ XO x). firstorder. Qed.



  Lemma Xle_lt_trans x y: Xle x y -> forall z, Xlt y z -> Xlt x z.

  Proof with assumption.

    unfold Xlt.

    intros.

    destruct H0.

    split.

      apply (preord_trans _ _ XO) with y...

    intro.

    apply H1.

    apply (preord_trans _ _ XO) with x...

  Qed.



  Inductive sorted: forall n, Vector.t X n -> Prop := 

    | sorted_nil: sorted Vector.nil

    | sorted_one x: sorted (Vector.cons x Vector.nil)

    | sorted_more (a b: X) n (t: Vector.t X n):

        Xle a b -> sorted (Vector.cons b t) -> sorted (Vector.cons a (Vector.cons b t)).



  Hint Constructors sorted.



  Lemma sorted_cons x n (v: Vector.t X (S n)): Xle x (head v) -> sorted v -> sorted (Vector.cons x v).

  Proof with auto.

    intros.

    rewrite (eq_cons v).

    apply sorted_more...

    rewrite <- eq_cons...

  Qed.



  Lemma sorted_cons' x n (v: Vector.t X n): (forall y, List.In y v -> Xle x y) -> sorted v -> sorted (Vector.cons x v).

  Proof with auto.

    induction v; intros.

      apply sorted_one.

    apply sorted_more...

    apply H. left...

  Qed.



  Lemma sorted_cons_inv x n (v: Vector.t X (S n)): sorted (Vector.cons x v) -> Xle x (head v).

  Proof. intros. rewrite (eq_cons v) in H. inversion_clear H. assumption. Qed.



  Lemma sorted_tail x n (v: Vector.t X n): sorted (Vector.cons x v) -> sorted v.

  Proof. intros. inversion_clear H; auto. Qed.



  Lemma sorted_cons_inv' (x: X) n (xs: Vector.t X n): sorted (Vector.cons x xs) ->

    forall x', List.In x' xs -> Xle x x'.

  Proof with auto.

    induction xs.

      simpl.

      intros.

      elimtype False...

    simpl.

    intros.

    inversion_clear H0.

      subst.

      inversion_clear H...

    apply IHxs...

    clear IHxs H1.

    revert H.

    dependent inversion_clear xs.

      simpl.

      intros.

      apply sorted_one.

    intros.

    apply sorted_more.

      apply (preord_trans _ _ XO) with h...

        apply (sorted_cons_inv H).

      apply (sorted_cons_inv (sorted_tail H)).

    apply (sorted_tail (sorted_tail H)).

  Qed.



  Lemma sorted_app (v w: List.list X): sorted v -> sorted w ->

    (forall x y, List.In x v -> List.In y w -> Xle x y) -> sorted (List.app v w).

  Proof with auto.

    induction v...

    intros.

    simpl.

    apply sorted_cons'.

      intros.

      clear IHv.

      rewrite list_round_trip in H2.

      destruct (List.in_app_or v w y H2).

        simpl in H.

        apply (sorted_cons_inv' H).

        rewrite list_round_trip...

      apply H1...

      left...

    apply IHv...

      simpl in H.

      apply sorted_tail with a...

    intros.

    apply H1...

    simpl...

  Qed.



  Lemma sorted_le_indices_le_values n (v: Vector.t X n): sorted v ->

    forall (i j: natBelow n), i <= j -> Xle (nth v i) (nth v j).

  Proof with auto with arith.

    intros s.

    induction s.

        intros.

        inversion i.

      intros.

      rewrite (nb1 i).

      rewrite (nb1 j).

      simpl.

      apply preord_refl...

    intro i. pattern i. apply natBelow_S_inv'; [idtac | intro m]; intro j; pattern j; apply natBelow_S_inv'.

          rewrite nth_0.

          intros. apply preord_refl...

        rewrite nth_0.

        intros.

        rewrite nth_S.

        apply (preord_trans _ _ XO) with (nth (Vector.cons b t) (nb0 _))...

      rewrite val_Snb.

      simpl @nb_val.

      intros.

      inversion H0.

    intro.

    do 2 rewrite val_Snb.

    do 2 rewrite nth_S...

  Qed.



  Lemma sorted_lt_values_lt_indices n (v: Vector.t X n): sorted v ->

    forall i j, Xlt (nth v i) (nth v j) -> i < j.

  Proof with auto with arith.

    intros s.

    induction s.

        intros.

        inversion i.

      intros i j.

      rewrite (nb1 i).

      rewrite (nb1 j).

      simpl.

      intro.

      elimtype False.

      apply (Xlt_irrefl H).

    intro i. pattern i. apply natBelow_S_inv'; [idtac | intro m]; intro j; pattern j; apply natBelow_S_inv'.

          rewrite nth_0.

          intros.

          elimtype False.

          apply (Xlt_irrefl H0).

        intro.

        rewrite val_nb0.

        rewrite val_Snb...

      rewrite nth_S.

      rewrite nth_0.

      intros.

      elimtype False.

      apply (Xle_nlt H).

      apply Xle_lt_trans with (nth (Vector.cons b t) m)...

      apply (sorted_le_indices_le_values s (nb0 _) m)...

    intro.

    do 2 rewrite nth_S.

    do 2 rewrite val_Snb...

  Qed.



  Variable XleDec: forall x y, { Xle x y } + { Xle y x }.



  Fixpoint insert_ordered (x: X) n: Vector.t X n -> Vector.t X (S n) :=

    match n return Vector.t X n -> Vector.t X (S n) with

    | 0 => fun _ => Vector.cons x Vector.nil

    | S n' => fun v => if XleDec x (head v)

        then Vector.cons x v

        else Vector.cons (head v) (insert_ordered x (tail v))

    end.



  Hint Immediate perm_refl.



  Lemma insert_ordered_permutes x n (v: Vector.t X n): Permutation (insert_ordered x v) (Vector.cons x v).

  Proof with auto.

    induction v; simpl...

    destruct (XleDec x h)...

    apply perm_trans with (Vector.cons h (Vector.cons x v))...

  Qed.



  Lemma insert_ordered_preserves_sorted n x (v: Vector.t X n): sorted v -> sorted (insert_ordered x v).

  Proof with auto.

    induction v.

      simpl...

    simpl.

    intros.

    destruct (XleDec x h).

      apply sorted_more...

    destruct n.

      rewrite (eq_nil v).

      simpl.

      apply sorted_more...

    cset (IHv (sorted_tail H)). clear IHv.

    cset (eq_cons v).

    revert H1.

    generalize (head v).

    generalize (tail v).

    intros.

    subst.

    simpl in *.

    destruct (XleDec x x1).

      apply sorted_more...

    apply sorted_more...

    apply (sorted_cons_inv H).

  Qed.



  Fixpoint insertion_sort n: Vector.t X n -> Vector.t X n :=

    match n return Vector.t X n -> Vector.t X n with

    | 0 => fun _ => Vector.nil

    | S n' => fun v => insert_ordered (head v) (insertion_sort (tail v))

    end.



  Lemma insertion_sort_sorts n (l: Vector.t X n): sorted (insertion_sort l).

  Proof with auto.

    induction n; intros.

      rewrite (eq_nil l)...

    rewrite (eq_cons l).

    simpl.

    apply insert_ordered_preserves_sorted...

  Qed.



  Lemma insertion_sort_permutes n (l: Vector.t X n): Permutation (insertion_sort l) l.

  Proof with auto.

    induction l...

    simpl.

    apply perm_trans with (Vector.cons h (insertion_sort l))...

    apply insert_ordered_permutes.

  Qed.



End contents.

