Set Implicit Arguments.

Require Import util.
(* util:
Set Implicit Arguments.
Global Set Asymmetric Patterns.

Require Import Relations.
Require Export Basics.
Require Import Setoid.

Arguments eq {A}.
Arguments fst {A B}.

Hint Unfold compose.

Definition proj1_conj (A B: Prop) (c: A /\ B): A :=
  match c with conj x _ => x end.

Definition proj2_conj (A B: Prop) (c: A /\ B): B :=
  match c with conj _ x => x end.

Lemma eq_trans (X: Set) (a b c: X): a = b -> b = c -> a = c.

Definition cmp_cmp (x y: comparison): { x = y } + { x <> y } :=
  
  match x, y return { x = y } + { x <> y } with
  | Lt, Lt | Gt, Gt | Eq, Eq => left _ (refl_equal _)
  | a, b => right _ (
      match a, b
      return match a, b with Lt, Lt | Gt, Gt | Eq, Eq => True | _, _ => ~(a = b) end with
      | Lt, Lt | Gt, Gt | Eq, Eq => I
      | Lt, _ => fun q => match q in _ = Lt with refl_equal => I end
      | Gt, _ => fun q => match q in _ = Gt with refl_equal => I end
      | Eq, _ => fun q => match q in _ = Eq with refl_equal => I end
      end
    )
  end. 

Fixpoint nat_cmp (x y: nat) {struct x}: comparison :=
  match x, y with
  | 0, 0 => Eq
  | 0, S _ => Lt
  | S _, 0 => Gt
  | S x', S y' => nat_cmp x' y'
  end.

Ltac cset e := let v := fresh in set (v := e); clearbody v.
Ltac cset' e := let v := fresh in set (v := e) in *; clearbody v.

Ltac extro x := generalize x; clear x.

Definition unsum_bool (A B: Prop) (sb: sumbool A B): bool := if sb then true else false.

Definition decision (P: Prop): Set := { P } + { ~ P }.
Definition predDecider (T: Set) (P: T -> Prop): Type := forall t, decision (P t).

Lemma negb_inv (b b': bool): negb b = negb b' -> b = b'.

Lemma negb_negb (b: bool): negb (negb b) = b.

Definition id {X} (x: X): X := x.

Definition ext_eq {A B: Type} (f g: A -> B): Prop := forall x, f x = g x.

Lemma ext_eq_trans: forall A B, transitive _ (@ext_eq A B).

Lemma ext_eq_refl: forall A B, reflexive _ (@ext_eq A B).

Lemma ext_eq_sym: forall A B, symmetric _ (@ext_eq A B).

Add Parametric Relation X Y: (X -> Y) (@ext_eq X Y)
  reflexivity proved by (@ext_eq_refl X Y)
  symmetry proved by (@ext_eq_sym X Y)
  transitivity proved by (@ext_eq_trans X Y)
    as ext_eq_rel.

Lemma ext_eq_rw (A B: Type) (f g: A -> B): ext_eq f g -> forall x, f x = g x.

Notation " g ∘ f " := (compose g f) (at level 40, left associativity).

Lemma comp_apply (A B C: Set) (f: B -> C) (g: A -> B) (x: A): (f ∘ g) x = f (g x).

Lemma comp_ass (A B C D: Set) (f: A -> B) (g: B -> C) (h: C -> D): h ∘ (g ∘ f) = (h ∘ g) ∘ f.

Definition compose_lunit A B (f: A -> B): ext_eq (@id B ∘ f) f.

Definition compose_runit A B (f: A -> B): ext_eq (f ∘ @id A) f.

Definition map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): C * B := (fst p, f (snd p)).

Lemma fst_map_snd (A B: Set) (f: A -> B) (C: Set) (p: C * A): fst (map_snd f p) = fst p.

Definition on {A B: Type} {C: B -> B -> Type} (g: A -> B) (f: forall b b', C b b') (x y: A): C (g x) (g y) := f (g x) (g y).

Definition unsumbool {A B}: { A } + { B } -> bool := fun x => if x then true else false.

Definition dep_flip {A B: Type} {C: A -> B -> Type} (f: forall a b, C a b) (b: B) (a: A): C a b := f a b.

Definition uncurry A B C (f: A -> B -> C) (ab: A * B): C := f (fst ab) (snd ab).

Section well_founded_pairs.

  Variables (A B: Type)
    (Ra: relation A) (Rb: relation B).

  Inductive pair_rel: relation (A * B) :=
    | pair_rel_l a a' b: Ra a a' -> pair_rel (a, b) (a', b)
    | pair_rel_r a b b': Rb b b' -> pair_rel (a, b) (a, b').

  Fixpoint acc_pairs a (Aa: Acc Ra a) {struct Aa}: forall b (Ab: Acc Rb b), Acc pair_rel (a, b) :=
    fix G b (Ab: Acc Rb b) {struct Ab}: Acc pair_rel _ := @Acc_intro _ pair_rel _
      match Aa, Ab with
      | Acc_intro x, Acc_intro y =>  fun z (za: pair_rel z (a, b)) =>
          match za in pair_rel z ab return
            (forall (p: A) (q: Ra p (fst ab)), Acc pair_rel (p, (snd ab))) -> (forall p, Rb p (snd ab) -> Acc pair_rel (fst ab, p)) -> Acc pair_rel z with
          | pair_rel_l v w c d => fun fr gr => fr _ d
          | pair_rel_r v w c d => fun fr gr => gr _ d
          end
          (fun (p: A) (q: Ra p (fst (a, b))) => @acc_pairs p (x p q) b Ab : Acc pair_rel (p, b))
          (fun (p: B) (q: Rb p (snd (a, b))) => @G p (y p q): Acc pair_rel (a, p))
      end.

   Lemma well_founded_pairs (Wa: well_founded Ra) (Wb: well_founded Rb): well_founded pair_rel.

End well_founded_pairs. *)
Require Import List.
Require Import monads.
(* monads:
Global Set Automatic Coercions Import.
Set Implicit Arguments.

Require Import List.
Require Import list_utils.
Require Import util.

Record Monad: Type :=
  { mon:> Set -> Set
  ; bind: forall a b, mon a -> (a -> mon b) -> mon b
  ; ret: forall (a: Set), a -> mon a
  
  ; mon_lunit: forall (a b: Set) (x: a) (f: a -> mon b), bind (ret x) f = f x
      
  ; mon_runit: forall (a: Set) (f: mon a), bind f (@ret a) = f
      
  ; mon_assoc: forall a b c (n: mon a) (f: a -> mon b) (g: b -> mon c),
      bind (bind n f) g =
      bind n (fun x => bind (f x) g)
      
  }.

Arguments bind [m a b].
Arguments ret {m a}.

Notation "x >>= y" := (bind x y) (at level 55).
Notation "x >> y" := (bind x (fun _ => y)) (at level 30, right associativity).
Notation "x <- y ; z" := (bind y (fun x : _ => z)) (at level 30, right associativity).

Record Functor: Type :=
  { func: Set -> Set
  ; func_map: forall (a b: Set) (f: a -> b), func a -> func b
  
  ; func_id: forall (X: Set), func_map (fun (x: X) => x) = (fun (x: func X) => x)
        
  ; func_assoc: forall (a b c: Set) (x: func a) (f: b -> c) (g: a -> b),
      func_map (f ∘ g) x = func_map f (func_map g x)
        
  }.

Arguments func_map [f a b].

Definition extMonad (M: Monad): Prop := forall (A B: Set) (f g: A -> M B), ext_eq f g -> forall x, bind x f = bind x g.

Lemma bind_eqq (M: Monad) (e: extMonad M) (A B: Set) (m n: M A) (f g: A -> M B):
  m = n -> ext_eq f g -> (m >>= f) = (n >>= g).

Definition extFlipped (M: Monad): extMonad M -> forall A (x: M A) (B: Set) (f g: A -> M B), ext_eq f g -> bind x f = bind x g.

Lemma mon_lunit_under_bind (M: Monad) (A B C: Set) (a: M A) (b: A -> B) (f: A -> B -> M C):
  extMonad M -> (x <- a ; (ret (b x) >>= f x)) = (x <- a ; f x (b x)).

Section MonadFunctor. 

  Variable M: Monad.

  Definition bind_map (a b: Set) (f: a -> b) (x: M a): M b :=
    xv <- x ;
    ret (f xv).

  Hypothesis f_ext_eq: forall A B (f g: A -> B), (forall x, f x = g x) -> f = g.

  Lemma eta A B (f: A -> B): (fun x => f x) = f.

  Definition MonadFunctor: Functor.

  Definition a_monad_isa_functor T (x: M T): func MonadFunctor T := x.
    End MonadFunctor.

Module IdMonad.

  Definition C (s: Set): Set := s. 

  Definition bind A B (x: C A) (y: A -> C B): C B := y x.
  Definition ret (A: Set) (x: A): C A := x.

  Definition M: Monad.

  Coercion id_isa_monad A (a: C A): M A := a.

  Lemma ext: extMonad M.

End IdMonad.

Unset Elimination Schemes.

Inductive Tree (A: Set): Set :=
  | Leaf: A -> Tree A
  | Node: list (Tree A) -> Tree A.

Set Elimination Schemes.

Definition Tree_ind
  : forall (A: Set) (P : Tree A -> Prop),
    (forall n : A, P (Leaf n)) ->
    (forall l : list (Tree A), (forall t, In t l -> P t) -> P (Node l)) ->
  forall t, P t.

Section MonadToys.

  Definition liftM (A B: Set) (f: A -> B) (M: Monad) (x: M A): M B :=
    xv <- x ; ret (f xv).

  Definition liftM2 (A B C: Set) (f: A -> B -> C) (M: Monad) (x: M A) (y: M B): M C :=
    xv <- x ; yv <- y ; ret (f xv yv).

  Fixpoint foldlM {A B: Set} {M: Monad} (f: A -> B -> M A) (x: A) (l: list B) {struct l}: M A :=
    match l with
    | nil => ret x
    | h :: t => fax <- f x h ; foldlM f fax t
    end. 

  Fixpoint foldrM {A B: Set} {M: Monad} (f: B -> A -> M A) (x: A) (l: list B) {struct l}: M A :=
    match l with
    | nil => ret x
    | h :: t => t' <- foldrM f x t; f h t'
    end. 

  Lemma foldlM_cons (A B: Set) (M: Monad) (f: A -> B -> M A) (x: A) (h: B) (t: list B):
    foldlM f x (h :: t) = fax <- f x h ; foldlM f fax t.

  Fixpoint filterM {A: Set} {M: Monad} (p: A -> M bool) (l: list A): M (list A) :=
    match l with
    | nil => ret nil
    | h :: t =>
      b <- p h ;
      t' <- filterM p t ;
      ret (if b then h :: t' else t')
    end. 

  Lemma filterM_id (A: Set) (p: A -> IdMonad.M bool) (l: list A): filter p l = filterM p l.

End MonadToys.

Arguments liftM [A B] _ [M].

Record MonadTrans: Type :=
  { transMonad: forall (m: Monad), extMonad m -> Monad
  ; lift: forall (m: Monad) (e: extMonad m) (A: Set), m A -> transMonad e A
  }. *)
Require Import sums_and_averages.
(* sums_and_averages:
Set Implicit Arguments.

Require Import
  Plus List Permutation Arith Relations RelationClasses Morphisms
  arith_lems util list_utils nat_seqs Omega.

Fixpoint sum (l: list nat): nat :=
  match l with
  | nil => 0
  | h :: t => h + sum t
  end.

Lemma sum_once h t: sum (h :: t) = h + sum t.

Lemma sum_app x y: sum (x ++ y) = sum x + sum y.

Require Import Rbase.
Require Import Rdefinitions.
Require Import Fourier.

Open Scope R_scope.

Definition Rsum: list R -> R := fold_right Rplus 0.

Lemma Rsum_sum_map (T: Set) (fi: T -> nat) (fr: T -> R) (l: list T):
  (forall x, In x l -> fr x = INR (fi x)) -> Rsum (map fr l) = INR (sum (map fi l)).

Lemma Rsum_app (x y: list R): Rsum (x ++ y) = Rsum x + Rsum y.

Lemma Rsum_constant r l: (forall x, In x l -> x = r) -> Rsum l = INR (length l) * r.

Lemma Rsum_le l r: (forall x, In x l -> x <= r) -> Rsum l <= INR (length l) * r.

Lemma le_Rsum l r: (forall x, In x l -> r <= x) -> INR (length l) * r <= Rsum l.

Lemma Rsum_map_plus X f g (l: list X):
  Rsum (map (fun x => f x + g x) l) =
  Rsum (map f l) + Rsum (map g l).

Lemma Rsum_map_app_map X Y f g (h: X -> Y) (l: list X):
  Rsum (map f (map g l ++ map h l)) = Rsum (map (fun x => f (g x) + f (h x)) l).

Lemma Rsum_map_le X f g (l: list X): (forall x, In x l -> f x <= g x) -> Rsum (map f l) <= Rsum (map g l).

Lemma Rsum_map_mult c l: Rsum (map (Rmult c) l) = c * Rsum l.

Lemma Rsum_repeat n: ext_eq (Rsum ∘ repeat n) (Rmult (INR n)).

Lemma Rsum_concat l: Rsum (concat l) = Rsum (map Rsum l).

Lemma Rsum_nonneg l: (forall x, In x l -> 0 <= x) -> 0 <= Rsum l.

Lemma Rsum_single x: Rsum (x :: nil) = x.

Definition RsumOver (X: Set) (l: list X) (f: X -> R): R := Rsum (map f l).

Lemma RsumOver_nats_le x y z: (y <= z)%nat -> forall f, (forall q, (x <= q)%nat -> 0 <= f q) ->
  RsumOver (nats x y) f <= RsumOver (nats x z) f.

Lemma RsumOver_cons (X: Set) (x: X) (l: list X) (f: X -> R): RsumOver (x :: l) f = f x + RsumOver l f.

Lemma RsumOver_concat_map (X Y: Set) (f: X -> R) (g: Y -> list X) (l: list Y):
  RsumOver (concat (map g l)) f = RsumOver l (fun x => RsumOver (g x) f).

Lemma RsumOver_constant_le (X: Set) (l: list X) (f: X -> R) (c: R):
  (forall x, List.In x l -> f x <= c) -> RsumOver l f <= INR (length l) * c.

Lemma nats_plusb b b' w: nats (b + b') w = map (plus b) (nats b' w).

Lemma RsumOver_nats b w f:
  RsumOver (nats b w) f =
  RsumOver (nats 0 w) (f ∘ plus b).

Lemma RsumOver_le (X: Set) (f g: X -> R) (l: list X):
  (forall x, In x l -> f x <= g x) -> RsumOver l f <= RsumOver l g.

Lemma RsumOver_mult_constant (X: Set) (f: X -> R) c (l: list X):
  c * RsumOver l f = RsumOver l (Rmult c ∘ f).

Lemma RsumOver_minus w f b d: (b + w <= d)%nat ->
  RsumOver (nats b w) (f ∘ minus d) = RsumOver (nats (S (d - (w + b))) w) f.

Definition Ravg (l: list R): R := Rsum l / INR (length l).

Lemma Ravg_nil: Ravg nil = 0.

Lemma Ravg_one h: Ravg (h :: nil) = h.

Lemma Ravg_cons h t: Ravg (h :: t) = (h + Ravg t * INR (length t)) / INR (S (length t)).

Lemma Ravg_0_le l: (forall x, In x l -> 0 <= x) -> 0 <= Ravg l.

Lemma Ravg_0 (l: list R): (forall x, In x l -> x = 0) -> Ravg l = 0.

Lemma Ravg_app x y:
  Ravg (x ++ y) = / INR (length x + length y) * (Ravg x * INR (length x) + Ravg y * INR (length y)).

Lemma Ravg_0_inv (l: list R): Ravg l = 0 -> (forall x, In x l -> 0 <= x) -> forall x, In x l -> x = 0.

Hint Resolve not_0_INR.

Lemma avg_filter_perms (T: Set) (f: list T -> R) (p: T -> bool) (t: list T):
  Ravg (map (f ∘ filter p) (perms t)) =
  Ravg (map f (perms (filter p t))).

Lemma Ravg_comp_map X
  (f: X -> R) (m: list X -> R) (g: R -> R):
  (forall a b, g (a * b) = g a * b) ->
  (forall l, g (Rsum l) = Rsum (map g l)) ->
    (forall l: list X, Ravg (map f l) = g (m l)) -> forall u,
    Ravg (map (fun l => Ravg (map f l)) u) = g (Ravg (map m u)).

Lemma Ravg_comp_map_le (U: Type)
  (f: U -> list R) (m: U -> R) (g: R -> R):
  (forall u, 0 <= m u) ->
  (forall a b, 0 <= a -> g a / INR (S b) <= g (a / INR (S b))) ->
  (forall l, Rsum (map g l) <= g (Rsum l)) ->
    (forall l, Ravg (f l) <= g (m l)) -> forall u, (0 < length u)%nat ->
    Ravg (map (Ravg ∘ f) u) <= g (Ravg (map m u)).

Lemma Ravg_concat v x:
  (forall l, In l x -> length l = v) ->
  Ravg (concat x) = Ravg (map Ravg x).

Lemma Ravg_map_plus X f g (l: list X):
  Ravg (map (fun x => f x + g x) l) =
  Ravg (map f l) + Ravg (map g l).

Lemma Ravg_constant l: l <> nil -> forall v, (forall x, In x l -> x = v) -> Ravg l = v.

Lemma Ravg_map_le X (f g: X -> R) (l: list X): (forall x, In x l -> f x <= g x) -> Ravg (map f l) <= Ravg (map g l).

Lemma Ravg_single x: Ravg (x :: nil) = x.

Require ne_tree.

Definition TRavg: ne_tree.T R -> R := ne_tree.fold (@id R) Ravg. *)
Require Import Setoid.
Require ne_tree.
Require arith_lems.
Require Import Rbase.
Require ne_tree_monad.

Open Scope R_scope.

Definition expec (T: Set) (f: T -> nat): ne_tree.T T -> R :=
  TRavg ∘ ne_tree.map (INR ∘ f).
    
Definition expec_sum (T U: Set) (f: U -> nat) (g: T -> ne_tree_monad.M U): list T -> R :=
  Rsum ∘ map (expec f ∘ g).

Section expec_ctors.

  Variables (T: Set) (f: T -> nat).

  Lemma expec_Leaf t: expec f (ne_tree.Leaf t) = INR (f t).
  Proof. auto. Qed.

  Lemma expec_Node l: expec f (ne_tree.Node l) = Ravg (ne_list.map (@expec _ f) l).
  Proof. unfold expec, compose. intros. simpl. rewrite ne_list.map_map. reflexivity. Qed.

  Lemma expec_Node_one x:
    expec f (ne_tree.Node (ne_list.one x)) = expec f x.
  Proof. unfold expec, compose. simpl. intros. rewrite Ravg_one. reflexivity. Qed.

  Lemma expec_Node_cons x t:
    expec f (ne_tree.Node (ne_list.cons x t)) =
    (expec f x + expec f (ne_tree.Node t) * INR (length t)) * / INR (S (length t)).
  Proof.
    intros.
    rewrite expec_Node.
    simpl ne_list.map.
    simpl Ravg.
    rewrite Ravg_cons.
    rewrite expec_Node.
    rewrite ne_list.map_length.
    field.
    auto with real.
  Qed.

End expec_ctors.

Add Parametric Morphism (A: Set): (@expec A)
  with signature (@ext_eq A nat) ==> (@ext_eq (ne_tree.T A) R)
  as expec_ext_morph.
Proof. intros. unfold expec. rewrite H. reflexivity. Qed.

Lemma expec_ext (T: Set) (f g: T -> nat) (e: ext_eq f g): forall x, expec f x = expec g x.
Proof. fold (ext_eq (expec f) (expec g)). apply expec_ext_morph. assumption. Qed.

Lemma lin_nat c d: ext_eq
  (TRavg ∘ ne_tree.map (INR ∘ plus d ∘ mult c))
  (Rplus (INR d) ∘ Rmult (INR c) ∘ TRavg ∘ ne_tree.map INR).
Proof.
  intro.
  induction x.
      repeat rewrite comp_apply.
      simpl.
      repeat rewrite comp_apply.
      rewrite plus_INR.
      rewrite mult_INR.
      reflexivity.
    repeat rewrite comp_apply in *.
    simpl.
    rewrite IHx.
    repeat rewrite Ravg_one.
    reflexivity.
  repeat rewrite comp_apply in *.
  simpl.
  rewrite IHx.
  inversion IHx0.
  repeat rewrite ne_list.map_map in *.
  repeat rewrite Ravg_cons.
  rewrite ne_list.map_length.
  rewrite H0.
  rewrite ne_list.map_length.
  rewrite S_INR.
  field.
  auto with real.
Qed.

Lemma Rmult_INR1_id: ext_eq (Rmult (INR 1)) (@id R).
Proof. intro. apply Rmult_1_l. Qed.

Lemma mult_1_id: ext_eq (mult 1) (@id nat).
Proof. intro. apply mult_1_l. Qed.

Lemma expec_plus_c (T: Set) (g: T -> nat) (c: nat):
  ext_eq (expec (plus c ∘ g)) (Rplus (INR c) ∘ expec g).
Proof.
  intros.
  unfold expec.
  rewrite comp_ass.
  rewrite <- ne_tree.map_map_ext.
  rewrite <- (compose_runit (INR ∘ plus c)).
  rewrite <- mult_1_id.
  rewrite comp_ass.
  rewrite lin_nat.
  rewrite <- comp_ass.
  rewrite ne_tree.map_map_ext.
  rewrite Rmult_INR1_id.
  rewrite compose_runit.
  reflexivity.
Qed.

Lemma expec_plus (T: Set) (f g: T -> nat) (t: ne_tree.T T):
  expec (fun x => plus (f x) (g x)) t = expec f t + expec g t.
Proof with auto.
  induction t.
      repeat rewrite expec_Leaf.
      apply plus_INR.
    repeat rewrite expec_Node_one...
  repeat rewrite expec_Node_cons.
  rewrite IHt.
  rewrite IHt0.
  field...
Qed.

Lemma expec_map (T U: Set) (g: T -> U) (f: U -> nat) (t: ne_tree.T T):
  expec f (ne_tree.map g t) = expec (f ∘ g) t.
Proof. intros. unfold expec. repeat rewrite comp_apply. rewrite ne_tree.map_map. reflexivity. Qed.

Lemma expec_nonneg (T: Set) (m: ne_tree_monad.M T) (f: T -> nat): 0 <= expec f m.
Proof with auto with real.
  induction m; intros.
      rewrite expec_Leaf...
    rewrite expec_Node_one...
  rewrite expec_Node_cons.
  apply Rmult_le_pos...
  apply Rplus_le_le_0_compat...
  apply Rmult_le_pos...
Qed.

Hint Resolve expec_nonneg.

Lemma expec_le (X: Set) (f g: X -> nat) (t: ne_tree.T X):
  (forall x, ne_tree.In x t -> (f x <= g x)%nat) -> expec f t <= expec g t.
Proof with auto with real.
  induction t; intros.
      simpl.
      repeat rewrite expec_Leaf...
    repeat rewrite expec_Node_one...
  repeat rewrite expec_Node_cons.
  apply Rmult_le_compat_r...
  apply Rplus_le_compat...
  apply Rmult_le_compat_r...
  apply IHt0.
  intros.
  apply H.
  right.
  inversion_clear H0...
Qed.

Lemma expec_0_inv (T: Set) (f: T -> nat) (t: ne_tree.T T):
  expec f t = 0 -> forall x, ne_tree.In x t -> f x = 0%nat.
Proof with auto with real.
  induction t.
      simpl.
      intros.
      inversion_clear H0.
      apply arith_lems.INR_0_inv...
    simpl.
    rewrite expec_Node_one.
    intros.
    inversion_clear H0.
    inversion_clear H1...
  rewrite expec_Node_cons.
  intros.
  inversion_clear H0.
  destruct (arith_lems.Rmult_0_inv H).
    assert (expec f t = 0).
      apply Rplus_eq_0_l with (expec f (ne_tree.Node l) * INR (length l))...
      apply Rmult_le_pos...
    assert (expec f (ne_tree.Node l) = 0).
      rewrite Rplus_comm in H0.
      cut (expec f (ne_tree.Node l) * INR (length l) = 0).
        intro.
        destruct (arith_lems.Rmult_0_inv H3)...
        cset (arith_lems.INR_0_inv _ H4).
        destruct l; discriminate.
      apply Rplus_eq_0_l with (expec f t)...
      apply Rmult_le_pos...
    inversion_clear H1...
  elimtype False.
  apply (Rinv_neq_0_compat (INR (S (length l))))...
Qed.

Lemma expec_constant (T: Set) (f: T -> nat) (c: nat) (t: ne_tree_monad.M T):
   (forall x, ne_tree.In x t -> f x = c) -> expec f t = INR c.
Proof with auto with real.
  induction t.
      intros.
      rewrite expec_Leaf...
    simpl.
    rewrite expec_Node_one...
  rewrite expec_Node_cons.
  intros.
  rewrite IHt...
  rewrite IHt0.
    rewrite S_INR.
    field...
  intros.
  apply H.
  inversion_clear H0...
Qed.

Section bind_expecs.

  Variables (T U: Set) (f: T -> nat).

  Lemma expec_bind_leaf (g: U -> T) (m: ne_tree_monad.M U):
    expec f (m >>= (ne_tree_monad.ret ∘ g)) = expec (f ∘ g) m.
  Proof with auto.
    induction m...
      simpl in *.
      repeat rewrite expec_Node_one...
    simpl in *.
    repeat rewrite expec_Node_cons.
    rewrite IHm.
    rewrite IHm0.
    repeat rewrite ne_list.map_length...
  Qed.

  Lemma expec_bind_cons (x: ne_tree_monad.M U) t (g: U -> ne_tree_monad.M T):
    expec f (@bind ne_tree_monad.M _ _  (ne_tree.Node (ne_list.cons x t)) g) =
    (expec f (x >>= g) + expec f (@bind ne_tree_monad.M _ _ (ne_tree.Node t) g) * INR (length t)) * / INR (S (length t)).
  Proof.
    intros.
    simpl expec.
    rewrite expec_Node_cons.
    repeat rewrite ne_list.map_length.
    reflexivity.
  Qed.

End bind_expecs.
