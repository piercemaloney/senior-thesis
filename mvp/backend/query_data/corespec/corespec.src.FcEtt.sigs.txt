Require Import FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)

Require Export FcEtt.ett_ott.
(* FcEtt.ett_ott:
Require Import Metalib.Metatheory.

Definition tmvar := var. 
Definition covar := var. 
Definition datacon := atom.
Definition const := atom.
Definition tyfam := atom.
Definition index := nat. 

Inductive relflag : Set :=  
 | Rel : relflag
 | Irrel : relflag.

Inductive constraint : Set :=  
 | Eq (a:tm) (b:tm) (A:tm)
with tm : Set :=  
 | a_Star : tm
 | a_Var_b (_:nat)
 | a_Var_f (x:tmvar)
 | a_Abs (rho:relflag) (A:tm) (b:tm)
 | a_UAbs (rho:relflag) (b:tm)
 | a_App (a:tm) (rho:relflag) (b:tm)
 | a_Fam (F:tyfam)
 | a_Const (T:const)
 | a_Pi (rho:relflag) (A:tm) (B:tm)
 | a_Conv (a:tm) (g:co)
 | a_CPi (phi:constraint) (B:tm)
 | a_CAbs (phi:constraint) (b:tm)
 | a_UCAbs (b:tm)
 | a_CApp (a:tm) (g:co)
 | a_Bullet : tm
 | a_DataCon (K:datacon)
 | a_Case (a:tm) (brs5:brs)
with brs : Set :=  
 | br_None : brs
 | br_One (K:datacon) (a:tm) (brs5:brs)
with co : Set :=  
 | g_Triv : co
 | g_Var_b (_:nat)
 | g_Var_f (c:covar)
 | g_Beta (a:tm) (b:tm)
 | g_Refl (a:tm)
 | g_Refl2 (a:tm) (b:tm) (g:co)
 | g_Sym (g:co)
 | g_Trans (g1:co) (g2:co)
 | g_PiCong (rho:relflag) (g1:co) (g2:co)
 | g_AbsCong (rho:relflag) (g1:co) (g2:co)
 | g_AppCong (g1:co) (rho:relflag) (g2:co)
 | g_PiFst (g:co)
 | g_CPiFst (g:co)
 | g_IsoSnd (g:co)
 | g_PiSnd (g1:co) (g2:co)
 | g_CPiCong (g1:co) (g3:co)
 | g_CAbsCong (g1:co) (g3:co) (g4:co)
 | g_CAppCong (g:co) (g1:co) (g2:co)
 | g_CPiSnd (g:co) (g1:co) (g2:co)
 | g_Cast (g1:co) (g2:co)
 | g_EqCong (g1:co) (A:tm) (g2:co)
 | g_IsoConv (phi1:constraint) (phi2:constraint) (g:co)
 | g_Eta (a:tm)
 | g_Left (g:co) (g':co)
 | g_Right (g:co) (g':co).

Inductive sort : Set :=  
 | Tm (A:tm)
 | Co (phi:constraint).

Inductive sig_sort : Set :=  
 | Cs (A:tm)
 | Ax (a:tm) (A:tm).

Definition context : Set := list ( atom * sort ).

Definition available_props : Type := atoms.

Definition sig : Set := list (atom * sig_sort).

Fixpoint open_co_wrt_co_rec (k:nat) (g_5:co) (g__6:co) {struct g__6}: co :=
  match g__6 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => g_Var_b nat
        | inleft (right _) => g_5
        | inright _ => g_Var_b (nat - 1)
      end
  | (g_Var_f c) => g_Var_f c
  | (g_Beta a b) => g_Beta (open_tm_wrt_co_rec k g_5 a) (open_tm_wrt_co_rec k g_5 b)
  | (g_Refl a) => g_Refl (open_tm_wrt_co_rec k g_5 a)
  | (g_Refl2 a b g) => g_Refl2 (open_tm_wrt_co_rec k g_5 a) (open_tm_wrt_co_rec k g_5 b) (open_co_wrt_co_rec k g_5 g)
  | (g_Sym g) => g_Sym (open_co_wrt_co_rec k g_5 g)
  | (g_Trans g1 g2) => g_Trans (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (open_co_wrt_co_rec k g_5 g1) rho (open_co_wrt_co_rec k g_5 g2)
  | (g_PiFst g) => g_PiFst (open_co_wrt_co_rec k g_5 g)
  | (g_CPiFst g) => g_CPiFst (open_co_wrt_co_rec k g_5 g)
  | (g_IsoSnd g) => g_IsoSnd (open_co_wrt_co_rec k g_5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec (S k) g_5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec (S k) g_5 g3) (open_co_wrt_co_rec k g_5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_Cast g1 g2) => g_Cast (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (open_co_wrt_co_rec k g_5 g1) (open_tm_wrt_co_rec k g_5 A) (open_co_wrt_co_rec k g_5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (open_constraint_wrt_co_rec k g_5 phi1) (open_constraint_wrt_co_rec k g_5 phi2) (open_co_wrt_co_rec k g_5 g)
  | (g_Eta a) => g_Eta (open_tm_wrt_co_rec k g_5 a)
  | (g_Left g g') => g_Left (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g')
  | (g_Right g g') => g_Right (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g')
end
with open_brs_wrt_co_rec (k:nat) (g5:co) (brs_6:brs) {struct brs_6}: brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (open_tm_wrt_co_rec k g5 a) (open_brs_wrt_co_rec k g5 brs5)
end
with open_tm_wrt_co_rec (k:nat) (g5:co) (a5:tm) {struct a5}: tm :=
  match a5 with
  | a_Star => a_Star 
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => a_Var_f x
  | (a_Abs rho A b) => a_Abs rho (open_tm_wrt_co_rec k g5 A) (open_tm_wrt_co_rec k g5 b)
  | (a_UAbs rho b) => a_UAbs rho (open_tm_wrt_co_rec k g5 b)
  | (a_App a rho b) => a_App (open_tm_wrt_co_rec k g5 a) rho (open_tm_wrt_co_rec k g5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (open_tm_wrt_co_rec k g5 A) (open_tm_wrt_co_rec k g5 B)
  | (a_Conv a g) => a_Conv (open_tm_wrt_co_rec k g5 a) (open_co_wrt_co_rec k g5 g)
  | (a_CPi phi B) => a_CPi (open_constraint_wrt_co_rec k g5 phi) (open_tm_wrt_co_rec (S k) g5 B)
  | (a_CAbs phi b) => a_CAbs (open_constraint_wrt_co_rec k g5 phi) (open_tm_wrt_co_rec (S k) g5 b)
  | (a_UCAbs b) => a_UCAbs (open_tm_wrt_co_rec (S k) g5 b)
  | (a_CApp a g) => a_CApp (open_tm_wrt_co_rec k g5 a) (open_co_wrt_co_rec k g5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (open_tm_wrt_co_rec k g5 a) (open_brs_wrt_co_rec k g5 brs5)
end
with open_constraint_wrt_co_rec (k:nat) (g5:co) (phi5:constraint) : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (open_tm_wrt_co_rec k g5 a) (open_tm_wrt_co_rec k g5 b) (open_tm_wrt_co_rec k g5 A)
end.

Fixpoint open_co_wrt_tm_rec (k:nat) (a5:tm) (g_5:co) {struct g_5}: co :=
  match g_5 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => g_Var_b nat
  | (g_Var_f c) => g_Var_f c
  | (g_Beta a b) => g_Beta (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b)
  | (g_Refl a) => g_Refl (open_tm_wrt_tm_rec k a5 a)
  | (g_Refl2 a b g) => g_Refl2 (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b) (open_co_wrt_tm_rec k a5 g)
  | (g_Sym g) => g_Sym (open_co_wrt_tm_rec k a5 g)
  | (g_Trans g1 g2) => g_Trans (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec (S k) a5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec (S k) a5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (open_co_wrt_tm_rec k a5 g1) rho (open_co_wrt_tm_rec k a5 g2)
  | (g_PiFst g) => g_PiFst (open_co_wrt_tm_rec k a5 g)
  | (g_CPiFst g) => g_CPiFst (open_co_wrt_tm_rec k a5 g)
  | (g_IsoSnd g) => g_IsoSnd (open_co_wrt_tm_rec k a5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g3) (open_co_wrt_tm_rec k a5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_Cast g1 g2) => g_Cast (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (open_co_wrt_tm_rec k a5 g1) (open_tm_wrt_tm_rec k a5 A) (open_co_wrt_tm_rec k a5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (open_constraint_wrt_tm_rec k a5 phi1) (open_constraint_wrt_tm_rec k a5 phi2) (open_co_wrt_tm_rec k a5 g)
  | (g_Eta a) => g_Eta (open_tm_wrt_tm_rec k a5 a)
  | (g_Left g g') => g_Left (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g')
  | (g_Right g g') => g_Right (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g')
end
with open_brs_wrt_tm_rec (k:nat) (a5:tm) (brs_6:brs) {struct brs_6}: brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (open_tm_wrt_tm_rec k a5 a) (open_brs_wrt_tm_rec k a5 brs5)
end
with open_tm_wrt_tm_rec (k:nat) (a5:tm) (a_6:tm) {struct a_6}: tm :=
  match a_6 with
  | a_Star => a_Star 
  | (a_Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => a_Var_b nat
        | inleft (right _) => a5
        | inright _ => a_Var_b (nat - 1)
      end
  | (a_Var_f x) => a_Var_f x
  | (a_Abs rho A b) => a_Abs rho (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 b)
  | (a_UAbs rho b) => a_UAbs rho (open_tm_wrt_tm_rec (S k) a5 b)
  | (a_App a rho b) => a_App (open_tm_wrt_tm_rec k a5 a) rho (open_tm_wrt_tm_rec k a5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 B)
  | (a_Conv a g) => a_Conv (open_tm_wrt_tm_rec k a5 a) (open_co_wrt_tm_rec k a5 g)
  | (a_CPi phi B) => a_CPi (open_constraint_wrt_tm_rec k a5 phi) (open_tm_wrt_tm_rec k a5 B)
  | (a_CAbs phi b) => a_CAbs (open_constraint_wrt_tm_rec k a5 phi) (open_tm_wrt_tm_rec k a5 b)
  | (a_UCAbs b) => a_UCAbs (open_tm_wrt_tm_rec k a5 b)
  | (a_CApp a g) => a_CApp (open_tm_wrt_tm_rec k a5 a) (open_co_wrt_tm_rec k a5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (open_tm_wrt_tm_rec k a5 a) (open_brs_wrt_tm_rec k a5 brs5)
end
with open_constraint_wrt_tm_rec (k:nat) (a5:tm) (phi5:constraint) : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b) (open_tm_wrt_tm_rec k a5 A)
end.

Definition open_sort_wrt_co_rec (k:nat) (g5:co) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (open_tm_wrt_co_rec k g5 A)
  | (Co phi) => Co (open_constraint_wrt_co_rec k g5 phi)
end.

Definition open_sig_sort_wrt_co_rec (k:nat) (g5:co) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (open_tm_wrt_co_rec k g5 A)
  | (Ax a A) => Ax (open_tm_wrt_co_rec k g5 a) (open_tm_wrt_co_rec k g5 A)
end.

Definition open_sig_sort_wrt_tm_rec (k:nat) (a5:tm) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (open_tm_wrt_tm_rec k a5 A)
  | (Ax a A) => Ax (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 A)
end.

Definition open_sort_wrt_tm_rec (k:nat) (a5:tm) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (open_tm_wrt_tm_rec k a5 A)
  | (Co phi) => Co (open_constraint_wrt_tm_rec k a5 phi)
end.

Definition open_brs_wrt_co g5 brs_6 := open_brs_wrt_co_rec 0 brs_6 g5.

Definition open_tm_wrt_co g5 a5 := open_tm_wrt_co_rec 0 a5 g5.

Definition open_brs_wrt_tm a5 brs_6 := open_brs_wrt_tm_rec 0 brs_6 a5.

Definition open_sort_wrt_co g5 sort5 := open_sort_wrt_co_rec 0 sort5 g5.

Definition open_sig_sort_wrt_co g5 sig_sort5 := open_sig_sort_wrt_co_rec 0 sig_sort5 g5.

Definition open_co_wrt_co g_5 g__6 := open_co_wrt_co_rec 0 g__6 g_5.

Definition open_sig_sort_wrt_tm a5 sig_sort5 := open_sig_sort_wrt_tm_rec 0 sig_sort5 a5.

Definition open_constraint_wrt_co g5 phi5 := open_constraint_wrt_co_rec 0 phi5 g5.

Definition open_constraint_wrt_tm a5 phi5 := open_constraint_wrt_tm_rec 0 phi5 a5.

Definition open_co_wrt_tm a5 g_5 := open_co_wrt_tm_rec 0 g_5 a5.

Definition open_sort_wrt_tm a5 sort5 := open_sort_wrt_tm_rec 0 sort5 a5.

Definition open_tm_wrt_tm a5 a_6 := open_tm_wrt_tm_rec 0 a_6 a5.

Inductive lc_co : co -> Prop :=    
 | lc_g_Triv : 
     (lc_co g_Triv)
 | lc_g_Var_f : forall (c:covar),
     (lc_co (g_Var_f c))
 | lc_g_Beta : forall (a b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_co (g_Beta a b))
 | lc_g_Refl : forall (a:tm),
     (lc_tm a) ->
     (lc_co (g_Refl a))
 | lc_g_Refl2 : forall (a b:tm) (g:co),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_co g) ->
     (lc_co (g_Refl2 a b g))
 | lc_g_Sym : forall (g:co),
     (lc_co g) ->
     (lc_co (g_Sym g))
 | lc_g_Trans : forall (g1 g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_Trans g1 g2))
 | lc_g_PiCong : forall (rho:relflag) (g1 g2:co),
     (lc_co g1) ->
      ( forall x , lc_co  ( open_co_wrt_tm g2 (a_Var_f x) )  )  ->
     (lc_co (g_PiCong rho g1 g2))
 | lc_g_AbsCong : forall (rho:relflag) (g1 g2:co),
     (lc_co g1) ->
      ( forall x , lc_co  ( open_co_wrt_tm g2 (a_Var_f x) )  )  ->
     (lc_co (g_AbsCong rho g1 g2))
 | lc_g_AppCong : forall (g1:co) (rho:relflag) (g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_AppCong g1 rho g2))
 | lc_g_PiFst : forall (g:co),
     (lc_co g) ->
     (lc_co (g_PiFst g))
 | lc_g_CPiFst : forall (g:co),
     (lc_co g) ->
     (lc_co (g_CPiFst g))
 | lc_g_IsoSnd : forall (g:co),
     (lc_co g) ->
     (lc_co (g_IsoSnd g))
 | lc_g_PiSnd : forall (g1 g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_PiSnd g1 g2))
 | lc_g_CPiCong : forall (g1 g3:co),
     (lc_co g1) ->
      ( forall c , lc_co  ( open_co_wrt_co g3 (g_Var_f c) )  )  ->
     (lc_co (g_CPiCong g1 g3))
 | lc_g_CAbsCong : forall (g1 g3 g4:co),
     (lc_co g1) ->
      ( forall c , lc_co  ( open_co_wrt_co g3 (g_Var_f c) )  )  ->
     (lc_co g4) ->
     (lc_co (g_CAbsCong g1 g3 g4))
 | lc_g_CAppCong : forall (g g1 g2:co),
     (lc_co g) ->
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_CAppCong g g1 g2))
 | lc_g_CPiSnd : forall (g g1 g2:co),
     (lc_co g) ->
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_CPiSnd g g1 g2))
 | lc_g_Cast : forall (g1 g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_Cast g1 g2))
 | lc_g_EqCong : forall (g1:co) (A:tm) (g2:co),
     (lc_co g1) ->
     (lc_tm A) ->
     (lc_co g2) ->
     (lc_co (g_EqCong g1 A g2))
 | lc_g_IsoConv : forall (phi1 phi2:constraint) (g:co),
     (lc_constraint phi1) ->
     (lc_constraint phi2) ->
     (lc_co g) ->
     (lc_co (g_IsoConv phi1 phi2 g))
 | lc_g_Eta : forall (a:tm),
     (lc_tm a) ->
     (lc_co (g_Eta a))
 | lc_g_Left : forall (g g':co),
     (lc_co g) ->
     (lc_co g') ->
     (lc_co (g_Left g g'))
 | lc_g_Right : forall (g g':co),
     (lc_co g) ->
     (lc_co g') ->
     (lc_co (g_Right g g'))
with lc_brs : brs -> Prop :=    
 | lc_br_None : 
     (lc_brs br_None)
 | lc_br_One : forall (K:datacon) (a:tm) (brs5:brs),
     (lc_tm a) ->
     (lc_brs brs5) ->
     (lc_brs (br_One K a brs5))
with lc_tm : tm -> Prop :=    
 | lc_a_Star : 
     (lc_tm a_Star)
 | lc_a_Var_f : forall (x:tmvar),
     (lc_tm (a_Var_f x))
 | lc_a_Abs : forall (rho:relflag) (A b:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm b (a_Var_f x) )  )  ->
     (lc_tm (a_Abs rho A b))
 | lc_a_UAbs : forall (rho:relflag) (b:tm),
      ( forall x , lc_tm  ( open_tm_wrt_tm b (a_Var_f x) )  )  ->
     (lc_tm (a_UAbs rho b))
 | lc_a_App : forall (a:tm) (rho:relflag) (b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm (a_App a rho b))
 | lc_a_Fam : forall (F:tyfam),
     (lc_tm (a_Fam F))
 | lc_a_Const : forall (T:const),
     (lc_tm (a_Const T))
 | lc_a_Pi : forall (rho:relflag) (A B:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     (lc_tm (a_Pi rho A B))
 | lc_a_Conv : forall (a:tm) (g:co),
     (lc_tm a) ->
     (lc_co g) ->
     (lc_tm (a_Conv a g))
 | lc_a_CPi : forall (phi:constraint) (B:tm),
     (lc_constraint phi) ->
      ( forall c , lc_tm  ( open_tm_wrt_co B (g_Var_f c) )  )  ->
     (lc_tm (a_CPi phi B))
 | lc_a_CAbs : forall (phi:constraint) (b:tm),
     (lc_constraint phi) ->
      ( forall c , lc_tm  ( open_tm_wrt_co b (g_Var_f c) )  )  ->
     (lc_tm (a_CAbs phi b))
 | lc_a_UCAbs : forall (b:tm),
      ( forall c , lc_tm  ( open_tm_wrt_co b (g_Var_f c) )  )  ->
     (lc_tm (a_UCAbs b))
 | lc_a_CApp : forall (a:tm) (g:co),
     (lc_tm a) ->
     (lc_co g) ->
     (lc_tm (a_CApp a g))
 | lc_a_Bullet : 
     (lc_tm a_Bullet)
 | lc_a_DataCon : forall (K:datacon),
     (lc_tm (a_DataCon K))
 | lc_a_Case : forall (a:tm) (brs5:brs),
     (lc_tm a) ->
     (lc_brs brs5) ->
     (lc_tm (a_Case a brs5))
with lc_constraint : constraint -> Prop :=    
 | lc_Eq : forall (a b A:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm A) ->
     (lc_constraint (Eq a b A)).

Inductive lc_sort : sort -> Prop :=    
 | lc_Tm : forall (A:tm),
     (lc_tm A) ->
     (lc_sort (Tm A))
 | lc_Co : forall (phi:constraint),
     (lc_constraint phi) ->
     (lc_sort (Co phi)).

Inductive lc_sig_sort : sig_sort -> Prop :=    
 | lc_Cs : forall (A:tm),
     (lc_tm A) ->
     (lc_sig_sort (Cs A))
 | lc_Ax : forall (a A:tm),
     (lc_tm a) ->
     (lc_tm A) ->
     (lc_sig_sort (Ax a A)).

Fixpoint fv_tm_tm_co (g_5:co) : vars :=
  match g_5 with
  | g_Triv => {}
  | (g_Var_b nat) => {}
  | (g_Var_f c) => {}
  | (g_Beta a b) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b)
  | (g_Refl a) => (fv_tm_tm_tm a)
  | (g_Refl2 a b g) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b) \u (fv_tm_tm_co g)
  | (g_Sym g) => (fv_tm_tm_co g)
  | (g_Trans g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_PiCong rho g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_AbsCong rho g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_AppCong g1 rho g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_PiFst g) => (fv_tm_tm_co g)
  | (g_CPiFst g) => (fv_tm_tm_co g)
  | (g_IsoSnd g) => (fv_tm_tm_co g)
  | (g_PiSnd g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_CPiCong g1 g3) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g3)
  | (g_CAbsCong g1 g3 g4) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g3) \u (fv_tm_tm_co g4)
  | (g_CAppCong g g1 g2) => (fv_tm_tm_co g) \u (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_CPiSnd g g1 g2) => (fv_tm_tm_co g) \u (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_Cast g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_EqCong g1 A g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_tm A) \u (fv_tm_tm_co g2)
  | (g_IsoConv phi1 phi2 g) => (fv_tm_tm_constraint phi1) \u (fv_tm_tm_constraint phi2) \u (fv_tm_tm_co g)
  | (g_Eta a) => (fv_tm_tm_tm a)
  | (g_Left g g') => (fv_tm_tm_co g) \u (fv_tm_tm_co g')
  | (g_Right g g') => (fv_tm_tm_co g) \u (fv_tm_tm_co g')
end
with fv_tm_tm_brs (brs_6:brs) : vars :=
  match brs_6 with
  | br_None => {}
  | (br_One K a brs5) => (fv_tm_tm_tm a) \u (fv_tm_tm_brs brs5)
end
with fv_tm_tm_tm (a5:tm) : vars :=
  match a5 with
  | a_Star => {}
  | (a_Var_b nat) => {}
  | (a_Var_f x) => {{x}}
  | (a_Abs rho A b) => (fv_tm_tm_tm A) \u (fv_tm_tm_tm b)
  | (a_UAbs rho b) => (fv_tm_tm_tm b)
  | (a_App a rho b) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b)
  | (a_Fam F) => {}
  | (a_Const T) => {}
  | (a_Pi rho A B) => (fv_tm_tm_tm A) \u (fv_tm_tm_tm B)
  | (a_Conv a g) => (fv_tm_tm_tm a) \u (fv_tm_tm_co g)
  | (a_CPi phi B) => (fv_tm_tm_constraint phi) \u (fv_tm_tm_tm B)
  | (a_CAbs phi b) => (fv_tm_tm_constraint phi) \u (fv_tm_tm_tm b)
  | (a_UCAbs b) => (fv_tm_tm_tm b)
  | (a_CApp a g) => (fv_tm_tm_tm a) \u (fv_tm_tm_co g)
  | a_Bullet => {}
  | (a_DataCon K) => {}
  | (a_Case a brs5) => (fv_tm_tm_tm a) \u (fv_tm_tm_brs brs5)
end
with fv_tm_tm_constraint (phi5:constraint) : vars :=
  match phi5 with
  | (Eq a b A) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b) \u (fv_tm_tm_tm A)
end.

Fixpoint fv_co_co_co (g_5:co) : vars :=
  match g_5 with
  | g_Triv => {}
  | (g_Var_b nat) => {}
  | (g_Var_f c) => {{c}}
  | (g_Beta a b) => (fv_co_co_tm a) \u (fv_co_co_tm b)
  | (g_Refl a) => (fv_co_co_tm a)
  | (g_Refl2 a b g) => (fv_co_co_tm a) \u (fv_co_co_tm b) \u (fv_co_co_co g)
  | (g_Sym g) => (fv_co_co_co g)
  | (g_Trans g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_PiCong rho g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_AbsCong rho g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_AppCong g1 rho g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_PiFst g) => (fv_co_co_co g)
  | (g_CPiFst g) => (fv_co_co_co g)
  | (g_IsoSnd g) => (fv_co_co_co g)
  | (g_PiSnd g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_CPiCong g1 g3) => (fv_co_co_co g1) \u (fv_co_co_co g3)
  | (g_CAbsCong g1 g3 g4) => (fv_co_co_co g1) \u (fv_co_co_co g3) \u (fv_co_co_co g4)
  | (g_CAppCong g g1 g2) => (fv_co_co_co g) \u (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_CPiSnd g g1 g2) => (fv_co_co_co g) \u (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_Cast g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_EqCong g1 A g2) => (fv_co_co_co g1) \u (fv_co_co_tm A) \u (fv_co_co_co g2)
  | (g_IsoConv phi1 phi2 g) => (fv_co_co_constraint phi1) \u (fv_co_co_constraint phi2) \u (fv_co_co_co g)
  | (g_Eta a) => (fv_co_co_tm a)
  | (g_Left g g') => (fv_co_co_co g) \u (fv_co_co_co g')
  | (g_Right g g') => (fv_co_co_co g) \u (fv_co_co_co g')
end
with fv_co_co_brs (brs_6:brs) : vars :=
  match brs_6 with
  | br_None => {}
  | (br_One K a brs5) => (fv_co_co_tm a) \u (fv_co_co_brs brs5)
end
with fv_co_co_tm (a5:tm) : vars :=
  match a5 with
  | a_Star => {}
  | (a_Var_b nat) => {}
  | (a_Var_f x) => {}
  | (a_Abs rho A b) => (fv_co_co_tm A) \u (fv_co_co_tm b)
  | (a_UAbs rho b) => (fv_co_co_tm b)
  | (a_App a rho b) => (fv_co_co_tm a) \u (fv_co_co_tm b)
  | (a_Fam F) => {}
  | (a_Const T) => {}
  | (a_Pi rho A B) => (fv_co_co_tm A) \u (fv_co_co_tm B)
  | (a_Conv a g) => (fv_co_co_tm a) \u (fv_co_co_co g)
  | (a_CPi phi B) => (fv_co_co_constraint phi) \u (fv_co_co_tm B)
  | (a_CAbs phi b) => (fv_co_co_constraint phi) \u (fv_co_co_tm b)
  | (a_UCAbs b) => (fv_co_co_tm b)
  | (a_CApp a g) => (fv_co_co_tm a) \u (fv_co_co_co g)
  | a_Bullet => {}
  | (a_DataCon K) => {}
  | (a_Case a brs5) => (fv_co_co_tm a) \u (fv_co_co_brs brs5)
end
with fv_co_co_constraint (phi5:constraint) : vars :=
  match phi5 with
  | (Eq a b A) => (fv_co_co_tm a) \u (fv_co_co_tm b) \u (fv_co_co_tm A)
end.

Definition fv_tm_tm_sig_sort (sig_sort5:sig_sort) : vars :=
  match sig_sort5 with
  | (Cs A) => (fv_tm_tm_tm A)
  | (Ax a A) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm A)
end.

Definition fv_co_co_sig_sort (sig_sort5:sig_sort) : vars :=
  match sig_sort5 with
  | (Cs A) => (fv_co_co_tm A)
  | (Ax a A) => (fv_co_co_tm a) \u (fv_co_co_tm A)
end.

Definition fv_tm_tm_sort (sort5:sort) : vars :=
  match sort5 with
  | (Tm A) => (fv_tm_tm_tm A)
  | (Co phi) => (fv_tm_tm_constraint phi)
end.

Definition fv_co_co_sort (sort5:sort) : vars :=
  match sort5 with
  | (Tm A) => (fv_co_co_tm A)
  | (Co phi) => (fv_co_co_constraint phi)
end.

Fixpoint tm_subst_tm_co (a5:tm) (x5:tmvar) (g_5:co) {struct g_5} : co :=
  match g_5 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => g_Var_b nat
  | (g_Var_f c) => g_Var_f c
  | (g_Beta a b) => g_Beta (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 b)
  | (g_Refl a) => g_Refl (tm_subst_tm_tm a5 x5 a)
  | (g_Refl2 a b g) => g_Refl2 (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 b) (tm_subst_tm_co a5 x5 g)
  | (g_Sym g) => g_Sym (tm_subst_tm_co a5 x5 g)
  | (g_Trans g1 g2) => g_Trans (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (tm_subst_tm_co a5 x5 g1) rho (tm_subst_tm_co a5 x5 g2)
  | (g_PiFst g) => g_PiFst (tm_subst_tm_co a5 x5 g)
  | (g_CPiFst g) => g_CPiFst (tm_subst_tm_co a5 x5 g)
  | (g_IsoSnd g) => g_IsoSnd (tm_subst_tm_co a5 x5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g3) (tm_subst_tm_co a5 x5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_Cast g1 g2) => g_Cast (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_tm a5 x5 A) (tm_subst_tm_co a5 x5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (tm_subst_tm_constraint a5 x5 phi1) (tm_subst_tm_constraint a5 x5 phi2) (tm_subst_tm_co a5 x5 g)
  | (g_Eta a) => g_Eta (tm_subst_tm_tm a5 x5 a)
  | (g_Left g g') => g_Left (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g')
  | (g_Right g g') => g_Right (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g')
end
with tm_subst_tm_brs (a5:tm) (x5:tmvar) (brs_6:brs) {struct brs_6} : brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_brs a5 x5 brs5)
end
with tm_subst_tm_tm (a5:tm) (x5:tmvar) (a_6:tm) {struct a_6} : tm :=
  match a_6 with
  | a_Star => a_Star 
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => (if eq_var x x5 then a5 else (a_Var_f x))
  | (a_Abs rho A b) => a_Abs rho (tm_subst_tm_tm a5 x5 A) (tm_subst_tm_tm a5 x5 b)
  | (a_UAbs rho b) => a_UAbs rho (tm_subst_tm_tm a5 x5 b)
  | (a_App a rho b) => a_App (tm_subst_tm_tm a5 x5 a) rho (tm_subst_tm_tm a5 x5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (tm_subst_tm_tm a5 x5 A) (tm_subst_tm_tm a5 x5 B)
  | (a_Conv a g) => a_Conv (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_co a5 x5 g)
  | (a_CPi phi B) => a_CPi (tm_subst_tm_constraint a5 x5 phi) (tm_subst_tm_tm a5 x5 B)
  | (a_CAbs phi b) => a_CAbs (tm_subst_tm_constraint a5 x5 phi) (tm_subst_tm_tm a5 x5 b)
  | (a_UCAbs b) => a_UCAbs (tm_subst_tm_tm a5 x5 b)
  | (a_CApp a g) => a_CApp (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_co a5 x5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_brs a5 x5 brs5)
end
with tm_subst_tm_constraint (a5:tm) (x5:tmvar) (phi5:constraint) {struct phi5} : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 b) (tm_subst_tm_tm a5 x5 A)
end.

Fixpoint co_subst_co_co (g_5:co) (c5:covar) (g__6:co) {struct g__6} : co :=
  match g__6 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => g_Var_b nat
  | (g_Var_f c) => (if eq_var c c5 then g_5 else (g_Var_f c))
  | (g_Beta a b) => g_Beta (co_subst_co_tm g_5 c5 a) (co_subst_co_tm g_5 c5 b)
  | (g_Refl a) => g_Refl (co_subst_co_tm g_5 c5 a)
  | (g_Refl2 a b g) => g_Refl2 (co_subst_co_tm g_5 c5 a) (co_subst_co_tm g_5 c5 b) (co_subst_co_co g_5 c5 g)
  | (g_Sym g) => g_Sym (co_subst_co_co g_5 c5 g)
  | (g_Trans g1 g2) => g_Trans (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (co_subst_co_co g_5 c5 g1) rho (co_subst_co_co g_5 c5 g2)
  | (g_PiFst g) => g_PiFst (co_subst_co_co g_5 c5 g)
  | (g_CPiFst g) => g_CPiFst (co_subst_co_co g_5 c5 g)
  | (g_IsoSnd g) => g_IsoSnd (co_subst_co_co g_5 c5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g3) (co_subst_co_co g_5 c5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_Cast g1 g2) => g_Cast (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (co_subst_co_co g_5 c5 g1) (co_subst_co_tm g_5 c5 A) (co_subst_co_co g_5 c5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (co_subst_co_constraint g_5 c5 phi1) (co_subst_co_constraint g_5 c5 phi2) (co_subst_co_co g_5 c5 g)
  | (g_Eta a) => g_Eta (co_subst_co_tm g_5 c5 a)
  | (g_Left g g') => g_Left (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g')
  | (g_Right g g') => g_Right (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g')
end
with co_subst_co_brs (g5:co) (c5:covar) (brs_6:brs) {struct brs_6} : brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (co_subst_co_tm g5 c5 a) (co_subst_co_brs g5 c5 brs5)
end
with co_subst_co_tm (g5:co) (c5:covar) (a5:tm) {struct a5} : tm :=
  match a5 with
  | a_Star => a_Star 
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => a_Var_f x
  | (a_Abs rho A b) => a_Abs rho (co_subst_co_tm g5 c5 A) (co_subst_co_tm g5 c5 b)
  | (a_UAbs rho b) => a_UAbs rho (co_subst_co_tm g5 c5 b)
  | (a_App a rho b) => a_App (co_subst_co_tm g5 c5 a) rho (co_subst_co_tm g5 c5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (co_subst_co_tm g5 c5 A) (co_subst_co_tm g5 c5 B)
  | (a_Conv a g) => a_Conv (co_subst_co_tm g5 c5 a) (co_subst_co_co g5 c5 g)
  | (a_CPi phi B) => a_CPi (co_subst_co_constraint g5 c5 phi) (co_subst_co_tm g5 c5 B)
  | (a_CAbs phi b) => a_CAbs (co_subst_co_constraint g5 c5 phi) (co_subst_co_tm g5 c5 b)
  | (a_UCAbs b) => a_UCAbs (co_subst_co_tm g5 c5 b)
  | (a_CApp a g) => a_CApp (co_subst_co_tm g5 c5 a) (co_subst_co_co g5 c5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (co_subst_co_tm g5 c5 a) (co_subst_co_brs g5 c5 brs5)
end
with co_subst_co_constraint (g5:co) (c5:covar) (phi5:constraint) {struct phi5} : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (co_subst_co_tm g5 c5 a) (co_subst_co_tm g5 c5 b) (co_subst_co_tm g5 c5 A)
end.

Definition tm_subst_tm_sort (a5:tm) (x5:tmvar) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (tm_subst_tm_tm a5 x5 A)
  | (Co phi) => Co (tm_subst_tm_constraint a5 x5 phi)
end.

Definition co_subst_co_sort (g5:co) (c5:covar) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (co_subst_co_tm g5 c5 A)
  | (Co phi) => Co (co_subst_co_constraint g5 c5 phi)
end.

Definition tm_subst_tm_sig_sort (a5:tm) (x5:tmvar) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (tm_subst_tm_tm a5 x5 A)
  | (Ax a A) => Ax (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 A)
end.

Definition co_subst_co_sig_sort (g5:co) (c5:covar) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (co_subst_co_tm g5 c5 A)
  | (Ax a A) => Ax (co_subst_co_tm g5 c5 a) (co_subst_co_tm g5 c5 A)
end.

Fixpoint erase_tm (a : tm) : tm :=
   match a with
   | a_Star    => a_Star
   | a_Var_b n => a_Var_b n
   | a_Var_f x => a_Var_f x
   | a_Abs rho A b => a_UAbs rho (erase_tm b)
   | a_UAbs rho b => a_UAbs rho (erase_tm b)
   | a_App a Rel b => a_App (erase_tm a) Rel (erase_tm b)
   | a_App a Irrel b => a_App (erase_tm a) Irrel a_Bullet
   | a_Const T => a_Const T
   | a_Fam F => a_Fam F
   | a_Pi rho A B => a_Pi rho (erase_tm A) (erase_tm B)
   | a_Conv a _ => erase_tm a
   | a_CPi phi B => a_CPi (erase_constraint phi) (erase_tm B)
   | a_CAbs phi b => a_UCAbs (erase_tm b)
   | a_UCAbs b => a_UCAbs (erase_tm b)
   | a_CApp a g => a_CApp (erase_tm a) g_Triv
   | a_DataCon K => a_Star  
   | a_Case a brs => a_Star 
   | a_Bullet => a_Bullet
   end
with erase_brs (x : brs) : brs :=
   match x with
   | br_None => br_None
   | br_One k a y => br_One k (erase_tm a) (erase_brs y)
   end
with erase_constraint (phi : constraint) : constraint :=
   match phi with
   | Eq A B A1 => Eq (erase_tm A) (erase_tm B) (erase_tm A1)
   end.

Definition erase_sort s :=
 match s with
 | Tm a => Tm (erase_tm a)
 | Co p => Co (erase_constraint p)
end.

Definition erase_csort s :=
 match s with
 | Cs a   => Cs (erase_tm a)
 | Ax a A => Ax (erase_tm a) (erase_tm A)
end.

Definition erase_context G := map erase_sort G.
Definition erase_sig S := map erase_csort S.

Definition Fix : atom.

Definition FixDef : tm :=
  (a_Abs Irrel a_Star
         (a_Abs Rel (a_Pi Rel (a_Var_b 0) (a_Var_b 1))
                (a_App (a_Var_b 0) Rel
                       (a_App (a_App (a_Fam Fix) Irrel (a_Var_b 1)) Rel (a_Var_b 0))))).

Definition FixTy : tm :=
  a_Pi Irrel a_Star
       (a_Pi Rel (a_Pi Rel (a_Var_b 0) (a_Var_b 1))
             (a_Var_b 1)).

Definition an_toplevel : sig := Fix ~ Ax FixDef FixTy.

Definition toplevel : sig := erase_sig an_toplevel.

Inductive Path : const -> tm -> Prop :=    
 | Path_Const : forall (T:const),
     Path T (a_Const T)
 | Path_App : forall (T:const) (a:tm) (rho:relflag) (b:tm),
     lc_tm b ->
     Path T a ->
     Path T  ( (a_App a rho b) ) 
 | Path_CApp : forall (T:const) (a:tm) (g:co),
     lc_co g ->
     Path T a ->
     Path T  ( (a_CApp a g) ) 
 | Path_Conv : forall (T:const) (a:tm) (g:co),
     lc_co g ->
     Path T a ->
     Path T  ( (a_Conv a g) ) .

Inductive CoercedValue : tm -> Prop :=    
 | CV : forall (a:tm),
     Value a ->
     CoercedValue a
 | CC : forall (a:tm) (g:co),
     lc_co g ->
     Value a ->
     CoercedValue  ( (a_Conv a g) ) 
with Value : tm -> Prop :=    
 | Value_Star : 
     Value a_Star
 | Value_Pi : forall (rho:relflag) (A B:tm),
     lc_tm A ->
     lc_tm (a_Pi rho A B) ->
     Value (a_Pi rho A B)
 | Value_CPi : forall (phi:constraint) (B:tm),
     lc_constraint phi ->
     lc_tm (a_CPi phi B) ->
     Value (a_CPi phi B)
 | Value_AbsRel : forall (A a:tm),
     lc_tm A ->
     lc_tm (a_Abs Rel A a) ->
     Value (a_Abs Rel A a)
 | Value_UAbsRel : forall (a:tm),
     lc_tm (a_UAbs Rel a) ->
     Value (a_UAbs Rel a)
 | Value_UAbsIrrel : forall (L:vars) (a:tm),
      ( forall x , x \notin  L  -> Value  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     Value (a_UAbs Irrel a)
 | Value_AbsIrrel : forall (L:vars) (A a:tm),
     lc_tm A ->
      ( forall x , x \notin  L  -> CoercedValue  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     Value (a_Abs Irrel A a)
 | Value_CAbs : forall (phi:constraint) (a:tm),
     lc_constraint phi ->
     lc_tm (a_CAbs phi a) ->
     Value (a_CAbs phi a)
 | Value_UCAbs : forall (a:tm),
     lc_tm (a_UCAbs a) ->
     Value (a_UCAbs a)
 | Value_Const : forall (T:const),
     Value (a_Const T)
 | Value_App : forall (a:tm) (rho:relflag) (b:tm) (T:const),
     lc_tm b ->
     Path T a ->
     Value a ->
     Value  ( (a_App a rho b) ) 
 | Value_CApp : forall (a:tm) (g:co) (T:const),
     lc_co g ->
     Path T a ->
     Value a ->
     Value  ( (a_CApp a g) ) 
with value_type : tm -> Prop :=    
 | value_type_Star : 
     value_type a_Star
 | value_type_Pi : forall (rho:relflag) (A B:tm),
     lc_tm A ->
     lc_tm (a_Pi rho A B) ->
     value_type (a_Pi rho A B)
 | value_type_CPi : forall (phi:constraint) (B:tm),
     lc_constraint phi ->
     lc_tm (a_CPi phi B) ->
     value_type (a_CPi phi B)
 | value_type_Const : forall (T:const),
     value_type (a_Const T)
 | value_type_App : forall (a:tm) (rho:relflag) (b:tm) (T:const),
     lc_tm b ->
     Path T a ->
     Value a ->
     value_type  ( (a_App a rho b) ) 
 | value_type_CApp : forall (a:tm) (g:co) (T:const),
     lc_co g ->
     Path T a ->
     Value a ->
     value_type  ( (a_CApp a g) ) 
with DataTy : tm -> tm -> Prop :=    
 | DT_Star : 
     DataTy a_Star a_Star
 | DT_Path : forall (A:tm) (T:const),
     Path T A ->
     DataTy A A
 | DT_Pi : forall (L:vars) (rho:relflag) (A B b:tm),
     lc_tm A ->
      ( forall x , x \notin  L  -> DataTy  ( open_tm_wrt_tm B (a_Var_f x) )  b )  ->
     DataTy  ( (a_Pi rho A B) )  b
 | DT_CPi : forall (L:vars) (phi:constraint) (B b:tm),
     lc_constraint phi ->
      ( forall c , c \notin  L  -> DataTy  ( open_tm_wrt_co B (g_Var_f c) )  b )  ->
     DataTy  ( (a_CPi phi B) )  b.

Inductive consistent : tm -> tm -> Prop :=    
 | consistent_a_Star : 
     consistent a_Star a_Star
 | consistent_a_Pi : forall (rho:relflag) (A1 B1 A2 B2:tm),
     lc_tm A1 ->
     lc_tm (a_Pi rho A1 B1) ->
     lc_tm A2 ->
     lc_tm (a_Pi rho A2 B2) ->
     consistent  ( (a_Pi rho A1 B1) )   ( (a_Pi rho A2 B2) ) 
 | consistent_a_CPi : forall (phi1:constraint) (A1:tm) (phi2:constraint) (A2:tm),
     lc_constraint phi1 ->
     lc_tm (a_CPi phi1 A1) ->
     lc_constraint phi2 ->
     lc_tm (a_CPi phi2 A2) ->
     consistent  ( (a_CPi phi1 A1) )   ( (a_CPi phi2 A2) ) 
 | consistent_a_Path : forall (a1 a2:tm) (T:const),
     Path T a1 ->
     Path T a2 ->
     consistent a1 a2
 | consistent_a_Step_R : forall (a b:tm),
     lc_tm a ->
      not ( value_type b )  ->
     consistent a b
 | consistent_a_Step_L : forall (a b:tm),
     lc_tm b ->
      not ( value_type a )  ->
     consistent a b.

Inductive RhoCheck : relflag -> tmvar -> tm -> Prop :=    
 | Rho_Rel : forall (x:tmvar) (A:tm),
      True  ->
     RhoCheck Rel x A
 | Rho_IrrRel : forall (x:tmvar) (A:tm),
      x  \notin fv_tm_tm_tm  A  ->
     RhoCheck Irrel x A.

Inductive erased_tm : tm -> Prop :=    
 | erased_a_Bullet : 
     erased_tm a_Bullet
 | erased_a_Star : 
     erased_tm a_Star
 | erased_a_Var : forall (x:tmvar),
     erased_tm (a_Var_f x)
 | erased_a_Abs : forall (L:vars) (rho:relflag) (a:tm),
      ( forall x , x \notin  L  -> erased_tm  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     erased_tm  ( (a_UAbs rho a) ) 
 | erased_a_App : forall (a b:tm),
     erased_tm a ->
     erased_tm b ->
     erased_tm  ( (a_App a Rel b) ) 
 | erased_a_AppIrrel : forall (a:tm),
     erased_tm a ->
     erased_tm  ( (a_App a Irrel a_Bullet) ) 
 | erased_a_Pi : forall (L:vars) (rho:relflag) (A B:tm),
     erased_tm A ->
      ( forall x , x \notin  L  -> erased_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     erased_tm  ( (a_Pi rho A B) ) 
 | erased_a_CPi : forall (L:vars) (a b A B:tm),
     erased_tm a ->
     erased_tm b ->
     erased_tm A ->
      ( forall c , c \notin  L  -> erased_tm  ( open_tm_wrt_co B (g_Var_f c) )  )  ->
     erased_tm  ( (a_CPi (Eq a b A) B) ) 
 | erased_a_CAbs : forall (L:vars) (b:tm),
      ( forall c , c \notin  L  -> erased_tm  ( open_tm_wrt_co b (g_Var_f c) )  )  ->
     erased_tm  ( (a_UCAbs b) ) 
 | erased_a_CApp : forall (a:tm),
     erased_tm a ->
     erased_tm  ( (a_CApp a g_Triv) ) 
 | erased_a_Const : forall (T:const),
     erased_tm (a_Const T)
 | erased_a_Fam : forall (F:tyfam),
     erased_tm (a_Fam F).

Inductive Par : context -> available_props -> tm -> tm -> Prop :=    
 | Par_Refl : forall (G:context) (D:available_props) (a:tm),
     lc_tm a ->
     Par G D a a
 | Par_Beta : forall (G:context) (D:available_props) (a b a' b':tm),
     Par G D a  ( (a_UAbs Rel a') )  ->
     Par G D b b' ->
     Par G D (a_App a Rel b)  (open_tm_wrt_tm  a'   b' ) 
 | Par_BetaIrrel : forall (G:context) (D:available_props) (a a':tm),
     Par G D a  ( (a_UAbs Irrel a') )  ->
     Par G D (a_App a Irrel a_Bullet)  (open_tm_wrt_tm  a'   a_Bullet ) 
 | Par_App : forall (G:context) (D:available_props) (a b a' b':tm),
     Par G D a a' ->
     Par G D b b' ->
     Par G D (a_App a Rel b) (a_App a' Rel b')
 | Par_AppIrrel : forall (G:context) (D:available_props) (a a':tm),
     Par G D a a' ->
     Par G D (a_App a Irrel a_Bullet) (a_App a' Irrel a_Bullet)
 | Par_CBeta : forall (G:context) (D:available_props) (a a':tm),
     Par G D a  ( (a_UCAbs a') )  ->
     Par G D (a_CApp a g_Triv)  (open_tm_wrt_co  a'   g_Triv ) 
 | Par_CApp : forall (G:context) (D:available_props) (a a':tm),
     Par G D a a' ->
     Par G D (a_CApp a g_Triv) (a_CApp a' g_Triv)
 | Par_Abs : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (a a':tm),
      ( forall x , x \notin  L  -> Par G D  ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm a' (a_Var_f x) )  )  ->
     Par G D (a_UAbs rho a) (a_UAbs rho a')
 | Par_Pi : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (A B A' B':tm),
     Par G D A A' ->
      ( forall x , x \notin  L  -> Par G D  ( open_tm_wrt_tm B (a_Var_f x) )   ( open_tm_wrt_tm B' (a_Var_f x) )  )  ->
     Par G D (a_Pi rho A B) (a_Pi rho A' B')
 | Par_CAbs : forall (L:vars) (G:context) (D:available_props) (a a':tm),
      ( forall c , c \notin  L  -> Par G D  ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co a' (g_Var_f c) )  )  ->
     Par G D (a_UCAbs a) (a_UCAbs a')
 | Par_CPi : forall (L:vars) (G:context) (D:available_props) (A B A1 a A' B' A1' a':tm),
     Par G D A A' ->
     Par G D B B' ->
      ( forall c , c \notin  L  -> Par G D  ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co a' (g_Var_f c) )  )  ->
     Par G D A1 A1' ->
     Par G D (a_CPi (Eq A B A1) a) (a_CPi (Eq A' B' A1') a')
 | Par_Axiom : forall (G:context) (D:available_props) (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   toplevel   ->
     Par G D (a_Fam F) a
 | Par_Eta : forall (L:vars) (G:context) (D:available_props) (a b' b:tm),
     Par G D b b' ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Rel (a_Var_f x)) )  )  ->
     Par G D (a_UAbs Rel a) b'
 | Par_EtaIrrel : forall (L:vars) (G:context) (D:available_props) (a b' b:tm),
     Par G D b b' ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Irrel a_Bullet) )  )  ->
     Par G D (a_UAbs Irrel a) b'
 | Par_EtaC : forall (L:vars) (G:context) (D:available_props) (a b' b:tm),
     Par G D b b' ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a (g_Var_f c) )   =  (a_CApp b g_Triv) )  )  ->
     Par G D (a_UCAbs a) b'
with MultiPar : context -> available_props -> tm -> tm -> Prop :=    
 | MP_Refl : forall (G:context) (D:available_props) (a:tm),
     lc_tm a ->
     MultiPar G D a a
 | MP_Step : forall (G:context) (D:available_props) (a a' b:tm),
     Par G D a b ->
     MultiPar G D b a' ->
     MultiPar G D a a'
with joins : context -> available_props -> tm -> tm -> Prop :=    
 | join : forall (G:context) (D:available_props) (a1 a2 b:tm),
     MultiPar G D a1 b ->
     MultiPar G D a2 b ->
     joins G D a1 a2.

Inductive Beta : tm -> tm -> Prop :=    
 | Beta_AppAbs : forall (v b:tm),
     lc_tm (a_UAbs Rel v) ->
     lc_tm b ->
     Beta (a_App  ( (a_UAbs Rel v) )  Rel b)  (open_tm_wrt_tm  v   b ) 
 | Beta_AppAbsIrrel : forall (v:tm),
     Value  ( (a_UAbs Irrel v) )  ->
     Beta (a_App  ( (a_UAbs Irrel v) )  Irrel a_Bullet)  (open_tm_wrt_tm  v   a_Bullet ) 
 | Beta_CAppCAbs : forall (a':tm),
     lc_tm (a_UCAbs a') ->
     Beta (a_CApp  ( (a_UCAbs a') )  g_Triv)  (open_tm_wrt_co  a'   g_Triv ) 
 | Beta_Axiom : forall (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   toplevel   ->
     Beta (a_Fam F) a
with reduction_in_one : tm -> tm -> Prop :=    
 | E_AbsTerm : forall (L:vars) (a a':tm),
      ( forall x , x \notin  L  -> reduction_in_one  ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm a' (a_Var_f x) )  )  ->
     reduction_in_one (a_UAbs Irrel a) (a_UAbs Irrel a')
 | E_AppLeft : forall (a b a':tm),
     lc_tm b ->
     reduction_in_one a a' ->
     reduction_in_one (a_App a Rel b) (a_App a' Rel b)
 | E_AppLeftIrrel : forall (a a':tm),
     reduction_in_one a a' ->
     reduction_in_one (a_App a Irrel a_Bullet) (a_App a' Irrel a_Bullet)
 | E_CAppLeft : forall (a a':tm),
     reduction_in_one a a' ->
     reduction_in_one (a_CApp a g_Triv) (a_CApp a' g_Triv)
 | E_AppAbs : forall (v a:tm),
     lc_tm (a_UAbs Rel v) ->
     lc_tm a ->
     reduction_in_one (a_App  ( (a_UAbs Rel v) )  Rel a)  (open_tm_wrt_tm  v   a ) 
 | E_AppAbsIrrel : forall (v:tm),
     Value  ( (a_UAbs Irrel v) )  ->
     reduction_in_one (a_App  ( (a_UAbs Irrel v) )  Irrel a_Bullet)  (open_tm_wrt_tm  v   a_Bullet ) 
 | E_CAppCAbs : forall (b:tm),
     lc_tm (a_UCAbs b) ->
     reduction_in_one (a_CApp  ( (a_UCAbs b) )  g_Triv)  (open_tm_wrt_co  b   g_Triv ) 
 | E_Axiom : forall (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   toplevel   ->
     reduction_in_one (a_Fam F) a
with reduction : tm -> tm -> Prop :=    
 | Equal : forall (a:tm),
     lc_tm a ->
     reduction a a
 | Step : forall (a a' b:tm),
     reduction_in_one a b ->
     reduction b a' ->
     reduction a a'.

Inductive PropWff : context -> constraint -> Prop :=    
 | E_Wff : forall (G:context) (a b A:tm),
     Typing G a A ->
     Typing G b A ->
      ( Typing G A a_Star )  ->
     PropWff G (Eq a b A)
with Typing : context -> tm -> tm -> Prop :=    
 | E_Star : forall (G:context),
     Ctx G ->
     Typing G a_Star a_Star
 | E_Var : forall (G:context) (x:tmvar) (A:tm),
     Ctx G ->
      binds  x  (Tm  A )  G  ->
     Typing G (a_Var_f x) A
 | E_Pi : forall (L:vars) (G:context) (rho:relflag) (A B:tm),
      ( forall x , x \notin  L  -> Typing  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm B (a_Var_f x) )  a_Star )  ->
      ( Typing G A a_Star )  ->
     Typing G (a_Pi rho A B) a_Star
 | E_Abs : forall (L:vars) (G:context) (rho:relflag) (a A B:tm),
      ( forall x , x \notin  L  -> Typing  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
      ( Typing G A a_Star )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     Typing G (a_UAbs rho a) (a_Pi rho A B)
 | E_App : forall (G:context) (b a B A:tm),
     Typing G b (a_Pi Rel A B) ->
     Typing G a A ->
     Typing G (a_App b Rel a)  (open_tm_wrt_tm  B   a ) 
 | E_IApp : forall (G:context) (b B a A:tm),
     Typing G b (a_Pi Irrel A B) ->
     Typing G a A ->
     Typing G (a_App b Irrel a_Bullet)  (open_tm_wrt_tm  B   a ) 
 | E_Conv : forall (G:context) (a B A:tm),
     Typing G a A ->
     DefEq G  (dom  G )  A B a_Star ->
      ( Typing G B a_Star )  ->
     Typing G a B
 | E_CPi : forall (L:vars) (G:context) (phi:constraint) (B:tm),
      ( forall c , c \notin  L  -> Typing  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co B (g_Var_f c) )  a_Star )  ->
      ( PropWff G phi )  ->
     Typing G (a_CPi phi B) a_Star
 | E_CAbs : forall (L:vars) (G:context) (a:tm) (phi:constraint) (B:tm),
      ( forall c , c \notin  L  -> Typing  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  )  ->
      ( PropWff G phi )  ->
     Typing G (a_UCAbs a) (a_CPi phi B)
 | E_CApp : forall (G:context) (a1 B1 a b A:tm),
     Typing G a1 (a_CPi  ( (Eq a b A) )  B1) ->
     DefEq G  (dom  G )  a b A ->
     Typing G (a_CApp a1 g_Triv)  (open_tm_wrt_co  B1   g_Triv ) 
 | E_Const : forall (G:context) (T:const) (A:tm),
     Ctx G ->
      binds  T  (Cs  A )   toplevel   ->
      ( Typing  nil  A a_Star )  ->
     Typing G (a_Const T) A
 | E_Fam : forall (G:context) (F:tyfam) (A a:tm),
     Ctx G ->
      binds  F  (Ax  a A )   toplevel   ->
      ( Typing  nil  A a_Star )  ->
     Typing G (a_Fam F) A
with Iso : context -> available_props -> constraint -> constraint -> Prop :=    
 | E_PropCong : forall (G:context) (D:available_props) (A1 B1 A A2 B2:tm),
     DefEq G D A1 A2 A ->
     DefEq G D B1 B2 A ->
     Iso G D (Eq A1 B1 A) (Eq A2 B2 A)
 | E_IsoConv : forall (G:context) (D:available_props) (A1 A2 A B:tm),
     DefEq G D A B a_Star ->
     PropWff G (Eq A1 A2 A) ->
     PropWff G (Eq A1 A2 B) ->
     Iso G D (Eq A1 A2 A) (Eq A1 A2 B)
 | E_CPiFst : forall (G:context) (D:available_props) (phi1 phi2:constraint) (B1 B2:tm),
     DefEq G D (a_CPi phi1 B1) (a_CPi phi2 B2) a_Star ->
     Iso G D phi1 phi2
with DefEq : context -> available_props -> tm -> tm -> tm -> Prop :=    
 | E_Assn : forall (G:context) (D:available_props) (a b A:tm) (c:covar),
     Ctx G ->
      binds  c  (Co   ( (Eq a b A) )  )  G  ->
      AtomSetImpl.In  c   D  ->
     DefEq G D a b A
 | E_Refl : forall (G:context) (D:available_props) (a A:tm),
     Typing G a A ->
     DefEq G D a a A
 | E_Sym : forall (G:context) (D:available_props) (a b A:tm),
     DefEq G D b a A ->
     DefEq G D a b A
 | E_Trans : forall (G:context) (D:available_props) (a b A a1:tm),
     DefEq G D a a1 A ->
     DefEq G D a1 b A ->
     DefEq G D a b A
 | E_Beta : forall (G:context) (D:available_props) (a1 a2 B:tm),
     Typing G a1 B ->
      ( Typing G a2 B )  ->
     Beta a1 a2 ->
     DefEq G D a1 a2 B
 | E_PiCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (A1 B1 A2 B2:tm),
     DefEq G D A1 A2 a_Star ->
      ( forall x , x \notin  L  -> DefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_tm_wrt_tm B1 (a_Var_f x) )   ( open_tm_wrt_tm B2 (a_Var_f x) )  a_Star )  ->
      ( Typing G A1 a_Star )  ->
      ( Typing G (a_Pi rho A1 B1) a_Star )  ->
      ( Typing G (a_Pi rho A2 B2) a_Star )  ->
     DefEq G D  ( (a_Pi rho A1 B1) )   ( (a_Pi rho A2 B2) )  a_Star
 | E_AbsCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (b1 b2 A1 B:tm),
      ( forall x , x \notin  L  -> DefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_tm_wrt_tm b1 (a_Var_f x) )   ( open_tm_wrt_tm b2 (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
      ( Typing G A1 a_Star )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm b1 (a_Var_f x) )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm b2 (a_Var_f x) )  )  ->
     DefEq G D  ( (a_UAbs rho b1) )   ( (a_UAbs rho b2) )  (a_Pi rho A1 B)
 | E_AppCong : forall (G:context) (D:available_props) (a1 a2 b1 b2 B A:tm),
     DefEq G D a1 b1 (a_Pi Rel A B) ->
     DefEq G D a2 b2 A ->
     DefEq G D (a_App a1 Rel a2) (a_App b1 Rel b2)  (open_tm_wrt_tm  B   a2 ) 
 | E_IAppCong : forall (G:context) (D:available_props) (a1 b1 B a A:tm),
     DefEq G D a1 b1 (a_Pi Irrel A B) ->
     Typing G a A ->
     DefEq G D (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet)  (open_tm_wrt_tm  B   a ) 
 | E_PiFst : forall (G:context) (D:available_props) (A1 A2:tm) (rho:relflag) (B1 B2:tm),
     DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star ->
     DefEq G D A1 A2 a_Star
 | E_PiSnd : forall (G:context) (D:available_props) (B1 a1 B2 a2:tm) (rho:relflag) (A1 A2:tm),
     DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star ->
     DefEq G D a1 a2 A1 ->
     DefEq G D  (open_tm_wrt_tm  B1   a1 )   (open_tm_wrt_tm  B2   a2 )  a_Star
 | E_CPiCong : forall (L:vars) (G:context) (D:available_props) (phi1:constraint) (A:tm) (phi2:constraint) (B:tm),
     Iso G D phi1 phi2 ->
      ( forall c , c \notin  L  -> DefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_tm_wrt_co A (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  a_Star )  ->
      ( PropWff G phi1 )  ->
      ( Typing G (a_CPi phi1 A) a_Star )  ->
      ( Typing G (a_CPi phi2 B) a_Star )  ->
     DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star
 | E_CAbsCong : forall (L:vars) (G:context) (D:available_props) (a b:tm) (phi1:constraint) (B:tm),
      ( forall c , c \notin  L  -> DefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co b (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  )  ->
      ( PropWff G phi1 )  ->
     DefEq G D  ( (a_UCAbs a) )   ( (a_UCAbs b) )  (a_CPi phi1 B)
 | E_CAppCong : forall (G:context) (D:available_props) (a1 b1 B a b A:tm),
     DefEq G D a1 b1 (a_CPi  ( (Eq a b A) )  B) ->
     DefEq G  (dom  G )  a b A ->
     DefEq G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv)  (open_tm_wrt_co  B   g_Triv ) 
 | E_CPiSnd : forall (G:context) (D:available_props) (B1 B2 a1 a2 A a1' a2' A':tm),
     DefEq G D (a_CPi  ( (Eq a1 a2 A) )  B1) (a_CPi  ( (Eq a1' a2' A') )  B2) a_Star ->
     DefEq G  (dom  G )  a1 a2 A ->
     DefEq G  (dom  G )  a1' a2' A' ->
     DefEq G D  (open_tm_wrt_co  B1   g_Triv )   (open_tm_wrt_co  B2   g_Triv )  a_Star
 | E_Cast : forall (G:context) (D:available_props) (a' b' A' a b A:tm),
     DefEq G D a b A ->
     Iso G D (Eq a b A) (Eq a' b' A') ->
     DefEq G D a' b' A'
 | E_EqConv : forall (G:context) (D:available_props) (a b B A:tm),
     DefEq G D a b A ->
     DefEq G  (dom  G )  A B a_Star ->
     DefEq G D a b B
 | E_IsoSnd : forall (G:context) (D:available_props) (A A' a b a' b':tm),
     Iso G D (Eq a b A) (Eq a' b' A') ->
     DefEq G D A A' a_Star
 | E_EtaRel : forall (L:vars) (G:context) (D:available_props) (a b A B:tm),
     Typing G b (a_Pi Rel A B) ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Rel (a_Var_f x)) )  )  ->
     DefEq G D (a_UAbs Rel a) b (a_Pi Rel A B)
 | E_EtaIrrel : forall (L:vars) (G:context) (D:available_props) (a b A B:tm),
     Typing G b (a_Pi Irrel A B) ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Irrel a_Bullet) )  )  ->
     DefEq G D (a_UAbs Irrel a) b (a_Pi Irrel A B)
 | E_EtaC : forall (L:vars) (G:context) (D:available_props) (a b:tm) (phi:constraint) (B:tm),
     Typing G b (a_CPi phi B) ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a (g_Var_f c) )   =  (a_CApp b g_Triv) )  )  ->
     DefEq G D (a_UCAbs a) b (a_CPi phi B)
with Ctx : context -> Prop :=    
 | E_Empty : 
     Ctx  nil 
 | E_ConsTm : forall (G:context) (x:tmvar) (A:tm),
     Ctx G ->
     Typing G A a_Star ->
      ~ AtomSetImpl.In  x  (dom  G )  ->
     Ctx  (( x ~ Tm  A ) ++  G ) 
 | E_ConsCo : forall (G:context) (c:covar) (phi:constraint),
     Ctx G ->
     PropWff G phi ->
      ~ AtomSetImpl.In  c  (dom  G )  ->
     Ctx  (( c ~ Co  phi ) ++  G ) .

Inductive Sig : sig -> Prop :=    
 | Sig_Empty : 
     Sig  nil 
 | Sig_ConsCs : forall (S:sig) (T:const) (A:tm),
     Sig S ->
     DataTy A a_Star ->
     Typing  nil  A a_Star ->
      ~ AtomSetImpl.In  T  (dom  S )  ->
     Sig  (( T ~ Cs A )++ S ) 
 | Sig_ConsAx : forall (S:sig) (F:tyfam) (a A:tm),
     Sig S ->
     Typing  nil  A a_Star ->
     Typing  nil  a A ->
      ~ AtomSetImpl.In  F  (dom  S )  ->
     Sig  (( F ~ Ax a A )++ S ) .

Inductive AnnPropWff : context -> constraint -> Prop :=    
 | An_Wff : forall (G:context) (a b A B:tm),
     AnnTyping G a A ->
     AnnTyping G b B ->
      (  (erase_tm  A )   =   (erase_tm  B )  )  ->
     AnnPropWff G (Eq a b A)
with AnnTyping : context -> tm -> tm -> Prop :=    
 | An_Star : forall (G:context),
     AnnCtx G ->
     AnnTyping G a_Star a_Star
 | An_Var : forall (G:context) (x:tmvar) (A:tm),
     AnnCtx G ->
      binds  x  (Tm  A )  G  ->
     AnnTyping G (a_Var_f x) A
 | An_Pi : forall (L:vars) (G:context) (rho:relflag) (A B:tm),
      ( forall x , x \notin  L  -> AnnTyping  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm B (a_Var_f x) )  a_Star )  ->
      ( AnnTyping G A a_Star )  ->
     AnnTyping G (a_Pi rho A B) a_Star
 | An_Abs : forall (L:vars) (G:context) (rho:relflag) (A a B:tm),
      ( AnnTyping G A a_Star )  ->
      ( forall x , x \notin  L  -> AnnTyping  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  (erase_tm   ( open_tm_wrt_tm a (a_Var_f x) )  )  )  ->
     AnnTyping G (a_Abs rho A a) (a_Pi rho A B)
 | An_App : forall (G:context) (b:tm) (rho:relflag) (a B A:tm),
     AnnTyping G b (a_Pi rho A B) ->
     AnnTyping G a A ->
     AnnTyping G (a_App b rho a)  (open_tm_wrt_tm  B   a ) 
 | An_Conv : forall (G:context) (a:tm) (g:co) (B A:tm),
     AnnTyping G a A ->
     AnnDefEq G  (dom  G )  g A B ->
     AnnTyping G B a_Star ->
     AnnTyping G (a_Conv a g) B
 | An_CPi : forall (L:vars) (G:context) (phi:constraint) (B:tm),
      ( AnnPropWff G phi )  ->
      ( forall c , c \notin  L  -> AnnTyping  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co B (g_Var_f c) )  a_Star )  ->
     AnnTyping G (a_CPi phi B) a_Star
 | An_CAbs : forall (L:vars) (G:context) (phi:constraint) (a B:tm),
      ( AnnPropWff G phi )  ->
      ( forall c , c \notin  L  -> AnnTyping  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  )  ->
     AnnTyping G (a_CAbs phi a) (a_CPi phi B)
 | An_CApp : forall (G:context) (a1:tm) (g:co) (B a b A1:tm),
     AnnTyping G a1 (a_CPi (Eq a b A1) B) ->
     AnnDefEq G  (dom  G )  g a b ->
     AnnTyping G (a_CApp a1 g)  (open_tm_wrt_co  B   g ) 
 | An_Const : forall (G:context) (T:const) (A:tm),
     AnnCtx G ->
      binds  T  (Cs  A )   an_toplevel   ->
      ( AnnTyping  nil  A a_Star )  ->
     AnnTyping G (a_Const T) A
 | An_Fam : forall (G:context) (F:tyfam) (A a:tm),
     AnnCtx G ->
      binds  F  (Ax  a A )   an_toplevel   ->
      ( AnnTyping  nil  A a_Star )  ->
     AnnTyping G (a_Fam F) A
with AnnIso : context -> available_props -> co -> constraint -> constraint -> Prop :=    
 | An_PropCong : forall (G:context) (D:available_props) (g1:co) (A:tm) (g2:co) (A1 B1 A2 B2:tm),
     AnnDefEq G D g1 A1 A2 ->
     AnnDefEq G D g2 B1 B2 ->
     AnnPropWff G (Eq A1 B1 A) ->
     AnnPropWff G (Eq A2 B2 A) ->
     AnnIso G D  ( (g_EqCong g1 A g2) )   ( (Eq A1 B1 A) )   ( (Eq A2 B2 A) ) 
 | An_CPiFst : forall (G:context) (D:available_props) (g:co) (phi1 phi2:constraint) (A2 B2:tm),
     AnnDefEq G D g (a_CPi phi1 A2) (a_CPi phi2 B2) ->
     AnnIso G D (g_CPiFst g) phi1 phi2
 | An_IsoSym : forall (G:context) (D:available_props) (g:co) (phi2 phi1:constraint),
     AnnIso G D g phi1 phi2 ->
     AnnIso G D (g_Sym g) phi2 phi1
 | An_IsoConv : forall (G:context) (D:available_props) (a1 a2 A a1' a2' B:tm) (g:co),
     AnnDefEq G D g A B ->
     AnnPropWff G (Eq a1 a2 A) ->
     AnnPropWff G (Eq a1' a2' B) ->
      (  (erase_tm  a1 )   =   (erase_tm  a1' )  )  ->
      (  (erase_tm  a2 )   =   (erase_tm  a2' )  )  ->
     AnnIso G D (g_IsoConv  ( (Eq a1 a2 A) )   ( (Eq a1' a2' B) )  g)  ( (Eq a1 a2 A) )   ( (Eq a1' a2' B) ) 
with AnnDefEq : context -> available_props -> co -> tm -> tm -> Prop :=    
 | An_Assn : forall (G:context) (D:available_props) (c:covar) (a b A:tm),
     AnnCtx G ->
      binds  c  (Co  (Eq a b A) )  G  ->
      AtomSetImpl.In  c   D  ->
     AnnDefEq G D (g_Var_f c) a b
 | An_Refl : forall (G:context) (D:available_props) (a A:tm),
     AnnTyping G a A ->
     AnnDefEq G D (g_Refl a) a a
 | An_EraseEq : forall (G:context) (D:available_props) (a b:tm) (g:co) (A B:tm),
     AnnTyping G a A ->
     AnnTyping G b B ->
      (  (erase_tm  a )   =   (erase_tm  b )  )  ->
     AnnDefEq G  (dom  G )  g A B ->
     AnnDefEq G D (g_Refl2 a b g) a b
 | An_Sym : forall (G:context) (D:available_props) (g:co) (a b B A:tm) (g1:co),
     AnnTyping G b B ->
     AnnTyping G a A ->
      ( AnnDefEq G  (dom  G )  g1 B A )  ->
     AnnDefEq G D g b a ->
     AnnDefEq G D (g_Sym g) a b
 | An_Trans : forall (G:context) (D:available_props) (g1 g2:co) (a b a1 A A1:tm) (g3:co),
     AnnDefEq G D g1 a a1 ->
     AnnDefEq G D g2 a1 b ->
      ( AnnTyping G a A )  ->
      ( AnnTyping G a1 A1 )  ->
      ( AnnDefEq G  (dom  G )  g3 A A1 )  ->
     AnnDefEq G D  ( (g_Trans g1 g2) )  a b
 | An_Beta : forall (G:context) (D:available_props) (a1 a2 B0 B1:tm),
     AnnTyping G a1 B0 ->
     AnnTyping G a2 B1 ->
      (  (erase_tm  B0 )   =   (erase_tm  B1 )  )  ->
     Beta  (erase_tm  a1 )   (erase_tm  a2 )  ->
     AnnDefEq G D (g_Beta a1 a2) a1 a2
 | An_PiCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (A1 B1 A2 B3 B2:tm),
     AnnDefEq G D g1 A1 A2 ->
      ( forall x , x \notin  L  -> AnnDefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_co_wrt_tm g2 (a_Var_f x) )   ( open_tm_wrt_tm B1 (a_Var_f x) )    (open_tm_wrt_tm  B2   (a_Var_f x) )   )  ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm B3 (a_Var_f x) )   =   (open_tm_wrt_tm  B2   (a_Conv (a_Var_f x) (g_Sym g1)) )  )  )  ->
     AnnTyping G (a_Pi rho A1 B1) a_Star ->
     AnnTyping G (a_Pi rho A2 B3) a_Star ->
     AnnTyping G  ( (a_Pi rho A1 B2) )  a_Star ->
     AnnDefEq G D (g_PiCong rho g1 g2)  ( (a_Pi rho A1 B1) )   ( (a_Pi rho A2 B3) ) 
 | An_AbsCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (A1 b1 A2 b3 b2 B:tm),
     AnnDefEq G D g1 A1 A2 ->
      ( forall x , x \notin  L  -> AnnDefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_co_wrt_tm g2 (a_Var_f x) )   ( open_tm_wrt_tm b1 (a_Var_f x) )    (open_tm_wrt_tm  b2   (a_Var_f x) )   )  ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm b3 (a_Var_f x) )   =   (open_tm_wrt_tm  b2   (a_Conv (a_Var_f x) (g_Sym g1)) )  )  )  ->
      ( AnnTyping G A1 a_Star )  ->
     AnnTyping G A2 a_Star ->
      ( forall x , x \notin  L  -> RhoCheck rho x  (erase_tm   ( open_tm_wrt_tm b1 (a_Var_f x) )  )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  (erase_tm   ( open_tm_wrt_tm b3 (a_Var_f x) )  )  )  ->
      ( AnnTyping G  ( (a_Abs rho A1 b2) )  B )  ->
     AnnDefEq G D  ( (g_AbsCong rho g1 g2) )   ( (a_Abs rho A1 b1) )   ( (a_Abs rho A2 b3) ) 
 | An_AppCong : forall (G:context) (D:available_props) (g1:co) (rho:relflag) (g2:co) (a1 a2 b1 b2 A B:tm) (g3:co),
     AnnDefEq G D g1 a1 b1 ->
     AnnDefEq G D g2 a2 b2 ->
     AnnTyping G (a_App a1 rho a2) A ->
     AnnTyping G (a_App b1 rho b2) B ->
      ( AnnDefEq G  (dom  G )  g3 A B )  ->
     AnnDefEq G D (g_AppCong g1 rho g2) (a_App a1 rho a2) (a_App b1 rho b2)
 | An_PiFst : forall (G:context) (D:available_props) (g:co) (A1 A2:tm) (rho:relflag) (B1 B2:tm),
     AnnDefEq G D g (a_Pi rho A1 B1) (a_Pi rho A2 B2) ->
     AnnDefEq G D (g_PiFst g) A1 A2
 | An_PiSnd : forall (G:context) (D:available_props) (g1 g2:co) (B1 a1 B2 a2:tm) (rho:relflag) (A1 A2:tm),
     AnnDefEq G D g1 (a_Pi rho A1 B1) (a_Pi rho A2 B2) ->
     AnnDefEq G D g2 a1 a2 ->
     AnnTyping G a1 A1 ->
     AnnTyping G a2 A2 ->
     AnnDefEq G D (g_PiSnd g1 g2)   (open_tm_wrt_tm  B1   a1 )     (open_tm_wrt_tm  B2   a2 )  
 | An_CPiCong : forall (L:vars) (G:context) (D:available_props) (g1 g3:co) (phi1:constraint) (B1:tm) (phi2:constraint) (B3 B2:tm),
     AnnIso G D g1 phi1 phi2 ->
      ( forall c , c \notin  L  -> AnnDefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_co_wrt_co g3 (g_Var_f c) )   ( open_tm_wrt_co B1 (g_Var_f c) )    (open_tm_wrt_co  B2   (g_Var_f c) )   )  ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co B3 (g_Var_f c) )   =   (open_tm_wrt_co  B2   (g_Cast (g_Var_f c) (g_Sym g1)) )  )  )  ->
     AnnTyping G (a_CPi phi1 B1) a_Star ->
      ( AnnTyping G (a_CPi phi2 B3) a_Star )  ->
     AnnTyping G (a_CPi phi1 B2) a_Star ->
     AnnDefEq G D  ( (g_CPiCong g1 g3) )   ( (a_CPi phi1 B1) )   ( (a_CPi phi2 B3) ) 
 | An_CAbsCong : forall (L:vars) (G:context) (D:available_props) (g1 g3 g4:co) (phi1:constraint) (a1:tm) (phi2:constraint) (a3 a2 B1 B2 B:tm),
     AnnIso G D g1 phi1 phi2 ->
      ( forall c , c \notin  L  -> AnnDefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_co_wrt_co g3 (g_Var_f c) )   ( open_tm_wrt_co a1 (g_Var_f c) )    (open_tm_wrt_co  a2   (g_Var_f c) )   )  ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a3 (g_Var_f c) )   =   (open_tm_wrt_co  a2   (g_Cast (g_Var_f c) (g_Sym g1)) )  )  )  ->
     AnnTyping G  ( (a_CAbs phi1 a1) )  (a_CPi phi1 B1) ->
     AnnTyping G  ( (a_CAbs phi2 a3) )  (a_CPi phi2 B2) ->
     AnnTyping G  ( (a_CAbs phi1 a2) )  B ->
     AnnDefEq G  (dom  G )  g4 (a_CPi phi1 B1) (a_CPi phi2 B2) ->
     AnnDefEq G D  ( (g_CAbsCong g1 g3 g4) )   ( (a_CAbs phi1 a1) )   ( (a_CAbs phi2 a3) ) 
 | An_CAppCong : forall (G:context) (D:available_props) (g1 g2 g3:co) (a1 b1 a2 b2 a3 b3 A B:tm) (g4:co),
     AnnDefEq G D g1 a1 b1 ->
     AnnDefEq G  (dom  G )  g2 a2 b2 ->
     AnnDefEq G  (dom  G )  g3 a3 b3 ->
     AnnTyping G (a_CApp a1 g2) A ->
     AnnTyping G (a_CApp b1 g3) B ->
      ( AnnDefEq G  (dom  G )  g4 A B )  ->
     AnnDefEq G D (g_CAppCong g1 g2 g3) (a_CApp a1 g2) (a_CApp b1 g3)
 | An_CPiSnd : forall (G:context) (D:available_props) (g1 g2 g3:co) (B1 B2 a a' A b b' B:tm),
     AnnDefEq G D g1  ( (a_CPi (Eq a a' A) B1) )   ( (a_CPi (Eq b b' B) B2) )  ->
     AnnDefEq G  (dom  G )  g2 a a' ->
     AnnDefEq G  (dom  G )  g3 b b' ->
     AnnDefEq G D (g_CPiSnd g1 g2 g3)  (open_tm_wrt_co  B1   g2 )   (open_tm_wrt_co  B2   g3 ) 
 | An_Cast : forall (G:context) (D:available_props) (g1 g2:co) (b b' a a' A B:tm),
     AnnDefEq G D g1 a a' ->
     AnnIso G D g2 (Eq a a' A) (Eq b b' B) ->
     AnnDefEq G D (g_Cast g1 g2) b b'
 | An_IsoSnd : forall (G:context) (D:available_props) (g:co) (A B a a' b b':tm),
     AnnIso G D g  ( (Eq a a' A) )   ( (Eq b b' B) )  ->
     AnnDefEq G D (g_IsoSnd g) A B
 | An_Eta : forall (L:vars) (G:context) (D:available_props) (b:tm) (rho:relflag) (A a B:tm),
     AnnTyping G b (a_Pi rho A B) ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b rho (a_Var_f x)) )  )  ->
     AnnDefEq G D (g_Eta b)  ( (a_Abs rho A a) )  b
 | An_EtaC : forall (L:vars) (G:context) (D:available_props) (b:tm) (phi:constraint) (a B:tm),
     AnnTyping G b (a_CPi phi B) ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a (g_Var_f c) )   =  (a_CApp b (g_Var_f c)) )  )  ->
     AnnDefEq G D (g_Eta b)  ( (a_CAbs phi a) )  b
with AnnCtx : context -> Prop :=    
 | An_Empty : 
     AnnCtx  nil 
 | An_ConsTm : forall (G:context) (x:tmvar) (A:tm),
     AnnCtx G ->
     AnnTyping G A a_Star ->
      ~ AtomSetImpl.In  x  (dom  G )  ->
     AnnCtx  (( x ~ Tm  A ) ++  G ) 
 | An_ConsCo : forall (G:context) (c:covar) (phi:constraint),
     AnnCtx G ->
     AnnPropWff G phi ->
      ~ AtomSetImpl.In  c  (dom  G )  ->
     AnnCtx  (( c ~ Co  phi ) ++  G ) 
with AnnSig : sig -> Prop :=    
 | An_Sig_Empty : 
     AnnSig  nil 
 | An_Sig_ConsCs : forall (S:sig) (T:const) (A:tm),
     AnnSig S ->
     AnnTyping  nil  A a_Star ->
     DataTy A a_Star ->
      ~ AtomSetImpl.In  T  (dom  S )  ->
     AnnSig  (( T ~ Cs A )++ S ) 
 | An_Sig_ConsAx : forall (S:sig) (F:tyfam) (a A:tm),
     AnnSig S ->
     AnnTyping  nil  A a_Star ->
     AnnTyping  nil  a A ->
      ~ AtomSetImpl.In  F  (dom  S )  ->
     AnnSig  (( F ~ Ax a A )++ S ) .

Inductive head_reduction : context -> tm -> tm -> Prop :=    
 | An_AppLeft : forall (G:context) (a:tm) (rho:relflag) (b a':tm),
     lc_tm b ->
     head_reduction G a a' ->
     head_reduction G (a_App a rho b) (a_App a' rho b)
 | An_AppAbs : forall (G:context) (rho:relflag) (A w a:tm),
     lc_tm a ->
     Value  ( (a_Abs rho A w) )  ->
     head_reduction G (a_App  ( (a_Abs rho A w) )  rho a)  (open_tm_wrt_tm  w   a ) 
 | An_CAppLeft : forall (G:context) (a:tm) (g:co) (a':tm),
     lc_co g ->
     head_reduction G a a' ->
     head_reduction G (a_CApp a g) (a_CApp a' g)
 | An_CAppCAbs : forall (G:context) (phi:constraint) (b:tm) (g:co),
     lc_constraint phi ->
     lc_tm (a_CAbs phi b) ->
     lc_co g ->
     head_reduction G (a_CApp  ( (a_CAbs phi b) )  g)  (open_tm_wrt_co  b   g ) 
 | An_AbsTerm : forall (L:vars) (G:context) (A b b':tm),
     AnnTyping G A a_Star ->
      ( forall x , x \notin  L  -> head_reduction  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm b (a_Var_f x) )   ( open_tm_wrt_tm b' (a_Var_f x) )  )  ->
     head_reduction G  ( (a_Abs Irrel A b) )   ( (a_Abs Irrel A b') ) 
 | An_Axiom : forall (G:context) (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   an_toplevel   ->
     head_reduction G (a_Fam F) a
 | An_ConvTerm : forall (G:context) (a:tm) (g:co) (a':tm),
     lc_co g ->
     head_reduction G a a' ->
     head_reduction G (a_Conv a g) (a_Conv a' g)
 | An_Combine : forall (G:context) (v:tm) (g1 g2:co),
     lc_co g1 ->
     lc_co g2 ->
     Value v ->
     head_reduction G (a_Conv  ( (a_Conv v g1) )  g2) (a_Conv v  ( (g_Trans g1 g2) ) )
 | An_Push : forall (G:context) (v:tm) (g:co) (rho:relflag) (b b':tm) (g':co) (A1 B1 A2 B2:tm),
     Value v ->
     AnnDefEq G  (dom  G )  g (a_Pi rho A1 B1) (a_Pi rho A2 B2) ->
      ( b'  =  (a_Conv b (g_Sym  ( (g_PiFst g) ) )) )  ->
      ( g'  =  (g_PiSnd g (g_Refl2 b' b  ( (g_PiFst g) ) )) )  ->
     head_reduction G (a_App  ( (a_Conv v g) )  rho b) (a_Conv  ( (a_App v rho b') )  g')
 | An_CPush : forall (G:context) (v:tm) (g g1 g1' g':co) (phi1:constraint) (A1:tm) (phi2:constraint) (A2:tm),
     Value v ->
     AnnDefEq G  (dom  G )  g (a_CPi phi1 A1) (a_CPi phi2 A2) ->
      ( g1'  =  (g_Cast g1 (g_Sym  ( (g_CPiFst g) ) )) )  ->
      ( g'  =  (g_CPiSnd g g1' g1) )  ->
     head_reduction G (a_CApp  ( (a_Conv v g) )  g1) (a_Conv  ( (a_CApp v g1') )  g').

Hint Constructors Path CoercedValue Value value_type DataTy consistent RhoCheck erased_tm Par MultiPar joins Beta reduction_in_one reduction PropWff Typing Iso DefEq Ctx Sig AnnPropWff AnnTyping AnnIso AnnDefEq AnnCtx AnnSig head_reduction lc_co lc_brs lc_tm lc_constraint lc_sort lc_sig_sort. *)
Require Export FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :   (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
     ( x : atom,
          x `notin` L
           DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
     DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  :  (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
     ( c : atom,
          c `notin` L
               DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
     DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    ( x : atom, x `notin` L  Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 :  (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    ( x : atom,
        x `notin` L  Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
     ( x : atom, x `notin` L  RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
     Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 :  (G : context) (a B A : tm),
    Typing G a A  DefEq G (dom G) A B a_Star 
    Typing G a B.

Axiom E_CPi2 :   (L : atoms) (G : context) (phi : constraint) (B : tm),
    ( c : atom, c `notin` L  Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 :  (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       ( c : atom,
        c `notin` L  Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
        Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     :  (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       ( x : atom,
        x `notin` L
         DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
        ( x : atom, x `notin` L  RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
        ( x : atom, x `notin` L  RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
        DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     :  (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       ( c : atom,
        c `notin` L
         DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c)))  DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
     AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
     AnnTyping G A a_Star
     AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :   c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
          AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
          AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :   c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
          AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
          AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion :  (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists :  x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
       (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
       (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
       AnnTyping G A1 a_Star
       AnnTyping G A2 a_Star
       RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
       RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
       AnnTyping G (a_Abs rho A1 b2) B
       AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists :  c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
     (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
     (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
     AnnTyping G (a_CPi phi1 B1) a_Star
     AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
     AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :   (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
       AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
       (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
       AnnTyping G (a_Pi rho A1 B1) a_Star
       AnnTyping G (a_Pi rho A2 B3) a_Star
       AnnTyping G (a_Pi rho A1 B2) a_Star
       AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
     (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
     (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
     AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
     AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
     AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
     AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
     (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
     (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
       x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
     (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
     x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
     (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
       c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig.
