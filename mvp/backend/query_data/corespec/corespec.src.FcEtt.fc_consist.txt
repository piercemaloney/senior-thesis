Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)

Require Export FcEtt.tactics.
(* FcEtt.tactics:
Require Import FcEtt.imports.

Require Import FcEtt.ett_inf.

Inductive Dyn : Type := dyn : forall {T : Type}, T -> Dyn.

Ltac unwrap_dyn d :=
  match d with
    | dyn ?v => v
  end.

Ltac split_hyp :=
  repeat (
      match goal with
        | [ H : _ /\ _ |- _ ] => destruct H
      end).

Ltac rewrite_and_clear eq :=
  first [rewrite -> eq | rewrite <- eq]; clear eq.

Ltac try_rewrite_and_clear eq :=
  first [rewrite -> ! eq | rewrite <- ! eq | idtac]; clear eq.

Ltac try_rewrite_and_clear_f eq :=
  first [rewrite ! eq | idtac]; clear eq.

Ltac find_eq_rew_clear :=
  match goal with
    | [ eq : forall t1,                _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2,             _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3,          _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4,       _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5,    _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5 t6, _ = _ |- _ ] => rewrite_and_clear eq
  end.

Ltac subst_forall :=
  repeat find_eq_rew_clear.

Tactic Notation "basic_nosolve_n"     int_or_var(n) :=
  intuition (subst; eauto n).
Tactic Notation "basic_nosolve_n'"    int_or_var(n) :=
  intuition (subst; simpl in *; subst; eauto n; try done).
Tactic Notation "basic_nosolve_fo_n"  int_or_var(n) :=
  firstorder (subst; eauto n).
Tactic Notation "basic_nosolve_fo_n'" int_or_var(n) :=
  firstorder (subst_forall; simpl in *; subst_forall; eauto n; try done).

Tactic Notation "basic_solve_n"     int_or_var(n) := try solve [basic_nosolve_n     n].
Tactic Notation "basic_solve_n'"    int_or_var(n) := try solve [basic_nosolve_n'    n].
Tactic Notation "basic_solve_fo_n"  int_or_var(n) := try solve [basic_nosolve_fo_n  n].
Tactic Notation "basic_solve_fo_n'" int_or_var(n) := try solve [basic_nosolve_fo_n' n].

Ltac basic_nosolve     := basic_nosolve_n     5.
Ltac basic_nosolve'    := basic_nosolve_n'    5.
Ltac basic_nosolve_fo  := basic_nosolve_fo_n  5.
Ltac basic_nosolve_fo' := basic_nosolve_fo_n' 5.

Ltac basic_solve     := try solve [basic_nosolve].
Ltac basic_solve'    := try solve [basic_nosolve'].
Ltac basic_solve_fo  := try solve [basic_nosolve_fo].
Ltac basic_solve_fo' := try solve [basic_nosolve_fo'].

Ltac solve_by_inv_hyp_about A :=
  multimatch goal with
    | [ H : context [?A] |- _ ] => solve [inversion H; basic_solve]
  end.

Ltac revert_all :=
  repeat match goal with
      | [ H : _ |- _ ] => revert H
    end.

Ltac revert_all_with t :=
  repeat match goal with
      | [ H : _ |- _ ] => try t H; revert dependent H
    end.

Ltac intro_all_with t :=
  repeat
    (let x := fresh in intro x; try (t x)).

Ltac disjunction_assumption :=
  match goal with
    | [H : ?P |- ?P]     => exact H
    | [H : ?P |- ?P ∨ _] => left; exact H
    | [       |- _  ∨ _] => right; disjunction_assumption
  end.

Ltac invert_and_clear H := inversion H; clear H.

Definition wrap : forall P : Prop, P -> P * True := fun _ p => (p, I).
Ltac wrap_hyp H := apply wrap in H.

Lemma AnnCtx_uniq G : AnnCtx G -> uniq G.

Ltac prove_this stmt name :=

  match stmt with
    | uniq ?G =>
      match goal with
      | [ HG : AnnCtx G |- _ ] =>
        
        move: (AnnCtx_uniq HG) => name 
      end
    end.

Ltac find_invertible_hyps :=
  repeat (
  match goal with
    
    | [ H : AnnIso _ _ (g_EqCong _ _ _) _ _ |- _ ] => invert_and_clear H
    
    | [ H : AnnIso _ _ (_ _) _ _ |- _ ] => inversion H; wrap_hyp H

    | [ H : AnnTyping _ (_ _) _ |- _ ] => inversion H; wrap_hyp H

  end).

Ltac pair_coupled_hyps :=
  repeat match goal with
    | [ H1 : binds ?T _ ?G, H2 : binds ?T _ ?G |- _ ] =>
      let unG := fresh "uniq" G in
      prove_this (uniq G) unG;
      move: (binds_unique _ _ _ _ _ H1 H2 unG) => ?; wrap_hyp H2

  end.

Ltac pcess_hyps :=
  find_invertible_hyps;

  pair_coupled_hyps;

  repeat (
    match goal with
      | [ H : _ /\ _       |- _ ] => destruct H

      | [ H : exists x, _  |- _ ] => destruct H

      | [ H : _ * True  |- _      ] => destruct H as [H _]

      | [ H :                   ?A = ?A |- _ ] => clear H
      | [ H : forall _,         ?A = ?A |- _ ] => clear H
      | [ H : forall _ _,       ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _,     ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _,   ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _ _, ?A = ?A |- _ ] => clear H
      
      | [ H : ?P |- _ ] => clear H; let x := fresh in assert (x : P) by solve [assumption | trivial]; clear x

      | [ H : ?C _                         = ?C _                         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _                       = ?C _ _                       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _                     = ?C _ _ _                     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _                   = ?C _ _ _ _                   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _                 = ?C _ _ _ _ _                 |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ |- _ ] => injection H; clear H; intros; try subst

    end).

Ltac pre :=
  repeat (intros; try split);
  
  unfold "~" in *.

Ltac pre' :=
  repeat (intros; try split);
  pcess_hyps;
  unfold "~" in *.

Ltac prove_eq_same_head :=
  solve [subst; reflexivity | f_equal; basic_solve].

Ltac break_union :=
  repeat match goal with
  
    | [ H : ~ ?x `in` union _ _ |- _ ] =>
        move: (notin_union_1 _ _ _ H) (notin_union_2 _ _ _ H) => ??; clear H
  end.

Ltac fsetdec_fast := solve [break_union; basic_solve_n 3].

Ltac autofresh_fixed x :=
   repeat match goal with
     | [ H : ∀ x' : atom, x' `notin` ?L -> _ |- _] =>
       let xL := fresh x L in
       (have xL : x `notin` L by first [fsetdec_fast | fsetdec]);
       specialize (H x xL);
       clear xL 
   end.

 Ltac autofresh :=
   let x := fresh "x" in
   pick fresh x;
   autofresh_fixed x.

Ltac autotype :=
  pcess_hyps;

  repeat match goal with
    | [ |- _ /\ _ ] => split

    | [ |- _ `in` _   ] => try fsetdec_fast; first [fsetdec | fail 2] 
    | [ |- ¬ _ `in` _ ] => try fsetdec_fast; first [fsetdec | fail 2]

    | [ |- _ [=] _  ] => first [fsetdec | fail 2]
    | [ |- _ [<=] _ ] => first [fsetdec | fail 2]

    | [ |- ?C _                         = ?C _                         ] => prove_eq_same_head
    | [ |- ?C _ _                       = ?C _ _                       ] => prove_eq_same_head
    | [ |- ?C _ _ _                     = ?C _ _ _                     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _                   = ?C _ _ _ _                   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _                 = ?C _ _ _ _ _                 ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ ] => prove_eq_same_head

    | _ => try done; basic_solve; fail 0

    | [ |- ex _ ] => eexists

    | [ |- AnnTyping _   (_ _) _   ] => econstructor; pcess_hyps
    | [ |- AnnDefEq  _ _ (_ _) _ _ ] => econstructor; pcess_hyps
    | [ |- AnnIso    _ _ (_ _) _ _ ] => econstructor; pcess_hyps
  end.

Ltac ok := autotype.
Ltac depind x := dependent induction x. *)
Require Export FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)
Require Export FcEtt.ett_inf.
(* FcEtt.ett_inf:
Require Import Coq.Logic.FunctionalExtensionality.
Require Import Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export ett_ott.

Scheme relflag_ind' := Induction for relflag Sort Prop.

Definition relflag_mutind :=
  fun H1 H2 H3 =>
  relflag_ind' H1 H2 H3.

Scheme relflag_rec' := Induction for relflag Sort Set.

Definition relflag_mutrec :=
  fun H1 H2 H3 =>
  relflag_rec' H1 H2 H3.

Scheme tm_ind' := Induction for tm Sort Prop
  with brs_ind' := Induction for brs Sort Prop
  with co_ind' := Induction for co Sort Prop
  with constraint_ind' := Induction for constraint Sort Prop.

Definition tm_brs_co_constraint_mutind :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49 =>
  (conj (tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  ((conj (brs_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  ((conj (co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  (constraint_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)))))).

Scheme tm_rec' := Induction for tm Sort Set
  with brs_rec' := Induction for brs Sort Set
  with co_rec' := Induction for co Sort Set
  with constraint_rec' := Induction for constraint Sort Set.

Definition tm_brs_co_constraint_mutrec :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49 =>
  (pair ((pair ((pair (tm_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  (brs_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)))
  (co_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)))
  (constraint_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)).

Fixpoint close_tm_wrt_tm_rec (n1 : nat) (x1 : tmvar) (a1 : tm) {struct a1} : tm :=
  match a1 with
    | a_Star => a_Star
    | a_Var_f x2 => if (x1 == x2) then (a_Var_b n1) else (a_Var_f x2)
    | a_Var_b n2 => if (lt_ge_dec n2 n1) then (a_Var_b n2) else (a_Var_b (S n2))
    | a_Abs rho1 A1 b1 => a_Abs rho1 (close_tm_wrt_tm_rec n1 x1 A1) (close_tm_wrt_tm_rec (S n1) x1 b1)
    | a_UAbs rho1 b1 => a_UAbs rho1 (close_tm_wrt_tm_rec (S n1) x1 b1)
    | a_App a2 rho1 b1 => a_App (close_tm_wrt_tm_rec n1 x1 a2) rho1 (close_tm_wrt_tm_rec n1 x1 b1)
    | a_Fam F1 => a_Fam F1
    | a_Const T1 => a_Const T1
    | a_Pi rho1 A1 B1 => a_Pi rho1 (close_tm_wrt_tm_rec n1 x1 A1) (close_tm_wrt_tm_rec (S n1) x1 B1)
    | a_Conv a2 g1 => a_Conv (close_tm_wrt_tm_rec n1 x1 a2) (close_co_wrt_tm_rec n1 x1 g1)
    | a_CPi phi1 B1 => a_CPi (close_constraint_wrt_tm_rec n1 x1 phi1) (close_tm_wrt_tm_rec n1 x1 B1)
    | a_CAbs phi1 b1 => a_CAbs (close_constraint_wrt_tm_rec n1 x1 phi1) (close_tm_wrt_tm_rec n1 x1 b1)
    | a_UCAbs b1 => a_UCAbs (close_tm_wrt_tm_rec n1 x1 b1)
    | a_CApp a2 g1 => a_CApp (close_tm_wrt_tm_rec n1 x1 a2) (close_co_wrt_tm_rec n1 x1 g1)
    | a_Bullet => a_Bullet
    | a_DataCon K1 => a_DataCon K1
    | a_Case a2 brs1 => a_Case (close_tm_wrt_tm_rec n1 x1 a2) (close_brs_wrt_tm_rec n1 x1 brs1)
  end

with close_brs_wrt_tm_rec (n1 : nat) (x1 : tmvar) (brs1 : brs) {struct brs1} : brs :=
  match brs1 with
    | br_None => br_None
    | br_One K1 a1 brs2 => br_One K1 (close_tm_wrt_tm_rec n1 x1 a1) (close_brs_wrt_tm_rec n1 x1 brs2)
  end

with close_co_wrt_tm_rec (n1 : nat) (x1 : tmvar) (g1 : co) {struct g1} : co :=
  match g1 with
    | g_Triv => g_Triv
    | g_Var_f c1 => g_Var_f c1
    | g_Var_b n2 => g_Var_b n2
    | g_Beta a1 b1 => g_Beta (close_tm_wrt_tm_rec n1 x1 a1) (close_tm_wrt_tm_rec n1 x1 b1)
    | g_Refl a1 => g_Refl (close_tm_wrt_tm_rec n1 x1 a1)
    | g_Refl2 a1 b1 g2 => g_Refl2 (close_tm_wrt_tm_rec n1 x1 a1) (close_tm_wrt_tm_rec n1 x1 b1) (close_co_wrt_tm_rec n1 x1 g2)
    | g_Sym g2 => g_Sym (close_co_wrt_tm_rec n1 x1 g2)
    | g_Trans g2 g3 => g_Trans (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3)
    | g_PiCong rho1 g2 g3 => g_PiCong rho1 (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec (S n1) x1 g3)
    | g_AbsCong rho1 g2 g3 => g_AbsCong rho1 (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec (S n1) x1 g3)
    | g_AppCong g2 rho1 g3 => g_AppCong (close_co_wrt_tm_rec n1 x1 g2) rho1 (close_co_wrt_tm_rec n1 x1 g3)
    | g_PiFst g2 => g_PiFst (close_co_wrt_tm_rec n1 x1 g2)
    | g_CPiFst g2 => g_CPiFst (close_co_wrt_tm_rec n1 x1 g2)
    | g_IsoSnd g2 => g_IsoSnd (close_co_wrt_tm_rec n1 x1 g2)
    | g_PiSnd g2 g3 => g_PiSnd (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3)
    | g_CPiCong g2 g3 => g_CPiCong (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3)
    | g_CAbsCong g2 g3 g4 => g_CAbsCong (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3) (close_co_wrt_tm_rec n1 x1 g4)
    | g_CAppCong g2 g3 g4 => g_CAppCong (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3) (close_co_wrt_tm_rec n1 x1 g4)
    | g_CPiSnd g2 g3 g4 => g_CPiSnd (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3) (close_co_wrt_tm_rec n1 x1 g4)
    | g_Cast g2 g3 => g_Cast (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3)
    | g_EqCong g2 A1 g3 => g_EqCong (close_co_wrt_tm_rec n1 x1 g2) (close_tm_wrt_tm_rec n1 x1 A1) (close_co_wrt_tm_rec n1 x1 g3)
    | g_IsoConv phi1 phi2 g2 => g_IsoConv (close_constraint_wrt_tm_rec n1 x1 phi1) (close_constraint_wrt_tm_rec n1 x1 phi2) (close_co_wrt_tm_rec n1 x1 g2)
    | g_Eta a1 => g_Eta (close_tm_wrt_tm_rec n1 x1 a1)
    | g_Left g2 g3 => g_Left (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3)
    | g_Right g2 g3 => g_Right (close_co_wrt_tm_rec n1 x1 g2) (close_co_wrt_tm_rec n1 x1 g3)
  end

with close_constraint_wrt_tm_rec (n1 : nat) (x1 : tmvar) (phi1 : constraint) {struct phi1} : constraint :=
  match phi1 with
    | Eq a1 b1 A1 => Eq (close_tm_wrt_tm_rec n1 x1 a1) (close_tm_wrt_tm_rec n1 x1 b1) (close_tm_wrt_tm_rec n1 x1 A1)
  end.

Fixpoint close_tm_wrt_co_rec (n1 : nat) (c1 : covar) (a1 : tm) {struct a1} : tm :=
  match a1 with
    | a_Star => a_Star
    | a_Var_f x1 => a_Var_f x1
    | a_Var_b n2 => a_Var_b n2
    | a_Abs rho1 A1 b1 => a_Abs rho1 (close_tm_wrt_co_rec n1 c1 A1) (close_tm_wrt_co_rec n1 c1 b1)
    | a_UAbs rho1 b1 => a_UAbs rho1 (close_tm_wrt_co_rec n1 c1 b1)
    | a_App a2 rho1 b1 => a_App (close_tm_wrt_co_rec n1 c1 a2) rho1 (close_tm_wrt_co_rec n1 c1 b1)
    | a_Fam F1 => a_Fam F1
    | a_Const T1 => a_Const T1
    | a_Pi rho1 A1 B1 => a_Pi rho1 (close_tm_wrt_co_rec n1 c1 A1) (close_tm_wrt_co_rec n1 c1 B1)
    | a_Conv a2 g1 => a_Conv (close_tm_wrt_co_rec n1 c1 a2) (close_co_wrt_co_rec n1 c1 g1)
    | a_CPi phi1 B1 => a_CPi (close_constraint_wrt_co_rec n1 c1 phi1) (close_tm_wrt_co_rec (S n1) c1 B1)
    | a_CAbs phi1 b1 => a_CAbs (close_constraint_wrt_co_rec n1 c1 phi1) (close_tm_wrt_co_rec (S n1) c1 b1)
    | a_UCAbs b1 => a_UCAbs (close_tm_wrt_co_rec (S n1) c1 b1)
    | a_CApp a2 g1 => a_CApp (close_tm_wrt_co_rec n1 c1 a2) (close_co_wrt_co_rec n1 c1 g1)
    | a_Bullet => a_Bullet
    | a_DataCon K1 => a_DataCon K1
    | a_Case a2 brs1 => a_Case (close_tm_wrt_co_rec n1 c1 a2) (close_brs_wrt_co_rec n1 c1 brs1)
  end

with close_brs_wrt_co_rec (n1 : nat) (c1 : covar) (brs1 : brs) {struct brs1} : brs :=
  match brs1 with
    | br_None => br_None
    | br_One K1 a1 brs2 => br_One K1 (close_tm_wrt_co_rec n1 c1 a1) (close_brs_wrt_co_rec n1 c1 brs2)
  end

with close_co_wrt_co_rec (n1 : nat) (c1 : covar) (g1 : co) {struct g1} : co :=
  match g1 with
    | g_Triv => g_Triv
    | g_Var_f c2 => if (c1 == c2) then (g_Var_b n1) else (g_Var_f c2)
    | g_Var_b n2 => if (lt_ge_dec n2 n1) then (g_Var_b n2) else (g_Var_b (S n2))
    | g_Beta a1 b1 => g_Beta (close_tm_wrt_co_rec n1 c1 a1) (close_tm_wrt_co_rec n1 c1 b1)
    | g_Refl a1 => g_Refl (close_tm_wrt_co_rec n1 c1 a1)
    | g_Refl2 a1 b1 g2 => g_Refl2 (close_tm_wrt_co_rec n1 c1 a1) (close_tm_wrt_co_rec n1 c1 b1) (close_co_wrt_co_rec n1 c1 g2)
    | g_Sym g2 => g_Sym (close_co_wrt_co_rec n1 c1 g2)
    | g_Trans g2 g3 => g_Trans (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
    | g_PiCong rho1 g2 g3 => g_PiCong rho1 (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
    | g_AbsCong rho1 g2 g3 => g_AbsCong rho1 (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
    | g_AppCong g2 rho1 g3 => g_AppCong (close_co_wrt_co_rec n1 c1 g2) rho1 (close_co_wrt_co_rec n1 c1 g3)
    | g_PiFst g2 => g_PiFst (close_co_wrt_co_rec n1 c1 g2)
    | g_CPiFst g2 => g_CPiFst (close_co_wrt_co_rec n1 c1 g2)
    | g_IsoSnd g2 => g_IsoSnd (close_co_wrt_co_rec n1 c1 g2)
    | g_PiSnd g2 g3 => g_PiSnd (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
    | g_CPiCong g2 g3 => g_CPiCong (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec (S n1) c1 g3)
    | g_CAbsCong g2 g3 g4 => g_CAbsCong (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec (S n1) c1 g3) (close_co_wrt_co_rec n1 c1 g4)
    | g_CAppCong g2 g3 g4 => g_CAppCong (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3) (close_co_wrt_co_rec n1 c1 g4)
    | g_CPiSnd g2 g3 g4 => g_CPiSnd (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3) (close_co_wrt_co_rec n1 c1 g4)
    | g_Cast g2 g3 => g_Cast (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
    | g_EqCong g2 A1 g3 => g_EqCong (close_co_wrt_co_rec n1 c1 g2) (close_tm_wrt_co_rec n1 c1 A1) (close_co_wrt_co_rec n1 c1 g3)
    | g_IsoConv phi1 phi2 g2 => g_IsoConv (close_constraint_wrt_co_rec n1 c1 phi1) (close_constraint_wrt_co_rec n1 c1 phi2) (close_co_wrt_co_rec n1 c1 g2)
    | g_Eta a1 => g_Eta (close_tm_wrt_co_rec n1 c1 a1)
    | g_Left g2 g3 => g_Left (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
    | g_Right g2 g3 => g_Right (close_co_wrt_co_rec n1 c1 g2) (close_co_wrt_co_rec n1 c1 g3)
  end

with close_constraint_wrt_co_rec (n1 : nat) (c1 : covar) (phi1 : constraint) {struct phi1} : constraint :=
  match phi1 with
    | Eq a1 b1 A1 => Eq (close_tm_wrt_co_rec n1 c1 a1) (close_tm_wrt_co_rec n1 c1 b1) (close_tm_wrt_co_rec n1 c1 A1)
  end.

Definition close_tm_wrt_tm x1 a1 := close_tm_wrt_tm_rec 0 x1 a1.

Definition close_brs_wrt_tm x1 brs1 := close_brs_wrt_tm_rec 0 x1 brs1.

Definition close_co_wrt_tm x1 g1 := close_co_wrt_tm_rec 0 x1 g1.

Definition close_constraint_wrt_tm x1 phi1 := close_constraint_wrt_tm_rec 0 x1 phi1.

Definition close_tm_wrt_co c1 a1 := close_tm_wrt_co_rec 0 c1 a1.

Definition close_brs_wrt_co c1 brs1 := close_brs_wrt_co_rec 0 c1 brs1.

Definition close_co_wrt_co c1 g1 := close_co_wrt_co_rec 0 c1 g1.

Definition close_constraint_wrt_co c1 phi1 := close_constraint_wrt_co_rec 0 c1 phi1.

Fixpoint size_relflag (rho1 : relflag) {struct rho1} : nat :=
  match rho1 with
    | Rel => 1
    | Irrel => 1
  end.

Fixpoint size_tm (a1 : tm) {struct a1} : nat :=
  match a1 with
    | a_Star => 1
    | a_Var_f x1 => 1
    | a_Var_b n1 => 1
    | a_Abs rho1 A1 b1 => 1 + (size_relflag rho1) + (size_tm A1) + (size_tm b1)
    | a_UAbs rho1 b1 => 1 + (size_relflag rho1) + (size_tm b1)
    | a_App a2 rho1 b1 => 1 + (size_tm a2) + (size_relflag rho1) + (size_tm b1)
    | a_Fam F1 => 1
    | a_Const T1 => 1
    | a_Pi rho1 A1 B1 => 1 + (size_relflag rho1) + (size_tm A1) + (size_tm B1)
    | a_Conv a2 g1 => 1 + (size_tm a2) + (size_co g1)
    | a_CPi phi1 B1 => 1 + (size_constraint phi1) + (size_tm B1)
    | a_CAbs phi1 b1 => 1 + (size_constraint phi1) + (size_tm b1)
    | a_UCAbs b1 => 1 + (size_tm b1)
    | a_CApp a2 g1 => 1 + (size_tm a2) + (size_co g1)
    | a_Bullet => 1
    | a_DataCon K1 => 1
    | a_Case a2 brs1 => 1 + (size_tm a2) + (size_brs brs1)
  end

with size_brs (brs1 : brs) {struct brs1} : nat :=
  match brs1 with
    | br_None => 1
    | br_One K1 a1 brs2 => 1 + (size_tm a1) + (size_brs brs2)
  end

with size_co (g1 : co) {struct g1} : nat :=
  match g1 with
    | g_Triv => 1
    | g_Var_f c1 => 1
    | g_Var_b n1 => 1
    | g_Beta a1 b1 => 1 + (size_tm a1) + (size_tm b1)
    | g_Refl a1 => 1 + (size_tm a1)
    | g_Refl2 a1 b1 g2 => 1 + (size_tm a1) + (size_tm b1) + (size_co g2)
    | g_Sym g2 => 1 + (size_co g2)
    | g_Trans g2 g3 => 1 + (size_co g2) + (size_co g3)
    | g_PiCong rho1 g2 g3 => 1 + (size_relflag rho1) + (size_co g2) + (size_co g3)
    | g_AbsCong rho1 g2 g3 => 1 + (size_relflag rho1) + (size_co g2) + (size_co g3)
    | g_AppCong g2 rho1 g3 => 1 + (size_co g2) + (size_relflag rho1) + (size_co g3)
    | g_PiFst g2 => 1 + (size_co g2)
    | g_CPiFst g2 => 1 + (size_co g2)
    | g_IsoSnd g2 => 1 + (size_co g2)
    | g_PiSnd g2 g3 => 1 + (size_co g2) + (size_co g3)
    | g_CPiCong g2 g3 => 1 + (size_co g2) + (size_co g3)
    | g_CAbsCong g2 g3 g4 => 1 + (size_co g2) + (size_co g3) + (size_co g4)
    | g_CAppCong g2 g3 g4 => 1 + (size_co g2) + (size_co g3) + (size_co g4)
    | g_CPiSnd g2 g3 g4 => 1 + (size_co g2) + (size_co g3) + (size_co g4)
    | g_Cast g2 g3 => 1 + (size_co g2) + (size_co g3)
    | g_EqCong g2 A1 g3 => 1 + (size_co g2) + (size_tm A1) + (size_co g3)
    | g_IsoConv phi1 phi2 g2 => 1 + (size_constraint phi1) + (size_constraint phi2) + (size_co g2)
    | g_Eta a1 => 1 + (size_tm a1)
    | g_Left g2 g3 => 1 + (size_co g2) + (size_co g3)
    | g_Right g2 g3 => 1 + (size_co g2) + (size_co g3)
  end

with size_constraint (phi1 : constraint) {struct phi1} : nat :=
  match phi1 with
    | Eq a1 b1 A1 => 1 + (size_tm a1) + (size_tm b1) + (size_tm A1)
  end.

Inductive degree_tm_wrt_tm : nat -> tm -> Prop :=
  | degree_wrt_tm_a_Star : forall n1,
    degree_tm_wrt_tm n1 (a_Star)
  | degree_wrt_tm_a_Var_f : forall n1 x1,
    degree_tm_wrt_tm n1 (a_Var_f x1)
  | degree_wrt_tm_a_Var_b : forall n1 n2,
    lt n2 n1 ->
    degree_tm_wrt_tm n1 (a_Var_b n2)
  | degree_wrt_tm_a_Abs : forall n1 rho1 A1 b1,
    degree_tm_wrt_tm n1 A1 ->
    degree_tm_wrt_tm (S n1) b1 ->
    degree_tm_wrt_tm n1 (a_Abs rho1 A1 b1)
  | degree_wrt_tm_a_UAbs : forall n1 rho1 b1,
    degree_tm_wrt_tm (S n1) b1 ->
    degree_tm_wrt_tm n1 (a_UAbs rho1 b1)
  | degree_wrt_tm_a_App : forall n1 a1 rho1 b1,
    degree_tm_wrt_tm n1 a1 ->
    degree_tm_wrt_tm n1 b1 ->
    degree_tm_wrt_tm n1 (a_App a1 rho1 b1)
  | degree_wrt_tm_a_Fam : forall n1 F1,
    degree_tm_wrt_tm n1 (a_Fam F1)
  | degree_wrt_tm_a_Const : forall n1 T1,
    degree_tm_wrt_tm n1 (a_Const T1)
  | degree_wrt_tm_a_Pi : forall n1 rho1 A1 B1,
    degree_tm_wrt_tm n1 A1 ->
    degree_tm_wrt_tm (S n1) B1 ->
    degree_tm_wrt_tm n1 (a_Pi rho1 A1 B1)
  | degree_wrt_tm_a_Conv : forall n1 a1 g1,
    degree_tm_wrt_tm n1 a1 ->
    degree_co_wrt_tm n1 g1 ->
    degree_tm_wrt_tm n1 (a_Conv a1 g1)
  | degree_wrt_tm_a_CPi : forall n1 phi1 B1,
    degree_constraint_wrt_tm n1 phi1 ->
    degree_tm_wrt_tm n1 B1 ->
    degree_tm_wrt_tm n1 (a_CPi phi1 B1)
  | degree_wrt_tm_a_CAbs : forall n1 phi1 b1,
    degree_constraint_wrt_tm n1 phi1 ->
    degree_tm_wrt_tm n1 b1 ->
    degree_tm_wrt_tm n1 (a_CAbs phi1 b1)
  | degree_wrt_tm_a_UCAbs : forall n1 b1,
    degree_tm_wrt_tm n1 b1 ->
    degree_tm_wrt_tm n1 (a_UCAbs b1)
  | degree_wrt_tm_a_CApp : forall n1 a1 g1,
    degree_tm_wrt_tm n1 a1 ->
    degree_co_wrt_tm n1 g1 ->
    degree_tm_wrt_tm n1 (a_CApp a1 g1)
  | degree_wrt_tm_a_Bullet : forall n1,
    degree_tm_wrt_tm n1 (a_Bullet)
  | degree_wrt_tm_a_DataCon : forall n1 K1,
    degree_tm_wrt_tm n1 (a_DataCon K1)
  | degree_wrt_tm_a_Case : forall n1 a1 brs1,
    degree_tm_wrt_tm n1 a1 ->
    degree_brs_wrt_tm n1 brs1 ->
    degree_tm_wrt_tm n1 (a_Case a1 brs1)

with degree_brs_wrt_tm : nat -> brs -> Prop :=
  | degree_wrt_tm_br_None : forall n1,
    degree_brs_wrt_tm n1 (br_None)
  | degree_wrt_tm_br_One : forall n1 K1 a1 brs1,
    degree_tm_wrt_tm n1 a1 ->
    degree_brs_wrt_tm n1 brs1 ->
    degree_brs_wrt_tm n1 (br_One K1 a1 brs1)

with degree_co_wrt_tm : nat -> co -> Prop :=
  | degree_wrt_tm_g_Triv : forall n1,
    degree_co_wrt_tm n1 (g_Triv)
  | degree_wrt_tm_g_Var_f : forall n1 c1,
    degree_co_wrt_tm n1 (g_Var_f c1)
  | degree_wrt_tm_g_Var_b : forall n1 n2,
    degree_co_wrt_tm n1 (g_Var_b n2)
  | degree_wrt_tm_g_Beta : forall n1 a1 b1,
    degree_tm_wrt_tm n1 a1 ->
    degree_tm_wrt_tm n1 b1 ->
    degree_co_wrt_tm n1 (g_Beta a1 b1)
  | degree_wrt_tm_g_Refl : forall n1 a1,
    degree_tm_wrt_tm n1 a1 ->
    degree_co_wrt_tm n1 (g_Refl a1)
  | degree_wrt_tm_g_Refl2 : forall n1 a1 b1 g1,
    degree_tm_wrt_tm n1 a1 ->
    degree_tm_wrt_tm n1 b1 ->
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 (g_Refl2 a1 b1 g1)
  | degree_wrt_tm_g_Sym : forall n1 g1,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 (g_Sym g1)
  | degree_wrt_tm_g_Trans : forall n1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_Trans g1 g2)
  | degree_wrt_tm_g_PiCong : forall n1 rho1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm (S n1) g2 ->
    degree_co_wrt_tm n1 (g_PiCong rho1 g1 g2)
  | degree_wrt_tm_g_AbsCong : forall n1 rho1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm (S n1) g2 ->
    degree_co_wrt_tm n1 (g_AbsCong rho1 g1 g2)
  | degree_wrt_tm_g_AppCong : forall n1 g1 rho1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_AppCong g1 rho1 g2)
  | degree_wrt_tm_g_PiFst : forall n1 g1,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 (g_PiFst g1)
  | degree_wrt_tm_g_CPiFst : forall n1 g1,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 (g_CPiFst g1)
  | degree_wrt_tm_g_IsoSnd : forall n1 g1,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 (g_IsoSnd g1)
  | degree_wrt_tm_g_PiSnd : forall n1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_PiSnd g1 g2)
  | degree_wrt_tm_g_CPiCong : forall n1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_CPiCong g1 g2)
  | degree_wrt_tm_g_CAbsCong : forall n1 g1 g2 g3,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 g3 ->
    degree_co_wrt_tm n1 (g_CAbsCong g1 g2 g3)
  | degree_wrt_tm_g_CAppCong : forall n1 g1 g2 g3,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 g3 ->
    degree_co_wrt_tm n1 (g_CAppCong g1 g2 g3)
  | degree_wrt_tm_g_CPiSnd : forall n1 g1 g2 g3,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 g3 ->
    degree_co_wrt_tm n1 (g_CPiSnd g1 g2 g3)
  | degree_wrt_tm_g_Cast : forall n1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_Cast g1 g2)
  | degree_wrt_tm_g_EqCong : forall n1 g1 A1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_tm_wrt_tm n1 A1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_EqCong g1 A1 g2)
  | degree_wrt_tm_g_IsoConv : forall n1 phi1 phi2 g1,
    degree_constraint_wrt_tm n1 phi1 ->
    degree_constraint_wrt_tm n1 phi2 ->
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 (g_IsoConv phi1 phi2 g1)
  | degree_wrt_tm_g_Eta : forall n1 a1,
    degree_tm_wrt_tm n1 a1 ->
    degree_co_wrt_tm n1 (g_Eta a1)
  | degree_wrt_tm_g_Left : forall n1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_Left g1 g2)
  | degree_wrt_tm_g_Right : forall n1 g1 g2,
    degree_co_wrt_tm n1 g1 ->
    degree_co_wrt_tm n1 g2 ->
    degree_co_wrt_tm n1 (g_Right g1 g2)

with degree_constraint_wrt_tm : nat -> constraint -> Prop :=
  | degree_wrt_tm_Eq : forall n1 a1 b1 A1,
    degree_tm_wrt_tm n1 a1 ->
    degree_tm_wrt_tm n1 b1 ->
    degree_tm_wrt_tm n1 A1 ->
    degree_constraint_wrt_tm n1 (Eq a1 b1 A1).

Inductive degree_tm_wrt_co : nat -> tm -> Prop :=
  | degree_wrt_co_a_Star : forall n1,
    degree_tm_wrt_co n1 (a_Star)
  | degree_wrt_co_a_Var_f : forall n1 x1,
    degree_tm_wrt_co n1 (a_Var_f x1)
  | degree_wrt_co_a_Var_b : forall n1 n2,
    degree_tm_wrt_co n1 (a_Var_b n2)
  | degree_wrt_co_a_Abs : forall n1 rho1 A1 b1,
    degree_tm_wrt_co n1 A1 ->
    degree_tm_wrt_co n1 b1 ->
    degree_tm_wrt_co n1 (a_Abs rho1 A1 b1)
  | degree_wrt_co_a_UAbs : forall n1 rho1 b1,
    degree_tm_wrt_co n1 b1 ->
    degree_tm_wrt_co n1 (a_UAbs rho1 b1)
  | degree_wrt_co_a_App : forall n1 a1 rho1 b1,
    degree_tm_wrt_co n1 a1 ->
    degree_tm_wrt_co n1 b1 ->
    degree_tm_wrt_co n1 (a_App a1 rho1 b1)
  | degree_wrt_co_a_Fam : forall n1 F1,
    degree_tm_wrt_co n1 (a_Fam F1)
  | degree_wrt_co_a_Const : forall n1 T1,
    degree_tm_wrt_co n1 (a_Const T1)
  | degree_wrt_co_a_Pi : forall n1 rho1 A1 B1,
    degree_tm_wrt_co n1 A1 ->
    degree_tm_wrt_co n1 B1 ->
    degree_tm_wrt_co n1 (a_Pi rho1 A1 B1)
  | degree_wrt_co_a_Conv : forall n1 a1 g1,
    degree_tm_wrt_co n1 a1 ->
    degree_co_wrt_co n1 g1 ->
    degree_tm_wrt_co n1 (a_Conv a1 g1)
  | degree_wrt_co_a_CPi : forall n1 phi1 B1,
    degree_constraint_wrt_co n1 phi1 ->
    degree_tm_wrt_co (S n1) B1 ->
    degree_tm_wrt_co n1 (a_CPi phi1 B1)
  | degree_wrt_co_a_CAbs : forall n1 phi1 b1,
    degree_constraint_wrt_co n1 phi1 ->
    degree_tm_wrt_co (S n1) b1 ->
    degree_tm_wrt_co n1 (a_CAbs phi1 b1)
  | degree_wrt_co_a_UCAbs : forall n1 b1,
    degree_tm_wrt_co (S n1) b1 ->
    degree_tm_wrt_co n1 (a_UCAbs b1)
  | degree_wrt_co_a_CApp : forall n1 a1 g1,
    degree_tm_wrt_co n1 a1 ->
    degree_co_wrt_co n1 g1 ->
    degree_tm_wrt_co n1 (a_CApp a1 g1)
  | degree_wrt_co_a_Bullet : forall n1,
    degree_tm_wrt_co n1 (a_Bullet)
  | degree_wrt_co_a_DataCon : forall n1 K1,
    degree_tm_wrt_co n1 (a_DataCon K1)
  | degree_wrt_co_a_Case : forall n1 a1 brs1,
    degree_tm_wrt_co n1 a1 ->
    degree_brs_wrt_co n1 brs1 ->
    degree_tm_wrt_co n1 (a_Case a1 brs1)

with degree_brs_wrt_co : nat -> brs -> Prop :=
  | degree_wrt_co_br_None : forall n1,
    degree_brs_wrt_co n1 (br_None)
  | degree_wrt_co_br_One : forall n1 K1 a1 brs1,
    degree_tm_wrt_co n1 a1 ->
    degree_brs_wrt_co n1 brs1 ->
    degree_brs_wrt_co n1 (br_One K1 a1 brs1)

with degree_co_wrt_co : nat -> co -> Prop :=
  | degree_wrt_co_g_Triv : forall n1,
    degree_co_wrt_co n1 (g_Triv)
  | degree_wrt_co_g_Var_f : forall n1 c1,
    degree_co_wrt_co n1 (g_Var_f c1)
  | degree_wrt_co_g_Var_b : forall n1 n2,
    lt n2 n1 ->
    degree_co_wrt_co n1 (g_Var_b n2)
  | degree_wrt_co_g_Beta : forall n1 a1 b1,
    degree_tm_wrt_co n1 a1 ->
    degree_tm_wrt_co n1 b1 ->
    degree_co_wrt_co n1 (g_Beta a1 b1)
  | degree_wrt_co_g_Refl : forall n1 a1,
    degree_tm_wrt_co n1 a1 ->
    degree_co_wrt_co n1 (g_Refl a1)
  | degree_wrt_co_g_Refl2 : forall n1 a1 b1 g1,
    degree_tm_wrt_co n1 a1 ->
    degree_tm_wrt_co n1 b1 ->
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 (g_Refl2 a1 b1 g1)
  | degree_wrt_co_g_Sym : forall n1 g1,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 (g_Sym g1)
  | degree_wrt_co_g_Trans : forall n1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_Trans g1 g2)
  | degree_wrt_co_g_PiCong : forall n1 rho1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_PiCong rho1 g1 g2)
  | degree_wrt_co_g_AbsCong : forall n1 rho1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_AbsCong rho1 g1 g2)
  | degree_wrt_co_g_AppCong : forall n1 g1 rho1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_AppCong g1 rho1 g2)
  | degree_wrt_co_g_PiFst : forall n1 g1,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 (g_PiFst g1)
  | degree_wrt_co_g_CPiFst : forall n1 g1,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 (g_CPiFst g1)
  | degree_wrt_co_g_IsoSnd : forall n1 g1,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 (g_IsoSnd g1)
  | degree_wrt_co_g_PiSnd : forall n1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_PiSnd g1 g2)
  | degree_wrt_co_g_CPiCong : forall n1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co (S n1) g2 ->
    degree_co_wrt_co n1 (g_CPiCong g1 g2)
  | degree_wrt_co_g_CAbsCong : forall n1 g1 g2 g3,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co (S n1) g2 ->
    degree_co_wrt_co n1 g3 ->
    degree_co_wrt_co n1 (g_CAbsCong g1 g2 g3)
  | degree_wrt_co_g_CAppCong : forall n1 g1 g2 g3,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 g3 ->
    degree_co_wrt_co n1 (g_CAppCong g1 g2 g3)
  | degree_wrt_co_g_CPiSnd : forall n1 g1 g2 g3,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 g3 ->
    degree_co_wrt_co n1 (g_CPiSnd g1 g2 g3)
  | degree_wrt_co_g_Cast : forall n1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_Cast g1 g2)
  | degree_wrt_co_g_EqCong : forall n1 g1 A1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_tm_wrt_co n1 A1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_EqCong g1 A1 g2)
  | degree_wrt_co_g_IsoConv : forall n1 phi1 phi2 g1,
    degree_constraint_wrt_co n1 phi1 ->
    degree_constraint_wrt_co n1 phi2 ->
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 (g_IsoConv phi1 phi2 g1)
  | degree_wrt_co_g_Eta : forall n1 a1,
    degree_tm_wrt_co n1 a1 ->
    degree_co_wrt_co n1 (g_Eta a1)
  | degree_wrt_co_g_Left : forall n1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_Left g1 g2)
  | degree_wrt_co_g_Right : forall n1 g1 g2,
    degree_co_wrt_co n1 g1 ->
    degree_co_wrt_co n1 g2 ->
    degree_co_wrt_co n1 (g_Right g1 g2)

with degree_constraint_wrt_co : nat -> constraint -> Prop :=
  | degree_wrt_co_Eq : forall n1 a1 b1 A1,
    degree_tm_wrt_co n1 a1 ->
    degree_tm_wrt_co n1 b1 ->
    degree_tm_wrt_co n1 A1 ->
    degree_constraint_wrt_co n1 (Eq a1 b1 A1).

Scheme degree_tm_wrt_tm_ind' := Induction for degree_tm_wrt_tm Sort Prop
  with degree_brs_wrt_tm_ind' := Induction for degree_brs_wrt_tm Sort Prop
  with degree_co_wrt_tm_ind' := Induction for degree_co_wrt_tm Sort Prop
  with degree_constraint_wrt_tm_ind' := Induction for degree_constraint_wrt_tm Sort Prop.

Definition degree_tm_wrt_tm_degree_brs_wrt_tm_degree_co_wrt_tm_degree_constraint_wrt_tm_mutind :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49 =>
  (conj (degree_tm_wrt_tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  ((conj (degree_brs_wrt_tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  ((conj (degree_co_wrt_tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  (degree_constraint_wrt_tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)))))).

Scheme degree_tm_wrt_co_ind' := Induction for degree_tm_wrt_co Sort Prop
  with degree_brs_wrt_co_ind' := Induction for degree_brs_wrt_co Sort Prop
  with degree_co_wrt_co_ind' := Induction for degree_co_wrt_co Sort Prop
  with degree_constraint_wrt_co_ind' := Induction for degree_constraint_wrt_co Sort Prop.

Definition degree_tm_wrt_co_degree_brs_wrt_co_degree_co_wrt_co_degree_constraint_wrt_co_mutind :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49 =>
  (conj (degree_tm_wrt_co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  ((conj (degree_brs_wrt_co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  ((conj (degree_co_wrt_co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)
  (degree_constraint_wrt_co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 H48 H49)))))).

Hint Constructors degree_tm_wrt_tm : core lngen.

Hint Constructors degree_brs_wrt_tm : core lngen.

Hint Constructors degree_co_wrt_tm : core lngen.

Hint Constructors degree_constraint_wrt_tm : core lngen.

Hint Constructors degree_tm_wrt_co : core lngen.

Hint Constructors degree_brs_wrt_co : core lngen.

Hint Constructors degree_co_wrt_co : core lngen.

Hint Constructors degree_constraint_wrt_co : core lngen.

Inductive lc_set_tm : tm -> Set :=
  | lc_set_a_Star :
    lc_set_tm (a_Star)
  | lc_set_a_Var_f : forall x1,
    lc_set_tm (a_Var_f x1)
  | lc_set_a_Abs : forall rho1 A1 b1,
    lc_set_tm A1 ->
    (forall x1 : tmvar, lc_set_tm (open_tm_wrt_tm b1 (a_Var_f x1))) ->
    lc_set_tm (a_Abs rho1 A1 b1)
  | lc_set_a_UAbs : forall rho1 b1,
    (forall x1 : tmvar, lc_set_tm (open_tm_wrt_tm b1 (a_Var_f x1))) ->
    lc_set_tm (a_UAbs rho1 b1)
  | lc_set_a_App : forall a1 rho1 b1,
    lc_set_tm a1 ->
    lc_set_tm b1 ->
    lc_set_tm (a_App a1 rho1 b1)
  | lc_set_a_Fam : forall F1,
    lc_set_tm (a_Fam F1)
  | lc_set_a_Const : forall T1,
    lc_set_tm (a_Const T1)
  | lc_set_a_Pi : forall rho1 A1 B1,
    lc_set_tm A1 ->
    (forall x1 : tmvar, lc_set_tm (open_tm_wrt_tm B1 (a_Var_f x1))) ->
    lc_set_tm (a_Pi rho1 A1 B1)
  | lc_set_a_Conv : forall a1 g1,
    lc_set_tm a1 ->
    lc_set_co g1 ->
    lc_set_tm (a_Conv a1 g1)
  | lc_set_a_CPi : forall phi1 B1,
    lc_set_constraint phi1 ->
    (forall c1 : covar, lc_set_tm (open_tm_wrt_co B1 (g_Var_f c1))) ->
    lc_set_tm (a_CPi phi1 B1)
  | lc_set_a_CAbs : forall phi1 b1,
    lc_set_constraint phi1 ->
    (forall c1 : covar, lc_set_tm (open_tm_wrt_co b1 (g_Var_f c1))) ->
    lc_set_tm (a_CAbs phi1 b1)
  | lc_set_a_UCAbs : forall b1,
    (forall c1 : covar, lc_set_tm (open_tm_wrt_co b1 (g_Var_f c1))) ->
    lc_set_tm (a_UCAbs b1)
  | lc_set_a_CApp : forall a1 g1,
    lc_set_tm a1 ->
    lc_set_co g1 ->
    lc_set_tm (a_CApp a1 g1)
  | lc_set_a_Bullet :
    lc_set_tm (a_Bullet)
  | lc_set_a_DataCon : forall K1,
    lc_set_tm (a_DataCon K1)
  | lc_set_a_Case : forall a1 brs1,
    lc_set_tm a1 ->
    lc_set_brs brs1 ->
    lc_set_tm (a_Case a1 brs1)

with lc_set_brs : brs -> Set :=
  | lc_set_br_None :
    lc_set_brs (br_None)
  | lc_set_br_One : forall K1 a1 brs1,
    lc_set_tm a1 ->
    lc_set_brs brs1 ->
    lc_set_brs (br_One K1 a1 brs1)

with lc_set_co : co -> Set :=
  | lc_set_g_Triv :
    lc_set_co (g_Triv)
  | lc_set_g_Var_f : forall c1,
    lc_set_co (g_Var_f c1)
  | lc_set_g_Beta : forall a1 b1,
    lc_set_tm a1 ->
    lc_set_tm b1 ->
    lc_set_co (g_Beta a1 b1)
  | lc_set_g_Refl : forall a1,
    lc_set_tm a1 ->
    lc_set_co (g_Refl a1)
  | lc_set_g_Refl2 : forall a1 b1 g1,
    lc_set_tm a1 ->
    lc_set_tm b1 ->
    lc_set_co g1 ->
    lc_set_co (g_Refl2 a1 b1 g1)
  | lc_set_g_Sym : forall g1,
    lc_set_co g1 ->
    lc_set_co (g_Sym g1)
  | lc_set_g_Trans : forall g1 g2,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co (g_Trans g1 g2)
  | lc_set_g_PiCong : forall rho1 g1 g2,
    lc_set_co g1 ->
    (forall x1 : tmvar, lc_set_co (open_co_wrt_tm g2 (a_Var_f x1))) ->
    lc_set_co (g_PiCong rho1 g1 g2)
  | lc_set_g_AbsCong : forall rho1 g1 g2,
    lc_set_co g1 ->
    (forall x1 : tmvar, lc_set_co (open_co_wrt_tm g2 (a_Var_f x1))) ->
    lc_set_co (g_AbsCong rho1 g1 g2)
  | lc_set_g_AppCong : forall g1 rho1 g2,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co (g_AppCong g1 rho1 g2)
  | lc_set_g_PiFst : forall g1,
    lc_set_co g1 ->
    lc_set_co (g_PiFst g1)
  | lc_set_g_CPiFst : forall g1,
    lc_set_co g1 ->
    lc_set_co (g_CPiFst g1)
  | lc_set_g_IsoSnd : forall g1,
    lc_set_co g1 ->
    lc_set_co (g_IsoSnd g1)
  | lc_set_g_PiSnd : forall g1 g2,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co (g_PiSnd g1 g2)
  | lc_set_g_CPiCong : forall g1 g2,
    lc_set_co g1 ->
    (forall c1 : covar, lc_set_co (open_co_wrt_co g2 (g_Var_f c1))) ->
    lc_set_co (g_CPiCong g1 g2)
  | lc_set_g_CAbsCong : forall g1 g2 g3,
    lc_set_co g1 ->
    (forall c1 : covar, lc_set_co (open_co_wrt_co g2 (g_Var_f c1))) ->
    lc_set_co g3 ->
    lc_set_co (g_CAbsCong g1 g2 g3)
  | lc_set_g_CAppCong : forall g1 g2 g3,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co g3 ->
    lc_set_co (g_CAppCong g1 g2 g3)
  | lc_set_g_CPiSnd : forall g1 g2 g3,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co g3 ->
    lc_set_co (g_CPiSnd g1 g2 g3)
  | lc_set_g_Cast : forall g1 g2,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co (g_Cast g1 g2)
  | lc_set_g_EqCong : forall g1 A1 g2,
    lc_set_co g1 ->
    lc_set_tm A1 ->
    lc_set_co g2 ->
    lc_set_co (g_EqCong g1 A1 g2)
  | lc_set_g_IsoConv : forall phi1 phi2 g1,
    lc_set_constraint phi1 ->
    lc_set_constraint phi2 ->
    lc_set_co g1 ->
    lc_set_co (g_IsoConv phi1 phi2 g1)
  | lc_set_g_Eta : forall a1,
    lc_set_tm a1 ->
    lc_set_co (g_Eta a1)
  | lc_set_g_Left : forall g1 g2,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co (g_Left g1 g2)
  | lc_set_g_Right : forall g1 g2,
    lc_set_co g1 ->
    lc_set_co g2 ->
    lc_set_co (g_Right g1 g2)

with lc_set_constraint : constraint -> Set :=
  | lc_set_Eq : forall a1 b1 A1,
    lc_set_tm a1 ->
    lc_set_tm b1 ->
    lc_set_tm A1 ->
    lc_set_constraint (Eq a1 b1 A1).

Scheme lc_tm_ind' := Induction for lc_tm Sort Prop
  with lc_brs_ind' := Induction for lc_brs Sort Prop
  with lc_co_ind' := Induction for lc_co Sort Prop
  with lc_constraint_ind' := Induction for lc_constraint Sort Prop.

Definition lc_tm_lc_brs_lc_co_lc_constraint_mutind :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 =>
  (conj (lc_tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  ((conj (lc_brs_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  ((conj (lc_co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  (lc_constraint_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)))))).

Scheme lc_set_tm_ind' := Induction for lc_set_tm Sort Prop
  with lc_set_brs_ind' := Induction for lc_set_brs Sort Prop
  with lc_set_co_ind' := Induction for lc_set_co Sort Prop
  with lc_set_constraint_ind' := Induction for lc_set_constraint Sort Prop.

Definition lc_set_tm_lc_set_brs_lc_set_co_lc_set_constraint_mutind :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 =>
  (conj (lc_set_tm_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  ((conj (lc_set_brs_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  ((conj (lc_set_co_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  (lc_set_constraint_ind' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)))))).

Scheme lc_set_tm_rec' := Induction for lc_set_tm Sort Set
  with lc_set_brs_rec' := Induction for lc_set_brs Sort Set
  with lc_set_co_rec' := Induction for lc_set_co Sort Set
  with lc_set_constraint_rec' := Induction for lc_set_constraint Sort Set.

Definition lc_set_tm_lc_set_brs_lc_set_co_lc_set_constraint_mutrec :=
  fun H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47 =>
  (pair ((pair ((pair (lc_set_tm_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)
  (lc_set_brs_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)))
  (lc_set_co_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)))
  (lc_set_constraint_rec' H1 H2 H3 H4 H5 H6 H7 H8 H9 H10 H11 H12 H13 H14 H15 H16 H17 H18 H19 H20 H21 H22 H23 H24 H25 H26 H27 H28 H29 H30 H31 H32 H33 H34 H35 H36 H37 H38 H39 H40 H41 H42 H43 H44 H45 H46 H47)).

Hint Constructors lc_tm : core lngen.

Hint Constructors lc_brs : core lngen.

Hint Constructors lc_co : core lngen.

Hint Constructors lc_constraint : core lngen.

Hint Constructors lc_set_tm : core lngen.

Hint Constructors lc_set_brs : core lngen.

Hint Constructors lc_set_co : core lngen.

Hint Constructors lc_set_constraint : core lngen.

Definition body_tm_wrt_tm a1 := forall x1, lc_tm (open_tm_wrt_tm a1 (a_Var_f x1)).

Definition body_brs_wrt_tm brs1 := forall x1, lc_brs (open_brs_wrt_tm brs1 (a_Var_f x1)).

Definition body_co_wrt_tm g1 := forall x1, lc_co (open_co_wrt_tm g1 (a_Var_f x1)).

Definition body_constraint_wrt_tm phi1 := forall x1, lc_constraint (open_constraint_wrt_tm phi1 (a_Var_f x1)).

Definition body_tm_wrt_co a1 := forall c1, lc_tm (open_tm_wrt_co a1 (g_Var_f c1)).

Definition body_brs_wrt_co brs1 := forall c1, lc_brs (open_brs_wrt_co brs1 (g_Var_f c1)).

Definition body_co_wrt_co g1 := forall c1, lc_co (open_co_wrt_co g1 (g_Var_f c1)).

Definition body_constraint_wrt_co phi1 := forall c1, lc_constraint (open_constraint_wrt_co phi1 (g_Var_f c1)).

Hint Unfold body_tm_wrt_tm.

Hint Unfold body_brs_wrt_tm.

Hint Unfold body_co_wrt_tm.

Hint Unfold body_constraint_wrt_tm.

Hint Unfold body_tm_wrt_co.

Hint Unfold body_brs_wrt_co.

Hint Unfold body_co_wrt_co.

Hint Unfold body_constraint_wrt_co.

Hint Resolve @plus_le_compat : lngen.

Ltac default_case_split ::=
  first
    [ progress destruct_notin
    | progress destruct_sum
    | progress safe_f_equal
    ].

Ltac default_auto ::= auto with arith lngen; tauto.
Ltac default_autorewrite ::= fail.

Lemma size_relflag_min_mutual :
(forall rho1, 1 <= size_relflag rho1).

Lemma size_relflag_min :
forall rho1, 1 <= size_relflag rho1.

Hint Resolve size_relflag_min : lngen.

Lemma size_tm_min_size_brs_min_size_co_min_size_constraint_min_mutual :
(forall a1, 1 <= size_tm a1) /\
(forall brs1, 1 <= size_brs brs1) /\
(forall g1, 1 <= size_co g1) /\
(forall phi1, 1 <= size_constraint phi1).

Lemma size_tm_min :
forall a1, 1 <= size_tm a1.

Hint Resolve size_tm_min : lngen.

Lemma size_brs_min :
forall brs1, 1 <= size_brs brs1.

Hint Resolve size_brs_min : lngen.

Lemma size_co_min :
forall g1, 1 <= size_co g1.

Hint Resolve size_co_min : lngen.

Lemma size_constraint_min :
forall phi1, 1 <= size_constraint phi1.

Hint Resolve size_constraint_min : lngen.

Lemma size_tm_close_tm_wrt_tm_rec_size_brs_close_brs_wrt_tm_rec_size_co_close_co_wrt_tm_rec_size_constraint_close_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1,
  size_tm (close_tm_wrt_tm_rec n1 x1 a1) = size_tm a1) /\
(forall brs1 x1 n1,
  size_brs (close_brs_wrt_tm_rec n1 x1 brs1) = size_brs brs1) /\
(forall g1 x1 n1,
  size_co (close_co_wrt_tm_rec n1 x1 g1) = size_co g1) /\
(forall phi1 x1 n1,
  size_constraint (close_constraint_wrt_tm_rec n1 x1 phi1) = size_constraint phi1).

Lemma size_tm_close_tm_wrt_tm_rec :
forall a1 x1 n1,
  size_tm (close_tm_wrt_tm_rec n1 x1 a1) = size_tm a1.

Hint Resolve size_tm_close_tm_wrt_tm_rec : lngen.
Hint Rewrite size_tm_close_tm_wrt_tm_rec using solve [auto] : lngen.

Lemma size_brs_close_brs_wrt_tm_rec :
forall brs1 x1 n1,
  size_brs (close_brs_wrt_tm_rec n1 x1 brs1) = size_brs brs1.

Hint Resolve size_brs_close_brs_wrt_tm_rec : lngen.
Hint Rewrite size_brs_close_brs_wrt_tm_rec using solve [auto] : lngen.

Lemma size_co_close_co_wrt_tm_rec :
forall g1 x1 n1,
  size_co (close_co_wrt_tm_rec n1 x1 g1) = size_co g1.

Hint Resolve size_co_close_co_wrt_tm_rec : lngen.
Hint Rewrite size_co_close_co_wrt_tm_rec using solve [auto] : lngen.

Lemma size_constraint_close_constraint_wrt_tm_rec :
forall phi1 x1 n1,
  size_constraint (close_constraint_wrt_tm_rec n1 x1 phi1) = size_constraint phi1.

Hint Resolve size_constraint_close_constraint_wrt_tm_rec : lngen.
Hint Rewrite size_constraint_close_constraint_wrt_tm_rec using solve [auto] : lngen.

Lemma size_tm_close_tm_wrt_co_rec_size_brs_close_brs_wrt_co_rec_size_co_close_co_wrt_co_rec_size_constraint_close_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1,
  size_tm (close_tm_wrt_co_rec n1 c1 a1) = size_tm a1) /\
(forall brs1 c1 n1,
  size_brs (close_brs_wrt_co_rec n1 c1 brs1) = size_brs brs1) /\
(forall g1 c1 n1,
  size_co (close_co_wrt_co_rec n1 c1 g1) = size_co g1) /\
(forall phi1 c1 n1,
  size_constraint (close_constraint_wrt_co_rec n1 c1 phi1) = size_constraint phi1).

Lemma size_tm_close_tm_wrt_co_rec :
forall a1 c1 n1,
  size_tm (close_tm_wrt_co_rec n1 c1 a1) = size_tm a1.

Hint Resolve size_tm_close_tm_wrt_co_rec : lngen.
Hint Rewrite size_tm_close_tm_wrt_co_rec using solve [auto] : lngen.

Lemma size_brs_close_brs_wrt_co_rec :
forall brs1 c1 n1,
  size_brs (close_brs_wrt_co_rec n1 c1 brs1) = size_brs brs1.

Hint Resolve size_brs_close_brs_wrt_co_rec : lngen.
Hint Rewrite size_brs_close_brs_wrt_co_rec using solve [auto] : lngen.

Lemma size_co_close_co_wrt_co_rec :
forall g1 c1 n1,
  size_co (close_co_wrt_co_rec n1 c1 g1) = size_co g1.

Hint Resolve size_co_close_co_wrt_co_rec : lngen.
Hint Rewrite size_co_close_co_wrt_co_rec using solve [auto] : lngen.

Lemma size_constraint_close_constraint_wrt_co_rec :
forall phi1 c1 n1,
  size_constraint (close_constraint_wrt_co_rec n1 c1 phi1) = size_constraint phi1.

Hint Resolve size_constraint_close_constraint_wrt_co_rec : lngen.
Hint Rewrite size_constraint_close_constraint_wrt_co_rec using solve [auto] : lngen.

Lemma size_tm_close_tm_wrt_tm :
forall a1 x1,
  size_tm (close_tm_wrt_tm x1 a1) = size_tm a1.

Hint Resolve size_tm_close_tm_wrt_tm : lngen.
Hint Rewrite size_tm_close_tm_wrt_tm using solve [auto] : lngen.

Lemma size_brs_close_brs_wrt_tm :
forall brs1 x1,
  size_brs (close_brs_wrt_tm x1 brs1) = size_brs brs1.

Hint Resolve size_brs_close_brs_wrt_tm : lngen.
Hint Rewrite size_brs_close_brs_wrt_tm using solve [auto] : lngen.

Lemma size_co_close_co_wrt_tm :
forall g1 x1,
  size_co (close_co_wrt_tm x1 g1) = size_co g1.

Hint Resolve size_co_close_co_wrt_tm : lngen.
Hint Rewrite size_co_close_co_wrt_tm using solve [auto] : lngen.

Lemma size_constraint_close_constraint_wrt_tm :
forall phi1 x1,
  size_constraint (close_constraint_wrt_tm x1 phi1) = size_constraint phi1.

Hint Resolve size_constraint_close_constraint_wrt_tm : lngen.
Hint Rewrite size_constraint_close_constraint_wrt_tm using solve [auto] : lngen.

Lemma size_tm_close_tm_wrt_co :
forall a1 c1,
  size_tm (close_tm_wrt_co c1 a1) = size_tm a1.

Hint Resolve size_tm_close_tm_wrt_co : lngen.
Hint Rewrite size_tm_close_tm_wrt_co using solve [auto] : lngen.

Lemma size_brs_close_brs_wrt_co :
forall brs1 c1,
  size_brs (close_brs_wrt_co c1 brs1) = size_brs brs1.

Hint Resolve size_brs_close_brs_wrt_co : lngen.
Hint Rewrite size_brs_close_brs_wrt_co using solve [auto] : lngen.

Lemma size_co_close_co_wrt_co :
forall g1 c1,
  size_co (close_co_wrt_co c1 g1) = size_co g1.

Hint Resolve size_co_close_co_wrt_co : lngen.
Hint Rewrite size_co_close_co_wrt_co using solve [auto] : lngen.

Lemma size_constraint_close_constraint_wrt_co :
forall phi1 c1,
  size_constraint (close_constraint_wrt_co c1 phi1) = size_constraint phi1.

Hint Resolve size_constraint_close_constraint_wrt_co : lngen.
Hint Rewrite size_constraint_close_constraint_wrt_co using solve [auto] : lngen.

Lemma size_tm_open_tm_wrt_tm_rec_size_brs_open_brs_wrt_tm_rec_size_co_open_co_wrt_tm_rec_size_constraint_open_constraint_wrt_tm_rec_mutual :
(forall a1 a2 n1,
  size_tm a1 <= size_tm (open_tm_wrt_tm_rec n1 a2 a1)) /\
(forall brs1 a1 n1,
  size_brs brs1 <= size_brs (open_brs_wrt_tm_rec n1 a1 brs1)) /\
(forall g1 a1 n1,
  size_co g1 <= size_co (open_co_wrt_tm_rec n1 a1 g1)) /\
(forall phi1 a1 n1,
  size_constraint phi1 <= size_constraint (open_constraint_wrt_tm_rec n1 a1 phi1)).

Lemma size_tm_open_tm_wrt_tm_rec :
forall a1 a2 n1,
  size_tm a1 <= size_tm (open_tm_wrt_tm_rec n1 a2 a1).

Hint Resolve size_tm_open_tm_wrt_tm_rec : lngen.

Lemma size_brs_open_brs_wrt_tm_rec :
forall brs1 a1 n1,
  size_brs brs1 <= size_brs (open_brs_wrt_tm_rec n1 a1 brs1).

Hint Resolve size_brs_open_brs_wrt_tm_rec : lngen.

Lemma size_co_open_co_wrt_tm_rec :
forall g1 a1 n1,
  size_co g1 <= size_co (open_co_wrt_tm_rec n1 a1 g1).

Hint Resolve size_co_open_co_wrt_tm_rec : lngen.

Lemma size_constraint_open_constraint_wrt_tm_rec :
forall phi1 a1 n1,
  size_constraint phi1 <= size_constraint (open_constraint_wrt_tm_rec n1 a1 phi1).

Hint Resolve size_constraint_open_constraint_wrt_tm_rec : lngen.

Lemma size_tm_open_tm_wrt_co_rec_size_brs_open_brs_wrt_co_rec_size_co_open_co_wrt_co_rec_size_constraint_open_constraint_wrt_co_rec_mutual :
(forall a1 g1 n1,
  size_tm a1 <= size_tm (open_tm_wrt_co_rec n1 g1 a1)) /\
(forall brs1 g1 n1,
  size_brs brs1 <= size_brs (open_brs_wrt_co_rec n1 g1 brs1)) /\
(forall g1 g2 n1,
  size_co g1 <= size_co (open_co_wrt_co_rec n1 g2 g1)) /\
(forall phi1 g1 n1,
  size_constraint phi1 <= size_constraint (open_constraint_wrt_co_rec n1 g1 phi1)).

Lemma size_tm_open_tm_wrt_co_rec :
forall a1 g1 n1,
  size_tm a1 <= size_tm (open_tm_wrt_co_rec n1 g1 a1).

Hint Resolve size_tm_open_tm_wrt_co_rec : lngen.

Lemma size_brs_open_brs_wrt_co_rec :
forall brs1 g1 n1,
  size_brs brs1 <= size_brs (open_brs_wrt_co_rec n1 g1 brs1).

Hint Resolve size_brs_open_brs_wrt_co_rec : lngen.

Lemma size_co_open_co_wrt_co_rec :
forall g1 g2 n1,
  size_co g1 <= size_co (open_co_wrt_co_rec n1 g2 g1).

Hint Resolve size_co_open_co_wrt_co_rec : lngen.

Lemma size_constraint_open_constraint_wrt_co_rec :
forall phi1 g1 n1,
  size_constraint phi1 <= size_constraint (open_constraint_wrt_co_rec n1 g1 phi1).

Hint Resolve size_constraint_open_constraint_wrt_co_rec : lngen.

Lemma size_tm_open_tm_wrt_tm :
forall a1 a2,
  size_tm a1 <= size_tm (open_tm_wrt_tm a1 a2).

Hint Resolve size_tm_open_tm_wrt_tm : lngen.

Lemma size_brs_open_brs_wrt_tm :
forall brs1 a1,
  size_brs brs1 <= size_brs (open_brs_wrt_tm brs1 a1).

Hint Resolve size_brs_open_brs_wrt_tm : lngen.

Lemma size_co_open_co_wrt_tm :
forall g1 a1,
  size_co g1 <= size_co (open_co_wrt_tm g1 a1).

Hint Resolve size_co_open_co_wrt_tm : lngen.

Lemma size_constraint_open_constraint_wrt_tm :
forall phi1 a1,
  size_constraint phi1 <= size_constraint (open_constraint_wrt_tm phi1 a1).

Hint Resolve size_constraint_open_constraint_wrt_tm : lngen.

Lemma size_tm_open_tm_wrt_co :
forall a1 g1,
  size_tm a1 <= size_tm (open_tm_wrt_co a1 g1).

Hint Resolve size_tm_open_tm_wrt_co : lngen.

Lemma size_brs_open_brs_wrt_co :
forall brs1 g1,
  size_brs brs1 <= size_brs (open_brs_wrt_co brs1 g1).

Hint Resolve size_brs_open_brs_wrt_co : lngen.

Lemma size_co_open_co_wrt_co :
forall g1 g2,
  size_co g1 <= size_co (open_co_wrt_co g1 g2).

Hint Resolve size_co_open_co_wrt_co : lngen.

Lemma size_constraint_open_constraint_wrt_co :
forall phi1 g1,
  size_constraint phi1 <= size_constraint (open_constraint_wrt_co phi1 g1).

Hint Resolve size_constraint_open_constraint_wrt_co : lngen.

Lemma size_tm_open_tm_wrt_tm_rec_var_size_brs_open_brs_wrt_tm_rec_var_size_co_open_co_wrt_tm_rec_var_size_constraint_open_constraint_wrt_tm_rec_var_mutual :
(forall a1 x1 n1,
  size_tm (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1) = size_tm a1) /\
(forall brs1 x1 n1,
  size_brs (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1) = size_brs brs1) /\
(forall g1 x1 n1,
  size_co (open_co_wrt_tm_rec n1 (a_Var_f x1) g1) = size_co g1) /\
(forall phi1 x1 n1,
  size_constraint (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1) = size_constraint phi1).

Lemma size_tm_open_tm_wrt_tm_rec_var :
forall a1 x1 n1,
  size_tm (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1) = size_tm a1.

Hint Resolve size_tm_open_tm_wrt_tm_rec_var : lngen.
Hint Rewrite size_tm_open_tm_wrt_tm_rec_var using solve [auto] : lngen.

Lemma size_brs_open_brs_wrt_tm_rec_var :
forall brs1 x1 n1,
  size_brs (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1) = size_brs brs1.

Hint Resolve size_brs_open_brs_wrt_tm_rec_var : lngen.
Hint Rewrite size_brs_open_brs_wrt_tm_rec_var using solve [auto] : lngen.

Lemma size_co_open_co_wrt_tm_rec_var :
forall g1 x1 n1,
  size_co (open_co_wrt_tm_rec n1 (a_Var_f x1) g1) = size_co g1.

Hint Resolve size_co_open_co_wrt_tm_rec_var : lngen.
Hint Rewrite size_co_open_co_wrt_tm_rec_var using solve [auto] : lngen.

Lemma size_constraint_open_constraint_wrt_tm_rec_var :
forall phi1 x1 n1,
  size_constraint (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1) = size_constraint phi1.

Hint Resolve size_constraint_open_constraint_wrt_tm_rec_var : lngen.
Hint Rewrite size_constraint_open_constraint_wrt_tm_rec_var using solve [auto] : lngen.

Lemma size_tm_open_tm_wrt_co_rec_var_size_brs_open_brs_wrt_co_rec_var_size_co_open_co_wrt_co_rec_var_size_constraint_open_constraint_wrt_co_rec_var_mutual :
(forall a1 c1 n1,
  size_tm (open_tm_wrt_co_rec n1 (g_Var_f c1) a1) = size_tm a1) /\
(forall brs1 c1 n1,
  size_brs (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1) = size_brs brs1) /\
(forall g1 c1 n1,
  size_co (open_co_wrt_co_rec n1 (g_Var_f c1) g1) = size_co g1) /\
(forall phi1 c1 n1,
  size_constraint (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1) = size_constraint phi1).

Lemma size_tm_open_tm_wrt_co_rec_var :
forall a1 c1 n1,
  size_tm (open_tm_wrt_co_rec n1 (g_Var_f c1) a1) = size_tm a1.

Hint Resolve size_tm_open_tm_wrt_co_rec_var : lngen.
Hint Rewrite size_tm_open_tm_wrt_co_rec_var using solve [auto] : lngen.

Lemma size_brs_open_brs_wrt_co_rec_var :
forall brs1 c1 n1,
  size_brs (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1) = size_brs brs1.

Hint Resolve size_brs_open_brs_wrt_co_rec_var : lngen.
Hint Rewrite size_brs_open_brs_wrt_co_rec_var using solve [auto] : lngen.

Lemma size_co_open_co_wrt_co_rec_var :
forall g1 c1 n1,
  size_co (open_co_wrt_co_rec n1 (g_Var_f c1) g1) = size_co g1.

Hint Resolve size_co_open_co_wrt_co_rec_var : lngen.
Hint Rewrite size_co_open_co_wrt_co_rec_var using solve [auto] : lngen.

Lemma size_constraint_open_constraint_wrt_co_rec_var :
forall phi1 c1 n1,
  size_constraint (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1) = size_constraint phi1.

Hint Resolve size_constraint_open_constraint_wrt_co_rec_var : lngen.
Hint Rewrite size_constraint_open_constraint_wrt_co_rec_var using solve [auto] : lngen.

Lemma size_tm_open_tm_wrt_tm_var :
forall a1 x1,
  size_tm (open_tm_wrt_tm a1 (a_Var_f x1)) = size_tm a1.

Hint Resolve size_tm_open_tm_wrt_tm_var : lngen.
Hint Rewrite size_tm_open_tm_wrt_tm_var using solve [auto] : lngen.

Lemma size_brs_open_brs_wrt_tm_var :
forall brs1 x1,
  size_brs (open_brs_wrt_tm brs1 (a_Var_f x1)) = size_brs brs1.

Hint Resolve size_brs_open_brs_wrt_tm_var : lngen.
Hint Rewrite size_brs_open_brs_wrt_tm_var using solve [auto] : lngen.

Lemma size_co_open_co_wrt_tm_var :
forall g1 x1,
  size_co (open_co_wrt_tm g1 (a_Var_f x1)) = size_co g1.

Hint Resolve size_co_open_co_wrt_tm_var : lngen.
Hint Rewrite size_co_open_co_wrt_tm_var using solve [auto] : lngen.

Lemma size_constraint_open_constraint_wrt_tm_var :
forall phi1 x1,
  size_constraint (open_constraint_wrt_tm phi1 (a_Var_f x1)) = size_constraint phi1.

Hint Resolve size_constraint_open_constraint_wrt_tm_var : lngen.
Hint Rewrite size_constraint_open_constraint_wrt_tm_var using solve [auto] : lngen.

Lemma size_tm_open_tm_wrt_co_var :
forall a1 c1,
  size_tm (open_tm_wrt_co a1 (g_Var_f c1)) = size_tm a1.

Hint Resolve size_tm_open_tm_wrt_co_var : lngen.
Hint Rewrite size_tm_open_tm_wrt_co_var using solve [auto] : lngen.

Lemma size_brs_open_brs_wrt_co_var :
forall brs1 c1,
  size_brs (open_brs_wrt_co brs1 (g_Var_f c1)) = size_brs brs1.

Hint Resolve size_brs_open_brs_wrt_co_var : lngen.
Hint Rewrite size_brs_open_brs_wrt_co_var using solve [auto] : lngen.

Lemma size_co_open_co_wrt_co_var :
forall g1 c1,
  size_co (open_co_wrt_co g1 (g_Var_f c1)) = size_co g1.

Hint Resolve size_co_open_co_wrt_co_var : lngen.
Hint Rewrite size_co_open_co_wrt_co_var using solve [auto] : lngen.

Lemma size_constraint_open_constraint_wrt_co_var :
forall phi1 c1,
  size_constraint (open_constraint_wrt_co phi1 (g_Var_f c1)) = size_constraint phi1.

Hint Resolve size_constraint_open_constraint_wrt_co_var : lngen.
Hint Rewrite size_constraint_open_constraint_wrt_co_var using solve [auto] : lngen.

Ltac default_auto ::= auto with lngen; tauto.
Ltac default_autorewrite ::= fail.

Lemma degree_tm_wrt_tm_S_degree_brs_wrt_tm_S_degree_co_wrt_tm_S_degree_constraint_wrt_tm_S_mutual :
(forall n1 a1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm (S n1) a1) /\
(forall n1 brs1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_brs_wrt_tm (S n1) brs1) /\
(forall n1 g1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm (S n1) g1) /\
(forall n1 phi1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_constraint_wrt_tm (S n1) phi1).

Lemma degree_tm_wrt_tm_S :
forall n1 a1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm (S n1) a1.

Hint Resolve degree_tm_wrt_tm_S : lngen.

Lemma degree_brs_wrt_tm_S :
forall n1 brs1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_brs_wrt_tm (S n1) brs1.

Hint Resolve degree_brs_wrt_tm_S : lngen.

Lemma degree_co_wrt_tm_S :
forall n1 g1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm (S n1) g1.

Hint Resolve degree_co_wrt_tm_S : lngen.

Lemma degree_constraint_wrt_tm_S :
forall n1 phi1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_constraint_wrt_tm (S n1) phi1.

Hint Resolve degree_constraint_wrt_tm_S : lngen.

Lemma degree_tm_wrt_co_S_degree_brs_wrt_co_S_degree_co_wrt_co_S_degree_constraint_wrt_co_S_mutual :
(forall n1 a1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co (S n1) a1) /\
(forall n1 brs1,
  degree_brs_wrt_co n1 brs1 ->
  degree_brs_wrt_co (S n1) brs1) /\
(forall n1 g1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co (S n1) g1) /\
(forall n1 phi1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_constraint_wrt_co (S n1) phi1).

Lemma degree_tm_wrt_co_S :
forall n1 a1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co (S n1) a1.

Hint Resolve degree_tm_wrt_co_S : lngen.

Lemma degree_brs_wrt_co_S :
forall n1 brs1,
  degree_brs_wrt_co n1 brs1 ->
  degree_brs_wrt_co (S n1) brs1.

Hint Resolve degree_brs_wrt_co_S : lngen.

Lemma degree_co_wrt_co_S :
forall n1 g1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co (S n1) g1.

Hint Resolve degree_co_wrt_co_S : lngen.

Lemma degree_constraint_wrt_co_S :
forall n1 phi1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_constraint_wrt_co (S n1) phi1.

Hint Resolve degree_constraint_wrt_co_S : lngen.

Lemma degree_tm_wrt_tm_O :
forall n1 a1,
  degree_tm_wrt_tm O a1 ->
  degree_tm_wrt_tm n1 a1.

Hint Resolve degree_tm_wrt_tm_O : lngen.

Lemma degree_brs_wrt_tm_O :
forall n1 brs1,
  degree_brs_wrt_tm O brs1 ->
  degree_brs_wrt_tm n1 brs1.

Hint Resolve degree_brs_wrt_tm_O : lngen.

Lemma degree_co_wrt_tm_O :
forall n1 g1,
  degree_co_wrt_tm O g1 ->
  degree_co_wrt_tm n1 g1.

Hint Resolve degree_co_wrt_tm_O : lngen.

Lemma degree_constraint_wrt_tm_O :
forall n1 phi1,
  degree_constraint_wrt_tm O phi1 ->
  degree_constraint_wrt_tm n1 phi1.

Hint Resolve degree_constraint_wrt_tm_O : lngen.

Lemma degree_tm_wrt_co_O :
forall n1 a1,
  degree_tm_wrt_co O a1 ->
  degree_tm_wrt_co n1 a1.

Hint Resolve degree_tm_wrt_co_O : lngen.

Lemma degree_brs_wrt_co_O :
forall n1 brs1,
  degree_brs_wrt_co O brs1 ->
  degree_brs_wrt_co n1 brs1.

Hint Resolve degree_brs_wrt_co_O : lngen.

Lemma degree_co_wrt_co_O :
forall n1 g1,
  degree_co_wrt_co O g1 ->
  degree_co_wrt_co n1 g1.

Hint Resolve degree_co_wrt_co_O : lngen.

Lemma degree_constraint_wrt_co_O :
forall n1 phi1,
  degree_constraint_wrt_co O phi1 ->
  degree_constraint_wrt_co n1 phi1.

Hint Resolve degree_constraint_wrt_co_O : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_tm_rec_degree_brs_wrt_tm_close_brs_wrt_tm_rec_degree_co_wrt_tm_close_co_wrt_tm_rec_degree_constraint_wrt_tm_close_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm (S n1) (close_tm_wrt_tm_rec n1 x1 a1)) /\
(forall brs1 x1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_brs_wrt_tm (S n1) (close_brs_wrt_tm_rec n1 x1 brs1)) /\
(forall g1 x1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm (S n1) (close_co_wrt_tm_rec n1 x1 g1)) /\
(forall phi1 x1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_constraint_wrt_tm (S n1) (close_constraint_wrt_tm_rec n1 x1 phi1)).

Lemma degree_tm_wrt_tm_close_tm_wrt_tm_rec :
forall a1 x1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm (S n1) (close_tm_wrt_tm_rec n1 x1 a1).

Hint Resolve degree_tm_wrt_tm_close_tm_wrt_tm_rec : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_tm_rec :
forall brs1 x1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_brs_wrt_tm (S n1) (close_brs_wrt_tm_rec n1 x1 brs1).

Hint Resolve degree_brs_wrt_tm_close_brs_wrt_tm_rec : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_tm_rec :
forall g1 x1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm (S n1) (close_co_wrt_tm_rec n1 x1 g1).

Hint Resolve degree_co_wrt_tm_close_co_wrt_tm_rec : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_tm_rec :
forall phi1 x1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_constraint_wrt_tm (S n1) (close_constraint_wrt_tm_rec n1 x1 phi1).

Hint Resolve degree_constraint_wrt_tm_close_constraint_wrt_tm_rec : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_co_rec_degree_brs_wrt_tm_close_brs_wrt_co_rec_degree_co_wrt_tm_close_co_wrt_co_rec_degree_constraint_wrt_tm_close_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1 n2,
  degree_tm_wrt_tm n2 a1 ->
  degree_tm_wrt_tm n2 (close_tm_wrt_co_rec n1 c1 a1)) /\
(forall brs1 c1 n1 n2,
  degree_brs_wrt_tm n2 brs1 ->
  degree_brs_wrt_tm n2 (close_brs_wrt_co_rec n1 c1 brs1)) /\
(forall g1 c1 n1 n2,
  degree_co_wrt_tm n2 g1 ->
  degree_co_wrt_tm n2 (close_co_wrt_co_rec n1 c1 g1)) /\
(forall phi1 c1 n1 n2,
  degree_constraint_wrt_tm n2 phi1 ->
  degree_constraint_wrt_tm n2 (close_constraint_wrt_co_rec n1 c1 phi1)).

Lemma degree_tm_wrt_tm_close_tm_wrt_co_rec :
forall a1 c1 n1 n2,
  degree_tm_wrt_tm n2 a1 ->
  degree_tm_wrt_tm n2 (close_tm_wrt_co_rec n1 c1 a1).

Hint Resolve degree_tm_wrt_tm_close_tm_wrt_co_rec : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_co_rec :
forall brs1 c1 n1 n2,
  degree_brs_wrt_tm n2 brs1 ->
  degree_brs_wrt_tm n2 (close_brs_wrt_co_rec n1 c1 brs1).

Hint Resolve degree_brs_wrt_tm_close_brs_wrt_co_rec : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_co_rec :
forall g1 c1 n1 n2,
  degree_co_wrt_tm n2 g1 ->
  degree_co_wrt_tm n2 (close_co_wrt_co_rec n1 c1 g1).

Hint Resolve degree_co_wrt_tm_close_co_wrt_co_rec : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_co_rec :
forall phi1 c1 n1 n2,
  degree_constraint_wrt_tm n2 phi1 ->
  degree_constraint_wrt_tm n2 (close_constraint_wrt_co_rec n1 c1 phi1).

Hint Resolve degree_constraint_wrt_tm_close_constraint_wrt_co_rec : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_tm_rec_degree_brs_wrt_co_close_brs_wrt_tm_rec_degree_co_wrt_co_close_co_wrt_tm_rec_degree_constraint_wrt_co_close_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1 n2,
  degree_tm_wrt_co n2 a1 ->
  degree_tm_wrt_co n2 (close_tm_wrt_tm_rec n1 x1 a1)) /\
(forall brs1 x1 n1 n2,
  degree_brs_wrt_co n2 brs1 ->
  degree_brs_wrt_co n2 (close_brs_wrt_tm_rec n1 x1 brs1)) /\
(forall g1 x1 n1 n2,
  degree_co_wrt_co n2 g1 ->
  degree_co_wrt_co n2 (close_co_wrt_tm_rec n1 x1 g1)) /\
(forall phi1 x1 n1 n2,
  degree_constraint_wrt_co n2 phi1 ->
  degree_constraint_wrt_co n2 (close_constraint_wrt_tm_rec n1 x1 phi1)).

Lemma degree_tm_wrt_co_close_tm_wrt_tm_rec :
forall a1 x1 n1 n2,
  degree_tm_wrt_co n2 a1 ->
  degree_tm_wrt_co n2 (close_tm_wrt_tm_rec n1 x1 a1).

Hint Resolve degree_tm_wrt_co_close_tm_wrt_tm_rec : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_tm_rec :
forall brs1 x1 n1 n2,
  degree_brs_wrt_co n2 brs1 ->
  degree_brs_wrt_co n2 (close_brs_wrt_tm_rec n1 x1 brs1).

Hint Resolve degree_brs_wrt_co_close_brs_wrt_tm_rec : lngen.

Lemma degree_co_wrt_co_close_co_wrt_tm_rec :
forall g1 x1 n1 n2,
  degree_co_wrt_co n2 g1 ->
  degree_co_wrt_co n2 (close_co_wrt_tm_rec n1 x1 g1).

Hint Resolve degree_co_wrt_co_close_co_wrt_tm_rec : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_tm_rec :
forall phi1 x1 n1 n2,
  degree_constraint_wrt_co n2 phi1 ->
  degree_constraint_wrt_co n2 (close_constraint_wrt_tm_rec n1 x1 phi1).

Hint Resolve degree_constraint_wrt_co_close_constraint_wrt_tm_rec : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_co_rec_degree_brs_wrt_co_close_brs_wrt_co_rec_degree_co_wrt_co_close_co_wrt_co_rec_degree_constraint_wrt_co_close_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co (S n1) (close_tm_wrt_co_rec n1 c1 a1)) /\
(forall brs1 c1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_brs_wrt_co (S n1) (close_brs_wrt_co_rec n1 c1 brs1)) /\
(forall g1 c1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co (S n1) (close_co_wrt_co_rec n1 c1 g1)) /\
(forall phi1 c1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_constraint_wrt_co (S n1) (close_constraint_wrt_co_rec n1 c1 phi1)).

Lemma degree_tm_wrt_co_close_tm_wrt_co_rec :
forall a1 c1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co (S n1) (close_tm_wrt_co_rec n1 c1 a1).

Hint Resolve degree_tm_wrt_co_close_tm_wrt_co_rec : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_co_rec :
forall brs1 c1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_brs_wrt_co (S n1) (close_brs_wrt_co_rec n1 c1 brs1).

Hint Resolve degree_brs_wrt_co_close_brs_wrt_co_rec : lngen.

Lemma degree_co_wrt_co_close_co_wrt_co_rec :
forall g1 c1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co (S n1) (close_co_wrt_co_rec n1 c1 g1).

Hint Resolve degree_co_wrt_co_close_co_wrt_co_rec : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_co_rec :
forall phi1 c1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_constraint_wrt_co (S n1) (close_constraint_wrt_co_rec n1 c1 phi1).

Hint Resolve degree_constraint_wrt_co_close_constraint_wrt_co_rec : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_tm :
forall a1 x1,
  degree_tm_wrt_tm 0 a1 ->
  degree_tm_wrt_tm 1 (close_tm_wrt_tm x1 a1).

Hint Resolve degree_tm_wrt_tm_close_tm_wrt_tm : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_tm :
forall brs1 x1,
  degree_brs_wrt_tm 0 brs1 ->
  degree_brs_wrt_tm 1 (close_brs_wrt_tm x1 brs1).

Hint Resolve degree_brs_wrt_tm_close_brs_wrt_tm : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_tm :
forall g1 x1,
  degree_co_wrt_tm 0 g1 ->
  degree_co_wrt_tm 1 (close_co_wrt_tm x1 g1).

Hint Resolve degree_co_wrt_tm_close_co_wrt_tm : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_tm :
forall phi1 x1,
  degree_constraint_wrt_tm 0 phi1 ->
  degree_constraint_wrt_tm 1 (close_constraint_wrt_tm x1 phi1).

Hint Resolve degree_constraint_wrt_tm_close_constraint_wrt_tm : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_co :
forall a1 c1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm n1 (close_tm_wrt_co c1 a1).

Hint Resolve degree_tm_wrt_tm_close_tm_wrt_co : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_co :
forall brs1 c1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_brs_wrt_tm n1 (close_brs_wrt_co c1 brs1).

Hint Resolve degree_brs_wrt_tm_close_brs_wrt_co : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_co :
forall g1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm n1 (close_co_wrt_co c1 g1).

Hint Resolve degree_co_wrt_tm_close_co_wrt_co : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_co :
forall phi1 c1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_constraint_wrt_tm n1 (close_constraint_wrt_co c1 phi1).

Hint Resolve degree_constraint_wrt_tm_close_constraint_wrt_co : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_tm :
forall a1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co n1 (close_tm_wrt_tm x1 a1).

Hint Resolve degree_tm_wrt_co_close_tm_wrt_tm : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_tm :
forall brs1 x1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_brs_wrt_co n1 (close_brs_wrt_tm x1 brs1).

Hint Resolve degree_brs_wrt_co_close_brs_wrt_tm : lngen.

Lemma degree_co_wrt_co_close_co_wrt_tm :
forall g1 x1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co n1 (close_co_wrt_tm x1 g1).

Hint Resolve degree_co_wrt_co_close_co_wrt_tm : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_tm :
forall phi1 x1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_constraint_wrt_co n1 (close_constraint_wrt_tm x1 phi1).

Hint Resolve degree_constraint_wrt_co_close_constraint_wrt_tm : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_co :
forall a1 c1,
  degree_tm_wrt_co 0 a1 ->
  degree_tm_wrt_co 1 (close_tm_wrt_co c1 a1).

Hint Resolve degree_tm_wrt_co_close_tm_wrt_co : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_co :
forall brs1 c1,
  degree_brs_wrt_co 0 brs1 ->
  degree_brs_wrt_co 1 (close_brs_wrt_co c1 brs1).

Hint Resolve degree_brs_wrt_co_close_brs_wrt_co : lngen.

Lemma degree_co_wrt_co_close_co_wrt_co :
forall g1 c1,
  degree_co_wrt_co 0 g1 ->
  degree_co_wrt_co 1 (close_co_wrt_co c1 g1).

Hint Resolve degree_co_wrt_co_close_co_wrt_co : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_co :
forall phi1 c1,
  degree_constraint_wrt_co 0 phi1 ->
  degree_constraint_wrt_co 1 (close_constraint_wrt_co c1 phi1).

Hint Resolve degree_constraint_wrt_co_close_constraint_wrt_co : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_tm_rec_inv_degree_brs_wrt_tm_close_brs_wrt_tm_rec_inv_degree_co_wrt_tm_close_co_wrt_tm_rec_inv_degree_constraint_wrt_tm_close_constraint_wrt_tm_rec_inv_mutual :
(forall a1 x1 n1,
  degree_tm_wrt_tm (S n1) (close_tm_wrt_tm_rec n1 x1 a1) ->
  degree_tm_wrt_tm n1 a1) /\
(forall brs1 x1 n1,
  degree_brs_wrt_tm (S n1) (close_brs_wrt_tm_rec n1 x1 brs1) ->
  degree_brs_wrt_tm n1 brs1) /\
(forall g1 x1 n1,
  degree_co_wrt_tm (S n1) (close_co_wrt_tm_rec n1 x1 g1) ->
  degree_co_wrt_tm n1 g1) /\
(forall phi1 x1 n1,
  degree_constraint_wrt_tm (S n1) (close_constraint_wrt_tm_rec n1 x1 phi1) ->
  degree_constraint_wrt_tm n1 phi1).

Lemma degree_tm_wrt_tm_close_tm_wrt_tm_rec_inv :
forall a1 x1 n1,
  degree_tm_wrt_tm (S n1) (close_tm_wrt_tm_rec n1 x1 a1) ->
  degree_tm_wrt_tm n1 a1.

Hint Immediate degree_tm_wrt_tm_close_tm_wrt_tm_rec_inv : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_tm_rec_inv :
forall brs1 x1 n1,
  degree_brs_wrt_tm (S n1) (close_brs_wrt_tm_rec n1 x1 brs1) ->
  degree_brs_wrt_tm n1 brs1.

Hint Immediate degree_brs_wrt_tm_close_brs_wrt_tm_rec_inv : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_tm_rec_inv :
forall g1 x1 n1,
  degree_co_wrt_tm (S n1) (close_co_wrt_tm_rec n1 x1 g1) ->
  degree_co_wrt_tm n1 g1.

Hint Immediate degree_co_wrt_tm_close_co_wrt_tm_rec_inv : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_tm_rec_inv :
forall phi1 x1 n1,
  degree_constraint_wrt_tm (S n1) (close_constraint_wrt_tm_rec n1 x1 phi1) ->
  degree_constraint_wrt_tm n1 phi1.

Hint Immediate degree_constraint_wrt_tm_close_constraint_wrt_tm_rec_inv : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_co_rec_inv_degree_brs_wrt_tm_close_brs_wrt_co_rec_inv_degree_co_wrt_tm_close_co_wrt_co_rec_inv_degree_constraint_wrt_tm_close_constraint_wrt_co_rec_inv_mutual :
(forall a1 c1 n1 n2,
  degree_tm_wrt_tm n2 (close_tm_wrt_co_rec n1 c1 a1) ->
  degree_tm_wrt_tm n2 a1) /\
(forall brs1 c1 n1 n2,
  degree_brs_wrt_tm n2 (close_brs_wrt_co_rec n1 c1 brs1) ->
  degree_brs_wrt_tm n2 brs1) /\
(forall g1 c1 n1 n2,
  degree_co_wrt_tm n2 (close_co_wrt_co_rec n1 c1 g1) ->
  degree_co_wrt_tm n2 g1) /\
(forall phi1 c1 n1 n2,
  degree_constraint_wrt_tm n2 (close_constraint_wrt_co_rec n1 c1 phi1) ->
  degree_constraint_wrt_tm n2 phi1).

Lemma degree_tm_wrt_tm_close_tm_wrt_co_rec_inv :
forall a1 c1 n1 n2,
  degree_tm_wrt_tm n2 (close_tm_wrt_co_rec n1 c1 a1) ->
  degree_tm_wrt_tm n2 a1.

Hint Immediate degree_tm_wrt_tm_close_tm_wrt_co_rec_inv : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_co_rec_inv :
forall brs1 c1 n1 n2,
  degree_brs_wrt_tm n2 (close_brs_wrt_co_rec n1 c1 brs1) ->
  degree_brs_wrt_tm n2 brs1.

Hint Immediate degree_brs_wrt_tm_close_brs_wrt_co_rec_inv : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_co_rec_inv :
forall g1 c1 n1 n2,
  degree_co_wrt_tm n2 (close_co_wrt_co_rec n1 c1 g1) ->
  degree_co_wrt_tm n2 g1.

Hint Immediate degree_co_wrt_tm_close_co_wrt_co_rec_inv : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_co_rec_inv :
forall phi1 c1 n1 n2,
  degree_constraint_wrt_tm n2 (close_constraint_wrt_co_rec n1 c1 phi1) ->
  degree_constraint_wrt_tm n2 phi1.

Hint Immediate degree_constraint_wrt_tm_close_constraint_wrt_co_rec_inv : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_tm_rec_inv_degree_brs_wrt_co_close_brs_wrt_tm_rec_inv_degree_co_wrt_co_close_co_wrt_tm_rec_inv_degree_constraint_wrt_co_close_constraint_wrt_tm_rec_inv_mutual :
(forall a1 x1 n1 n2,
  degree_tm_wrt_co n2 (close_tm_wrt_tm_rec n1 x1 a1) ->
  degree_tm_wrt_co n2 a1) /\
(forall brs1 x1 n1 n2,
  degree_brs_wrt_co n2 (close_brs_wrt_tm_rec n1 x1 brs1) ->
  degree_brs_wrt_co n2 brs1) /\
(forall g1 x1 n1 n2,
  degree_co_wrt_co n2 (close_co_wrt_tm_rec n1 x1 g1) ->
  degree_co_wrt_co n2 g1) /\
(forall phi1 x1 n1 n2,
  degree_constraint_wrt_co n2 (close_constraint_wrt_tm_rec n1 x1 phi1) ->
  degree_constraint_wrt_co n2 phi1).

Lemma degree_tm_wrt_co_close_tm_wrt_tm_rec_inv :
forall a1 x1 n1 n2,
  degree_tm_wrt_co n2 (close_tm_wrt_tm_rec n1 x1 a1) ->
  degree_tm_wrt_co n2 a1.

Hint Immediate degree_tm_wrt_co_close_tm_wrt_tm_rec_inv : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_tm_rec_inv :
forall brs1 x1 n1 n2,
  degree_brs_wrt_co n2 (close_brs_wrt_tm_rec n1 x1 brs1) ->
  degree_brs_wrt_co n2 brs1.

Hint Immediate degree_brs_wrt_co_close_brs_wrt_tm_rec_inv : lngen.

Lemma degree_co_wrt_co_close_co_wrt_tm_rec_inv :
forall g1 x1 n1 n2,
  degree_co_wrt_co n2 (close_co_wrt_tm_rec n1 x1 g1) ->
  degree_co_wrt_co n2 g1.

Hint Immediate degree_co_wrt_co_close_co_wrt_tm_rec_inv : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_tm_rec_inv :
forall phi1 x1 n1 n2,
  degree_constraint_wrt_co n2 (close_constraint_wrt_tm_rec n1 x1 phi1) ->
  degree_constraint_wrt_co n2 phi1.

Hint Immediate degree_constraint_wrt_co_close_constraint_wrt_tm_rec_inv : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_co_rec_inv_degree_brs_wrt_co_close_brs_wrt_co_rec_inv_degree_co_wrt_co_close_co_wrt_co_rec_inv_degree_constraint_wrt_co_close_constraint_wrt_co_rec_inv_mutual :
(forall a1 c1 n1,
  degree_tm_wrt_co (S n1) (close_tm_wrt_co_rec n1 c1 a1) ->
  degree_tm_wrt_co n1 a1) /\
(forall brs1 c1 n1,
  degree_brs_wrt_co (S n1) (close_brs_wrt_co_rec n1 c1 brs1) ->
  degree_brs_wrt_co n1 brs1) /\
(forall g1 c1 n1,
  degree_co_wrt_co (S n1) (close_co_wrt_co_rec n1 c1 g1) ->
  degree_co_wrt_co n1 g1) /\
(forall phi1 c1 n1,
  degree_constraint_wrt_co (S n1) (close_constraint_wrt_co_rec n1 c1 phi1) ->
  degree_constraint_wrt_co n1 phi1).

Lemma degree_tm_wrt_co_close_tm_wrt_co_rec_inv :
forall a1 c1 n1,
  degree_tm_wrt_co (S n1) (close_tm_wrt_co_rec n1 c1 a1) ->
  degree_tm_wrt_co n1 a1.

Hint Immediate degree_tm_wrt_co_close_tm_wrt_co_rec_inv : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_co_rec_inv :
forall brs1 c1 n1,
  degree_brs_wrt_co (S n1) (close_brs_wrt_co_rec n1 c1 brs1) ->
  degree_brs_wrt_co n1 brs1.

Hint Immediate degree_brs_wrt_co_close_brs_wrt_co_rec_inv : lngen.

Lemma degree_co_wrt_co_close_co_wrt_co_rec_inv :
forall g1 c1 n1,
  degree_co_wrt_co (S n1) (close_co_wrt_co_rec n1 c1 g1) ->
  degree_co_wrt_co n1 g1.

Hint Immediate degree_co_wrt_co_close_co_wrt_co_rec_inv : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_co_rec_inv :
forall phi1 c1 n1,
  degree_constraint_wrt_co (S n1) (close_constraint_wrt_co_rec n1 c1 phi1) ->
  degree_constraint_wrt_co n1 phi1.

Hint Immediate degree_constraint_wrt_co_close_constraint_wrt_co_rec_inv : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_tm_inv :
forall a1 x1,
  degree_tm_wrt_tm 1 (close_tm_wrt_tm x1 a1) ->
  degree_tm_wrt_tm 0 a1.

Hint Immediate degree_tm_wrt_tm_close_tm_wrt_tm_inv : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_tm_inv :
forall brs1 x1,
  degree_brs_wrt_tm 1 (close_brs_wrt_tm x1 brs1) ->
  degree_brs_wrt_tm 0 brs1.

Hint Immediate degree_brs_wrt_tm_close_brs_wrt_tm_inv : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_tm_inv :
forall g1 x1,
  degree_co_wrt_tm 1 (close_co_wrt_tm x1 g1) ->
  degree_co_wrt_tm 0 g1.

Hint Immediate degree_co_wrt_tm_close_co_wrt_tm_inv : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_tm_inv :
forall phi1 x1,
  degree_constraint_wrt_tm 1 (close_constraint_wrt_tm x1 phi1) ->
  degree_constraint_wrt_tm 0 phi1.

Hint Immediate degree_constraint_wrt_tm_close_constraint_wrt_tm_inv : lngen.

Lemma degree_tm_wrt_tm_close_tm_wrt_co_inv :
forall a1 c1 n1,
  degree_tm_wrt_tm n1 (close_tm_wrt_co c1 a1) ->
  degree_tm_wrt_tm n1 a1.

Hint Immediate degree_tm_wrt_tm_close_tm_wrt_co_inv : lngen.

Lemma degree_brs_wrt_tm_close_brs_wrt_co_inv :
forall brs1 c1 n1,
  degree_brs_wrt_tm n1 (close_brs_wrt_co c1 brs1) ->
  degree_brs_wrt_tm n1 brs1.

Hint Immediate degree_brs_wrt_tm_close_brs_wrt_co_inv : lngen.

Lemma degree_co_wrt_tm_close_co_wrt_co_inv :
forall g1 c1 n1,
  degree_co_wrt_tm n1 (close_co_wrt_co c1 g1) ->
  degree_co_wrt_tm n1 g1.

Hint Immediate degree_co_wrt_tm_close_co_wrt_co_inv : lngen.

Lemma degree_constraint_wrt_tm_close_constraint_wrt_co_inv :
forall phi1 c1 n1,
  degree_constraint_wrt_tm n1 (close_constraint_wrt_co c1 phi1) ->
  degree_constraint_wrt_tm n1 phi1.

Hint Immediate degree_constraint_wrt_tm_close_constraint_wrt_co_inv : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_tm_inv :
forall a1 x1 n1,
  degree_tm_wrt_co n1 (close_tm_wrt_tm x1 a1) ->
  degree_tm_wrt_co n1 a1.

Hint Immediate degree_tm_wrt_co_close_tm_wrt_tm_inv : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_tm_inv :
forall brs1 x1 n1,
  degree_brs_wrt_co n1 (close_brs_wrt_tm x1 brs1) ->
  degree_brs_wrt_co n1 brs1.

Hint Immediate degree_brs_wrt_co_close_brs_wrt_tm_inv : lngen.

Lemma degree_co_wrt_co_close_co_wrt_tm_inv :
forall g1 x1 n1,
  degree_co_wrt_co n1 (close_co_wrt_tm x1 g1) ->
  degree_co_wrt_co n1 g1.

Hint Immediate degree_co_wrt_co_close_co_wrt_tm_inv : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_tm_inv :
forall phi1 x1 n1,
  degree_constraint_wrt_co n1 (close_constraint_wrt_tm x1 phi1) ->
  degree_constraint_wrt_co n1 phi1.

Hint Immediate degree_constraint_wrt_co_close_constraint_wrt_tm_inv : lngen.

Lemma degree_tm_wrt_co_close_tm_wrt_co_inv :
forall a1 c1,
  degree_tm_wrt_co 1 (close_tm_wrt_co c1 a1) ->
  degree_tm_wrt_co 0 a1.

Hint Immediate degree_tm_wrt_co_close_tm_wrt_co_inv : lngen.

Lemma degree_brs_wrt_co_close_brs_wrt_co_inv :
forall brs1 c1,
  degree_brs_wrt_co 1 (close_brs_wrt_co c1 brs1) ->
  degree_brs_wrt_co 0 brs1.

Hint Immediate degree_brs_wrt_co_close_brs_wrt_co_inv : lngen.

Lemma degree_co_wrt_co_close_co_wrt_co_inv :
forall g1 c1,
  degree_co_wrt_co 1 (close_co_wrt_co c1 g1) ->
  degree_co_wrt_co 0 g1.

Hint Immediate degree_co_wrt_co_close_co_wrt_co_inv : lngen.

Lemma degree_constraint_wrt_co_close_constraint_wrt_co_inv :
forall phi1 c1,
  degree_constraint_wrt_co 1 (close_constraint_wrt_co c1 phi1) ->
  degree_constraint_wrt_co 0 phi1.

Hint Immediate degree_constraint_wrt_co_close_constraint_wrt_co_inv : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_tm_rec_degree_brs_wrt_tm_open_brs_wrt_tm_rec_degree_co_wrt_tm_open_co_wrt_tm_rec_degree_constraint_wrt_tm_open_constraint_wrt_tm_rec_mutual :
(forall a1 a2 n1,
  degree_tm_wrt_tm (S n1) a1 ->
  degree_tm_wrt_tm n1 a2 ->
  degree_tm_wrt_tm n1 (open_tm_wrt_tm_rec n1 a2 a1)) /\
(forall brs1 a1 n1,
  degree_brs_wrt_tm (S n1) brs1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_brs_wrt_tm n1 (open_brs_wrt_tm_rec n1 a1 brs1)) /\
(forall g1 a1 n1,
  degree_co_wrt_tm (S n1) g1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 (open_co_wrt_tm_rec n1 a1 g1)) /\
(forall phi1 a1 n1,
  degree_constraint_wrt_tm (S n1) phi1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_constraint_wrt_tm n1 (open_constraint_wrt_tm_rec n1 a1 phi1)).

Lemma degree_tm_wrt_tm_open_tm_wrt_tm_rec :
forall a1 a2 n1,
  degree_tm_wrt_tm (S n1) a1 ->
  degree_tm_wrt_tm n1 a2 ->
  degree_tm_wrt_tm n1 (open_tm_wrt_tm_rec n1 a2 a1).

Hint Resolve degree_tm_wrt_tm_open_tm_wrt_tm_rec : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_tm_rec :
forall brs1 a1 n1,
  degree_brs_wrt_tm (S n1) brs1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_brs_wrt_tm n1 (open_brs_wrt_tm_rec n1 a1 brs1).

Hint Resolve degree_brs_wrt_tm_open_brs_wrt_tm_rec : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_tm_rec :
forall g1 a1 n1,
  degree_co_wrt_tm (S n1) g1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 (open_co_wrt_tm_rec n1 a1 g1).

Hint Resolve degree_co_wrt_tm_open_co_wrt_tm_rec : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_tm_rec :
forall phi1 a1 n1,
  degree_constraint_wrt_tm (S n1) phi1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_constraint_wrt_tm n1 (open_constraint_wrt_tm_rec n1 a1 phi1).

Hint Resolve degree_constraint_wrt_tm_open_constraint_wrt_tm_rec : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_co_rec_degree_brs_wrt_tm_open_brs_wrt_co_rec_degree_co_wrt_tm_open_co_wrt_co_rec_degree_constraint_wrt_tm_open_constraint_wrt_co_rec_mutual :
(forall a1 g1 n1 n2,
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 (open_tm_wrt_co_rec n2 g1 a1)) /\
(forall brs1 g1 n1 n2,
  degree_brs_wrt_tm n1 brs1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_brs_wrt_tm n1 (open_brs_wrt_co_rec n2 g1 brs1)) /\
(forall g1 g2 n1 n2,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm n1 g2 ->
  degree_co_wrt_tm n1 (open_co_wrt_co_rec n2 g2 g1)) /\
(forall phi1 g1 n1 n2,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_constraint_wrt_tm n1 (open_constraint_wrt_co_rec n2 g1 phi1)).

Lemma degree_tm_wrt_tm_open_tm_wrt_co_rec :
forall a1 g1 n1 n2,
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 (open_tm_wrt_co_rec n2 g1 a1).

Hint Resolve degree_tm_wrt_tm_open_tm_wrt_co_rec : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_co_rec :
forall brs1 g1 n1 n2,
  degree_brs_wrt_tm n1 brs1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_brs_wrt_tm n1 (open_brs_wrt_co_rec n2 g1 brs1).

Hint Resolve degree_brs_wrt_tm_open_brs_wrt_co_rec : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_co_rec :
forall g1 g2 n1 n2,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm n1 g2 ->
  degree_co_wrt_tm n1 (open_co_wrt_co_rec n2 g2 g1).

Hint Resolve degree_co_wrt_tm_open_co_wrt_co_rec : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_co_rec :
forall phi1 g1 n1 n2,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_constraint_wrt_tm n1 (open_constraint_wrt_co_rec n2 g1 phi1).

Hint Resolve degree_constraint_wrt_tm_open_constraint_wrt_co_rec : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_tm_rec_degree_brs_wrt_co_open_brs_wrt_tm_rec_degree_co_wrt_co_open_co_wrt_tm_rec_degree_constraint_wrt_co_open_constraint_wrt_tm_rec_mutual :
(forall a1 a2 n1 n2,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co n1 a2 ->
  degree_tm_wrt_co n1 (open_tm_wrt_tm_rec n2 a2 a1)) /\
(forall brs1 a1 n1 n2,
  degree_brs_wrt_co n1 brs1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_brs_wrt_co n1 (open_brs_wrt_tm_rec n2 a1 brs1)) /\
(forall g1 a1 n1 n2,
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 (open_co_wrt_tm_rec n2 a1 g1)) /\
(forall phi1 a1 n1 n2,
  degree_constraint_wrt_co n1 phi1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_constraint_wrt_co n1 (open_constraint_wrt_tm_rec n2 a1 phi1)).

Lemma degree_tm_wrt_co_open_tm_wrt_tm_rec :
forall a1 a2 n1 n2,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co n1 a2 ->
  degree_tm_wrt_co n1 (open_tm_wrt_tm_rec n2 a2 a1).

Hint Resolve degree_tm_wrt_co_open_tm_wrt_tm_rec : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_tm_rec :
forall brs1 a1 n1 n2,
  degree_brs_wrt_co n1 brs1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_brs_wrt_co n1 (open_brs_wrt_tm_rec n2 a1 brs1).

Hint Resolve degree_brs_wrt_co_open_brs_wrt_tm_rec : lngen.

Lemma degree_co_wrt_co_open_co_wrt_tm_rec :
forall g1 a1 n1 n2,
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 (open_co_wrt_tm_rec n2 a1 g1).

Hint Resolve degree_co_wrt_co_open_co_wrt_tm_rec : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_tm_rec :
forall phi1 a1 n1 n2,
  degree_constraint_wrt_co n1 phi1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_constraint_wrt_co n1 (open_constraint_wrt_tm_rec n2 a1 phi1).

Hint Resolve degree_constraint_wrt_co_open_constraint_wrt_tm_rec : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_co_rec_degree_brs_wrt_co_open_brs_wrt_co_rec_degree_co_wrt_co_open_co_wrt_co_rec_degree_constraint_wrt_co_open_constraint_wrt_co_rec_mutual :
(forall a1 g1 n1,
  degree_tm_wrt_co (S n1) a1 ->
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 (open_tm_wrt_co_rec n1 g1 a1)) /\
(forall brs1 g1 n1,
  degree_brs_wrt_co (S n1) brs1 ->
  degree_co_wrt_co n1 g1 ->
  degree_brs_wrt_co n1 (open_brs_wrt_co_rec n1 g1 brs1)) /\
(forall g1 g2 n1,
  degree_co_wrt_co (S n1) g1 ->
  degree_co_wrt_co n1 g2 ->
  degree_co_wrt_co n1 (open_co_wrt_co_rec n1 g2 g1)) /\
(forall phi1 g1 n1,
  degree_constraint_wrt_co (S n1) phi1 ->
  degree_co_wrt_co n1 g1 ->
  degree_constraint_wrt_co n1 (open_constraint_wrt_co_rec n1 g1 phi1)).

Lemma degree_tm_wrt_co_open_tm_wrt_co_rec :
forall a1 g1 n1,
  degree_tm_wrt_co (S n1) a1 ->
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 (open_tm_wrt_co_rec n1 g1 a1).

Hint Resolve degree_tm_wrt_co_open_tm_wrt_co_rec : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_co_rec :
forall brs1 g1 n1,
  degree_brs_wrt_co (S n1) brs1 ->
  degree_co_wrt_co n1 g1 ->
  degree_brs_wrt_co n1 (open_brs_wrt_co_rec n1 g1 brs1).

Hint Resolve degree_brs_wrt_co_open_brs_wrt_co_rec : lngen.

Lemma degree_co_wrt_co_open_co_wrt_co_rec :
forall g1 g2 n1,
  degree_co_wrt_co (S n1) g1 ->
  degree_co_wrt_co n1 g2 ->
  degree_co_wrt_co n1 (open_co_wrt_co_rec n1 g2 g1).

Hint Resolve degree_co_wrt_co_open_co_wrt_co_rec : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_co_rec :
forall phi1 g1 n1,
  degree_constraint_wrt_co (S n1) phi1 ->
  degree_co_wrt_co n1 g1 ->
  degree_constraint_wrt_co n1 (open_constraint_wrt_co_rec n1 g1 phi1).

Hint Resolve degree_constraint_wrt_co_open_constraint_wrt_co_rec : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_tm :
forall a1 a2,
  degree_tm_wrt_tm 1 a1 ->
  degree_tm_wrt_tm 0 a2 ->
  degree_tm_wrt_tm 0 (open_tm_wrt_tm a1 a2).

Hint Resolve degree_tm_wrt_tm_open_tm_wrt_tm : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_tm :
forall brs1 a1,
  degree_brs_wrt_tm 1 brs1 ->
  degree_tm_wrt_tm 0 a1 ->
  degree_brs_wrt_tm 0 (open_brs_wrt_tm brs1 a1).

Hint Resolve degree_brs_wrt_tm_open_brs_wrt_tm : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_tm :
forall g1 a1,
  degree_co_wrt_tm 1 g1 ->
  degree_tm_wrt_tm 0 a1 ->
  degree_co_wrt_tm 0 (open_co_wrt_tm g1 a1).

Hint Resolve degree_co_wrt_tm_open_co_wrt_tm : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_tm :
forall phi1 a1,
  degree_constraint_wrt_tm 1 phi1 ->
  degree_tm_wrt_tm 0 a1 ->
  degree_constraint_wrt_tm 0 (open_constraint_wrt_tm phi1 a1).

Hint Resolve degree_constraint_wrt_tm_open_constraint_wrt_tm : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_co :
forall a1 g1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 (open_tm_wrt_co a1 g1).

Hint Resolve degree_tm_wrt_tm_open_tm_wrt_co : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_co :
forall brs1 g1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_brs_wrt_tm n1 (open_brs_wrt_co brs1 g1).

Hint Resolve degree_brs_wrt_tm_open_brs_wrt_co : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_co :
forall g1 g2 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm n1 g2 ->
  degree_co_wrt_tm n1 (open_co_wrt_co g1 g2).

Hint Resolve degree_co_wrt_tm_open_co_wrt_co : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_co :
forall phi1 g1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_constraint_wrt_tm n1 (open_constraint_wrt_co phi1 g1).

Hint Resolve degree_constraint_wrt_tm_open_constraint_wrt_co : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_tm :
forall a1 a2 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co n1 a2 ->
  degree_tm_wrt_co n1 (open_tm_wrt_tm a1 a2).

Hint Resolve degree_tm_wrt_co_open_tm_wrt_tm : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_tm :
forall brs1 a1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_brs_wrt_co n1 (open_brs_wrt_tm brs1 a1).

Hint Resolve degree_brs_wrt_co_open_brs_wrt_tm : lngen.

Lemma degree_co_wrt_co_open_co_wrt_tm :
forall g1 a1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 (open_co_wrt_tm g1 a1).

Hint Resolve degree_co_wrt_co_open_co_wrt_tm : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_tm :
forall phi1 a1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_constraint_wrt_co n1 (open_constraint_wrt_tm phi1 a1).

Hint Resolve degree_constraint_wrt_co_open_constraint_wrt_tm : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_co :
forall a1 g1,
  degree_tm_wrt_co 1 a1 ->
  degree_co_wrt_co 0 g1 ->
  degree_tm_wrt_co 0 (open_tm_wrt_co a1 g1).

Hint Resolve degree_tm_wrt_co_open_tm_wrt_co : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_co :
forall brs1 g1,
  degree_brs_wrt_co 1 brs1 ->
  degree_co_wrt_co 0 g1 ->
  degree_brs_wrt_co 0 (open_brs_wrt_co brs1 g1).

Hint Resolve degree_brs_wrt_co_open_brs_wrt_co : lngen.

Lemma degree_co_wrt_co_open_co_wrt_co :
forall g1 g2,
  degree_co_wrt_co 1 g1 ->
  degree_co_wrt_co 0 g2 ->
  degree_co_wrt_co 0 (open_co_wrt_co g1 g2).

Hint Resolve degree_co_wrt_co_open_co_wrt_co : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_co :
forall phi1 g1,
  degree_constraint_wrt_co 1 phi1 ->
  degree_co_wrt_co 0 g1 ->
  degree_constraint_wrt_co 0 (open_constraint_wrt_co phi1 g1).

Hint Resolve degree_constraint_wrt_co_open_constraint_wrt_co : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_tm_rec_inv_degree_brs_wrt_tm_open_brs_wrt_tm_rec_inv_degree_co_wrt_tm_open_co_wrt_tm_rec_inv_degree_constraint_wrt_tm_open_constraint_wrt_tm_rec_inv_mutual :
(forall a1 a2 n1,
  degree_tm_wrt_tm n1 (open_tm_wrt_tm_rec n1 a2 a1) ->
  degree_tm_wrt_tm (S n1) a1) /\
(forall brs1 a1 n1,
  degree_brs_wrt_tm n1 (open_brs_wrt_tm_rec n1 a1 brs1) ->
  degree_brs_wrt_tm (S n1) brs1) /\
(forall g1 a1 n1,
  degree_co_wrt_tm n1 (open_co_wrt_tm_rec n1 a1 g1) ->
  degree_co_wrt_tm (S n1) g1) /\
(forall phi1 a1 n1,
  degree_constraint_wrt_tm n1 (open_constraint_wrt_tm_rec n1 a1 phi1) ->
  degree_constraint_wrt_tm (S n1) phi1).

Lemma degree_tm_wrt_tm_open_tm_wrt_tm_rec_inv :
forall a1 a2 n1,
  degree_tm_wrt_tm n1 (open_tm_wrt_tm_rec n1 a2 a1) ->
  degree_tm_wrt_tm (S n1) a1.

Hint Immediate degree_tm_wrt_tm_open_tm_wrt_tm_rec_inv : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_tm_rec_inv :
forall brs1 a1 n1,
  degree_brs_wrt_tm n1 (open_brs_wrt_tm_rec n1 a1 brs1) ->
  degree_brs_wrt_tm (S n1) brs1.

Hint Immediate degree_brs_wrt_tm_open_brs_wrt_tm_rec_inv : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_tm_rec_inv :
forall g1 a1 n1,
  degree_co_wrt_tm n1 (open_co_wrt_tm_rec n1 a1 g1) ->
  degree_co_wrt_tm (S n1) g1.

Hint Immediate degree_co_wrt_tm_open_co_wrt_tm_rec_inv : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_tm_rec_inv :
forall phi1 a1 n1,
  degree_constraint_wrt_tm n1 (open_constraint_wrt_tm_rec n1 a1 phi1) ->
  degree_constraint_wrt_tm (S n1) phi1.

Hint Immediate degree_constraint_wrt_tm_open_constraint_wrt_tm_rec_inv : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_co_rec_inv_degree_brs_wrt_tm_open_brs_wrt_co_rec_inv_degree_co_wrt_tm_open_co_wrt_co_rec_inv_degree_constraint_wrt_tm_open_constraint_wrt_co_rec_inv_mutual :
(forall a1 g1 n1 n2,
  degree_tm_wrt_tm n1 (open_tm_wrt_co_rec n2 g1 a1) ->
  degree_tm_wrt_tm n1 a1) /\
(forall brs1 g1 n1 n2,
  degree_brs_wrt_tm n1 (open_brs_wrt_co_rec n2 g1 brs1) ->
  degree_brs_wrt_tm n1 brs1) /\
(forall g1 g2 n1 n2,
  degree_co_wrt_tm n1 (open_co_wrt_co_rec n2 g2 g1) ->
  degree_co_wrt_tm n1 g1) /\
(forall phi1 g1 n1 n2,
  degree_constraint_wrt_tm n1 (open_constraint_wrt_co_rec n2 g1 phi1) ->
  degree_constraint_wrt_tm n1 phi1).

Lemma degree_tm_wrt_tm_open_tm_wrt_co_rec_inv :
forall a1 g1 n1 n2,
  degree_tm_wrt_tm n1 (open_tm_wrt_co_rec n2 g1 a1) ->
  degree_tm_wrt_tm n1 a1.

Hint Immediate degree_tm_wrt_tm_open_tm_wrt_co_rec_inv : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_co_rec_inv :
forall brs1 g1 n1 n2,
  degree_brs_wrt_tm n1 (open_brs_wrt_co_rec n2 g1 brs1) ->
  degree_brs_wrt_tm n1 brs1.

Hint Immediate degree_brs_wrt_tm_open_brs_wrt_co_rec_inv : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_co_rec_inv :
forall g1 g2 n1 n2,
  degree_co_wrt_tm n1 (open_co_wrt_co_rec n2 g2 g1) ->
  degree_co_wrt_tm n1 g1.

Hint Immediate degree_co_wrt_tm_open_co_wrt_co_rec_inv : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_co_rec_inv :
forall phi1 g1 n1 n2,
  degree_constraint_wrt_tm n1 (open_constraint_wrt_co_rec n2 g1 phi1) ->
  degree_constraint_wrt_tm n1 phi1.

Hint Immediate degree_constraint_wrt_tm_open_constraint_wrt_co_rec_inv : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_tm_rec_inv_degree_brs_wrt_co_open_brs_wrt_tm_rec_inv_degree_co_wrt_co_open_co_wrt_tm_rec_inv_degree_constraint_wrt_co_open_constraint_wrt_tm_rec_inv_mutual :
(forall a1 a2 n1 n2,
  degree_tm_wrt_co n1 (open_tm_wrt_tm_rec n2 a2 a1) ->
  degree_tm_wrt_co n1 a1) /\
(forall brs1 a1 n1 n2,
  degree_brs_wrt_co n1 (open_brs_wrt_tm_rec n2 a1 brs1) ->
  degree_brs_wrt_co n1 brs1) /\
(forall g1 a1 n1 n2,
  degree_co_wrt_co n1 (open_co_wrt_tm_rec n2 a1 g1) ->
  degree_co_wrt_co n1 g1) /\
(forall phi1 a1 n1 n2,
  degree_constraint_wrt_co n1 (open_constraint_wrt_tm_rec n2 a1 phi1) ->
  degree_constraint_wrt_co n1 phi1).

Lemma degree_tm_wrt_co_open_tm_wrt_tm_rec_inv :
forall a1 a2 n1 n2,
  degree_tm_wrt_co n1 (open_tm_wrt_tm_rec n2 a2 a1) ->
  degree_tm_wrt_co n1 a1.

Hint Immediate degree_tm_wrt_co_open_tm_wrt_tm_rec_inv : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_tm_rec_inv :
forall brs1 a1 n1 n2,
  degree_brs_wrt_co n1 (open_brs_wrt_tm_rec n2 a1 brs1) ->
  degree_brs_wrt_co n1 brs1.

Hint Immediate degree_brs_wrt_co_open_brs_wrt_tm_rec_inv : lngen.

Lemma degree_co_wrt_co_open_co_wrt_tm_rec_inv :
forall g1 a1 n1 n2,
  degree_co_wrt_co n1 (open_co_wrt_tm_rec n2 a1 g1) ->
  degree_co_wrt_co n1 g1.

Hint Immediate degree_co_wrt_co_open_co_wrt_tm_rec_inv : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_tm_rec_inv :
forall phi1 a1 n1 n2,
  degree_constraint_wrt_co n1 (open_constraint_wrt_tm_rec n2 a1 phi1) ->
  degree_constraint_wrt_co n1 phi1.

Hint Immediate degree_constraint_wrt_co_open_constraint_wrt_tm_rec_inv : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_co_rec_inv_degree_brs_wrt_co_open_brs_wrt_co_rec_inv_degree_co_wrt_co_open_co_wrt_co_rec_inv_degree_constraint_wrt_co_open_constraint_wrt_co_rec_inv_mutual :
(forall a1 g1 n1,
  degree_tm_wrt_co n1 (open_tm_wrt_co_rec n1 g1 a1) ->
  degree_tm_wrt_co (S n1) a1) /\
(forall brs1 g1 n1,
  degree_brs_wrt_co n1 (open_brs_wrt_co_rec n1 g1 brs1) ->
  degree_brs_wrt_co (S n1) brs1) /\
(forall g1 g2 n1,
  degree_co_wrt_co n1 (open_co_wrt_co_rec n1 g2 g1) ->
  degree_co_wrt_co (S n1) g1) /\
(forall phi1 g1 n1,
  degree_constraint_wrt_co n1 (open_constraint_wrt_co_rec n1 g1 phi1) ->
  degree_constraint_wrt_co (S n1) phi1).

Lemma degree_tm_wrt_co_open_tm_wrt_co_rec_inv :
forall a1 g1 n1,
  degree_tm_wrt_co n1 (open_tm_wrt_co_rec n1 g1 a1) ->
  degree_tm_wrt_co (S n1) a1.

Hint Immediate degree_tm_wrt_co_open_tm_wrt_co_rec_inv : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_co_rec_inv :
forall brs1 g1 n1,
  degree_brs_wrt_co n1 (open_brs_wrt_co_rec n1 g1 brs1) ->
  degree_brs_wrt_co (S n1) brs1.

Hint Immediate degree_brs_wrt_co_open_brs_wrt_co_rec_inv : lngen.

Lemma degree_co_wrt_co_open_co_wrt_co_rec_inv :
forall g1 g2 n1,
  degree_co_wrt_co n1 (open_co_wrt_co_rec n1 g2 g1) ->
  degree_co_wrt_co (S n1) g1.

Hint Immediate degree_co_wrt_co_open_co_wrt_co_rec_inv : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_co_rec_inv :
forall phi1 g1 n1,
  degree_constraint_wrt_co n1 (open_constraint_wrt_co_rec n1 g1 phi1) ->
  degree_constraint_wrt_co (S n1) phi1.

Hint Immediate degree_constraint_wrt_co_open_constraint_wrt_co_rec_inv : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_tm_inv :
forall a1 a2,
  degree_tm_wrt_tm 0 (open_tm_wrt_tm a1 a2) ->
  degree_tm_wrt_tm 1 a1.

Hint Immediate degree_tm_wrt_tm_open_tm_wrt_tm_inv : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_tm_inv :
forall brs1 a1,
  degree_brs_wrt_tm 0 (open_brs_wrt_tm brs1 a1) ->
  degree_brs_wrt_tm 1 brs1.

Hint Immediate degree_brs_wrt_tm_open_brs_wrt_tm_inv : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_tm_inv :
forall g1 a1,
  degree_co_wrt_tm 0 (open_co_wrt_tm g1 a1) ->
  degree_co_wrt_tm 1 g1.

Hint Immediate degree_co_wrt_tm_open_co_wrt_tm_inv : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_tm_inv :
forall phi1 a1,
  degree_constraint_wrt_tm 0 (open_constraint_wrt_tm phi1 a1) ->
  degree_constraint_wrt_tm 1 phi1.

Hint Immediate degree_constraint_wrt_tm_open_constraint_wrt_tm_inv : lngen.

Lemma degree_tm_wrt_tm_open_tm_wrt_co_inv :
forall a1 g1 n1,
  degree_tm_wrt_tm n1 (open_tm_wrt_co a1 g1) ->
  degree_tm_wrt_tm n1 a1.

Hint Immediate degree_tm_wrt_tm_open_tm_wrt_co_inv : lngen.

Lemma degree_brs_wrt_tm_open_brs_wrt_co_inv :
forall brs1 g1 n1,
  degree_brs_wrt_tm n1 (open_brs_wrt_co brs1 g1) ->
  degree_brs_wrt_tm n1 brs1.

Hint Immediate degree_brs_wrt_tm_open_brs_wrt_co_inv : lngen.

Lemma degree_co_wrt_tm_open_co_wrt_co_inv :
forall g1 g2 n1,
  degree_co_wrt_tm n1 (open_co_wrt_co g1 g2) ->
  degree_co_wrt_tm n1 g1.

Hint Immediate degree_co_wrt_tm_open_co_wrt_co_inv : lngen.

Lemma degree_constraint_wrt_tm_open_constraint_wrt_co_inv :
forall phi1 g1 n1,
  degree_constraint_wrt_tm n1 (open_constraint_wrt_co phi1 g1) ->
  degree_constraint_wrt_tm n1 phi1.

Hint Immediate degree_constraint_wrt_tm_open_constraint_wrt_co_inv : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_tm_inv :
forall a1 a2 n1,
  degree_tm_wrt_co n1 (open_tm_wrt_tm a1 a2) ->
  degree_tm_wrt_co n1 a1.

Hint Immediate degree_tm_wrt_co_open_tm_wrt_tm_inv : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_tm_inv :
forall brs1 a1 n1,
  degree_brs_wrt_co n1 (open_brs_wrt_tm brs1 a1) ->
  degree_brs_wrt_co n1 brs1.

Hint Immediate degree_brs_wrt_co_open_brs_wrt_tm_inv : lngen.

Lemma degree_co_wrt_co_open_co_wrt_tm_inv :
forall g1 a1 n1,
  degree_co_wrt_co n1 (open_co_wrt_tm g1 a1) ->
  degree_co_wrt_co n1 g1.

Hint Immediate degree_co_wrt_co_open_co_wrt_tm_inv : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_tm_inv :
forall phi1 a1 n1,
  degree_constraint_wrt_co n1 (open_constraint_wrt_tm phi1 a1) ->
  degree_constraint_wrt_co n1 phi1.

Hint Immediate degree_constraint_wrt_co_open_constraint_wrt_tm_inv : lngen.

Lemma degree_tm_wrt_co_open_tm_wrt_co_inv :
forall a1 g1,
  degree_tm_wrt_co 0 (open_tm_wrt_co a1 g1) ->
  degree_tm_wrt_co 1 a1.

Hint Immediate degree_tm_wrt_co_open_tm_wrt_co_inv : lngen.

Lemma degree_brs_wrt_co_open_brs_wrt_co_inv :
forall brs1 g1,
  degree_brs_wrt_co 0 (open_brs_wrt_co brs1 g1) ->
  degree_brs_wrt_co 1 brs1.

Hint Immediate degree_brs_wrt_co_open_brs_wrt_co_inv : lngen.

Lemma degree_co_wrt_co_open_co_wrt_co_inv :
forall g1 g2,
  degree_co_wrt_co 0 (open_co_wrt_co g1 g2) ->
  degree_co_wrt_co 1 g1.

Hint Immediate degree_co_wrt_co_open_co_wrt_co_inv : lngen.

Lemma degree_constraint_wrt_co_open_constraint_wrt_co_inv :
forall phi1 g1,
  degree_constraint_wrt_co 0 (open_constraint_wrt_co phi1 g1) ->
  degree_constraint_wrt_co 1 phi1.

Hint Immediate degree_constraint_wrt_co_open_constraint_wrt_co_inv : lngen.

Ltac default_auto ::= auto with lngen brute_force; tauto.
Ltac default_autorewrite ::= fail.

Lemma close_tm_wrt_tm_rec_inj_close_brs_wrt_tm_rec_inj_close_co_wrt_tm_rec_inj_close_constraint_wrt_tm_rec_inj_mutual :
(forall a1 a2 x1 n1,
  close_tm_wrt_tm_rec n1 x1 a1 = close_tm_wrt_tm_rec n1 x1 a2 ->
  a1 = a2) /\
(forall brs1 brs2 x1 n1,
  close_brs_wrt_tm_rec n1 x1 brs1 = close_brs_wrt_tm_rec n1 x1 brs2 ->
  brs1 = brs2) /\
(forall g1 g2 x1 n1,
  close_co_wrt_tm_rec n1 x1 g1 = close_co_wrt_tm_rec n1 x1 g2 ->
  g1 = g2) /\
(forall phi1 phi2 x1 n1,
  close_constraint_wrt_tm_rec n1 x1 phi1 = close_constraint_wrt_tm_rec n1 x1 phi2 ->
  phi1 = phi2).

Lemma close_tm_wrt_tm_rec_inj :
forall a1 a2 x1 n1,
  close_tm_wrt_tm_rec n1 x1 a1 = close_tm_wrt_tm_rec n1 x1 a2 ->
  a1 = a2.

Hint Immediate close_tm_wrt_tm_rec_inj : lngen.

Lemma close_brs_wrt_tm_rec_inj :
forall brs1 brs2 x1 n1,
  close_brs_wrt_tm_rec n1 x1 brs1 = close_brs_wrt_tm_rec n1 x1 brs2 ->
  brs1 = brs2.

Hint Immediate close_brs_wrt_tm_rec_inj : lngen.

Lemma close_co_wrt_tm_rec_inj :
forall g1 g2 x1 n1,
  close_co_wrt_tm_rec n1 x1 g1 = close_co_wrt_tm_rec n1 x1 g2 ->
  g1 = g2.

Hint Immediate close_co_wrt_tm_rec_inj : lngen.

Lemma close_constraint_wrt_tm_rec_inj :
forall phi1 phi2 x1 n1,
  close_constraint_wrt_tm_rec n1 x1 phi1 = close_constraint_wrt_tm_rec n1 x1 phi2 ->
  phi1 = phi2.

Hint Immediate close_constraint_wrt_tm_rec_inj : lngen.

Lemma close_tm_wrt_co_rec_inj_close_brs_wrt_co_rec_inj_close_co_wrt_co_rec_inj_close_constraint_wrt_co_rec_inj_mutual :
(forall a1 a2 c1 n1,
  close_tm_wrt_co_rec n1 c1 a1 = close_tm_wrt_co_rec n1 c1 a2 ->
  a1 = a2) /\
(forall brs1 brs2 c1 n1,
  close_brs_wrt_co_rec n1 c1 brs1 = close_brs_wrt_co_rec n1 c1 brs2 ->
  brs1 = brs2) /\
(forall g1 g2 c1 n1,
  close_co_wrt_co_rec n1 c1 g1 = close_co_wrt_co_rec n1 c1 g2 ->
  g1 = g2) /\
(forall phi1 phi2 c1 n1,
  close_constraint_wrt_co_rec n1 c1 phi1 = close_constraint_wrt_co_rec n1 c1 phi2 ->
  phi1 = phi2).

Lemma close_tm_wrt_co_rec_inj :
forall a1 a2 c1 n1,
  close_tm_wrt_co_rec n1 c1 a1 = close_tm_wrt_co_rec n1 c1 a2 ->
  a1 = a2.

Hint Immediate close_tm_wrt_co_rec_inj : lngen.

Lemma close_brs_wrt_co_rec_inj :
forall brs1 brs2 c1 n1,
  close_brs_wrt_co_rec n1 c1 brs1 = close_brs_wrt_co_rec n1 c1 brs2 ->
  brs1 = brs2.

Hint Immediate close_brs_wrt_co_rec_inj : lngen.

Lemma close_co_wrt_co_rec_inj :
forall g1 g2 c1 n1,
  close_co_wrt_co_rec n1 c1 g1 = close_co_wrt_co_rec n1 c1 g2 ->
  g1 = g2.

Hint Immediate close_co_wrt_co_rec_inj : lngen.

Lemma close_constraint_wrt_co_rec_inj :
forall phi1 phi2 c1 n1,
  close_constraint_wrt_co_rec n1 c1 phi1 = close_constraint_wrt_co_rec n1 c1 phi2 ->
  phi1 = phi2.

Hint Immediate close_constraint_wrt_co_rec_inj : lngen.

Lemma close_tm_wrt_tm_inj :
forall a1 a2 x1,
  close_tm_wrt_tm x1 a1 = close_tm_wrt_tm x1 a2 ->
  a1 = a2.

Hint Immediate close_tm_wrt_tm_inj : lngen.

Lemma close_brs_wrt_tm_inj :
forall brs1 brs2 x1,
  close_brs_wrt_tm x1 brs1 = close_brs_wrt_tm x1 brs2 ->
  brs1 = brs2.

Hint Immediate close_brs_wrt_tm_inj : lngen.

Lemma close_co_wrt_tm_inj :
forall g1 g2 x1,
  close_co_wrt_tm x1 g1 = close_co_wrt_tm x1 g2 ->
  g1 = g2.

Hint Immediate close_co_wrt_tm_inj : lngen.

Lemma close_constraint_wrt_tm_inj :
forall phi1 phi2 x1,
  close_constraint_wrt_tm x1 phi1 = close_constraint_wrt_tm x1 phi2 ->
  phi1 = phi2.

Hint Immediate close_constraint_wrt_tm_inj : lngen.

Lemma close_tm_wrt_co_inj :
forall a1 a2 c1,
  close_tm_wrt_co c1 a1 = close_tm_wrt_co c1 a2 ->
  a1 = a2.

Hint Immediate close_tm_wrt_co_inj : lngen.

Lemma close_brs_wrt_co_inj :
forall brs1 brs2 c1,
  close_brs_wrt_co c1 brs1 = close_brs_wrt_co c1 brs2 ->
  brs1 = brs2.

Hint Immediate close_brs_wrt_co_inj : lngen.

Lemma close_co_wrt_co_inj :
forall g1 g2 c1,
  close_co_wrt_co c1 g1 = close_co_wrt_co c1 g2 ->
  g1 = g2.

Hint Immediate close_co_wrt_co_inj : lngen.

Lemma close_constraint_wrt_co_inj :
forall phi1 phi2 c1,
  close_constraint_wrt_co c1 phi1 = close_constraint_wrt_co c1 phi2 ->
  phi1 = phi2.

Hint Immediate close_constraint_wrt_co_inj : lngen.

Lemma close_tm_wrt_tm_rec_open_tm_wrt_tm_rec_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec_close_co_wrt_tm_rec_open_co_wrt_tm_rec_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1,
  x1 `notin` fv_tm_tm_tm a1 ->
  close_tm_wrt_tm_rec n1 x1 (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1) = a1) /\
(forall brs1 x1 n1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  close_brs_wrt_tm_rec n1 x1 (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1) = brs1) /\
(forall g1 x1 n1,
  x1 `notin` fv_tm_tm_co g1 ->
  close_co_wrt_tm_rec n1 x1 (open_co_wrt_tm_rec n1 (a_Var_f x1) g1) = g1) /\
(forall phi1 x1 n1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  close_constraint_wrt_tm_rec n1 x1 (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1) = phi1).

Lemma close_tm_wrt_tm_rec_open_tm_wrt_tm_rec :
forall a1 x1 n1,
  x1 `notin` fv_tm_tm_tm a1 ->
  close_tm_wrt_tm_rec n1 x1 (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1) = a1.

Hint Resolve close_tm_wrt_tm_rec_open_tm_wrt_tm_rec : lngen.
Hint Rewrite close_tm_wrt_tm_rec_open_tm_wrt_tm_rec using solve [auto] : lngen.

Lemma close_brs_wrt_tm_rec_open_brs_wrt_tm_rec :
forall brs1 x1 n1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  close_brs_wrt_tm_rec n1 x1 (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1) = brs1.

Hint Resolve close_brs_wrt_tm_rec_open_brs_wrt_tm_rec : lngen.
Hint Rewrite close_brs_wrt_tm_rec_open_brs_wrt_tm_rec using solve [auto] : lngen.

Lemma close_co_wrt_tm_rec_open_co_wrt_tm_rec :
forall g1 x1 n1,
  x1 `notin` fv_tm_tm_co g1 ->
  close_co_wrt_tm_rec n1 x1 (open_co_wrt_tm_rec n1 (a_Var_f x1) g1) = g1.

Hint Resolve close_co_wrt_tm_rec_open_co_wrt_tm_rec : lngen.
Hint Rewrite close_co_wrt_tm_rec_open_co_wrt_tm_rec using solve [auto] : lngen.

Lemma close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec :
forall phi1 x1 n1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  close_constraint_wrt_tm_rec n1 x1 (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1) = phi1.

Hint Resolve close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec : lngen.
Hint Rewrite close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec using solve [auto] : lngen.

Lemma close_tm_wrt_co_rec_open_tm_wrt_co_rec_close_brs_wrt_co_rec_open_brs_wrt_co_rec_close_co_wrt_co_rec_open_co_wrt_co_rec_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1,
  c1 `notin` fv_co_co_tm a1 ->
  close_tm_wrt_co_rec n1 c1 (open_tm_wrt_co_rec n1 (g_Var_f c1) a1) = a1) /\
(forall brs1 c1 n1,
  c1 `notin` fv_co_co_brs brs1 ->
  close_brs_wrt_co_rec n1 c1 (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1) = brs1) /\
(forall g1 c1 n1,
  c1 `notin` fv_co_co_co g1 ->
  close_co_wrt_co_rec n1 c1 (open_co_wrt_co_rec n1 (g_Var_f c1) g1) = g1) /\
(forall phi1 c1 n1,
  c1 `notin` fv_co_co_constraint phi1 ->
  close_constraint_wrt_co_rec n1 c1 (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1) = phi1).

Lemma close_tm_wrt_co_rec_open_tm_wrt_co_rec :
forall a1 c1 n1,
  c1 `notin` fv_co_co_tm a1 ->
  close_tm_wrt_co_rec n1 c1 (open_tm_wrt_co_rec n1 (g_Var_f c1) a1) = a1.

Hint Resolve close_tm_wrt_co_rec_open_tm_wrt_co_rec : lngen.
Hint Rewrite close_tm_wrt_co_rec_open_tm_wrt_co_rec using solve [auto] : lngen.

Lemma close_brs_wrt_co_rec_open_brs_wrt_co_rec :
forall brs1 c1 n1,
  c1 `notin` fv_co_co_brs brs1 ->
  close_brs_wrt_co_rec n1 c1 (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1) = brs1.

Hint Resolve close_brs_wrt_co_rec_open_brs_wrt_co_rec : lngen.
Hint Rewrite close_brs_wrt_co_rec_open_brs_wrt_co_rec using solve [auto] : lngen.

Lemma close_co_wrt_co_rec_open_co_wrt_co_rec :
forall g1 c1 n1,
  c1 `notin` fv_co_co_co g1 ->
  close_co_wrt_co_rec n1 c1 (open_co_wrt_co_rec n1 (g_Var_f c1) g1) = g1.

Hint Resolve close_co_wrt_co_rec_open_co_wrt_co_rec : lngen.
Hint Rewrite close_co_wrt_co_rec_open_co_wrt_co_rec using solve [auto] : lngen.

Lemma close_constraint_wrt_co_rec_open_constraint_wrt_co_rec :
forall phi1 c1 n1,
  c1 `notin` fv_co_co_constraint phi1 ->
  close_constraint_wrt_co_rec n1 c1 (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1) = phi1.

Hint Resolve close_constraint_wrt_co_rec_open_constraint_wrt_co_rec : lngen.
Hint Rewrite close_constraint_wrt_co_rec_open_constraint_wrt_co_rec using solve [auto] : lngen.

Lemma close_tm_wrt_tm_open_tm_wrt_tm :
forall a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  close_tm_wrt_tm x1 (open_tm_wrt_tm a1 (a_Var_f x1)) = a1.

Hint Resolve close_tm_wrt_tm_open_tm_wrt_tm : lngen.
Hint Rewrite close_tm_wrt_tm_open_tm_wrt_tm using solve [auto] : lngen.

Lemma close_brs_wrt_tm_open_brs_wrt_tm :
forall brs1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  close_brs_wrt_tm x1 (open_brs_wrt_tm brs1 (a_Var_f x1)) = brs1.

Hint Resolve close_brs_wrt_tm_open_brs_wrt_tm : lngen.
Hint Rewrite close_brs_wrt_tm_open_brs_wrt_tm using solve [auto] : lngen.

Lemma close_co_wrt_tm_open_co_wrt_tm :
forall g1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  close_co_wrt_tm x1 (open_co_wrt_tm g1 (a_Var_f x1)) = g1.

Hint Resolve close_co_wrt_tm_open_co_wrt_tm : lngen.
Hint Rewrite close_co_wrt_tm_open_co_wrt_tm using solve [auto] : lngen.

Lemma close_constraint_wrt_tm_open_constraint_wrt_tm :
forall phi1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  close_constraint_wrt_tm x1 (open_constraint_wrt_tm phi1 (a_Var_f x1)) = phi1.

Hint Resolve close_constraint_wrt_tm_open_constraint_wrt_tm : lngen.
Hint Rewrite close_constraint_wrt_tm_open_constraint_wrt_tm using solve [auto] : lngen.

Lemma close_tm_wrt_co_open_tm_wrt_co :
forall a1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  close_tm_wrt_co c1 (open_tm_wrt_co a1 (g_Var_f c1)) = a1.

Hint Resolve close_tm_wrt_co_open_tm_wrt_co : lngen.
Hint Rewrite close_tm_wrt_co_open_tm_wrt_co using solve [auto] : lngen.

Lemma close_brs_wrt_co_open_brs_wrt_co :
forall brs1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  close_brs_wrt_co c1 (open_brs_wrt_co brs1 (g_Var_f c1)) = brs1.

Hint Resolve close_brs_wrt_co_open_brs_wrt_co : lngen.
Hint Rewrite close_brs_wrt_co_open_brs_wrt_co using solve [auto] : lngen.

Lemma close_co_wrt_co_open_co_wrt_co :
forall g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  close_co_wrt_co c1 (open_co_wrt_co g1 (g_Var_f c1)) = g1.

Hint Resolve close_co_wrt_co_open_co_wrt_co : lngen.
Hint Rewrite close_co_wrt_co_open_co_wrt_co using solve [auto] : lngen.

Lemma close_constraint_wrt_co_open_constraint_wrt_co :
forall phi1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  close_constraint_wrt_co c1 (open_constraint_wrt_co phi1 (g_Var_f c1)) = phi1.

Hint Resolve close_constraint_wrt_co_open_constraint_wrt_co : lngen.
Hint Rewrite close_constraint_wrt_co_open_constraint_wrt_co using solve [auto] : lngen.

Lemma open_tm_wrt_tm_rec_close_tm_wrt_tm_rec_open_brs_wrt_tm_rec_close_brs_wrt_tm_rec_open_co_wrt_tm_rec_close_co_wrt_tm_rec_open_constraint_wrt_tm_rec_close_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1,
  open_tm_wrt_tm_rec n1 (a_Var_f x1) (close_tm_wrt_tm_rec n1 x1 a1) = a1) /\
(forall brs1 x1 n1,
  open_brs_wrt_tm_rec n1 (a_Var_f x1) (close_brs_wrt_tm_rec n1 x1 brs1) = brs1) /\
(forall g1 x1 n1,
  open_co_wrt_tm_rec n1 (a_Var_f x1) (close_co_wrt_tm_rec n1 x1 g1) = g1) /\
(forall phi1 x1 n1,
  open_constraint_wrt_tm_rec n1 (a_Var_f x1) (close_constraint_wrt_tm_rec n1 x1 phi1) = phi1).

Lemma open_tm_wrt_tm_rec_close_tm_wrt_tm_rec :
forall a1 x1 n1,
  open_tm_wrt_tm_rec n1 (a_Var_f x1) (close_tm_wrt_tm_rec n1 x1 a1) = a1.

Hint Resolve open_tm_wrt_tm_rec_close_tm_wrt_tm_rec : lngen.
Hint Rewrite open_tm_wrt_tm_rec_close_tm_wrt_tm_rec using solve [auto] : lngen.

Lemma open_brs_wrt_tm_rec_close_brs_wrt_tm_rec :
forall brs1 x1 n1,
  open_brs_wrt_tm_rec n1 (a_Var_f x1) (close_brs_wrt_tm_rec n1 x1 brs1) = brs1.

Hint Resolve open_brs_wrt_tm_rec_close_brs_wrt_tm_rec : lngen.
Hint Rewrite open_brs_wrt_tm_rec_close_brs_wrt_tm_rec using solve [auto] : lngen.

Lemma open_co_wrt_tm_rec_close_co_wrt_tm_rec :
forall g1 x1 n1,
  open_co_wrt_tm_rec n1 (a_Var_f x1) (close_co_wrt_tm_rec n1 x1 g1) = g1.

Hint Resolve open_co_wrt_tm_rec_close_co_wrt_tm_rec : lngen.
Hint Rewrite open_co_wrt_tm_rec_close_co_wrt_tm_rec using solve [auto] : lngen.

Lemma open_constraint_wrt_tm_rec_close_constraint_wrt_tm_rec :
forall phi1 x1 n1,
  open_constraint_wrt_tm_rec n1 (a_Var_f x1) (close_constraint_wrt_tm_rec n1 x1 phi1) = phi1.

Hint Resolve open_constraint_wrt_tm_rec_close_constraint_wrt_tm_rec : lngen.
Hint Rewrite open_constraint_wrt_tm_rec_close_constraint_wrt_tm_rec using solve [auto] : lngen.

Lemma open_tm_wrt_co_rec_close_tm_wrt_co_rec_open_brs_wrt_co_rec_close_brs_wrt_co_rec_open_co_wrt_co_rec_close_co_wrt_co_rec_open_constraint_wrt_co_rec_close_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1,
  open_tm_wrt_co_rec n1 (g_Var_f c1) (close_tm_wrt_co_rec n1 c1 a1) = a1) /\
(forall brs1 c1 n1,
  open_brs_wrt_co_rec n1 (g_Var_f c1) (close_brs_wrt_co_rec n1 c1 brs1) = brs1) /\
(forall g1 c1 n1,
  open_co_wrt_co_rec n1 (g_Var_f c1) (close_co_wrt_co_rec n1 c1 g1) = g1) /\
(forall phi1 c1 n1,
  open_constraint_wrt_co_rec n1 (g_Var_f c1) (close_constraint_wrt_co_rec n1 c1 phi1) = phi1).

Lemma open_tm_wrt_co_rec_close_tm_wrt_co_rec :
forall a1 c1 n1,
  open_tm_wrt_co_rec n1 (g_Var_f c1) (close_tm_wrt_co_rec n1 c1 a1) = a1.

Hint Resolve open_tm_wrt_co_rec_close_tm_wrt_co_rec : lngen.
Hint Rewrite open_tm_wrt_co_rec_close_tm_wrt_co_rec using solve [auto] : lngen.

Lemma open_brs_wrt_co_rec_close_brs_wrt_co_rec :
forall brs1 c1 n1,
  open_brs_wrt_co_rec n1 (g_Var_f c1) (close_brs_wrt_co_rec n1 c1 brs1) = brs1.

Hint Resolve open_brs_wrt_co_rec_close_brs_wrt_co_rec : lngen.
Hint Rewrite open_brs_wrt_co_rec_close_brs_wrt_co_rec using solve [auto] : lngen.

Lemma open_co_wrt_co_rec_close_co_wrt_co_rec :
forall g1 c1 n1,
  open_co_wrt_co_rec n1 (g_Var_f c1) (close_co_wrt_co_rec n1 c1 g1) = g1.

Hint Resolve open_co_wrt_co_rec_close_co_wrt_co_rec : lngen.
Hint Rewrite open_co_wrt_co_rec_close_co_wrt_co_rec using solve [auto] : lngen.

Lemma open_constraint_wrt_co_rec_close_constraint_wrt_co_rec :
forall phi1 c1 n1,
  open_constraint_wrt_co_rec n1 (g_Var_f c1) (close_constraint_wrt_co_rec n1 c1 phi1) = phi1.

Hint Resolve open_constraint_wrt_co_rec_close_constraint_wrt_co_rec : lngen.
Hint Rewrite open_constraint_wrt_co_rec_close_constraint_wrt_co_rec using solve [auto] : lngen.

Lemma open_tm_wrt_tm_close_tm_wrt_tm :
forall a1 x1,
  open_tm_wrt_tm (close_tm_wrt_tm x1 a1) (a_Var_f x1) = a1.

Hint Resolve open_tm_wrt_tm_close_tm_wrt_tm : lngen.
Hint Rewrite open_tm_wrt_tm_close_tm_wrt_tm using solve [auto] : lngen.

Lemma open_brs_wrt_tm_close_brs_wrt_tm :
forall brs1 x1,
  open_brs_wrt_tm (close_brs_wrt_tm x1 brs1) (a_Var_f x1) = brs1.

Hint Resolve open_brs_wrt_tm_close_brs_wrt_tm : lngen.
Hint Rewrite open_brs_wrt_tm_close_brs_wrt_tm using solve [auto] : lngen.

Lemma open_co_wrt_tm_close_co_wrt_tm :
forall g1 x1,
  open_co_wrt_tm (close_co_wrt_tm x1 g1) (a_Var_f x1) = g1.

Hint Resolve open_co_wrt_tm_close_co_wrt_tm : lngen.
Hint Rewrite open_co_wrt_tm_close_co_wrt_tm using solve [auto] : lngen.

Lemma open_constraint_wrt_tm_close_constraint_wrt_tm :
forall phi1 x1,
  open_constraint_wrt_tm (close_constraint_wrt_tm x1 phi1) (a_Var_f x1) = phi1.

Hint Resolve open_constraint_wrt_tm_close_constraint_wrt_tm : lngen.
Hint Rewrite open_constraint_wrt_tm_close_constraint_wrt_tm using solve [auto] : lngen.

Lemma open_tm_wrt_co_close_tm_wrt_co :
forall a1 c1,
  open_tm_wrt_co (close_tm_wrt_co c1 a1) (g_Var_f c1) = a1.

Hint Resolve open_tm_wrt_co_close_tm_wrt_co : lngen.
Hint Rewrite open_tm_wrt_co_close_tm_wrt_co using solve [auto] : lngen.

Lemma open_brs_wrt_co_close_brs_wrt_co :
forall brs1 c1,
  open_brs_wrt_co (close_brs_wrt_co c1 brs1) (g_Var_f c1) = brs1.

Hint Resolve open_brs_wrt_co_close_brs_wrt_co : lngen.
Hint Rewrite open_brs_wrt_co_close_brs_wrt_co using solve [auto] : lngen.

Lemma open_co_wrt_co_close_co_wrt_co :
forall g1 c1,
  open_co_wrt_co (close_co_wrt_co c1 g1) (g_Var_f c1) = g1.

Hint Resolve open_co_wrt_co_close_co_wrt_co : lngen.
Hint Rewrite open_co_wrt_co_close_co_wrt_co using solve [auto] : lngen.

Lemma open_constraint_wrt_co_close_constraint_wrt_co :
forall phi1 c1,
  open_constraint_wrt_co (close_constraint_wrt_co c1 phi1) (g_Var_f c1) = phi1.

Hint Resolve open_constraint_wrt_co_close_constraint_wrt_co : lngen.
Hint Rewrite open_constraint_wrt_co_close_constraint_wrt_co using solve [auto] : lngen.

Lemma open_tm_wrt_tm_rec_inj_open_brs_wrt_tm_rec_inj_open_co_wrt_tm_rec_inj_open_constraint_wrt_tm_rec_inj_mutual :
(forall a2 a1 x1 n1,
  x1 `notin` fv_tm_tm_tm a2 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  open_tm_wrt_tm_rec n1 (a_Var_f x1) a2 = open_tm_wrt_tm_rec n1 (a_Var_f x1) a1 ->
  a2 = a1) /\
(forall brs2 brs1 x1 n1,
  x1 `notin` fv_tm_tm_brs brs2 ->
  x1 `notin` fv_tm_tm_brs brs1 ->
  open_brs_wrt_tm_rec n1 (a_Var_f x1) brs2 = open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1 ->
  brs2 = brs1) /\
(forall g2 g1 x1 n1,
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co g1 ->
  open_co_wrt_tm_rec n1 (a_Var_f x1) g2 = open_co_wrt_tm_rec n1 (a_Var_f x1) g1 ->
  g2 = g1) /\
(forall phi2 phi1 x1 n1,
  x1 `notin` fv_tm_tm_constraint phi2 ->
  x1 `notin` fv_tm_tm_constraint phi1 ->
  open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi2 = open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1 ->
  phi2 = phi1).

Lemma open_tm_wrt_tm_rec_inj :
forall a2 a1 x1 n1,
  x1 `notin` fv_tm_tm_tm a2 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  open_tm_wrt_tm_rec n1 (a_Var_f x1) a2 = open_tm_wrt_tm_rec n1 (a_Var_f x1) a1 ->
  a2 = a1.

Hint Immediate open_tm_wrt_tm_rec_inj : lngen.

Lemma open_brs_wrt_tm_rec_inj :
forall brs2 brs1 x1 n1,
  x1 `notin` fv_tm_tm_brs brs2 ->
  x1 `notin` fv_tm_tm_brs brs1 ->
  open_brs_wrt_tm_rec n1 (a_Var_f x1) brs2 = open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1 ->
  brs2 = brs1.

Hint Immediate open_brs_wrt_tm_rec_inj : lngen.

Lemma open_co_wrt_tm_rec_inj :
forall g2 g1 x1 n1,
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co g1 ->
  open_co_wrt_tm_rec n1 (a_Var_f x1) g2 = open_co_wrt_tm_rec n1 (a_Var_f x1) g1 ->
  g2 = g1.

Hint Immediate open_co_wrt_tm_rec_inj : lngen.

Lemma open_constraint_wrt_tm_rec_inj :
forall phi2 phi1 x1 n1,
  x1 `notin` fv_tm_tm_constraint phi2 ->
  x1 `notin` fv_tm_tm_constraint phi1 ->
  open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi2 = open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1 ->
  phi2 = phi1.

Hint Immediate open_constraint_wrt_tm_rec_inj : lngen.

Lemma open_tm_wrt_co_rec_inj_open_brs_wrt_co_rec_inj_open_co_wrt_co_rec_inj_open_constraint_wrt_co_rec_inj_mutual :
(forall a2 a1 c1 n1,
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm a1 ->
  open_tm_wrt_co_rec n1 (g_Var_f c1) a2 = open_tm_wrt_co_rec n1 (g_Var_f c1) a1 ->
  a2 = a1) /\
(forall brs2 brs1 c1 n1,
  c1 `notin` fv_co_co_brs brs2 ->
  c1 `notin` fv_co_co_brs brs1 ->
  open_brs_wrt_co_rec n1 (g_Var_f c1) brs2 = open_brs_wrt_co_rec n1 (g_Var_f c1) brs1 ->
  brs2 = brs1) /\
(forall g2 g1 c1 n1,
  c1 `notin` fv_co_co_co g2 ->
  c1 `notin` fv_co_co_co g1 ->
  open_co_wrt_co_rec n1 (g_Var_f c1) g2 = open_co_wrt_co_rec n1 (g_Var_f c1) g1 ->
  g2 = g1) /\
(forall phi2 phi1 c1 n1,
  c1 `notin` fv_co_co_constraint phi2 ->
  c1 `notin` fv_co_co_constraint phi1 ->
  open_constraint_wrt_co_rec n1 (g_Var_f c1) phi2 = open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1 ->
  phi2 = phi1).

Lemma open_tm_wrt_co_rec_inj :
forall a2 a1 c1 n1,
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm a1 ->
  open_tm_wrt_co_rec n1 (g_Var_f c1) a2 = open_tm_wrt_co_rec n1 (g_Var_f c1) a1 ->
  a2 = a1.

Hint Immediate open_tm_wrt_co_rec_inj : lngen.

Lemma open_brs_wrt_co_rec_inj :
forall brs2 brs1 c1 n1,
  c1 `notin` fv_co_co_brs brs2 ->
  c1 `notin` fv_co_co_brs brs1 ->
  open_brs_wrt_co_rec n1 (g_Var_f c1) brs2 = open_brs_wrt_co_rec n1 (g_Var_f c1) brs1 ->
  brs2 = brs1.

Hint Immediate open_brs_wrt_co_rec_inj : lngen.

Lemma open_co_wrt_co_rec_inj :
forall g2 g1 c1 n1,
  c1 `notin` fv_co_co_co g2 ->
  c1 `notin` fv_co_co_co g1 ->
  open_co_wrt_co_rec n1 (g_Var_f c1) g2 = open_co_wrt_co_rec n1 (g_Var_f c1) g1 ->
  g2 = g1.

Hint Immediate open_co_wrt_co_rec_inj : lngen.

Lemma open_constraint_wrt_co_rec_inj :
forall phi2 phi1 c1 n1,
  c1 `notin` fv_co_co_constraint phi2 ->
  c1 `notin` fv_co_co_constraint phi1 ->
  open_constraint_wrt_co_rec n1 (g_Var_f c1) phi2 = open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1 ->
  phi2 = phi1.

Hint Immediate open_constraint_wrt_co_rec_inj : lngen.

Lemma open_tm_wrt_tm_inj :
forall a2 a1 x1,
  x1 `notin` fv_tm_tm_tm a2 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  open_tm_wrt_tm a2 (a_Var_f x1) = open_tm_wrt_tm a1 (a_Var_f x1) ->
  a2 = a1.

Hint Immediate open_tm_wrt_tm_inj : lngen.

Lemma open_brs_wrt_tm_inj :
forall brs2 brs1 x1,
  x1 `notin` fv_tm_tm_brs brs2 ->
  x1 `notin` fv_tm_tm_brs brs1 ->
  open_brs_wrt_tm brs2 (a_Var_f x1) = open_brs_wrt_tm brs1 (a_Var_f x1) ->
  brs2 = brs1.

Hint Immediate open_brs_wrt_tm_inj : lngen.

Lemma open_co_wrt_tm_inj :
forall g2 g1 x1,
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co g1 ->
  open_co_wrt_tm g2 (a_Var_f x1) = open_co_wrt_tm g1 (a_Var_f x1) ->
  g2 = g1.

Hint Immediate open_co_wrt_tm_inj : lngen.

Lemma open_constraint_wrt_tm_inj :
forall phi2 phi1 x1,
  x1 `notin` fv_tm_tm_constraint phi2 ->
  x1 `notin` fv_tm_tm_constraint phi1 ->
  open_constraint_wrt_tm phi2 (a_Var_f x1) = open_constraint_wrt_tm phi1 (a_Var_f x1) ->
  phi2 = phi1.

Hint Immediate open_constraint_wrt_tm_inj : lngen.

Lemma open_tm_wrt_co_inj :
forall a2 a1 c1,
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm a1 ->
  open_tm_wrt_co a2 (g_Var_f c1) = open_tm_wrt_co a1 (g_Var_f c1) ->
  a2 = a1.

Hint Immediate open_tm_wrt_co_inj : lngen.

Lemma open_brs_wrt_co_inj :
forall brs2 brs1 c1,
  c1 `notin` fv_co_co_brs brs2 ->
  c1 `notin` fv_co_co_brs brs1 ->
  open_brs_wrt_co brs2 (g_Var_f c1) = open_brs_wrt_co brs1 (g_Var_f c1) ->
  brs2 = brs1.

Hint Immediate open_brs_wrt_co_inj : lngen.

Lemma open_co_wrt_co_inj :
forall g2 g1 c1,
  c1 `notin` fv_co_co_co g2 ->
  c1 `notin` fv_co_co_co g1 ->
  open_co_wrt_co g2 (g_Var_f c1) = open_co_wrt_co g1 (g_Var_f c1) ->
  g2 = g1.

Hint Immediate open_co_wrt_co_inj : lngen.

Lemma open_constraint_wrt_co_inj :
forall phi2 phi1 c1,
  c1 `notin` fv_co_co_constraint phi2 ->
  c1 `notin` fv_co_co_constraint phi1 ->
  open_constraint_wrt_co phi2 (g_Var_f c1) = open_constraint_wrt_co phi1 (g_Var_f c1) ->
  phi2 = phi1.

Hint Immediate open_constraint_wrt_co_inj : lngen.

Ltac default_auto ::= auto with lngen brute_force; tauto.
Ltac default_autorewrite ::= autorewrite with lngen.

Lemma degree_tm_wrt_tm_of_lc_tm_degree_brs_wrt_tm_of_lc_brs_degree_co_wrt_tm_of_lc_co_degree_constraint_wrt_tm_of_lc_constraint_mutual :
(forall a1,
  lc_tm a1 ->
  degree_tm_wrt_tm 0 a1) /\
(forall brs1,
  lc_brs brs1 ->
  degree_brs_wrt_tm 0 brs1) /\
(forall g1,
  lc_co g1 ->
  degree_co_wrt_tm 0 g1) /\
(forall phi1,
  lc_constraint phi1 ->
  degree_constraint_wrt_tm 0 phi1).

Lemma degree_tm_wrt_tm_of_lc_tm :
forall a1,
  lc_tm a1 ->
  degree_tm_wrt_tm 0 a1.

Hint Resolve degree_tm_wrt_tm_of_lc_tm : lngen.

Lemma degree_brs_wrt_tm_of_lc_brs :
forall brs1,
  lc_brs brs1 ->
  degree_brs_wrt_tm 0 brs1.

Hint Resolve degree_brs_wrt_tm_of_lc_brs : lngen.

Lemma degree_co_wrt_tm_of_lc_co :
forall g1,
  lc_co g1 ->
  degree_co_wrt_tm 0 g1.

Hint Resolve degree_co_wrt_tm_of_lc_co : lngen.

Lemma degree_constraint_wrt_tm_of_lc_constraint :
forall phi1,
  lc_constraint phi1 ->
  degree_constraint_wrt_tm 0 phi1.

Hint Resolve degree_constraint_wrt_tm_of_lc_constraint : lngen.

Lemma degree_tm_wrt_co_of_lc_tm_degree_brs_wrt_co_of_lc_brs_degree_co_wrt_co_of_lc_co_degree_constraint_wrt_co_of_lc_constraint_mutual :
(forall a1,
  lc_tm a1 ->
  degree_tm_wrt_co 0 a1) /\
(forall brs1,
  lc_brs brs1 ->
  degree_brs_wrt_co 0 brs1) /\
(forall g1,
  lc_co g1 ->
  degree_co_wrt_co 0 g1) /\
(forall phi1,
  lc_constraint phi1 ->
  degree_constraint_wrt_co 0 phi1).

Lemma degree_tm_wrt_co_of_lc_tm :
forall a1,
  lc_tm a1 ->
  degree_tm_wrt_co 0 a1.

Hint Resolve degree_tm_wrt_co_of_lc_tm : lngen.

Lemma degree_brs_wrt_co_of_lc_brs :
forall brs1,
  lc_brs brs1 ->
  degree_brs_wrt_co 0 brs1.

Hint Resolve degree_brs_wrt_co_of_lc_brs : lngen.

Lemma degree_co_wrt_co_of_lc_co :
forall g1,
  lc_co g1 ->
  degree_co_wrt_co 0 g1.

Hint Resolve degree_co_wrt_co_of_lc_co : lngen.

Lemma degree_constraint_wrt_co_of_lc_constraint :
forall phi1,
  lc_constraint phi1 ->
  degree_constraint_wrt_co 0 phi1.

Hint Resolve degree_constraint_wrt_co_of_lc_constraint : lngen.

Lemma lc_tm_of_degree_lc_brs_of_degree_lc_co_of_degree_lc_constraint_of_degree_size_mutual :
forall i1,
(forall a1,
  size_tm a1 = i1 ->
  degree_tm_wrt_tm 0 a1 ->
  degree_tm_wrt_co 0 a1 ->
  lc_tm a1) /\
(forall brs1,
  size_brs brs1 = i1 ->
  degree_brs_wrt_tm 0 brs1 ->
  degree_brs_wrt_co 0 brs1 ->
  lc_brs brs1) /\
(forall g1,
  size_co g1 = i1 ->
  degree_co_wrt_tm 0 g1 ->
  degree_co_wrt_co 0 g1 ->
  lc_co g1) /\
(forall phi1,
  size_constraint phi1 = i1 ->
  degree_constraint_wrt_tm 0 phi1 ->
  degree_constraint_wrt_co 0 phi1 ->
  lc_constraint phi1).

Lemma lc_tm_of_degree :
forall a1,
  degree_tm_wrt_tm 0 a1 ->
  degree_tm_wrt_co 0 a1 ->
  lc_tm a1.

Hint Resolve lc_tm_of_degree : lngen.

Lemma lc_brs_of_degree :
forall brs1,
  degree_brs_wrt_tm 0 brs1 ->
  degree_brs_wrt_co 0 brs1 ->
  lc_brs brs1.

Hint Resolve lc_brs_of_degree : lngen.

Lemma lc_co_of_degree :
forall g1,
  degree_co_wrt_tm 0 g1 ->
  degree_co_wrt_co 0 g1 ->
  lc_co g1.

Hint Resolve lc_co_of_degree : lngen.

Lemma lc_constraint_of_degree :
forall phi1,
  degree_constraint_wrt_tm 0 phi1 ->
  degree_constraint_wrt_co 0 phi1 ->
  lc_constraint phi1.

Hint Resolve lc_constraint_of_degree : lngen.

Ltac relflag_lc_exists_tac :=
  repeat (match goal with
            | H : _ |- _ =>
              fail 1
          end).

Ltac tm_brs_co_constraint_lc_exists_tac :=
  repeat (match goal with
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_tm_wrt_tm_of_lc_tm in J1;
              let J2 := fresh in pose proof H as J2; apply degree_tm_wrt_co_of_lc_tm in J2; clear H
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_brs_wrt_tm_of_lc_brs in J1;
              let J2 := fresh in pose proof H as J2; apply degree_brs_wrt_co_of_lc_brs in J2; clear H
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_co_wrt_tm_of_lc_co in J1;
              let J2 := fresh in pose proof H as J2; apply degree_co_wrt_co_of_lc_co in J2; clear H
            | H : _ |- _ =>
              let J1 := fresh in pose proof H as J1; apply degree_constraint_wrt_tm_of_lc_constraint in J1;
              let J2 := fresh in pose proof H as J2; apply degree_constraint_wrt_co_of_lc_constraint in J2; clear H
          end).

Lemma lc_a_Abs_exists :
forall x1 rho1 A1 b1,
  lc_tm A1 ->
  lc_tm (open_tm_wrt_tm b1 (a_Var_f x1)) ->
  lc_tm (a_Abs rho1 A1 b1).

Lemma lc_a_UAbs_exists :
forall x1 rho1 b1,
  lc_tm (open_tm_wrt_tm b1 (a_Var_f x1)) ->
  lc_tm (a_UAbs rho1 b1).

Lemma lc_a_Pi_exists :
forall x1 rho1 A1 B1,
  lc_tm A1 ->
  lc_tm (open_tm_wrt_tm B1 (a_Var_f x1)) ->
  lc_tm (a_Pi rho1 A1 B1).

Lemma lc_a_CPi_exists :
forall c1 phi1 B1,
  lc_constraint phi1 ->
  lc_tm (open_tm_wrt_co B1 (g_Var_f c1)) ->
  lc_tm (a_CPi phi1 B1).

Lemma lc_a_CAbs_exists :
forall c1 phi1 b1,
  lc_constraint phi1 ->
  lc_tm (open_tm_wrt_co b1 (g_Var_f c1)) ->
  lc_tm (a_CAbs phi1 b1).

Lemma lc_a_UCAbs_exists :
forall c1 b1,
  lc_tm (open_tm_wrt_co b1 (g_Var_f c1)) ->
  lc_tm (a_UCAbs b1).

Lemma lc_g_PiCong_exists :
forall x1 rho1 g1 g2,
  lc_co g1 ->
  lc_co (open_co_wrt_tm g2 (a_Var_f x1)) ->
  lc_co (g_PiCong rho1 g1 g2).

Lemma lc_g_AbsCong_exists :
forall x1 rho1 g1 g2,
  lc_co g1 ->
  lc_co (open_co_wrt_tm g2 (a_Var_f x1)) ->
  lc_co (g_AbsCong rho1 g1 g2).

Lemma lc_g_CPiCong_exists :
forall c1 g1 g2,
  lc_co g1 ->
  lc_co (open_co_wrt_co g2 (g_Var_f c1)) ->
  lc_co (g_CPiCong g1 g2).

Lemma lc_g_CAbsCong_exists :
forall c1 g1 g2 g3,
  lc_co g1 ->
  lc_co (open_co_wrt_co g2 (g_Var_f c1)) ->
  lc_co g3 ->
  lc_co (g_CAbsCong g1 g2 g3).

Hint Extern 1 (lc_tm (a_Abs _ _ _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_a_Abs_exists x1).

Hint Extern 1 (lc_tm (a_UAbs _ _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_a_UAbs_exists x1).

Hint Extern 1 (lc_tm (a_Pi _ _ _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_a_Pi_exists x1).

Hint Extern 1 (lc_tm (a_CPi _ _)) =>
  let c1 := fresh in
  pick_fresh c1;
  apply (lc_a_CPi_exists c1).

Hint Extern 1 (lc_tm (a_CAbs _ _)) =>
  let c1 := fresh in
  pick_fresh c1;
  apply (lc_a_CAbs_exists c1).

Hint Extern 1 (lc_tm (a_UCAbs _)) =>
  let c1 := fresh in
  pick_fresh c1;
  apply (lc_a_UCAbs_exists c1).

Hint Extern 1 (lc_co (g_PiCong _ _ _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_g_PiCong_exists x1).

Hint Extern 1 (lc_co (g_AbsCong _ _ _)) =>
  let x1 := fresh in
  pick_fresh x1;
  apply (lc_g_AbsCong_exists x1).

Hint Extern 1 (lc_co (g_CPiCong _ _)) =>
  let c1 := fresh in
  pick_fresh c1;
  apply (lc_g_CPiCong_exists c1).

Hint Extern 1 (lc_co (g_CAbsCong _ _ _)) =>
  let c1 := fresh in
  pick_fresh c1;
  apply (lc_g_CAbsCong_exists c1).

Lemma lc_body_tm_wrt_tm :
forall a1 a2,
  body_tm_wrt_tm a1 ->
  lc_tm a2 ->
  lc_tm (open_tm_wrt_tm a1 a2).

Hint Resolve lc_body_tm_wrt_tm : lngen.

Lemma lc_body_brs_wrt_tm :
forall brs1 a1,
  body_brs_wrt_tm brs1 ->
  lc_tm a1 ->
  lc_brs (open_brs_wrt_tm brs1 a1).

Hint Resolve lc_body_brs_wrt_tm : lngen.

Lemma lc_body_co_wrt_tm :
forall g1 a1,
  body_co_wrt_tm g1 ->
  lc_tm a1 ->
  lc_co (open_co_wrt_tm g1 a1).

Hint Resolve lc_body_co_wrt_tm : lngen.

Lemma lc_body_constraint_wrt_tm :
forall phi1 a1,
  body_constraint_wrt_tm phi1 ->
  lc_tm a1 ->
  lc_constraint (open_constraint_wrt_tm phi1 a1).

Hint Resolve lc_body_constraint_wrt_tm : lngen.

Lemma lc_body_tm_wrt_co :
forall a1 g1,
  body_tm_wrt_co a1 ->
  lc_co g1 ->
  lc_tm (open_tm_wrt_co a1 g1).

Hint Resolve lc_body_tm_wrt_co : lngen.

Lemma lc_body_brs_wrt_co :
forall brs1 g1,
  body_brs_wrt_co brs1 ->
  lc_co g1 ->
  lc_brs (open_brs_wrt_co brs1 g1).

Hint Resolve lc_body_brs_wrt_co : lngen.

Lemma lc_body_co_wrt_co :
forall g1 g2,
  body_co_wrt_co g1 ->
  lc_co g2 ->
  lc_co (open_co_wrt_co g1 g2).

Hint Resolve lc_body_co_wrt_co : lngen.

Lemma lc_body_constraint_wrt_co :
forall phi1 g1,
  body_constraint_wrt_co phi1 ->
  lc_co g1 ->
  lc_constraint (open_constraint_wrt_co phi1 g1).

Hint Resolve lc_body_constraint_wrt_co : lngen.

Lemma lc_body_a_Abs_3 :
forall rho1 A1 b1,
  lc_tm (a_Abs rho1 A1 b1) ->
  body_tm_wrt_tm b1.

Hint Resolve lc_body_a_Abs_3 : lngen.

Lemma lc_body_a_UAbs_2 :
forall rho1 b1,
  lc_tm (a_UAbs rho1 b1) ->
  body_tm_wrt_tm b1.

Hint Resolve lc_body_a_UAbs_2 : lngen.

Lemma lc_body_a_Pi_3 :
forall rho1 A1 B1,
  lc_tm (a_Pi rho1 A1 B1) ->
  body_tm_wrt_tm B1.

Hint Resolve lc_body_a_Pi_3 : lngen.

Lemma lc_body_a_CPi_2 :
forall phi1 B1,
  lc_tm (a_CPi phi1 B1) ->
  body_tm_wrt_co B1.

Hint Resolve lc_body_a_CPi_2 : lngen.

Lemma lc_body_a_CAbs_2 :
forall phi1 b1,
  lc_tm (a_CAbs phi1 b1) ->
  body_tm_wrt_co b1.

Hint Resolve lc_body_a_CAbs_2 : lngen.

Lemma lc_body_a_UCAbs_1 :
forall b1,
  lc_tm (a_UCAbs b1) ->
  body_tm_wrt_co b1.

Hint Resolve lc_body_a_UCAbs_1 : lngen.

Lemma lc_body_g_PiCong_3 :
forall rho1 g1 g2,
  lc_co (g_PiCong rho1 g1 g2) ->
  body_co_wrt_tm g2.

Hint Resolve lc_body_g_PiCong_3 : lngen.

Lemma lc_body_g_AbsCong_3 :
forall rho1 g1 g2,
  lc_co (g_AbsCong rho1 g1 g2) ->
  body_co_wrt_tm g2.

Hint Resolve lc_body_g_AbsCong_3 : lngen.

Lemma lc_body_g_CPiCong_2 :
forall g1 g2,
  lc_co (g_CPiCong g1 g2) ->
  body_co_wrt_co g2.

Hint Resolve lc_body_g_CPiCong_2 : lngen.

Lemma lc_body_g_CAbsCong_2 :
forall g1 g2 g3,
  lc_co (g_CAbsCong g1 g2 g3) ->
  body_co_wrt_co g2.

Hint Resolve lc_body_g_CAbsCong_2 : lngen.

Lemma lc_tm_unique_lc_brs_unique_lc_co_unique_lc_constraint_unique_mutual :
(forall a1 (proof2 proof3 : lc_tm a1), proof2 = proof3) /\
(forall brs1 (proof2 proof3 : lc_brs brs1), proof2 = proof3) /\
(forall g1 (proof2 proof3 : lc_co g1), proof2 = proof3) /\
(forall phi1 (proof2 proof3 : lc_constraint phi1), proof2 = proof3).

Lemma lc_tm_unique :
forall a1 (proof2 proof3 : lc_tm a1), proof2 = proof3.

Hint Resolve lc_tm_unique : lngen.

Lemma lc_brs_unique :
forall brs1 (proof2 proof3 : lc_brs brs1), proof2 = proof3.

Hint Resolve lc_brs_unique : lngen.

Lemma lc_co_unique :
forall g1 (proof2 proof3 : lc_co g1), proof2 = proof3.

Hint Resolve lc_co_unique : lngen.

Lemma lc_constraint_unique :
forall phi1 (proof2 proof3 : lc_constraint phi1), proof2 = proof3.

Hint Resolve lc_constraint_unique : lngen.

Lemma lc_tm_of_lc_set_tm_lc_brs_of_lc_set_brs_lc_co_of_lc_set_co_lc_constraint_of_lc_set_constraint_mutual :
(forall a1, lc_set_tm a1 -> lc_tm a1) /\
(forall brs1, lc_set_brs brs1 -> lc_brs brs1) /\
(forall g1, lc_set_co g1 -> lc_co g1) /\
(forall phi1, lc_set_constraint phi1 -> lc_constraint phi1).

Lemma lc_tm_of_lc_set_tm :
forall a1, lc_set_tm a1 -> lc_tm a1.

Hint Resolve lc_tm_of_lc_set_tm : lngen.

Lemma lc_brs_of_lc_set_brs :
forall brs1, lc_set_brs brs1 -> lc_brs brs1.

Hint Resolve lc_brs_of_lc_set_brs : lngen.

Lemma lc_co_of_lc_set_co :
forall g1, lc_set_co g1 -> lc_co g1.

Hint Resolve lc_co_of_lc_set_co : lngen.

Lemma lc_constraint_of_lc_set_constraint :
forall phi1, lc_set_constraint phi1 -> lc_constraint phi1.

Hint Resolve lc_constraint_of_lc_set_constraint : lngen.

Lemma lc_set_tm_of_lc_tm_lc_set_brs_of_lc_brs_lc_set_co_of_lc_co_lc_set_constraint_of_lc_constraint_size_mutual :
forall i1,
(forall a1,
  size_tm a1 = i1 ->
  lc_tm a1 ->
  lc_set_tm a1) *
(forall brs1,
  size_brs brs1 = i1 ->
  lc_brs brs1 ->
  lc_set_brs brs1) *
(forall g1,
  size_co g1 = i1 ->
  lc_co g1 ->
  lc_set_co g1) *
(forall phi1,
  size_constraint phi1 = i1 ->
  lc_constraint phi1 ->
  lc_set_constraint phi1).

Lemma lc_set_tm_of_lc_tm :
forall a1,
  lc_tm a1 ->
  lc_set_tm a1.

Hint Resolve lc_set_tm_of_lc_tm : lngen.

Lemma lc_set_brs_of_lc_brs :
forall brs1,
  lc_brs brs1 ->
  lc_set_brs brs1.

Hint Resolve lc_set_brs_of_lc_brs : lngen.

Lemma lc_set_co_of_lc_co :
forall g1,
  lc_co g1 ->
  lc_set_co g1.

Hint Resolve lc_set_co_of_lc_co : lngen.

Lemma lc_set_constraint_of_lc_constraint :
forall phi1,
  lc_constraint phi1 ->
  lc_set_constraint phi1.

Hint Resolve lc_set_constraint_of_lc_constraint : lngen.

Ltac default_auto ::= auto with lngen; tauto.
Ltac default_autorewrite ::= fail.

Lemma close_tm_wrt_tm_rec_degree_tm_wrt_tm_close_brs_wrt_tm_rec_degree_brs_wrt_tm_close_co_wrt_tm_rec_degree_co_wrt_tm_close_constraint_wrt_tm_rec_degree_constraint_wrt_tm_mutual :
(forall a1 x1 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  close_tm_wrt_tm_rec n1 x1 a1 = a1) /\
(forall brs1 x1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  x1 `notin` fv_tm_tm_brs brs1 ->
  close_brs_wrt_tm_rec n1 x1 brs1 = brs1) /\
(forall g1 x1 n1,
  degree_co_wrt_tm n1 g1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  close_co_wrt_tm_rec n1 x1 g1 = g1) /\
(forall phi1 x1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  x1 `notin` fv_tm_tm_constraint phi1 ->
  close_constraint_wrt_tm_rec n1 x1 phi1 = phi1).

Lemma close_tm_wrt_tm_rec_degree_tm_wrt_tm :
forall a1 x1 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  close_tm_wrt_tm_rec n1 x1 a1 = a1.

Hint Resolve close_tm_wrt_tm_rec_degree_tm_wrt_tm : lngen.
Hint Rewrite close_tm_wrt_tm_rec_degree_tm_wrt_tm using solve [auto] : lngen.

Lemma close_brs_wrt_tm_rec_degree_brs_wrt_tm :
forall brs1 x1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  x1 `notin` fv_tm_tm_brs brs1 ->
  close_brs_wrt_tm_rec n1 x1 brs1 = brs1.

Hint Resolve close_brs_wrt_tm_rec_degree_brs_wrt_tm : lngen.
Hint Rewrite close_brs_wrt_tm_rec_degree_brs_wrt_tm using solve [auto] : lngen.

Lemma close_co_wrt_tm_rec_degree_co_wrt_tm :
forall g1 x1 n1,
  degree_co_wrt_tm n1 g1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  close_co_wrt_tm_rec n1 x1 g1 = g1.

Hint Resolve close_co_wrt_tm_rec_degree_co_wrt_tm : lngen.
Hint Rewrite close_co_wrt_tm_rec_degree_co_wrt_tm using solve [auto] : lngen.

Lemma close_constraint_wrt_tm_rec_degree_constraint_wrt_tm :
forall phi1 x1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  x1 `notin` fv_tm_tm_constraint phi1 ->
  close_constraint_wrt_tm_rec n1 x1 phi1 = phi1.

Hint Resolve close_constraint_wrt_tm_rec_degree_constraint_wrt_tm : lngen.
Hint Rewrite close_constraint_wrt_tm_rec_degree_constraint_wrt_tm using solve [auto] : lngen.

Lemma close_tm_wrt_co_rec_degree_tm_wrt_co_close_brs_wrt_co_rec_degree_brs_wrt_co_close_co_wrt_co_rec_degree_co_wrt_co_close_constraint_wrt_co_rec_degree_constraint_wrt_co_mutual :
(forall a1 c1 n1,
  degree_tm_wrt_co n1 a1 ->
  c1 `notin` fv_co_co_tm a1 ->
  close_tm_wrt_co_rec n1 c1 a1 = a1) /\
(forall brs1 c1 n1,
  degree_brs_wrt_co n1 brs1 ->
  c1 `notin` fv_co_co_brs brs1 ->
  close_brs_wrt_co_rec n1 c1 brs1 = brs1) /\
(forall g1 c1 n1,
  degree_co_wrt_co n1 g1 ->
  c1 `notin` fv_co_co_co g1 ->
  close_co_wrt_co_rec n1 c1 g1 = g1) /\
(forall phi1 c1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  c1 `notin` fv_co_co_constraint phi1 ->
  close_constraint_wrt_co_rec n1 c1 phi1 = phi1).

Lemma close_tm_wrt_co_rec_degree_tm_wrt_co :
forall a1 c1 n1,
  degree_tm_wrt_co n1 a1 ->
  c1 `notin` fv_co_co_tm a1 ->
  close_tm_wrt_co_rec n1 c1 a1 = a1.

Hint Resolve close_tm_wrt_co_rec_degree_tm_wrt_co : lngen.
Hint Rewrite close_tm_wrt_co_rec_degree_tm_wrt_co using solve [auto] : lngen.

Lemma close_brs_wrt_co_rec_degree_brs_wrt_co :
forall brs1 c1 n1,
  degree_brs_wrt_co n1 brs1 ->
  c1 `notin` fv_co_co_brs brs1 ->
  close_brs_wrt_co_rec n1 c1 brs1 = brs1.

Hint Resolve close_brs_wrt_co_rec_degree_brs_wrt_co : lngen.
Hint Rewrite close_brs_wrt_co_rec_degree_brs_wrt_co using solve [auto] : lngen.

Lemma close_co_wrt_co_rec_degree_co_wrt_co :
forall g1 c1 n1,
  degree_co_wrt_co n1 g1 ->
  c1 `notin` fv_co_co_co g1 ->
  close_co_wrt_co_rec n1 c1 g1 = g1.

Hint Resolve close_co_wrt_co_rec_degree_co_wrt_co : lngen.
Hint Rewrite close_co_wrt_co_rec_degree_co_wrt_co using solve [auto] : lngen.

Lemma close_constraint_wrt_co_rec_degree_constraint_wrt_co :
forall phi1 c1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  c1 `notin` fv_co_co_constraint phi1 ->
  close_constraint_wrt_co_rec n1 c1 phi1 = phi1.

Hint Resolve close_constraint_wrt_co_rec_degree_constraint_wrt_co : lngen.
Hint Rewrite close_constraint_wrt_co_rec_degree_constraint_wrt_co using solve [auto] : lngen.

Lemma close_tm_wrt_tm_lc_tm :
forall a1 x1,
  lc_tm a1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  close_tm_wrt_tm x1 a1 = a1.

Hint Resolve close_tm_wrt_tm_lc_tm : lngen.
Hint Rewrite close_tm_wrt_tm_lc_tm using solve [auto] : lngen.

Lemma close_brs_wrt_tm_lc_brs :
forall brs1 x1,
  lc_brs brs1 ->
  x1 `notin` fv_tm_tm_brs brs1 ->
  close_brs_wrt_tm x1 brs1 = brs1.

Hint Resolve close_brs_wrt_tm_lc_brs : lngen.
Hint Rewrite close_brs_wrt_tm_lc_brs using solve [auto] : lngen.

Lemma close_co_wrt_tm_lc_co :
forall g1 x1,
  lc_co g1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  close_co_wrt_tm x1 g1 = g1.

Hint Resolve close_co_wrt_tm_lc_co : lngen.
Hint Rewrite close_co_wrt_tm_lc_co using solve [auto] : lngen.

Lemma close_constraint_wrt_tm_lc_constraint :
forall phi1 x1,
  lc_constraint phi1 ->
  x1 `notin` fv_tm_tm_constraint phi1 ->
  close_constraint_wrt_tm x1 phi1 = phi1.

Hint Resolve close_constraint_wrt_tm_lc_constraint : lngen.
Hint Rewrite close_constraint_wrt_tm_lc_constraint using solve [auto] : lngen.

Lemma close_tm_wrt_co_lc_tm :
forall a1 c1,
  lc_tm a1 ->
  c1 `notin` fv_co_co_tm a1 ->
  close_tm_wrt_co c1 a1 = a1.

Hint Resolve close_tm_wrt_co_lc_tm : lngen.
Hint Rewrite close_tm_wrt_co_lc_tm using solve [auto] : lngen.

Lemma close_brs_wrt_co_lc_brs :
forall brs1 c1,
  lc_brs brs1 ->
  c1 `notin` fv_co_co_brs brs1 ->
  close_brs_wrt_co c1 brs1 = brs1.

Hint Resolve close_brs_wrt_co_lc_brs : lngen.
Hint Rewrite close_brs_wrt_co_lc_brs using solve [auto] : lngen.

Lemma close_co_wrt_co_lc_co :
forall g1 c1,
  lc_co g1 ->
  c1 `notin` fv_co_co_co g1 ->
  close_co_wrt_co c1 g1 = g1.

Hint Resolve close_co_wrt_co_lc_co : lngen.
Hint Rewrite close_co_wrt_co_lc_co using solve [auto] : lngen.

Lemma close_constraint_wrt_co_lc_constraint :
forall phi1 c1,
  lc_constraint phi1 ->
  c1 `notin` fv_co_co_constraint phi1 ->
  close_constraint_wrt_co c1 phi1 = phi1.

Hint Resolve close_constraint_wrt_co_lc_constraint : lngen.
Hint Rewrite close_constraint_wrt_co_lc_constraint using solve [auto] : lngen.

Lemma open_tm_wrt_tm_rec_degree_tm_wrt_tm_open_brs_wrt_tm_rec_degree_brs_wrt_tm_open_co_wrt_tm_rec_degree_co_wrt_tm_open_constraint_wrt_tm_rec_degree_constraint_wrt_tm_mutual :
(forall a2 a1 n1,
  degree_tm_wrt_tm n1 a2 ->
  open_tm_wrt_tm_rec n1 a1 a2 = a2) /\
(forall brs1 a1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  open_brs_wrt_tm_rec n1 a1 brs1 = brs1) /\
(forall g1 a1 n1,
  degree_co_wrt_tm n1 g1 ->
  open_co_wrt_tm_rec n1 a1 g1 = g1) /\
(forall phi1 a1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  open_constraint_wrt_tm_rec n1 a1 phi1 = phi1).

Lemma open_tm_wrt_tm_rec_degree_tm_wrt_tm :
forall a2 a1 n1,
  degree_tm_wrt_tm n1 a2 ->
  open_tm_wrt_tm_rec n1 a1 a2 = a2.

Hint Resolve open_tm_wrt_tm_rec_degree_tm_wrt_tm : lngen.
Hint Rewrite open_tm_wrt_tm_rec_degree_tm_wrt_tm using solve [auto] : lngen.

Lemma open_brs_wrt_tm_rec_degree_brs_wrt_tm :
forall brs1 a1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  open_brs_wrt_tm_rec n1 a1 brs1 = brs1.

Hint Resolve open_brs_wrt_tm_rec_degree_brs_wrt_tm : lngen.
Hint Rewrite open_brs_wrt_tm_rec_degree_brs_wrt_tm using solve [auto] : lngen.

Lemma open_co_wrt_tm_rec_degree_co_wrt_tm :
forall g1 a1 n1,
  degree_co_wrt_tm n1 g1 ->
  open_co_wrt_tm_rec n1 a1 g1 = g1.

Hint Resolve open_co_wrt_tm_rec_degree_co_wrt_tm : lngen.
Hint Rewrite open_co_wrt_tm_rec_degree_co_wrt_tm using solve [auto] : lngen.

Lemma open_constraint_wrt_tm_rec_degree_constraint_wrt_tm :
forall phi1 a1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  open_constraint_wrt_tm_rec n1 a1 phi1 = phi1.

Hint Resolve open_constraint_wrt_tm_rec_degree_constraint_wrt_tm : lngen.
Hint Rewrite open_constraint_wrt_tm_rec_degree_constraint_wrt_tm using solve [auto] : lngen.

Lemma open_tm_wrt_co_rec_degree_tm_wrt_co_open_brs_wrt_co_rec_degree_brs_wrt_co_open_co_wrt_co_rec_degree_co_wrt_co_open_constraint_wrt_co_rec_degree_constraint_wrt_co_mutual :
(forall a1 g1 n1,
  degree_tm_wrt_co n1 a1 ->
  open_tm_wrt_co_rec n1 g1 a1 = a1) /\
(forall brs1 g1 n1,
  degree_brs_wrt_co n1 brs1 ->
  open_brs_wrt_co_rec n1 g1 brs1 = brs1) /\
(forall g2 g1 n1,
  degree_co_wrt_co n1 g2 ->
  open_co_wrt_co_rec n1 g1 g2 = g2) /\
(forall phi1 g1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  open_constraint_wrt_co_rec n1 g1 phi1 = phi1).

Lemma open_tm_wrt_co_rec_degree_tm_wrt_co :
forall a1 g1 n1,
  degree_tm_wrt_co n1 a1 ->
  open_tm_wrt_co_rec n1 g1 a1 = a1.

Hint Resolve open_tm_wrt_co_rec_degree_tm_wrt_co : lngen.
Hint Rewrite open_tm_wrt_co_rec_degree_tm_wrt_co using solve [auto] : lngen.

Lemma open_brs_wrt_co_rec_degree_brs_wrt_co :
forall brs1 g1 n1,
  degree_brs_wrt_co n1 brs1 ->
  open_brs_wrt_co_rec n1 g1 brs1 = brs1.

Hint Resolve open_brs_wrt_co_rec_degree_brs_wrt_co : lngen.
Hint Rewrite open_brs_wrt_co_rec_degree_brs_wrt_co using solve [auto] : lngen.

Lemma open_co_wrt_co_rec_degree_co_wrt_co :
forall g2 g1 n1,
  degree_co_wrt_co n1 g2 ->
  open_co_wrt_co_rec n1 g1 g2 = g2.

Hint Resolve open_co_wrt_co_rec_degree_co_wrt_co : lngen.
Hint Rewrite open_co_wrt_co_rec_degree_co_wrt_co using solve [auto] : lngen.

Lemma open_constraint_wrt_co_rec_degree_constraint_wrt_co :
forall phi1 g1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  open_constraint_wrt_co_rec n1 g1 phi1 = phi1.

Hint Resolve open_constraint_wrt_co_rec_degree_constraint_wrt_co : lngen.
Hint Rewrite open_constraint_wrt_co_rec_degree_constraint_wrt_co using solve [auto] : lngen.

Lemma open_tm_wrt_tm_lc_tm :
forall a2 a1,
  lc_tm a2 ->
  open_tm_wrt_tm a2 a1 = a2.

Hint Resolve open_tm_wrt_tm_lc_tm : lngen.
Hint Rewrite open_tm_wrt_tm_lc_tm using solve [auto] : lngen.

Lemma open_brs_wrt_tm_lc_brs :
forall brs1 a1,
  lc_brs brs1 ->
  open_brs_wrt_tm brs1 a1 = brs1.

Hint Resolve open_brs_wrt_tm_lc_brs : lngen.
Hint Rewrite open_brs_wrt_tm_lc_brs using solve [auto] : lngen.

Lemma open_co_wrt_tm_lc_co :
forall g1 a1,
  lc_co g1 ->
  open_co_wrt_tm g1 a1 = g1.

Hint Resolve open_co_wrt_tm_lc_co : lngen.
Hint Rewrite open_co_wrt_tm_lc_co using solve [auto] : lngen.

Lemma open_constraint_wrt_tm_lc_constraint :
forall phi1 a1,
  lc_constraint phi1 ->
  open_constraint_wrt_tm phi1 a1 = phi1.

Hint Resolve open_constraint_wrt_tm_lc_constraint : lngen.
Hint Rewrite open_constraint_wrt_tm_lc_constraint using solve [auto] : lngen.

Lemma open_tm_wrt_co_lc_tm :
forall a1 g1,
  lc_tm a1 ->
  open_tm_wrt_co a1 g1 = a1.

Hint Resolve open_tm_wrt_co_lc_tm : lngen.
Hint Rewrite open_tm_wrt_co_lc_tm using solve [auto] : lngen.

Lemma open_brs_wrt_co_lc_brs :
forall brs1 g1,
  lc_brs brs1 ->
  open_brs_wrt_co brs1 g1 = brs1.

Hint Resolve open_brs_wrt_co_lc_brs : lngen.
Hint Rewrite open_brs_wrt_co_lc_brs using solve [auto] : lngen.

Lemma open_co_wrt_co_lc_co :
forall g2 g1,
  lc_co g2 ->
  open_co_wrt_co g2 g1 = g2.

Hint Resolve open_co_wrt_co_lc_co : lngen.
Hint Rewrite open_co_wrt_co_lc_co using solve [auto] : lngen.

Lemma open_constraint_wrt_co_lc_constraint :
forall phi1 g1,
  lc_constraint phi1 ->
  open_constraint_wrt_co phi1 g1 = phi1.

Hint Resolve open_constraint_wrt_co_lc_constraint : lngen.
Hint Rewrite open_constraint_wrt_co_lc_constraint using solve [auto] : lngen.

Ltac default_auto ::= auto with set lngen; tauto.
Ltac default_autorewrite ::= autorewrite with lngen.

Lemma fv_tm_tm_tm_close_tm_wrt_tm_rec_fv_tm_tm_brs_close_brs_wrt_tm_rec_fv_tm_tm_co_close_co_wrt_tm_rec_fv_tm_tm_constraint_close_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1,
  fv_tm_tm_tm (close_tm_wrt_tm_rec n1 x1 a1) [=] remove x1 (fv_tm_tm_tm a1)) /\
(forall brs1 x1 n1,
  fv_tm_tm_brs (close_brs_wrt_tm_rec n1 x1 brs1) [=] remove x1 (fv_tm_tm_brs brs1)) /\
(forall g1 x1 n1,
  fv_tm_tm_co (close_co_wrt_tm_rec n1 x1 g1) [=] remove x1 (fv_tm_tm_co g1)) /\
(forall phi1 x1 n1,
  fv_tm_tm_constraint (close_constraint_wrt_tm_rec n1 x1 phi1) [=] remove x1 (fv_tm_tm_constraint phi1)).

Lemma fv_tm_tm_tm_close_tm_wrt_tm_rec :
forall a1 x1 n1,
  fv_tm_tm_tm (close_tm_wrt_tm_rec n1 x1 a1) [=] remove x1 (fv_tm_tm_tm a1).

Hint Resolve fv_tm_tm_tm_close_tm_wrt_tm_rec : lngen.
Hint Rewrite fv_tm_tm_tm_close_tm_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_tm_tm_brs_close_brs_wrt_tm_rec :
forall brs1 x1 n1,
  fv_tm_tm_brs (close_brs_wrt_tm_rec n1 x1 brs1) [=] remove x1 (fv_tm_tm_brs brs1).

Hint Resolve fv_tm_tm_brs_close_brs_wrt_tm_rec : lngen.
Hint Rewrite fv_tm_tm_brs_close_brs_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_tm_tm_co_close_co_wrt_tm_rec :
forall g1 x1 n1,
  fv_tm_tm_co (close_co_wrt_tm_rec n1 x1 g1) [=] remove x1 (fv_tm_tm_co g1).

Hint Resolve fv_tm_tm_co_close_co_wrt_tm_rec : lngen.
Hint Rewrite fv_tm_tm_co_close_co_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_tm_tm_constraint_close_constraint_wrt_tm_rec :
forall phi1 x1 n1,
  fv_tm_tm_constraint (close_constraint_wrt_tm_rec n1 x1 phi1) [=] remove x1 (fv_tm_tm_constraint phi1).

Hint Resolve fv_tm_tm_constraint_close_constraint_wrt_tm_rec : lngen.
Hint Rewrite fv_tm_tm_constraint_close_constraint_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_tm_tm_tm_close_tm_wrt_co_rec_fv_tm_tm_brs_close_brs_wrt_co_rec_fv_tm_tm_co_close_co_wrt_co_rec_fv_tm_tm_constraint_close_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1,
  fv_tm_tm_tm (close_tm_wrt_co_rec n1 c1 a1) [=] fv_tm_tm_tm a1) /\
(forall brs1 c1 n1,
  fv_tm_tm_brs (close_brs_wrt_co_rec n1 c1 brs1) [=] fv_tm_tm_brs brs1) /\
(forall g1 c1 n1,
  fv_tm_tm_co (close_co_wrt_co_rec n1 c1 g1) [=] fv_tm_tm_co g1) /\
(forall phi1 c1 n1,
  fv_tm_tm_constraint (close_constraint_wrt_co_rec n1 c1 phi1) [=] fv_tm_tm_constraint phi1).

Lemma fv_tm_tm_tm_close_tm_wrt_co_rec :
forall a1 c1 n1,
  fv_tm_tm_tm (close_tm_wrt_co_rec n1 c1 a1) [=] fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_close_tm_wrt_co_rec : lngen.
Hint Rewrite fv_tm_tm_tm_close_tm_wrt_co_rec using solve [auto] : lngen.

Lemma fv_tm_tm_brs_close_brs_wrt_co_rec :
forall brs1 c1 n1,
  fv_tm_tm_brs (close_brs_wrt_co_rec n1 c1 brs1) [=] fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_close_brs_wrt_co_rec : lngen.
Hint Rewrite fv_tm_tm_brs_close_brs_wrt_co_rec using solve [auto] : lngen.

Lemma fv_tm_tm_co_close_co_wrt_co_rec :
forall g1 c1 n1,
  fv_tm_tm_co (close_co_wrt_co_rec n1 c1 g1) [=] fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_close_co_wrt_co_rec : lngen.
Hint Rewrite fv_tm_tm_co_close_co_wrt_co_rec using solve [auto] : lngen.

Lemma fv_tm_tm_constraint_close_constraint_wrt_co_rec :
forall phi1 c1 n1,
  fv_tm_tm_constraint (close_constraint_wrt_co_rec n1 c1 phi1) [=] fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_close_constraint_wrt_co_rec : lngen.
Hint Rewrite fv_tm_tm_constraint_close_constraint_wrt_co_rec using solve [auto] : lngen.

Lemma fv_co_co_tm_close_tm_wrt_tm_rec_fv_co_co_brs_close_brs_wrt_tm_rec_fv_co_co_co_close_co_wrt_tm_rec_fv_co_co_constraint_close_constraint_wrt_tm_rec_mutual :
(forall a1 x1 n1,
  fv_co_co_tm (close_tm_wrt_tm_rec n1 x1 a1) [=] fv_co_co_tm a1) /\
(forall brs1 x1 n1,
  fv_co_co_brs (close_brs_wrt_tm_rec n1 x1 brs1) [=] fv_co_co_brs brs1) /\
(forall g1 x1 n1,
  fv_co_co_co (close_co_wrt_tm_rec n1 x1 g1) [=] fv_co_co_co g1) /\
(forall phi1 x1 n1,
  fv_co_co_constraint (close_constraint_wrt_tm_rec n1 x1 phi1) [=] fv_co_co_constraint phi1).

Lemma fv_co_co_tm_close_tm_wrt_tm_rec :
forall a1 x1 n1,
  fv_co_co_tm (close_tm_wrt_tm_rec n1 x1 a1) [=] fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_close_tm_wrt_tm_rec : lngen.
Hint Rewrite fv_co_co_tm_close_tm_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_co_co_brs_close_brs_wrt_tm_rec :
forall brs1 x1 n1,
  fv_co_co_brs (close_brs_wrt_tm_rec n1 x1 brs1) [=] fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_close_brs_wrt_tm_rec : lngen.
Hint Rewrite fv_co_co_brs_close_brs_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_co_co_co_close_co_wrt_tm_rec :
forall g1 x1 n1,
  fv_co_co_co (close_co_wrt_tm_rec n1 x1 g1) [=] fv_co_co_co g1.

Hint Resolve fv_co_co_co_close_co_wrt_tm_rec : lngen.
Hint Rewrite fv_co_co_co_close_co_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_co_co_constraint_close_constraint_wrt_tm_rec :
forall phi1 x1 n1,
  fv_co_co_constraint (close_constraint_wrt_tm_rec n1 x1 phi1) [=] fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_close_constraint_wrt_tm_rec : lngen.
Hint Rewrite fv_co_co_constraint_close_constraint_wrt_tm_rec using solve [auto] : lngen.

Lemma fv_co_co_tm_close_tm_wrt_co_rec_fv_co_co_brs_close_brs_wrt_co_rec_fv_co_co_co_close_co_wrt_co_rec_fv_co_co_constraint_close_constraint_wrt_co_rec_mutual :
(forall a1 c1 n1,
  fv_co_co_tm (close_tm_wrt_co_rec n1 c1 a1) [=] remove c1 (fv_co_co_tm a1)) /\
(forall brs1 c1 n1,
  fv_co_co_brs (close_brs_wrt_co_rec n1 c1 brs1) [=] remove c1 (fv_co_co_brs brs1)) /\
(forall g1 c1 n1,
  fv_co_co_co (close_co_wrt_co_rec n1 c1 g1) [=] remove c1 (fv_co_co_co g1)) /\
(forall phi1 c1 n1,
  fv_co_co_constraint (close_constraint_wrt_co_rec n1 c1 phi1) [=] remove c1 (fv_co_co_constraint phi1)).

Lemma fv_co_co_tm_close_tm_wrt_co_rec :
forall a1 c1 n1,
  fv_co_co_tm (close_tm_wrt_co_rec n1 c1 a1) [=] remove c1 (fv_co_co_tm a1).

Hint Resolve fv_co_co_tm_close_tm_wrt_co_rec : lngen.
Hint Rewrite fv_co_co_tm_close_tm_wrt_co_rec using solve [auto] : lngen.

Lemma fv_co_co_brs_close_brs_wrt_co_rec :
forall brs1 c1 n1,
  fv_co_co_brs (close_brs_wrt_co_rec n1 c1 brs1) [=] remove c1 (fv_co_co_brs brs1).

Hint Resolve fv_co_co_brs_close_brs_wrt_co_rec : lngen.
Hint Rewrite fv_co_co_brs_close_brs_wrt_co_rec using solve [auto] : lngen.

Lemma fv_co_co_co_close_co_wrt_co_rec :
forall g1 c1 n1,
  fv_co_co_co (close_co_wrt_co_rec n1 c1 g1) [=] remove c1 (fv_co_co_co g1).

Hint Resolve fv_co_co_co_close_co_wrt_co_rec : lngen.
Hint Rewrite fv_co_co_co_close_co_wrt_co_rec using solve [auto] : lngen.

Lemma fv_co_co_constraint_close_constraint_wrt_co_rec :
forall phi1 c1 n1,
  fv_co_co_constraint (close_constraint_wrt_co_rec n1 c1 phi1) [=] remove c1 (fv_co_co_constraint phi1).

Hint Resolve fv_co_co_constraint_close_constraint_wrt_co_rec : lngen.
Hint Rewrite fv_co_co_constraint_close_constraint_wrt_co_rec using solve [auto] : lngen.

Lemma fv_tm_tm_tm_close_tm_wrt_tm :
forall a1 x1,
  fv_tm_tm_tm (close_tm_wrt_tm x1 a1) [=] remove x1 (fv_tm_tm_tm a1).

Hint Resolve fv_tm_tm_tm_close_tm_wrt_tm : lngen.
Hint Rewrite fv_tm_tm_tm_close_tm_wrt_tm using solve [auto] : lngen.

Lemma fv_tm_tm_brs_close_brs_wrt_tm :
forall brs1 x1,
  fv_tm_tm_brs (close_brs_wrt_tm x1 brs1) [=] remove x1 (fv_tm_tm_brs brs1).

Hint Resolve fv_tm_tm_brs_close_brs_wrt_tm : lngen.
Hint Rewrite fv_tm_tm_brs_close_brs_wrt_tm using solve [auto] : lngen.

Lemma fv_tm_tm_co_close_co_wrt_tm :
forall g1 x1,
  fv_tm_tm_co (close_co_wrt_tm x1 g1) [=] remove x1 (fv_tm_tm_co g1).

Hint Resolve fv_tm_tm_co_close_co_wrt_tm : lngen.
Hint Rewrite fv_tm_tm_co_close_co_wrt_tm using solve [auto] : lngen.

Lemma fv_tm_tm_constraint_close_constraint_wrt_tm :
forall phi1 x1,
  fv_tm_tm_constraint (close_constraint_wrt_tm x1 phi1) [=] remove x1 (fv_tm_tm_constraint phi1).

Hint Resolve fv_tm_tm_constraint_close_constraint_wrt_tm : lngen.
Hint Rewrite fv_tm_tm_constraint_close_constraint_wrt_tm using solve [auto] : lngen.

Lemma fv_tm_tm_tm_close_tm_wrt_co :
forall a1 c1,
  fv_tm_tm_tm (close_tm_wrt_co c1 a1) [=] fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_close_tm_wrt_co : lngen.
Hint Rewrite fv_tm_tm_tm_close_tm_wrt_co using solve [auto] : lngen.

Lemma fv_tm_tm_brs_close_brs_wrt_co :
forall brs1 c1,
  fv_tm_tm_brs (close_brs_wrt_co c1 brs1) [=] fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_close_brs_wrt_co : lngen.
Hint Rewrite fv_tm_tm_brs_close_brs_wrt_co using solve [auto] : lngen.

Lemma fv_tm_tm_co_close_co_wrt_co :
forall g1 c1,
  fv_tm_tm_co (close_co_wrt_co c1 g1) [=] fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_close_co_wrt_co : lngen.
Hint Rewrite fv_tm_tm_co_close_co_wrt_co using solve [auto] : lngen.

Lemma fv_tm_tm_constraint_close_constraint_wrt_co :
forall phi1 c1,
  fv_tm_tm_constraint (close_constraint_wrt_co c1 phi1) [=] fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_close_constraint_wrt_co : lngen.
Hint Rewrite fv_tm_tm_constraint_close_constraint_wrt_co using solve [auto] : lngen.

Lemma fv_co_co_tm_close_tm_wrt_tm :
forall a1 x1,
  fv_co_co_tm (close_tm_wrt_tm x1 a1) [=] fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_close_tm_wrt_tm : lngen.
Hint Rewrite fv_co_co_tm_close_tm_wrt_tm using solve [auto] : lngen.

Lemma fv_co_co_brs_close_brs_wrt_tm :
forall brs1 x1,
  fv_co_co_brs (close_brs_wrt_tm x1 brs1) [=] fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_close_brs_wrt_tm : lngen.
Hint Rewrite fv_co_co_brs_close_brs_wrt_tm using solve [auto] : lngen.

Lemma fv_co_co_co_close_co_wrt_tm :
forall g1 x1,
  fv_co_co_co (close_co_wrt_tm x1 g1) [=] fv_co_co_co g1.

Hint Resolve fv_co_co_co_close_co_wrt_tm : lngen.
Hint Rewrite fv_co_co_co_close_co_wrt_tm using solve [auto] : lngen.

Lemma fv_co_co_constraint_close_constraint_wrt_tm :
forall phi1 x1,
  fv_co_co_constraint (close_constraint_wrt_tm x1 phi1) [=] fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_close_constraint_wrt_tm : lngen.
Hint Rewrite fv_co_co_constraint_close_constraint_wrt_tm using solve [auto] : lngen.

Lemma fv_co_co_tm_close_tm_wrt_co :
forall a1 c1,
  fv_co_co_tm (close_tm_wrt_co c1 a1) [=] remove c1 (fv_co_co_tm a1).

Hint Resolve fv_co_co_tm_close_tm_wrt_co : lngen.
Hint Rewrite fv_co_co_tm_close_tm_wrt_co using solve [auto] : lngen.

Lemma fv_co_co_brs_close_brs_wrt_co :
forall brs1 c1,
  fv_co_co_brs (close_brs_wrt_co c1 brs1) [=] remove c1 (fv_co_co_brs brs1).

Hint Resolve fv_co_co_brs_close_brs_wrt_co : lngen.
Hint Rewrite fv_co_co_brs_close_brs_wrt_co using solve [auto] : lngen.

Lemma fv_co_co_co_close_co_wrt_co :
forall g1 c1,
  fv_co_co_co (close_co_wrt_co c1 g1) [=] remove c1 (fv_co_co_co g1).

Hint Resolve fv_co_co_co_close_co_wrt_co : lngen.
Hint Rewrite fv_co_co_co_close_co_wrt_co using solve [auto] : lngen.

Lemma fv_co_co_constraint_close_constraint_wrt_co :
forall phi1 c1,
  fv_co_co_constraint (close_constraint_wrt_co c1 phi1) [=] remove c1 (fv_co_co_constraint phi1).

Hint Resolve fv_co_co_constraint_close_constraint_wrt_co : lngen.
Hint Rewrite fv_co_co_constraint_close_constraint_wrt_co using solve [auto] : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_tm_rec_lower_fv_tm_tm_brs_open_brs_wrt_tm_rec_lower_fv_tm_tm_co_open_co_wrt_tm_rec_lower_fv_tm_tm_constraint_open_constraint_wrt_tm_rec_lower_mutual :
(forall a1 a2 n1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (open_tm_wrt_tm_rec n1 a2 a1)) /\
(forall brs1 a1 n1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (open_brs_wrt_tm_rec n1 a1 brs1)) /\
(forall g1 a1 n1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (open_co_wrt_tm_rec n1 a1 g1)) /\
(forall phi1 a1 n1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (open_constraint_wrt_tm_rec n1 a1 phi1)).

Lemma fv_tm_tm_tm_open_tm_wrt_tm_rec_lower :
forall a1 a2 n1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (open_tm_wrt_tm_rec n1 a2 a1).

Hint Resolve fv_tm_tm_tm_open_tm_wrt_tm_rec_lower : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_tm_rec_lower :
forall brs1 a1 n1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (open_brs_wrt_tm_rec n1 a1 brs1).

Hint Resolve fv_tm_tm_brs_open_brs_wrt_tm_rec_lower : lngen.

Lemma fv_tm_tm_co_open_co_wrt_tm_rec_lower :
forall g1 a1 n1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (open_co_wrt_tm_rec n1 a1 g1).

Hint Resolve fv_tm_tm_co_open_co_wrt_tm_rec_lower : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_tm_rec_lower :
forall phi1 a1 n1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (open_constraint_wrt_tm_rec n1 a1 phi1).

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_tm_rec_lower : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_co_rec_lower_fv_tm_tm_brs_open_brs_wrt_co_rec_lower_fv_tm_tm_co_open_co_wrt_co_rec_lower_fv_tm_tm_constraint_open_constraint_wrt_co_rec_lower_mutual :
(forall a1 g1 n1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (open_tm_wrt_co_rec n1 g1 a1)) /\
(forall brs1 g1 n1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (open_brs_wrt_co_rec n1 g1 brs1)) /\
(forall g1 g2 n1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (open_co_wrt_co_rec n1 g2 g1)) /\
(forall phi1 g1 n1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (open_constraint_wrt_co_rec n1 g1 phi1)).

Lemma fv_tm_tm_tm_open_tm_wrt_co_rec_lower :
forall a1 g1 n1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (open_tm_wrt_co_rec n1 g1 a1).

Hint Resolve fv_tm_tm_tm_open_tm_wrt_co_rec_lower : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_co_rec_lower :
forall brs1 g1 n1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (open_brs_wrt_co_rec n1 g1 brs1).

Hint Resolve fv_tm_tm_brs_open_brs_wrt_co_rec_lower : lngen.

Lemma fv_tm_tm_co_open_co_wrt_co_rec_lower :
forall g1 g2 n1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (open_co_wrt_co_rec n1 g2 g1).

Hint Resolve fv_tm_tm_co_open_co_wrt_co_rec_lower : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_co_rec_lower :
forall phi1 g1 n1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (open_constraint_wrt_co_rec n1 g1 phi1).

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_co_rec_lower : lngen.

Lemma fv_co_co_tm_open_tm_wrt_tm_rec_lower_fv_co_co_brs_open_brs_wrt_tm_rec_lower_fv_co_co_co_open_co_wrt_tm_rec_lower_fv_co_co_constraint_open_constraint_wrt_tm_rec_lower_mutual :
(forall a1 a2 n1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (open_tm_wrt_tm_rec n1 a2 a1)) /\
(forall brs1 a1 n1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (open_brs_wrt_tm_rec n1 a1 brs1)) /\
(forall g1 a1 n1,
  fv_co_co_co g1 [<=] fv_co_co_co (open_co_wrt_tm_rec n1 a1 g1)) /\
(forall phi1 a1 n1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (open_constraint_wrt_tm_rec n1 a1 phi1)).

Lemma fv_co_co_tm_open_tm_wrt_tm_rec_lower :
forall a1 a2 n1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (open_tm_wrt_tm_rec n1 a2 a1).

Hint Resolve fv_co_co_tm_open_tm_wrt_tm_rec_lower : lngen.

Lemma fv_co_co_brs_open_brs_wrt_tm_rec_lower :
forall brs1 a1 n1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (open_brs_wrt_tm_rec n1 a1 brs1).

Hint Resolve fv_co_co_brs_open_brs_wrt_tm_rec_lower : lngen.

Lemma fv_co_co_co_open_co_wrt_tm_rec_lower :
forall g1 a1 n1,
  fv_co_co_co g1 [<=] fv_co_co_co (open_co_wrt_tm_rec n1 a1 g1).

Hint Resolve fv_co_co_co_open_co_wrt_tm_rec_lower : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_tm_rec_lower :
forall phi1 a1 n1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (open_constraint_wrt_tm_rec n1 a1 phi1).

Hint Resolve fv_co_co_constraint_open_constraint_wrt_tm_rec_lower : lngen.

Lemma fv_co_co_tm_open_tm_wrt_co_rec_lower_fv_co_co_brs_open_brs_wrt_co_rec_lower_fv_co_co_co_open_co_wrt_co_rec_lower_fv_co_co_constraint_open_constraint_wrt_co_rec_lower_mutual :
(forall a1 g1 n1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (open_tm_wrt_co_rec n1 g1 a1)) /\
(forall brs1 g1 n1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (open_brs_wrt_co_rec n1 g1 brs1)) /\
(forall g1 g2 n1,
  fv_co_co_co g1 [<=] fv_co_co_co (open_co_wrt_co_rec n1 g2 g1)) /\
(forall phi1 g1 n1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (open_constraint_wrt_co_rec n1 g1 phi1)).

Lemma fv_co_co_tm_open_tm_wrt_co_rec_lower :
forall a1 g1 n1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (open_tm_wrt_co_rec n1 g1 a1).

Hint Resolve fv_co_co_tm_open_tm_wrt_co_rec_lower : lngen.

Lemma fv_co_co_brs_open_brs_wrt_co_rec_lower :
forall brs1 g1 n1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (open_brs_wrt_co_rec n1 g1 brs1).

Hint Resolve fv_co_co_brs_open_brs_wrt_co_rec_lower : lngen.

Lemma fv_co_co_co_open_co_wrt_co_rec_lower :
forall g1 g2 n1,
  fv_co_co_co g1 [<=] fv_co_co_co (open_co_wrt_co_rec n1 g2 g1).

Hint Resolve fv_co_co_co_open_co_wrt_co_rec_lower : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_co_rec_lower :
forall phi1 g1 n1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (open_constraint_wrt_co_rec n1 g1 phi1).

Hint Resolve fv_co_co_constraint_open_constraint_wrt_co_rec_lower : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_tm_lower :
forall a1 a2,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (open_tm_wrt_tm a1 a2).

Hint Resolve fv_tm_tm_tm_open_tm_wrt_tm_lower : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_tm_lower :
forall brs1 a1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (open_brs_wrt_tm brs1 a1).

Hint Resolve fv_tm_tm_brs_open_brs_wrt_tm_lower : lngen.

Lemma fv_tm_tm_co_open_co_wrt_tm_lower :
forall g1 a1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (open_co_wrt_tm g1 a1).

Hint Resolve fv_tm_tm_co_open_co_wrt_tm_lower : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_tm_lower :
forall phi1 a1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (open_constraint_wrt_tm phi1 a1).

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_tm_lower : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_co_lower :
forall a1 g1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (open_tm_wrt_co a1 g1).

Hint Resolve fv_tm_tm_tm_open_tm_wrt_co_lower : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_co_lower :
forall brs1 g1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (open_brs_wrt_co brs1 g1).

Hint Resolve fv_tm_tm_brs_open_brs_wrt_co_lower : lngen.

Lemma fv_tm_tm_co_open_co_wrt_co_lower :
forall g1 g2,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (open_co_wrt_co g1 g2).

Hint Resolve fv_tm_tm_co_open_co_wrt_co_lower : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_co_lower :
forall phi1 g1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (open_constraint_wrt_co phi1 g1).

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_co_lower : lngen.

Lemma fv_co_co_tm_open_tm_wrt_tm_lower :
forall a1 a2,
  fv_co_co_tm a1 [<=] fv_co_co_tm (open_tm_wrt_tm a1 a2).

Hint Resolve fv_co_co_tm_open_tm_wrt_tm_lower : lngen.

Lemma fv_co_co_brs_open_brs_wrt_tm_lower :
forall brs1 a1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (open_brs_wrt_tm brs1 a1).

Hint Resolve fv_co_co_brs_open_brs_wrt_tm_lower : lngen.

Lemma fv_co_co_co_open_co_wrt_tm_lower :
forall g1 a1,
  fv_co_co_co g1 [<=] fv_co_co_co (open_co_wrt_tm g1 a1).

Hint Resolve fv_co_co_co_open_co_wrt_tm_lower : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_tm_lower :
forall phi1 a1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (open_constraint_wrt_tm phi1 a1).

Hint Resolve fv_co_co_constraint_open_constraint_wrt_tm_lower : lngen.

Lemma fv_co_co_tm_open_tm_wrt_co_lower :
forall a1 g1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (open_tm_wrt_co a1 g1).

Hint Resolve fv_co_co_tm_open_tm_wrt_co_lower : lngen.

Lemma fv_co_co_brs_open_brs_wrt_co_lower :
forall brs1 g1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (open_brs_wrt_co brs1 g1).

Hint Resolve fv_co_co_brs_open_brs_wrt_co_lower : lngen.

Lemma fv_co_co_co_open_co_wrt_co_lower :
forall g1 g2,
  fv_co_co_co g1 [<=] fv_co_co_co (open_co_wrt_co g1 g2).

Hint Resolve fv_co_co_co_open_co_wrt_co_lower : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_co_lower :
forall phi1 g1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (open_constraint_wrt_co phi1 g1).

Hint Resolve fv_co_co_constraint_open_constraint_wrt_co_lower : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_tm_rec_upper_fv_tm_tm_brs_open_brs_wrt_tm_rec_upper_fv_tm_tm_co_open_co_wrt_tm_rec_upper_fv_tm_tm_constraint_open_constraint_wrt_tm_rec_upper_mutual :
(forall a1 a2 n1,
  fv_tm_tm_tm (open_tm_wrt_tm_rec n1 a2 a1) [<=] fv_tm_tm_tm a2 `union` fv_tm_tm_tm a1) /\
(forall brs1 a1 n1,
  fv_tm_tm_brs (open_brs_wrt_tm_rec n1 a1 brs1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_brs brs1) /\
(forall g1 a1 n1,
  fv_tm_tm_co (open_co_wrt_tm_rec n1 a1 g1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_co g1) /\
(forall phi1 a1 n1,
  fv_tm_tm_constraint (open_constraint_wrt_tm_rec n1 a1 phi1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_constraint phi1).

Lemma fv_tm_tm_tm_open_tm_wrt_tm_rec_upper :
forall a1 a2 n1,
  fv_tm_tm_tm (open_tm_wrt_tm_rec n1 a2 a1) [<=] fv_tm_tm_tm a2 `union` fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_open_tm_wrt_tm_rec_upper : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_tm_rec_upper :
forall brs1 a1 n1,
  fv_tm_tm_brs (open_brs_wrt_tm_rec n1 a1 brs1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_open_brs_wrt_tm_rec_upper : lngen.

Lemma fv_tm_tm_co_open_co_wrt_tm_rec_upper :
forall g1 a1 n1,
  fv_tm_tm_co (open_co_wrt_tm_rec n1 a1 g1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_open_co_wrt_tm_rec_upper : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_tm_rec_upper :
forall phi1 a1 n1,
  fv_tm_tm_constraint (open_constraint_wrt_tm_rec n1 a1 phi1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_tm_rec_upper : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_co_rec_upper_fv_tm_tm_brs_open_brs_wrt_co_rec_upper_fv_tm_tm_co_open_co_wrt_co_rec_upper_fv_tm_tm_constraint_open_constraint_wrt_co_rec_upper_mutual :
(forall a1 g1 n1,
  fv_tm_tm_tm (open_tm_wrt_co_rec n1 g1 a1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_tm a1) /\
(forall brs1 g1 n1,
  fv_tm_tm_brs (open_brs_wrt_co_rec n1 g1 brs1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_brs brs1) /\
(forall g1 g2 n1,
  fv_tm_tm_co (open_co_wrt_co_rec n1 g2 g1) [<=] fv_tm_tm_co g2 `union` fv_tm_tm_co g1) /\
(forall phi1 g1 n1,
  fv_tm_tm_constraint (open_constraint_wrt_co_rec n1 g1 phi1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_constraint phi1).

Lemma fv_tm_tm_tm_open_tm_wrt_co_rec_upper :
forall a1 g1 n1,
  fv_tm_tm_tm (open_tm_wrt_co_rec n1 g1 a1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_open_tm_wrt_co_rec_upper : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_co_rec_upper :
forall brs1 g1 n1,
  fv_tm_tm_brs (open_brs_wrt_co_rec n1 g1 brs1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_open_brs_wrt_co_rec_upper : lngen.

Lemma fv_tm_tm_co_open_co_wrt_co_rec_upper :
forall g1 g2 n1,
  fv_tm_tm_co (open_co_wrt_co_rec n1 g2 g1) [<=] fv_tm_tm_co g2 `union` fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_open_co_wrt_co_rec_upper : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_co_rec_upper :
forall phi1 g1 n1,
  fv_tm_tm_constraint (open_constraint_wrt_co_rec n1 g1 phi1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_co_rec_upper : lngen.

Lemma fv_co_co_tm_open_tm_wrt_tm_rec_upper_fv_co_co_brs_open_brs_wrt_tm_rec_upper_fv_co_co_co_open_co_wrt_tm_rec_upper_fv_co_co_constraint_open_constraint_wrt_tm_rec_upper_mutual :
(forall a1 a2 n1,
  fv_co_co_tm (open_tm_wrt_tm_rec n1 a2 a1) [<=] fv_co_co_tm a2 `union` fv_co_co_tm a1) /\
(forall brs1 a1 n1,
  fv_co_co_brs (open_brs_wrt_tm_rec n1 a1 brs1) [<=] fv_co_co_tm a1 `union` fv_co_co_brs brs1) /\
(forall g1 a1 n1,
  fv_co_co_co (open_co_wrt_tm_rec n1 a1 g1) [<=] fv_co_co_tm a1 `union` fv_co_co_co g1) /\
(forall phi1 a1 n1,
  fv_co_co_constraint (open_constraint_wrt_tm_rec n1 a1 phi1) [<=] fv_co_co_tm a1 `union` fv_co_co_constraint phi1).

Lemma fv_co_co_tm_open_tm_wrt_tm_rec_upper :
forall a1 a2 n1,
  fv_co_co_tm (open_tm_wrt_tm_rec n1 a2 a1) [<=] fv_co_co_tm a2 `union` fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_open_tm_wrt_tm_rec_upper : lngen.

Lemma fv_co_co_brs_open_brs_wrt_tm_rec_upper :
forall brs1 a1 n1,
  fv_co_co_brs (open_brs_wrt_tm_rec n1 a1 brs1) [<=] fv_co_co_tm a1 `union` fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_open_brs_wrt_tm_rec_upper : lngen.

Lemma fv_co_co_co_open_co_wrt_tm_rec_upper :
forall g1 a1 n1,
  fv_co_co_co (open_co_wrt_tm_rec n1 a1 g1) [<=] fv_co_co_tm a1 `union` fv_co_co_co g1.

Hint Resolve fv_co_co_co_open_co_wrt_tm_rec_upper : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_tm_rec_upper :
forall phi1 a1 n1,
  fv_co_co_constraint (open_constraint_wrt_tm_rec n1 a1 phi1) [<=] fv_co_co_tm a1 `union` fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_open_constraint_wrt_tm_rec_upper : lngen.

Lemma fv_co_co_tm_open_tm_wrt_co_rec_upper_fv_co_co_brs_open_brs_wrt_co_rec_upper_fv_co_co_co_open_co_wrt_co_rec_upper_fv_co_co_constraint_open_constraint_wrt_co_rec_upper_mutual :
(forall a1 g1 n1,
  fv_co_co_tm (open_tm_wrt_co_rec n1 g1 a1) [<=] fv_co_co_co g1 `union` fv_co_co_tm a1) /\
(forall brs1 g1 n1,
  fv_co_co_brs (open_brs_wrt_co_rec n1 g1 brs1) [<=] fv_co_co_co g1 `union` fv_co_co_brs brs1) /\
(forall g1 g2 n1,
  fv_co_co_co (open_co_wrt_co_rec n1 g2 g1) [<=] fv_co_co_co g2 `union` fv_co_co_co g1) /\
(forall phi1 g1 n1,
  fv_co_co_constraint (open_constraint_wrt_co_rec n1 g1 phi1) [<=] fv_co_co_co g1 `union` fv_co_co_constraint phi1).

Lemma fv_co_co_tm_open_tm_wrt_co_rec_upper :
forall a1 g1 n1,
  fv_co_co_tm (open_tm_wrt_co_rec n1 g1 a1) [<=] fv_co_co_co g1 `union` fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_open_tm_wrt_co_rec_upper : lngen.

Lemma fv_co_co_brs_open_brs_wrt_co_rec_upper :
forall brs1 g1 n1,
  fv_co_co_brs (open_brs_wrt_co_rec n1 g1 brs1) [<=] fv_co_co_co g1 `union` fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_open_brs_wrt_co_rec_upper : lngen.

Lemma fv_co_co_co_open_co_wrt_co_rec_upper :
forall g1 g2 n1,
  fv_co_co_co (open_co_wrt_co_rec n1 g2 g1) [<=] fv_co_co_co g2 `union` fv_co_co_co g1.

Hint Resolve fv_co_co_co_open_co_wrt_co_rec_upper : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_co_rec_upper :
forall phi1 g1 n1,
  fv_co_co_constraint (open_constraint_wrt_co_rec n1 g1 phi1) [<=] fv_co_co_co g1 `union` fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_open_constraint_wrt_co_rec_upper : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_tm_upper :
forall a1 a2,
  fv_tm_tm_tm (open_tm_wrt_tm a1 a2) [<=] fv_tm_tm_tm a2 `union` fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_open_tm_wrt_tm_upper : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_tm_upper :
forall brs1 a1,
  fv_tm_tm_brs (open_brs_wrt_tm brs1 a1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_open_brs_wrt_tm_upper : lngen.

Lemma fv_tm_tm_co_open_co_wrt_tm_upper :
forall g1 a1,
  fv_tm_tm_co (open_co_wrt_tm g1 a1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_open_co_wrt_tm_upper : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_tm_upper :
forall phi1 a1,
  fv_tm_tm_constraint (open_constraint_wrt_tm phi1 a1) [<=] fv_tm_tm_tm a1 `union` fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_tm_upper : lngen.

Lemma fv_tm_tm_tm_open_tm_wrt_co_upper :
forall a1 g1,
  fv_tm_tm_tm (open_tm_wrt_co a1 g1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_open_tm_wrt_co_upper : lngen.

Lemma fv_tm_tm_brs_open_brs_wrt_co_upper :
forall brs1 g1,
  fv_tm_tm_brs (open_brs_wrt_co brs1 g1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_open_brs_wrt_co_upper : lngen.

Lemma fv_tm_tm_co_open_co_wrt_co_upper :
forall g1 g2,
  fv_tm_tm_co (open_co_wrt_co g1 g2) [<=] fv_tm_tm_co g2 `union` fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_open_co_wrt_co_upper : lngen.

Lemma fv_tm_tm_constraint_open_constraint_wrt_co_upper :
forall phi1 g1,
  fv_tm_tm_constraint (open_constraint_wrt_co phi1 g1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_open_constraint_wrt_co_upper : lngen.

Lemma fv_co_co_tm_open_tm_wrt_tm_upper :
forall a1 a2,
  fv_co_co_tm (open_tm_wrt_tm a1 a2) [<=] fv_co_co_tm a2 `union` fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_open_tm_wrt_tm_upper : lngen.

Lemma fv_co_co_brs_open_brs_wrt_tm_upper :
forall brs1 a1,
  fv_co_co_brs (open_brs_wrt_tm brs1 a1) [<=] fv_co_co_tm a1 `union` fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_open_brs_wrt_tm_upper : lngen.

Lemma fv_co_co_co_open_co_wrt_tm_upper :
forall g1 a1,
  fv_co_co_co (open_co_wrt_tm g1 a1) [<=] fv_co_co_tm a1 `union` fv_co_co_co g1.

Hint Resolve fv_co_co_co_open_co_wrt_tm_upper : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_tm_upper :
forall phi1 a1,
  fv_co_co_constraint (open_constraint_wrt_tm phi1 a1) [<=] fv_co_co_tm a1 `union` fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_open_constraint_wrt_tm_upper : lngen.

Lemma fv_co_co_tm_open_tm_wrt_co_upper :
forall a1 g1,
  fv_co_co_tm (open_tm_wrt_co a1 g1) [<=] fv_co_co_co g1 `union` fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_open_tm_wrt_co_upper : lngen.

Lemma fv_co_co_brs_open_brs_wrt_co_upper :
forall brs1 g1,
  fv_co_co_brs (open_brs_wrt_co brs1 g1) [<=] fv_co_co_co g1 `union` fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_open_brs_wrt_co_upper : lngen.

Lemma fv_co_co_co_open_co_wrt_co_upper :
forall g1 g2,
  fv_co_co_co (open_co_wrt_co g1 g2) [<=] fv_co_co_co g2 `union` fv_co_co_co g1.

Hint Resolve fv_co_co_co_open_co_wrt_co_upper : lngen.

Lemma fv_co_co_constraint_open_constraint_wrt_co_upper :
forall phi1 g1,
  fv_co_co_constraint (open_constraint_wrt_co phi1 g1) [<=] fv_co_co_co g1 `union` fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_open_constraint_wrt_co_upper : lngen.

Lemma fv_tm_tm_tm_tm_subst_tm_tm_fresh_fv_tm_tm_brs_tm_subst_tm_brs_fresh_fv_tm_tm_co_tm_subst_tm_co_fresh_fv_tm_tm_constraint_tm_subst_tm_constraint_fresh_mutual :
(forall a1 a2 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1) [=] fv_tm_tm_tm a1) /\
(forall brs1 a1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1) [=] fv_tm_tm_brs brs1) /\
(forall g1 a1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  fv_tm_tm_co (tm_subst_tm_co a1 x1 g1) [=] fv_tm_tm_co g1) /\
(forall phi1 a1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1) [=] fv_tm_tm_constraint phi1).

Lemma fv_tm_tm_tm_tm_subst_tm_tm_fresh :
forall a1 a2 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1) [=] fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_tm_subst_tm_tm_fresh : lngen.
Hint Rewrite fv_tm_tm_tm_tm_subst_tm_tm_fresh using solve [auto] : lngen.

Lemma fv_tm_tm_brs_tm_subst_tm_brs_fresh :
forall brs1 a1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1) [=] fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_tm_subst_tm_brs_fresh : lngen.
Hint Rewrite fv_tm_tm_brs_tm_subst_tm_brs_fresh using solve [auto] : lngen.

Lemma fv_tm_tm_co_tm_subst_tm_co_fresh :
forall g1 a1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  fv_tm_tm_co (tm_subst_tm_co a1 x1 g1) [=] fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_tm_subst_tm_co_fresh : lngen.
Hint Rewrite fv_tm_tm_co_tm_subst_tm_co_fresh using solve [auto] : lngen.

Lemma fv_tm_tm_constraint_tm_subst_tm_constraint_fresh :
forall phi1 a1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1) [=] fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_tm_subst_tm_constraint_fresh : lngen.
Hint Rewrite fv_tm_tm_constraint_tm_subst_tm_constraint_fresh using solve [auto] : lngen.

Lemma fv_co_co_tm_co_subst_co_tm_fresh_fv_co_co_brs_co_subst_co_brs_fresh_fv_co_co_co_co_subst_co_co_fresh_fv_co_co_constraint_co_subst_co_constraint_fresh_mutual :
(forall a1 g1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  fv_co_co_tm (co_subst_co_tm g1 c1 a1) [=] fv_co_co_tm a1) /\
(forall brs1 g1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  fv_co_co_brs (co_subst_co_brs g1 c1 brs1) [=] fv_co_co_brs brs1) /\
(forall g1 g2 c1,
  c1 `notin` fv_co_co_co g1 ->
  fv_co_co_co (co_subst_co_co g2 c1 g1) [=] fv_co_co_co g1) /\
(forall phi1 g1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1) [=] fv_co_co_constraint phi1).

Lemma fv_co_co_tm_co_subst_co_tm_fresh :
forall a1 g1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  fv_co_co_tm (co_subst_co_tm g1 c1 a1) [=] fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_co_subst_co_tm_fresh : lngen.
Hint Rewrite fv_co_co_tm_co_subst_co_tm_fresh using solve [auto] : lngen.

Lemma fv_co_co_brs_co_subst_co_brs_fresh :
forall brs1 g1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  fv_co_co_brs (co_subst_co_brs g1 c1 brs1) [=] fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_co_subst_co_brs_fresh : lngen.
Hint Rewrite fv_co_co_brs_co_subst_co_brs_fresh using solve [auto] : lngen.

Lemma fv_co_co_co_co_subst_co_co_fresh :
forall g1 g2 c1,
  c1 `notin` fv_co_co_co g1 ->
  fv_co_co_co (co_subst_co_co g2 c1 g1) [=] fv_co_co_co g1.

Hint Resolve fv_co_co_co_co_subst_co_co_fresh : lngen.
Hint Rewrite fv_co_co_co_co_subst_co_co_fresh using solve [auto] : lngen.

Lemma fv_co_co_constraint_co_subst_co_constraint_fresh :
forall phi1 g1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1) [=] fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_co_subst_co_constraint_fresh : lngen.
Hint Rewrite fv_co_co_constraint_co_subst_co_constraint_fresh using solve [auto] : lngen.

Lemma fv_tm_tm_tm_tm_subst_tm_tm_lower_fv_tm_tm_brs_tm_subst_tm_brs_lower_fv_tm_tm_co_tm_subst_tm_co_lower_fv_tm_tm_constraint_tm_subst_tm_constraint_lower_mutual :
(forall a1 a2 x1,
  remove x1 (fv_tm_tm_tm a1) [<=] fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 x1,
  remove x1 (fv_tm_tm_brs brs1) [<=] fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1,
  remove x1 (fv_tm_tm_co g1) [<=] fv_tm_tm_co (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1,
  remove x1 (fv_tm_tm_constraint phi1) [<=] fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1)).

Lemma fv_tm_tm_tm_tm_subst_tm_tm_lower :
forall a1 a2 x1,
  remove x1 (fv_tm_tm_tm a1) [<=] fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1).

Hint Resolve fv_tm_tm_tm_tm_subst_tm_tm_lower : lngen.

Lemma fv_tm_tm_brs_tm_subst_tm_brs_lower :
forall brs1 a1 x1,
  remove x1 (fv_tm_tm_brs brs1) [<=] fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve fv_tm_tm_brs_tm_subst_tm_brs_lower : lngen.

Lemma fv_tm_tm_co_tm_subst_tm_co_lower :
forall g1 a1 x1,
  remove x1 (fv_tm_tm_co g1) [<=] fv_tm_tm_co (tm_subst_tm_co a1 x1 g1).

Hint Resolve fv_tm_tm_co_tm_subst_tm_co_lower : lngen.

Lemma fv_tm_tm_constraint_tm_subst_tm_constraint_lower :
forall phi1 a1 x1,
  remove x1 (fv_tm_tm_constraint phi1) [<=] fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve fv_tm_tm_constraint_tm_subst_tm_constraint_lower : lngen.

Lemma fv_tm_tm_tm_co_subst_co_tm_lower_fv_tm_tm_brs_co_subst_co_brs_lower_fv_tm_tm_co_co_subst_co_co_lower_fv_tm_tm_constraint_co_subst_co_constraint_lower_mutual :
(forall a1 g1 c1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 c1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 c1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (co_subst_co_constraint g1 c1 phi1)).

Lemma fv_tm_tm_tm_co_subst_co_tm_lower :
forall a1 g1 c1,
  fv_tm_tm_tm a1 [<=] fv_tm_tm_tm (co_subst_co_tm g1 c1 a1).

Hint Resolve fv_tm_tm_tm_co_subst_co_tm_lower : lngen.

Lemma fv_tm_tm_brs_co_subst_co_brs_lower :
forall brs1 g1 c1,
  fv_tm_tm_brs brs1 [<=] fv_tm_tm_brs (co_subst_co_brs g1 c1 brs1).

Hint Resolve fv_tm_tm_brs_co_subst_co_brs_lower : lngen.

Lemma fv_tm_tm_co_co_subst_co_co_lower :
forall g1 g2 c1,
  fv_tm_tm_co g1 [<=] fv_tm_tm_co (co_subst_co_co g2 c1 g1).

Hint Resolve fv_tm_tm_co_co_subst_co_co_lower : lngen.

Lemma fv_tm_tm_constraint_co_subst_co_constraint_lower :
forall phi1 g1 c1,
  fv_tm_tm_constraint phi1 [<=] fv_tm_tm_constraint (co_subst_co_constraint g1 c1 phi1).

Hint Resolve fv_tm_tm_constraint_co_subst_co_constraint_lower : lngen.

Lemma fv_co_co_tm_tm_subst_tm_tm_lower_fv_co_co_brs_tm_subst_tm_brs_lower_fv_co_co_co_tm_subst_tm_co_lower_fv_co_co_constraint_tm_subst_tm_constraint_lower_mutual :
(forall a1 a2 x1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 x1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1,
  fv_co_co_co g1 [<=] fv_co_co_co (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (tm_subst_tm_constraint a1 x1 phi1)).

Lemma fv_co_co_tm_tm_subst_tm_tm_lower :
forall a1 a2 x1,
  fv_co_co_tm a1 [<=] fv_co_co_tm (tm_subst_tm_tm a2 x1 a1).

Hint Resolve fv_co_co_tm_tm_subst_tm_tm_lower : lngen.

Lemma fv_co_co_brs_tm_subst_tm_brs_lower :
forall brs1 a1 x1,
  fv_co_co_brs brs1 [<=] fv_co_co_brs (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve fv_co_co_brs_tm_subst_tm_brs_lower : lngen.

Lemma fv_co_co_co_tm_subst_tm_co_lower :
forall g1 a1 x1,
  fv_co_co_co g1 [<=] fv_co_co_co (tm_subst_tm_co a1 x1 g1).

Hint Resolve fv_co_co_co_tm_subst_tm_co_lower : lngen.

Lemma fv_co_co_constraint_tm_subst_tm_constraint_lower :
forall phi1 a1 x1,
  fv_co_co_constraint phi1 [<=] fv_co_co_constraint (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve fv_co_co_constraint_tm_subst_tm_constraint_lower : lngen.

Lemma fv_co_co_tm_co_subst_co_tm_lower_fv_co_co_brs_co_subst_co_brs_lower_fv_co_co_co_co_subst_co_co_lower_fv_co_co_constraint_co_subst_co_constraint_lower_mutual :
(forall a1 g1 c1,
  remove c1 (fv_co_co_tm a1) [<=] fv_co_co_tm (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1,
  remove c1 (fv_co_co_brs brs1) [<=] fv_co_co_brs (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 c1,
  remove c1 (fv_co_co_co g1) [<=] fv_co_co_co (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 c1,
  remove c1 (fv_co_co_constraint phi1) [<=] fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1)).

Lemma fv_co_co_tm_co_subst_co_tm_lower :
forall a1 g1 c1,
  remove c1 (fv_co_co_tm a1) [<=] fv_co_co_tm (co_subst_co_tm g1 c1 a1).

Hint Resolve fv_co_co_tm_co_subst_co_tm_lower : lngen.

Lemma fv_co_co_brs_co_subst_co_brs_lower :
forall brs1 g1 c1,
  remove c1 (fv_co_co_brs brs1) [<=] fv_co_co_brs (co_subst_co_brs g1 c1 brs1).

Hint Resolve fv_co_co_brs_co_subst_co_brs_lower : lngen.

Lemma fv_co_co_co_co_subst_co_co_lower :
forall g1 g2 c1,
  remove c1 (fv_co_co_co g1) [<=] fv_co_co_co (co_subst_co_co g2 c1 g1).

Hint Resolve fv_co_co_co_co_subst_co_co_lower : lngen.

Lemma fv_co_co_constraint_co_subst_co_constraint_lower :
forall phi1 g1 c1,
  remove c1 (fv_co_co_constraint phi1) [<=] fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1).

Hint Resolve fv_co_co_constraint_co_subst_co_constraint_lower : lngen.

Lemma fv_tm_tm_tm_tm_subst_tm_tm_notin_fv_tm_tm_brs_tm_subst_tm_brs_notin_fv_tm_tm_co_tm_subst_tm_co_notin_fv_tm_tm_constraint_tm_subst_tm_constraint_notin_mutual :
(forall a1 a2 x1 x2,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 `notin` fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 x1 x2,
  x2 `notin` fv_tm_tm_brs brs1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1 x2,
  x2 `notin` fv_tm_tm_co g1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_co (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1 x2,
  x2 `notin` fv_tm_tm_constraint phi1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1)).

Lemma fv_tm_tm_tm_tm_subst_tm_tm_notin :
forall a1 a2 x1 x2,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 `notin` fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1).

Hint Resolve fv_tm_tm_tm_tm_subst_tm_tm_notin : lngen.

Lemma fv_tm_tm_brs_tm_subst_tm_brs_notin :
forall brs1 a1 x1 x2,
  x2 `notin` fv_tm_tm_brs brs1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve fv_tm_tm_brs_tm_subst_tm_brs_notin : lngen.

Lemma fv_tm_tm_co_tm_subst_tm_co_notin :
forall g1 a1 x1 x2,
  x2 `notin` fv_tm_tm_co g1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_co (tm_subst_tm_co a1 x1 g1).

Hint Resolve fv_tm_tm_co_tm_subst_tm_co_notin : lngen.

Lemma fv_tm_tm_constraint_tm_subst_tm_constraint_notin :
forall phi1 a1 x1 x2,
  x2 `notin` fv_tm_tm_constraint phi1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 `notin` fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve fv_tm_tm_constraint_tm_subst_tm_constraint_notin : lngen.

Lemma fv_tm_tm_tm_co_subst_co_tm_notin_fv_tm_tm_brs_co_subst_co_brs_notin_fv_tm_tm_co_co_subst_co_co_notin_fv_tm_tm_constraint_co_subst_co_constraint_notin_mutual :
(forall a1 g1 c1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_tm (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_brs (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 c1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 c1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_constraint (co_subst_co_constraint g1 c1 phi1)).

Lemma fv_tm_tm_tm_co_subst_co_tm_notin :
forall a1 g1 c1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_tm (co_subst_co_tm g1 c1 a1).

Hint Resolve fv_tm_tm_tm_co_subst_co_tm_notin : lngen.

Lemma fv_tm_tm_brs_co_subst_co_brs_notin :
forall brs1 g1 c1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_brs (co_subst_co_brs g1 c1 brs1).

Hint Resolve fv_tm_tm_brs_co_subst_co_brs_notin : lngen.

Lemma fv_tm_tm_co_co_subst_co_co_notin :
forall g1 g2 c1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co (co_subst_co_co g2 c1 g1).

Hint Resolve fv_tm_tm_co_co_subst_co_co_notin : lngen.

Lemma fv_tm_tm_constraint_co_subst_co_constraint_notin :
forall phi1 g1 c1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_constraint (co_subst_co_constraint g1 c1 phi1).

Hint Resolve fv_tm_tm_constraint_co_subst_co_constraint_notin : lngen.

Lemma fv_co_co_tm_tm_subst_tm_tm_notin_fv_co_co_brs_tm_subst_tm_brs_notin_fv_co_co_co_tm_subst_tm_co_notin_fv_co_co_constraint_tm_subst_tm_constraint_notin_mutual :
(forall a1 a2 x1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 x1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_brs (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_co (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_constraint (tm_subst_tm_constraint a1 x1 phi1)).

Lemma fv_co_co_tm_tm_subst_tm_tm_notin :
forall a1 a2 x1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm (tm_subst_tm_tm a2 x1 a1).

Hint Resolve fv_co_co_tm_tm_subst_tm_tm_notin : lngen.

Lemma fv_co_co_brs_tm_subst_tm_brs_notin :
forall brs1 a1 x1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_brs (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve fv_co_co_brs_tm_subst_tm_brs_notin : lngen.

Lemma fv_co_co_co_tm_subst_tm_co_notin :
forall g1 a1 x1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_co (tm_subst_tm_co a1 x1 g1).

Hint Resolve fv_co_co_co_tm_subst_tm_co_notin : lngen.

Lemma fv_co_co_constraint_tm_subst_tm_constraint_notin :
forall phi1 a1 x1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_constraint (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve fv_co_co_constraint_tm_subst_tm_constraint_notin : lngen.

Lemma fv_co_co_tm_co_subst_co_tm_notin_fv_co_co_brs_co_subst_co_brs_notin_fv_co_co_co_co_subst_co_co_notin_fv_co_co_constraint_co_subst_co_constraint_notin_mutual :
(forall a1 g1 c1 c2,
  c2 `notin` fv_co_co_tm a1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_tm (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1 c2,
  c2 `notin` fv_co_co_brs brs1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_brs (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 c1 c2,
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_co g2 ->
  c2 `notin` fv_co_co_co (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 c1 c2,
  c2 `notin` fv_co_co_constraint phi1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1)).

Lemma fv_co_co_tm_co_subst_co_tm_notin :
forall a1 g1 c1 c2,
  c2 `notin` fv_co_co_tm a1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_tm (co_subst_co_tm g1 c1 a1).

Hint Resolve fv_co_co_tm_co_subst_co_tm_notin : lngen.

Lemma fv_co_co_brs_co_subst_co_brs_notin :
forall brs1 g1 c1 c2,
  c2 `notin` fv_co_co_brs brs1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_brs (co_subst_co_brs g1 c1 brs1).

Hint Resolve fv_co_co_brs_co_subst_co_brs_notin : lngen.

Lemma fv_co_co_co_co_subst_co_co_notin :
forall g1 g2 c1 c2,
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_co g2 ->
  c2 `notin` fv_co_co_co (co_subst_co_co g2 c1 g1).

Hint Resolve fv_co_co_co_co_subst_co_co_notin : lngen.

Lemma fv_co_co_constraint_co_subst_co_constraint_notin :
forall phi1 g1 c1 c2,
  c2 `notin` fv_co_co_constraint phi1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 `notin` fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1).

Hint Resolve fv_co_co_constraint_co_subst_co_constraint_notin : lngen.

Lemma fv_tm_tm_tm_tm_subst_tm_tm_upper_fv_tm_tm_brs_tm_subst_tm_brs_upper_fv_tm_tm_co_tm_subst_tm_co_upper_fv_tm_tm_constraint_tm_subst_tm_constraint_upper_mutual :
(forall a1 a2 x1,
  fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1) [<=] fv_tm_tm_tm a2 `union` remove x1 (fv_tm_tm_tm a1)) /\
(forall brs1 a1 x1,
  fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1) [<=] fv_tm_tm_tm a1 `union` remove x1 (fv_tm_tm_brs brs1)) /\
(forall g1 a1 x1,
  fv_tm_tm_co (tm_subst_tm_co a1 x1 g1) [<=] fv_tm_tm_tm a1 `union` remove x1 (fv_tm_tm_co g1)) /\
(forall phi1 a1 x1,
  fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1) [<=] fv_tm_tm_tm a1 `union` remove x1 (fv_tm_tm_constraint phi1)).

Lemma fv_tm_tm_tm_tm_subst_tm_tm_upper :
forall a1 a2 x1,
  fv_tm_tm_tm (tm_subst_tm_tm a2 x1 a1) [<=] fv_tm_tm_tm a2 `union` remove x1 (fv_tm_tm_tm a1).

Hint Resolve fv_tm_tm_tm_tm_subst_tm_tm_upper : lngen.

Lemma fv_tm_tm_brs_tm_subst_tm_brs_upper :
forall brs1 a1 x1,
  fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1) [<=] fv_tm_tm_tm a1 `union` remove x1 (fv_tm_tm_brs brs1).

Hint Resolve fv_tm_tm_brs_tm_subst_tm_brs_upper : lngen.

Lemma fv_tm_tm_co_tm_subst_tm_co_upper :
forall g1 a1 x1,
  fv_tm_tm_co (tm_subst_tm_co a1 x1 g1) [<=] fv_tm_tm_tm a1 `union` remove x1 (fv_tm_tm_co g1).

Hint Resolve fv_tm_tm_co_tm_subst_tm_co_upper : lngen.

Lemma fv_tm_tm_constraint_tm_subst_tm_constraint_upper :
forall phi1 a1 x1,
  fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1) [<=] fv_tm_tm_tm a1 `union` remove x1 (fv_tm_tm_constraint phi1).

Hint Resolve fv_tm_tm_constraint_tm_subst_tm_constraint_upper : lngen.

Lemma fv_tm_tm_tm_co_subst_co_tm_upper_fv_tm_tm_brs_co_subst_co_brs_upper_fv_tm_tm_co_co_subst_co_co_upper_fv_tm_tm_constraint_co_subst_co_constraint_upper_mutual :
(forall a1 g1 c1,
  fv_tm_tm_tm (co_subst_co_tm g1 c1 a1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_tm a1) /\
(forall brs1 g1 c1,
  fv_tm_tm_brs (co_subst_co_brs g1 c1 brs1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_brs brs1) /\
(forall g1 g2 c1,
  fv_tm_tm_co (co_subst_co_co g2 c1 g1) [<=] fv_tm_tm_co g2 `union` fv_tm_tm_co g1) /\
(forall phi1 g1 c1,
  fv_tm_tm_constraint (co_subst_co_constraint g1 c1 phi1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_constraint phi1).

Lemma fv_tm_tm_tm_co_subst_co_tm_upper :
forall a1 g1 c1,
  fv_tm_tm_tm (co_subst_co_tm g1 c1 a1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_tm a1.

Hint Resolve fv_tm_tm_tm_co_subst_co_tm_upper : lngen.

Lemma fv_tm_tm_brs_co_subst_co_brs_upper :
forall brs1 g1 c1,
  fv_tm_tm_brs (co_subst_co_brs g1 c1 brs1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_brs brs1.

Hint Resolve fv_tm_tm_brs_co_subst_co_brs_upper : lngen.

Lemma fv_tm_tm_co_co_subst_co_co_upper :
forall g1 g2 c1,
  fv_tm_tm_co (co_subst_co_co g2 c1 g1) [<=] fv_tm_tm_co g2 `union` fv_tm_tm_co g1.

Hint Resolve fv_tm_tm_co_co_subst_co_co_upper : lngen.

Lemma fv_tm_tm_constraint_co_subst_co_constraint_upper :
forall phi1 g1 c1,
  fv_tm_tm_constraint (co_subst_co_constraint g1 c1 phi1) [<=] fv_tm_tm_co g1 `union` fv_tm_tm_constraint phi1.

Hint Resolve fv_tm_tm_constraint_co_subst_co_constraint_upper : lngen.

Lemma fv_co_co_tm_tm_subst_tm_tm_upper_fv_co_co_brs_tm_subst_tm_brs_upper_fv_co_co_co_tm_subst_tm_co_upper_fv_co_co_constraint_tm_subst_tm_constraint_upper_mutual :
(forall a1 a2 x1,
  fv_co_co_tm (tm_subst_tm_tm a2 x1 a1) [<=] fv_co_co_tm a2 `union` fv_co_co_tm a1) /\
(forall brs1 a1 x1,
  fv_co_co_brs (tm_subst_tm_brs a1 x1 brs1) [<=] fv_co_co_tm a1 `union` fv_co_co_brs brs1) /\
(forall g1 a1 x1,
  fv_co_co_co (tm_subst_tm_co a1 x1 g1) [<=] fv_co_co_tm a1 `union` fv_co_co_co g1) /\
(forall phi1 a1 x1,
  fv_co_co_constraint (tm_subst_tm_constraint a1 x1 phi1) [<=] fv_co_co_tm a1 `union` fv_co_co_constraint phi1).

Lemma fv_co_co_tm_tm_subst_tm_tm_upper :
forall a1 a2 x1,
  fv_co_co_tm (tm_subst_tm_tm a2 x1 a1) [<=] fv_co_co_tm a2 `union` fv_co_co_tm a1.

Hint Resolve fv_co_co_tm_tm_subst_tm_tm_upper : lngen.

Lemma fv_co_co_brs_tm_subst_tm_brs_upper :
forall brs1 a1 x1,
  fv_co_co_brs (tm_subst_tm_brs a1 x1 brs1) [<=] fv_co_co_tm a1 `union` fv_co_co_brs brs1.

Hint Resolve fv_co_co_brs_tm_subst_tm_brs_upper : lngen.

Lemma fv_co_co_co_tm_subst_tm_co_upper :
forall g1 a1 x1,
  fv_co_co_co (tm_subst_tm_co a1 x1 g1) [<=] fv_co_co_tm a1 `union` fv_co_co_co g1.

Hint Resolve fv_co_co_co_tm_subst_tm_co_upper : lngen.

Lemma fv_co_co_constraint_tm_subst_tm_constraint_upper :
forall phi1 a1 x1,
  fv_co_co_constraint (tm_subst_tm_constraint a1 x1 phi1) [<=] fv_co_co_tm a1 `union` fv_co_co_constraint phi1.

Hint Resolve fv_co_co_constraint_tm_subst_tm_constraint_upper : lngen.

Lemma fv_co_co_tm_co_subst_co_tm_upper_fv_co_co_brs_co_subst_co_brs_upper_fv_co_co_co_co_subst_co_co_upper_fv_co_co_constraint_co_subst_co_constraint_upper_mutual :
(forall a1 g1 c1,
  fv_co_co_tm (co_subst_co_tm g1 c1 a1) [<=] fv_co_co_co g1 `union` remove c1 (fv_co_co_tm a1)) /\
(forall brs1 g1 c1,
  fv_co_co_brs (co_subst_co_brs g1 c1 brs1) [<=] fv_co_co_co g1 `union` remove c1 (fv_co_co_brs brs1)) /\
(forall g1 g2 c1,
  fv_co_co_co (co_subst_co_co g2 c1 g1) [<=] fv_co_co_co g2 `union` remove c1 (fv_co_co_co g1)) /\
(forall phi1 g1 c1,
  fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1) [<=] fv_co_co_co g1 `union` remove c1 (fv_co_co_constraint phi1)).

Lemma fv_co_co_tm_co_subst_co_tm_upper :
forall a1 g1 c1,
  fv_co_co_tm (co_subst_co_tm g1 c1 a1) [<=] fv_co_co_co g1 `union` remove c1 (fv_co_co_tm a1).

Hint Resolve fv_co_co_tm_co_subst_co_tm_upper : lngen.

Lemma fv_co_co_brs_co_subst_co_brs_upper :
forall brs1 g1 c1,
  fv_co_co_brs (co_subst_co_brs g1 c1 brs1) [<=] fv_co_co_co g1 `union` remove c1 (fv_co_co_brs brs1).

Hint Resolve fv_co_co_brs_co_subst_co_brs_upper : lngen.

Lemma fv_co_co_co_co_subst_co_co_upper :
forall g1 g2 c1,
  fv_co_co_co (co_subst_co_co g2 c1 g1) [<=] fv_co_co_co g2 `union` remove c1 (fv_co_co_co g1).

Hint Resolve fv_co_co_co_co_subst_co_co_upper : lngen.

Lemma fv_co_co_constraint_co_subst_co_constraint_upper :
forall phi1 g1 c1,
  fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1) [<=] fv_co_co_co g1 `union` remove c1 (fv_co_co_constraint phi1).

Hint Resolve fv_co_co_constraint_co_subst_co_constraint_upper : lngen.

Ltac default_auto ::= auto with lngen brute_force; tauto.
Ltac default_autorewrite ::= autorewrite with lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_tm_rec_tm_subst_tm_brs_close_brs_wrt_tm_rec_tm_subst_tm_co_close_co_wrt_tm_rec_tm_subst_tm_constraint_close_constraint_wrt_tm_rec_mutual :
(forall a2 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_tm a1 x1 (close_tm_wrt_tm_rec n1 x2 a2) = close_tm_wrt_tm_rec n1 x2 (tm_subst_tm_tm a1 x1 a2)) /\
(forall brs1 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_brs a1 x1 (close_brs_wrt_tm_rec n1 x2 brs1) = close_brs_wrt_tm_rec n1 x2 (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_co a1 x1 (close_co_wrt_tm_rec n1 x2 g1) = close_co_wrt_tm_rec n1 x2 (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_constraint a1 x1 (close_constraint_wrt_tm_rec n1 x2 phi1) = close_constraint_wrt_tm_rec n1 x2 (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_close_tm_wrt_tm_rec :
forall a2 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_tm a1 x1 (close_tm_wrt_tm_rec n1 x2 a2) = close_tm_wrt_tm_rec n1 x2 (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_tm_rec : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_tm_rec :
forall brs1 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_brs a1 x1 (close_brs_wrt_tm_rec n1 x2 brs1) = close_brs_wrt_tm_rec n1 x2 (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_tm_rec : lngen.

Lemma tm_subst_tm_co_close_co_wrt_tm_rec :
forall g1 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_co a1 x1 (close_co_wrt_tm_rec n1 x2 g1) = close_co_wrt_tm_rec n1 x2 (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_close_co_wrt_tm_rec : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_tm_rec :
forall phi1 a1 x1 x2 n1,
  degree_tm_wrt_tm n1 a1 ->
  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_constraint a1 x1 (close_constraint_wrt_tm_rec n1 x2 phi1) = close_constraint_wrt_tm_rec n1 x2 (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_tm_rec : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_co_rec_tm_subst_tm_brs_close_brs_wrt_co_rec_tm_subst_tm_co_close_co_wrt_co_rec_tm_subst_tm_constraint_close_constraint_wrt_co_rec_mutual :
(forall a2 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_tm a1 c1 (close_tm_wrt_co_rec n1 x1 a2) = close_tm_wrt_co_rec n1 x1 (tm_subst_tm_tm a1 c1 a2)) /\
(forall brs1 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_brs a1 c1 (close_brs_wrt_co_rec n1 x1 brs1) = close_brs_wrt_co_rec n1 x1 (tm_subst_tm_brs a1 c1 brs1)) /\
(forall g1 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_co a1 c1 (close_co_wrt_co_rec n1 x1 g1) = close_co_wrt_co_rec n1 x1 (tm_subst_tm_co a1 c1 g1)) /\
(forall phi1 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_constraint a1 c1 (close_constraint_wrt_co_rec n1 x1 phi1) = close_constraint_wrt_co_rec n1 x1 (tm_subst_tm_constraint a1 c1 phi1)).

Lemma tm_subst_tm_tm_close_tm_wrt_co_rec :
forall a2 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_tm a1 c1 (close_tm_wrt_co_rec n1 x1 a2) = close_tm_wrt_co_rec n1 x1 (tm_subst_tm_tm a1 c1 a2).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_co_rec : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_co_rec :
forall brs1 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_brs a1 c1 (close_brs_wrt_co_rec n1 x1 brs1) = close_brs_wrt_co_rec n1 x1 (tm_subst_tm_brs a1 c1 brs1).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_co_rec : lngen.

Lemma tm_subst_tm_co_close_co_wrt_co_rec :
forall g1 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_co a1 c1 (close_co_wrt_co_rec n1 x1 g1) = close_co_wrt_co_rec n1 x1 (tm_subst_tm_co a1 c1 g1).

Hint Resolve tm_subst_tm_co_close_co_wrt_co_rec : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_co_rec :
forall phi1 a1 c1 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_constraint a1 c1 (close_constraint_wrt_co_rec n1 x1 phi1) = close_constraint_wrt_co_rec n1 x1 (tm_subst_tm_constraint a1 c1 phi1).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_co_rec : lngen.

Lemma co_subst_co_tm_close_tm_wrt_tm_rec_co_subst_co_brs_close_brs_wrt_tm_rec_co_subst_co_co_close_co_wrt_tm_rec_co_subst_co_constraint_close_constraint_wrt_tm_rec_mutual :
(forall a1 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_tm g1 x1 (close_tm_wrt_tm_rec n1 c1 a1) = close_tm_wrt_tm_rec n1 c1 (co_subst_co_tm g1 x1 a1)) /\
(forall brs1 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_brs g1 x1 (close_brs_wrt_tm_rec n1 c1 brs1) = close_brs_wrt_tm_rec n1 c1 (co_subst_co_brs g1 x1 brs1)) /\
(forall g2 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_co g1 x1 (close_co_wrt_tm_rec n1 c1 g2) = close_co_wrt_tm_rec n1 c1 (co_subst_co_co g1 x1 g2)) /\
(forall phi1 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_constraint g1 x1 (close_constraint_wrt_tm_rec n1 c1 phi1) = close_constraint_wrt_tm_rec n1 c1 (co_subst_co_constraint g1 x1 phi1)).

Lemma co_subst_co_tm_close_tm_wrt_tm_rec :
forall a1 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_tm g1 x1 (close_tm_wrt_tm_rec n1 c1 a1) = close_tm_wrt_tm_rec n1 c1 (co_subst_co_tm g1 x1 a1).

Hint Resolve co_subst_co_tm_close_tm_wrt_tm_rec : lngen.

Lemma co_subst_co_brs_close_brs_wrt_tm_rec :
forall brs1 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_brs g1 x1 (close_brs_wrt_tm_rec n1 c1 brs1) = close_brs_wrt_tm_rec n1 c1 (co_subst_co_brs g1 x1 brs1).

Hint Resolve co_subst_co_brs_close_brs_wrt_tm_rec : lngen.

Lemma co_subst_co_co_close_co_wrt_tm_rec :
forall g2 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_co g1 x1 (close_co_wrt_tm_rec n1 c1 g2) = close_co_wrt_tm_rec n1 c1 (co_subst_co_co g1 x1 g2).

Hint Resolve co_subst_co_co_close_co_wrt_tm_rec : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_tm_rec :
forall phi1 g1 x1 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_constraint g1 x1 (close_constraint_wrt_tm_rec n1 c1 phi1) = close_constraint_wrt_tm_rec n1 c1 (co_subst_co_constraint g1 x1 phi1).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_tm_rec : lngen.

Lemma co_subst_co_tm_close_tm_wrt_co_rec_co_subst_co_brs_close_brs_wrt_co_rec_co_subst_co_co_close_co_wrt_co_rec_co_subst_co_constraint_close_constraint_wrt_co_rec_mutual :
(forall a1 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_tm g1 c1 (close_tm_wrt_co_rec n1 c2 a1) = close_tm_wrt_co_rec n1 c2 (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_brs g1 c1 (close_brs_wrt_co_rec n1 c2 brs1) = close_brs_wrt_co_rec n1 c2 (co_subst_co_brs g1 c1 brs1)) /\
(forall g2 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_co g1 c1 (close_co_wrt_co_rec n1 c2 g2) = close_co_wrt_co_rec n1 c2 (co_subst_co_co g1 c1 g2)) /\
(forall phi1 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_constraint g1 c1 (close_constraint_wrt_co_rec n1 c2 phi1) = close_constraint_wrt_co_rec n1 c2 (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_close_tm_wrt_co_rec :
forall a1 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_tm g1 c1 (close_tm_wrt_co_rec n1 c2 a1) = close_tm_wrt_co_rec n1 c2 (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_close_tm_wrt_co_rec : lngen.

Lemma co_subst_co_brs_close_brs_wrt_co_rec :
forall brs1 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_brs g1 c1 (close_brs_wrt_co_rec n1 c2 brs1) = close_brs_wrt_co_rec n1 c2 (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_close_brs_wrt_co_rec : lngen.

Lemma co_subst_co_co_close_co_wrt_co_rec :
forall g2 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_co g1 c1 (close_co_wrt_co_rec n1 c2 g2) = close_co_wrt_co_rec n1 c2 (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_co_close_co_wrt_co_rec : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_co_rec :
forall phi1 g1 c1 c2 n1,
  degree_co_wrt_co n1 g1 ->
  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_constraint g1 c1 (close_constraint_wrt_co_rec n1 c2 phi1) = close_constraint_wrt_co_rec n1 c2 (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_co_rec : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_tm :
forall a2 a1 x1 x2,
  lc_tm a1 ->  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_tm a1 x1 (close_tm_wrt_tm x2 a2) = close_tm_wrt_tm x2 (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_tm : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_tm :
forall brs1 a1 x1 x2,
  lc_tm a1 ->  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_brs a1 x1 (close_brs_wrt_tm x2 brs1) = close_brs_wrt_tm x2 (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_tm : lngen.

Lemma tm_subst_tm_co_close_co_wrt_tm :
forall g1 a1 x1 x2,
  lc_tm a1 ->  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_co a1 x1 (close_co_wrt_tm x2 g1) = close_co_wrt_tm x2 (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_close_co_wrt_tm : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_tm :
forall phi1 a1 x1 x2,
  lc_tm a1 ->  x1 <> x2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  tm_subst_tm_constraint a1 x1 (close_constraint_wrt_tm x2 phi1) = close_constraint_wrt_tm x2 (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_tm : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_co :
forall a2 a1 c1 x1,
  lc_tm a1 ->  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_tm a1 c1 (close_tm_wrt_co x1 a2) = close_tm_wrt_co x1 (tm_subst_tm_tm a1 c1 a2).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_co : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_co :
forall brs1 a1 c1 x1,
  lc_tm a1 ->  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_brs a1 c1 (close_brs_wrt_co x1 brs1) = close_brs_wrt_co x1 (tm_subst_tm_brs a1 c1 brs1).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_co : lngen.

Lemma tm_subst_tm_co_close_co_wrt_co :
forall g1 a1 c1 x1,
  lc_tm a1 ->  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_co a1 c1 (close_co_wrt_co x1 g1) = close_co_wrt_co x1 (tm_subst_tm_co a1 c1 g1).

Hint Resolve tm_subst_tm_co_close_co_wrt_co : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_co :
forall phi1 a1 c1 x1,
  lc_tm a1 ->  x1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_constraint a1 c1 (close_constraint_wrt_co x1 phi1) = close_constraint_wrt_co x1 (tm_subst_tm_constraint a1 c1 phi1).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_co : lngen.

Lemma co_subst_co_tm_close_tm_wrt_tm :
forall a1 g1 x1 c1,
  lc_co g1 ->  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_tm g1 x1 (close_tm_wrt_tm c1 a1) = close_tm_wrt_tm c1 (co_subst_co_tm g1 x1 a1).

Hint Resolve co_subst_co_tm_close_tm_wrt_tm : lngen.

Lemma co_subst_co_brs_close_brs_wrt_tm :
forall brs1 g1 x1 c1,
  lc_co g1 ->  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_brs g1 x1 (close_brs_wrt_tm c1 brs1) = close_brs_wrt_tm c1 (co_subst_co_brs g1 x1 brs1).

Hint Resolve co_subst_co_brs_close_brs_wrt_tm : lngen.

Lemma co_subst_co_co_close_co_wrt_tm :
forall g2 g1 x1 c1,
  lc_co g1 ->  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_co g1 x1 (close_co_wrt_tm c1 g2) = close_co_wrt_tm c1 (co_subst_co_co g1 x1 g2).

Hint Resolve co_subst_co_co_close_co_wrt_tm : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_tm :
forall phi1 g1 x1 c1,
  lc_co g1 ->  c1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_constraint g1 x1 (close_constraint_wrt_tm c1 phi1) = close_constraint_wrt_tm c1 (co_subst_co_constraint g1 x1 phi1).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_tm : lngen.

Lemma co_subst_co_tm_close_tm_wrt_co :
forall a1 g1 c1 c2,
  lc_co g1 ->  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_tm g1 c1 (close_tm_wrt_co c2 a1) = close_tm_wrt_co c2 (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_close_tm_wrt_co : lngen.

Lemma co_subst_co_brs_close_brs_wrt_co :
forall brs1 g1 c1 c2,
  lc_co g1 ->  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_brs g1 c1 (close_brs_wrt_co c2 brs1) = close_brs_wrt_co c2 (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_close_brs_wrt_co : lngen.

Lemma co_subst_co_co_close_co_wrt_co :
forall g2 g1 c1 c2,
  lc_co g1 ->  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_co g1 c1 (close_co_wrt_co c2 g2) = close_co_wrt_co c2 (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_co_close_co_wrt_co : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_co :
forall phi1 g1 c1 c2,
  lc_co g1 ->  c1 <> c2 ->
  c2 `notin` fv_co_co_co g1 ->
  co_subst_co_constraint g1 c1 (close_constraint_wrt_co c2 phi1) = close_constraint_wrt_co c2 (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_co : lngen.

Lemma tm_subst_tm_tm_degree_tm_wrt_tm_tm_subst_tm_brs_degree_brs_wrt_tm_tm_subst_tm_co_degree_co_wrt_tm_tm_subst_tm_constraint_degree_constraint_wrt_tm_mutual :
(forall a1 a2 x1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm n1 a2 ->
  degree_tm_wrt_tm n1 (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 x1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_brs_wrt_tm n1 (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_constraint_wrt_tm n1 (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_degree_tm_wrt_tm :
forall a1 a2 x1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_tm_wrt_tm n1 a2 ->
  degree_tm_wrt_tm n1 (tm_subst_tm_tm a2 x1 a1).

Hint Resolve tm_subst_tm_tm_degree_tm_wrt_tm : lngen.

Lemma tm_subst_tm_brs_degree_brs_wrt_tm :
forall brs1 a1 x1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_brs_wrt_tm n1 (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_degree_brs_wrt_tm : lngen.

Lemma tm_subst_tm_co_degree_co_wrt_tm :
forall g1 a1 x1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_degree_co_wrt_tm : lngen.

Lemma tm_subst_tm_constraint_degree_constraint_wrt_tm :
forall phi1 a1 x1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_tm_wrt_tm n1 a1 ->
  degree_constraint_wrt_tm n1 (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_degree_constraint_wrt_tm : lngen.

Lemma tm_subst_tm_tm_degree_tm_wrt_co_tm_subst_tm_brs_degree_brs_wrt_co_tm_subst_tm_co_degree_co_wrt_co_tm_subst_tm_constraint_degree_constraint_wrt_co_mutual :
(forall a1 a2 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co n1 a2 ->
  degree_tm_wrt_co n1 (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 x1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_brs_wrt_co n1 (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_constraint_wrt_co n1 (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_degree_tm_wrt_co :
forall a1 a2 x1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_tm_wrt_co n1 a2 ->
  degree_tm_wrt_co n1 (tm_subst_tm_tm a2 x1 a1).

Hint Resolve tm_subst_tm_tm_degree_tm_wrt_co : lngen.

Lemma tm_subst_tm_brs_degree_brs_wrt_co :
forall brs1 a1 x1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_brs_wrt_co n1 (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_degree_brs_wrt_co : lngen.

Lemma tm_subst_tm_co_degree_co_wrt_co :
forall g1 a1 x1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_degree_co_wrt_co : lngen.

Lemma tm_subst_tm_constraint_degree_constraint_wrt_co :
forall phi1 a1 x1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_tm_wrt_co n1 a1 ->
  degree_constraint_wrt_co n1 (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_degree_constraint_wrt_co : lngen.

Lemma co_subst_co_tm_degree_tm_wrt_tm_co_subst_co_brs_degree_brs_wrt_tm_co_subst_co_co_degree_co_wrt_tm_co_subst_co_constraint_degree_constraint_wrt_tm_mutual :
(forall a1 g1 c1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_brs_wrt_tm n1 (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm n1 g2 ->
  degree_co_wrt_tm n1 (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 c1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_constraint_wrt_tm n1 (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_degree_tm_wrt_tm :
forall a1 g1 c1 n1,
  degree_tm_wrt_tm n1 a1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_tm_wrt_tm n1 (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_degree_tm_wrt_tm : lngen.

Lemma co_subst_co_brs_degree_brs_wrt_tm :
forall brs1 g1 c1 n1,
  degree_brs_wrt_tm n1 brs1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_brs_wrt_tm n1 (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_degree_brs_wrt_tm : lngen.

Lemma co_subst_co_co_degree_co_wrt_tm :
forall g1 g2 c1 n1,
  degree_co_wrt_tm n1 g1 ->
  degree_co_wrt_tm n1 g2 ->
  degree_co_wrt_tm n1 (co_subst_co_co g2 c1 g1).

Hint Resolve co_subst_co_co_degree_co_wrt_tm : lngen.

Lemma co_subst_co_constraint_degree_constraint_wrt_tm :
forall phi1 g1 c1 n1,
  degree_constraint_wrt_tm n1 phi1 ->
  degree_co_wrt_tm n1 g1 ->
  degree_constraint_wrt_tm n1 (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_degree_constraint_wrt_tm : lngen.

Lemma co_subst_co_tm_degree_tm_wrt_co_co_subst_co_brs_degree_brs_wrt_co_co_subst_co_co_degree_co_wrt_co_co_subst_co_constraint_degree_constraint_wrt_co_mutual :
(forall a1 g1 c1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_co_wrt_co n1 g1 ->
  degree_brs_wrt_co n1 (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 c1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co n1 g2 ->
  degree_co_wrt_co n1 (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 c1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_co_wrt_co n1 g1 ->
  degree_constraint_wrt_co n1 (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_degree_tm_wrt_co :
forall a1 g1 c1 n1,
  degree_tm_wrt_co n1 a1 ->
  degree_co_wrt_co n1 g1 ->
  degree_tm_wrt_co n1 (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_degree_tm_wrt_co : lngen.

Lemma co_subst_co_brs_degree_brs_wrt_co :
forall brs1 g1 c1 n1,
  degree_brs_wrt_co n1 brs1 ->
  degree_co_wrt_co n1 g1 ->
  degree_brs_wrt_co n1 (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_degree_brs_wrt_co : lngen.

Lemma co_subst_co_co_degree_co_wrt_co :
forall g1 g2 c1 n1,
  degree_co_wrt_co n1 g1 ->
  degree_co_wrt_co n1 g2 ->
  degree_co_wrt_co n1 (co_subst_co_co g2 c1 g1).

Hint Resolve co_subst_co_co_degree_co_wrt_co : lngen.

Lemma co_subst_co_constraint_degree_constraint_wrt_co :
forall phi1 g1 c1 n1,
  degree_constraint_wrt_co n1 phi1 ->
  degree_co_wrt_co n1 g1 ->
  degree_constraint_wrt_co n1 (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_degree_constraint_wrt_co : lngen.

Lemma tm_subst_tm_tm_fresh_eq_tm_subst_tm_brs_fresh_eq_tm_subst_tm_co_fresh_eq_tm_subst_tm_constraint_fresh_eq_mutual :
(forall a2 a1 x1,
  x1 `notin` fv_tm_tm_tm a2 ->
  tm_subst_tm_tm a1 x1 a2 = a2) /\
(forall brs1 a1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  tm_subst_tm_brs a1 x1 brs1 = brs1) /\
(forall g1 a1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  tm_subst_tm_co a1 x1 g1 = g1) /\
(forall phi1 a1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  tm_subst_tm_constraint a1 x1 phi1 = phi1).

Lemma tm_subst_tm_tm_fresh_eq :
forall a2 a1 x1,
  x1 `notin` fv_tm_tm_tm a2 ->
  tm_subst_tm_tm a1 x1 a2 = a2.

Hint Resolve tm_subst_tm_tm_fresh_eq : lngen.
Hint Rewrite tm_subst_tm_tm_fresh_eq using solve [auto] : lngen.

Lemma tm_subst_tm_brs_fresh_eq :
forall brs1 a1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  tm_subst_tm_brs a1 x1 brs1 = brs1.

Hint Resolve tm_subst_tm_brs_fresh_eq : lngen.
Hint Rewrite tm_subst_tm_brs_fresh_eq using solve [auto] : lngen.

Lemma tm_subst_tm_co_fresh_eq :
forall g1 a1 x1,
  x1 `notin` fv_tm_tm_co g1 ->
  tm_subst_tm_co a1 x1 g1 = g1.

Hint Resolve tm_subst_tm_co_fresh_eq : lngen.
Hint Rewrite tm_subst_tm_co_fresh_eq using solve [auto] : lngen.

Lemma tm_subst_tm_constraint_fresh_eq :
forall phi1 a1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  tm_subst_tm_constraint a1 x1 phi1 = phi1.

Hint Resolve tm_subst_tm_constraint_fresh_eq : lngen.
Hint Rewrite tm_subst_tm_constraint_fresh_eq using solve [auto] : lngen.

Lemma co_subst_co_tm_fresh_eq_co_subst_co_brs_fresh_eq_co_subst_co_co_fresh_eq_co_subst_co_constraint_fresh_eq_mutual :
(forall a1 g1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  co_subst_co_tm g1 c1 a1 = a1) /\
(forall brs1 g1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  co_subst_co_brs g1 c1 brs1 = brs1) /\
(forall g2 g1 c1,
  c1 `notin` fv_co_co_co g2 ->
  co_subst_co_co g1 c1 g2 = g2) /\
(forall phi1 g1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  co_subst_co_constraint g1 c1 phi1 = phi1).

Lemma co_subst_co_tm_fresh_eq :
forall a1 g1 c1,
  c1 `notin` fv_co_co_tm a1 ->
  co_subst_co_tm g1 c1 a1 = a1.

Hint Resolve co_subst_co_tm_fresh_eq : lngen.
Hint Rewrite co_subst_co_tm_fresh_eq using solve [auto] : lngen.

Lemma co_subst_co_brs_fresh_eq :
forall brs1 g1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  co_subst_co_brs g1 c1 brs1 = brs1.

Hint Resolve co_subst_co_brs_fresh_eq : lngen.
Hint Rewrite co_subst_co_brs_fresh_eq using solve [auto] : lngen.

Lemma co_subst_co_co_fresh_eq :
forall g2 g1 c1,
  c1 `notin` fv_co_co_co g2 ->
  co_subst_co_co g1 c1 g2 = g2.

Hint Resolve co_subst_co_co_fresh_eq : lngen.
Hint Rewrite co_subst_co_co_fresh_eq using solve [auto] : lngen.

Lemma co_subst_co_constraint_fresh_eq :
forall phi1 g1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  co_subst_co_constraint g1 c1 phi1 = phi1.

Hint Resolve co_subst_co_constraint_fresh_eq : lngen.
Hint Rewrite co_subst_co_constraint_fresh_eq using solve [auto] : lngen.

Lemma tm_subst_tm_tm_fresh_same_tm_subst_tm_brs_fresh_same_tm_subst_tm_co_fresh_same_tm_subst_tm_constraint_fresh_same_mutual :
(forall a2 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_tm (tm_subst_tm_tm a1 x1 a2)) /\
(forall brs1 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_fresh_same :
forall a2 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_tm (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_tm_fresh_same : lngen.

Lemma tm_subst_tm_brs_fresh_same :
forall brs1 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_brs (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_fresh_same : lngen.

Lemma tm_subst_tm_co_fresh_same :
forall g1 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_fresh_same : lngen.

Lemma tm_subst_tm_constraint_fresh_same :
forall phi1 a1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_constraint (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_fresh_same : lngen.

Lemma co_subst_co_tm_fresh_same_co_subst_co_brs_fresh_same_co_subst_co_co_fresh_same_co_subst_co_constraint_fresh_same_mutual :
(forall a1 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_brs (co_subst_co_brs g1 c1 brs1)) /\
(forall g2 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_co (co_subst_co_co g1 c1 g2)) /\
(forall phi1 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_fresh_same :
forall a1 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_fresh_same : lngen.

Lemma co_subst_co_brs_fresh_same :
forall brs1 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_brs (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_fresh_same : lngen.

Lemma co_subst_co_co_fresh_same :
forall g2 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_co (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_co_fresh_same : lngen.

Lemma co_subst_co_constraint_fresh_same :
forall phi1 g1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_constraint (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_fresh_same : lngen.

Lemma tm_subst_tm_tm_fresh_tm_subst_tm_brs_fresh_tm_subst_tm_co_fresh_tm_subst_tm_constraint_fresh_mutual :
(forall a2 a1 x1 x2,
  x1 `notin` fv_tm_tm_tm a2 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_tm (tm_subst_tm_tm a1 x2 a2)) /\
(forall brs1 a1 x1 x2,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_brs (tm_subst_tm_brs a1 x2 brs1)) /\
(forall g1 a1 x1 x2,
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co (tm_subst_tm_co a1 x2 g1)) /\
(forall phi1 a1 x1 x2,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_constraint (tm_subst_tm_constraint a1 x2 phi1)).

Lemma tm_subst_tm_tm_fresh :
forall a2 a1 x1 x2,
  x1 `notin` fv_tm_tm_tm a2 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_tm (tm_subst_tm_tm a1 x2 a2).

Hint Resolve tm_subst_tm_tm_fresh : lngen.

Lemma tm_subst_tm_brs_fresh :
forall brs1 a1 x1 x2,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_brs (tm_subst_tm_brs a1 x2 brs1).

Hint Resolve tm_subst_tm_brs_fresh : lngen.

Lemma tm_subst_tm_co_fresh :
forall g1 a1 x1 x2,
  x1 `notin` fv_tm_tm_co g1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co (tm_subst_tm_co a1 x2 g1).

Hint Resolve tm_subst_tm_co_fresh : lngen.

Lemma tm_subst_tm_constraint_fresh :
forall phi1 a1 x1 x2,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_constraint (tm_subst_tm_constraint a1 x2 phi1).

Hint Resolve tm_subst_tm_constraint_fresh : lngen.

Lemma co_subst_co_tm_fresh_co_subst_co_brs_fresh_co_subst_co_co_fresh_co_subst_co_constraint_fresh_mutual :
(forall a1 g1 c1 c2,
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm (co_subst_co_tm g1 c2 a1)) /\
(forall brs1 g1 c1 c2,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_brs (co_subst_co_brs g1 c2 brs1)) /\
(forall g2 g1 c1 c2,
  c1 `notin` fv_co_co_co g2 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_co (co_subst_co_co g1 c2 g2)) /\
(forall phi1 g1 c1 c2,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_constraint (co_subst_co_constraint g1 c2 phi1)).

Lemma co_subst_co_tm_fresh :
forall a1 g1 c1 c2,
  c1 `notin` fv_co_co_tm a1 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm (co_subst_co_tm g1 c2 a1).

Hint Resolve co_subst_co_tm_fresh : lngen.

Lemma co_subst_co_brs_fresh :
forall brs1 g1 c1 c2,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_brs (co_subst_co_brs g1 c2 brs1).

Hint Resolve co_subst_co_brs_fresh : lngen.

Lemma co_subst_co_co_fresh :
forall g2 g1 c1 c2,
  c1 `notin` fv_co_co_co g2 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_co (co_subst_co_co g1 c2 g2).

Hint Resolve co_subst_co_co_fresh : lngen.

Lemma co_subst_co_constraint_fresh :
forall phi1 g1 c1 c2,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_constraint (co_subst_co_constraint g1 c2 phi1).

Hint Resolve co_subst_co_constraint_fresh : lngen.

Lemma tm_subst_tm_tm_lc_tm :
forall a1 a2 x1,
  lc_tm a1 ->
  lc_tm a2 ->
  lc_tm (tm_subst_tm_tm a2 x1 a1).

Hint Resolve tm_subst_tm_tm_lc_tm : lngen.

Lemma tm_subst_tm_brs_lc_brs :
forall brs1 a1 x1,
  lc_brs brs1 ->
  lc_tm a1 ->
  lc_brs (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_lc_brs : lngen.

Lemma tm_subst_tm_co_lc_co :
forall g1 a1 x1,
  lc_co g1 ->
  lc_tm a1 ->
  lc_co (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_lc_co : lngen.

Lemma tm_subst_tm_constraint_lc_constraint :
forall phi1 a1 x1,
  lc_constraint phi1 ->
  lc_tm a1 ->
  lc_constraint (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_lc_constraint : lngen.

Lemma co_subst_co_tm_lc_tm :
forall a1 g1 c1,
  lc_tm a1 ->
  lc_co g1 ->
  lc_tm (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_lc_tm : lngen.

Lemma co_subst_co_brs_lc_brs :
forall brs1 g1 c1,
  lc_brs brs1 ->
  lc_co g1 ->
  lc_brs (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_lc_brs : lngen.

Lemma co_subst_co_co_lc_co :
forall g1 g2 c1,
  lc_co g1 ->
  lc_co g2 ->
  lc_co (co_subst_co_co g2 c1 g1).

Hint Resolve co_subst_co_co_lc_co : lngen.

Lemma co_subst_co_constraint_lc_constraint :
forall phi1 g1 c1,
  lc_constraint phi1 ->
  lc_co g1 ->
  lc_constraint (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_lc_constraint : lngen.

Lemma tm_subst_tm_tm_open_tm_wrt_tm_rec_tm_subst_tm_brs_open_brs_wrt_tm_rec_tm_subst_tm_co_open_co_wrt_tm_rec_tm_subst_tm_constraint_open_constraint_wrt_tm_rec_mutual :
(forall a3 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 (open_tm_wrt_tm_rec n1 a2 a3) = open_tm_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_tm a1 x1 a3)) /\
(forall brs1 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 (open_brs_wrt_tm_rec n1 a2 brs1) = open_brs_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 (open_co_wrt_tm_rec n1 a2 g1) = open_co_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm_rec n1 a2 phi1) = open_constraint_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_open_tm_wrt_tm_rec :
forall a3 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 (open_tm_wrt_tm_rec n1 a2 a3) = open_tm_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_tm a1 x1 a3).

Hint Resolve tm_subst_tm_tm_open_tm_wrt_tm_rec : lngen.

Lemma tm_subst_tm_brs_open_brs_wrt_tm_rec :
forall brs1 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 (open_brs_wrt_tm_rec n1 a2 brs1) = open_brs_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_open_brs_wrt_tm_rec : lngen.

Lemma tm_subst_tm_co_open_co_wrt_tm_rec :
forall g1 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 (open_co_wrt_tm_rec n1 a2 g1) = open_co_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_open_co_wrt_tm_rec : lngen.

Lemma tm_subst_tm_constraint_open_constraint_wrt_tm_rec :
forall phi1 a1 a2 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm_rec n1 a2 phi1) = open_constraint_wrt_tm_rec n1 (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_open_constraint_wrt_tm_rec : lngen.

Lemma tm_subst_tm_tm_open_tm_wrt_co_rec_tm_subst_tm_brs_open_brs_wrt_co_rec_tm_subst_tm_co_open_co_wrt_co_rec_tm_subst_tm_constraint_open_constraint_wrt_co_rec_mutual :
(forall a2 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 (open_tm_wrt_co_rec n1 g1 a2) = open_tm_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_tm a1 x1 a2)) /\
(forall brs1 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 (open_brs_wrt_co_rec n1 g1 brs1) = open_brs_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g2 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 (open_co_wrt_co_rec n1 g1 g2) = open_co_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_co a1 x1 g2)) /\
(forall phi1 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co_rec n1 g1 phi1) = open_constraint_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_open_tm_wrt_co_rec :
forall a2 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 (open_tm_wrt_co_rec n1 g1 a2) = open_tm_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_tm_open_tm_wrt_co_rec : lngen.

Lemma tm_subst_tm_brs_open_brs_wrt_co_rec :
forall brs1 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 (open_brs_wrt_co_rec n1 g1 brs1) = open_brs_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_open_brs_wrt_co_rec : lngen.

Lemma tm_subst_tm_co_open_co_wrt_co_rec :
forall g2 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 (open_co_wrt_co_rec n1 g1 g2) = open_co_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_co a1 x1 g2).

Hint Resolve tm_subst_tm_co_open_co_wrt_co_rec : lngen.

Lemma tm_subst_tm_constraint_open_constraint_wrt_co_rec :
forall phi1 a1 g1 x1 n1,
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co_rec n1 g1 phi1) = open_constraint_wrt_co_rec n1 (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_open_constraint_wrt_co_rec : lngen.

Lemma co_subst_co_tm_open_tm_wrt_tm_rec_co_subst_co_brs_open_brs_wrt_tm_rec_co_subst_co_co_open_co_wrt_tm_rec_co_subst_co_constraint_open_constraint_wrt_tm_rec_mutual :
(forall a2 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_tm g1 c1 (open_tm_wrt_tm_rec n1 a1 a2) = open_tm_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_tm g1 c1 a2)) /\
(forall brs1 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_brs g1 c1 (open_brs_wrt_tm_rec n1 a1 brs1) = open_brs_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_brs g1 c1 brs1)) /\
(forall g2 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_co g1 c1 (open_co_wrt_tm_rec n1 a1 g2) = open_co_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_co g1 c1 g2)) /\
(forall phi1 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_constraint g1 c1 (open_constraint_wrt_tm_rec n1 a1 phi1) = open_constraint_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_open_tm_wrt_tm_rec :
forall a2 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_tm g1 c1 (open_tm_wrt_tm_rec n1 a1 a2) = open_tm_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_tm g1 c1 a2).

Hint Resolve co_subst_co_tm_open_tm_wrt_tm_rec : lngen.

Lemma co_subst_co_brs_open_brs_wrt_tm_rec :
forall brs1 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_brs g1 c1 (open_brs_wrt_tm_rec n1 a1 brs1) = open_brs_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_open_brs_wrt_tm_rec : lngen.

Lemma co_subst_co_co_open_co_wrt_tm_rec :
forall g2 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_co g1 c1 (open_co_wrt_tm_rec n1 a1 g2) = open_co_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_co_open_co_wrt_tm_rec : lngen.

Lemma co_subst_co_constraint_open_constraint_wrt_tm_rec :
forall phi1 g1 a1 c1 n1,
  lc_co g1 ->
  co_subst_co_constraint g1 c1 (open_constraint_wrt_tm_rec n1 a1 phi1) = open_constraint_wrt_tm_rec n1 (co_subst_co_tm g1 c1 a1) (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_open_constraint_wrt_tm_rec : lngen.

Lemma co_subst_co_tm_open_tm_wrt_co_rec_co_subst_co_brs_open_brs_wrt_co_rec_co_subst_co_co_open_co_wrt_co_rec_co_subst_co_constraint_open_constraint_wrt_co_rec_mutual :
(forall a1 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_tm g1 c1 (open_tm_wrt_co_rec n1 g2 a1) = open_tm_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_brs g1 c1 (open_brs_wrt_co_rec n1 g2 brs1) = open_brs_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_brs g1 c1 brs1)) /\
(forall g3 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_co g1 c1 (open_co_wrt_co_rec n1 g2 g3) = open_co_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_co g1 c1 g3)) /\
(forall phi1 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_constraint g1 c1 (open_constraint_wrt_co_rec n1 g2 phi1) = open_constraint_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_open_tm_wrt_co_rec :
forall a1 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_tm g1 c1 (open_tm_wrt_co_rec n1 g2 a1) = open_tm_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_open_tm_wrt_co_rec : lngen.

Lemma co_subst_co_brs_open_brs_wrt_co_rec :
forall brs1 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_brs g1 c1 (open_brs_wrt_co_rec n1 g2 brs1) = open_brs_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_open_brs_wrt_co_rec : lngen.

Lemma co_subst_co_co_open_co_wrt_co_rec :
forall g3 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_co g1 c1 (open_co_wrt_co_rec n1 g2 g3) = open_co_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_co g1 c1 g3).

Hint Resolve co_subst_co_co_open_co_wrt_co_rec : lngen.

Lemma co_subst_co_constraint_open_constraint_wrt_co_rec :
forall phi1 g1 g2 c1 n1,
  lc_co g1 ->
  co_subst_co_constraint g1 c1 (open_constraint_wrt_co_rec n1 g2 phi1) = open_constraint_wrt_co_rec n1 (co_subst_co_co g1 c1 g2) (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_open_constraint_wrt_co_rec : lngen.

Lemma tm_subst_tm_tm_open_tm_wrt_tm :
forall a3 a1 a2 x1,
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 (open_tm_wrt_tm a3 a2) = open_tm_wrt_tm (tm_subst_tm_tm a1 x1 a3) (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_tm_open_tm_wrt_tm : lngen.

Lemma tm_subst_tm_brs_open_brs_wrt_tm :
forall brs1 a1 a2 x1,
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 (open_brs_wrt_tm brs1 a2) = open_brs_wrt_tm (tm_subst_tm_brs a1 x1 brs1) (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_brs_open_brs_wrt_tm : lngen.

Lemma tm_subst_tm_co_open_co_wrt_tm :
forall g1 a1 a2 x1,
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 (open_co_wrt_tm g1 a2) = open_co_wrt_tm (tm_subst_tm_co a1 x1 g1) (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_co_open_co_wrt_tm : lngen.

Lemma tm_subst_tm_constraint_open_constraint_wrt_tm :
forall phi1 a1 a2 x1,
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm phi1 a2) = open_constraint_wrt_tm (tm_subst_tm_constraint a1 x1 phi1) (tm_subst_tm_tm a1 x1 a2).

Hint Resolve tm_subst_tm_constraint_open_constraint_wrt_tm : lngen.

Lemma tm_subst_tm_tm_open_tm_wrt_co :
forall a2 a1 g1 x1,
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 (open_tm_wrt_co a2 g1) = open_tm_wrt_co (tm_subst_tm_tm a1 x1 a2) (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_tm_open_tm_wrt_co : lngen.

Lemma tm_subst_tm_brs_open_brs_wrt_co :
forall brs1 a1 g1 x1,
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 (open_brs_wrt_co brs1 g1) = open_brs_wrt_co (tm_subst_tm_brs a1 x1 brs1) (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_brs_open_brs_wrt_co : lngen.

Lemma tm_subst_tm_co_open_co_wrt_co :
forall g2 a1 g1 x1,
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 (open_co_wrt_co g2 g1) = open_co_wrt_co (tm_subst_tm_co a1 x1 g2) (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_open_co_wrt_co : lngen.

Lemma tm_subst_tm_constraint_open_constraint_wrt_co :
forall phi1 a1 g1 x1,
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co phi1 g1) = open_constraint_wrt_co (tm_subst_tm_constraint a1 x1 phi1) (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_constraint_open_constraint_wrt_co : lngen.

Lemma co_subst_co_tm_open_tm_wrt_tm :
forall a2 g1 a1 c1,
  lc_co g1 ->
  co_subst_co_tm g1 c1 (open_tm_wrt_tm a2 a1) = open_tm_wrt_tm (co_subst_co_tm g1 c1 a2) (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_open_tm_wrt_tm : lngen.

Lemma co_subst_co_brs_open_brs_wrt_tm :
forall brs1 g1 a1 c1,
  lc_co g1 ->
  co_subst_co_brs g1 c1 (open_brs_wrt_tm brs1 a1) = open_brs_wrt_tm (co_subst_co_brs g1 c1 brs1) (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_brs_open_brs_wrt_tm : lngen.

Lemma co_subst_co_co_open_co_wrt_tm :
forall g2 g1 a1 c1,
  lc_co g1 ->
  co_subst_co_co g1 c1 (open_co_wrt_tm g2 a1) = open_co_wrt_tm (co_subst_co_co g1 c1 g2) (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_co_open_co_wrt_tm : lngen.

Lemma co_subst_co_constraint_open_constraint_wrt_tm :
forall phi1 g1 a1 c1,
  lc_co g1 ->
  co_subst_co_constraint g1 c1 (open_constraint_wrt_tm phi1 a1) = open_constraint_wrt_tm (co_subst_co_constraint g1 c1 phi1) (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_constraint_open_constraint_wrt_tm : lngen.

Lemma co_subst_co_tm_open_tm_wrt_co :
forall a1 g1 g2 c1,
  lc_co g1 ->
  co_subst_co_tm g1 c1 (open_tm_wrt_co a1 g2) = open_tm_wrt_co (co_subst_co_tm g1 c1 a1) (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_tm_open_tm_wrt_co : lngen.

Lemma co_subst_co_brs_open_brs_wrt_co :
forall brs1 g1 g2 c1,
  lc_co g1 ->
  co_subst_co_brs g1 c1 (open_brs_wrt_co brs1 g2) = open_brs_wrt_co (co_subst_co_brs g1 c1 brs1) (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_brs_open_brs_wrt_co : lngen.

Lemma co_subst_co_co_open_co_wrt_co :
forall g3 g1 g2 c1,
  lc_co g1 ->
  co_subst_co_co g1 c1 (open_co_wrt_co g3 g2) = open_co_wrt_co (co_subst_co_co g1 c1 g3) (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_co_open_co_wrt_co : lngen.

Lemma co_subst_co_constraint_open_constraint_wrt_co :
forall phi1 g1 g2 c1,
  lc_co g1 ->
  co_subst_co_constraint g1 c1 (open_constraint_wrt_co phi1 g2) = open_constraint_wrt_co (co_subst_co_constraint g1 c1 phi1) (co_subst_co_co g1 c1 g2).

Hint Resolve co_subst_co_constraint_open_constraint_wrt_co : lngen.

Lemma tm_subst_tm_tm_open_tm_wrt_tm_var :
forall a2 a1 x1 x2,
  x1 <> x2 ->
  lc_tm a1 ->
  open_tm_wrt_tm (tm_subst_tm_tm a1 x1 a2) (a_Var_f x2) = tm_subst_tm_tm a1 x1 (open_tm_wrt_tm a2 (a_Var_f x2)).

Hint Resolve tm_subst_tm_tm_open_tm_wrt_tm_var : lngen.

Lemma tm_subst_tm_brs_open_brs_wrt_tm_var :
forall brs1 a1 x1 x2,
  x1 <> x2 ->
  lc_tm a1 ->
  open_brs_wrt_tm (tm_subst_tm_brs a1 x1 brs1) (a_Var_f x2) = tm_subst_tm_brs a1 x1 (open_brs_wrt_tm brs1 (a_Var_f x2)).

Hint Resolve tm_subst_tm_brs_open_brs_wrt_tm_var : lngen.

Lemma tm_subst_tm_co_open_co_wrt_tm_var :
forall g1 a1 x1 x2,
  x1 <> x2 ->
  lc_tm a1 ->
  open_co_wrt_tm (tm_subst_tm_co a1 x1 g1) (a_Var_f x2) = tm_subst_tm_co a1 x1 (open_co_wrt_tm g1 (a_Var_f x2)).

Hint Resolve tm_subst_tm_co_open_co_wrt_tm_var : lngen.

Lemma tm_subst_tm_constraint_open_constraint_wrt_tm_var :
forall phi1 a1 x1 x2,
  x1 <> x2 ->
  lc_tm a1 ->
  open_constraint_wrt_tm (tm_subst_tm_constraint a1 x1 phi1) (a_Var_f x2) = tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm phi1 (a_Var_f x2)).

Hint Resolve tm_subst_tm_constraint_open_constraint_wrt_tm_var : lngen.

Lemma tm_subst_tm_tm_open_tm_wrt_co_var :
forall a2 a1 x1 c1,
  lc_tm a1 ->
  open_tm_wrt_co (tm_subst_tm_tm a1 x1 a2) (g_Var_f c1) = tm_subst_tm_tm a1 x1 (open_tm_wrt_co a2 (g_Var_f c1)).

Hint Resolve tm_subst_tm_tm_open_tm_wrt_co_var : lngen.

Lemma tm_subst_tm_brs_open_brs_wrt_co_var :
forall brs1 a1 x1 c1,
  lc_tm a1 ->
  open_brs_wrt_co (tm_subst_tm_brs a1 x1 brs1) (g_Var_f c1) = tm_subst_tm_brs a1 x1 (open_brs_wrt_co brs1 (g_Var_f c1)).

Hint Resolve tm_subst_tm_brs_open_brs_wrt_co_var : lngen.

Lemma tm_subst_tm_co_open_co_wrt_co_var :
forall g1 a1 x1 c1,
  lc_tm a1 ->
  open_co_wrt_co (tm_subst_tm_co a1 x1 g1) (g_Var_f c1) = tm_subst_tm_co a1 x1 (open_co_wrt_co g1 (g_Var_f c1)).

Hint Resolve tm_subst_tm_co_open_co_wrt_co_var : lngen.

Lemma tm_subst_tm_constraint_open_constraint_wrt_co_var :
forall phi1 a1 x1 c1,
  lc_tm a1 ->
  open_constraint_wrt_co (tm_subst_tm_constraint a1 x1 phi1) (g_Var_f c1) = tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co phi1 (g_Var_f c1)).

Hint Resolve tm_subst_tm_constraint_open_constraint_wrt_co_var : lngen.

Lemma co_subst_co_tm_open_tm_wrt_tm_var :
forall a1 g1 c1 x1,
  lc_co g1 ->
  open_tm_wrt_tm (co_subst_co_tm g1 c1 a1) (a_Var_f x1) = co_subst_co_tm g1 c1 (open_tm_wrt_tm a1 (a_Var_f x1)).

Hint Resolve co_subst_co_tm_open_tm_wrt_tm_var : lngen.

Lemma co_subst_co_brs_open_brs_wrt_tm_var :
forall brs1 g1 c1 x1,
  lc_co g1 ->
  open_brs_wrt_tm (co_subst_co_brs g1 c1 brs1) (a_Var_f x1) = co_subst_co_brs g1 c1 (open_brs_wrt_tm brs1 (a_Var_f x1)).

Hint Resolve co_subst_co_brs_open_brs_wrt_tm_var : lngen.

Lemma co_subst_co_co_open_co_wrt_tm_var :
forall g2 g1 c1 x1,
  lc_co g1 ->
  open_co_wrt_tm (co_subst_co_co g1 c1 g2) (a_Var_f x1) = co_subst_co_co g1 c1 (open_co_wrt_tm g2 (a_Var_f x1)).

Hint Resolve co_subst_co_co_open_co_wrt_tm_var : lngen.

Lemma co_subst_co_constraint_open_constraint_wrt_tm_var :
forall phi1 g1 c1 x1,
  lc_co g1 ->
  open_constraint_wrt_tm (co_subst_co_constraint g1 c1 phi1) (a_Var_f x1) = co_subst_co_constraint g1 c1 (open_constraint_wrt_tm phi1 (a_Var_f x1)).

Hint Resolve co_subst_co_constraint_open_constraint_wrt_tm_var : lngen.

Lemma co_subst_co_tm_open_tm_wrt_co_var :
forall a1 g1 c1 c2,
  c1 <> c2 ->
  lc_co g1 ->
  open_tm_wrt_co (co_subst_co_tm g1 c1 a1) (g_Var_f c2) = co_subst_co_tm g1 c1 (open_tm_wrt_co a1 (g_Var_f c2)).

Hint Resolve co_subst_co_tm_open_tm_wrt_co_var : lngen.

Lemma co_subst_co_brs_open_brs_wrt_co_var :
forall brs1 g1 c1 c2,
  c1 <> c2 ->
  lc_co g1 ->
  open_brs_wrt_co (co_subst_co_brs g1 c1 brs1) (g_Var_f c2) = co_subst_co_brs g1 c1 (open_brs_wrt_co brs1 (g_Var_f c2)).

Hint Resolve co_subst_co_brs_open_brs_wrt_co_var : lngen.

Lemma co_subst_co_co_open_co_wrt_co_var :
forall g2 g1 c1 c2,
  c1 <> c2 ->
  lc_co g1 ->
  open_co_wrt_co (co_subst_co_co g1 c1 g2) (g_Var_f c2) = co_subst_co_co g1 c1 (open_co_wrt_co g2 (g_Var_f c2)).

Hint Resolve co_subst_co_co_open_co_wrt_co_var : lngen.

Lemma co_subst_co_constraint_open_constraint_wrt_co_var :
forall phi1 g1 c1 c2,
  c1 <> c2 ->
  lc_co g1 ->
  open_constraint_wrt_co (co_subst_co_constraint g1 c1 phi1) (g_Var_f c2) = co_subst_co_constraint g1 c1 (open_constraint_wrt_co phi1 (g_Var_f c2)).

Hint Resolve co_subst_co_constraint_open_constraint_wrt_co_var : lngen.

Lemma tm_subst_tm_tm_spec_rec_tm_subst_tm_brs_spec_rec_tm_subst_tm_co_spec_rec_tm_subst_tm_constraint_spec_rec_mutual :
(forall a1 a2 x1 n1,
  tm_subst_tm_tm a2 x1 a1 = open_tm_wrt_tm_rec n1 a2 (close_tm_wrt_tm_rec n1 x1 a1)) /\
(forall brs1 a1 x1 n1,
  tm_subst_tm_brs a1 x1 brs1 = open_brs_wrt_tm_rec n1 a1 (close_brs_wrt_tm_rec n1 x1 brs1)) /\
(forall g1 a1 x1 n1,
  tm_subst_tm_co a1 x1 g1 = open_co_wrt_tm_rec n1 a1 (close_co_wrt_tm_rec n1 x1 g1)) /\
(forall phi1 a1 x1 n1,
  tm_subst_tm_constraint a1 x1 phi1 = open_constraint_wrt_tm_rec n1 a1 (close_constraint_wrt_tm_rec n1 x1 phi1)).

Lemma tm_subst_tm_tm_spec_rec :
forall a1 a2 x1 n1,
  tm_subst_tm_tm a2 x1 a1 = open_tm_wrt_tm_rec n1 a2 (close_tm_wrt_tm_rec n1 x1 a1).

Hint Resolve tm_subst_tm_tm_spec_rec : lngen.

Lemma tm_subst_tm_brs_spec_rec :
forall brs1 a1 x1 n1,
  tm_subst_tm_brs a1 x1 brs1 = open_brs_wrt_tm_rec n1 a1 (close_brs_wrt_tm_rec n1 x1 brs1).

Hint Resolve tm_subst_tm_brs_spec_rec : lngen.

Lemma tm_subst_tm_co_spec_rec :
forall g1 a1 x1 n1,
  tm_subst_tm_co a1 x1 g1 = open_co_wrt_tm_rec n1 a1 (close_co_wrt_tm_rec n1 x1 g1).

Hint Resolve tm_subst_tm_co_spec_rec : lngen.

Lemma tm_subst_tm_constraint_spec_rec :
forall phi1 a1 x1 n1,
  tm_subst_tm_constraint a1 x1 phi1 = open_constraint_wrt_tm_rec n1 a1 (close_constraint_wrt_tm_rec n1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_spec_rec : lngen.

Lemma co_subst_co_tm_spec_rec_co_subst_co_brs_spec_rec_co_subst_co_co_spec_rec_co_subst_co_constraint_spec_rec_mutual :
(forall a1 g1 c1 n1,
  co_subst_co_tm g1 c1 a1 = open_tm_wrt_co_rec n1 g1 (close_tm_wrt_co_rec n1 c1 a1)) /\
(forall brs1 g1 c1 n1,
  co_subst_co_brs g1 c1 brs1 = open_brs_wrt_co_rec n1 g1 (close_brs_wrt_co_rec n1 c1 brs1)) /\
(forall g1 g2 c1 n1,
  co_subst_co_co g2 c1 g1 = open_co_wrt_co_rec n1 g2 (close_co_wrt_co_rec n1 c1 g1)) /\
(forall phi1 g1 c1 n1,
  co_subst_co_constraint g1 c1 phi1 = open_constraint_wrt_co_rec n1 g1 (close_constraint_wrt_co_rec n1 c1 phi1)).

Lemma co_subst_co_tm_spec_rec :
forall a1 g1 c1 n1,
  co_subst_co_tm g1 c1 a1 = open_tm_wrt_co_rec n1 g1 (close_tm_wrt_co_rec n1 c1 a1).

Hint Resolve co_subst_co_tm_spec_rec : lngen.

Lemma co_subst_co_brs_spec_rec :
forall brs1 g1 c1 n1,
  co_subst_co_brs g1 c1 brs1 = open_brs_wrt_co_rec n1 g1 (close_brs_wrt_co_rec n1 c1 brs1).

Hint Resolve co_subst_co_brs_spec_rec : lngen.

Lemma co_subst_co_co_spec_rec :
forall g1 g2 c1 n1,
  co_subst_co_co g2 c1 g1 = open_co_wrt_co_rec n1 g2 (close_co_wrt_co_rec n1 c1 g1).

Hint Resolve co_subst_co_co_spec_rec : lngen.

Lemma co_subst_co_constraint_spec_rec :
forall phi1 g1 c1 n1,
  co_subst_co_constraint g1 c1 phi1 = open_constraint_wrt_co_rec n1 g1 (close_constraint_wrt_co_rec n1 c1 phi1).

Hint Resolve co_subst_co_constraint_spec_rec : lngen.

Lemma tm_subst_tm_tm_spec :
forall a1 a2 x1,
  tm_subst_tm_tm a2 x1 a1 = open_tm_wrt_tm (close_tm_wrt_tm x1 a1) a2.

Hint Resolve tm_subst_tm_tm_spec : lngen.

Lemma tm_subst_tm_brs_spec :
forall brs1 a1 x1,
  tm_subst_tm_brs a1 x1 brs1 = open_brs_wrt_tm (close_brs_wrt_tm x1 brs1) a1.

Hint Resolve tm_subst_tm_brs_spec : lngen.

Lemma tm_subst_tm_co_spec :
forall g1 a1 x1,
  tm_subst_tm_co a1 x1 g1 = open_co_wrt_tm (close_co_wrt_tm x1 g1) a1.

Hint Resolve tm_subst_tm_co_spec : lngen.

Lemma tm_subst_tm_constraint_spec :
forall phi1 a1 x1,
  tm_subst_tm_constraint a1 x1 phi1 = open_constraint_wrt_tm (close_constraint_wrt_tm x1 phi1) a1.

Hint Resolve tm_subst_tm_constraint_spec : lngen.

Lemma co_subst_co_tm_spec :
forall a1 g1 c1,
  co_subst_co_tm g1 c1 a1 = open_tm_wrt_co (close_tm_wrt_co c1 a1) g1.

Hint Resolve co_subst_co_tm_spec : lngen.

Lemma co_subst_co_brs_spec :
forall brs1 g1 c1,
  co_subst_co_brs g1 c1 brs1 = open_brs_wrt_co (close_brs_wrt_co c1 brs1) g1.

Hint Resolve co_subst_co_brs_spec : lngen.

Lemma co_subst_co_co_spec :
forall g1 g2 c1,
  co_subst_co_co g2 c1 g1 = open_co_wrt_co (close_co_wrt_co c1 g1) g2.

Hint Resolve co_subst_co_co_spec : lngen.

Lemma co_subst_co_constraint_spec :
forall phi1 g1 c1,
  co_subst_co_constraint g1 c1 phi1 = open_constraint_wrt_co (close_constraint_wrt_co c1 phi1) g1.

Hint Resolve co_subst_co_constraint_spec : lngen.

Lemma tm_subst_tm_tm_tm_subst_tm_tm_tm_subst_tm_brs_tm_subst_tm_brs_tm_subst_tm_co_tm_subst_tm_co_tm_subst_tm_constraint_tm_subst_tm_constraint_mutual :
(forall a1 a2 a3 x2 x1,
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 <> x1 ->
  tm_subst_tm_tm a2 x1 (tm_subst_tm_tm a3 x2 a1) = tm_subst_tm_tm (tm_subst_tm_tm a2 x1 a3) x2 (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 a2 x2 x1,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  tm_subst_tm_brs a1 x1 (tm_subst_tm_brs a2 x2 brs1) = tm_subst_tm_brs (tm_subst_tm_tm a1 x1 a2) x2 (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 a2 x2 x1,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  tm_subst_tm_co a1 x1 (tm_subst_tm_co a2 x2 g1) = tm_subst_tm_co (tm_subst_tm_tm a1 x1 a2) x2 (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 a2 x2 x1,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  tm_subst_tm_constraint a1 x1 (tm_subst_tm_constraint a2 x2 phi1) = tm_subst_tm_constraint (tm_subst_tm_tm a1 x1 a2) x2 (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_tm_subst_tm_tm :
forall a1 a2 a3 x2 x1,
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 <> x1 ->
  tm_subst_tm_tm a2 x1 (tm_subst_tm_tm a3 x2 a1) = tm_subst_tm_tm (tm_subst_tm_tm a2 x1 a3) x2 (tm_subst_tm_tm a2 x1 a1).

Hint Resolve tm_subst_tm_tm_tm_subst_tm_tm : lngen.

Lemma tm_subst_tm_brs_tm_subst_tm_brs :
forall brs1 a1 a2 x2 x1,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  tm_subst_tm_brs a1 x1 (tm_subst_tm_brs a2 x2 brs1) = tm_subst_tm_brs (tm_subst_tm_tm a1 x1 a2) x2 (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_tm_subst_tm_brs : lngen.

Lemma tm_subst_tm_co_tm_subst_tm_co :
forall g1 a1 a2 x2 x1,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  tm_subst_tm_co a1 x1 (tm_subst_tm_co a2 x2 g1) = tm_subst_tm_co (tm_subst_tm_tm a1 x1 a2) x2 (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_tm_subst_tm_co : lngen.

Lemma tm_subst_tm_constraint_tm_subst_tm_constraint :
forall phi1 a1 a2 x2 x1,
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  tm_subst_tm_constraint a1 x1 (tm_subst_tm_constraint a2 x2 phi1) = tm_subst_tm_constraint (tm_subst_tm_tm a1 x1 a2) x2 (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_tm_subst_tm_constraint : lngen.

Lemma tm_subst_tm_tm_co_subst_co_tm_tm_subst_tm_brs_co_subst_co_brs_tm_subst_tm_co_co_subst_co_co_tm_subst_tm_constraint_co_subst_co_constraint_mutual :
(forall a1 a2 g1 c1 x1,
  c1 `notin` fv_co_co_tm a2 ->
  tm_subst_tm_tm a2 x1 (co_subst_co_tm g1 c1 a1) = co_subst_co_tm (tm_subst_tm_co a2 x1 g1) c1 (tm_subst_tm_tm a2 x1 a1)) /\
(forall brs1 a1 g1 c1 x1,
  c1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_brs a1 x1 (co_subst_co_brs g1 c1 brs1) = co_subst_co_brs (tm_subst_tm_co a1 x1 g1) c1 (tm_subst_tm_brs a1 x1 brs1)) /\
(forall g1 a1 g2 c1 x1,
  c1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_co a1 x1 (co_subst_co_co g2 c1 g1) = co_subst_co_co (tm_subst_tm_co a1 x1 g2) c1 (tm_subst_tm_co a1 x1 g1)) /\
(forall phi1 a1 g1 c1 x1,
  c1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_constraint a1 x1 (co_subst_co_constraint g1 c1 phi1) = co_subst_co_constraint (tm_subst_tm_co a1 x1 g1) c1 (tm_subst_tm_constraint a1 x1 phi1)).

Lemma tm_subst_tm_tm_co_subst_co_tm :
forall a1 a2 g1 c1 x1,
  c1 `notin` fv_co_co_tm a2 ->
  tm_subst_tm_tm a2 x1 (co_subst_co_tm g1 c1 a1) = co_subst_co_tm (tm_subst_tm_co a2 x1 g1) c1 (tm_subst_tm_tm a2 x1 a1).

Hint Resolve tm_subst_tm_tm_co_subst_co_tm : lngen.

Lemma tm_subst_tm_brs_co_subst_co_brs :
forall brs1 a1 g1 c1 x1,
  c1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_brs a1 x1 (co_subst_co_brs g1 c1 brs1) = co_subst_co_brs (tm_subst_tm_co a1 x1 g1) c1 (tm_subst_tm_brs a1 x1 brs1).

Hint Resolve tm_subst_tm_brs_co_subst_co_brs : lngen.

Lemma tm_subst_tm_co_co_subst_co_co :
forall g1 a1 g2 c1 x1,
  c1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_co a1 x1 (co_subst_co_co g2 c1 g1) = co_subst_co_co (tm_subst_tm_co a1 x1 g2) c1 (tm_subst_tm_co a1 x1 g1).

Hint Resolve tm_subst_tm_co_co_subst_co_co : lngen.

Lemma tm_subst_tm_constraint_co_subst_co_constraint :
forall phi1 a1 g1 c1 x1,
  c1 `notin` fv_co_co_tm a1 ->
  tm_subst_tm_constraint a1 x1 (co_subst_co_constraint g1 c1 phi1) = co_subst_co_constraint (tm_subst_tm_co a1 x1 g1) c1 (tm_subst_tm_constraint a1 x1 phi1).

Hint Resolve tm_subst_tm_constraint_co_subst_co_constraint : lngen.

Lemma co_subst_co_tm_tm_subst_tm_tm_co_subst_co_brs_tm_subst_tm_brs_co_subst_co_co_tm_subst_tm_co_co_subst_co_constraint_tm_subst_tm_constraint_mutual :
(forall a1 g1 a2 x1 c1,
  x1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_tm g1 c1 (tm_subst_tm_tm a2 x1 a1) = tm_subst_tm_tm (co_subst_co_tm g1 c1 a2) x1 (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 a1 x1 c1,
  x1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_brs g1 c1 (tm_subst_tm_brs a1 x1 brs1) = tm_subst_tm_brs (co_subst_co_tm g1 c1 a1) x1 (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 a1 x1 c1,
  x1 `notin` fv_tm_tm_co g2 ->
  co_subst_co_co g2 c1 (tm_subst_tm_co a1 x1 g1) = tm_subst_tm_co (co_subst_co_tm g2 c1 a1) x1 (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 a1 x1 c1,
  x1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_constraint g1 c1 (tm_subst_tm_constraint a1 x1 phi1) = tm_subst_tm_constraint (co_subst_co_tm g1 c1 a1) x1 (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_tm_subst_tm_tm :
forall a1 g1 a2 x1 c1,
  x1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_tm g1 c1 (tm_subst_tm_tm a2 x1 a1) = tm_subst_tm_tm (co_subst_co_tm g1 c1 a2) x1 (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_tm_subst_tm_tm : lngen.

Lemma co_subst_co_brs_tm_subst_tm_brs :
forall brs1 g1 a1 x1 c1,
  x1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_brs g1 c1 (tm_subst_tm_brs a1 x1 brs1) = tm_subst_tm_brs (co_subst_co_tm g1 c1 a1) x1 (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_tm_subst_tm_brs : lngen.

Lemma co_subst_co_co_tm_subst_tm_co :
forall g1 g2 a1 x1 c1,
  x1 `notin` fv_tm_tm_co g2 ->
  co_subst_co_co g2 c1 (tm_subst_tm_co a1 x1 g1) = tm_subst_tm_co (co_subst_co_tm g2 c1 a1) x1 (co_subst_co_co g2 c1 g1).

Hint Resolve co_subst_co_co_tm_subst_tm_co : lngen.

Lemma co_subst_co_constraint_tm_subst_tm_constraint :
forall phi1 g1 a1 x1 c1,
  x1 `notin` fv_tm_tm_co g1 ->
  co_subst_co_constraint g1 c1 (tm_subst_tm_constraint a1 x1 phi1) = tm_subst_tm_constraint (co_subst_co_tm g1 c1 a1) x1 (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_tm_subst_tm_constraint : lngen.

Lemma co_subst_co_tm_co_subst_co_tm_co_subst_co_brs_co_subst_co_brs_co_subst_co_co_co_subst_co_co_co_subst_co_constraint_co_subst_co_constraint_mutual :
(forall a1 g1 g2 c2 c1,
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  co_subst_co_tm g1 c1 (co_subst_co_tm g2 c2 a1) = co_subst_co_tm (co_subst_co_co g1 c1 g2) c2 (co_subst_co_tm g1 c1 a1)) /\
(forall brs1 g1 g2 c2 c1,
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  co_subst_co_brs g1 c1 (co_subst_co_brs g2 c2 brs1) = co_subst_co_brs (co_subst_co_co g1 c1 g2) c2 (co_subst_co_brs g1 c1 brs1)) /\
(forall g1 g2 g3 c2 c1,
  c2 `notin` fv_co_co_co g2 ->
  c2 <> c1 ->
  co_subst_co_co g2 c1 (co_subst_co_co g3 c2 g1) = co_subst_co_co (co_subst_co_co g2 c1 g3) c2 (co_subst_co_co g2 c1 g1)) /\
(forall phi1 g1 g2 c2 c1,
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  co_subst_co_constraint g1 c1 (co_subst_co_constraint g2 c2 phi1) = co_subst_co_constraint (co_subst_co_co g1 c1 g2) c2 (co_subst_co_constraint g1 c1 phi1)).

Lemma co_subst_co_tm_co_subst_co_tm :
forall a1 g1 g2 c2 c1,
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  co_subst_co_tm g1 c1 (co_subst_co_tm g2 c2 a1) = co_subst_co_tm (co_subst_co_co g1 c1 g2) c2 (co_subst_co_tm g1 c1 a1).

Hint Resolve co_subst_co_tm_co_subst_co_tm : lngen.

Lemma co_subst_co_brs_co_subst_co_brs :
forall brs1 g1 g2 c2 c1,
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  co_subst_co_brs g1 c1 (co_subst_co_brs g2 c2 brs1) = co_subst_co_brs (co_subst_co_co g1 c1 g2) c2 (co_subst_co_brs g1 c1 brs1).

Hint Resolve co_subst_co_brs_co_subst_co_brs : lngen.

Lemma co_subst_co_co_co_subst_co_co :
forall g1 g2 g3 c2 c1,
  c2 `notin` fv_co_co_co g2 ->
  c2 <> c1 ->
  co_subst_co_co g2 c1 (co_subst_co_co g3 c2 g1) = co_subst_co_co (co_subst_co_co g2 c1 g3) c2 (co_subst_co_co g2 c1 g1).

Hint Resolve co_subst_co_co_co_subst_co_co : lngen.

Lemma co_subst_co_constraint_co_subst_co_constraint :
forall phi1 g1 g2 c2 c1,
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  co_subst_co_constraint g1 c1 (co_subst_co_constraint g2 c2 phi1) = co_subst_co_constraint (co_subst_co_co g1 c1 g2) c2 (co_subst_co_constraint g1 c1 phi1).

Hint Resolve co_subst_co_constraint_co_subst_co_constraint : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_tm_rec_open_tm_wrt_tm_rec_tm_subst_tm_brs_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec_tm_subst_tm_co_close_co_wrt_tm_rec_open_co_wrt_tm_rec_tm_subst_tm_constraint_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec_mutual :
(forall a2 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_tm a1 x1 a2 = close_tm_wrt_tm_rec n1 x2 (tm_subst_tm_tm a1 x1 (open_tm_wrt_tm_rec n1 (a_Var_f x2) a2))) *
(forall brs1 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_brs brs1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_brs a1 x1 brs1 = close_brs_wrt_tm_rec n1 x2 (tm_subst_tm_brs a1 x1 (open_brs_wrt_tm_rec n1 (a_Var_f x2) brs1))) *
(forall g1 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_co g1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_co a1 x1 g1 = close_co_wrt_tm_rec n1 x2 (tm_subst_tm_co a1 x1 (open_co_wrt_tm_rec n1 (a_Var_f x2) g1))) *
(forall phi1 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_constraint phi1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_constraint a1 x1 phi1 = close_constraint_wrt_tm_rec n1 x2 (tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm_rec n1 (a_Var_f x2) phi1))).

Lemma tm_subst_tm_tm_close_tm_wrt_tm_rec_open_tm_wrt_tm_rec :
forall a2 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_tm a1 x1 a2 = close_tm_wrt_tm_rec n1 x2 (tm_subst_tm_tm a1 x1 (open_tm_wrt_tm_rec n1 (a_Var_f x2) a2)).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_tm_rec_open_tm_wrt_tm_rec : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec :
forall brs1 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_brs brs1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_brs a1 x1 brs1 = close_brs_wrt_tm_rec n1 x2 (tm_subst_tm_brs a1 x1 (open_brs_wrt_tm_rec n1 (a_Var_f x2) brs1)).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec : lngen.

Lemma tm_subst_tm_co_close_co_wrt_tm_rec_open_co_wrt_tm_rec :
forall g1 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_co g1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_co a1 x1 g1 = close_co_wrt_tm_rec n1 x2 (tm_subst_tm_co a1 x1 (open_co_wrt_tm_rec n1 (a_Var_f x2) g1)).

Hint Resolve tm_subst_tm_co_close_co_wrt_tm_rec_open_co_wrt_tm_rec : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec :
forall phi1 a1 x1 x2 n1,
  x2 `notin` fv_tm_tm_constraint phi1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  degree_tm_wrt_tm n1 a1 ->
  tm_subst_tm_constraint a1 x1 phi1 = close_constraint_wrt_tm_rec n1 x2 (tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm_rec n1 (a_Var_f x2) phi1)).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_co_rec_open_tm_wrt_co_rec_tm_subst_tm_brs_close_brs_wrt_co_rec_open_brs_wrt_co_rec_tm_subst_tm_co_close_co_wrt_co_rec_open_co_wrt_co_rec_tm_subst_tm_constraint_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec_mutual :
(forall a2 a1 x1 c1 n1,
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_tm a1 x1 a2 = close_tm_wrt_co_rec n1 c1 (tm_subst_tm_tm a1 x1 (open_tm_wrt_co_rec n1 (g_Var_f c1) a2))) *
(forall brs1 a1 x1 c1 n1,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_brs a1 x1 brs1 = close_brs_wrt_co_rec n1 c1 (tm_subst_tm_brs a1 x1 (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1))) *
(forall g1 a1 x1 c1 n1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_co a1 x1 g1 = close_co_wrt_co_rec n1 c1 (tm_subst_tm_co a1 x1 (open_co_wrt_co_rec n1 (g_Var_f c1) g1))) *
(forall phi1 a1 x1 c1 n1,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_constraint a1 x1 phi1 = close_constraint_wrt_co_rec n1 c1 (tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1))).

Lemma tm_subst_tm_tm_close_tm_wrt_co_rec_open_tm_wrt_co_rec :
forall a2 a1 x1 c1 n1,
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_tm a1 x1 a2 = close_tm_wrt_co_rec n1 c1 (tm_subst_tm_tm a1 x1 (open_tm_wrt_co_rec n1 (g_Var_f c1) a2)).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_co_rec_open_tm_wrt_co_rec : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_co_rec_open_brs_wrt_co_rec :
forall brs1 a1 x1 c1 n1,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_brs a1 x1 brs1 = close_brs_wrt_co_rec n1 c1 (tm_subst_tm_brs a1 x1 (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1)).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_co_rec_open_brs_wrt_co_rec : lngen.

Lemma tm_subst_tm_co_close_co_wrt_co_rec_open_co_wrt_co_rec :
forall g1 a1 x1 c1 n1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_co a1 x1 g1 = close_co_wrt_co_rec n1 c1 (tm_subst_tm_co a1 x1 (open_co_wrt_co_rec n1 (g_Var_f c1) g1)).

Hint Resolve tm_subst_tm_co_close_co_wrt_co_rec_open_co_wrt_co_rec : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec :
forall phi1 a1 x1 c1 n1,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_tm a1 ->
  degree_tm_wrt_co n1 a1 ->
  tm_subst_tm_constraint a1 x1 phi1 = close_constraint_wrt_co_rec n1 c1 (tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1)).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec : lngen.

Lemma co_subst_co_tm_close_tm_wrt_tm_rec_open_tm_wrt_tm_rec_co_subst_co_brs_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec_co_subst_co_co_close_co_wrt_tm_rec_open_co_wrt_tm_rec_co_subst_co_constraint_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec_mutual :
(forall a1 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_tm g1 c1 a1 = close_tm_wrt_tm_rec n1 x1 (co_subst_co_tm g1 c1 (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1))) *
(forall brs1 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_brs g1 c1 brs1 = close_brs_wrt_tm_rec n1 x1 (co_subst_co_brs g1 c1 (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1))) *
(forall g2 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_co g1 c1 g2 = close_co_wrt_tm_rec n1 x1 (co_subst_co_co g1 c1 (open_co_wrt_tm_rec n1 (a_Var_f x1) g2))) *
(forall phi1 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_constraint g1 c1 phi1 = close_constraint_wrt_tm_rec n1 x1 (co_subst_co_constraint g1 c1 (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1))).

Lemma co_subst_co_tm_close_tm_wrt_tm_rec_open_tm_wrt_tm_rec :
forall a1 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_tm g1 c1 a1 = close_tm_wrt_tm_rec n1 x1 (co_subst_co_tm g1 c1 (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1)).

Hint Resolve co_subst_co_tm_close_tm_wrt_tm_rec_open_tm_wrt_tm_rec : lngen.

Lemma co_subst_co_brs_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec :
forall brs1 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_brs g1 c1 brs1 = close_brs_wrt_tm_rec n1 x1 (co_subst_co_brs g1 c1 (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1)).

Hint Resolve co_subst_co_brs_close_brs_wrt_tm_rec_open_brs_wrt_tm_rec : lngen.

Lemma co_subst_co_co_close_co_wrt_tm_rec_open_co_wrt_tm_rec :
forall g2 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_co g1 c1 g2 = close_co_wrt_tm_rec n1 x1 (co_subst_co_co g1 c1 (open_co_wrt_tm_rec n1 (a_Var_f x1) g2)).

Hint Resolve co_subst_co_co_close_co_wrt_tm_rec_open_co_wrt_tm_rec : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec :
forall phi1 g1 c1 x1 n1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  degree_co_wrt_tm n1 g1 ->
  co_subst_co_constraint g1 c1 phi1 = close_constraint_wrt_tm_rec n1 x1 (co_subst_co_constraint g1 c1 (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1)).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_tm_rec_open_constraint_wrt_tm_rec : lngen.

Lemma co_subst_co_tm_close_tm_wrt_co_rec_open_tm_wrt_co_rec_co_subst_co_brs_close_brs_wrt_co_rec_open_brs_wrt_co_rec_co_subst_co_co_close_co_wrt_co_rec_open_co_wrt_co_rec_co_subst_co_constraint_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec_mutual :
(forall a1 g1 c1 c2 n1,
  c2 `notin` fv_co_co_tm a1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_tm g1 c1 a1 = close_tm_wrt_co_rec n1 c2 (co_subst_co_tm g1 c1 (open_tm_wrt_co_rec n1 (g_Var_f c2) a1))) *
(forall brs1 g1 c1 c2 n1,
  c2 `notin` fv_co_co_brs brs1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_brs g1 c1 brs1 = close_brs_wrt_co_rec n1 c2 (co_subst_co_brs g1 c1 (open_brs_wrt_co_rec n1 (g_Var_f c2) brs1))) *
(forall g2 g1 c1 c2 n1,
  c2 `notin` fv_co_co_co g2 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_co g1 c1 g2 = close_co_wrt_co_rec n1 c2 (co_subst_co_co g1 c1 (open_co_wrt_co_rec n1 (g_Var_f c2) g2))) *
(forall phi1 g1 c1 c2 n1,
  c2 `notin` fv_co_co_constraint phi1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_constraint g1 c1 phi1 = close_constraint_wrt_co_rec n1 c2 (co_subst_co_constraint g1 c1 (open_constraint_wrt_co_rec n1 (g_Var_f c2) phi1))).

Lemma co_subst_co_tm_close_tm_wrt_co_rec_open_tm_wrt_co_rec :
forall a1 g1 c1 c2 n1,
  c2 `notin` fv_co_co_tm a1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_tm g1 c1 a1 = close_tm_wrt_co_rec n1 c2 (co_subst_co_tm g1 c1 (open_tm_wrt_co_rec n1 (g_Var_f c2) a1)).

Hint Resolve co_subst_co_tm_close_tm_wrt_co_rec_open_tm_wrt_co_rec : lngen.

Lemma co_subst_co_brs_close_brs_wrt_co_rec_open_brs_wrt_co_rec :
forall brs1 g1 c1 c2 n1,
  c2 `notin` fv_co_co_brs brs1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_brs g1 c1 brs1 = close_brs_wrt_co_rec n1 c2 (co_subst_co_brs g1 c1 (open_brs_wrt_co_rec n1 (g_Var_f c2) brs1)).

Hint Resolve co_subst_co_brs_close_brs_wrt_co_rec_open_brs_wrt_co_rec : lngen.

Lemma co_subst_co_co_close_co_wrt_co_rec_open_co_wrt_co_rec :
forall g2 g1 c1 c2 n1,
  c2 `notin` fv_co_co_co g2 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_co g1 c1 g2 = close_co_wrt_co_rec n1 c2 (co_subst_co_co g1 c1 (open_co_wrt_co_rec n1 (g_Var_f c2) g2)).

Hint Resolve co_subst_co_co_close_co_wrt_co_rec_open_co_wrt_co_rec : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec :
forall phi1 g1 c1 c2 n1,
  c2 `notin` fv_co_co_constraint phi1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  degree_co_wrt_co n1 g1 ->
  co_subst_co_constraint g1 c1 phi1 = close_constraint_wrt_co_rec n1 c2 (co_subst_co_constraint g1 c1 (open_constraint_wrt_co_rec n1 (g_Var_f c2) phi1)).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_co_rec_open_constraint_wrt_co_rec : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_tm_open_tm_wrt_tm :
forall a2 a1 x1 x2,
  x2 `notin` fv_tm_tm_tm a2 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 a2 = close_tm_wrt_tm x2 (tm_subst_tm_tm a1 x1 (open_tm_wrt_tm a2 (a_Var_f x2))).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_tm_open_tm_wrt_tm : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_tm_open_brs_wrt_tm :
forall brs1 a1 x1 x2,
  x2 `notin` fv_tm_tm_brs brs1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 brs1 = close_brs_wrt_tm x2 (tm_subst_tm_brs a1 x1 (open_brs_wrt_tm brs1 (a_Var_f x2))).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_tm_open_brs_wrt_tm : lngen.

Lemma tm_subst_tm_co_close_co_wrt_tm_open_co_wrt_tm :
forall g1 a1 x1 x2,
  x2 `notin` fv_tm_tm_co g1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 g1 = close_co_wrt_tm x2 (tm_subst_tm_co a1 x1 (open_co_wrt_tm g1 (a_Var_f x2))).

Hint Resolve tm_subst_tm_co_close_co_wrt_tm_open_co_wrt_tm : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_tm_open_constraint_wrt_tm :
forall phi1 a1 x1 x2,
  x2 `notin` fv_tm_tm_constraint phi1 ->
  x2 `notin` fv_tm_tm_tm a1 ->
  x2 <> x1 ->
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 phi1 = close_constraint_wrt_tm x2 (tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm phi1 (a_Var_f x2))).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_tm_open_constraint_wrt_tm : lngen.

Lemma tm_subst_tm_tm_close_tm_wrt_co_open_tm_wrt_co :
forall a2 a1 x1 c1,
  c1 `notin` fv_co_co_tm a2 ->
  c1 `notin` fv_co_co_tm a1 ->
  lc_tm a1 ->
  tm_subst_tm_tm a1 x1 a2 = close_tm_wrt_co c1 (tm_subst_tm_tm a1 x1 (open_tm_wrt_co a2 (g_Var_f c1))).

Hint Resolve tm_subst_tm_tm_close_tm_wrt_co_open_tm_wrt_co : lngen.

Lemma tm_subst_tm_brs_close_brs_wrt_co_open_brs_wrt_co :
forall brs1 a1 x1 c1,
  c1 `notin` fv_co_co_brs brs1 ->
  c1 `notin` fv_co_co_tm a1 ->
  lc_tm a1 ->
  tm_subst_tm_brs a1 x1 brs1 = close_brs_wrt_co c1 (tm_subst_tm_brs a1 x1 (open_brs_wrt_co brs1 (g_Var_f c1))).

Hint Resolve tm_subst_tm_brs_close_brs_wrt_co_open_brs_wrt_co : lngen.

Lemma tm_subst_tm_co_close_co_wrt_co_open_co_wrt_co :
forall g1 a1 x1 c1,
  c1 `notin` fv_co_co_co g1 ->
  c1 `notin` fv_co_co_tm a1 ->
  lc_tm a1 ->
  tm_subst_tm_co a1 x1 g1 = close_co_wrt_co c1 (tm_subst_tm_co a1 x1 (open_co_wrt_co g1 (g_Var_f c1))).

Hint Resolve tm_subst_tm_co_close_co_wrt_co_open_co_wrt_co : lngen.

Lemma tm_subst_tm_constraint_close_constraint_wrt_co_open_constraint_wrt_co :
forall phi1 a1 x1 c1,
  c1 `notin` fv_co_co_constraint phi1 ->
  c1 `notin` fv_co_co_tm a1 ->
  lc_tm a1 ->
  tm_subst_tm_constraint a1 x1 phi1 = close_constraint_wrt_co c1 (tm_subst_tm_constraint a1 x1 (open_constraint_wrt_co phi1 (g_Var_f c1))).

Hint Resolve tm_subst_tm_constraint_close_constraint_wrt_co_open_constraint_wrt_co : lngen.

Lemma co_subst_co_tm_close_tm_wrt_tm_open_tm_wrt_tm :
forall a1 g1 c1 x1,
  x1 `notin` fv_tm_tm_tm a1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  lc_co g1 ->
  co_subst_co_tm g1 c1 a1 = close_tm_wrt_tm x1 (co_subst_co_tm g1 c1 (open_tm_wrt_tm a1 (a_Var_f x1))).

Hint Resolve co_subst_co_tm_close_tm_wrt_tm_open_tm_wrt_tm : lngen.

Lemma co_subst_co_brs_close_brs_wrt_tm_open_brs_wrt_tm :
forall brs1 g1 c1 x1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  lc_co g1 ->
  co_subst_co_brs g1 c1 brs1 = close_brs_wrt_tm x1 (co_subst_co_brs g1 c1 (open_brs_wrt_tm brs1 (a_Var_f x1))).

Hint Resolve co_subst_co_brs_close_brs_wrt_tm_open_brs_wrt_tm : lngen.

Lemma co_subst_co_co_close_co_wrt_tm_open_co_wrt_tm :
forall g2 g1 c1 x1,
  x1 `notin` fv_tm_tm_co g2 ->
  x1 `notin` fv_tm_tm_co g1 ->
  lc_co g1 ->
  co_subst_co_co g1 c1 g2 = close_co_wrt_tm x1 (co_subst_co_co g1 c1 (open_co_wrt_tm g2 (a_Var_f x1))).

Hint Resolve co_subst_co_co_close_co_wrt_tm_open_co_wrt_tm : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_tm_open_constraint_wrt_tm :
forall phi1 g1 c1 x1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  x1 `notin` fv_tm_tm_co g1 ->
  lc_co g1 ->
  co_subst_co_constraint g1 c1 phi1 = close_constraint_wrt_tm x1 (co_subst_co_constraint g1 c1 (open_constraint_wrt_tm phi1 (a_Var_f x1))).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_tm_open_constraint_wrt_tm : lngen.

Lemma co_subst_co_tm_close_tm_wrt_co_open_tm_wrt_co :
forall a1 g1 c1 c2,
  c2 `notin` fv_co_co_tm a1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  lc_co g1 ->
  co_subst_co_tm g1 c1 a1 = close_tm_wrt_co c2 (co_subst_co_tm g1 c1 (open_tm_wrt_co a1 (g_Var_f c2))).

Hint Resolve co_subst_co_tm_close_tm_wrt_co_open_tm_wrt_co : lngen.

Lemma co_subst_co_brs_close_brs_wrt_co_open_brs_wrt_co :
forall brs1 g1 c1 c2,
  c2 `notin` fv_co_co_brs brs1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  lc_co g1 ->
  co_subst_co_brs g1 c1 brs1 = close_brs_wrt_co c2 (co_subst_co_brs g1 c1 (open_brs_wrt_co brs1 (g_Var_f c2))).

Hint Resolve co_subst_co_brs_close_brs_wrt_co_open_brs_wrt_co : lngen.

Lemma co_subst_co_co_close_co_wrt_co_open_co_wrt_co :
forall g2 g1 c1 c2,
  c2 `notin` fv_co_co_co g2 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  lc_co g1 ->
  co_subst_co_co g1 c1 g2 = close_co_wrt_co c2 (co_subst_co_co g1 c1 (open_co_wrt_co g2 (g_Var_f c2))).

Hint Resolve co_subst_co_co_close_co_wrt_co_open_co_wrt_co : lngen.

Lemma co_subst_co_constraint_close_constraint_wrt_co_open_constraint_wrt_co :
forall phi1 g1 c1 c2,
  c2 `notin` fv_co_co_constraint phi1 ->
  c2 `notin` fv_co_co_co g1 ->
  c2 <> c1 ->
  lc_co g1 ->
  co_subst_co_constraint g1 c1 phi1 = close_constraint_wrt_co c2 (co_subst_co_constraint g1 c1 (open_constraint_wrt_co phi1 (g_Var_f c2))).

Hint Resolve co_subst_co_constraint_close_constraint_wrt_co_open_constraint_wrt_co : lngen.

Lemma tm_subst_tm_tm_a_Abs :
forall x2 rho1 A1 b1 a1 x1,
  lc_tm a1 ->
  x2 `notin` fv_tm_tm_tm a1 `union` fv_tm_tm_tm b1 `union` singleton x1 ->
  tm_subst_tm_tm a1 x1 (a_Abs rho1 A1 b1) = a_Abs (rho1) (tm_subst_tm_tm a1 x1 A1) (close_tm_wrt_tm x2 (tm_subst_tm_tm a1 x1 (open_tm_wrt_tm b1 (a_Var_f x2)))).

Hint Resolve tm_subst_tm_tm_a_Abs : lngen.

Lemma tm_subst_tm_tm_a_UAbs :
forall x2 rho1 b1 a1 x1,
  lc_tm a1 ->
  x2 `notin` fv_tm_tm_tm a1 `union` fv_tm_tm_tm b1 `union` singleton x1 ->
  tm_subst_tm_tm a1 x1 (a_UAbs rho1 b1) = a_UAbs (rho1) (close_tm_wrt_tm x2 (tm_subst_tm_tm a1 x1 (open_tm_wrt_tm b1 (a_Var_f x2)))).

Hint Resolve tm_subst_tm_tm_a_UAbs : lngen.

Lemma tm_subst_tm_tm_a_Pi :
forall x2 rho1 A1 B1 a1 x1,
  lc_tm a1 ->
  x2 `notin` fv_tm_tm_tm a1 `union` fv_tm_tm_tm B1 `union` singleton x1 ->
  tm_subst_tm_tm a1 x1 (a_Pi rho1 A1 B1) = a_Pi (rho1) (tm_subst_tm_tm a1 x1 A1) (close_tm_wrt_tm x2 (tm_subst_tm_tm a1 x1 (open_tm_wrt_tm B1 (a_Var_f x2)))).

Hint Resolve tm_subst_tm_tm_a_Pi : lngen.

Lemma tm_subst_tm_tm_a_CPi :
forall c1 phi1 B1 a1 x1,
  lc_tm a1 ->
  c1 `notin` fv_co_co_tm a1 `union` fv_co_co_tm B1 ->
  tm_subst_tm_tm a1 x1 (a_CPi phi1 B1) = a_CPi (tm_subst_tm_constraint a1 x1 phi1) (close_tm_wrt_co c1 (tm_subst_tm_tm a1 x1 (open_tm_wrt_co B1 (g_Var_f c1)))).

Hint Resolve tm_subst_tm_tm_a_CPi : lngen.

Lemma tm_subst_tm_tm_a_CAbs :
forall c1 phi1 b1 a1 x1,
  lc_tm a1 ->
  c1 `notin` fv_co_co_tm a1 `union` fv_co_co_tm b1 ->
  tm_subst_tm_tm a1 x1 (a_CAbs phi1 b1) = a_CAbs (tm_subst_tm_constraint a1 x1 phi1) (close_tm_wrt_co c1 (tm_subst_tm_tm a1 x1 (open_tm_wrt_co b1 (g_Var_f c1)))).

Hint Resolve tm_subst_tm_tm_a_CAbs : lngen.

Lemma tm_subst_tm_tm_a_UCAbs :
forall c1 b1 a1 x1,
  lc_tm a1 ->
  c1 `notin` fv_co_co_tm a1 `union` fv_co_co_tm b1 ->
  tm_subst_tm_tm a1 x1 (a_UCAbs b1) = a_UCAbs (close_tm_wrt_co c1 (tm_subst_tm_tm a1 x1 (open_tm_wrt_co b1 (g_Var_f c1)))).

Hint Resolve tm_subst_tm_tm_a_UCAbs : lngen.

Lemma co_subst_co_tm_a_Abs :
forall x1 rho1 A1 b1 g1 c1,
  lc_co g1 ->
  x1 `notin` fv_tm_tm_co g1 `union` fv_tm_tm_tm b1 ->
  co_subst_co_tm g1 c1 (a_Abs rho1 A1 b1) = a_Abs (rho1) (co_subst_co_tm g1 c1 A1) (close_tm_wrt_tm x1 (co_subst_co_tm g1 c1 (open_tm_wrt_tm b1 (a_Var_f x1)))).

Hint Resolve co_subst_co_tm_a_Abs : lngen.

Lemma co_subst_co_tm_a_UAbs :
forall x1 rho1 b1 g1 c1,
  lc_co g1 ->
  x1 `notin` fv_tm_tm_co g1 `union` fv_tm_tm_tm b1 ->
  co_subst_co_tm g1 c1 (a_UAbs rho1 b1) = a_UAbs (rho1) (close_tm_wrt_tm x1 (co_subst_co_tm g1 c1 (open_tm_wrt_tm b1 (a_Var_f x1)))).

Hint Resolve co_subst_co_tm_a_UAbs : lngen.

Lemma co_subst_co_tm_a_Pi :
forall x1 rho1 A1 B1 g1 c1,
  lc_co g1 ->
  x1 `notin` fv_tm_tm_co g1 `union` fv_tm_tm_tm B1 ->
  co_subst_co_tm g1 c1 (a_Pi rho1 A1 B1) = a_Pi (rho1) (co_subst_co_tm g1 c1 A1) (close_tm_wrt_tm x1 (co_subst_co_tm g1 c1 (open_tm_wrt_tm B1 (a_Var_f x1)))).

Hint Resolve co_subst_co_tm_a_Pi : lngen.

Lemma co_subst_co_tm_a_CPi :
forall c2 phi1 B1 g1 c1,
  lc_co g1 ->
  c2 `notin` fv_co_co_co g1 `union` fv_co_co_tm B1 `union` singleton c1 ->
  co_subst_co_tm g1 c1 (a_CPi phi1 B1) = a_CPi (co_subst_co_constraint g1 c1 phi1) (close_tm_wrt_co c2 (co_subst_co_tm g1 c1 (open_tm_wrt_co B1 (g_Var_f c2)))).

Hint Resolve co_subst_co_tm_a_CPi : lngen.

Lemma co_subst_co_tm_a_CAbs :
forall c2 phi1 b1 g1 c1,
  lc_co g1 ->
  c2 `notin` fv_co_co_co g1 `union` fv_co_co_tm b1 `union` singleton c1 ->
  co_subst_co_tm g1 c1 (a_CAbs phi1 b1) = a_CAbs (co_subst_co_constraint g1 c1 phi1) (close_tm_wrt_co c2 (co_subst_co_tm g1 c1 (open_tm_wrt_co b1 (g_Var_f c2)))).

Hint Resolve co_subst_co_tm_a_CAbs : lngen.

Lemma co_subst_co_tm_a_UCAbs :
forall c2 b1 g1 c1,
  lc_co g1 ->
  c2 `notin` fv_co_co_co g1 `union` fv_co_co_tm b1 `union` singleton c1 ->
  co_subst_co_tm g1 c1 (a_UCAbs b1) = a_UCAbs (close_tm_wrt_co c2 (co_subst_co_tm g1 c1 (open_tm_wrt_co b1 (g_Var_f c2)))).

Hint Resolve co_subst_co_tm_a_UCAbs : lngen.

Lemma tm_subst_tm_co_g_PiCong :
forall x2 rho1 g1 g2 a1 x1,
  lc_tm a1 ->
  x2 `notin` fv_tm_tm_tm a1 `union` fv_tm_tm_co g2 `union` singleton x1 ->
  tm_subst_tm_co a1 x1 (g_PiCong rho1 g1 g2) = g_PiCong (rho1) (tm_subst_tm_co a1 x1 g1) (close_co_wrt_tm x2 (tm_subst_tm_co a1 x1 (open_co_wrt_tm g2 (a_Var_f x2)))).

Hint Resolve tm_subst_tm_co_g_PiCong : lngen.

Lemma tm_subst_tm_co_g_AbsCong :
forall x2 rho1 g1 g2 a1 x1,
  lc_tm a1 ->
  x2 `notin` fv_tm_tm_tm a1 `union` fv_tm_tm_co g2 `union` singleton x1 ->
  tm_subst_tm_co a1 x1 (g_AbsCong rho1 g1 g2) = g_AbsCong (rho1) (tm_subst_tm_co a1 x1 g1) (close_co_wrt_tm x2 (tm_subst_tm_co a1 x1 (open_co_wrt_tm g2 (a_Var_f x2)))).

Hint Resolve tm_subst_tm_co_g_AbsCong : lngen.

Lemma tm_subst_tm_co_g_CPiCong :
forall c1 g1 g2 a1 x1,
  lc_tm a1 ->
  c1 `notin` fv_co_co_tm a1 `union` fv_co_co_co g2 ->
  tm_subst_tm_co a1 x1 (g_CPiCong g1 g2) = g_CPiCong (tm_subst_tm_co a1 x1 g1) (close_co_wrt_co c1 (tm_subst_tm_co a1 x1 (open_co_wrt_co g2 (g_Var_f c1)))).

Hint Resolve tm_subst_tm_co_g_CPiCong : lngen.

Lemma tm_subst_tm_co_g_CAbsCong :
forall c1 g1 g2 g3 a1 x1,
  lc_tm a1 ->
  c1 `notin` fv_co_co_tm a1 `union` fv_co_co_co g2 ->
  tm_subst_tm_co a1 x1 (g_CAbsCong g1 g2 g3) = g_CAbsCong (tm_subst_tm_co a1 x1 g1) (close_co_wrt_co c1 (tm_subst_tm_co a1 x1 (open_co_wrt_co g2 (g_Var_f c1)))) (tm_subst_tm_co a1 x1 g3).

Hint Resolve tm_subst_tm_co_g_CAbsCong : lngen.

Lemma co_subst_co_co_g_PiCong :
forall x1 rho1 g2 g3 g1 c1,
  lc_co g1 ->
  x1 `notin` fv_tm_tm_co g1 `union` fv_tm_tm_co g3 ->
  co_subst_co_co g1 c1 (g_PiCong rho1 g2 g3) = g_PiCong (rho1) (co_subst_co_co g1 c1 g2) (close_co_wrt_tm x1 (co_subst_co_co g1 c1 (open_co_wrt_tm g3 (a_Var_f x1)))).

Hint Resolve co_subst_co_co_g_PiCong : lngen.

Lemma co_subst_co_co_g_AbsCong :
forall x1 rho1 g2 g3 g1 c1,
  lc_co g1 ->
  x1 `notin` fv_tm_tm_co g1 `union` fv_tm_tm_co g3 ->
  co_subst_co_co g1 c1 (g_AbsCong rho1 g2 g3) = g_AbsCong (rho1) (co_subst_co_co g1 c1 g2) (close_co_wrt_tm x1 (co_subst_co_co g1 c1 (open_co_wrt_tm g3 (a_Var_f x1)))).

Hint Resolve co_subst_co_co_g_AbsCong : lngen.

Lemma co_subst_co_co_g_CPiCong :
forall c2 g2 g3 g1 c1,
  lc_co g1 ->
  c2 `notin` fv_co_co_co g1 `union` fv_co_co_co g3 `union` singleton c1 ->
  co_subst_co_co g1 c1 (g_CPiCong g2 g3) = g_CPiCong (co_subst_co_co g1 c1 g2) (close_co_wrt_co c2 (co_subst_co_co g1 c1 (open_co_wrt_co g3 (g_Var_f c2)))).

Hint Resolve co_subst_co_co_g_CPiCong : lngen.

Lemma co_subst_co_co_g_CAbsCong :
forall c2 g2 g3 g4 g1 c1,
  lc_co g1 ->
  c2 `notin` fv_co_co_co g1 `union` fv_co_co_co g3 `union` singleton c1 ->
  co_subst_co_co g1 c1 (g_CAbsCong g2 g3 g4) = g_CAbsCong (co_subst_co_co g1 c1 g2) (close_co_wrt_co c2 (co_subst_co_co g1 c1 (open_co_wrt_co g3 (g_Var_f c2)))) (co_subst_co_co g1 c1 g4).

Hint Resolve co_subst_co_co_g_CAbsCong : lngen.

Lemma tm_subst_tm_tm_intro_rec_tm_subst_tm_brs_intro_rec_tm_subst_tm_co_intro_rec_tm_subst_tm_constraint_intro_rec_mutual :
(forall a1 x1 a2 n1,
  x1 `notin` fv_tm_tm_tm a1 ->
  open_tm_wrt_tm_rec n1 a2 a1 = tm_subst_tm_tm a2 x1 (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1)) /\
(forall brs1 x1 a1 n1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  open_brs_wrt_tm_rec n1 a1 brs1 = tm_subst_tm_brs a1 x1 (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1)) /\
(forall g1 x1 a1 n1,
  x1 `notin` fv_tm_tm_co g1 ->
  open_co_wrt_tm_rec n1 a1 g1 = tm_subst_tm_co a1 x1 (open_co_wrt_tm_rec n1 (a_Var_f x1) g1)) /\
(forall phi1 x1 a1 n1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  open_constraint_wrt_tm_rec n1 a1 phi1 = tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1)).

Lemma tm_subst_tm_tm_intro_rec :
forall a1 x1 a2 n1,
  x1 `notin` fv_tm_tm_tm a1 ->
  open_tm_wrt_tm_rec n1 a2 a1 = tm_subst_tm_tm a2 x1 (open_tm_wrt_tm_rec n1 (a_Var_f x1) a1).

Hint Resolve tm_subst_tm_tm_intro_rec : lngen.
Hint Rewrite tm_subst_tm_tm_intro_rec using solve [auto] : lngen.

Lemma tm_subst_tm_brs_intro_rec :
forall brs1 x1 a1 n1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  open_brs_wrt_tm_rec n1 a1 brs1 = tm_subst_tm_brs a1 x1 (open_brs_wrt_tm_rec n1 (a_Var_f x1) brs1).

Hint Resolve tm_subst_tm_brs_intro_rec : lngen.
Hint Rewrite tm_subst_tm_brs_intro_rec using solve [auto] : lngen.

Lemma tm_subst_tm_co_intro_rec :
forall g1 x1 a1 n1,
  x1 `notin` fv_tm_tm_co g1 ->
  open_co_wrt_tm_rec n1 a1 g1 = tm_subst_tm_co a1 x1 (open_co_wrt_tm_rec n1 (a_Var_f x1) g1).

Hint Resolve tm_subst_tm_co_intro_rec : lngen.
Hint Rewrite tm_subst_tm_co_intro_rec using solve [auto] : lngen.

Lemma tm_subst_tm_constraint_intro_rec :
forall phi1 x1 a1 n1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  open_constraint_wrt_tm_rec n1 a1 phi1 = tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm_rec n1 (a_Var_f x1) phi1).

Hint Resolve tm_subst_tm_constraint_intro_rec : lngen.
Hint Rewrite tm_subst_tm_constraint_intro_rec using solve [auto] : lngen.

Lemma co_subst_co_tm_intro_rec_co_subst_co_brs_intro_rec_co_subst_co_co_intro_rec_co_subst_co_constraint_intro_rec_mutual :
(forall a1 c1 g1 n1,
  c1 `notin` fv_co_co_tm a1 ->
  open_tm_wrt_co_rec n1 g1 a1 = co_subst_co_tm g1 c1 (open_tm_wrt_co_rec n1 (g_Var_f c1) a1)) /\
(forall brs1 c1 g1 n1,
  c1 `notin` fv_co_co_brs brs1 ->
  open_brs_wrt_co_rec n1 g1 brs1 = co_subst_co_brs g1 c1 (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1)) /\
(forall g1 c1 g2 n1,
  c1 `notin` fv_co_co_co g1 ->
  open_co_wrt_co_rec n1 g2 g1 = co_subst_co_co g2 c1 (open_co_wrt_co_rec n1 (g_Var_f c1) g1)) /\
(forall phi1 c1 g1 n1,
  c1 `notin` fv_co_co_constraint phi1 ->
  open_constraint_wrt_co_rec n1 g1 phi1 = co_subst_co_constraint g1 c1 (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1)).

Lemma co_subst_co_tm_intro_rec :
forall a1 c1 g1 n1,
  c1 `notin` fv_co_co_tm a1 ->
  open_tm_wrt_co_rec n1 g1 a1 = co_subst_co_tm g1 c1 (open_tm_wrt_co_rec n1 (g_Var_f c1) a1).

Hint Resolve co_subst_co_tm_intro_rec : lngen.
Hint Rewrite co_subst_co_tm_intro_rec using solve [auto] : lngen.

Lemma co_subst_co_brs_intro_rec :
forall brs1 c1 g1 n1,
  c1 `notin` fv_co_co_brs brs1 ->
  open_brs_wrt_co_rec n1 g1 brs1 = co_subst_co_brs g1 c1 (open_brs_wrt_co_rec n1 (g_Var_f c1) brs1).

Hint Resolve co_subst_co_brs_intro_rec : lngen.
Hint Rewrite co_subst_co_brs_intro_rec using solve [auto] : lngen.

Lemma co_subst_co_co_intro_rec :
forall g1 c1 g2 n1,
  c1 `notin` fv_co_co_co g1 ->
  open_co_wrt_co_rec n1 g2 g1 = co_subst_co_co g2 c1 (open_co_wrt_co_rec n1 (g_Var_f c1) g1).

Hint Resolve co_subst_co_co_intro_rec : lngen.
Hint Rewrite co_subst_co_co_intro_rec using solve [auto] : lngen.

Lemma co_subst_co_constraint_intro_rec :
forall phi1 c1 g1 n1,
  c1 `notin` fv_co_co_constraint phi1 ->
  open_constraint_wrt_co_rec n1 g1 phi1 = co_subst_co_constraint g1 c1 (open_constraint_wrt_co_rec n1 (g_Var_f c1) phi1).

Hint Resolve co_subst_co_constraint_intro_rec : lngen.
Hint Rewrite co_subst_co_constraint_intro_rec using solve [auto] : lngen.

Lemma tm_subst_tm_tm_intro :
forall x1 a1 a2,
  x1 `notin` fv_tm_tm_tm a1 ->
  open_tm_wrt_tm a1 a2 = tm_subst_tm_tm a2 x1 (open_tm_wrt_tm a1 (a_Var_f x1)).

Hint Resolve tm_subst_tm_tm_intro : lngen.

Lemma tm_subst_tm_brs_intro :
forall x1 brs1 a1,
  x1 `notin` fv_tm_tm_brs brs1 ->
  open_brs_wrt_tm brs1 a1 = tm_subst_tm_brs a1 x1 (open_brs_wrt_tm brs1 (a_Var_f x1)).

Hint Resolve tm_subst_tm_brs_intro : lngen.

Lemma tm_subst_tm_co_intro :
forall x1 g1 a1,
  x1 `notin` fv_tm_tm_co g1 ->
  open_co_wrt_tm g1 a1 = tm_subst_tm_co a1 x1 (open_co_wrt_tm g1 (a_Var_f x1)).

Hint Resolve tm_subst_tm_co_intro : lngen.

Lemma tm_subst_tm_constraint_intro :
forall x1 phi1 a1,
  x1 `notin` fv_tm_tm_constraint phi1 ->
  open_constraint_wrt_tm phi1 a1 = tm_subst_tm_constraint a1 x1 (open_constraint_wrt_tm phi1 (a_Var_f x1)).

Hint Resolve tm_subst_tm_constraint_intro : lngen.

Lemma co_subst_co_tm_intro :
forall c1 a1 g1,
  c1 `notin` fv_co_co_tm a1 ->
  open_tm_wrt_co a1 g1 = co_subst_co_tm g1 c1 (open_tm_wrt_co a1 (g_Var_f c1)).

Hint Resolve co_subst_co_tm_intro : lngen.

Lemma co_subst_co_brs_intro :
forall c1 brs1 g1,
  c1 `notin` fv_co_co_brs brs1 ->
  open_brs_wrt_co brs1 g1 = co_subst_co_brs g1 c1 (open_brs_wrt_co brs1 (g_Var_f c1)).

Hint Resolve co_subst_co_brs_intro : lngen.

Lemma co_subst_co_co_intro :
forall c1 g1 g2,
  c1 `notin` fv_co_co_co g1 ->
  open_co_wrt_co g1 g2 = co_subst_co_co g2 c1 (open_co_wrt_co g1 (g_Var_f c1)).

Hint Resolve co_subst_co_co_intro : lngen.

Lemma co_subst_co_constraint_intro :
forall c1 phi1 g1,
  c1 `notin` fv_co_co_constraint phi1 ->
  open_constraint_wrt_co phi1 g1 = co_subst_co_constraint g1 c1 (open_constraint_wrt_co phi1 (g_Var_f c1)).

Hint Resolve co_subst_co_constraint_intro : lngen.

Ltac default_auto ::= auto; tauto.
Ltac default_autorewrite ::= fail. *)
Require Export FcEtt.ett_ott.
(* FcEtt.ett_ott:
Require Import Metalib.Metatheory.

Definition tmvar := var. 
Definition covar := var. 
Definition datacon := atom.
Definition const := atom.
Definition tyfam := atom.
Definition index := nat. 

Inductive relflag : Set :=  
 | Rel : relflag
 | Irrel : relflag.

Inductive constraint : Set :=  
 | Eq (a:tm) (b:tm) (A:tm)
with tm : Set :=  
 | a_Star : tm
 | a_Var_b (_:nat)
 | a_Var_f (x:tmvar)
 | a_Abs (rho:relflag) (A:tm) (b:tm)
 | a_UAbs (rho:relflag) (b:tm)
 | a_App (a:tm) (rho:relflag) (b:tm)
 | a_Fam (F:tyfam)
 | a_Const (T:const)
 | a_Pi (rho:relflag) (A:tm) (B:tm)
 | a_Conv (a:tm) (g:co)
 | a_CPi (phi:constraint) (B:tm)
 | a_CAbs (phi:constraint) (b:tm)
 | a_UCAbs (b:tm)
 | a_CApp (a:tm) (g:co)
 | a_Bullet : tm
 | a_DataCon (K:datacon)
 | a_Case (a:tm) (brs5:brs)
with brs : Set :=  
 | br_None : brs
 | br_One (K:datacon) (a:tm) (brs5:brs)
with co : Set :=  
 | g_Triv : co
 | g_Var_b (_:nat)
 | g_Var_f (c:covar)
 | g_Beta (a:tm) (b:tm)
 | g_Refl (a:tm)
 | g_Refl2 (a:tm) (b:tm) (g:co)
 | g_Sym (g:co)
 | g_Trans (g1:co) (g2:co)
 | g_PiCong (rho:relflag) (g1:co) (g2:co)
 | g_AbsCong (rho:relflag) (g1:co) (g2:co)
 | g_AppCong (g1:co) (rho:relflag) (g2:co)
 | g_PiFst (g:co)
 | g_CPiFst (g:co)
 | g_IsoSnd (g:co)
 | g_PiSnd (g1:co) (g2:co)
 | g_CPiCong (g1:co) (g3:co)
 | g_CAbsCong (g1:co) (g3:co) (g4:co)
 | g_CAppCong (g:co) (g1:co) (g2:co)
 | g_CPiSnd (g:co) (g1:co) (g2:co)
 | g_Cast (g1:co) (g2:co)
 | g_EqCong (g1:co) (A:tm) (g2:co)
 | g_IsoConv (phi1:constraint) (phi2:constraint) (g:co)
 | g_Eta (a:tm)
 | g_Left (g:co) (g':co)
 | g_Right (g:co) (g':co).

Inductive sort : Set :=  
 | Tm (A:tm)
 | Co (phi:constraint).

Inductive sig_sort : Set :=  
 | Cs (A:tm)
 | Ax (a:tm) (A:tm).

Definition context : Set := list ( atom * sort ).

Definition available_props : Type := atoms.

Definition sig : Set := list (atom * sig_sort).

Fixpoint open_co_wrt_co_rec (k:nat) (g_5:co) (g__6:co) {struct g__6}: co :=
  match g__6 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => g_Var_b nat
        | inleft (right _) => g_5
        | inright _ => g_Var_b (nat - 1)
      end
  | (g_Var_f c) => g_Var_f c
  | (g_Beta a b) => g_Beta (open_tm_wrt_co_rec k g_5 a) (open_tm_wrt_co_rec k g_5 b)
  | (g_Refl a) => g_Refl (open_tm_wrt_co_rec k g_5 a)
  | (g_Refl2 a b g) => g_Refl2 (open_tm_wrt_co_rec k g_5 a) (open_tm_wrt_co_rec k g_5 b) (open_co_wrt_co_rec k g_5 g)
  | (g_Sym g) => g_Sym (open_co_wrt_co_rec k g_5 g)
  | (g_Trans g1 g2) => g_Trans (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (open_co_wrt_co_rec k g_5 g1) rho (open_co_wrt_co_rec k g_5 g2)
  | (g_PiFst g) => g_PiFst (open_co_wrt_co_rec k g_5 g)
  | (g_CPiFst g) => g_CPiFst (open_co_wrt_co_rec k g_5 g)
  | (g_IsoSnd g) => g_IsoSnd (open_co_wrt_co_rec k g_5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec (S k) g_5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec (S k) g_5 g3) (open_co_wrt_co_rec k g_5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_Cast g1 g2) => g_Cast (open_co_wrt_co_rec k g_5 g1) (open_co_wrt_co_rec k g_5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (open_co_wrt_co_rec k g_5 g1) (open_tm_wrt_co_rec k g_5 A) (open_co_wrt_co_rec k g_5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (open_constraint_wrt_co_rec k g_5 phi1) (open_constraint_wrt_co_rec k g_5 phi2) (open_co_wrt_co_rec k g_5 g)
  | (g_Eta a) => g_Eta (open_tm_wrt_co_rec k g_5 a)
  | (g_Left g g') => g_Left (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g')
  | (g_Right g g') => g_Right (open_co_wrt_co_rec k g_5 g) (open_co_wrt_co_rec k g_5 g')
end
with open_brs_wrt_co_rec (k:nat) (g5:co) (brs_6:brs) {struct brs_6}: brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (open_tm_wrt_co_rec k g5 a) (open_brs_wrt_co_rec k g5 brs5)
end
with open_tm_wrt_co_rec (k:nat) (g5:co) (a5:tm) {struct a5}: tm :=
  match a5 with
  | a_Star => a_Star 
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => a_Var_f x
  | (a_Abs rho A b) => a_Abs rho (open_tm_wrt_co_rec k g5 A) (open_tm_wrt_co_rec k g5 b)
  | (a_UAbs rho b) => a_UAbs rho (open_tm_wrt_co_rec k g5 b)
  | (a_App a rho b) => a_App (open_tm_wrt_co_rec k g5 a) rho (open_tm_wrt_co_rec k g5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (open_tm_wrt_co_rec k g5 A) (open_tm_wrt_co_rec k g5 B)
  | (a_Conv a g) => a_Conv (open_tm_wrt_co_rec k g5 a) (open_co_wrt_co_rec k g5 g)
  | (a_CPi phi B) => a_CPi (open_constraint_wrt_co_rec k g5 phi) (open_tm_wrt_co_rec (S k) g5 B)
  | (a_CAbs phi b) => a_CAbs (open_constraint_wrt_co_rec k g5 phi) (open_tm_wrt_co_rec (S k) g5 b)
  | (a_UCAbs b) => a_UCAbs (open_tm_wrt_co_rec (S k) g5 b)
  | (a_CApp a g) => a_CApp (open_tm_wrt_co_rec k g5 a) (open_co_wrt_co_rec k g5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (open_tm_wrt_co_rec k g5 a) (open_brs_wrt_co_rec k g5 brs5)
end
with open_constraint_wrt_co_rec (k:nat) (g5:co) (phi5:constraint) : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (open_tm_wrt_co_rec k g5 a) (open_tm_wrt_co_rec k g5 b) (open_tm_wrt_co_rec k g5 A)
end.

Fixpoint open_co_wrt_tm_rec (k:nat) (a5:tm) (g_5:co) {struct g_5}: co :=
  match g_5 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => g_Var_b nat
  | (g_Var_f c) => g_Var_f c
  | (g_Beta a b) => g_Beta (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b)
  | (g_Refl a) => g_Refl (open_tm_wrt_tm_rec k a5 a)
  | (g_Refl2 a b g) => g_Refl2 (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b) (open_co_wrt_tm_rec k a5 g)
  | (g_Sym g) => g_Sym (open_co_wrt_tm_rec k a5 g)
  | (g_Trans g1 g2) => g_Trans (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec (S k) a5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec (S k) a5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (open_co_wrt_tm_rec k a5 g1) rho (open_co_wrt_tm_rec k a5 g2)
  | (g_PiFst g) => g_PiFst (open_co_wrt_tm_rec k a5 g)
  | (g_CPiFst g) => g_CPiFst (open_co_wrt_tm_rec k a5 g)
  | (g_IsoSnd g) => g_IsoSnd (open_co_wrt_tm_rec k a5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g3) (open_co_wrt_tm_rec k a5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_Cast g1 g2) => g_Cast (open_co_wrt_tm_rec k a5 g1) (open_co_wrt_tm_rec k a5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (open_co_wrt_tm_rec k a5 g1) (open_tm_wrt_tm_rec k a5 A) (open_co_wrt_tm_rec k a5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (open_constraint_wrt_tm_rec k a5 phi1) (open_constraint_wrt_tm_rec k a5 phi2) (open_co_wrt_tm_rec k a5 g)
  | (g_Eta a) => g_Eta (open_tm_wrt_tm_rec k a5 a)
  | (g_Left g g') => g_Left (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g')
  | (g_Right g g') => g_Right (open_co_wrt_tm_rec k a5 g) (open_co_wrt_tm_rec k a5 g')
end
with open_brs_wrt_tm_rec (k:nat) (a5:tm) (brs_6:brs) {struct brs_6}: brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (open_tm_wrt_tm_rec k a5 a) (open_brs_wrt_tm_rec k a5 brs5)
end
with open_tm_wrt_tm_rec (k:nat) (a5:tm) (a_6:tm) {struct a_6}: tm :=
  match a_6 with
  | a_Star => a_Star 
  | (a_Var_b nat) => 
      match lt_eq_lt_dec nat k with
        | inleft (left _) => a_Var_b nat
        | inleft (right _) => a5
        | inright _ => a_Var_b (nat - 1)
      end
  | (a_Var_f x) => a_Var_f x
  | (a_Abs rho A b) => a_Abs rho (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 b)
  | (a_UAbs rho b) => a_UAbs rho (open_tm_wrt_tm_rec (S k) a5 b)
  | (a_App a rho b) => a_App (open_tm_wrt_tm_rec k a5 a) rho (open_tm_wrt_tm_rec k a5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (open_tm_wrt_tm_rec k a5 A) (open_tm_wrt_tm_rec (S k) a5 B)
  | (a_Conv a g) => a_Conv (open_tm_wrt_tm_rec k a5 a) (open_co_wrt_tm_rec k a5 g)
  | (a_CPi phi B) => a_CPi (open_constraint_wrt_tm_rec k a5 phi) (open_tm_wrt_tm_rec k a5 B)
  | (a_CAbs phi b) => a_CAbs (open_constraint_wrt_tm_rec k a5 phi) (open_tm_wrt_tm_rec k a5 b)
  | (a_UCAbs b) => a_UCAbs (open_tm_wrt_tm_rec k a5 b)
  | (a_CApp a g) => a_CApp (open_tm_wrt_tm_rec k a5 a) (open_co_wrt_tm_rec k a5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (open_tm_wrt_tm_rec k a5 a) (open_brs_wrt_tm_rec k a5 brs5)
end
with open_constraint_wrt_tm_rec (k:nat) (a5:tm) (phi5:constraint) : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 b) (open_tm_wrt_tm_rec k a5 A)
end.

Definition open_sort_wrt_co_rec (k:nat) (g5:co) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (open_tm_wrt_co_rec k g5 A)
  | (Co phi) => Co (open_constraint_wrt_co_rec k g5 phi)
end.

Definition open_sig_sort_wrt_co_rec (k:nat) (g5:co) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (open_tm_wrt_co_rec k g5 A)
  | (Ax a A) => Ax (open_tm_wrt_co_rec k g5 a) (open_tm_wrt_co_rec k g5 A)
end.

Definition open_sig_sort_wrt_tm_rec (k:nat) (a5:tm) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (open_tm_wrt_tm_rec k a5 A)
  | (Ax a A) => Ax (open_tm_wrt_tm_rec k a5 a) (open_tm_wrt_tm_rec k a5 A)
end.

Definition open_sort_wrt_tm_rec (k:nat) (a5:tm) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (open_tm_wrt_tm_rec k a5 A)
  | (Co phi) => Co (open_constraint_wrt_tm_rec k a5 phi)
end.

Definition open_brs_wrt_co g5 brs_6 := open_brs_wrt_co_rec 0 brs_6 g5.

Definition open_tm_wrt_co g5 a5 := open_tm_wrt_co_rec 0 a5 g5.

Definition open_brs_wrt_tm a5 brs_6 := open_brs_wrt_tm_rec 0 brs_6 a5.

Definition open_sort_wrt_co g5 sort5 := open_sort_wrt_co_rec 0 sort5 g5.

Definition open_sig_sort_wrt_co g5 sig_sort5 := open_sig_sort_wrt_co_rec 0 sig_sort5 g5.

Definition open_co_wrt_co g_5 g__6 := open_co_wrt_co_rec 0 g__6 g_5.

Definition open_sig_sort_wrt_tm a5 sig_sort5 := open_sig_sort_wrt_tm_rec 0 sig_sort5 a5.

Definition open_constraint_wrt_co g5 phi5 := open_constraint_wrt_co_rec 0 phi5 g5.

Definition open_constraint_wrt_tm a5 phi5 := open_constraint_wrt_tm_rec 0 phi5 a5.

Definition open_co_wrt_tm a5 g_5 := open_co_wrt_tm_rec 0 g_5 a5.

Definition open_sort_wrt_tm a5 sort5 := open_sort_wrt_tm_rec 0 sort5 a5.

Definition open_tm_wrt_tm a5 a_6 := open_tm_wrt_tm_rec 0 a_6 a5.

Inductive lc_co : co -> Prop :=    
 | lc_g_Triv : 
     (lc_co g_Triv)
 | lc_g_Var_f : forall (c:covar),
     (lc_co (g_Var_f c))
 | lc_g_Beta : forall (a b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_co (g_Beta a b))
 | lc_g_Refl : forall (a:tm),
     (lc_tm a) ->
     (lc_co (g_Refl a))
 | lc_g_Refl2 : forall (a b:tm) (g:co),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_co g) ->
     (lc_co (g_Refl2 a b g))
 | lc_g_Sym : forall (g:co),
     (lc_co g) ->
     (lc_co (g_Sym g))
 | lc_g_Trans : forall (g1 g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_Trans g1 g2))
 | lc_g_PiCong : forall (rho:relflag) (g1 g2:co),
     (lc_co g1) ->
      ( forall x , lc_co  ( open_co_wrt_tm g2 (a_Var_f x) )  )  ->
     (lc_co (g_PiCong rho g1 g2))
 | lc_g_AbsCong : forall (rho:relflag) (g1 g2:co),
     (lc_co g1) ->
      ( forall x , lc_co  ( open_co_wrt_tm g2 (a_Var_f x) )  )  ->
     (lc_co (g_AbsCong rho g1 g2))
 | lc_g_AppCong : forall (g1:co) (rho:relflag) (g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_AppCong g1 rho g2))
 | lc_g_PiFst : forall (g:co),
     (lc_co g) ->
     (lc_co (g_PiFst g))
 | lc_g_CPiFst : forall (g:co),
     (lc_co g) ->
     (lc_co (g_CPiFst g))
 | lc_g_IsoSnd : forall (g:co),
     (lc_co g) ->
     (lc_co (g_IsoSnd g))
 | lc_g_PiSnd : forall (g1 g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_PiSnd g1 g2))
 | lc_g_CPiCong : forall (g1 g3:co),
     (lc_co g1) ->
      ( forall c , lc_co  ( open_co_wrt_co g3 (g_Var_f c) )  )  ->
     (lc_co (g_CPiCong g1 g3))
 | lc_g_CAbsCong : forall (g1 g3 g4:co),
     (lc_co g1) ->
      ( forall c , lc_co  ( open_co_wrt_co g3 (g_Var_f c) )  )  ->
     (lc_co g4) ->
     (lc_co (g_CAbsCong g1 g3 g4))
 | lc_g_CAppCong : forall (g g1 g2:co),
     (lc_co g) ->
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_CAppCong g g1 g2))
 | lc_g_CPiSnd : forall (g g1 g2:co),
     (lc_co g) ->
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_CPiSnd g g1 g2))
 | lc_g_Cast : forall (g1 g2:co),
     (lc_co g1) ->
     (lc_co g2) ->
     (lc_co (g_Cast g1 g2))
 | lc_g_EqCong : forall (g1:co) (A:tm) (g2:co),
     (lc_co g1) ->
     (lc_tm A) ->
     (lc_co g2) ->
     (lc_co (g_EqCong g1 A g2))
 | lc_g_IsoConv : forall (phi1 phi2:constraint) (g:co),
     (lc_constraint phi1) ->
     (lc_constraint phi2) ->
     (lc_co g) ->
     (lc_co (g_IsoConv phi1 phi2 g))
 | lc_g_Eta : forall (a:tm),
     (lc_tm a) ->
     (lc_co (g_Eta a))
 | lc_g_Left : forall (g g':co),
     (lc_co g) ->
     (lc_co g') ->
     (lc_co (g_Left g g'))
 | lc_g_Right : forall (g g':co),
     (lc_co g) ->
     (lc_co g') ->
     (lc_co (g_Right g g'))
with lc_brs : brs -> Prop :=    
 | lc_br_None : 
     (lc_brs br_None)
 | lc_br_One : forall (K:datacon) (a:tm) (brs5:brs),
     (lc_tm a) ->
     (lc_brs brs5) ->
     (lc_brs (br_One K a brs5))
with lc_tm : tm -> Prop :=    
 | lc_a_Star : 
     (lc_tm a_Star)
 | lc_a_Var_f : forall (x:tmvar),
     (lc_tm (a_Var_f x))
 | lc_a_Abs : forall (rho:relflag) (A b:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm b (a_Var_f x) )  )  ->
     (lc_tm (a_Abs rho A b))
 | lc_a_UAbs : forall (rho:relflag) (b:tm),
      ( forall x , lc_tm  ( open_tm_wrt_tm b (a_Var_f x) )  )  ->
     (lc_tm (a_UAbs rho b))
 | lc_a_App : forall (a:tm) (rho:relflag) (b:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm (a_App a rho b))
 | lc_a_Fam : forall (F:tyfam),
     (lc_tm (a_Fam F))
 | lc_a_Const : forall (T:const),
     (lc_tm (a_Const T))
 | lc_a_Pi : forall (rho:relflag) (A B:tm),
     (lc_tm A) ->
      ( forall x , lc_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     (lc_tm (a_Pi rho A B))
 | lc_a_Conv : forall (a:tm) (g:co),
     (lc_tm a) ->
     (lc_co g) ->
     (lc_tm (a_Conv a g))
 | lc_a_CPi : forall (phi:constraint) (B:tm),
     (lc_constraint phi) ->
      ( forall c , lc_tm  ( open_tm_wrt_co B (g_Var_f c) )  )  ->
     (lc_tm (a_CPi phi B))
 | lc_a_CAbs : forall (phi:constraint) (b:tm),
     (lc_constraint phi) ->
      ( forall c , lc_tm  ( open_tm_wrt_co b (g_Var_f c) )  )  ->
     (lc_tm (a_CAbs phi b))
 | lc_a_UCAbs : forall (b:tm),
      ( forall c , lc_tm  ( open_tm_wrt_co b (g_Var_f c) )  )  ->
     (lc_tm (a_UCAbs b))
 | lc_a_CApp : forall (a:tm) (g:co),
     (lc_tm a) ->
     (lc_co g) ->
     (lc_tm (a_CApp a g))
 | lc_a_Bullet : 
     (lc_tm a_Bullet)
 | lc_a_DataCon : forall (K:datacon),
     (lc_tm (a_DataCon K))
 | lc_a_Case : forall (a:tm) (brs5:brs),
     (lc_tm a) ->
     (lc_brs brs5) ->
     (lc_tm (a_Case a brs5))
with lc_constraint : constraint -> Prop :=    
 | lc_Eq : forall (a b A:tm),
     (lc_tm a) ->
     (lc_tm b) ->
     (lc_tm A) ->
     (lc_constraint (Eq a b A)).

Inductive lc_sort : sort -> Prop :=    
 | lc_Tm : forall (A:tm),
     (lc_tm A) ->
     (lc_sort (Tm A))
 | lc_Co : forall (phi:constraint),
     (lc_constraint phi) ->
     (lc_sort (Co phi)).

Inductive lc_sig_sort : sig_sort -> Prop :=    
 | lc_Cs : forall (A:tm),
     (lc_tm A) ->
     (lc_sig_sort (Cs A))
 | lc_Ax : forall (a A:tm),
     (lc_tm a) ->
     (lc_tm A) ->
     (lc_sig_sort (Ax a A)).

Fixpoint fv_tm_tm_co (g_5:co) : vars :=
  match g_5 with
  | g_Triv => {}
  | (g_Var_b nat) => {}
  | (g_Var_f c) => {}
  | (g_Beta a b) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b)
  | (g_Refl a) => (fv_tm_tm_tm a)
  | (g_Refl2 a b g) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b) \u (fv_tm_tm_co g)
  | (g_Sym g) => (fv_tm_tm_co g)
  | (g_Trans g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_PiCong rho g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_AbsCong rho g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_AppCong g1 rho g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_PiFst g) => (fv_tm_tm_co g)
  | (g_CPiFst g) => (fv_tm_tm_co g)
  | (g_IsoSnd g) => (fv_tm_tm_co g)
  | (g_PiSnd g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_CPiCong g1 g3) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g3)
  | (g_CAbsCong g1 g3 g4) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g3) \u (fv_tm_tm_co g4)
  | (g_CAppCong g g1 g2) => (fv_tm_tm_co g) \u (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_CPiSnd g g1 g2) => (fv_tm_tm_co g) \u (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_Cast g1 g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_co g2)
  | (g_EqCong g1 A g2) => (fv_tm_tm_co g1) \u (fv_tm_tm_tm A) \u (fv_tm_tm_co g2)
  | (g_IsoConv phi1 phi2 g) => (fv_tm_tm_constraint phi1) \u (fv_tm_tm_constraint phi2) \u (fv_tm_tm_co g)
  | (g_Eta a) => (fv_tm_tm_tm a)
  | (g_Left g g') => (fv_tm_tm_co g) \u (fv_tm_tm_co g')
  | (g_Right g g') => (fv_tm_tm_co g) \u (fv_tm_tm_co g')
end
with fv_tm_tm_brs (brs_6:brs) : vars :=
  match brs_6 with
  | br_None => {}
  | (br_One K a brs5) => (fv_tm_tm_tm a) \u (fv_tm_tm_brs brs5)
end
with fv_tm_tm_tm (a5:tm) : vars :=
  match a5 with
  | a_Star => {}
  | (a_Var_b nat) => {}
  | (a_Var_f x) => {{x}}
  | (a_Abs rho A b) => (fv_tm_tm_tm A) \u (fv_tm_tm_tm b)
  | (a_UAbs rho b) => (fv_tm_tm_tm b)
  | (a_App a rho b) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b)
  | (a_Fam F) => {}
  | (a_Const T) => {}
  | (a_Pi rho A B) => (fv_tm_tm_tm A) \u (fv_tm_tm_tm B)
  | (a_Conv a g) => (fv_tm_tm_tm a) \u (fv_tm_tm_co g)
  | (a_CPi phi B) => (fv_tm_tm_constraint phi) \u (fv_tm_tm_tm B)
  | (a_CAbs phi b) => (fv_tm_tm_constraint phi) \u (fv_tm_tm_tm b)
  | (a_UCAbs b) => (fv_tm_tm_tm b)
  | (a_CApp a g) => (fv_tm_tm_tm a) \u (fv_tm_tm_co g)
  | a_Bullet => {}
  | (a_DataCon K) => {}
  | (a_Case a brs5) => (fv_tm_tm_tm a) \u (fv_tm_tm_brs brs5)
end
with fv_tm_tm_constraint (phi5:constraint) : vars :=
  match phi5 with
  | (Eq a b A) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm b) \u (fv_tm_tm_tm A)
end.

Fixpoint fv_co_co_co (g_5:co) : vars :=
  match g_5 with
  | g_Triv => {}
  | (g_Var_b nat) => {}
  | (g_Var_f c) => {{c}}
  | (g_Beta a b) => (fv_co_co_tm a) \u (fv_co_co_tm b)
  | (g_Refl a) => (fv_co_co_tm a)
  | (g_Refl2 a b g) => (fv_co_co_tm a) \u (fv_co_co_tm b) \u (fv_co_co_co g)
  | (g_Sym g) => (fv_co_co_co g)
  | (g_Trans g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_PiCong rho g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_AbsCong rho g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_AppCong g1 rho g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_PiFst g) => (fv_co_co_co g)
  | (g_CPiFst g) => (fv_co_co_co g)
  | (g_IsoSnd g) => (fv_co_co_co g)
  | (g_PiSnd g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_CPiCong g1 g3) => (fv_co_co_co g1) \u (fv_co_co_co g3)
  | (g_CAbsCong g1 g3 g4) => (fv_co_co_co g1) \u (fv_co_co_co g3) \u (fv_co_co_co g4)
  | (g_CAppCong g g1 g2) => (fv_co_co_co g) \u (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_CPiSnd g g1 g2) => (fv_co_co_co g) \u (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_Cast g1 g2) => (fv_co_co_co g1) \u (fv_co_co_co g2)
  | (g_EqCong g1 A g2) => (fv_co_co_co g1) \u (fv_co_co_tm A) \u (fv_co_co_co g2)
  | (g_IsoConv phi1 phi2 g) => (fv_co_co_constraint phi1) \u (fv_co_co_constraint phi2) \u (fv_co_co_co g)
  | (g_Eta a) => (fv_co_co_tm a)
  | (g_Left g g') => (fv_co_co_co g) \u (fv_co_co_co g')
  | (g_Right g g') => (fv_co_co_co g) \u (fv_co_co_co g')
end
with fv_co_co_brs (brs_6:brs) : vars :=
  match brs_6 with
  | br_None => {}
  | (br_One K a brs5) => (fv_co_co_tm a) \u (fv_co_co_brs brs5)
end
with fv_co_co_tm (a5:tm) : vars :=
  match a5 with
  | a_Star => {}
  | (a_Var_b nat) => {}
  | (a_Var_f x) => {}
  | (a_Abs rho A b) => (fv_co_co_tm A) \u (fv_co_co_tm b)
  | (a_UAbs rho b) => (fv_co_co_tm b)
  | (a_App a rho b) => (fv_co_co_tm a) \u (fv_co_co_tm b)
  | (a_Fam F) => {}
  | (a_Const T) => {}
  | (a_Pi rho A B) => (fv_co_co_tm A) \u (fv_co_co_tm B)
  | (a_Conv a g) => (fv_co_co_tm a) \u (fv_co_co_co g)
  | (a_CPi phi B) => (fv_co_co_constraint phi) \u (fv_co_co_tm B)
  | (a_CAbs phi b) => (fv_co_co_constraint phi) \u (fv_co_co_tm b)
  | (a_UCAbs b) => (fv_co_co_tm b)
  | (a_CApp a g) => (fv_co_co_tm a) \u (fv_co_co_co g)
  | a_Bullet => {}
  | (a_DataCon K) => {}
  | (a_Case a brs5) => (fv_co_co_tm a) \u (fv_co_co_brs brs5)
end
with fv_co_co_constraint (phi5:constraint) : vars :=
  match phi5 with
  | (Eq a b A) => (fv_co_co_tm a) \u (fv_co_co_tm b) \u (fv_co_co_tm A)
end.

Definition fv_tm_tm_sig_sort (sig_sort5:sig_sort) : vars :=
  match sig_sort5 with
  | (Cs A) => (fv_tm_tm_tm A)
  | (Ax a A) => (fv_tm_tm_tm a) \u (fv_tm_tm_tm A)
end.

Definition fv_co_co_sig_sort (sig_sort5:sig_sort) : vars :=
  match sig_sort5 with
  | (Cs A) => (fv_co_co_tm A)
  | (Ax a A) => (fv_co_co_tm a) \u (fv_co_co_tm A)
end.

Definition fv_tm_tm_sort (sort5:sort) : vars :=
  match sort5 with
  | (Tm A) => (fv_tm_tm_tm A)
  | (Co phi) => (fv_tm_tm_constraint phi)
end.

Definition fv_co_co_sort (sort5:sort) : vars :=
  match sort5 with
  | (Tm A) => (fv_co_co_tm A)
  | (Co phi) => (fv_co_co_constraint phi)
end.

Fixpoint tm_subst_tm_co (a5:tm) (x5:tmvar) (g_5:co) {struct g_5} : co :=
  match g_5 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => g_Var_b nat
  | (g_Var_f c) => g_Var_f c
  | (g_Beta a b) => g_Beta (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 b)
  | (g_Refl a) => g_Refl (tm_subst_tm_tm a5 x5 a)
  | (g_Refl2 a b g) => g_Refl2 (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 b) (tm_subst_tm_co a5 x5 g)
  | (g_Sym g) => g_Sym (tm_subst_tm_co a5 x5 g)
  | (g_Trans g1 g2) => g_Trans (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (tm_subst_tm_co a5 x5 g1) rho (tm_subst_tm_co a5 x5 g2)
  | (g_PiFst g) => g_PiFst (tm_subst_tm_co a5 x5 g)
  | (g_CPiFst g) => g_CPiFst (tm_subst_tm_co a5 x5 g)
  | (g_IsoSnd g) => g_IsoSnd (tm_subst_tm_co a5 x5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g3) (tm_subst_tm_co a5 x5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_Cast g1 g2) => g_Cast (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_co a5 x5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (tm_subst_tm_co a5 x5 g1) (tm_subst_tm_tm a5 x5 A) (tm_subst_tm_co a5 x5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (tm_subst_tm_constraint a5 x5 phi1) (tm_subst_tm_constraint a5 x5 phi2) (tm_subst_tm_co a5 x5 g)
  | (g_Eta a) => g_Eta (tm_subst_tm_tm a5 x5 a)
  | (g_Left g g') => g_Left (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g')
  | (g_Right g g') => g_Right (tm_subst_tm_co a5 x5 g) (tm_subst_tm_co a5 x5 g')
end
with tm_subst_tm_brs (a5:tm) (x5:tmvar) (brs_6:brs) {struct brs_6} : brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_brs a5 x5 brs5)
end
with tm_subst_tm_tm (a5:tm) (x5:tmvar) (a_6:tm) {struct a_6} : tm :=
  match a_6 with
  | a_Star => a_Star 
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => (if eq_var x x5 then a5 else (a_Var_f x))
  | (a_Abs rho A b) => a_Abs rho (tm_subst_tm_tm a5 x5 A) (tm_subst_tm_tm a5 x5 b)
  | (a_UAbs rho b) => a_UAbs rho (tm_subst_tm_tm a5 x5 b)
  | (a_App a rho b) => a_App (tm_subst_tm_tm a5 x5 a) rho (tm_subst_tm_tm a5 x5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (tm_subst_tm_tm a5 x5 A) (tm_subst_tm_tm a5 x5 B)
  | (a_Conv a g) => a_Conv (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_co a5 x5 g)
  | (a_CPi phi B) => a_CPi (tm_subst_tm_constraint a5 x5 phi) (tm_subst_tm_tm a5 x5 B)
  | (a_CAbs phi b) => a_CAbs (tm_subst_tm_constraint a5 x5 phi) (tm_subst_tm_tm a5 x5 b)
  | (a_UCAbs b) => a_UCAbs (tm_subst_tm_tm a5 x5 b)
  | (a_CApp a g) => a_CApp (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_co a5 x5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_brs a5 x5 brs5)
end
with tm_subst_tm_constraint (a5:tm) (x5:tmvar) (phi5:constraint) {struct phi5} : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 b) (tm_subst_tm_tm a5 x5 A)
end.

Fixpoint co_subst_co_co (g_5:co) (c5:covar) (g__6:co) {struct g__6} : co :=
  match g__6 with
  | g_Triv => g_Triv 
  | (g_Var_b nat) => g_Var_b nat
  | (g_Var_f c) => (if eq_var c c5 then g_5 else (g_Var_f c))
  | (g_Beta a b) => g_Beta (co_subst_co_tm g_5 c5 a) (co_subst_co_tm g_5 c5 b)
  | (g_Refl a) => g_Refl (co_subst_co_tm g_5 c5 a)
  | (g_Refl2 a b g) => g_Refl2 (co_subst_co_tm g_5 c5 a) (co_subst_co_tm g_5 c5 b) (co_subst_co_co g_5 c5 g)
  | (g_Sym g) => g_Sym (co_subst_co_co g_5 c5 g)
  | (g_Trans g1 g2) => g_Trans (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_PiCong rho g1 g2) => g_PiCong rho (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_AbsCong rho g1 g2) => g_AbsCong rho (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_AppCong g1 rho g2) => g_AppCong (co_subst_co_co g_5 c5 g1) rho (co_subst_co_co g_5 c5 g2)
  | (g_PiFst g) => g_PiFst (co_subst_co_co g_5 c5 g)
  | (g_CPiFst g) => g_CPiFst (co_subst_co_co g_5 c5 g)
  | (g_IsoSnd g) => g_IsoSnd (co_subst_co_co g_5 c5 g)
  | (g_PiSnd g1 g2) => g_PiSnd (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_CPiCong g1 g3) => g_CPiCong (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g3)
  | (g_CAbsCong g1 g3 g4) => g_CAbsCong (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g3) (co_subst_co_co g_5 c5 g4)
  | (g_CAppCong g g1 g2) => g_CAppCong (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_CPiSnd g g1 g2) => g_CPiSnd (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_Cast g1 g2) => g_Cast (co_subst_co_co g_5 c5 g1) (co_subst_co_co g_5 c5 g2)
  | (g_EqCong g1 A g2) => g_EqCong (co_subst_co_co g_5 c5 g1) (co_subst_co_tm g_5 c5 A) (co_subst_co_co g_5 c5 g2)
  | (g_IsoConv phi1 phi2 g) => g_IsoConv (co_subst_co_constraint g_5 c5 phi1) (co_subst_co_constraint g_5 c5 phi2) (co_subst_co_co g_5 c5 g)
  | (g_Eta a) => g_Eta (co_subst_co_tm g_5 c5 a)
  | (g_Left g g') => g_Left (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g')
  | (g_Right g g') => g_Right (co_subst_co_co g_5 c5 g) (co_subst_co_co g_5 c5 g')
end
with co_subst_co_brs (g5:co) (c5:covar) (brs_6:brs) {struct brs_6} : brs :=
  match brs_6 with
  | br_None => br_None 
  | (br_One K a brs5) => br_One K (co_subst_co_tm g5 c5 a) (co_subst_co_brs g5 c5 brs5)
end
with co_subst_co_tm (g5:co) (c5:covar) (a5:tm) {struct a5} : tm :=
  match a5 with
  | a_Star => a_Star 
  | (a_Var_b nat) => a_Var_b nat
  | (a_Var_f x) => a_Var_f x
  | (a_Abs rho A b) => a_Abs rho (co_subst_co_tm g5 c5 A) (co_subst_co_tm g5 c5 b)
  | (a_UAbs rho b) => a_UAbs rho (co_subst_co_tm g5 c5 b)
  | (a_App a rho b) => a_App (co_subst_co_tm g5 c5 a) rho (co_subst_co_tm g5 c5 b)
  | (a_Fam F) => a_Fam F
  | (a_Const T) => a_Const T
  | (a_Pi rho A B) => a_Pi rho (co_subst_co_tm g5 c5 A) (co_subst_co_tm g5 c5 B)
  | (a_Conv a g) => a_Conv (co_subst_co_tm g5 c5 a) (co_subst_co_co g5 c5 g)
  | (a_CPi phi B) => a_CPi (co_subst_co_constraint g5 c5 phi) (co_subst_co_tm g5 c5 B)
  | (a_CAbs phi b) => a_CAbs (co_subst_co_constraint g5 c5 phi) (co_subst_co_tm g5 c5 b)
  | (a_UCAbs b) => a_UCAbs (co_subst_co_tm g5 c5 b)
  | (a_CApp a g) => a_CApp (co_subst_co_tm g5 c5 a) (co_subst_co_co g5 c5 g)
  | a_Bullet => a_Bullet 
  | (a_DataCon K) => a_DataCon K
  | (a_Case a brs5) => a_Case (co_subst_co_tm g5 c5 a) (co_subst_co_brs g5 c5 brs5)
end
with co_subst_co_constraint (g5:co) (c5:covar) (phi5:constraint) {struct phi5} : constraint :=
  match phi5 with
  | (Eq a b A) => Eq (co_subst_co_tm g5 c5 a) (co_subst_co_tm g5 c5 b) (co_subst_co_tm g5 c5 A)
end.

Definition tm_subst_tm_sort (a5:tm) (x5:tmvar) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (tm_subst_tm_tm a5 x5 A)
  | (Co phi) => Co (tm_subst_tm_constraint a5 x5 phi)
end.

Definition co_subst_co_sort (g5:co) (c5:covar) (sort5:sort) : sort :=
  match sort5 with
  | (Tm A) => Tm (co_subst_co_tm g5 c5 A)
  | (Co phi) => Co (co_subst_co_constraint g5 c5 phi)
end.

Definition tm_subst_tm_sig_sort (a5:tm) (x5:tmvar) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (tm_subst_tm_tm a5 x5 A)
  | (Ax a A) => Ax (tm_subst_tm_tm a5 x5 a) (tm_subst_tm_tm a5 x5 A)
end.

Definition co_subst_co_sig_sort (g5:co) (c5:covar) (sig_sort5:sig_sort) : sig_sort :=
  match sig_sort5 with
  | (Cs A) => Cs (co_subst_co_tm g5 c5 A)
  | (Ax a A) => Ax (co_subst_co_tm g5 c5 a) (co_subst_co_tm g5 c5 A)
end.

Fixpoint erase_tm (a : tm) : tm :=
   match a with
   | a_Star    => a_Star
   | a_Var_b n => a_Var_b n
   | a_Var_f x => a_Var_f x
   | a_Abs rho A b => a_UAbs rho (erase_tm b)
   | a_UAbs rho b => a_UAbs rho (erase_tm b)
   | a_App a Rel b => a_App (erase_tm a) Rel (erase_tm b)
   | a_App a Irrel b => a_App (erase_tm a) Irrel a_Bullet
   | a_Const T => a_Const T
   | a_Fam F => a_Fam F
   | a_Pi rho A B => a_Pi rho (erase_tm A) (erase_tm B)
   | a_Conv a _ => erase_tm a
   | a_CPi phi B => a_CPi (erase_constraint phi) (erase_tm B)
   | a_CAbs phi b => a_UCAbs (erase_tm b)
   | a_UCAbs b => a_UCAbs (erase_tm b)
   | a_CApp a g => a_CApp (erase_tm a) g_Triv
   | a_DataCon K => a_Star  
   | a_Case a brs => a_Star 
   | a_Bullet => a_Bullet
   end
with erase_brs (x : brs) : brs :=
   match x with
   | br_None => br_None
   | br_One k a y => br_One k (erase_tm a) (erase_brs y)
   end
with erase_constraint (phi : constraint) : constraint :=
   match phi with
   | Eq A B A1 => Eq (erase_tm A) (erase_tm B) (erase_tm A1)
   end.

Definition erase_sort s :=
 match s with
 | Tm a => Tm (erase_tm a)
 | Co p => Co (erase_constraint p)
end.

Definition erase_csort s :=
 match s with
 | Cs a   => Cs (erase_tm a)
 | Ax a A => Ax (erase_tm a) (erase_tm A)
end.

Definition erase_context G := map erase_sort G.
Definition erase_sig S := map erase_csort S.

Definition Fix : atom.

Definition FixDef : tm :=
  (a_Abs Irrel a_Star
         (a_Abs Rel (a_Pi Rel (a_Var_b 0) (a_Var_b 1))
                (a_App (a_Var_b 0) Rel
                       (a_App (a_App (a_Fam Fix) Irrel (a_Var_b 1)) Rel (a_Var_b 0))))).

Definition FixTy : tm :=
  a_Pi Irrel a_Star
       (a_Pi Rel (a_Pi Rel (a_Var_b 0) (a_Var_b 1))
             (a_Var_b 1)).

Definition an_toplevel : sig := Fix ~ Ax FixDef FixTy.

Definition toplevel : sig := erase_sig an_toplevel.

Inductive Path : const -> tm -> Prop :=    
 | Path_Const : forall (T:const),
     Path T (a_Const T)
 | Path_App : forall (T:const) (a:tm) (rho:relflag) (b:tm),
     lc_tm b ->
     Path T a ->
     Path T  ( (a_App a rho b) ) 
 | Path_CApp : forall (T:const) (a:tm) (g:co),
     lc_co g ->
     Path T a ->
     Path T  ( (a_CApp a g) ) 
 | Path_Conv : forall (T:const) (a:tm) (g:co),
     lc_co g ->
     Path T a ->
     Path T  ( (a_Conv a g) ) .

Inductive CoercedValue : tm -> Prop :=    
 | CV : forall (a:tm),
     Value a ->
     CoercedValue a
 | CC : forall (a:tm) (g:co),
     lc_co g ->
     Value a ->
     CoercedValue  ( (a_Conv a g) ) 
with Value : tm -> Prop :=    
 | Value_Star : 
     Value a_Star
 | Value_Pi : forall (rho:relflag) (A B:tm),
     lc_tm A ->
     lc_tm (a_Pi rho A B) ->
     Value (a_Pi rho A B)
 | Value_CPi : forall (phi:constraint) (B:tm),
     lc_constraint phi ->
     lc_tm (a_CPi phi B) ->
     Value (a_CPi phi B)
 | Value_AbsRel : forall (A a:tm),
     lc_tm A ->
     lc_tm (a_Abs Rel A a) ->
     Value (a_Abs Rel A a)
 | Value_UAbsRel : forall (a:tm),
     lc_tm (a_UAbs Rel a) ->
     Value (a_UAbs Rel a)
 | Value_UAbsIrrel : forall (L:vars) (a:tm),
      ( forall x , x \notin  L  -> Value  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     Value (a_UAbs Irrel a)
 | Value_AbsIrrel : forall (L:vars) (A a:tm),
     lc_tm A ->
      ( forall x , x \notin  L  -> CoercedValue  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     Value (a_Abs Irrel A a)
 | Value_CAbs : forall (phi:constraint) (a:tm),
     lc_constraint phi ->
     lc_tm (a_CAbs phi a) ->
     Value (a_CAbs phi a)
 | Value_UCAbs : forall (a:tm),
     lc_tm (a_UCAbs a) ->
     Value (a_UCAbs a)
 | Value_Const : forall (T:const),
     Value (a_Const T)
 | Value_App : forall (a:tm) (rho:relflag) (b:tm) (T:const),
     lc_tm b ->
     Path T a ->
     Value a ->
     Value  ( (a_App a rho b) ) 
 | Value_CApp : forall (a:tm) (g:co) (T:const),
     lc_co g ->
     Path T a ->
     Value a ->
     Value  ( (a_CApp a g) ) 
with value_type : tm -> Prop :=    
 | value_type_Star : 
     value_type a_Star
 | value_type_Pi : forall (rho:relflag) (A B:tm),
     lc_tm A ->
     lc_tm (a_Pi rho A B) ->
     value_type (a_Pi rho A B)
 | value_type_CPi : forall (phi:constraint) (B:tm),
     lc_constraint phi ->
     lc_tm (a_CPi phi B) ->
     value_type (a_CPi phi B)
 | value_type_Const : forall (T:const),
     value_type (a_Const T)
 | value_type_App : forall (a:tm) (rho:relflag) (b:tm) (T:const),
     lc_tm b ->
     Path T a ->
     Value a ->
     value_type  ( (a_App a rho b) ) 
 | value_type_CApp : forall (a:tm) (g:co) (T:const),
     lc_co g ->
     Path T a ->
     Value a ->
     value_type  ( (a_CApp a g) ) 
with DataTy : tm -> tm -> Prop :=    
 | DT_Star : 
     DataTy a_Star a_Star
 | DT_Path : forall (A:tm) (T:const),
     Path T A ->
     DataTy A A
 | DT_Pi : forall (L:vars) (rho:relflag) (A B b:tm),
     lc_tm A ->
      ( forall x , x \notin  L  -> DataTy  ( open_tm_wrt_tm B (a_Var_f x) )  b )  ->
     DataTy  ( (a_Pi rho A B) )  b
 | DT_CPi : forall (L:vars) (phi:constraint) (B b:tm),
     lc_constraint phi ->
      ( forall c , c \notin  L  -> DataTy  ( open_tm_wrt_co B (g_Var_f c) )  b )  ->
     DataTy  ( (a_CPi phi B) )  b.

Inductive consistent : tm -> tm -> Prop :=    
 | consistent_a_Star : 
     consistent a_Star a_Star
 | consistent_a_Pi : forall (rho:relflag) (A1 B1 A2 B2:tm),
     lc_tm A1 ->
     lc_tm (a_Pi rho A1 B1) ->
     lc_tm A2 ->
     lc_tm (a_Pi rho A2 B2) ->
     consistent  ( (a_Pi rho A1 B1) )   ( (a_Pi rho A2 B2) ) 
 | consistent_a_CPi : forall (phi1:constraint) (A1:tm) (phi2:constraint) (A2:tm),
     lc_constraint phi1 ->
     lc_tm (a_CPi phi1 A1) ->
     lc_constraint phi2 ->
     lc_tm (a_CPi phi2 A2) ->
     consistent  ( (a_CPi phi1 A1) )   ( (a_CPi phi2 A2) ) 
 | consistent_a_Path : forall (a1 a2:tm) (T:const),
     Path T a1 ->
     Path T a2 ->
     consistent a1 a2
 | consistent_a_Step_R : forall (a b:tm),
     lc_tm a ->
      not ( value_type b )  ->
     consistent a b
 | consistent_a_Step_L : forall (a b:tm),
     lc_tm b ->
      not ( value_type a )  ->
     consistent a b.

Inductive RhoCheck : relflag -> tmvar -> tm -> Prop :=    
 | Rho_Rel : forall (x:tmvar) (A:tm),
      True  ->
     RhoCheck Rel x A
 | Rho_IrrRel : forall (x:tmvar) (A:tm),
      x  \notin fv_tm_tm_tm  A  ->
     RhoCheck Irrel x A.

Inductive erased_tm : tm -> Prop :=    
 | erased_a_Bullet : 
     erased_tm a_Bullet
 | erased_a_Star : 
     erased_tm a_Star
 | erased_a_Var : forall (x:tmvar),
     erased_tm (a_Var_f x)
 | erased_a_Abs : forall (L:vars) (rho:relflag) (a:tm),
      ( forall x , x \notin  L  -> erased_tm  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     erased_tm  ( (a_UAbs rho a) ) 
 | erased_a_App : forall (a b:tm),
     erased_tm a ->
     erased_tm b ->
     erased_tm  ( (a_App a Rel b) ) 
 | erased_a_AppIrrel : forall (a:tm),
     erased_tm a ->
     erased_tm  ( (a_App a Irrel a_Bullet) ) 
 | erased_a_Pi : forall (L:vars) (rho:relflag) (A B:tm),
     erased_tm A ->
      ( forall x , x \notin  L  -> erased_tm  ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
     erased_tm  ( (a_Pi rho A B) ) 
 | erased_a_CPi : forall (L:vars) (a b A B:tm),
     erased_tm a ->
     erased_tm b ->
     erased_tm A ->
      ( forall c , c \notin  L  -> erased_tm  ( open_tm_wrt_co B (g_Var_f c) )  )  ->
     erased_tm  ( (a_CPi (Eq a b A) B) ) 
 | erased_a_CAbs : forall (L:vars) (b:tm),
      ( forall c , c \notin  L  -> erased_tm  ( open_tm_wrt_co b (g_Var_f c) )  )  ->
     erased_tm  ( (a_UCAbs b) ) 
 | erased_a_CApp : forall (a:tm),
     erased_tm a ->
     erased_tm  ( (a_CApp a g_Triv) ) 
 | erased_a_Const : forall (T:const),
     erased_tm (a_Const T)
 | erased_a_Fam : forall (F:tyfam),
     erased_tm (a_Fam F).

Inductive Par : context -> available_props -> tm -> tm -> Prop :=    
 | Par_Refl : forall (G:context) (D:available_props) (a:tm),
     lc_tm a ->
     Par G D a a
 | Par_Beta : forall (G:context) (D:available_props) (a b a' b':tm),
     Par G D a  ( (a_UAbs Rel a') )  ->
     Par G D b b' ->
     Par G D (a_App a Rel b)  (open_tm_wrt_tm  a'   b' ) 
 | Par_BetaIrrel : forall (G:context) (D:available_props) (a a':tm),
     Par G D a  ( (a_UAbs Irrel a') )  ->
     Par G D (a_App a Irrel a_Bullet)  (open_tm_wrt_tm  a'   a_Bullet ) 
 | Par_App : forall (G:context) (D:available_props) (a b a' b':tm),
     Par G D a a' ->
     Par G D b b' ->
     Par G D (a_App a Rel b) (a_App a' Rel b')
 | Par_AppIrrel : forall (G:context) (D:available_props) (a a':tm),
     Par G D a a' ->
     Par G D (a_App a Irrel a_Bullet) (a_App a' Irrel a_Bullet)
 | Par_CBeta : forall (G:context) (D:available_props) (a a':tm),
     Par G D a  ( (a_UCAbs a') )  ->
     Par G D (a_CApp a g_Triv)  (open_tm_wrt_co  a'   g_Triv ) 
 | Par_CApp : forall (G:context) (D:available_props) (a a':tm),
     Par G D a a' ->
     Par G D (a_CApp a g_Triv) (a_CApp a' g_Triv)
 | Par_Abs : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (a a':tm),
      ( forall x , x \notin  L  -> Par G D  ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm a' (a_Var_f x) )  )  ->
     Par G D (a_UAbs rho a) (a_UAbs rho a')
 | Par_Pi : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (A B A' B':tm),
     Par G D A A' ->
      ( forall x , x \notin  L  -> Par G D  ( open_tm_wrt_tm B (a_Var_f x) )   ( open_tm_wrt_tm B' (a_Var_f x) )  )  ->
     Par G D (a_Pi rho A B) (a_Pi rho A' B')
 | Par_CAbs : forall (L:vars) (G:context) (D:available_props) (a a':tm),
      ( forall c , c \notin  L  -> Par G D  ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co a' (g_Var_f c) )  )  ->
     Par G D (a_UCAbs a) (a_UCAbs a')
 | Par_CPi : forall (L:vars) (G:context) (D:available_props) (A B A1 a A' B' A1' a':tm),
     Par G D A A' ->
     Par G D B B' ->
      ( forall c , c \notin  L  -> Par G D  ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co a' (g_Var_f c) )  )  ->
     Par G D A1 A1' ->
     Par G D (a_CPi (Eq A B A1) a) (a_CPi (Eq A' B' A1') a')
 | Par_Axiom : forall (G:context) (D:available_props) (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   toplevel   ->
     Par G D (a_Fam F) a
 | Par_Eta : forall (L:vars) (G:context) (D:available_props) (a b' b:tm),
     Par G D b b' ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Rel (a_Var_f x)) )  )  ->
     Par G D (a_UAbs Rel a) b'
 | Par_EtaIrrel : forall (L:vars) (G:context) (D:available_props) (a b' b:tm),
     Par G D b b' ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Irrel a_Bullet) )  )  ->
     Par G D (a_UAbs Irrel a) b'
 | Par_EtaC : forall (L:vars) (G:context) (D:available_props) (a b' b:tm),
     Par G D b b' ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a (g_Var_f c) )   =  (a_CApp b g_Triv) )  )  ->
     Par G D (a_UCAbs a) b'
with MultiPar : context -> available_props -> tm -> tm -> Prop :=    
 | MP_Refl : forall (G:context) (D:available_props) (a:tm),
     lc_tm a ->
     MultiPar G D a a
 | MP_Step : forall (G:context) (D:available_props) (a a' b:tm),
     Par G D a b ->
     MultiPar G D b a' ->
     MultiPar G D a a'
with joins : context -> available_props -> tm -> tm -> Prop :=    
 | join : forall (G:context) (D:available_props) (a1 a2 b:tm),
     MultiPar G D a1 b ->
     MultiPar G D a2 b ->
     joins G D a1 a2.

Inductive Beta : tm -> tm -> Prop :=    
 | Beta_AppAbs : forall (v b:tm),
     lc_tm (a_UAbs Rel v) ->
     lc_tm b ->
     Beta (a_App  ( (a_UAbs Rel v) )  Rel b)  (open_tm_wrt_tm  v   b ) 
 | Beta_AppAbsIrrel : forall (v:tm),
     Value  ( (a_UAbs Irrel v) )  ->
     Beta (a_App  ( (a_UAbs Irrel v) )  Irrel a_Bullet)  (open_tm_wrt_tm  v   a_Bullet ) 
 | Beta_CAppCAbs : forall (a':tm),
     lc_tm (a_UCAbs a') ->
     Beta (a_CApp  ( (a_UCAbs a') )  g_Triv)  (open_tm_wrt_co  a'   g_Triv ) 
 | Beta_Axiom : forall (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   toplevel   ->
     Beta (a_Fam F) a
with reduction_in_one : tm -> tm -> Prop :=    
 | E_AbsTerm : forall (L:vars) (a a':tm),
      ( forall x , x \notin  L  -> reduction_in_one  ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm a' (a_Var_f x) )  )  ->
     reduction_in_one (a_UAbs Irrel a) (a_UAbs Irrel a')
 | E_AppLeft : forall (a b a':tm),
     lc_tm b ->
     reduction_in_one a a' ->
     reduction_in_one (a_App a Rel b) (a_App a' Rel b)
 | E_AppLeftIrrel : forall (a a':tm),
     reduction_in_one a a' ->
     reduction_in_one (a_App a Irrel a_Bullet) (a_App a' Irrel a_Bullet)
 | E_CAppLeft : forall (a a':tm),
     reduction_in_one a a' ->
     reduction_in_one (a_CApp a g_Triv) (a_CApp a' g_Triv)
 | E_AppAbs : forall (v a:tm),
     lc_tm (a_UAbs Rel v) ->
     lc_tm a ->
     reduction_in_one (a_App  ( (a_UAbs Rel v) )  Rel a)  (open_tm_wrt_tm  v   a ) 
 | E_AppAbsIrrel : forall (v:tm),
     Value  ( (a_UAbs Irrel v) )  ->
     reduction_in_one (a_App  ( (a_UAbs Irrel v) )  Irrel a_Bullet)  (open_tm_wrt_tm  v   a_Bullet ) 
 | E_CAppCAbs : forall (b:tm),
     lc_tm (a_UCAbs b) ->
     reduction_in_one (a_CApp  ( (a_UCAbs b) )  g_Triv)  (open_tm_wrt_co  b   g_Triv ) 
 | E_Axiom : forall (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   toplevel   ->
     reduction_in_one (a_Fam F) a
with reduction : tm -> tm -> Prop :=    
 | Equal : forall (a:tm),
     lc_tm a ->
     reduction a a
 | Step : forall (a a' b:tm),
     reduction_in_one a b ->
     reduction b a' ->
     reduction a a'.

Inductive PropWff : context -> constraint -> Prop :=    
 | E_Wff : forall (G:context) (a b A:tm),
     Typing G a A ->
     Typing G b A ->
      ( Typing G A a_Star )  ->
     PropWff G (Eq a b A)
with Typing : context -> tm -> tm -> Prop :=    
 | E_Star : forall (G:context),
     Ctx G ->
     Typing G a_Star a_Star
 | E_Var : forall (G:context) (x:tmvar) (A:tm),
     Ctx G ->
      binds  x  (Tm  A )  G  ->
     Typing G (a_Var_f x) A
 | E_Pi : forall (L:vars) (G:context) (rho:relflag) (A B:tm),
      ( forall x , x \notin  L  -> Typing  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm B (a_Var_f x) )  a_Star )  ->
      ( Typing G A a_Star )  ->
     Typing G (a_Pi rho A B) a_Star
 | E_Abs : forall (L:vars) (G:context) (rho:relflag) (a A B:tm),
      ( forall x , x \notin  L  -> Typing  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
      ( Typing G A a_Star )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm a (a_Var_f x) )  )  ->
     Typing G (a_UAbs rho a) (a_Pi rho A B)
 | E_App : forall (G:context) (b a B A:tm),
     Typing G b (a_Pi Rel A B) ->
     Typing G a A ->
     Typing G (a_App b Rel a)  (open_tm_wrt_tm  B   a ) 
 | E_IApp : forall (G:context) (b B a A:tm),
     Typing G b (a_Pi Irrel A B) ->
     Typing G a A ->
     Typing G (a_App b Irrel a_Bullet)  (open_tm_wrt_tm  B   a ) 
 | E_Conv : forall (G:context) (a B A:tm),
     Typing G a A ->
     DefEq G  (dom  G )  A B a_Star ->
      ( Typing G B a_Star )  ->
     Typing G a B
 | E_CPi : forall (L:vars) (G:context) (phi:constraint) (B:tm),
      ( forall c , c \notin  L  -> Typing  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co B (g_Var_f c) )  a_Star )  ->
      ( PropWff G phi )  ->
     Typing G (a_CPi phi B) a_Star
 | E_CAbs : forall (L:vars) (G:context) (a:tm) (phi:constraint) (B:tm),
      ( forall c , c \notin  L  -> Typing  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  )  ->
      ( PropWff G phi )  ->
     Typing G (a_UCAbs a) (a_CPi phi B)
 | E_CApp : forall (G:context) (a1 B1 a b A:tm),
     Typing G a1 (a_CPi  ( (Eq a b A) )  B1) ->
     DefEq G  (dom  G )  a b A ->
     Typing G (a_CApp a1 g_Triv)  (open_tm_wrt_co  B1   g_Triv ) 
 | E_Const : forall (G:context) (T:const) (A:tm),
     Ctx G ->
      binds  T  (Cs  A )   toplevel   ->
      ( Typing  nil  A a_Star )  ->
     Typing G (a_Const T) A
 | E_Fam : forall (G:context) (F:tyfam) (A a:tm),
     Ctx G ->
      binds  F  (Ax  a A )   toplevel   ->
      ( Typing  nil  A a_Star )  ->
     Typing G (a_Fam F) A
with Iso : context -> available_props -> constraint -> constraint -> Prop :=    
 | E_PropCong : forall (G:context) (D:available_props) (A1 B1 A A2 B2:tm),
     DefEq G D A1 A2 A ->
     DefEq G D B1 B2 A ->
     Iso G D (Eq A1 B1 A) (Eq A2 B2 A)
 | E_IsoConv : forall (G:context) (D:available_props) (A1 A2 A B:tm),
     DefEq G D A B a_Star ->
     PropWff G (Eq A1 A2 A) ->
     PropWff G (Eq A1 A2 B) ->
     Iso G D (Eq A1 A2 A) (Eq A1 A2 B)
 | E_CPiFst : forall (G:context) (D:available_props) (phi1 phi2:constraint) (B1 B2:tm),
     DefEq G D (a_CPi phi1 B1) (a_CPi phi2 B2) a_Star ->
     Iso G D phi1 phi2
with DefEq : context -> available_props -> tm -> tm -> tm -> Prop :=    
 | E_Assn : forall (G:context) (D:available_props) (a b A:tm) (c:covar),
     Ctx G ->
      binds  c  (Co   ( (Eq a b A) )  )  G  ->
      AtomSetImpl.In  c   D  ->
     DefEq G D a b A
 | E_Refl : forall (G:context) (D:available_props) (a A:tm),
     Typing G a A ->
     DefEq G D a a A
 | E_Sym : forall (G:context) (D:available_props) (a b A:tm),
     DefEq G D b a A ->
     DefEq G D a b A
 | E_Trans : forall (G:context) (D:available_props) (a b A a1:tm),
     DefEq G D a a1 A ->
     DefEq G D a1 b A ->
     DefEq G D a b A
 | E_Beta : forall (G:context) (D:available_props) (a1 a2 B:tm),
     Typing G a1 B ->
      ( Typing G a2 B )  ->
     Beta a1 a2 ->
     DefEq G D a1 a2 B
 | E_PiCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (A1 B1 A2 B2:tm),
     DefEq G D A1 A2 a_Star ->
      ( forall x , x \notin  L  -> DefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_tm_wrt_tm B1 (a_Var_f x) )   ( open_tm_wrt_tm B2 (a_Var_f x) )  a_Star )  ->
      ( Typing G A1 a_Star )  ->
      ( Typing G (a_Pi rho A1 B1) a_Star )  ->
      ( Typing G (a_Pi rho A2 B2) a_Star )  ->
     DefEq G D  ( (a_Pi rho A1 B1) )   ( (a_Pi rho A2 B2) )  a_Star
 | E_AbsCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (b1 b2 A1 B:tm),
      ( forall x , x \notin  L  -> DefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_tm_wrt_tm b1 (a_Var_f x) )   ( open_tm_wrt_tm b2 (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
      ( Typing G A1 a_Star )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm b1 (a_Var_f x) )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  ( open_tm_wrt_tm b2 (a_Var_f x) )  )  ->
     DefEq G D  ( (a_UAbs rho b1) )   ( (a_UAbs rho b2) )  (a_Pi rho A1 B)
 | E_AppCong : forall (G:context) (D:available_props) (a1 a2 b1 b2 B A:tm),
     DefEq G D a1 b1 (a_Pi Rel A B) ->
     DefEq G D a2 b2 A ->
     DefEq G D (a_App a1 Rel a2) (a_App b1 Rel b2)  (open_tm_wrt_tm  B   a2 ) 
 | E_IAppCong : forall (G:context) (D:available_props) (a1 b1 B a A:tm),
     DefEq G D a1 b1 (a_Pi Irrel A B) ->
     Typing G a A ->
     DefEq G D (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet)  (open_tm_wrt_tm  B   a ) 
 | E_PiFst : forall (G:context) (D:available_props) (A1 A2:tm) (rho:relflag) (B1 B2:tm),
     DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star ->
     DefEq G D A1 A2 a_Star
 | E_PiSnd : forall (G:context) (D:available_props) (B1 a1 B2 a2:tm) (rho:relflag) (A1 A2:tm),
     DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star ->
     DefEq G D a1 a2 A1 ->
     DefEq G D  (open_tm_wrt_tm  B1   a1 )   (open_tm_wrt_tm  B2   a2 )  a_Star
 | E_CPiCong : forall (L:vars) (G:context) (D:available_props) (phi1:constraint) (A:tm) (phi2:constraint) (B:tm),
     Iso G D phi1 phi2 ->
      ( forall c , c \notin  L  -> DefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_tm_wrt_co A (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  a_Star )  ->
      ( PropWff G phi1 )  ->
      ( Typing G (a_CPi phi1 A) a_Star )  ->
      ( Typing G (a_CPi phi2 B) a_Star )  ->
     DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star
 | E_CAbsCong : forall (L:vars) (G:context) (D:available_props) (a b:tm) (phi1:constraint) (B:tm),
      ( forall c , c \notin  L  -> DefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co b (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  )  ->
      ( PropWff G phi1 )  ->
     DefEq G D  ( (a_UCAbs a) )   ( (a_UCAbs b) )  (a_CPi phi1 B)
 | E_CAppCong : forall (G:context) (D:available_props) (a1 b1 B a b A:tm),
     DefEq G D a1 b1 (a_CPi  ( (Eq a b A) )  B) ->
     DefEq G  (dom  G )  a b A ->
     DefEq G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv)  (open_tm_wrt_co  B   g_Triv ) 
 | E_CPiSnd : forall (G:context) (D:available_props) (B1 B2 a1 a2 A a1' a2' A':tm),
     DefEq G D (a_CPi  ( (Eq a1 a2 A) )  B1) (a_CPi  ( (Eq a1' a2' A') )  B2) a_Star ->
     DefEq G  (dom  G )  a1 a2 A ->
     DefEq G  (dom  G )  a1' a2' A' ->
     DefEq G D  (open_tm_wrt_co  B1   g_Triv )   (open_tm_wrt_co  B2   g_Triv )  a_Star
 | E_Cast : forall (G:context) (D:available_props) (a' b' A' a b A:tm),
     DefEq G D a b A ->
     Iso G D (Eq a b A) (Eq a' b' A') ->
     DefEq G D a' b' A'
 | E_EqConv : forall (G:context) (D:available_props) (a b B A:tm),
     DefEq G D a b A ->
     DefEq G  (dom  G )  A B a_Star ->
     DefEq G D a b B
 | E_IsoSnd : forall (G:context) (D:available_props) (A A' a b a' b':tm),
     Iso G D (Eq a b A) (Eq a' b' A') ->
     DefEq G D A A' a_Star
 | E_EtaRel : forall (L:vars) (G:context) (D:available_props) (a b A B:tm),
     Typing G b (a_Pi Rel A B) ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Rel (a_Var_f x)) )  )  ->
     DefEq G D (a_UAbs Rel a) b (a_Pi Rel A B)
 | E_EtaIrrel : forall (L:vars) (G:context) (D:available_props) (a b A B:tm),
     Typing G b (a_Pi Irrel A B) ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b Irrel a_Bullet) )  )  ->
     DefEq G D (a_UAbs Irrel a) b (a_Pi Irrel A B)
 | E_EtaC : forall (L:vars) (G:context) (D:available_props) (a b:tm) (phi:constraint) (B:tm),
     Typing G b (a_CPi phi B) ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a (g_Var_f c) )   =  (a_CApp b g_Triv) )  )  ->
     DefEq G D (a_UCAbs a) b (a_CPi phi B)
with Ctx : context -> Prop :=    
 | E_Empty : 
     Ctx  nil 
 | E_ConsTm : forall (G:context) (x:tmvar) (A:tm),
     Ctx G ->
     Typing G A a_Star ->
      ~ AtomSetImpl.In  x  (dom  G )  ->
     Ctx  (( x ~ Tm  A ) ++  G ) 
 | E_ConsCo : forall (G:context) (c:covar) (phi:constraint),
     Ctx G ->
     PropWff G phi ->
      ~ AtomSetImpl.In  c  (dom  G )  ->
     Ctx  (( c ~ Co  phi ) ++  G ) .

Inductive Sig : sig -> Prop :=    
 | Sig_Empty : 
     Sig  nil 
 | Sig_ConsCs : forall (S:sig) (T:const) (A:tm),
     Sig S ->
     DataTy A a_Star ->
     Typing  nil  A a_Star ->
      ~ AtomSetImpl.In  T  (dom  S )  ->
     Sig  (( T ~ Cs A )++ S ) 
 | Sig_ConsAx : forall (S:sig) (F:tyfam) (a A:tm),
     Sig S ->
     Typing  nil  A a_Star ->
     Typing  nil  a A ->
      ~ AtomSetImpl.In  F  (dom  S )  ->
     Sig  (( F ~ Ax a A )++ S ) .

Inductive AnnPropWff : context -> constraint -> Prop :=    
 | An_Wff : forall (G:context) (a b A B:tm),
     AnnTyping G a A ->
     AnnTyping G b B ->
      (  (erase_tm  A )   =   (erase_tm  B )  )  ->
     AnnPropWff G (Eq a b A)
with AnnTyping : context -> tm -> tm -> Prop :=    
 | An_Star : forall (G:context),
     AnnCtx G ->
     AnnTyping G a_Star a_Star
 | An_Var : forall (G:context) (x:tmvar) (A:tm),
     AnnCtx G ->
      binds  x  (Tm  A )  G  ->
     AnnTyping G (a_Var_f x) A
 | An_Pi : forall (L:vars) (G:context) (rho:relflag) (A B:tm),
      ( forall x , x \notin  L  -> AnnTyping  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm B (a_Var_f x) )  a_Star )  ->
      ( AnnTyping G A a_Star )  ->
     AnnTyping G (a_Pi rho A B) a_Star
 | An_Abs : forall (L:vars) (G:context) (rho:relflag) (A a B:tm),
      ( AnnTyping G A a_Star )  ->
      ( forall x , x \notin  L  -> AnnTyping  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm a (a_Var_f x) )   ( open_tm_wrt_tm B (a_Var_f x) )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  (erase_tm   ( open_tm_wrt_tm a (a_Var_f x) )  )  )  ->
     AnnTyping G (a_Abs rho A a) (a_Pi rho A B)
 | An_App : forall (G:context) (b:tm) (rho:relflag) (a B A:tm),
     AnnTyping G b (a_Pi rho A B) ->
     AnnTyping G a A ->
     AnnTyping G (a_App b rho a)  (open_tm_wrt_tm  B   a ) 
 | An_Conv : forall (G:context) (a:tm) (g:co) (B A:tm),
     AnnTyping G a A ->
     AnnDefEq G  (dom  G )  g A B ->
     AnnTyping G B a_Star ->
     AnnTyping G (a_Conv a g) B
 | An_CPi : forall (L:vars) (G:context) (phi:constraint) (B:tm),
      ( AnnPropWff G phi )  ->
      ( forall c , c \notin  L  -> AnnTyping  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co B (g_Var_f c) )  a_Star )  ->
     AnnTyping G (a_CPi phi B) a_Star
 | An_CAbs : forall (L:vars) (G:context) (phi:constraint) (a B:tm),
      ( AnnPropWff G phi )  ->
      ( forall c , c \notin  L  -> AnnTyping  (( c ~ Co  phi ) ++  G )   ( open_tm_wrt_co a (g_Var_f c) )   ( open_tm_wrt_co B (g_Var_f c) )  )  ->
     AnnTyping G (a_CAbs phi a) (a_CPi phi B)
 | An_CApp : forall (G:context) (a1:tm) (g:co) (B a b A1:tm),
     AnnTyping G a1 (a_CPi (Eq a b A1) B) ->
     AnnDefEq G  (dom  G )  g a b ->
     AnnTyping G (a_CApp a1 g)  (open_tm_wrt_co  B   g ) 
 | An_Const : forall (G:context) (T:const) (A:tm),
     AnnCtx G ->
      binds  T  (Cs  A )   an_toplevel   ->
      ( AnnTyping  nil  A a_Star )  ->
     AnnTyping G (a_Const T) A
 | An_Fam : forall (G:context) (F:tyfam) (A a:tm),
     AnnCtx G ->
      binds  F  (Ax  a A )   an_toplevel   ->
      ( AnnTyping  nil  A a_Star )  ->
     AnnTyping G (a_Fam F) A
with AnnIso : context -> available_props -> co -> constraint -> constraint -> Prop :=    
 | An_PropCong : forall (G:context) (D:available_props) (g1:co) (A:tm) (g2:co) (A1 B1 A2 B2:tm),
     AnnDefEq G D g1 A1 A2 ->
     AnnDefEq G D g2 B1 B2 ->
     AnnPropWff G (Eq A1 B1 A) ->
     AnnPropWff G (Eq A2 B2 A) ->
     AnnIso G D  ( (g_EqCong g1 A g2) )   ( (Eq A1 B1 A) )   ( (Eq A2 B2 A) ) 
 | An_CPiFst : forall (G:context) (D:available_props) (g:co) (phi1 phi2:constraint) (A2 B2:tm),
     AnnDefEq G D g (a_CPi phi1 A2) (a_CPi phi2 B2) ->
     AnnIso G D (g_CPiFst g) phi1 phi2
 | An_IsoSym : forall (G:context) (D:available_props) (g:co) (phi2 phi1:constraint),
     AnnIso G D g phi1 phi2 ->
     AnnIso G D (g_Sym g) phi2 phi1
 | An_IsoConv : forall (G:context) (D:available_props) (a1 a2 A a1' a2' B:tm) (g:co),
     AnnDefEq G D g A B ->
     AnnPropWff G (Eq a1 a2 A) ->
     AnnPropWff G (Eq a1' a2' B) ->
      (  (erase_tm  a1 )   =   (erase_tm  a1' )  )  ->
      (  (erase_tm  a2 )   =   (erase_tm  a2' )  )  ->
     AnnIso G D (g_IsoConv  ( (Eq a1 a2 A) )   ( (Eq a1' a2' B) )  g)  ( (Eq a1 a2 A) )   ( (Eq a1' a2' B) ) 
with AnnDefEq : context -> available_props -> co -> tm -> tm -> Prop :=    
 | An_Assn : forall (G:context) (D:available_props) (c:covar) (a b A:tm),
     AnnCtx G ->
      binds  c  (Co  (Eq a b A) )  G  ->
      AtomSetImpl.In  c   D  ->
     AnnDefEq G D (g_Var_f c) a b
 | An_Refl : forall (G:context) (D:available_props) (a A:tm),
     AnnTyping G a A ->
     AnnDefEq G D (g_Refl a) a a
 | An_EraseEq : forall (G:context) (D:available_props) (a b:tm) (g:co) (A B:tm),
     AnnTyping G a A ->
     AnnTyping G b B ->
      (  (erase_tm  a )   =   (erase_tm  b )  )  ->
     AnnDefEq G  (dom  G )  g A B ->
     AnnDefEq G D (g_Refl2 a b g) a b
 | An_Sym : forall (G:context) (D:available_props) (g:co) (a b B A:tm) (g1:co),
     AnnTyping G b B ->
     AnnTyping G a A ->
      ( AnnDefEq G  (dom  G )  g1 B A )  ->
     AnnDefEq G D g b a ->
     AnnDefEq G D (g_Sym g) a b
 | An_Trans : forall (G:context) (D:available_props) (g1 g2:co) (a b a1 A A1:tm) (g3:co),
     AnnDefEq G D g1 a a1 ->
     AnnDefEq G D g2 a1 b ->
      ( AnnTyping G a A )  ->
      ( AnnTyping G a1 A1 )  ->
      ( AnnDefEq G  (dom  G )  g3 A A1 )  ->
     AnnDefEq G D  ( (g_Trans g1 g2) )  a b
 | An_Beta : forall (G:context) (D:available_props) (a1 a2 B0 B1:tm),
     AnnTyping G a1 B0 ->
     AnnTyping G a2 B1 ->
      (  (erase_tm  B0 )   =   (erase_tm  B1 )  )  ->
     Beta  (erase_tm  a1 )   (erase_tm  a2 )  ->
     AnnDefEq G D (g_Beta a1 a2) a1 a2
 | An_PiCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (A1 B1 A2 B3 B2:tm),
     AnnDefEq G D g1 A1 A2 ->
      ( forall x , x \notin  L  -> AnnDefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_co_wrt_tm g2 (a_Var_f x) )   ( open_tm_wrt_tm B1 (a_Var_f x) )    (open_tm_wrt_tm  B2   (a_Var_f x) )   )  ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm B3 (a_Var_f x) )   =   (open_tm_wrt_tm  B2   (a_Conv (a_Var_f x) (g_Sym g1)) )  )  )  ->
     AnnTyping G (a_Pi rho A1 B1) a_Star ->
     AnnTyping G (a_Pi rho A2 B3) a_Star ->
     AnnTyping G  ( (a_Pi rho A1 B2) )  a_Star ->
     AnnDefEq G D (g_PiCong rho g1 g2)  ( (a_Pi rho A1 B1) )   ( (a_Pi rho A2 B3) ) 
 | An_AbsCong : forall (L:vars) (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (A1 b1 A2 b3 b2 B:tm),
     AnnDefEq G D g1 A1 A2 ->
      ( forall x , x \notin  L  -> AnnDefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_co_wrt_tm g2 (a_Var_f x) )   ( open_tm_wrt_tm b1 (a_Var_f x) )    (open_tm_wrt_tm  b2   (a_Var_f x) )   )  ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm b3 (a_Var_f x) )   =   (open_tm_wrt_tm  b2   (a_Conv (a_Var_f x) (g_Sym g1)) )  )  )  ->
      ( AnnTyping G A1 a_Star )  ->
     AnnTyping G A2 a_Star ->
      ( forall x , x \notin  L  -> RhoCheck rho x  (erase_tm   ( open_tm_wrt_tm b1 (a_Var_f x) )  )  )  ->
      ( forall x , x \notin  L  -> RhoCheck rho x  (erase_tm   ( open_tm_wrt_tm b3 (a_Var_f x) )  )  )  ->
      ( AnnTyping G  ( (a_Abs rho A1 b2) )  B )  ->
     AnnDefEq G D  ( (g_AbsCong rho g1 g2) )   ( (a_Abs rho A1 b1) )   ( (a_Abs rho A2 b3) ) 
 | An_AppCong : forall (G:context) (D:available_props) (g1:co) (rho:relflag) (g2:co) (a1 a2 b1 b2 A B:tm) (g3:co),
     AnnDefEq G D g1 a1 b1 ->
     AnnDefEq G D g2 a2 b2 ->
     AnnTyping G (a_App a1 rho a2) A ->
     AnnTyping G (a_App b1 rho b2) B ->
      ( AnnDefEq G  (dom  G )  g3 A B )  ->
     AnnDefEq G D (g_AppCong g1 rho g2) (a_App a1 rho a2) (a_App b1 rho b2)
 | An_PiFst : forall (G:context) (D:available_props) (g:co) (A1 A2:tm) (rho:relflag) (B1 B2:tm),
     AnnDefEq G D g (a_Pi rho A1 B1) (a_Pi rho A2 B2) ->
     AnnDefEq G D (g_PiFst g) A1 A2
 | An_PiSnd : forall (G:context) (D:available_props) (g1 g2:co) (B1 a1 B2 a2:tm) (rho:relflag) (A1 A2:tm),
     AnnDefEq G D g1 (a_Pi rho A1 B1) (a_Pi rho A2 B2) ->
     AnnDefEq G D g2 a1 a2 ->
     AnnTyping G a1 A1 ->
     AnnTyping G a2 A2 ->
     AnnDefEq G D (g_PiSnd g1 g2)   (open_tm_wrt_tm  B1   a1 )     (open_tm_wrt_tm  B2   a2 )  
 | An_CPiCong : forall (L:vars) (G:context) (D:available_props) (g1 g3:co) (phi1:constraint) (B1:tm) (phi2:constraint) (B3 B2:tm),
     AnnIso G D g1 phi1 phi2 ->
      ( forall c , c \notin  L  -> AnnDefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_co_wrt_co g3 (g_Var_f c) )   ( open_tm_wrt_co B1 (g_Var_f c) )    (open_tm_wrt_co  B2   (g_Var_f c) )   )  ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co B3 (g_Var_f c) )   =   (open_tm_wrt_co  B2   (g_Cast (g_Var_f c) (g_Sym g1)) )  )  )  ->
     AnnTyping G (a_CPi phi1 B1) a_Star ->
      ( AnnTyping G (a_CPi phi2 B3) a_Star )  ->
     AnnTyping G (a_CPi phi1 B2) a_Star ->
     AnnDefEq G D  ( (g_CPiCong g1 g3) )   ( (a_CPi phi1 B1) )   ( (a_CPi phi2 B3) ) 
 | An_CAbsCong : forall (L:vars) (G:context) (D:available_props) (g1 g3 g4:co) (phi1:constraint) (a1:tm) (phi2:constraint) (a3 a2 B1 B2 B:tm),
     AnnIso G D g1 phi1 phi2 ->
      ( forall c , c \notin  L  -> AnnDefEq  (( c ~ Co  phi1 ) ++  G )  D  ( open_co_wrt_co g3 (g_Var_f c) )   ( open_tm_wrt_co a1 (g_Var_f c) )    (open_tm_wrt_co  a2   (g_Var_f c) )   )  ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a3 (g_Var_f c) )   =   (open_tm_wrt_co  a2   (g_Cast (g_Var_f c) (g_Sym g1)) )  )  )  ->
     AnnTyping G  ( (a_CAbs phi1 a1) )  (a_CPi phi1 B1) ->
     AnnTyping G  ( (a_CAbs phi2 a3) )  (a_CPi phi2 B2) ->
     AnnTyping G  ( (a_CAbs phi1 a2) )  B ->
     AnnDefEq G  (dom  G )  g4 (a_CPi phi1 B1) (a_CPi phi2 B2) ->
     AnnDefEq G D  ( (g_CAbsCong g1 g3 g4) )   ( (a_CAbs phi1 a1) )   ( (a_CAbs phi2 a3) ) 
 | An_CAppCong : forall (G:context) (D:available_props) (g1 g2 g3:co) (a1 b1 a2 b2 a3 b3 A B:tm) (g4:co),
     AnnDefEq G D g1 a1 b1 ->
     AnnDefEq G  (dom  G )  g2 a2 b2 ->
     AnnDefEq G  (dom  G )  g3 a3 b3 ->
     AnnTyping G (a_CApp a1 g2) A ->
     AnnTyping G (a_CApp b1 g3) B ->
      ( AnnDefEq G  (dom  G )  g4 A B )  ->
     AnnDefEq G D (g_CAppCong g1 g2 g3) (a_CApp a1 g2) (a_CApp b1 g3)
 | An_CPiSnd : forall (G:context) (D:available_props) (g1 g2 g3:co) (B1 B2 a a' A b b' B:tm),
     AnnDefEq G D g1  ( (a_CPi (Eq a a' A) B1) )   ( (a_CPi (Eq b b' B) B2) )  ->
     AnnDefEq G  (dom  G )  g2 a a' ->
     AnnDefEq G  (dom  G )  g3 b b' ->
     AnnDefEq G D (g_CPiSnd g1 g2 g3)  (open_tm_wrt_co  B1   g2 )   (open_tm_wrt_co  B2   g3 ) 
 | An_Cast : forall (G:context) (D:available_props) (g1 g2:co) (b b' a a' A B:tm),
     AnnDefEq G D g1 a a' ->
     AnnIso G D g2 (Eq a a' A) (Eq b b' B) ->
     AnnDefEq G D (g_Cast g1 g2) b b'
 | An_IsoSnd : forall (G:context) (D:available_props) (g:co) (A B a a' b b':tm),
     AnnIso G D g  ( (Eq a a' A) )   ( (Eq b b' B) )  ->
     AnnDefEq G D (g_IsoSnd g) A B
 | An_Eta : forall (L:vars) (G:context) (D:available_props) (b:tm) (rho:relflag) (A a B:tm),
     AnnTyping G b (a_Pi rho A B) ->
      ( forall x , x \notin  L  ->  (  ( open_tm_wrt_tm a (a_Var_f x) )   =  (a_App b rho (a_Var_f x)) )  )  ->
     AnnDefEq G D (g_Eta b)  ( (a_Abs rho A a) )  b
 | An_EtaC : forall (L:vars) (G:context) (D:available_props) (b:tm) (phi:constraint) (a B:tm),
     AnnTyping G b (a_CPi phi B) ->
      ( forall c , c \notin  L  ->  (  ( open_tm_wrt_co a (g_Var_f c) )   =  (a_CApp b (g_Var_f c)) )  )  ->
     AnnDefEq G D (g_Eta b)  ( (a_CAbs phi a) )  b
with AnnCtx : context -> Prop :=    
 | An_Empty : 
     AnnCtx  nil 
 | An_ConsTm : forall (G:context) (x:tmvar) (A:tm),
     AnnCtx G ->
     AnnTyping G A a_Star ->
      ~ AtomSetImpl.In  x  (dom  G )  ->
     AnnCtx  (( x ~ Tm  A ) ++  G ) 
 | An_ConsCo : forall (G:context) (c:covar) (phi:constraint),
     AnnCtx G ->
     AnnPropWff G phi ->
      ~ AtomSetImpl.In  c  (dom  G )  ->
     AnnCtx  (( c ~ Co  phi ) ++  G ) 
with AnnSig : sig -> Prop :=    
 | An_Sig_Empty : 
     AnnSig  nil 
 | An_Sig_ConsCs : forall (S:sig) (T:const) (A:tm),
     AnnSig S ->
     AnnTyping  nil  A a_Star ->
     DataTy A a_Star ->
      ~ AtomSetImpl.In  T  (dom  S )  ->
     AnnSig  (( T ~ Cs A )++ S ) 
 | An_Sig_ConsAx : forall (S:sig) (F:tyfam) (a A:tm),
     AnnSig S ->
     AnnTyping  nil  A a_Star ->
     AnnTyping  nil  a A ->
      ~ AtomSetImpl.In  F  (dom  S )  ->
     AnnSig  (( F ~ Ax a A )++ S ) .

Inductive head_reduction : context -> tm -> tm -> Prop :=    
 | An_AppLeft : forall (G:context) (a:tm) (rho:relflag) (b a':tm),
     lc_tm b ->
     head_reduction G a a' ->
     head_reduction G (a_App a rho b) (a_App a' rho b)
 | An_AppAbs : forall (G:context) (rho:relflag) (A w a:tm),
     lc_tm a ->
     Value  ( (a_Abs rho A w) )  ->
     head_reduction G (a_App  ( (a_Abs rho A w) )  rho a)  (open_tm_wrt_tm  w   a ) 
 | An_CAppLeft : forall (G:context) (a:tm) (g:co) (a':tm),
     lc_co g ->
     head_reduction G a a' ->
     head_reduction G (a_CApp a g) (a_CApp a' g)
 | An_CAppCAbs : forall (G:context) (phi:constraint) (b:tm) (g:co),
     lc_constraint phi ->
     lc_tm (a_CAbs phi b) ->
     lc_co g ->
     head_reduction G (a_CApp  ( (a_CAbs phi b) )  g)  (open_tm_wrt_co  b   g ) 
 | An_AbsTerm : forall (L:vars) (G:context) (A b b':tm),
     AnnTyping G A a_Star ->
      ( forall x , x \notin  L  -> head_reduction  (( x ~ Tm  A ) ++  G )   ( open_tm_wrt_tm b (a_Var_f x) )   ( open_tm_wrt_tm b' (a_Var_f x) )  )  ->
     head_reduction G  ( (a_Abs Irrel A b) )   ( (a_Abs Irrel A b') ) 
 | An_Axiom : forall (G:context) (F:tyfam) (a A:tm),
      binds  F  (Ax  a A )   an_toplevel   ->
     head_reduction G (a_Fam F) a
 | An_ConvTerm : forall (G:context) (a:tm) (g:co) (a':tm),
     lc_co g ->
     head_reduction G a a' ->
     head_reduction G (a_Conv a g) (a_Conv a' g)
 | An_Combine : forall (G:context) (v:tm) (g1 g2:co),
     lc_co g1 ->
     lc_co g2 ->
     Value v ->
     head_reduction G (a_Conv  ( (a_Conv v g1) )  g2) (a_Conv v  ( (g_Trans g1 g2) ) )
 | An_Push : forall (G:context) (v:tm) (g:co) (rho:relflag) (b b':tm) (g':co) (A1 B1 A2 B2:tm),
     Value v ->
     AnnDefEq G  (dom  G )  g (a_Pi rho A1 B1) (a_Pi rho A2 B2) ->
      ( b'  =  (a_Conv b (g_Sym  ( (g_PiFst g) ) )) )  ->
      ( g'  =  (g_PiSnd g (g_Refl2 b' b  ( (g_PiFst g) ) )) )  ->
     head_reduction G (a_App  ( (a_Conv v g) )  rho b) (a_Conv  ( (a_App v rho b') )  g')
 | An_CPush : forall (G:context) (v:tm) (g g1 g1' g':co) (phi1:constraint) (A1:tm) (phi2:constraint) (A2:tm),
     Value v ->
     AnnDefEq G  (dom  G )  g (a_CPi phi1 A1) (a_CPi phi2 A2) ->
      ( g1'  =  (g_Cast g1 (g_Sym  ( (g_CPiFst g) ) )) )  ->
      ( g'  =  (g_CPiSnd g g1' g1) )  ->
     head_reduction G (a_CApp  ( (a_Conv v g) )  g1) (a_Conv  ( (a_CApp v g1') )  g').

Hint Constructors Path CoercedValue Value value_type DataTy consistent RhoCheck erased_tm Par MultiPar joins Beta reduction_in_one reduction PropWff Typing Iso DefEq Ctx Sig AnnPropWff AnnTyping AnnIso AnnDefEq AnnCtx AnnSig head_reduction lc_co lc_brs lc_tm lc_constraint lc_sort lc_sig_sort. *)
Require Export FcEtt.ett_ind.
(* FcEtt.ett_ind:
Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Export FcEtt.fset_facts.
Require Export FcEtt.ett_inf.
Require Export FcEtt.tactics.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma tm_subst_tm_tm_var : forall a x, tm_subst_tm_tm a x (a_Var_f x) = a.

Lemma co_subst_co_co_var : forall a x, co_subst_co_co a x (g_Var_f x) = a.

Lemma tm_subst_tm_tm_var_neq : forall a x y, x <> y ->
    tm_subst_tm_tm a y (a_Var_f x) = (a_Var_f x).

Lemma co_subst_co_co_var_neq : forall a x y, x <> y ->
    co_subst_co_co a y (g_Var_f x) = (g_Var_f x).

Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm_var : subst_open_var.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co_var : open_subst_var.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co_var : open_subst_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_tm : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm : subst_open.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm : open_subst.

Ltac apply_lc_exists x :=
  pick fresh x;
  ( apply lc_a_Abs_exists      with (x1 := x)
  || apply lc_a_Pi_exists       with (x1 := x)
  || apply lc_a_CPi_exists      with (c1 := x)
  || apply lc_a_CAbs_exists     with (c1 := x)
  || apply lc_a_UAbs_exists     with (x1:= x)
  || apply lc_a_UCAbs_exists    with (c1 := x)
  || apply lc_g_PiCong_exists   with (x1 := x)
  || apply lc_g_AbsCong_exists  with (x1 := x)
  || apply lc_g_CPiCong_exists  with (c1 := x)
  || apply lc_g_CAbsCong_exists with (c1 := x)
  || fail "invalid case for apply_lc_exists" );
  eauto 2.

Ltac lc_solve_binds :=
  match goal with
  
  | [ H : binds ?x ?s nil |- _ ] => inversion H; clear H
  
  | [ H : binds _ ?s ([(_,_)] ++ _) |- _ ?s] =>
      destruct (binds_cons_1 _ _ _ _ _ _ H); basic_solve
  
  | [ b : binds ?x _ ?G, H : ∀ (x' : atom) _, binds x' _ ?G → _ |- _] =>
      by apply H in b; inversion b; try done;
          match goal with
            | [H' : lc_constraint _ |- _] => inversion H' ; clear H'
            | [H' : lc_tm         _ |- _] => inversion H' ; clear H'
          end
  end.

Ltac lc_inversion c :=
  repeat match goal with
    
  | [ H : forall x, (x `in` ?L -> False) -> lc_tm _ /\ _ |- _ ] =>
    destruct (H c ltac:(auto)); split_hyp; clear H
  
  | [ H : lc_constraint (_ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Abs _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_App _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Pi _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Conv _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CPi _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UCAbs _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CApp _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Case _ _) |- _ ] =>
    inversion H; clear H
 end.

Ltac apply_lc_body :=
  match goal with
  | |- lc_tm (open_tm_wrt_tm ?a ?b) => eapply lc_body_tm_wrt_tm; auto
  | |- lc_tm (open_tm_wrt_co ?a ?b) => eapply lc_body_tm_wrt_co; auto
  end.

Lemma co_subst_co_tm_lc_tm_inverse
  : ∀ (g1 : co) (c1 : covar),
      lc_co g1 ->
      (forall A,
          lc_tm A -> forall XX, A = (co_subst_co_tm g1 c1 XX) -> lc_tm XX)
      /\
      (forall b1,
          lc_brs b1 -> forall XX, b1 = (co_subst_co_brs g1 c1 XX) -> lc_brs XX)
      /\
      (forall co,
          lc_co co -> forall XX, co = (co_subst_co_co g1 c1 XX) -> lc_co XX)
      /\
      (forall phi,
          lc_constraint phi -> forall XX, phi = (co_subst_co_constraint g1 c1 XX) ->
          lc_constraint XX).

Ltac invert_syntactic_equality :=
  repeat match goal with
  | [ H : a_Var_f _  = a_Var_f _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Abs _ _ = a_Abs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UAbs _ _ = a_UAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Pi _ _ _ = a_Pi _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_App _ _ _ = a_App _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Fam _  = a_Fam _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Const _  = a_Const _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Conv _ _ = a_Conv _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UCAbs _ = a_UCAbs _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CAbs + _ = a_CAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CApp _ _  = a_CApp _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CPi _ _ = a_CPi _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : Eq _ _ _ = Eq _ _ _ |- _ ] =>
    inversion H; subst; clear H
  end.

Ltac ann_invert_clear :=
  match goal with
  | H : AnnTyping _ a_Star _ |- _ => inversion H; subst; clear H
  | H : AnnTyping _ (_ _) _ |- _ =>  inversion H; subst; clear H
  | H : AnnPropWff _ _ |- _ => inversion H; subst; clear H
  | H : AnnIso _ _ (_ _) _ _ |- _ => inversion H; subst; clear H
  | H : AnnDefEq _ _ (_ _) _ _  |- _ => inversion H; subst; clear H
  | H : AnnCtx ([(_,_)] ++ _) |- _ => inversion H; subst; clear H
  | H : AnnCtx (_ :: _) |- _ => inversion H; subst; clear H
  end.

Lemma lc_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x0)).

Lemma fv_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    x0 `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0)).

Scheme typing_ind' := Induction for Typing Sort Prop
   with wff_ind'   := Induction for PropWff Sort Prop
   with iso_ind'   := Induction for Iso Sort Prop
   with defeq_ind' := Induction for DefEq Sort Prop
   with ctx_ind'   := Induction for Ctx Sort Prop.

Combined Scheme typing_wff_iso_defeq_mutual from typing_ind', wff_ind', iso_ind', defeq_ind', ctx_ind'.

Scheme ann_typing_ind' := Induction for AnnTyping Sort Prop
   with ann_wff_ind'   := Induction for AnnPropWff Sort Prop
   with ann_iso_ind'   := Induction for AnnIso Sort Prop
   with ann_defeq_ind' := Induction for AnnDefEq Sort Prop
   with ann_ctx_ind'   := Induction for AnnCtx Sort Prop.

Combined Scheme ann_typing_wff_iso_defeq_mutual
from ann_typing_ind', ann_wff_ind', ann_iso_ind',
     ann_defeq_ind', ann_ctx_ind'.

Scheme CoercedValue_ind' := Induction for CoercedValue Sort Prop
                            with Value_ind' := Induction for Value Sort Prop.
Combined Scheme CoercedValue_Value_mutual from CoercedValue_ind', Value_ind'.

Ltac ext_induction CON :=
    apply typing_wff_iso_defeq_mutual;
    [ pose CON :=  E_Star       |
      pose CON :=  E_Var        |
      pose CON :=  E_Pi         |
      pose CON :=  E_Abs        |
      pose CON :=  E_App        |
      pose CON :=  E_IApp       |
      pose CON :=  E_Conv       |
      pose CON :=  E_CPi        |
      pose CON :=  E_CAbs       |
      pose CON :=  E_CApp       |
      pose CON :=  E_Const      |
      pose CON :=  E_Fam        |
      pose CON :=  E_Wff        |
      pose CON :=  E_PropCong   |
      pose CON :=  E_IsoConv    |
      pose CON :=  E_CPiFst     |
      pose CON :=  E_Assn       |
      pose CON :=  E_Refl       |
      pose CON :=  E_Sym        |
      pose CON :=  E_Trans      |
      pose CON :=  E_Beta       |
      pose CON :=  E_PiCong     |
      pose CON :=  E_AbsCong    |
      pose CON :=  E_AppCong    |
      pose CON :=  E_IAppCong   |
      pose CON :=  E_PiFst      |
      pose CON :=  E_PiSnd      |
      pose CON :=  E_CPiCong    |
      pose CON :=  E_CAbsCong   |
      pose CON :=  E_CAppCong   |
      pose CON :=  E_CPiSnd     |
      pose CON :=  E_Cast       |
      pose CON :=  E_EqConv     |
      pose CON :=  E_IsoSnd     |
      pose CON :=  E_EtaRel     |
      pose CON :=  E_EtaIrrel   |
      pose CON :=  E_EtaC       |

      pose CON :=  E_Empty      |
      pose CON :=  E_ConsTm     |
      pose CON :=  E_ConsCo     ].

Ltac ann_induction CON :=
    apply ann_typing_wff_iso_defeq_mutual;
    [ pose CON :=  An_Star       |
      pose CON :=  An_Var        |
      pose CON :=  An_Pi         |
      pose CON :=  An_Abs        |
      pose CON :=  An_App        |
      pose CON :=  An_Conv       |
      pose CON :=  An_CPi        |
      pose CON :=  An_CAbs       |
      pose CON :=  An_CApp       |
      pose CON :=  An_Const      |
      pose CON :=  An_Fam        |
      pose CON :=  An_Wff        |
      pose CON :=  An_PropCong   |
      pose CON :=  An_CPiFst     |
      pose CON :=  An_IsoSym     |
      pose CON :=  An_IsoConv    |
      pose CON :=  An_Assn       |
      pose CON :=  An_Refl       |
      pose CON :=  An_EraseEq      |
      pose CON :=  An_Sym        |
      pose CON :=  An_Trans      |
      pose CON :=  An_Beta       |
      pose CON :=  An_PiCong     |
      pose CON :=  An_AbsCong    |
      pose CON :=  An_AppCong    |
      pose CON :=  An_PiFst      |
      pose CON :=  An_PiSnd      |
      pose CON :=  An_CPiCong    |
      pose CON :=  An_CAbsCong   |
      pose CON :=  An_CAppCong   |
      pose CON :=  An_CPiSnd     |
      pose CON :=  An_Cast       |
      pose CON :=  An_IsoSnd     |
      pose CON :=  An_Eta        |
      pose CON :=  An_EtaC       |

      pose CON :=  An_Empty      |
      pose CON :=  An_ConsTm     |
      pose CON :=  An_ConsCo     ].

Ltac ensure_case C :=
  match goal with [ CON := C : ?A |- _ ] => idtac end.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let C1 := gather_atoms_with (fun x : context => dom x) in
  let D1 := gather_atoms_with (fun x => fv_tm_tm_tm x) in
  let D2 := gather_atoms_with (fun x => fv_tm_tm_co x) in
  let D3 := gather_atoms_with (fun x => fv_tm_tm_constraint x) in
  let D4 := gather_atoms_with (fun x => fv_tm_tm_sort x) in
  let D5 := gather_atoms_with (fun x => fv_tm_tm_brs x) in
  let D6 := gather_atoms_with (fun x => fv_co_co_tm x) in
  let D7 := gather_atoms_with (fun x => fv_co_co_co x) in
  let D8 := gather_atoms_with (fun x => fv_co_co_constraint x) in
  let D9 := gather_atoms_with (fun x => fv_co_co_sort x) in
  let D10 := gather_atoms_with (fun x => fv_co_co_brs x) in
  constr:(A \u B \u C1 \u D1 \u D2 \u D3 \u D4 \u D5 \u D6 \u D7 \u D8 \u D9 \u D10).

Ltac rewrite_body :=
  match goal with
  | [ e : ∀ x : atom, (x `in` ?L → False)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
     rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ c : atom, (c `notin` ?L)
      → open_tm_wrt_co _ (g_Var_f c) =
        open_tm_wrt_co _ (g_Cast (g_Var_f c) (g_Sym _)) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `in` ?L → False) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `notin` ?L) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto

  end.

Ltac lc_solve :=
  let c := fresh in
  try lc_solve_binds;
  try apply_lc_exists c;
  lc_inversion c; auto;
  try rewrite_body;
  try apply_lc_body;
  eauto with lc.

Hint Resolve lc_a_Pi_exists
     lc_a_CPi_exists lc_a_Abs_exists lc_a_CAbs_exists lc_a_UAbs_exists.

Hint Resolve lc_body_tm_wrt_tm lc_body_tm_wrt_co. 

Lemma rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)) ->
    RhoCheck rho x0 (open_tm_wrt_tm a (a_Var_f x0)).

Lemma eta_swap: forall x y a' b rho,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b rho (a_Var_f x) ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b rho (a_Var_f y).

Lemma eta_swap_irrel: forall x y a' b,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b Irrel a_Bullet ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b Irrel a_Bullet.

Lemma eta_swap_c: forall x y a' b,
    x `notin` fv_co_co_tm a' \u fv_co_co_tm b ->
    open_tm_wrt_co a' (g_Var_f x) = a_CApp b g_Triv ->
    open_tm_wrt_co a' (g_Var_f y) = a_CApp b g_Triv.

Ltac auto_rew_env :=
  multimatch goal with
    | [ |- context [([(?x, ?T)] ++ ?G1 ++ ?G2 ++ ?G3)] ] => rewrite_env (((x ~ (T)) ++ G1) ++ G2 ++ G3)
  end.

Ltac E_pick_fresh x :=
  match goal with
    | [ |- Typing _ ?shape _ ] =>
      let v := match shape with
            | a_Pi _ _ _ => E_Pi
            | a_UAbs _ _ => E_Abs
            | a_CPi _ _  => E_CPi
            | a_CAbs _ _ => E_CAbs
            | a_UCAbs _  => E_CAbs
           end
      in pick fresh x and apply v
    | [ |- DefEq _ _ ?shape ?s2 _ ] =>
      let v := match shape with
               | a_Pi _ _ _ => E_PiCong
               | a_UAbs Rel _ => match s2 with
                                | a_UAbs _ _ => E_AbsCong
                                | _ => E_EtaRel
                                end
               | a_UAbs Irrel _ => match s2 with 
                                | a_UAbs _ _ =>  E_AbsCong
                                | _ => E_EtaIrrel
                                end
               | a_CPi _ _  => E_CPiCong
               | a_CAbs _ _ => E_CAbsCong
               | a_UCAbs _  => match s2 with 
                                | a_UCAbs _ =>  E_CAbsCong
                                | _ => E_EtaC
                                end
               end
      in pick fresh x and apply v
  end.

Ltac Par_pick_fresh x :=
  match goal with
    | [ |- Par _ _ ?shape ?s2 ] =>
      let v := match shape with
            | a_Pi _ _ _ => Par_Pi
            | a_UAbs Rel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_Eta
                                end
            | a_UAbs Irrel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_EtaIrrel
                                end
            | a_UAbs _ _ =>  Par_Abs
            | a_CPi _ _  => Par_CPi
            | a_CAbs _ _ => Par_CAbs
            | a_UCAbs _  => match s2 with
                                | a_UCAbs _ => Par_CAbs
                                | _ => Par_EtaC
                                end
           end
      in pick fresh x and apply v
  end.

Ltac An_pick_fresh x :=
  let shape := match goal with
                 | [ |- AnnTyping _   ?shape _    ] => shape
                 | [ |- AnnDefEq  _ _ ?shape _  _ ] => shape
               end in
  let ctor  := match shape with
    | a_Pi     _ _ _ => An_Pi
    | a_Abs    _ _ _ => An_Abs
    | a_CPi      _ _ => An_CPi
    | a_CAbs     _ _ => An_CAbs
    | g_PiCong _ _ _ => An_PiCong
    | g_AbsCong _ _ _  => An_AbsCong
    | g_CPiCong  _ _   => An_CPiCong
    | g_CAbsCong _ _ _ => An_CAbsCong
    | g_Eta _          => An_Eta
               end in
  pick fresh x and apply ctor.

Ltac RhoCheck_inversion y :=
  match goal with
  | [ K : ∀ x : atom, x `notin` ?L → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  | [ K : ∀ x : atom, (x `in` ?L -> False) → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  end.

Lemma lc_open_switch_co :
  forall g t, lc_co g ->
  lc_tm (open_tm_wrt_co t g_Triv) ->
  lc_tm (open_tm_wrt_co t g).

Hint Resolve lc_open_switch_co.

Lemma tm_subst_cast : forall a x g,
    tm_subst_tm_tm a x (a_Conv (a_Var_f x) g) = a_Conv a (tm_subst_tm_co a x g).

Hint Rewrite tm_subst_cast. *)
Require Export FcEtt.ext_wf.
(* FcEtt.ext_wf:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Import FcEtt.imports.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.
Require Import FcEtt.tactics.

Require Import FcEtt.utils.

Require Import FcEtt.sigs.
Require Import FcEtt.toplevel.

Lemma Path_lc : forall T a, Path T a -> lc_tm a.

Hint Resolve Path_lc : lc.

Lemma DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.
Hint Resolve DataTy_lc : lc.

Lemma CoercedValue_Value_lc_mutual: (forall A, CoercedValue A -> lc_tm A) /\
                                    (forall A, Value A -> lc_tm A).

Lemma Value_lc : forall A, Value A -> lc_tm A.
Lemma CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

Hint Resolve Value_lc CoercedValue_lc : lc.

Lemma ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Definition Typing_Ctx  := first  ctx_wff_mutual.
Definition PropWff_Ctx := second ctx_wff_mutual.
Definition Iso_Ctx     := third  ctx_wff_mutual.
Definition DefEq_Ctx   := fourth ctx_wff_mutual.

Hint Resolve Typing_Ctx PropWff_Ctx Iso_Ctx DefEq_Ctx.

Lemma Ctx_uniq : forall G, Ctx G -> uniq G.

Hint Resolve Ctx_uniq.

Lemma lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi, PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T, DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Definition Typing_lc  := first lc_mutual.
Definition PropWff_lc := second lc_mutual.
Definition Iso_lc     := third lc_mutual.
Definition DefEq_lc   := fourth lc_mutual.
Definition Ctx_lc     := fifth lc_mutual.

Lemma Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Lemma Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Lemma Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Lemma Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.
Lemma DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.

Lemma DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Lemma DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Hint Resolve Typing_lc1 Typing_lc2 Iso_lc1 Iso_lc2 DefEq_lc1 DefEq_lc2 DefEq_lc3 Ctx_lc : lc.

Lemma Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s. *)
Require Export FcEtt.ett_par.
(* FcEtt.ett_par:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Import FcEtt.utils.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ext_context_fv.

Require Import FcEtt.ext_wf.
Import ext_wf.

Require Import FcEtt.erase_syntax.

Require Export FcEtt.toplevel.

Require Export FcEtt.ett_value.

Inductive multipar S D ( a : tm) : tm -> Prop :=
| mp_refl : multipar S D a a
| mp_step : forall b c, Par S D a b -> multipar S D b c -> multipar S D a c.

Hint Constructors multipar.

Ltac erased_pick_fresh x :=
  match goal with
    [ |- erased_tm ?s ] =>
    let v := match s with
             | a_UAbs _ _  => erased_a_Abs
             | a_Pi _ _ _  => erased_a_Pi
             | a_CPi _ _   => erased_a_CPi
             | a_UCAbs _   => erased_a_CAbs
             end
    in pick fresh x and apply v
  end.

Ltac erased_inversion :=
  repeat match goal with
  | [H : erased_tm (a_UAbs _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_App _ _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_Pi _ _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_CPi _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_UCAbs _ ) |- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_CApp _ _)|- _ ] =>
    inversion H; subst; clear H
end.

Ltac erased_case :=
  let x := fresh in
  let h0 := fresh in
  erased_pick_fresh x; eauto using lc_erase;
  match goal with
    [ H : forall x, erased_tm (erase (open_tm_wrt_tm ?b (a_Var_f x))) |- _ ] =>
    move: (H x) => h0; rewrite <- open_tm_erase_tm in h0; eauto
  | [ H : ∀ c, erased_tm (erase (open_tm_wrt_co ?b (g_Var_f c))) |- _ ] =>
    move: (H x) => h0; rewrite <- open_co_erase_tm2 with (g := (g_Var_f x)) in h0; auto
  end.

Inductive erased_sort : sort -> Prop :=
| erased_Tm : forall a, erased_tm a -> erased_sort (Tm a)
| erased_Co : forall a b A, erased_tm a -> erased_tm b -> erased_tm A -> erased_sort (Co (Eq a b A)).

Definition erased_context : context -> Prop :=
  Forall (fun p => match p with (a,s) => erased_sort s end).

Definition joins S D a b := exists c, erased_context S /\ erased_tm a /\ erased_tm b /\
                               multipar S D a c /\ multipar S D b c.

Lemma erased_lc : forall a, erased_tm a -> lc_tm a.

Hint Resolve erased_lc : lc.

Lemma subst_tm_erased : forall x b, erased_tm b -> forall a , erased_tm a -> erased_tm (tm_subst_tm_tm b x a).

Lemma erased_a_Abs_exists : ∀  (rho : relflag) (a : tm) x,
                x `notin` fv_tm_tm_tm a
              → erased_tm (open_tm_wrt_tm a (a_Var_f x))
              → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
              → erased_tm (a_UAbs rho a).

Lemma erased_a_Abs_inversion : forall rho a, 
     erased_tm (a_UAbs rho a) -> forall x, x `notin` fv_tm_tm_tm a 
  -> erased_tm (open_tm_wrt_tm a (a_Var_f x)) /\ RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)).

Lemma subst_co_erased : forall c g a , lc_co g -> erased_tm a -> erased_tm (co_subst_co_tm g c a).

Hint Resolve subst_tm_erased subst_co_erased : erased.

Lemma erased_a_CAbs_inversion : forall b, 
     erased_tm (a_UCAbs b) -> forall c, c `notin` fv_co_co_tm b 
  -> erased_tm (open_tm_wrt_co b (g_Var_f c)).

Lemma Par_lc1 : forall G D a a' , Par G D a a' -> lc_tm a.

Ltac lc_toplevel_inversion :=
  match goal with
  | [ b : binds ?F _ toplevel |- _ ] =>
    apply Toplevel_lc in b; inversion b; auto
end.

Lemma Par_lc2 : forall G D a a' , Par G D a a' -> lc_tm a'.

Hint Resolve Par_lc1 Par_lc2 : lc.

Lemma typing_erased_mutual:
    (forall G b A, Typing G b A -> erased_tm b) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall A B T, phi = Eq A B T -> erased_tm A /\ erased_tm B /\ erased_tm T) /\
     (forall G0 D p1 p2 (H : Iso G0 D p1 p2), True ) /\
     (forall G0 D A B T (H : DefEq G0 D A B T), True) /\
     (forall G0 (H : Ctx G0), True).

Lemma Typing_erased: forall G b A, Typing G b A -> erased_tm b.

Hint Resolve Typing_erased : erased.

Lemma typing_erased_type_mutual:
    (forall G b A, Typing G b A -> erased_tm A) /\
    (forall G0 phi (H : PropWff G0 phi), True) /\
     (forall G0 D p1 p2 (H : Iso G0 D p1 p2), True ) /\
     (forall G0 D A B T (H : DefEq G0 D A B T), True) /\
     (forall G0 (H : Ctx G0), erased_context G0).

Lemma Typing_erased_type : forall G b A, Typing G b A -> erased_tm A.

Hint Resolve Typing_erased_type : erased.

Lemma toplevel_erased1 : forall F a A, binds F (Ax a A) toplevel -> erased_tm a.
Lemma toplevel_erased2 : forall F a A, binds F (Ax a A) toplevel -> erased_tm A.

Hint Resolve toplevel_erased1 toplevel_erased2 : erased.

Ltac erased_body x Ea :=
    match goal with
     | [ H4 : ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_tm ?a (a_Var_f x))
                         |- _ ] =>
      move: (H4 x ltac:(auto)) => Ea; clear H4
     | [ H4 : ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_co ?a (g_Var_f x))
                         |- _ ] =>
      move: (H4 x ltac:(auto)) => Ea; clear H4
    end.

Ltac eta_eq y EQ :=
   match goal with
     | [ H : ∀ x : atom, x `notin` ?L → open_tm_wrt_tm ?a (a_Var_f x) =
                           a_App ?b ?rho _ |- _ ] =>
        move: (H y ltac:(auto)) =>  EQ
end.

Lemma Par_fv_preservation: forall G D x a b, Par G D a b ->
                                        x `notin` fv_tm_tm_tm a ->
                                        x `notin` fv_tm_tm_tm b.
Proof.
  intros.
  induction H; eauto 2; simpl.
  all: simpl in H0.
  all: try solve [move => h0; apply AtomSetFacts.union_iff in h0; case: h0 => h0; eauto; apply IHreduction_in_one; auto].
  all: try auto.
  - simpl in *.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_tm a' b') => h0.
    apply fv_tm_tm_tm_open_tm_wrt_tm_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec_fast.
    fsetdec_fast.
    auto.
  - rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper.
    fsetdec.
  - have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a' g_Triv) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec.
    auto.
  - pick fresh x0.
    assert (Fl : x0 `notin` L). auto.
    assert (Fa : x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0))).
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper. auto.
    move: (H1 x0 Fl Fa) => h0.
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto. 
  - pick fresh x0.
    have na': x `notin` fv_tm_tm_tm A'. eauto.
    have nb: x `notin` fv_tm_tm_tm (open_tm_wrt_tm B (a_Var_f x0)).
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper. eauto.
    have nob': x `notin` fv_tm_tm_tm (open_tm_wrt_tm B' (a_Var_f x0)). eauto.
    have nb': x `notin` fv_tm_tm_tm B'.
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto.
    eauto.
  - pick_fresh c0.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have K:= H1 c0 ltac:(auto) h0.
    move => h1.
    apply K. auto.
    apply fv_tm_tm_tm_open_tm_wrt_co_lower; auto.
  - pick fresh c0 for L.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have h2: x `notin` fv_tm_tm_tm (open_tm_wrt_co a' (g_Var_f c0)). eauto.
    move: (fv_tm_tm_tm_open_tm_wrt_co_lower a' (g_Var_f c0)) => h3.
    have h4: x `notin` fv_tm_tm_tm a'. fsetdec.

    move => h1.
    apply AtomSetFacts.union_iff in h1.
    case: h1 => h1; eauto.
    apply AtomSetFacts.union_iff in h1.

Lemma Par_fv_co_preservation: forall G D x a b, Par G D a b ->
                                        x `notin` fv_co_co_tm a ->
                                        x `notin` fv_co_co_tm b.
Proof.
  intros.
  induction H; eauto 2; simpl.
  all: simpl in H0.
  all: try solve [move => h0; apply AtomSetFacts.union_iff in h0; case: h0 => h0; eauto; apply IHreduction_in_one; auto].
  all: try auto.
  - simpl in *.
    have: x `notin` fv_co_co_tm (open_tm_wrt_tm a' b') => h0.
    apply fv_co_co_tm_open_tm_wrt_tm_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec_fast.
    fsetdec_fast.
    auto.
  - rewrite fv_co_co_tm_open_tm_wrt_tm_upper.
    fsetdec.
  - have: x `notin` fv_co_co_tm (open_tm_wrt_co a' g_Triv) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec.
    auto.
  - pick fresh x0.
    assert (Fl : x0 `notin` L). auto.
    assert (Fa : x `notin` fv_co_co_tm (open_tm_wrt_tm a (a_Var_f x0))).
    rewrite fv_co_co_tm_open_tm_wrt_tm_upper. auto.
    move: (H1 x0 Fl Fa) => h0.
    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto. 
  - pick fresh x0.
    have na': x `notin` fv_co_co_tm A'. eauto.
    have nb: x `notin` fv_co_co_tm (open_tm_wrt_tm B (a_Var_f x0)).
    rewrite fv_co_co_tm_open_tm_wrt_tm_upper. eauto.
    have nob': x `notin` fv_co_co_tm (open_tm_wrt_tm B' (a_Var_f x0)). eauto.
    have nb': x `notin` fv_co_co_tm B'.
    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto.
    eauto.
  - pick_fresh c0.
    have: x `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have K:= H1 c0 ltac:(auto) h0.
    move => h1.
    apply K. auto.
    apply fv_co_co_tm_open_tm_wrt_co_lower; auto.
  - pick fresh c0.
    have: x `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0. assert (Q: c0 `notin` singleton x). fsetdec. clear Fr.
    fsetdec.
    have h2: x `notin` fv_co_co_tm (open_tm_wrt_co a' (g_Var_f c0)). eauto.
    move: (fv_co_co_tm_open_tm_wrt_co_lower a' (g_Var_f c0)) => h3.
    have h4: x `notin` fv_co_co_tm a'. fsetdec.
    move => h1.
    apply AtomSetFacts.union_iff in h1.
    case: h1 => h1; eauto.
    apply AtomSetFacts.union_iff in h1.

Lemma Par_erased_tm : forall G D a a', Par G D a a' -> erased_tm a -> erased_tm a'.

Hint Resolve Par_erased_tm : erased. 

Lemma subst1 : forall b S D a a' x, Par S D a a' -> erased_tm b ->
                           Par S D (tm_subst_tm_tm a x b) (tm_subst_tm_tm a' x b).

Lemma open1 : forall b S D a a' L, Par S D a a'
  -> (forall x, x `notin` L -> erased_tm (open_tm_wrt_tm b (a_Var_f x)))
  -> Par S D (open_tm_wrt_tm b a) (open_tm_wrt_tm b a').

Lemma subst2 : forall S D b x, lc_tm b ->
  forall a a', Par S D a a' -> Par S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b x a').

Lemma subst3 : forall S D b b' x,
    Par S D b b' ->
    forall a a', erased_tm a -> Par S D a a' ->
    Par S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b' x a').

Lemma subst4 : forall S D b x, lc_co b ->
    forall a a', Par S D a a' ->
    Par S D (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Lemma multipar_subst3 : forall S D b b' x, erased_tm b ->
    multipar S D b b' ->
    forall a a', erased_tm a -> multipar S D a a' ->
    multipar S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b' x a').

Lemma multipar_subst4 : forall S D b x, lc_co b ->
    forall a a', multipar S D a a' ->
    multipar S D (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Lemma erased_tm_open_tm_wrt_tm: forall a x, erased_tm a -> erased_tm (open_tm_wrt_tm a (a_Var_f x)).

Hint Resolve erased_tm_open_tm_wrt_tm : erased.

Lemma Par_Pi_exists: ∀ x (G : context) D rho (A B A' B' : tm),
    x `notin` fv_tm_tm_tm B -> Par G D A A'
    → Par G D (open_tm_wrt_tm B (a_Var_f x)) B'
    → Par G D (a_Pi rho A B) (a_Pi rho A' (close_tm_wrt_tm x B')).

Lemma Par_CPi_exists:  ∀ c (G : context) D (A B a A' B' a' T T': tm),
       c `notin` fv_co_co_tm a -> Par G D A A'
       → Par G D B B' -> Par G D T T'
         → Par G D (open_tm_wrt_co a (g_Var_f c)) (a')
         → Par G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') (close_tm_wrt_co c a')).

Lemma Par_Abs_exists: ∀ x (G : context) D rho (a a' : tm),
    x `notin` fv_tm_tm_tm a
    → Par G D (open_tm_wrt_tm a (a_Var_f x)) a'
    → Par G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma Par_CAbs_exists: forall c (G : context) D (a a': tm),
       c `notin` fv_co_co_tm a
       -> Par G D (open_tm_wrt_co a (g_Var_f c)) a'
       → Par G D (a_UCAbs a) (a_UCAbs (close_tm_wrt_co c a')).

Lemma Par_EtaRel_exists : forall (G: context) D a b b' x,
   x `notin` union (fv_tm_tm_tm a) (fv_tm_tm_tm b) ->
   Par G D b b' ->
   (open_tm_wrt_tm a (a_Var_f x)) = a_App b Rel (a_Var_f x) ->
   Par G D (a_UAbs Rel a) b'.

Lemma Par_EtaRel_close : forall (G: context) D b b' x,
   x `notin` fv_tm_tm_tm b ->
   Par G D b b' ->
   Par G D (a_UAbs Rel (close_tm_wrt_tm x (a_App b Rel (a_Var_f x)))) b'.

Lemma Par_open_tm_wrt_co_preservation: forall G D B1 B2 c, Par G D (open_tm_wrt_co B1 (g_Var_f c)) B2 -> exists B', B2 = open_tm_wrt_co B' (g_Var_f c) /\ Par G D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B' (g_Var_f c)).

Lemma Par_open_tm_wrt_tm_preservation: forall G D B1 B2 x, Par G D (open_tm_wrt_tm B1 (a_Var_f x)) B2 -> exists B', B2 = open_tm_wrt_tm B' (a_Var_f x) /\ Par G D (open_tm_wrt_tm B1 (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x)).

Lemma multipar_Pi_exists: ∀ x (G : context) D rho (A B A' B' : tm),
       lc_tm (a_Pi rho A B) -> x `notin` fv_tm_tm_tm B -> multipar G D A A'
       → multipar G D (open_tm_wrt_tm B (a_Var_f x)) B'
       → multipar G D (a_Pi rho A B) (a_Pi rho A' (close_tm_wrt_tm x B')).

Lemma multipar_Pi_A_proj: ∀ (G : context) D rho (A B A' B' : tm),
    lc_tm A -> multipar G D (a_Pi rho A B) (a_Pi rho A' B')
    -> multipar G D A A'.

Lemma multipar_Pi_B_proj: ∀ (G : context) D rho (A B A' B' : tm),
    multipar G D (a_Pi rho A B) (a_Pi rho A' B')
    → (exists L, forall x, x `notin` L -> multipar G D (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x))).

Lemma multipar_CPi_exists:  ∀ c (G : context) D (A B a T A' B' a' T': tm),
       lc_tm (a_CPi (Eq A B T) a) -> c `notin` fv_co_co_tm a -> multipar G D A A'
       → multipar G D B B' -> multipar G D T T'
         → multipar G D (open_tm_wrt_co a (g_Var_f c)) a'
         → multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') (close_tm_wrt_co c a')).

Lemma multipar_CPi_B_proj:  ∀ (G : context) D (A B a A' B' a' T T': tm),
    multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') a')
  → (exists L, forall c, c `notin` L -> multipar G D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c))).

Lemma multipar_CPi_phi_proj:  ∀ (G : context) D (A B a A' B' a' T T': tm),
    multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') a')
    -> (multipar G D A A'/\ multipar G D B B' /\ multipar G D T T').

Lemma multipar_Abs_exists: ∀ x (G : context) D rho (a a' : tm),
       lc_tm (a_UAbs rho a) -> x `notin` fv_tm_tm_tm a
       → multipar G D (open_tm_wrt_tm a (a_Var_f x)) a'
       → multipar G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma multipar_CAbs_exists: forall c (G : context) D (a a': tm),
       lc_tm (a_UCAbs a) -> c `notin` fv_co_co_tm a
       -> multipar G D (open_tm_wrt_co a (g_Var_f c)) a'
       → multipar G D (a_UCAbs a) (a_UCAbs (close_tm_wrt_co c a')).

Lemma multipar_open_tm_wrt_co_preservation: forall G D B1 B2 c, multipar G D (open_tm_wrt_co B1 (g_Var_f c)) B2 -> exists B', B2 = open_tm_wrt_co B' (g_Var_f c) /\ multipar G D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B' (g_Var_f c)).

Lemma multipar_open_tm_wrt_tm_preservation: forall G D B1 B2 x, multipar G D (open_tm_wrt_tm B1 (a_Var_f x)) B2 -> exists B', B2 = open_tm_wrt_tm B' (a_Var_f x) /\ multipar G D (open_tm_wrt_tm B1 (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x)).

Lemma context_Par_irrelevance: forall G1 G2 D1 D2 a a',
                                             Par G1 D1 a a' -> Par G2 D2 a a'.

Lemma multipar_context_independent: forall G1 G2 D A B,  multipar G1 D A B -> multipar G2 D A B.

Lemma Par_weaken_available :
  forall G D a b, Par G D a b -> forall D', D [<=] D' -> Par G D' a b.

Lemma Par_respects_atoms:
  forall G D a b, Par G D a b -> forall D', D [=] D' -> Par G D' a b.

Lemma Par_availability_independence: forall G D1 D2 a b, Par G D1 a b -> Par G D2 a b.

Lemma Par_remove_available:
  forall G D a b, Par G D a b -> Par G (AtomSetImpl.inter D (dom G)) a b.

Lemma Par_weakening :
  forall G0 D a b, Par G0 D a b ->
  forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) ->  Par (F ++ E ++ G) D a b. *)
Require Export FcEtt.ett_inf_cs.
(* FcEtt.ett_inf_cs:
Require Import FcEtt.ett_inf.
Require Import FcEtt.imports.

Module Operators.

  Module Close.

    Record class1 (ssort : Type) (vartype : Type) :=  Class1 {close_ : vartype -> ssort -> ssort; close_rec_ : nat -> vartype -> ssort -> ssort}.

    Record class (ssort : Type) := Class {class_tm : class1 ssort tmvar; class_co : class1 ssort covar}.

    Arguments Class {ssort} class_tm class_co.
    Arguments Class1 {ssort vartype} close_ close_rec_.

  End Close.

  Module Open.

  End Open.

  Module Erase.

    Record class (ssort : Type) := Class {erase_ssort : ssort -> ssort}.

    Arguments Class {ssort} erase_ssort.

  End Erase.

  Module FV.

    Record class (ssort : Type) := Class {fv_tm : ssort -> atoms; fv_co : ssort -> atoms}.

    Arguments Class {ssort} fv_tm fv_co.

  End FV.

  Structure type := Pack {stxsort : Type; class_close : Close.class stxsort; class_Erase : Erase.class stxsort; class_Fv : FV.class stxsort}.

  Definition close_tm' (e : type) : tmvar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class (Close.Class1 c _) _) _ _ := e return tmvar -> stxsort e -> stxsort e in c.

  Definition close_tm_rec' (e : type) : nat -> tmvar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class (Close.Class1 _ c) _) _ _ := e return nat -> tmvar -> stxsort e -> stxsort e in c.

  Definition close_co' (e : type) : covar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class _ (Close.Class1 c _)) _ _ := e return covar -> stxsort e -> stxsort e in c.

  Definition close_co_rec' (e : type) : nat -> covar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class _ (Close.Class1 _ c)) _ _ := e return nat -> covar -> stxsort e -> stxsort e in c.

  Definition erase' (e : type) : stxsort e -> stxsort e :=
    let 'Pack _ _ (Erase.Class c) _ := e in c.

  Definition fv_tm' (e : type) : stxsort e -> atoms :=
    let 'Pack _ _ _ (FV.Class c _) := e in c.

  Definition fv_co' (e : type) : stxsort e -> atoms :=
    let 'Pack _ _ _ (FV.Class _ c) := e in c.

  Arguments close_tm' {e} s v : simpl nomatch.
  Arguments close_tm_rec' {e} k s v : simpl nomatch.
  Arguments close_co' {e} s v : simpl nomatch.
  Arguments close_co_rec' {e} k s v : simpl nomatch.
  Arguments erase' {e} s : simpl nomatch.
  Arguments fv_tm' {e} s : simpl nomatch.
  Arguments fv_co' {e} s : simpl nomatch.

  Module Theory.

    Notation close_tm := close_tm'.
    Notation close_tm_rec := close_tm_rec'.
    Notation close_co := close_co'.
    Notation close_co_rec := close_co_rec'.

    Notation erase := erase'.

    Notation fv_tm := fv_tm'.
    Notation fv_co := fv_co'.

  End Theory.

End Operators.

Export Operators.Theory.

Definition tm_Closecl         : Operators.Close.class tm         := Operators.Close.Class (Operators.Close.Class1 close_tm_wrt_tm close_tm_wrt_tm_rec)                 (Operators.Close.Class1 close_tm_wrt_co close_tm_wrt_co_rec).
Definition co_Closecl         : Operators.Close.class co         := Operators.Close.Class (Operators.Close.Class1 close_co_wrt_tm close_co_wrt_tm_rec)                 (Operators.Close.Class1 close_co_wrt_co close_co_wrt_co_rec).
Definition brs_Closecl        : Operators.Close.class brs        := Operators.Close.Class (Operators.Close.Class1 close_brs_wrt_tm close_brs_wrt_tm_rec)               (Operators.Close.Class1 close_brs_wrt_co close_brs_wrt_co_rec).
Definition constraint_Closecl : Operators.Close.class constraint := Operators.Close.Class (Operators.Close.Class1 close_constraint_wrt_tm close_constraint_wrt_tm_rec) (Operators.Close.Class1 close_constraint_wrt_co close_constraint_wrt_co_rec).

Definition erase_co (_ : co) := g_Triv.

Definition tm_Erasecl         : Operators.Erase.class tm         := Operators.Erase.Class erase_tm.
Definition co_Erasecl         : Operators.Erase.class co         := Operators.Erase.Class erase_co.
Definition brs_Erasecl        : Operators.Erase.class brs        := Operators.Erase.Class erase_brs.
Definition constraint_Erasecl : Operators.Erase.class constraint := Operators.Erase.Class erase_constraint.

Definition tm_FVcl         : Operators.FV.class tm         := Operators.FV.Class fv_tm_tm_tm         fv_co_co_tm.
Definition co_FVcl         : Operators.FV.class co         := Operators.FV.Class fv_tm_tm_co         fv_co_co_co.
Definition brs_FVcl        : Operators.FV.class brs        := Operators.FV.Class fv_tm_tm_brs        fv_co_co_brs.
Definition constraint_FVcl : Operators.FV.class constraint := Operators.FV.Class fv_tm_tm_constraint fv_co_co_constraint.

Canonical Structure tm_OpsTy         : Operators.type := Operators.Pack tm_Closecl         tm_Erasecl         tm_FVcl.
Canonical Structure co_OpsTy         : Operators.type := Operators.Pack co_Closecl         co_Erasecl         co_FVcl.
Canonical Structure brs_OpsTy        : Operators.type := Operators.Pack brs_Closecl        brs_Erasecl        brs_FVcl.
Canonical Structure constraint_OpsTy : Operators.type := Operators.Pack constraint_Closecl constraint_Erasecl constraint_FVcl.

Module Test.

End Test.

Module Rew.
  Definition r_erase_tm         : forall x, erase_tm x = erase x         := fun _ => eq_refl.
  Definition r_erase_co         : forall x, erase_co x = erase x         := fun _ => eq_refl.
  Definition r_erase_brs        : forall x, erase_brs x = erase x        := fun _ => eq_refl.
  Definition r_erase_constraint : forall x, erase_constraint x = erase x := fun _ => eq_refl.

  Definition r_close_tm_tm         : forall x t, close_tm_wrt_tm x t = close_tm x t         := fun _ _ => eq_refl.
  Definition r_close_tm_co         : forall x t, close_co_wrt_tm x t = close_tm x t         := fun _ _ => eq_refl.
  Definition r_close_tm_brs        : forall x t, close_brs_wrt_tm x t = close_tm x t        := fun _ _ => eq_refl.
  Definition r_close_tm_constraint : forall x t, close_constraint_wrt_tm x t = close_tm x t := fun _ _ => eq_refl.

  Definition r_close_co_tm         : forall x t, close_tm_wrt_co x t = close_co x t         := fun _ _ => eq_refl.
  Definition r_close_co_co         : forall x t, close_co_wrt_co x t = close_co x t         := fun _ _ => eq_refl.
  Definition r_close_co_brs        : forall x t, close_brs_wrt_co x t = close_co x t        := fun _ _ => eq_refl.
  Definition r_close_co_constraint : forall x t, close_constraint_wrt_co x t = close_co x t := fun _ _ => eq_refl.

  Module Exprt.
    Hint Rewrite -> r_erase_tm r_erase_co r_erase_brs r_erase_constraint : rewdb_cs.

    Ltac autorewcs :=
      rewrite ? r_erase_tm;
      rewrite ? r_erase_co;
      rewrite ? r_erase_brs;
      rewrite ? r_erase_constraint;

      rewrite ? r_close_tm_tm;
      rewrite ? r_close_tm_co;
      rewrite ? r_close_tm_brs;
      rewrite ? r_close_tm_constraint;

      rewrite ? r_close_co_tm;
      rewrite ? r_close_co_co;
      rewrite ? r_close_co_brs;
      rewrite ? r_close_co_constraint.

    Ltac autorewcshyp H :=
      rewrite ? r_erase_tm in H;
      rewrite ? r_erase_co in H;
      rewrite ? r_erase_brs in H;
      rewrite ? r_erase_constraint in H;

      rewrite ? r_close_tm_tm in H;
      rewrite ? r_close_tm_co in H;
      rewrite ? r_close_tm_brs in H;
      rewrite ? r_close_tm_constraint in H;

      rewrite ? r_close_co_tm in H;
      rewrite ? r_close_co_co in H;
      rewrite ? r_close_co_brs in H;
      rewrite ? r_close_co_constraint in H.
  End Exprt.
End Rew.

Export Rew.Exprt. *)

Require Import FcEtt.erase_syntax.
(* FcEtt.erase_syntax:
Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).

Lemma erase_dom : forall G, dom G = dom (erase_context G).

Lemma path_erase : forall T p, Path T p -> Path T (erase p).

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end. *)
Require Import FcEtt.fc_invert.
(* FcEtt.fc_invert:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.
Require Import FcEtt.fset_facts.

Require Import FcEtt.ett_ott.
Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.

Require Import FcEtt.erase_syntax.
Require Export Metalib.CoqEqDec.
Require Import Coq.Logic.Decidable.
Require Import Metalib.Metatheory.
Require Import FcEtt.fc_unique.

Require Import FcEtt.fc_wf.
Require Import FcEtt.toplevel.
Require Import FcEtt.fc_context_fv.

Module fc_invert (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig).
Import weak subst.

Module unique := fc_unique wf subst.
Import unique.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma AnnTyping_regularity :
  (forall G a A, AnnTyping G a A -> AnnTyping G A a_Star).

Lemma AnnPropWff_regularity :
  forall G A B A1, AnnPropWff G (Eq A B A1) -> exists B1 g,
      AnnTyping G A A1 /\ AnnTyping G B B1 /\ AnnDefEq G empty g A1 B1.

Lemma erase_pi : forall G AB0 rho A B S, erase AB0 = (a_Pi rho A B) -> AnnTyping G AB0 S ->
  exists A1 B0, erase AB0 = erase (a_Pi rho A1 B0) /\ erase A1 = A /\ erase B0 = B /\ AnnTyping G (a_Pi rho A1 B0) a_Star.

Lemma erase_cpi : forall AB0 A B G S,
    erase AB0 = (a_CPi A B) -> AnnTyping G AB0 S ->
    exists A1 B0, erase AB0 = erase (a_CPi A1 B0) /\ erase_constraint A1 = A /\ erase B0 = B
             /\ AnnTyping G (a_CPi A1 B0) a_Star.

Lemma erase_app_Rel :
  forall AB0 A B C G, erase AB0 = (a_App A Rel B) -> AnnTyping G AB0 C ->
  exists A1 B0 g D, erase AB0 = erase (a_App A1 Rel B0) /\ erase A1 = A /\ erase B0 = B /\
          AnnTyping G (a_App A1 Rel B0) D /\ AnnDefEq G (dom G) g C D.

Lemma erase_app_Irrel :
  forall AB0 A C G, erase AB0 = (a_App A Irrel a_Bullet) -> AnnTyping G AB0 C ->
  exists A1 B0 g D, erase AB0 = erase (a_App A1 Irrel B0) /\ erase A1 = A /\
          AnnTyping G (a_App A1 Irrel B0) D /\ AnnDefEq G (dom G) g C D.

Lemma erasure_compatible : forall G a A (H1 :AnnTyping G a A),
    forall b B (H2 : AnnTyping G b B)
      (E : erase a = erase b)
      (F : erase A = erase B),
    exists g1, AnnDefEq G (dom G) g1 a b.

Lemma AnnDefEqAnnIso_regularity :
  (forall G0 a A, AnnTyping G0 a A -> True ) /\
  (forall G0 phi,   AnnPropWff G0 phi -> True ) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 AnnPropWff G p1 /\ AnnPropWff G p2) /\
  (forall G D g A B,   AnnDefEq G D g A B ->
           exists C1 C2 g', AnnTyping G A C1 /\ AnnTyping G B C2 /\ AnnDefEq G (dom G) g' C1 C2) /\
  (forall G0, AnnCtx G0 -> True).

Definition  AnnDefEq_regularity :
    (forall G D g A B,   AnnDefEq G D g A B ->
                    exists C1 C2 g', AnnTyping G A C1 /\ AnnTyping G B C2
                                /\ AnnDefEq G (dom G) g' C1 C2) :=
  fourth AnnDefEqAnnIso_regularity.

Definition AnnIso_regularity :
  forall G D g phi1 phi2, AnnIso G D g phi1 phi2 ->
                     AnnPropWff G phi1 /\ AnnPropWff G phi2 :=
  third AnnDefEqAnnIso_regularity.

  Lemma An_Sym2
    : ∀ (G : context) (D : available_props) (g : co) (a b : tm),
      AnnDefEq G D g b a → AnnDefEq G D (g_Sym g) a b.

Lemma An_Trans2
     : ∀ (G : context) (D : available_props) (g1 g2 : co)
       (a b a1 : tm),
       AnnDefEq G D g1 a a1
       → AnnDefEq G D g2 a1 b
       → AnnDefEq G D (g_Trans g1 g2) a b .

Lemma erase_a_Const : forall G0 a0 A0 A1 T,
       erase a0 = a_Const T ->
       binds T (Cs A1) an_toplevel ->
       AnnTyping G0 a0 A0   ->
       exists g, AnnDefEq G0 (dom G0) g A0 A1.

Lemma erase_capp :
  forall AB0 C G, AnnTyping G AB0 C -> forall A, erase AB0 = (a_CApp A g_Triv) ->
  exists a1 g0 g D, erase AB0 = erase (a_CApp a1 g0) /\ erase a1 = A /\
          AnnTyping G (a_CApp a1 g0) D /\ AnnDefEq G (dom G) g C D.

Lemma An_AppCong2 : ∀ (G : context) (D : available_props) rho (g1 g2 : co)
       (a1 a2 b1 b2 A B : tm),
       AnnDefEq G D g1 a1 b1
       → AnnDefEq G D g2 a2 b2
         → AnnTyping G (a_App a1 rho a2) A
           → AnnTyping G (a_App b1 rho b2) B
           → AnnDefEq G D (g_AppCong g1 rho g2) (a_App a1 rho a2) (a_App b1 rho b2).

Lemma An_CAppCong2 :
      ∀ (G : context) (D : available_props) (g1 g2 g3 : co) (a1 b1 a2 b2 a3 b3 A B : tm),
       AnnDefEq G D g1 a1 b1
       → AnnDefEq G (dom G) g2 a2 b2
       → AnnDefEq G (dom G) g3 a3 b3
       → AnnTyping G (a_CApp a1 g2) A
       → AnnTyping G (a_CApp b1 g3) B
       → AnnDefEq G D (g_CAppCong g1 g2 g3) (a_CApp a1 g2) (a_CApp b1 g3).

Lemma An_Trans'
     : ∀ (G : context) (D : available_props) (g1 g2 : co)
       (a b a1 : tm),
       AnnDefEq G D g1 a a1
       → AnnDefEq G D g2 a1 b
       → exists g, AnnDefEq G D g a b .

Lemma An_Sym'
   : ∀ (G : context) (D : available_props) (g : co) (a b : tm),
       AnnDefEq G D g b a → exists g, AnnDefEq G D g a b.

Lemma An_Refl_Star : forall G D a b A,
     erase a = erase b -> AnnTyping G b a_Star ->
     AnnTyping G a A -> erase A = a_Star ->
     exists g, AnnDefEq G D g a b.

Lemma An_IsoRefl2_derivable  : ∀ (G : context) (D : available_props) (phi1 phi2 : constraint),
       AnnPropWff G phi1
       → AnnPropWff G phi2
       → erase_constraint phi1 = erase_constraint phi2 →
       exists g,
       AnnIso G D g phi1 phi2.

Lemma An_Pi_exists2
     : ∀ (x : atom) (G : list (atom * sort)) (rho : relflag) (A B : tm),
       x `notin` union (dom G) (fv_tm_tm_tm B)
       → AnnTyping ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
       → AnnTyping G (a_Pi rho A B) a_Star.

Lemma An_Abs_exists2
  : ∀ (x : atom) (G : context) (rho : relflag) (A a B : tm),
    x `notin` union (dom G) (union (fv_tm_tm_tm a) (fv_tm_tm_tm B))
    → AnnTyping ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    → RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x)))
    → AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

Lemma An_CPi_exists2
  : ∀ (c : atom) (G : context) (phi : constraint) (B : tm),
       c `notin` union (dom G) (fv_co_co_tm B)
       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
       → AnnTyping G (a_CPi phi B) a_Star.

Lemma An_CAbs_exists2
   : ∀ (c : atom) (G : context) (phi : constraint) (a B : tm),
       c `notin` union (dom G) (union (fv_co_co_tm a) (fv_co_co_tm B))
       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c))
       → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

Lemma An_Fam2 :  ∀ (G : context) (F : tyfam) (A a : tm),
       AnnCtx G
       → binds F (Ax a A) an_toplevel
       → AnnTyping G (a_Fam F) A.

Lemma An_AbsCong_exists2
      : ∀ (x1 x2 : atom) (G : context) (D : available_props) (rho : relflag) (g1 g2 : co)
        (A1 b1 A2 b3 b2 B : tm),
        x1 `notin` union (dom G) (union (fv_tm_tm_tm b1) (union (fv_tm_tm_tm b2) (fv_tm_tm_co g2)))
        → x2 `notin` union (dom G) (union (fv_tm_tm_tm b2) (union (fv_tm_tm_tm b3) (fv_tm_tm_co g1)))
          → AnnDefEq G D g1 A1 A2
            → AnnDefEq ([(x1, Tm A1)]++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
              → open_tm_wrt_tm b3 (a_Var_f x2) = open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1))
                  → AnnTyping G A2 a_Star
                    → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
                      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
                        → AnnTyping G (a_Abs rho A1 b2) B
                          → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

 Lemma An_CPiCong_exists2
      : ∀ (c : atom) (G : context) (D : available_props)
        (g1 g3 : co) (phi1 : constraint) (B1 : tm)
        (phi2 : constraint) (B3 B2 : tm),
        AnnIso G D g1 phi1 phi2
        → c
          `notin` (union (dom G)
                   (union D
                    (union (fv_co_co_tm B2)
                       (union (fv_co_co_tm B1)
                          (union (fv_co_co_co g3)
                              (union (fv_co_co_co g1)
                                     (fv_co_co_tm B3)))))))
          → AnnDefEq ([(c, Co phi1)] ++ G) D
                     (open_co_wrt_co g3 (g_Var_f c))
                     (open_tm_wrt_co B1 (g_Var_f c))
                     (open_tm_wrt_co B2 (g_Var_f c))
          → open_tm_wrt_co B3 (g_Var_f c) =
            open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1))
          → AnnTyping G (a_CPi phi1 B1) a_Star
          → AnnTyping G (a_CPi phi1 B2) a_Star
          → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1) (a_CPi phi2 B3).

End fc_invert. *)
Require Import FcEtt.ext_consist.
(* FcEtt.ext_consist:
Require Import FcEtt.sigs.

Require Import Omega.

Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.tactics.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.
Require Export FcEtt.ett_par.
Require Export FcEtt.erase_syntax.
Require Import FcEtt.ext_red_one.
Require Import FcEtt.ext_red.

Require Import FcEtt.ext_wf.

Module ext_consist (invert : ext_invert_sig)(fc_wf: fc_wf_sig).
Import invert.
Import fc_wf.

Module red_one := ext_red_one invert.
Export red_one.

Module red := ext_red invert.
Export red.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Definition Good (G : context) (D : available_props):=
  erased_context G /\
  forall c1 A B1 T1,
    binds c1 (Co (Eq A B1 T1)) G
    -> c1 `in` D
    -> exists C, Par G D A C /\ Par G D B1 C.

Lemma open2 :
  forall x b b' S D a a',
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm a ->
    erased_tm b ->
    erased_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    Par S D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)) ->
    Par S D b b' ->
    Par S D (open_tm_wrt_tm a b) (open_tm_wrt_tm a' b').

Lemma a_Pi_head : forall S G b A rho B,
    Par S G (a_Pi rho A B) b -> exists A' B' L,
      b = a_Pi rho A' B' /\ Par S G A A' /\
      (forall x, x `notin` L -> Par S G (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x))).

Lemma Par_Abs_inversion : forall G D a b rho,
    Par G D (a_UAbs rho a) b ->
    (exists a', b = (a_UAbs rho a') /\
          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->
               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))
    \/
    (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' rho (a_Var_f x)) /\ rho = Rel)
    \/ (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' rho a_Bullet) /\ rho = Irrel). 

Lemma Par_Abs_inversion_Rel : forall G D a b,
    Par G D (a_UAbs Rel a) b ->
    (exists a', b = (a_UAbs Rel a') /\
          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->
               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))
    \/
    (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' Rel (a_Var_f x))).

Lemma Par_Abs_inversion_Irrel : forall G D a b,
    Par G D (a_UAbs Irrel a) b ->
    (exists a', b = (a_UAbs Irrel a') /\
          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->
               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))
    \/ (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' Irrel a_Bullet)). 

Lemma Par_CAbs_inversion : forall G D a b,
    Par G D (a_UCAbs a) b ->
    (exists a', b = (a_UCAbs a') /\
          forall c, c `notin` fv_co_co_tm a \u fv_co_co_tm a' ->
               Par G D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c)))
    \/ (exists a', Par G D a' b /\ (forall c, c `notin`  fv_co_co_tm a ->
          open_tm_wrt_co a (g_Var_f c) = a_CApp a' g_Triv)). 

Lemma copen2 :
  forall c (b: co) S D a a',
    lc_co b ->
    c `notin` fv_co_co_tm a' \u fv_co_co_tm a ->
    Par S D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c)) ->
    Par S D (open_tm_wrt_co a b) (open_tm_wrt_co a' b).

Ltac try_refl :=
  try match goal with
      | [ P2 : Par _ _ _ ?b |- _ ] =>
        exists b; assert (lc_tm b); try eapply Par_lc2; eauto; try split; eauto; fail
      end.

Ltac invert_equality :=
  match goal with
  | [ H : _ = _ |- _ ] =>
    inversion H
  end.

  Ltac try_refl_left :=
  try match goal with
      | [ P2 : Par _ _ ?b ?b |- exists cc:tm, Par ?S ?D ?b cc /\ Par ?S ?D ?a2 cc ] =>
        exists a2; assert (lc_tm a2); try eapply Par_lc2; eauto; try split; eauto; fail
      end.
  Ltac try_refl_right :=
  try match goal with
      | [ P2 : Par _ _ ?b ?b |- exists cc:tm, Par ?S ?D ?a2 cc /\ Par ?S ?D ?b cc ] =>
        exists a2; assert (lc_tm a2); try eapply Par_lc2; eauto; try split; eauto; fail
      end.

  Ltac invert_erased :=
    match goal with
    | [ H : erased_tm ?a |- _ ] => inversion H; subst; clear H
    end.

  Ltac invert_erased_tm b :=
        let h0 := fresh in
        match goal with
          [ h : Par ?G ?D ?a b, h1: erased_tm ?a |- _ ] =>
          assert (h0 : erased_tm b);
          [ eapply (Par_erased_tm h); eauto | inversion h0; subst]
        end.

      Ltac eta_expand x :=
        let h1 := fresh in
      match goal with
       | [ H18 : ∀ x : atom,
              x `notin` ?L0
              → open_tm_wrt_tm ?a (a_Var_f x) = a_App ?b0 ?rho (a_Var_f x)
              |- _ ] =>
        pick fresh x for (L0 \u  fv_tm_tm_tm a \u fv_tm_tm_tm b0);
        move: (H18 x ltac:(auto)) => h1; clear H18;
        rewrite (@tm_subst_tm_tm_intro x a); auto; rewrite h1;
        simpl; destruct (@eq_dec tmvar _ x x); try done;
        rewrite tm_subst_tm_tm_fresh_eq; auto
       | [ H18 : ∀ x : atom,
              x `notin` ?L0
              → open_tm_wrt_tm ?a (a_Var_f x) = a_App ?b0 ?rho a_Bullet
              |- _ ] =>
        pick fresh x for (L0 \u  fv_tm_tm_tm a \u fv_tm_tm_tm b0);
        move: (H18 x ltac:(auto)) => h1; clear H18;
        rewrite (@tm_subst_tm_tm_intro x a); auto; rewrite h1;
        simpl; destruct (@eq_dec tmvar _ x x); try done;
        rewrite tm_subst_tm_tm_fresh_eq; auto
       | [ H18 : ∀ x : atom,
              x `notin` ?L0
              → open_tm_wrt_co ?a (g_Var_f x) = a_CApp ?b0 g_Triv
              |- _ ] =>
        pick fresh x for (L0 \u  fv_co_co_tm a \u fv_co_co_tm b0);
        move: (H18 x ltac:(auto)) => h1; clear H18;
        rewrite (@co_subst_co_tm_intro x a); auto; rewrite h1;
        simpl; destruct (@eq_dec tmvar _ x x); try done;
        rewrite co_subst_co_tm_fresh_eq; auto
      end.

      Ltac eta_case a'0 Y2 :=
         let x:= fresh in
         pick fresh x;
         rewrite (tm_subst_tm_tm_intro x a'0); auto;
         rewrite Y2; auto; simpl;
         rewrite (tm_subst_tm_tm_fresh_eq); auto;
         destruct eq_dec; try done;
         eauto; clear x.

Ltac invert_lc :=
  match goal with
    | [ H : lc_tm ?a |- _ ] => inversion H; subst; clear H
  end.

  Ltac use_size_induction a ac Par1 Par2 :=
  match goal with
  | [   IH : forall y: nat, ?T,
        H2 : Good ?G ?D,
        H3 : erased_tm a,
        H : Par ?G ?D a ?b0,
        H4 : Par ?G ?D a ?b1 |- _ ] =>
      move: (@IH (size_tm a) ltac:(omega) a ltac:(auto) _ _ _ H2 H3 H _ H4) => [ ac [Par1 Par2]]
  end.

  Ltac use_size_induction_open a0 x ac Par1 Par2 :=
      let h0 := fresh in
      let h1 := fresh in
      let h2 := fresh in
      let EQ1 := fresh in
      let EQ2 := fresh in
      match goal with
        | [  H : ∀ x : atom,
              x `notin` ?L
              → Par ?S ?D (?open_tm_wrt_tm a0 (?a_Var_f x)) ?b,
             H4: ∀ x : atom,
                 x `notin` ?L0
                 → Par ?S ?D (?open_tm_wrt_tm a0 (?a_Var_f x)) ?c,
             H1 : ∀ x : atom, x `notin` ?L1 →
    erased_tm (?open_tm_wrt_tm a0 (?a_Var_f x)) |- _ ] =>
    move: (H x ltac:(auto)) => h0; clear H;
    move: (H4 x ltac:(auto)) => h1; clear H4;
                               move: (H1 x ltac:(auto)) => h2; clear H1;
    move: (size_tm_open_tm_wrt_tm_var a0 x) => EQ1;
    move: (size_tm_open_tm_wrt_co_var a0 x) => EQ2;

    use_size_induction (open_tm_wrt_tm a0 (a_Var_f x)) ac Par1 Par2;
    clear h0; clear h1; clear h2; clear EQ1; clear EQ2
    end.

Ltac par_erased_open x J Par4 :=
  let K := fresh in
  let KK := fresh in
  let h0 := fresh in
  match goal with
  | [H13 : ∀ x : atom, x `notin` ?L →
                       Par ?G ?D (open_tm_wrt_tm ?a (a_Var_f x)) ?b,
     H4 : ∀ x : atom, x `notin` ?L1 → erased_tm  (open_tm_wrt_tm ?a (a_Var_f x))
       |- _ ] =>
    have: x `notin` L; auto => h0;
    pose K:= H13 x h0; clearbody K; clear h0;
    have: x `notin` L1; auto => h0;
    pose KK := H4 x h0; clearbody KK;
    pose J := subst3 x Par4 KK K;
    clearbody J;
    repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in J; [auto;
    simpl in J;
    destruct eq_dec; try congruence;
    repeat rewrite tm_subst_tm_tm_fresh_eq in J; auto
    | try apply (Par_lc2 Par4); auto
    | apply (Par_lc1 Par4); auto]
  end.

      Ltac finish_open_co a'0 :=
        let K := fresh in
        let J := fresh in
        let h0 := fresh in
      match goal with
      | H12 : forall c, c `notin` ?L -> Par ?G ?D (open_tm_wrt_co a'0 (g_Var_f c)) (open_tm_wrt_co ?b (g_Var_f c)) |- _ =>
        pick_fresh c;
        have: c `notin` L; auto => h0;
        pose K := H12 c h0; clearbody K;
        pose J := subst4 c lc_g_Triv K;
        clearbody J;
        repeat rewrite co_subst_co_tm_open_tm_wrt_co in J; eauto;
        simpl in J;
        destruct eq_dec; try congruence;
        repeat rewrite co_subst_co_tm_fresh_eq in J; eauto with lc

      end.

Lemma open_tm_wrt_tm_bullet_var_eq: forall a x, 
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    open_tm_wrt_tm a (a_Bullet) = open_tm_wrt_tm a (a_Var_f x).

Lemma open_tm_wrt_tm_inj_irrel: forall(a2 a1 : tm) (x1 : atom),
x1 `notin` fv_tm_tm_tm (open_tm_wrt_tm a2 (a_Var_f x1)) 
-> x1 `notin` fv_tm_tm_tm (open_tm_wrt_tm a1 (a_Var_f x1))
  -> open_tm_wrt_tm a2 a_Bullet = open_tm_wrt_tm a1 (a_Var_f x1)
    -> a2 = a1.

Lemma open_tm_wrt_co_triv_var_eq: forall a c, 
    c `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c)) ->
    open_tm_wrt_co a g_Triv = open_tm_wrt_co a (g_Var_f c).

Lemma open_tm_wrt_co_inj: forall(a2 a1 : tm) (c : atom),
c `notin` fv_co_co_tm (open_tm_wrt_co a2 (g_Var_f c)) 
-> c `notin` fv_co_co_tm (open_tm_wrt_co a1 (g_Var_f c))
  -> open_tm_wrt_co a2 g_Triv = open_tm_wrt_co a1 (g_Var_f c)
    -> a2 = a1.

Lemma erased_fv_co: forall a x, erased_tm a -> x `notin` fv_co_co_tm a.

Lemma confluence_size : forall n a, size_tm a <= n ->  forall S D a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

Lemma confluence : forall S D a a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

Lemma multipar_Star : forall S D A B, multipar S D A B -> A = a_Star -> B = a_Star.

Lemma multipar_Bullet : forall S D B, multipar S D a_Bullet B -> B = a_Bullet.

Inductive Path_consistent : const -> tm -> tm -> Prop :=
  PC_Const : forall T, Path_consistent T (a_Const T) (a_Const T)
| PC_App   : forall T a1 a2 b1 b2,
    erased_tm a2 -> erased_tm b2 ->
    Path_consistent T a1 b1 ->
    Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2)
| PC_AppIrrel : forall T a1 b1,
    Path_consistent T a1 b1 ->
    Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet)
| PC_CApp  : forall T a1 b1,
    Path_consistent T a1 b1 ->
    Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv).
Hint Constructors Path_consistent.

Lemma Path_consistent_Path1 : forall T a b, Path_consistent T a b -> Path T a.
Lemma Path_consistent_Path2 : forall T a b, Path_consistent T a b -> Path T b.

Lemma Path_consistent_erased1 : forall T a b, Path_consistent T a b -> erased_tm a.
Lemma Path_consistent_erased2 : forall T a b, Path_consistent T a b -> erased_tm b.
Hint Resolve Path_consistent_erased1 Path_consistent_erased2 : erased.

Lemma Path_consistent_Refl :
  forall a T, Path T a -> erased_tm a -> Path_consistent T a a.

Lemma Path_consistent_Trans_aux :
  forall b T,  Path T b -> forall a c, Path_consistent T a b -> Path_consistent T b c -> Path_consistent T a c.

Lemma Path_consistent_Trans : forall T a b c,
  Path_consistent T a b -> Path_consistent T b c -> Path_consistent T a c.

Lemma Path_consistent_Sym :
  forall T a b, Path_consistent T a b -> Path_consistent T b a.

Lemma Par_Path_consistent :
  forall S D a b T, Par S D a b -> Path T a -> erased_tm a -> Path_consistent T a b.

Lemma multipar_Path_consistent :
  forall S D a b T, multipar S D a b -> Path T a -> erased_tm a -> Path_consistent T a b.

Lemma Par_Path :
  forall S D a b T, Par S D a b -> Path T a -> Path T b.

Lemma multipar_Path : forall S D a b T ,
    multipar S D a b -> Path T a -> Path T b.

    Lemma Par_Path_consistent_App : forall T G D a1 a2 b1 b2,
        Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
        Par G D (a_App a1 Rel a2) ( a_App b1 Rel b2) ->
        Par G D a1 b1.

    Lemma Par_Path_consistent_AppIrrel : forall T G D a1 b1,
        Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->
        Par G D (a_App a1 Irrel a_Bullet) ( a_App b1 Irrel a_Bullet) ->
        Par G D a1 b1.

    Lemma Par_Path_consistent_CApp : forall T G D a1 b1,
        Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
        Par G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
        Par G D a1 b1.

    Lemma Par_Path_consistent_App2 : forall T G D a1 a2 b1 b2,
        Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
        Par G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->
        Par G D a2 b2.

    Lemma multipar_Path_consistent_App : forall G D a1 a2 b1 b2 T,
      multipar G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      multipar G D a1 b1.

    Lemma multipar_Path_consistent_AppIrrel : forall G D a1 b1 T,
      multipar G D (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->
      Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->
      multipar G D a1 b1.

     Lemma multipar_Path_consistent_App2 : forall G D a1 a2 b1 b2 T,
      multipar G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      multipar G D a2 b2.

    Lemma multipar_Path_consistent_CApp : forall G D a1 b1 T,
      multipar G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
      Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
      multipar G D a1 b1.

Ltac binds_notbinds :=
    match goal with
    [ H0 : binds ?c (Ax ?T ?a) toplevel,
      H5 : forall (c : atom) a, not (binds c (Ax ?T a) an_toplevel) |- _  ] =>
      unfold not in H5; unfold toplevel in H0; unfold erase_sig in H0;
      apply binds_map_3 in H0; destruct H0 as (s' & EQ & B);
      destruct s'; simpl in EQ; inversion EQ; subst;
      apply H5 in B; contradiction
      end.

Lemma Par_Const : forall S D T b,
    Par S D (a_Const T) b -> b = a_Const T.

Lemma multipar_Const : forall S D T b,
    multipar S D (a_Const T) b ->
    (b = a_Const T).

Lemma multipar_Pi : forall S D rho A B, multipar S D A B -> forall A1 A2,
      A = a_Pi rho A1 A2 -> exists B1 B2, B = (a_Pi rho B1 B2).

Lemma multipar_CPi : forall S D A C, multipar S D A C -> forall A1 A2 A3 B, A = a_CPi (Eq A1 A2 A3) B -> exists B1 B2 B3 C2,
        C = (a_CPi (Eq B1 B2 B3) C2).

Lemma multipar_UAbs_Rel : forall S D a b x,
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm b ->
    multipar S D (a_UAbs Rel a) b ->
    (exists b2, b = (a_UAbs Rel b2))
    \/ (exists a1, exists a2, multipar S D (a_UAbs Rel a) (a_UAbs Rel a1) /\
               open_tm_wrt_tm a1 (a_Var_f x) = a_App a2 Rel (a_Var_f x)).

Lemma multipar_UAbs_Irrel : forall S D a b x,
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm b ->
    multipar S D (a_UAbs Irrel a) b ->
    (exists b2, b = (a_UAbs Irrel b2))
    \/ (exists a1, exists a2, multipar S D (a_UAbs Irrel a) (a_UAbs Irrel a1) /\
               open_tm_wrt_tm a1 (a_Var_f x) = a_App a2 Irrel a_Bullet).

Lemma multipar_CAbs : forall S D A C, multipar S D A C -> forall A1 A2 A3 B, A = a_CAbs (Eq A1 A2 A3) B -> exists B1 B2 B3 C2,
        C = (a_CAbs (Eq B1 B2 B3) C2).

Definition decide_Path : forall a, lc_tm a -> (exists T, Path T a) \/ (forall T, not (Path T a)).

Ltac step_left := apply consistent_a_Step_R; [auto |intro N; inversion N; inversion H0]; fail.
Ltac step_right := apply consistent_a_Step_L; [auto | intro N; inversion N; inversion H0]; fail.

Ltac multipar_step SIDE EQ :=
  match goal with
  | [ SIDE : multipar _ _ a_Star _ |- _ ] =>
    apply multipar_Star in SIDE; auto; rename SIDE into EQ
  | [ SIDE : multipar _ _ (a_Pi _ _ _) _ |- _ ] =>
    destruct (multipar_Pi SIDE eq_refl) as [b1' [b2' EQ]]
  | [ SIDE : multipar _ _ (a_CPi ?phi _) _ |- _ ] =>
    try (destruct phi); destruct (multipar_CPi SIDE eq_refl)
      as (B1' & B2' & C1' & C2' &  EQ)
  | [ SIDE : multipar _ _ (a_Const ?T) _ |- _ ] =>
    apply multipar_Const in SIDE; auto; rename SIDE into EQ
  | [ SIDE : Path_consistent _ _ _ |- _ ] =>
    rename SIDE into EQ
  end.

Lemma join_consistent : forall S D a b, joins S D a b -> consistent a b.

Lemma multipar_confluence_helper : forall S D a a1, Good S D -> erased_tm a -> multipar S D a a1
-> forall a2, Par S D a a2 -> exists e, Par S D a1 e /\ multipar S D a2 e.

Lemma multipar_confluence : forall S D a a1, Good S D -> erased_tm a -> multipar S D a a1
-> forall a2, multipar S D a a2 -> exists b, multipar S D a1 b /\ multipar S D a2 b.

Lemma multipar_append : forall S D a b c, multipar S D a b -> multipar S D b c -> multipar S D a c.

Lemma join_transitive : forall S D a b, Good S D -> joins S D a b -> forall c, joins S D b c -> joins S D a c.

Lemma join_symmetry: forall S D a b, joins S D a b -> joins S D b a.

Definition extends (G G2 : context) := exists G1, G = G1 ++ G2.

Lemma multipar_lc2: forall G D a1 a2, lc_tm a1 -> multipar G D a1 a2 -> lc_tm a2.

Hint Resolve multipar_context_independent : DB.

Lemma join_context_independent: forall G1 G2 D A B, erased_context G2 ->
                                             joins G1 D A B -> joins G2 D A B.

Lemma Good_NoAssn: forall c G D phi, erased_sort (Co phi) -> Good G D -> c `notin` D -> Good ((c, Co phi) :: G) D.

Hint Resolve Good_NoAssn.

Hint Resolve multipar_context_independent.

Lemma Good_add_tm: forall G D x A,
    erased_tm A -> Good G D -> Good ((x, Tm A)::G ) D.

Lemma Good_add_tm_2: forall G D x A, x `notin` dom G -> erased_tm A -> Good G D -> Good ((x, Tm A)::G ) (add x D).

Lemma multipar_app_left_Rel:
  forall a a' c' S D, lc_tm a -> multipar S D a' c' -> multipar S D (a_App a Rel a') (a_App a Rel c').

Lemma multipar_capp_left: forall a a' S D, multipar S D a a' -> multipar S D (a_CApp a g_Triv) (a_CApp a' g_Triv).

Lemma join_capp: forall a a' S D, joins S D a a' -> joins S D (a_CApp a g_Triv) (a_CApp a' g_Triv).

Lemma multipar_app_lr_Rel: forall a a' c c' S D, lc_tm a -> lc_tm a' -> multipar S D a c -> multipar S D a' c' -> multipar S D (a_App a Rel a') (a_App c Rel c').

Lemma multipar_app_lr_Irrel: forall a c S D, lc_tm a -> multipar S D a c -> multipar S D (a_App a Irrel a_Bullet) (a_App c Irrel a_Bullet).

Lemma join_app_Rel: forall a a' b b' S D, joins S D a b -> joins S D a' b' -> joins S D (a_App a Rel a') (a_App b Rel b').

Lemma join_app_Irrel: forall a b S D, joins S D a b -> joins S D (a_App a Irrel a_Bullet) (a_App b Irrel a_Bullet).

Lemma multipar_UAbs_exists :  ∀ (x : atom) (G : context) (D : available_props)
       (rho : relflag) (a a' : tm),
    x `notin` fv_tm_tm_tm a
       → multipar G D (open_tm_wrt_tm a (a_Var_f x)) a'
         → multipar G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma multipar_iapp : forall G D a c y L,
    y `notin` fv_tm_tm_tm a \u L ->
    (forall x, x `notin` L -> RhoCheck Irrel x (open_tm_wrt_tm a (a_Var_f x))) ->
    multipar G D (open_tm_wrt_tm a a_Bullet) c ->
    multipar G D (a_UAbs Irrel a) (a_UAbs Irrel (close_tm_wrt_tm y c)).

Lemma joins_iapp : forall S D a1 a2 L1 L2,
    (forall x, x `notin` L1 -> RhoCheck Irrel x (open_tm_wrt_tm a1 (a_Var_f x))) ->
    (forall x, x `notin` L2 -> RhoCheck Irrel x (open_tm_wrt_tm a2 (a_Var_f x))) ->
    joins S D (open_tm_wrt_tm a1 a_Bullet) (open_tm_wrt_tm a2 a_Bullet) ->
    joins S D (a_UAbs Irrel a1) (a_UAbs Irrel a2).

Lemma multipar_App_destruct_Rel : forall S D a1 a2 c,
    multipar S D (a_App a1 Rel a2) c ->
    (exists a1' a2',
        multipar S D (a_App a1 Rel a2) (a_App (a_UAbs Rel a1') Rel a2') /\
        multipar S D a1 (a_UAbs Rel a1') /\
        multipar S D a2 a2' /\
        multipar S D (open_tm_wrt_tm a1' a2') c) \/
    (exists a1' a2',
        multipar S D (a_App a1 Rel a2) (a_App a1' Rel a2') /\
        multipar S D a1 a1' /\
        multipar S D a2 a2').

Lemma multipar_App_destruct_Irrel : forall S D a1 c,
    multipar S D (a_App a1 Irrel a_Bullet) c ->
    (exists a1',
        multipar S D (a_App a1 Irrel a_Bullet) (a_App (a_UAbs Irrel a1') Irrel a_Bullet) /\
        multipar S D a1 (a_UAbs Irrel a1') /\ multipar S D (open_tm_wrt_tm a1' a_Bullet) c) \/
    (exists a1',
        multipar S D (a_App a1 Irrel a_Bullet) (a_App a1' Irrel a_Bullet) /\
        multipar S D a1 a1').

Lemma consistent_mutual:
  (forall S a A,   Typing S a A -> True) /\
  (forall S phi,   PropWff S phi -> True) /\
  (forall S D p1 p2, Iso S D p1 p2 -> Good S D -> (forall A1 B1 T1 A2 B2 T2, p1 = Eq A1 B1 T1 -> p2 = Eq A2 B2 T2-> (joins S D A1 A2 /\ joins S D B1 B2 /\ joins S D T1 T2))) /\
  (forall S D A B T,   DefEq S D A B T -> Good S D -> joins S D A B) /\
  (forall S,       Ctx S -> True).

Lemma consistent_defeq: forall S D A B T,   DefEq S D A B T -> Good S D -> joins S D A B.

Lemma no_aAbs : forall G rho A' a A, Typing G (a_Abs rho A' a) A -> False.

Lemma no_aCAbs : forall G A' a A, Typing G (a_CAbs A' a) A -> False.

Lemma Good_nil : forall D, Good nil D.

Lemma consistent_Star : forall A0,
    consistent a_Star A0 -> value_type A0 -> A0 = a_Star.

Definition irrelevant G D (a : tm) :=
  (forall x A, binds x (Tm A) G -> x `notin` fv_tm a) /\ Good G D.

Lemma irrelevant_Good : forall G D a, irrelevant G D a -> Good G D.

Ltac impossible_Path :=
  match goal with
     [H : Path ?T (a_Pi _ _ _) |- _] => inversion H
   | [H : Path ?T a_Star |- _] => inversion H
   | [H : Path ?T (a_CPi _ _) |- _] => inversion H
  end.

Ltac impossible_defeq :=
  let h0 := fresh in
  let VT := fresh in
  let VT2 := fresh in
  match goal with
  | [ H : DefEq ?G (dom ?G) ?B ?A ?C |- _ ] =>
    pose h0:= H; clearbody h0;
    apply consistent_defeq in h0; eauto;
    [apply join_consistent in h0;
     destruct (DefEq_lc H) as (l0 & l1 & l2); inversion l0; inversion l1; subst;
     have VT: value_type A; eauto;
     have VT2 : value_type B; eauto;
     inversion h0; subst; try impossible_Path;
     eauto; try done | eapply irrelevant_Good; eauto]
  end.

Lemma canonical_forms_Star : forall G a, irrelevant G (dom G) a ->
    Typing G a a_Star -> Value a -> value_type a.

Lemma DefEq_Star: forall A G D, Good G D -> value_type A -> DefEq G D A a_Star a_Star -> A = a_Star.

Lemma canonical_forms_Pi : forall G rho a A B, irrelevant G (dom G) a ->
    Typing G a (a_Pi rho A B) -> Value a ->
    (exists a1, a = a_UAbs rho a1) \/ (exists T, Path T a).

Lemma canonical_forms_CPi : forall G a phi B, irrelevant G (dom G) a ->
    Typing G a (a_CPi phi B) -> Value a ->
    (exists a1, a = a_UCAbs a1) \/ (exists T, Path T a).

Ltac show_irrelevant IR :=
        let x := fresh in
        let A0 := fresh in
        let B0 := fresh in
        let h0 := fresh in
        let h1 := fresh in
        unfold irrelevant in *;
        move: IR => [h0 h1]; split; auto;
        intros x A0 B0;  apply h0 in B0; simpl in B0; fsetdec.

Lemma notin_sub : forall x a b, x `notin` a -> b [<=] a -> x `notin` b.

Lemma progress : forall G a A, Typing G a A ->
                          irrelevant G (dom G) a ->
                          Value a \/ exists a', reduction_in_one a a'.

End ext_consist. *)
Require Import FcEtt.erase.
(* FcEtt.erase:
Require Import FcEtt.sigs.

Require Import FcEtt.utils.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.
Require Import FcEtt.imports.
Require Import FcEtt.tactics.
Require Import FcEtt.erase_syntax.
Require Import FcEtt.ext_red.  
Require Import FcEtt.fc_invert FcEtt.fc_unique.
Require Import FcEtt.ett_par.
Require Import FcEtt.toplevel.
Require Import FcEtt.fc_context_fv.

Module erase (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)
             (e_invert : ext_invert_sig).

Include e_invert.

Module e_red := ext_red e_invert.
Import e_red.

Import wf weak subst.

Module invert := fc_invert wf weak subst.
Module unique := fc_unique wf subst.
Import invert unique.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma Path_erase : forall T a, Path T a -> Path T (erase a).

Hint Constructors Typing PropWff Iso DefEq Ctx.

Ltac dispatch_rho  :=
  match goal with
  |  H11 : ∀ x : atom,
      ¬ x `in` ?L0 →
             RhoCheck ?rho x (erase_tm (open_tm_wrt_tm ?b1 (a_Var_f x)))
             |-
             ∀ x : atom,
               ¬ x `in` ?LL → RhoCheck ?rho x (open_tm_wrt_tm (erase_tm ?b1) (a_Var_f x))
           =>
   let Fr := fresh in
   let r' := fresh in
   intros x; intros;
   assert (FrL0 : x `notin` L0); eauto;
   move: (H11 x FrL0) => r';
   autorewcshyp r';
   rewrite -open_tm_erase_tm in r'; eapply r'
end.

Lemma erase_mutual :
  (forall G a A, AnnTyping G a A ->
          Typing (erase_context G) (erase a) (erase A)) /\
  (forall G phi, AnnPropWff G phi ->
          PropWff (erase_context G) (erase phi)) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
          Iso (erase_context G) D
              (erase_constraint p1) (erase_constraint p2)) /\
  (forall G D g a b,
      AnnDefEq G D g a b ->
      forall A, AnnTyping G a A ->
             DefEq (erase_context G) D (erase a) (erase b) (erase A)) /\
  (forall G, AnnCtx G -> Ctx (erase_context G) /\
    forall c t, binds c t G -> binds c (erase_sort t) (erase_context G)).

Definition AnnTyping_erase :
  (forall G a A, AnnTyping G a A ->
            Typing (erase_context G) (erase a) (erase A)) := first erase_mutual.
Definition AnnPropWff_erase :
  (forall G phi, AnnPropWff G phi ->
            PropWff (erase_context G) (erase phi)) := second erase_mutual.
Definition AnnIso_erase :
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
          Iso (erase_context G) D
              (erase_constraint p1) (erase_constraint p2)) := third erase_mutual.
Definition AnnDefEq_erase :
  (forall G D g a b,
      AnnDefEq G D g a b ->
      forall A, AnnTyping G a A ->
           DefEq (erase_context G) D (erase a) (erase b) (erase A)) := fourth erase_mutual.
Definition AnnCtx_erase :
  (forall G, AnnCtx G -> Ctx (erase_context G) /\
    forall c t, binds c t G -> binds c (erase_sort t) (erase_context G)) := fifth erase_mutual.

Lemma erasure_a_Star :
  forall G a A, AnnTyping G a A -> erase A = a_Star ->
           exists a', erase a = erase a' /\ AnnTyping G a' a_Star.

Lemma erasure_cvt :
    forall G a A, AnnTyping G a A -> forall B, erase A = erase B -> AnnTyping G B a_Star ->
                                    exists a', erase a = erase a' /\ AnnTyping G a' B.

Lemma AnnDefEq_invertb : forall G D g a b, AnnDefEq G D g a b ->
  exists A b' g, AnnTyping G a A /\ AnnTyping G b' A /\ erase b' = erase b /\ AnnDefEq G D g b b'.

Lemma erasure_AnnDefEq : forall G D g A'' B'' S A' B',
      AnnDefEq G D g A'' B'' ->
      AnnTyping G A'' S -> erase S = a_Star ->
      erase A'' = erase A' -> erase B'' = erase B' ->
      AnnTyping G A' a_Star -> AnnTyping G B' a_Star ->
      exists g', AnnDefEq G D g' A' B'.

Lemma AnnDefEq_invert_a_Star : forall G0 D g1 A1' A2' S,
      AnnDefEq G0 D g1 A1' A2' ->
      AnnTyping G0 A1' S ->
      erase S = a_Star ->
      exists A1'', exists A2'', exists g, erase A1'' = erase A1'
                       /\ erase A2'' = erase A2'
                       /\ AnnDefEq G0 D g A1'' A2''
                       /\ AnnTyping G0 A1'' a_Star
                       /\ AnnTyping G0 A2'' a_Star.

Lemma Path_to_Path : forall  a0, lc_tm a0 -> forall T a,
      Path T a -> erase a0 = a -> Path T a0.

Lemma annotation_mutual :
  (forall G a A, Typing G a A ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists a0 A0,
         (erase a0) = a /\
         (erase A0) = A /\
         AnnTyping G0 a0 A0) /\
  (forall G phi, PropWff G phi ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists phi0,
          erase_constraint phi0 = phi /\
          AnnPropWff G0 phi0) /\
  (forall G D p1 p2, Iso G D p1 p2 ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists g0 p1' p2',
       (erase_constraint p1') = p1 /\
       (erase_constraint p2') = p2 /\
       AnnIso G0 D g0 p1' p2') /\
  (forall G D a b A, DefEq G D a b A ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists g a0 b0 A0,
       (erase a0) = a /\
       (erase b0) = b /\
       (erase A0) = A /\
       AnnDefEq G0 D g a0 b0 /\ AnnTyping G0 a0 A0 /\ AnnTyping G0 b0 A0) /\
  (forall G, Ctx G -> True).

End erase. *)
Require Import FcEtt.fc_head_reduction.
(* FcEtt.fc_head_reduction:
Require Import FcEtt.sigs.
Require Import FcEtt.fc_wf.

Module fc_head_reduction (e_invert : ext_invert_sig)
       (wk: fc_weak_sig) (wf : fc_wf_sig) (sub : fc_subst_sig).

Import e_invert.
Import wk.
Import sub.

Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.tactics.

Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ett_par.
Require Export FcEtt.erase_syntax.

Require Import FcEtt.ext_red_one.
Module red1 := ext_red_one e_invert.
Import red1.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma weaken_head_reduction : forall G0 a a',
    head_reduction G0 a a' ->
    forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> head_reduction (F ++ E ++ G) a a'.

Lemma subst_head_reduction : forall G a a',
    head_reduction G a a' -> forall G1 G2 A b x,
       G = G1 ++ [(x, Tm A)] ++ G2
      -> AnnTyping G2 b A
      -> head_reduction (map (tm_subst_tm_sort b x) G1 ++ G2)
                       (tm_subst_tm_tm b x a)
                       (tm_subst_tm_tm b x a').

Ltac resolve_open a :=
    let s := fresh in
    match goal with
      [ x1 : ?b = open_tm_wrt_tm a (a_Var_f ?x) |- _ ] =>
      destruct a; inversion x1;
        [unfold open_tm_wrt_tm in x1;
         simpl in x1;
         match goal with [ n:nat |- _ ] =>
                         destruct (lt_eq_lt_dec n 0) as [s | [| s]];
                         try destruct s; inversion x1
         end | subst; unfold open_tm_wrt_tm in x1;
               unfold open_tm_wrt_tm; simpl in *; inversion x1; clear x1]
    end.

Lemma An_AbsTerm_exists : ∀ G x A (a a' : tm),
    x `notin` (fv_tm a \u fv_tm a' \u dom G) ->
    AnnTyping G A a_Star ->
    head_reduction ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
                                      (open_tm_wrt_tm a' (a_Var_f x))
    → head_reduction G (a_Abs Irrel A a) (a_Abs Irrel A a').

End fc_head_reduction. *)

Require Import FcEtt.fc_preservation.
(* FcEtt.fc_preservation:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Require Import FcEtt.ett_ott.
Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.

Require Import FcEtt.ett_par.
Require Import FcEtt.ext_invert.
Require Import FcEtt.ext_red.
Require Import FcEtt.ext_red_one.
Require Import FcEtt.erase_syntax.

Require Import FcEtt.fc_invert FcEtt.fc_unique.

Module fc_preservation (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)
        (e_subst : ext_subst_sig).

Import subst weak wf.

Module e_invert := ext_invert e_subst.
Import e_invert.

Module red := ext_red e_invert.
Import red.

Module red_one := ext_red_one e_invert.
Import red_one.

Module invert := fc_invert wf weak subst.
Module unique := fc_unique wf subst.
Import invert unique.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma open_a_Conv : forall a b g,
    open_tm_wrt_tm (a_Conv a g) b =
    a_Conv (open_tm_wrt_tm a b) (open_co_wrt_tm g b).

Lemma open_a_Conv_co : forall a b g,
    open_tm_wrt_co (a_Conv a g) b =
    a_Conv (open_tm_wrt_co a b) (open_co_wrt_co g b).

Ltac lc_erase_hyp :=
  match goal with
  | H : AnnTyping ?G ?a ?A0 |- lc_tm (erase_tm ?a) => eapply lc_erase; apply (AnnTyping_lc H)
  | H : AnnTyping ?G ?a ?A0 |- lc_tm ?a => apply (AnnTyping_lc1 H)
  | H : lc_tm ?a |- lc_tm (erase ?a) => eapply lc_erase; eauto
  | H : lc_tm (a_Abs ?r ?a ?b) |- lc_tm ?c => apply lc_erase in H; simpl in H; auto
  | H : lc_tm (a_CAbs ?a ?b) |- lc_tm ?c => apply lc_erase in H; simpl in H; auto
  end.

Lemma binds_toplevel: forall F a A,
  binds F (Ax a A) an_toplevel ->
  binds F (Ax (erase a) (erase A)) toplevel.

Ltac do_rho :=
  match goal with
    H : ∀ x : atom, x `notin` ?L → RhoCheck Irrel x (erase_tm (open_tm_wrt_tm ?b (a_Var_f x))) |-
                    ?x `notin` fv_tm_tm_tm (open_tm_wrt_tm (erase ?b) (a_Var_f ?x)) =>
    let h := fresh in
    let F := fresh in
    assert (F : x `notin` L); auto;
    move: (H x F) => h; inversion h; subst;
    replace (a_Var_f x) with (erase (a_Var_f x)); auto;
    rewrite open_tm_erase_tm; auto
  end.

Ltac eauto_lc := simpl; eauto using AnnTyping_lc1, Value_lc,
                        AnnDefEq_lc3, AnnPropWff_lc.

Lemma head_reduction_in_one : forall G a b,
    head_reduction G a b -> forall A,  AnnTyping G a A ->
    reduction_in_one (erase a) (erase b) \/ erase a = erase b.

Lemma head_reduction_erased : forall G a b, head_reduction G a b ->
    forall A, AnnTyping G a A ->  Par G (dom G) (erase a) (erase b).

Lemma preservation : forall G a A, AnnTyping G a A -> forall a', head_reduction G a a' -> AnnTyping G a' A.

End fc_preservation. *)
Require Import FcEtt.ext_subst.
(* FcEtt.ext_subst:
Require Import FcEtt.sigs.

Require Import FcEtt.tactics.
Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.fset_facts.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.

Require Export FcEtt.beta.
Require Export FcEtt.ext_wf.
Require Export FcEtt.ett_value.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Module ext_subst (weak : ext_weak_sig) <: ext_subst_sig.
  Include weak.

Lemma Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Lemma binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Lemma tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Lemma tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Lemma tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Lemma co_subst_fresh :
forall G phi a0 x s,
  PropWff G phi -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_constraint a0 x phi = phi.

Lemma bind_map_tm_subst_tm_sort: forall c F A B T x a,
    binds c (Co (Eq A B T)) F ->
    binds c (Co (Eq (tm_subst_tm_tm a x A)
                    (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T))) (map (tm_subst_tm_sort a x) F).

Lemma binds_map_4: forall x A F c0,
    binds x (Tm A) F ->
    binds x (Tm (co_subst_co_tm g_Triv c0 A)) (map (co_subst_co_sort g_Triv c0) F).

Lemma binds_map_5: forall c A B T F c1 ,
    binds c (Co (Eq A B T) ) F ->
    binds c (Co (Eq (co_subst_co_tm g_Triv c1 A) (co_subst_co_tm g_Triv c1 B) (co_subst_co_tm g_Triv c1 T)) ) (map (co_subst_co_sort g_Triv c1) F).

Lemma tm_subst_tm_tm_dom_invariance: forall x a F, dom F = dom (map (tm_subst_tm_sort a x) F).

Lemma subst_rho: forall L G a A x y b rho
    (T : Typing G a A)
    (Neq: x <> y)
    (Fr: y `notin` fv_tm_tm_tm a)
    (Fr2: y `notin` L)
    (K : (forall x, x `notin` L -> RhoCheck rho x (open_tm_wrt_tm b (a_Var_f x)))),
    RhoCheck rho y  (tm_subst_tm_tm a x (open_tm_wrt_tm b (a_Var_f y))).

Ltac rewrite_subst_context :=
  match goal with
  | [ |- context [([(?y, ?C (_ _ _ ?T))] ++ map ?sub ?F ++ ?G0)] ] =>
    rewrite_env (map sub ((y ~ (C T)) ++ F) ++ G0)
  end.

Ltac eapply_E_subst :=
  first [ eapply E_Star     |
          eapply E_App      |
          eapply E_IApp     |
          eapply E_CApp     |
          eapply E_Const    |
          eapply E_IsoConv  |
          eapply E_AppCong  |
          eapply E_IAppCong |
          eapply E_CAppCong |
          eapply E_PiSnd    |
          eapply E_CPiSnd].

Lemma tm_substitution_mutual :
  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Lemma Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Lemma co_subst_rho: forall L x y a rho
    (Neq: x <> y)
    (Fr2: y `notin` L)
    (K : (forall x, x `notin` L -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))),
    RhoCheck rho y  (co_subst_co_tm g_Triv x (open_tm_wrt_tm a (a_Var_f y))).

Lemma co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Lemma Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Lemma Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Lemma DefEq_swap : forall x1 x G A1 D b1 b2 B,
   x1 `notin` fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u fv_tm_tm_tm B
  -> x `notin` dom G \u {{ x1 }}
  -> DefEq ([(x1, Tm A1)] ++ G) D
          (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
          (open_tm_wrt_tm B (a_Var_f x1))
  -> DefEq ([(x, Tm A1)] ++ G) D
          (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
          (open_tm_wrt_tm B (a_Var_f x)).

Lemma E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Lemma E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst. *)

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Module fc_consist (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)
                  (e_invert : ext_invert_sig)(e_subst : ext_subst_sig).

Import wf weak.

Export subst.

Module invert := fc_invert wf weak subst.
Export invert.

Module consist := ext_consist e_invert wf.
Export consist.

Module erase' := erase wf weak subst e_invert.
Export erase'.

Module head := fc_head_reduction  e_invert weak wf subst.
Export head.

Module pres := fc_preservation wf weak subst e_subst.
Import pres.

Lemma erased_tm_erase_mutual :
  (forall G0 a B (H : AnnTyping G0 a B),
     erased_tm (erase a) /\ erased_tm (erase B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall a b A, phi = (Eq a b A) ->
                                         erased_tm (erase a) /\ erased_tm (erase b)
                                         /\ erased_tm (erase A)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
     True) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      True) /\
  (forall G0 (H : AnnCtx G0),
     forall x A, binds x (Tm A) G0 -> erased_tm (erase_tm A)
  ).
Proof.
 apply ann_typing_wff_iso_defeq_mutual; intros; simpl; repeat split; eauto.
 all: try solve [inversion H; eauto].
 all: try solve [inversion H1; eauto].
 all: try solve [inversion H0; eauto].
   
  - 
    erased_pick_fresh y. inversion H0. eauto using lc_erase.
    move: (H y) => h0. assert (W: y `notin` L). eauto.
    apply h0 in W. inversion W. rewrite <- open_tm_erase_tm in H1. eauto.
  - 
    destruct rho; eauto. 
    
    pick fresh x and apply erased_a_Abs. 
    replace (a_Var_f x) with (erase (a_Var_f x)); eauto.
    rewrite open_tm_erase_tm. assert (W: x `notin` L). auto. apply H0 in W.
    inversion W. auto. auto.
    
    pick fresh x and apply erased_a_Abs.
    replace (a_Var_f x) with (erase (a_Var_f x)); eauto.
    rewrite open_tm_erase_tm. assert (W: x `notin` L). auto. apply H0 in W.
    inversion W. auto.
    econstructor.
    assert (W: x `notin` L). auto.
    apply r in W. inversion W. simpl. 
    rewrite Rew.r_erase_tm.
    rewrite Rew.r_erase_tm in H1. rewrite -open_tm_erase_tm in H1.
    simpl in H1. auto.
  - 
    erased_pick_fresh y. inversion H. eauto using lc_erase.
    move: (H0 y) => h0. assert (W: y `notin` L). eauto.
    apply h0 in W. inversion W. clear h0 W. 
    rewrite <- open_tm_erase_tm in H2. eauto.
  - inversion H. inversion H0. destruct rho; simpl; eauto.
  - rewrite <- open_tm_erase_tm.
    set M := erase_tm B.
    inversion H. inversion H2; subst.
    pick fresh x.
    unfold M in Fr.
    rewrite (tm_subst_tm_tm_intro x); eauto.
    eapply subst_tm_erased. inversion H0. auto.
    eapply H7. fsetdec.
  - 
    destruct phi. destruct (H _ _ _ eq_refl) as (h0 & h1 & h2). simpl.
    eauto. erased_pick_fresh y; eauto using lc_erase.
    assert (W: y `notin` L). auto. apply H0 in W.
    rewrite Rew.r_erase_tm.
    erewrite open_co_erase_tm2. inversion W. apply H1.
  - 
    pick fresh y and apply erased_a_CAbs.
    assert (W: y `notin` L). auto. apply H0 in W.
    rewrite Rew.r_erase_tm.
    erewrite open_co_erase_tm2. inversion W. apply H1.
  - 
    destruct phi. destruct (H _ _ _ eq_refl) as (h0 & h1 & h2). simpl.
    eauto. erased_pick_fresh y; eauto using lc_erase.
    assert (W: y `notin` L). auto. apply H0 in W.
    rewrite Rew.r_erase_tm.
    erewrite open_co_erase_tm2. inversion W. apply H2.
  - rewrite <- open_co_erase_tm.
    set M := erase_tm B.
    inversion H. inversion H2; subst.
    pick fresh x.
    unfold M in Fr.
    assert (W: x `notin` L). fsetdec. apply H10 in W.
    erewrite open_co_erase_tm with (a := (g_Var_f x)).
    erewrite open_co_erase_tm2 in W. apply W.
  - inversion H1. subst. inversion H. auto.
  - inversion H1. subst. inversion H0. auto.
  - inversion H1. subst. inversion H. auto.
  - simpl in H1.
    apply binds_cons_iff in H1.
    inversion H1. inversion H2.
    + inversion H4; subst; auto.
      inversion H0; auto.
    + apply H in H2; auto.
  - simpl in H1.
    apply binds_cons_iff in H1.
    inversion H1. destruct phi.
    inversion H2. inversion H4. 
    apply H in H2; auto.
Qed.

Lemma erased_tm_erase : forall G0 a B, AnnTyping G0 a B -> erased_tm (erase a).
Proof.
  intros.
  destruct erased_tm_erase_mutual.
  apply H0 in H. inversion H. auto.
Qed.

Lemma erased_tm_erase_type : forall G0 a B, AnnTyping G0 a B -> erased_tm (erase B).
Proof.
  intros.
  destruct erased_tm_erase_mutual.
  apply H0 in H. inversion H. auto.
Qed.

Hint Resolve erased_tm_erase : erased.

Definition AnnGood G D := Good (erase_context G) D.

Lemma AnnGoodIsGood : forall G D, AnnGood G D -> Good (erase_context G) D.
Proof. intros. auto.
Qed.

Lemma AnnGoodnil : AnnGood nil AtomSetImpl.empty.
  unfold AnnGood. simpl. unfold Good. unfold erased_context.
  split. auto.
  intros.
  unfold binds in H. inversion H.
Qed.

Lemma AnnDefEq_consistent : forall S D g A B, AnnDefEq S D g A B -> AnnGood S D -> consistent (erase A) (erase B).
Proof.
  intros S D g A B H H0.
  pose S' := AnnGoodIsGood H0.
  destruct (AnnDefEq_regularity H) as (S1 & S2 & gs & TS1 & TS2 & ES).
  assert (DefEq (erase_context S) D (erase A) (erase B) (erase S1)).
  { apply (AnnDefEq_erase H).
    auto.
  }
  assert (C : consistent (erase A) (erase B)).
  eapply join_consistent.
  eapply consistent_defeq. eauto. eauto.
  inversion C; subst; auto.
Qed.

Lemma Paths_are_DataTy : forall T a,
    Path T a -> Value a -> forall G A, AnnTyping G a A -> DataTy A a_Star.
Proof.
  induction 1; intros.
  - inversion H0. subst.
    eapply (binds_to_type _ _ AnnSig_an_toplevel); eauto.
  - inversion H1. inversion H2. subst.
    move: (IHPath H8 _ _ H14) => h0.
    inversion h0. subst.
    pick fresh x.
    rewrite (tm_subst_tm_tm_intro x); eauto with lngen.
  - inversion H1. inversion H2. subst.
    move: (IHPath H7 _ _ H11) => h0.
    inversion h0. subst.
    pick fresh x.
    rewrite (co_subst_co_tm_intro x); eauto with lngen.
  - inversion H1.
Qed.

Lemma Paths_have_value_types : forall T a,
    Path T a -> Value a -> forall G A, AnnTyping G a A -> value_type A.
Proof. intros.
       eapply DataTy_value_type; eauto.
       eapply Paths_are_DataTy; eauto.
Qed.

Lemma values_have_value_types :
  forall G D a A, AnnGood G D ->  AnnTyping G a A -> Value a -> value_type A.
Proof.
  intros G D a A AN H V.
  move: (AnnTyping_regularity H) => h0.
  inversion H; subst; auto.
  all: try solve [inversion V; inversion H2].
  all: match goal with
  | [H : AnnTyping ?G ?b ?A |- value_type ?b] =>
    apply AnnTyping_lc in H; split_hyp; lc_inversion c;  eauto
       end.
  + inversion V.
    eapply (@Paths_have_value_types T (a_App b rho a0)); eauto.
  + inversion V.
    eapply (@Paths_have_value_types T (a_CApp a1 g)); eauto.
  + eapply DataTy_value_type.
    eapply (binds_to_type _ _ AnnSig_an_toplevel); eauto.
Qed.

Lemma canonical_forms_a_Pi :
  forall G D a rho A B, AnnGood G D ->
                   AnnTyping G a (a_Pi rho A B) -> Value a ->
                   (exists a', a = a_Abs rho A a') \/ (exists T, Path T a).
Proof.
  intros G D a rho A B AN H V.
  inversion V; subst; inversion H; subst; try solve [inversion H0].
  all: try solve [left; exists a0; auto].
  all: try solve [right; exists T; auto].
Qed.

Lemma canonical_forms_a_CPi :
  forall G D a phi B, AnnGood G D ->
                 AnnTyping G a (a_CPi phi B) -> Value a ->
                 (exists a', a = a_CAbs phi a') \/ (exists T, Path T a).
Proof.
  intros G D a phi B AN H V.
  inversion V; subst; inversion H; subst; try solve [inversion H0].
  all: try solve [left; exists a0; auto].
  all: try solve [right; exists T; auto].
Qed.

Lemma consistent_a_Pi :
  forall G A B C g rho,
    AnnGood G (dom G) -> value_type C ->
    AnnDefEq G (dom G) g C (a_Pi rho A B) -> exists A' B', C = a_Pi rho A' B'.
Proof.
  intros G A B C g rho AN VT DE.
  move: (AnnDefEq_consistent DE AN) => K;  simpl in K.
  inversion K.
  destruct C; destruct rho0; try destruct rho1; simpl in H; inversion H.
  - exists C1. exists C2. subst. auto.
  - subst. exists C1. exists C2. auto.
  - inversion VT.
  - inversion VT.
  - inversion H0.
  - assert False.
    apply AnnDefEq_lc in DE. split_hyp.
    match goal with
      [ H0 : ¬ value_type (a_Pi rho (erase_tm A) (erase_tm B)),
        H4 : lc_tm (a_Pi rho A B) |- _ ] =>
    apply H0; econstructor;
      pose M := H4; clearbody M; inversion M;
      eauto using lc_tm_erase;
      move: (lc_erase) => [h0 _]; apply h0 in H4; auto end.
    done.
  - subst.
    apply value_type_erase in VT. done.
Qed.

Lemma consistent_a_CPi :
  forall G phi B C g,
    AnnGood G (dom G) -> value_type C -> AnnDefEq G (dom G) g C (a_CPi phi B) -> exists phi' B', C = a_CPi phi' B'.
Proof.
  intros G phi B C g AN VT DE.
  move: (AnnDefEq_consistent DE AN) => K;  simpl in K.
  inversion K.
  destruct C; try destruct rho; simpl in H; inversion H;
  try solve [inversion VT; inversion H1].
  - subst. exists phi0. exists C.  auto.
  - inversion H0.
  - assert False.
    apply AnnDefEq_lc in DE. split_hyp.
    apply H0. econstructor.
    pose M := H4. inversion M.
    apply lc_erase. auto.
    move: (lc_erase) => [h0 _]. apply h0 in H4. apply H4.
    done.
  - subst.
    apply value_type_erase in VT. done.
Qed.

Definition irrelevant G D (a : tm) :=
  (forall x A, binds x (Tm A) G -> x `notin` fv_tm (erase a)) /\ AnnGood G D.

Lemma progress : forall G a A, irrelevant G (dom G) a -> AnnTyping G a A -> CoercedValue a \/ exists a', head_reduction G a a'.
Proof.
  intros G a A AN H.
  destruct AN as [IR AN].
  assert (M : AnnTyping G a A); auto.
  dependent induction H; destruct (AnnTyping_lc M) as [LCa LCA]; inversion LCa.
  - left; auto.
  - apply IR in H0. simpl in H0. fsetdec.
  - left; eauto.
  - destruct rho; try solve [left; eauto].
    pick fresh x.
    have: x `notin` L; auto => h0.
    move: (H2 x h0) => h1.
    inversion h1. subst. clear H2.
    destruct (H1 x h0) as [V | [a' R]].
    { move: (H0 x h0) => h2.
      have ctx: (AnnCtx ([(x, Tm A)] ++ G)) by eauto with ctx_wff.
      move: (AnnCtx_uniq ctx) => u. inversion u. subst.
      intros x0 A0 b0.
      apply binds_cons_uniq_1 in b0. destruct b0; split_hyp.
      ++ subst. auto.
      ++ move: (IR _ _ H2) => fr. simpl in fr.
         rewrite <- open_tm_erase_tm.
         eapply notin_sub; [idtac| eapply fv_tm_tm_tm_open_tm_wrt_tm_upper].
         simpl.
         fsetdec.
      ++ eauto. }
    { unfold AnnGood. simpl. eapply Good_add_tm_2; eauto.
      rewrite <- erase_dom. auto.
      eapply Typing_erased. eapply (AnnTyping_erase). eauto. }
    { eauto. }
    -- inversion V. subst.
       ++ left.
       econstructor.
       eapply Value_AbsIrrel_exists with (x := x); eauto.
       ++ resolve_open a.
       left. eapply CV.
       eapply Value_AbsIrrel_exists with (x:=x); eauto.
    -- right. exists (a_Abs Irrel A (close_tm_wrt_tm x a')).
       eapply An_AbsTerm_exists with (x := x).
         { eapply notin_union; auto.
           simpl. rewrite fv_tm_tm_tm_close_tm_wrt_tm. auto. }
         auto.
         rewrite open_tm_wrt_tm_close_tm_wrt_tm. auto.
  - destruct IHAnnTyping1; auto.
    + intros. move: (IR x A0 H6) => h0. destruct rho; simpl in h0. fsetdec. fsetdec.
    + inversion M. subst.
      match goal with
        H: CoercedValue b |- _ => inversion H
      end.
      -- 
        edestruct canonical_forms_a_Pi as [[ a1 EQ] | [T P]] ; eauto; subst.
        
        ++ right. 
           exists (open_tm_wrt_tm a1 a). eapply An_AppAbs; eauto.
      -- right. 
         subst.
         inversion H.
         subst.
         have VT: value_type A1. eapply values_have_value_types; eauto.
         edestruct consistent_a_Pi as (A' & B' & EQ); eauto. subst.
         edestruct canonical_forms_a_Pi as [[ a0' EQ] | [T P]]; eauto; subst.
    + subst.
      match goal with H : exists a' : tm, head_reduction G b a' |- _ => destruct H end.
      right. eexists. eapply An_AppLeft; eauto.
  - 
    subst. destruct IHAnnTyping1; auto.
    inversion H2.
    + subst. left; auto.
    + subst. right. inversion H4.
      eexists.  eapply An_Combine; eauto.
    + destruct H2. right. eexists. eapply An_ConvTerm; eauto.
  - left; auto.
  - left; auto.
  - destruct IHAnnTyping; auto.
    + intros. move: (IR x A H5) => h0. simpl in h0. fsetdec.
    + inversion M. subst.
      match goal with
        H : CoercedValue ?a1 |- _ => inversion H
      end.
      -- edestruct canonical_forms_a_CPi as [[a2 EQ]|[T p]]; eauto; subst.
         right. exists (open_tm_wrt_co a2 g). eapply An_CAppCAbs; eauto.
         destruct (AnnTyping_lc H) as [h0 h1]. inversion h0; auto.
      -- subst.  inversion H. subst.
         have VT: value_type A. eapply values_have_value_types; eauto.
        edestruct consistent_a_CPi as (A' & a2 & EQ); eauto. subst.
        edestruct canonical_forms_a_CPi as [[a0' EQ]|[T p]]; eauto; subst.
    + destruct H5. right. eexists. eapply An_CAppLeft. eauto. eauto.
  - left. eauto.
  - right. exists a. eauto.
Qed.

Inductive multi (rel : tm -> tm -> Prop) : tm -> tm -> Prop :=
| multi_refl : forall a, lc_tm a -> multi rel a a
| multi_step : forall a b c, rel a b -> multi rel b c -> multi rel a c.

Lemma multi_trans : forall r a b, multi r a b -> forall c, multi r b c -> multi r a c.
Proof.
  intros.
  dependent induction H. auto.
  eapply multi_step. eauto. auto.
Qed.

Lemma multi_An_AbsTerm_exists : ∀ (G : list (atom * sort)) (x : atom) (A a a' : tm),
       x `notin` union (fv_tm a) (union (fv_tm a') (dom G))
       → AnnTyping G A a_Star
         → multi (head_reduction ([(x, Tm A)] ++ G)) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm a' (a_Var_f x))
           → multi (head_reduction G) (a_Abs Irrel A a) (a_Abs Irrel A a').
Proof.
  intros.
  dependent induction H1.
  + apply open_tm_wrt_tm_inj in x; auto.
    subst.
    eapply multi_refl; eauto using AnnTyping_lc1.
  + eapply multi_step with (b := a_Abs Irrel A (close_tm_wrt_tm x b)); eauto.
    eapply An_AbsTerm_exists with (x:=x); auto.
    autorewrite with lngen. auto.
    autorewrite with lngen. auto.
    eapply IHmulti with (x0:=x); auto.
    autorewrite with lngen. auto.
    autorewrite with lngen. auto.
Qed.

Lemma multi_An_ConvTerm : ∀ (G : context) (a : tm) (g : co) (a' : tm),
    lc_co g → multi (head_reduction G) a a'
    → multi (head_reduction G) (a_Conv a g) (a_Conv a' g).
Proof.
  intros.
  dependent induction H0.
  - eapply multi_refl; eauto.
  - eapply multi_step with (b:= (a_Conv b g)); auto.
Qed.

Lemma multi_An_AppLeft : ∀ (G : context) (a b: tm) rho (a' : tm),
    lc_tm b → multi (head_reduction G) a a'
    → multi (head_reduction G) (a_App a rho b) (a_App a' rho b).
Proof.
  intros.
  dependent induction H0.
  - eapply multi_refl; eauto.
  - eapply multi_step with (b:= (a_App b0 rho b)); auto.
Qed.

Lemma multi_An_CAppLeft : ∀ (G : context) (a: tm) (g:co) (a' : tm),
    lc_co g → multi (head_reduction G) a a'
    → multi (head_reduction G) (a_CApp a g) (a_CApp a' g).
Proof.
  intros.
  dependent induction H0.
  - eapply multi_refl; eauto.
  - eapply multi_step with (b:= (a_CApp b g)); auto.
Qed.

Lemma multi_preservation : forall G a b A, multi (head_reduction G) a b ->
                                      AnnTyping G a A ->
                                      AnnTyping G b A.
Proof.
  induction 1.
  intros. auto.
  intros.
  eapply IHmulti.
  eapply preservation; eauto.
Qed.

Lemma erased_constraint_erase :
  forall G a b A, AnnPropWff G (Eq a b A) -> erased_tm (erase a) /\ erased_tm (erase b)
                                      /\ erased_tm (erase A).
Proof.
  move: erased_tm_erase_mutual => [_ [h [_ _]]].
  eauto.
Qed.

Lemma erased_context_erase :
  forall G, AnnCtx G -> erased_context (erase_context G).
       Proof.
         induction 1; simpl; unfold erased_context; rewrite Forall_forall.
         - intros. inversion H.
         - intros. destruct x0. inversion H2.
           -- inversion H3. destruct s. inversion H6. subst. 
              econstructor. eapply erased_tm_erase. eauto.
              inversion H6.
           -- unfold erased_context in IHAnnCtx.
              move: (Forall_forall (λ p : atom * sort, let (_, s) := p in erased_sort s) (erase_context G)) => [h0 h1].
              move: (h0 IHAnnCtx) => h2.
              eapply (h2 (a,s)). auto.
         - intros. destruct x. inversion H2.
           -- inversion H3. destruct s. inversion H6.
              inversion H6. subst.
              destruct phi.
              inversion H0.
              econstructor. 
              + eapply erased_tm_erase. eauto using AnnTyping_lc1.
              + eapply erased_tm_erase. eauto using AnnTyping_lc2.
              + eapply erased_tm_erase_type. eauto.
           -- unfold erased_context in IHAnnCtx.
              move: (Forall_forall (λ p : atom * sort, let (_, s) := p in erased_sort s) (erase_context G)) => [h0 h1].
              move: (h0 IHAnnCtx) => h2.
              eapply (h2 (a,s)). auto.
       Qed.

Lemma AnnGood_add_tm :
  forall G x A,  x `notin` dom G -> AnnTyping G A a_Star -> AnnGood G (dom G) -> AnnGood (x ~ Tm A ++ G) (dom (x ~ Tm A ++ G)).
Proof.
  intros G x A Fr AT GG.
  inversion GG.  econstructor. eapply erased_context_erase; eauto using AnnTyping_AnnCtx.
  intros.
  simpl in H1.
  apply binds_cons_1 in H1.
  destruct H1 as [[_ EQ] | BI1]. inversion EQ.
  edestruct (H0 c1) as (C & P1 & P2); eauto.
  move: (binds_In _ c1 _ _ BI1) => b0.
  unfold erase_context in b0. move: (dom_map _ _ erase_sort G) => DM. fsetdec.
  exists C. repeat split;
         eapply context_Par_irrelevance; eauto.
Qed.

Ltac eauto_lc := simpl; eauto using AnnTyping_lc1, Value_lc,
                        AnnDefEq_lc3, AnnPropWff_lc.

Lemma erased_Value_reduces_to_CoercedValue :
  forall G a0 A,
    AnnTyping G a0 A
    -> AnnGood G (dom G) -> forall a, erase a0 = a -> Value a
           -> exists av, multi (head_reduction G) a0 av /\ CoercedValue av /\ erase av = a.
Proof.
  intros G a0 A H. induction H.
  all: intros GG aa E V; simpl in E; inversion E; subst.
  all: try solve [inversion V].
  all: try solve [eexists; repeat split;
                  try eapply multi_refl; eauto_lc].
  + exists (a_Pi rho A B).
    have ?: lc_tm (a_Pi rho A B) by eauto_lc.
    repeat split; try eapply multi_refl; eauto_lc.

  + have ?: lc_tm (a_Abs rho A a) by eauto_lc.
    destruct rho.
    ++ exists (a_Abs Rel A a).
       repeat split; try eapply multi_refl; eauto_lc.
    ++ 
      inversion V. subst.
      match goal with
        [H5 : forall x, x `notin` ?L -> Value _ |- _ ] =>
        pick_fresh y; move: (H5 y ltac:(auto)) => Va; clear H5 end.

      have EE: erase (open_tm_wrt_tm a (a_Var_f y)) = open_tm_wrt_tm (erase_tm a) (a_Var_f y)
        by simpl_erase; auto.

       have G1 : AnnGood (y ~ Tm A ++ G) (dom (y ~ Tm A ++ G)) by  eapply AnnGood_add_tm; eauto.

       match goal with
         [ H1 : ∀ x : atom, x `notin` ?L → AnnGood _ _ -> _ |- _ ] =>
         move: (H1 y ltac:(auto) G1 _ EE Va) => [av [MS [VV EV]]] end.

       exists (a_Abs Irrel A (close_tm_wrt_tm y av)).
       repeat split.
       +++ eapply multi_An_AbsTerm_exists with (x:=y);
            autorewrite with lngen; eauto.
       +++ econstructor.
           eapply Value_AbsIrrel_exists with (x:=y); autorewrite with lngen; eauto_lc.
       +++ simpl_erase. rewrite EV.
           simpl. rewrite close_tm_wrt_tm_open_tm_wrt_tm; eauto using fv_tm_erase_tm.

  + destruct rho; simpl in V; inversion V; subst;
    move: (IHAnnTyping1 GG (erase b) eq_refl ltac:(auto)) => [av [MS [CV EE]]];
    inversion CV; subst.
    ++ exists (a_App av Rel a).
       repeat split. eapply multi_An_AppLeft; eauto_lc.
       repeat econstructor; eauto_lc.
       eapply Path_to_Path; eauto_lc.
       simpl. autorewcs. congruence.
    ++ move: (multi_preservation MS H) => TC. inversion TC.
       move: (values_have_value_types GG H9 H3) => VT.
       move: (consistent_a_Pi GG VT H11) => [A' [B' EQ]]. subst.
       pose VV := H3. clearbody VV.
       eapply An_Push with (b:=a) in H3; try eapply H11; try reflexivity.
       eexists.
       split. eapply multi_trans.
       eapply multi_An_AppLeft; eauto_lc.
       eapply multi_step; eauto_lc.
       eapply multi_refl; eauto_lc.
       repeat econstructor; eauto_lc.
       split.
       eapply CC; econstructor; eauto_lc.
       econstructor; eauto_lc.
       eapply Path_to_Path; eauto_lc.
       simpl in EE. simpl. congruence.
    ++ exists (a_App av Irrel a).
       repeat split. eapply multi_An_AppLeft; eauto_lc.
       repeat econstructor; eauto_lc.
       eapply Path_to_Path; eauto_lc.
       simpl. autorewcs. congruence.
    ++ move: (multi_preservation MS H) => TC. inversion TC.
       move: (values_have_value_types GG H9 H3) => VT.
       move: (consistent_a_Pi GG VT H11) => [A' [B' EQ]]. subst.
       pose VV := H3. clearbody VV.
       eapply An_Push with (b:=a) in H3; try eapply H11; try reflexivity.
       eexists.
       split. eapply multi_trans.
       eapply multi_An_AppLeft; eauto_lc.
       eapply multi_step; eauto_lc.
       eapply multi_refl; eauto_lc.
       repeat econstructor; eauto_lc.
       split.
       eapply CC; econstructor; eauto_lc.
       econstructor; eauto_lc.
       eapply Path_to_Path; eauto_lc.
       simpl in EE. simpl. congruence.

  + move: (IHAnnTyping1 GG _ eq_refl V) => [av [MS [CV EE]]].
    inversion CV.
    ++ subst.
      exists (a_Conv av g).
      repeat split.
      eapply multi_An_ConvTerm; eauto using AnnDefEq_lc3.
      eapply CC; eauto using AnnDefEq_lc3.
      simpl. autorewcs. auto.
    ++ subst.
      have ?: lc_tm a0 by eauto using Value_lc.
      have ?: lc_co g by eauto using AnnDefEq_lc3.
      exists (a_Conv a0 (g_Trans g0 g)).
      split.
      eapply multi_trans.
      eapply multi_An_ConvTerm; eauto.
      eapply multi_step.
      eapply An_Combine; eauto.
      eapply multi_refl; eauto.
      split. eapply CC; eauto.
      simpl. simpl in EE. auto.
  + exists (a_CPi phi B).
    have ?: lc_tm (a_CPi phi B) by eapply AnnTyping_lc1; eauto.
    repeat split; try eapply multi_refl; eauto using Value_lc;
      simpl; auto.
    econstructor; eauto using AnnTyping_lc1, AnnPropWff_lc.
  + exists (a_CAbs phi a).
    have ?: lc_tm (a_CAbs phi a). eapply AnnTyping_lc1; eauto.
    repeat split; try eapply multi_refl; eauto using Value_lc;
      simpl; auto.
    econstructor; eauto using AnnTyping_lc1, AnnPropWff_lc.
  + 
    simpl in V; inversion V; subst;
    move: (IHAnnTyping GG (erase a1) eq_refl ltac:(auto)) => [av [MS [CV EE]]];
    inversion CV; subst.
    ++ exists (a_CApp av g).
       repeat split.
       eapply multi_An_CAppLeft; eauto_lc.
       repeat econstructor; eauto_lc.
       eapply Path_to_Path; eauto_lc.
       simpl. autorewcs. congruence.
    ++ move: (multi_preservation MS H) => TC. inversion TC.
       move: (values_have_value_types GG H9 H3) => VT.
       move: (consistent_a_CPi GG VT H11) => [A' [B' EQ]]. subst.
       pose VV := H3. clearbody VV.
       eapply An_CPush with (g:=g0) in H3; try eapply H11; try reflexivity.
       eexists.
       split.
       eapply multi_trans.
       eapply multi_An_CAppLeft; eauto_lc.
       eapply multi_step; eauto_lc.
       eapply multi_refl; eauto_lc.
       repeat econstructor; eauto_lc.
       split.
       eapply CC; econstructor; eauto_lc.
       eapply Path_to_Path; eauto_lc.
       simpl in EE. simpl. congruence.
Qed.

Ltac solve_irrelevant y AA b0 h0 :=
  match goal with
    [ H1 : irrelevant _ _ _ |- _ ] => inversion H1 end;
  match goal with
    [ H4 : forall x A, binds x _ _ -> x `notin` _ |- _ ] =>
    simpl in H4; econstructor; eauto;
    try (intros y AA b0; move: (H4 y AA b0) => h0; fsetdec) end.

Lemma paths_arent_abs :
  forall a T, Path T a -> forall rho b, a = a_UAbs rho b -> False.
Proof.
  intros a T P.
  induction P; intros r b0 EQ;
    try  destruct rho; simpl in *; inversion EQ.
Qed.

Ltac no_paths:=
  match goal with
    [ EE : erase (a_App ?b0 ?rho ?a) = a_UAbs _ ?b, H : Path ?T ?b0 |- _ ] =>
    destruct rho; simpl in EE;
    match goal with
      [ FF : ?a = a_UAbs _ ?b |- _ ] =>
      have P: (Path T a); by eauto using lc_tm_erase end end.

Ltac induction_a0 :=
  let IR := fresh  in
  let a0' := fresh in
  let y := fresh in
  let AA := fresh in
  let b0 := fresh in
  let h0 := fresh in
  match goal with
    [ IHa0 : ∀ A0 : tm, irrelevant ?G (dom ?G) ?a0 → _,
        H1 : irrelevant ?G _ (a_Conv ?a0 ?g),
        H2 : AnnTyping ?G (a_Conv ?a0 ?g) ?A0 |- _ ] =>
    inversion H2; subst;
    (have IR: irrelevant G (dom G) a0 by solve_irrelevant y AA b0 h0);
    move: (IHa0 _ IR ltac:(eauto) ltac:(auto)) =>
    [a0' [? ?]];
    exists (a_Conv a0' g);
    split; [ eapply multi_An_ConvTerm; eauto with lc | simpl; auto ]
  end.

Lemma reduction_annotation : forall a a',
    reduction_in_one a a' ->
    forall G a0 A0, irrelevant G (dom G) a0 -> AnnTyping G a0 A0 -> erase a0 = a ->
    exists a0', multi (head_reduction G) a0 a0' /\ erase a0' = a'.
Proof.
  intros a a' H.
  induction H.
  - 
    intros.
    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst.
    + inversion H2. subst.
      pick fresh x for (L \u L0 \u (fv_tm a0_2) \u dom G \u fv_tm a').
      move: (H11 x ltac:(auto)) => RC. inversion RC. subst. clear H11.
      move: (H10 x ltac:(auto)) => T2. clear H10.
      inversion H1.
      have IR: irrelevant ((x ~ Tm a0_1) ++ G) (dom (x ~ Tm a0_1 ++ G))
                       (open_tm_wrt_tm a0_2 (a_Var_f x)).
      econstructor; eauto.
      { intros x0 A0 b0.
        destruct (binds_cons_1 _ x0 x _ _ _ b0).
        + split_hyp.
          inversion H9. subst.
          autorewcshyp H4.  auto.
        + move: (binds_In _ _ _ _ H7) => h0.
          have NE: x0 <> x. fsetdec.
          move: (H5 _ _ H7) => NI. simpl in NI.
          simpl_erase.
          move: (fv_tm_tm_tm_open_tm_wrt_tm_upper (erase a0_2) (a_Var_f x)) => h1.
          simpl in h1. fsetdec.
      }
      { eapply AnnGood_add_tm; eauto. }
      have h1: erase (open_tm_wrt_tm a0_2 (a_Var_f x)) =
               open_tm_wrt_tm (erase_tm a0_2) (a_Var_f x).
      simpl_erase. auto.
      move: (H0 x ltac:(auto) _ _ _ IR T2 h1) => [a0' [ms ee]].
      exists (a_Abs Irrel a0_1 (close_tm_wrt_tm x a0')).
      split.
      eapply multi_An_AbsTerm_exists with (x:=x);
        autorewrite with lngen; auto.
      simpl_erase. rewrite ee.
      simpl. autorewrite with lngen. auto.
    + inversion H2.
    + induction_a0.
  -  
    intros.
    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst.
    + inversion H1. simpl in H4.
      inversion H2. subst.
      have I1: irrelevant G (dom G) a0_1.
      solve_irrelevant y AA b0 h0.
      move: (IHreduction_in_one _ _ _ I1 H11 eq_refl) => [a0_1' [MS E']].
      exists (a_App a0_1' Rel a0_2).
      split.
      eapply multi_An_AppLeft; eauto using AnnTyping_lc1.
      simpl. autorewcs. congruence.
    + induction_a0.
  -  
    intros.
    dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst.
    + inversion H1. simpl in H4.
      inversion H2. subst.
      have I1: irrelevant G (dom G) a0_1.
      solve_irrelevant y AA b0 h0.
      move: (IHreduction_in_one _ _ _ I1 H8 eq_refl) => [a0_1' [MS E']].
      exists (a_App a0_1' Irrel a0_2).
      split.
      eapply multi_An_AppLeft; eauto using AnnTyping_lc1.
      simpl. autorewcs. congruence.
    + induction_a0.
  -  
    intros.
    match goal with
      [ H2 : erase ?a0 = _ |- _ ] =>
      dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst
    end.
    + induction_a0.
    + ann_invert_clear.
      have I: irrelevant G (dom G) a0. solve_irrelevant y AA b0 h0.
      match goal with
        [ H7 : AnnTyping ?G a0 ?A |- _ ] =>
        move: (IHreduction_in_one _ _ _ I H7 eq_refl) => [a0_1' [MS E']]
      end.
      exists (a_CApp a0_1' g).
      split. eapply multi_An_CAppLeft; eauto with lc.
      simpl. autorewcs. congruence.
  - 
    intros.
    
    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst.
    + 
      ann_invert_clear.
      inversion H1.
      have ?: Value (a_UAbs Rel v) by eauto.
      move: (erased_Value_reduces_to_CoercedValue H10 H4 H5 ltac:(auto)) =>
      [av ?]. split_hyp.
      move: (multi_preservation H6 H10) => Tav.
      
      match goal with [ H : CoercedValue av |- _ ] => inversion H; subst end.
      ++ 
         match goal with [ H10 : Value av , H9 : erase av = _ |- _ ] =>
            inversion Tav; subst; inversion H10; subst; simpl in H9; inversion H9 end.
         exists (open_tm_wrt_tm a a0_2).
         split.
         eapply multi_trans with (b:= a_App (a_Abs Rel A a) Rel a0_2).
         eapply multi_An_AppLeft; eauto_lc.
         eapply multi_step; eauto_lc.
         eapply multi_refl; eauto.
         { lc_inversion c. subst.
           pick fresh y.
           rewrite (tm_subst_tm_tm_intro y); auto.
           eapply tm_subst_tm_tm_lc_tm; eauto using AnnTyping_lc1. }
         rewrite open_tm_erase_tm. auto.
         
         no_paths.
      ++ 
         have LC: lc_tm a0_1 by eauto using AnnTyping_lc1.
         
         inversion H1.
         ann_invert_clear.
         match goal with
           [ H4 : AnnGood _ _,  H20 : AnnDefEq G (dom G) g A0 (a_Pi Rel A B),
             H18 : AnnTyping G a A0, H11: Value a |- _ ] =>
         move: (values_have_value_types H4 H18 H11) => VT;
         move: (consistent_a_Pi H4 VT H20) => [A' [B' EQ]]; subst;
         move: (An_Push _ _ _ _ a0_2 _ _ _ _ _ _ H11 H20 eq_refl eq_refl)=> RED end.
         have TA': AnnTyping G A' a_Star.
           { move: (AnnTyping_regularity H17) => T1. inversion T1. auto. }
         have Tb': AnnTyping G (a_Conv a0_2 (g_Sym (g_PiFst g))) A'.
           { eapply An_Conv; eauto.
             eapply An_Sym.  eauto. eauto using AnnTyping_regularity.
             eapply An_Refl; eauto. eauto with ctx_wff.
             eapply An_PiFst; eauto. }

         simpl in *.
         match goal with
           [ H10: Value ?a, H9 : erase_tm ?a = _ , Ta : AnnTyping G ?a _ |- _ ] =>
           inversion Ta; subst; inversion H10; subst; simpl in H9; inversion H9 end.

         eexists.
         split.
         
         eapply multi_trans with (b:= a_App (a_Conv (a_Abs Rel A' a0) g) Rel a0_2).
         eapply multi_An_AppLeft; eauto_lc.

         eapply (multi_step _ RED).

         eapply multi_step.
         eapply An_ConvTerm. eauto using AnnTyping_lc1, AnnDefEq_lc3.
         eapply An_AppAbs; eauto using AnnTyping_lc1.

         eapply multi_refl.
         { lc_inversion c. repeat econstructor; eauto_lc. }

         simpl_erase. auto.

         destruct rho.
         +++ have P: Path T (a_App (erase v) Rel (erase a0)); by eauto
                                                                    using lc_tm_erase.
         +++ have P: Path T (a_App (erase v) Irrel a_Bullet); by eauto using lc_tm_erase.
    + 
      induction_a0.
  - 
    intros.
    dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst.
    + 
      ann_invert_clear.
      inversion H0.
      match goal with [H12 : AnnTyping G a0_1 (a_Pi Irrel A B),
                       H4  : AnnGood G (dom G),
                       H6  : erase_tm a0_1 = a_UAbs Irrel v |- _ ] =>
      move: H12 => Ta01;
      move: (erased_Value_reduces_to_CoercedValue Ta01 H4 H6
             ltac:(auto)) => [av [RE ?]];
      split_hyp end.
      move: (multi_preservation RE Ta01) => Tav.
      
      match goal with [ H : CoercedValue av |- _ ] => inversion H; subst end.
      ++ 
         match goal with [ H10 : Value av , H9 : erase av = _ |- _ ] =>
            inversion Tav; subst; inversion H10; subst; simpl in H9; inversion H9 end.
         exists (open_tm_wrt_tm a a0_2).
         split.
         eapply multi_trans with (b:= a_App (a_Abs Irrel A a) Irrel a0_2).
         eapply multi_An_AppLeft; eauto_lc.
         eapply multi_step; eauto_lc.
         eapply multi_refl; eauto.
         { lc_inversion c. subst.
           pick fresh y.
           rewrite (tm_subst_tm_tm_intro y); auto.
           eapply tm_subst_tm_tm_lc_tm; eauto using AnnTyping_lc1. }
         {
         
           simpl_erase.
           pick fresh x.
           move: (H16 x ltac:(auto)) => RC. inversion RC.
           rewrite (tm_subst_tm_tm_intro x (erase a)).
           replace (a_Var_f x) with (erase (a_Var_f x)); auto.
           rewrite open_tm_erase_tm.
           rewrite tm_subst_tm_tm_fresh_eq; auto.
           rewrite (tm_subst_tm_tm_intro x (erase a)).
           replace (a_Var_f x) with (erase (a_Var_f x)); auto.
           rewrite open_tm_erase_tm.
           rewrite tm_subst_tm_tm_fresh_eq; auto.
           apply fv_tm_erase_tm; auto.
           apply fv_tm_erase_tm; auto.
         }

         no_paths.
      ++ 
         have LC: lc_tm a0_1 by eauto using AnnTyping_lc1.
         
         inversion H0.
         ann_invert_clear.
         match goal with
           [ H4 : AnnGood _ _,  H20 : AnnDefEq G (dom G) g A0 (a_Pi Irrel A B),
             H18 : AnnTyping G a A0, H11: Value a |- _ ] =>
         move: (values_have_value_types H4 H18 H11) => VT;
         move: (consistent_a_Pi H4 VT H20) => [A' [B' EQ]]; subst;
         move: (An_Push _ _ _ _ a0_2 _ _ _ _ _ _ H11 H20 eq_refl eq_refl)=> RED;
         have TA': AnnTyping G A' a_Star by
           (move: (AnnTyping_regularity H18) => T1; inversion T1; auto)
         end.
         have Tb': AnnTyping G (a_Conv a0_2 (g_Sym (g_PiFst g))) A'.
           { eapply An_Conv; eauto.
             eapply An_Sym.  eauto. eauto using AnnTyping_regularity.
             eapply An_Refl; eauto. eauto with ctx_wff.
             eapply An_PiFst; eauto. }

         simpl in *.
         match goal with
           [ H10: Value ?a, H9 : erase_tm ?a = _ , Ta : AnnTyping G ?a _ |- _ ] =>
           inversion Ta; subst; inversion H10; subst; simpl in H9; inversion H9 end.

         eexists.
         split.
         
         eapply multi_trans with (b:= a_App (a_Conv (a_Abs Irrel A' a0) g) Irrel a0_2).
         eapply multi_An_AppLeft; eauto_lc.

         eapply (multi_step _ RED).

         eapply multi_step.
         eapply An_ConvTerm. eauto using AnnTyping_lc1, AnnDefEq_lc3.
         eapply An_AppAbs; eauto using AnnTyping_lc1.

         eapply multi_refl.

         { lc_inversion c. repeat econstructor; eauto_lc.
           pick fresh y.
           move: (H22 y ltac:(auto)) => h0.
           rewrite (tm_subst_tm_tm_intro y); auto.
           apply tm_subst_tm_tm_lc_tm; eauto_lc.
         }

         {
           simpl_erase.
           pick fresh x.
           move: (H22 x ltac:(auto)) => RC. inversion RC.
           rewrite (tm_subst_tm_tm_intro x (erase a0)).
           replace (a_Var_f x) with (erase (a_Var_f x)); auto.
           rewrite open_tm_erase_tm.
           rewrite tm_subst_tm_tm_fresh_eq; auto.
           rewrite (tm_subst_tm_tm_intro x (erase a0)).
           replace (a_Var_f x) with (erase (a_Var_f x)); auto.
           rewrite open_tm_erase_tm.
           rewrite tm_subst_tm_tm_fresh_eq; auto.
           apply fv_tm_erase_tm; auto.
           apply fv_tm_erase_tm; auto.
         }

         destruct rho.
         +++ have P: Path T (a_App (erase v) Rel (erase a0)); by eauto
                                                                    using lc_tm_erase.
         +++ have P: Path T (a_App (erase v) Irrel a_Bullet); by eauto using lc_tm_erase.
    + 
      induction_a0.
  - 
    intros.
    match goal with
      [ H3 : erase a0 = _ |- _ ] =>
    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst
    end.
    +  
      induction_a0.

    + 
      clear IHa0.
      ann_invert_clear.
      match goal with
        [ H0 : irrelevant _ _ _ |- _ ] => inversion H0
      end.
      have ?: Value (a_UCAbs b) by eauto.
      match goal with
        [ H8 : AnnTyping G a0 _,
          H4 : AnnGood G (dom G),
          H5 : erase_tm a0 = _ |- _ ] =>
        move: (erased_Value_reduces_to_CoercedValue H8 H4 H5 ltac:(auto)) =>
        [av ?] ;  split_hyp end.
      match goal with
        [ H6 : multi (head_reduction G) a0 ?av,
          H8 : AnnTyping G a0 _ |- _ ] =>
        move: (multi_preservation H6 H8) => Tav
      end.
      
      match goal with [ H : CoercedValue av |- _ ] => inversion H; subst end.
      ++ 
        match goal with [ H10 : Value av , H9 : erase av = _ |- _ ] =>
        inversion Tav; subst; inversion H10; subst; try destruct rho;
        simpl in H9; inversion H9 end.
        subst.

        exists (open_tm_wrt_co a1 g).
        split.
        eapply multi_trans with (b := a_CApp (a_CAbs (Eq a b0 A1) a1) g).
        eapply multi_An_CAppLeft; eauto_lc.
        eapply multi_step.
        eapply An_CAppCAbs; eauto_lc.
        eapply multi_refl; eauto_lc.

        { invert_lc.
          eapply lc_body_tm_wrt_co; eauto_lc. }

        rewrite <- open_co_erase_tm2 with (g := g_Triv).
        auto.

      ++ 
         have LC: lc_tm a1 by eauto using Value_lc.
         
         match goal with
           [ H0 : irrelevant _ _ _ |- _ ] => inversion H0
         end.
         ann_invert_clear.
         match goal with
           [ H4 : AnnGood _ _,  H20 : AnnDefEq G (dom G) ?g0 A (a_CPi _ _),
             H18 : AnnTyping G a1 A, H11: Value a1 |- _ ] =>
         move: (values_have_value_types H4 H18 H11) => VT;
         move: (consistent_a_CPi H4 VT H20) => [phi' [B' EQ]]; subst;
         move : (An_CPush G a1 g0 g _ _ _ _ _ _ H11 H20 eq_refl eq_refl) => RED
         end.
         destruct phi' as [a' b' A'].
         have Tb':
           AnnDefEq G (dom G) (g_Cast g (g_Sym (g_CPiFst g0))) a' b'.
           { eapply An_Cast; eauto. }

         simpl in *.
         match goal with
           [ H10: Value ?a, H9 : erase_tm ?a = _ , Ta : AnnTyping G ?a _ |- _ ] =>
           inversion Ta; subst; inversion H10; subst; try destruct rho;
           simpl in H9; inversion H9 end.

         eexists.
         split.
         
         eapply multi_trans.

         eapply multi_An_CAppLeft; eauto_lc.

         eapply (multi_step _ RED).

         eapply multi_step.
         eapply An_ConvTerm. eauto using AnnTyping_lc1, AnnDefEq_lc3.
         eapply An_CAppCAbs; eauto_lc.

         eapply multi_refl.

         { lc_inversion c. repeat econstructor; eauto_lc. }

         simpl_erase.
         rewrite <- open_co_erase_tm2 with (g := g_Triv).
         auto.

  - 
    intros.
    dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst.

    + unfold toplevel in H. unfold erase_sig in H.
      destruct (@binds_map_3 _ _ erase_csort F (Ax a A) an_toplevel H).
      split_hyp. destruct x; inversion H3. subst.

      exists a0. repeat split.
      eapply multi_step. eauto.
      eapply multi_refl.
      eauto using AnnTyping_lc1, an_toplevel_closed.

    + 
      induction_a0.

Unshelve. all: auto.
Qed.

End fc_consist.
