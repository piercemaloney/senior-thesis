Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)



Require Export FcEtt.tactics.

Require Export FcEtt.imports.

Require Export FcEtt.ett_inf.

Require Export FcEtt.ett_ott.

Require Export FcEtt.ett_ind.

Require Export FcEtt.ext_wf.

Require Export FcEtt.ett_par.

Require Export FcEtt.ett_inf_cs.



Require Import FcEtt.erase_syntax.
(* FcEtt.erase_syntax:
Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).

Lemma erase_dom : forall G, dom G = dom (erase_context G).

Lemma path_erase : forall T p, Path T p -> Path T (erase p).

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end. *)

Require Import FcEtt.fc_invert.
(* FcEtt.fc_invert:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.
Require Import FcEtt.fset_facts.

Require Import FcEtt.ett_ott.
Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.

Require Import FcEtt.erase_syntax.
Require Export Metalib.CoqEqDec.
Require Import Coq.Logic.Decidable.
Require Import Metalib.Metatheory.
Require Import FcEtt.fc_unique.

Require Import FcEtt.fc_wf.
Require Import FcEtt.toplevel.
Require Import FcEtt.fc_context_fv.

Module fc_invert (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig).
Import weak subst.

Module unique := fc_unique wf subst.
Import unique.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma AnnTyping_regularity :
  (forall G a A, AnnTyping G a A -> AnnTyping G A a_Star).

Lemma AnnPropWff_regularity :
  forall G A B A1, AnnPropWff G (Eq A B A1) -> exists B1 g,
      AnnTyping G A A1 /\ AnnTyping G B B1 /\ AnnDefEq G empty g A1 B1.

Lemma erase_pi : forall G AB0 rho A B S, erase AB0 = (a_Pi rho A B) -> AnnTyping G AB0 S ->
  exists A1 B0, erase AB0 = erase (a_Pi rho A1 B0) /\ erase A1 = A /\ erase B0 = B /\ AnnTyping G (a_Pi rho A1 B0) a_Star.

Lemma erase_cpi : forall AB0 A B G S,
    erase AB0 = (a_CPi A B) -> AnnTyping G AB0 S ->
    exists A1 B0, erase AB0 = erase (a_CPi A1 B0) /\ erase_constraint A1 = A /\ erase B0 = B
             /\ AnnTyping G (a_CPi A1 B0) a_Star.

Lemma erase_app_Rel :
  forall AB0 A B C G, erase AB0 = (a_App A Rel B) -> AnnTyping G AB0 C ->
  exists A1 B0 g D, erase AB0 = erase (a_App A1 Rel B0) /\ erase A1 = A /\ erase B0 = B /\
          AnnTyping G (a_App A1 Rel B0) D /\ AnnDefEq G (dom G) g C D.

Lemma erase_app_Irrel :
  forall AB0 A C G, erase AB0 = (a_App A Irrel a_Bullet) -> AnnTyping G AB0 C ->
  exists A1 B0 g D, erase AB0 = erase (a_App A1 Irrel B0) /\ erase A1 = A /\
          AnnTyping G (a_App A1 Irrel B0) D /\ AnnDefEq G (dom G) g C D.

Lemma erasure_compatible : forall G a A (H1 :AnnTyping G a A),
    forall b B (H2 : AnnTyping G b B)
      (E : erase a = erase b)
      (F : erase A = erase B),
    exists g1, AnnDefEq G (dom G) g1 a b.

Lemma AnnDefEqAnnIso_regularity :
  (forall G0 a A, AnnTyping G0 a A -> True ) /\
  (forall G0 phi,   AnnPropWff G0 phi -> True ) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 AnnPropWff G p1 /\ AnnPropWff G p2) /\
  (forall G D g A B,   AnnDefEq G D g A B ->
           exists C1 C2 g', AnnTyping G A C1 /\ AnnTyping G B C2 /\ AnnDefEq G (dom G) g' C1 C2) /\
  (forall G0, AnnCtx G0 -> True).

Definition  AnnDefEq_regularity :
    (forall G D g A B,   AnnDefEq G D g A B ->
                    exists C1 C2 g', AnnTyping G A C1 /\ AnnTyping G B C2
                                /\ AnnDefEq G (dom G) g' C1 C2) :=
  fourth AnnDefEqAnnIso_regularity.

Definition AnnIso_regularity :
  forall G D g phi1 phi2, AnnIso G D g phi1 phi2 ->
                     AnnPropWff G phi1 /\ AnnPropWff G phi2 :=
  third AnnDefEqAnnIso_regularity.

  Lemma An_Sym2
    : ∀ (G : context) (D : available_props) (g : co) (a b : tm),
      AnnDefEq G D g b a → AnnDefEq G D (g_Sym g) a b.

Lemma An_Trans2
     : ∀ (G : context) (D : available_props) (g1 g2 : co)
       (a b a1 : tm),
       AnnDefEq G D g1 a a1
       → AnnDefEq G D g2 a1 b
       → AnnDefEq G D (g_Trans g1 g2) a b .

Lemma erase_a_Const : forall G0 a0 A0 A1 T,
       erase a0 = a_Const T ->
       binds T (Cs A1) an_toplevel ->
       AnnTyping G0 a0 A0   ->
       exists g, AnnDefEq G0 (dom G0) g A0 A1.

Lemma erase_capp :
  forall AB0 C G, AnnTyping G AB0 C -> forall A, erase AB0 = (a_CApp A g_Triv) ->
  exists a1 g0 g D, erase AB0 = erase (a_CApp a1 g0) /\ erase a1 = A /\
          AnnTyping G (a_CApp a1 g0) D /\ AnnDefEq G (dom G) g C D.

Lemma An_AppCong2 : ∀ (G : context) (D : available_props) rho (g1 g2 : co)
       (a1 a2 b1 b2 A B : tm),
       AnnDefEq G D g1 a1 b1
       → AnnDefEq G D g2 a2 b2
         → AnnTyping G (a_App a1 rho a2) A
           → AnnTyping G (a_App b1 rho b2) B
           → AnnDefEq G D (g_AppCong g1 rho g2) (a_App a1 rho a2) (a_App b1 rho b2).

Lemma An_CAppCong2 :
      ∀ (G : context) (D : available_props) (g1 g2 g3 : co) (a1 b1 a2 b2 a3 b3 A B : tm),
       AnnDefEq G D g1 a1 b1
       → AnnDefEq G (dom G) g2 a2 b2
       → AnnDefEq G (dom G) g3 a3 b3
       → AnnTyping G (a_CApp a1 g2) A
       → AnnTyping G (a_CApp b1 g3) B
       → AnnDefEq G D (g_CAppCong g1 g2 g3) (a_CApp a1 g2) (a_CApp b1 g3).

Lemma An_Trans'
     : ∀ (G : context) (D : available_props) (g1 g2 : co)
       (a b a1 : tm),
       AnnDefEq G D g1 a a1
       → AnnDefEq G D g2 a1 b
       → exists g, AnnDefEq G D g a b .

Lemma An_Sym'
   : ∀ (G : context) (D : available_props) (g : co) (a b : tm),
       AnnDefEq G D g b a → exists g, AnnDefEq G D g a b.

Lemma An_Refl_Star : forall G D a b A,
     erase a = erase b -> AnnTyping G b a_Star ->
     AnnTyping G a A -> erase A = a_Star ->
     exists g, AnnDefEq G D g a b.

Lemma An_IsoRefl2_derivable  : ∀ (G : context) (D : available_props) (phi1 phi2 : constraint),
       AnnPropWff G phi1
       → AnnPropWff G phi2
       → erase_constraint phi1 = erase_constraint phi2 →
       exists g,
       AnnIso G D g phi1 phi2.

Lemma An_Pi_exists2
     : ∀ (x : atom) (G : list (atom * sort)) (rho : relflag) (A B : tm),
       x `notin` union (dom G) (fv_tm_tm_tm B)
       → AnnTyping ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
       → AnnTyping G (a_Pi rho A B) a_Star.

Lemma An_Abs_exists2
  : ∀ (x : atom) (G : context) (rho : relflag) (A a B : tm),
    x `notin` union (dom G) (union (fv_tm_tm_tm a) (fv_tm_tm_tm B))
    → AnnTyping ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    → RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x)))
    → AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

Lemma An_CPi_exists2
  : ∀ (c : atom) (G : context) (phi : constraint) (B : tm),
       c `notin` union (dom G) (fv_co_co_tm B)
       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
       → AnnTyping G (a_CPi phi B) a_Star.

Lemma An_CAbs_exists2
   : ∀ (c : atom) (G : context) (phi : constraint) (a B : tm),
       c `notin` union (dom G) (union (fv_co_co_tm a) (fv_co_co_tm B))
       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c))
       → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

Lemma An_Fam2 :  ∀ (G : context) (F : tyfam) (A a : tm),
       AnnCtx G
       → binds F (Ax a A) an_toplevel
       → AnnTyping G (a_Fam F) A.

Lemma An_AbsCong_exists2
      : ∀ (x1 x2 : atom) (G : context) (D : available_props) (rho : relflag) (g1 g2 : co)
        (A1 b1 A2 b3 b2 B : tm),
        x1 `notin` union (dom G) (union (fv_tm_tm_tm b1) (union (fv_tm_tm_tm b2) (fv_tm_tm_co g2)))
        → x2 `notin` union (dom G) (union (fv_tm_tm_tm b2) (union (fv_tm_tm_tm b3) (fv_tm_tm_co g1)))
          → AnnDefEq G D g1 A1 A2
            → AnnDefEq ([(x1, Tm A1)]++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
              → open_tm_wrt_tm b3 (a_Var_f x2) = open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1))
                  → AnnTyping G A2 a_Star
                    → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
                      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
                        → AnnTyping G (a_Abs rho A1 b2) B
                          → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

 Lemma An_CPiCong_exists2
      : ∀ (c : atom) (G : context) (D : available_props)
        (g1 g3 : co) (phi1 : constraint) (B1 : tm)
        (phi2 : constraint) (B3 B2 : tm),
        AnnIso G D g1 phi1 phi2
        → c
          `notin` (union (dom G)
                   (union D
                    (union (fv_co_co_tm B2)
                       (union (fv_co_co_tm B1)
                          (union (fv_co_co_co g3)
                              (union (fv_co_co_co g1)
                                     (fv_co_co_tm B3)))))))
          → AnnDefEq ([(c, Co phi1)] ++ G) D
                     (open_co_wrt_co g3 (g_Var_f c))
                     (open_tm_wrt_co B1 (g_Var_f c))
                     (open_tm_wrt_co B2 (g_Var_f c))
          → open_tm_wrt_co B3 (g_Var_f c) =
            open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1))
          → AnnTyping G (a_CPi phi1 B1) a_Star
          → AnnTyping G (a_CPi phi1 B2) a_Star
          → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1) (a_CPi phi2 B3).

End fc_invert. *)

Require Import FcEtt.ext_consist.
(* FcEtt.ext_consist:
Require Import FcEtt.sigs.

Require Import Omega.

Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.tactics.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.
Require Export FcEtt.ett_par.
Require Export FcEtt.erase_syntax.
Require Import FcEtt.ext_red_one.
Require Import FcEtt.ext_red.

Require Import FcEtt.ext_wf.

Module ext_consist (invert : ext_invert_sig)(fc_wf: fc_wf_sig).
Import invert.
Import fc_wf.

Module red_one := ext_red_one invert.
Export red_one.

Module red := ext_red invert.
Export red.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Definition Good (G : context) (D : available_props):=
  erased_context G /\
  forall c1 A B1 T1,
    binds c1 (Co (Eq A B1 T1)) G
    -> c1 `in` D
    -> exists C, Par G D A C /\ Par G D B1 C.

Lemma open2 :
  forall x b b' S D a a',
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm a ->
    erased_tm b ->
    erased_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    Par S D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)) ->
    Par S D b b' ->
    Par S D (open_tm_wrt_tm a b) (open_tm_wrt_tm a' b').

Lemma a_Pi_head : forall S G b A rho B,
    Par S G (a_Pi rho A B) b -> exists A' B' L,
      b = a_Pi rho A' B' /\ Par S G A A' /\
      (forall x, x `notin` L -> Par S G (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x))).

Lemma Par_Abs_inversion : forall G D a b rho,
    Par G D (a_UAbs rho a) b ->
    (exists a', b = (a_UAbs rho a') /\
          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->
               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))
    \/
    (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' rho (a_Var_f x)) /\ rho = Rel)
    \/ (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' rho a_Bullet) /\ rho = Irrel). 

Lemma Par_Abs_inversion_Rel : forall G D a b,
    Par G D (a_UAbs Rel a) b ->
    (exists a', b = (a_UAbs Rel a') /\
          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->
               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))
    \/
    (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' Rel (a_Var_f x))).

Lemma Par_Abs_inversion_Irrel : forall G D a b,
    Par G D (a_UAbs Irrel a) b ->
    (exists a', b = (a_UAbs Irrel a') /\
          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->
               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))
    \/ (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->
          open_tm_wrt_tm a (a_Var_f x) = a_App a' Irrel a_Bullet)). 

Lemma Par_CAbs_inversion : forall G D a b,
    Par G D (a_UCAbs a) b ->
    (exists a', b = (a_UCAbs a') /\
          forall c, c `notin` fv_co_co_tm a \u fv_co_co_tm a' ->
               Par G D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c)))
    \/ (exists a', Par G D a' b /\ (forall c, c `notin`  fv_co_co_tm a ->
          open_tm_wrt_co a (g_Var_f c) = a_CApp a' g_Triv)). 

Lemma copen2 :
  forall c (b: co) S D a a',
    lc_co b ->
    c `notin` fv_co_co_tm a' \u fv_co_co_tm a ->
    Par S D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c)) ->
    Par S D (open_tm_wrt_co a b) (open_tm_wrt_co a' b).

Ltac try_refl :=
  try match goal with
      | [ P2 : Par _ _ _ ?b |- _ ] =>
        exists b; assert (lc_tm b); try eapply Par_lc2; eauto; try split; eauto; fail
      end.

Ltac invert_equality :=
  match goal with
  | [ H : _ = _ |- _ ] =>
    inversion H
  end.

  Ltac try_refl_left :=
  try match goal with
      | [ P2 : Par _ _ ?b ?b |- exists cc:tm, Par ?S ?D ?b cc /\ Par ?S ?D ?a2 cc ] =>
        exists a2; assert (lc_tm a2); try eapply Par_lc2; eauto; try split; eauto; fail
      end.
  Ltac try_refl_right :=
  try match goal with
      | [ P2 : Par _ _ ?b ?b |- exists cc:tm, Par ?S ?D ?a2 cc /\ Par ?S ?D ?b cc ] =>
        exists a2; assert (lc_tm a2); try eapply Par_lc2; eauto; try split; eauto; fail
      end.

  Ltac invert_erased :=
    match goal with
    | [ H : erased_tm ?a |- _ ] => inversion H; subst; clear H
    end.

  Ltac invert_erased_tm b :=
        let h0 := fresh in
        match goal with
          [ h : Par ?G ?D ?a b, h1: erased_tm ?a |- _ ] =>
          assert (h0 : erased_tm b);
          [ eapply (Par_erased_tm h); eauto | inversion h0; subst]
        end.

      Ltac eta_expand x :=
        let h1 := fresh in
      match goal with
       | [ H18 : ∀ x : atom,
              x `notin` ?L0
              → open_tm_wrt_tm ?a (a_Var_f x) = a_App ?b0 ?rho (a_Var_f x)
              |- _ ] =>
        pick fresh x for (L0 \u  fv_tm_tm_tm a \u fv_tm_tm_tm b0);
        move: (H18 x ltac:(auto)) => h1; clear H18;
        rewrite (@tm_subst_tm_tm_intro x a); auto; rewrite h1;
        simpl; destruct (@eq_dec tmvar _ x x); try done;
        rewrite tm_subst_tm_tm_fresh_eq; auto
       | [ H18 : ∀ x : atom,
              x `notin` ?L0
              → open_tm_wrt_tm ?a (a_Var_f x) = a_App ?b0 ?rho a_Bullet
              |- _ ] =>
        pick fresh x for (L0 \u  fv_tm_tm_tm a \u fv_tm_tm_tm b0);
        move: (H18 x ltac:(auto)) => h1; clear H18;
        rewrite (@tm_subst_tm_tm_intro x a); auto; rewrite h1;
        simpl; destruct (@eq_dec tmvar _ x x); try done;
        rewrite tm_subst_tm_tm_fresh_eq; auto
       | [ H18 : ∀ x : atom,
              x `notin` ?L0
              → open_tm_wrt_co ?a (g_Var_f x) = a_CApp ?b0 g_Triv
              |- _ ] =>
        pick fresh x for (L0 \u  fv_co_co_tm a \u fv_co_co_tm b0);
        move: (H18 x ltac:(auto)) => h1; clear H18;
        rewrite (@co_subst_co_tm_intro x a); auto; rewrite h1;
        simpl; destruct (@eq_dec tmvar _ x x); try done;
        rewrite co_subst_co_tm_fresh_eq; auto
      end.

      Ltac eta_case a'0 Y2 :=
         let x:= fresh in
         pick fresh x;
         rewrite (tm_subst_tm_tm_intro x a'0); auto;
         rewrite Y2; auto; simpl;
         rewrite (tm_subst_tm_tm_fresh_eq); auto;
         destruct eq_dec; try done;
         eauto; clear x.

Ltac invert_lc :=
  match goal with
    | [ H : lc_tm ?a |- _ ] => inversion H; subst; clear H
  end.

  Ltac use_size_induction a ac Par1 Par2 :=
  match goal with
  | [   IH : forall y: nat, ?T,
        H2 : Good ?G ?D,
        H3 : erased_tm a,
        H : Par ?G ?D a ?b0,
        H4 : Par ?G ?D a ?b1 |- _ ] =>
      move: (@IH (size_tm a) ltac:(omega) a ltac:(auto) _ _ _ H2 H3 H _ H4) => [ ac [Par1 Par2]]
  end.

  Ltac use_size_induction_open a0 x ac Par1 Par2 :=
      let h0 := fresh in
      let h1 := fresh in
      let h2 := fresh in
      let EQ1 := fresh in
      let EQ2 := fresh in
      match goal with
        | [  H : ∀ x : atom,
              x `notin` ?L
              → Par ?S ?D (?open_tm_wrt_tm a0 (?a_Var_f x)) ?b,
             H4: ∀ x : atom,
                 x `notin` ?L0
                 → Par ?S ?D (?open_tm_wrt_tm a0 (?a_Var_f x)) ?c,
             H1 : ∀ x : atom, x `notin` ?L1 →
    erased_tm (?open_tm_wrt_tm a0 (?a_Var_f x)) |- _ ] =>
    move: (H x ltac:(auto)) => h0; clear H;
    move: (H4 x ltac:(auto)) => h1; clear H4;
                               move: (H1 x ltac:(auto)) => h2; clear H1;
    move: (size_tm_open_tm_wrt_tm_var a0 x) => EQ1;
    move: (size_tm_open_tm_wrt_co_var a0 x) => EQ2;

    use_size_induction (open_tm_wrt_tm a0 (a_Var_f x)) ac Par1 Par2;
    clear h0; clear h1; clear h2; clear EQ1; clear EQ2
    end.

Ltac par_erased_open x J Par4 :=
  let K := fresh in
  let KK := fresh in
  let h0 := fresh in
  match goal with
  | [H13 : ∀ x : atom, x `notin` ?L →
                       Par ?G ?D (open_tm_wrt_tm ?a (a_Var_f x)) ?b,
     H4 : ∀ x : atom, x `notin` ?L1 → erased_tm  (open_tm_wrt_tm ?a (a_Var_f x))
       |- _ ] =>
    have: x `notin` L; auto => h0;
    pose K:= H13 x h0; clearbody K; clear h0;
    have: x `notin` L1; auto => h0;
    pose KK := H4 x h0; clearbody KK;
    pose J := subst3 x Par4 KK K;
    clearbody J;
    repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in J; [auto;
    simpl in J;
    destruct eq_dec; try congruence;
    repeat rewrite tm_subst_tm_tm_fresh_eq in J; auto
    | try apply (Par_lc2 Par4); auto
    | apply (Par_lc1 Par4); auto]
  end.

      Ltac finish_open_co a'0 :=
        let K := fresh in
        let J := fresh in
        let h0 := fresh in
      match goal with
      | H12 : forall c, c `notin` ?L -> Par ?G ?D (open_tm_wrt_co a'0 (g_Var_f c)) (open_tm_wrt_co ?b (g_Var_f c)) |- _ =>
        pick_fresh c;
        have: c `notin` L; auto => h0;
        pose K := H12 c h0; clearbody K;
        pose J := subst4 c lc_g_Triv K;
        clearbody J;
        repeat rewrite co_subst_co_tm_open_tm_wrt_co in J; eauto;
        simpl in J;
        destruct eq_dec; try congruence;
        repeat rewrite co_subst_co_tm_fresh_eq in J; eauto with lc

      end.

Lemma open_tm_wrt_tm_bullet_var_eq: forall a x, 
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    open_tm_wrt_tm a (a_Bullet) = open_tm_wrt_tm a (a_Var_f x).

Lemma open_tm_wrt_tm_inj_irrel: forall(a2 a1 : tm) (x1 : atom),
x1 `notin` fv_tm_tm_tm (open_tm_wrt_tm a2 (a_Var_f x1)) 
-> x1 `notin` fv_tm_tm_tm (open_tm_wrt_tm a1 (a_Var_f x1))
  -> open_tm_wrt_tm a2 a_Bullet = open_tm_wrt_tm a1 (a_Var_f x1)
    -> a2 = a1.

Lemma open_tm_wrt_co_triv_var_eq: forall a c, 
    c `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c)) ->
    open_tm_wrt_co a g_Triv = open_tm_wrt_co a (g_Var_f c).

Lemma open_tm_wrt_co_inj: forall(a2 a1 : tm) (c : atom),
c `notin` fv_co_co_tm (open_tm_wrt_co a2 (g_Var_f c)) 
-> c `notin` fv_co_co_tm (open_tm_wrt_co a1 (g_Var_f c))
  -> open_tm_wrt_co a2 g_Triv = open_tm_wrt_co a1 (g_Var_f c)
    -> a2 = a1.

Lemma erased_fv_co: forall a x, erased_tm a -> x `notin` fv_co_co_tm a.

Lemma confluence_size : forall n a, size_tm a <= n ->  forall S D a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

Lemma confluence : forall S D a a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

Lemma multipar_Star : forall S D A B, multipar S D A B -> A = a_Star -> B = a_Star.

Lemma multipar_Bullet : forall S D B, multipar S D a_Bullet B -> B = a_Bullet.

Inductive Path_consistent : const -> tm -> tm -> Prop :=
  PC_Const : forall T, Path_consistent T (a_Const T) (a_Const T)
| PC_App   : forall T a1 a2 b1 b2,
    erased_tm a2 -> erased_tm b2 ->
    Path_consistent T a1 b1 ->
    Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2)
| PC_AppIrrel : forall T a1 b1,
    Path_consistent T a1 b1 ->
    Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet)
| PC_CApp  : forall T a1 b1,
    Path_consistent T a1 b1 ->
    Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv).
Hint Constructors Path_consistent.

Lemma Path_consistent_Path1 : forall T a b, Path_consistent T a b -> Path T a.
Lemma Path_consistent_Path2 : forall T a b, Path_consistent T a b -> Path T b.

Lemma Path_consistent_erased1 : forall T a b, Path_consistent T a b -> erased_tm a.
Lemma Path_consistent_erased2 : forall T a b, Path_consistent T a b -> erased_tm b.
Hint Resolve Path_consistent_erased1 Path_consistent_erased2 : erased.

Lemma Path_consistent_Refl :
  forall a T, Path T a -> erased_tm a -> Path_consistent T a a.

Lemma Path_consistent_Trans_aux :
  forall b T,  Path T b -> forall a c, Path_consistent T a b -> Path_consistent T b c -> Path_consistent T a c.

Lemma Path_consistent_Trans : forall T a b c,
  Path_consistent T a b -> Path_consistent T b c -> Path_consistent T a c.

Lemma Path_consistent_Sym :
  forall T a b, Path_consistent T a b -> Path_consistent T b a.

Lemma Par_Path_consistent :
  forall S D a b T, Par S D a b -> Path T a -> erased_tm a -> Path_consistent T a b.

Lemma multipar_Path_consistent :
  forall S D a b T, multipar S D a b -> Path T a -> erased_tm a -> Path_consistent T a b.

Lemma Par_Path :
  forall S D a b T, Par S D a b -> Path T a -> Path T b.

Lemma multipar_Path : forall S D a b T ,
    multipar S D a b -> Path T a -> Path T b.

    Lemma Par_Path_consistent_App : forall T G D a1 a2 b1 b2,
        Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
        Par G D (a_App a1 Rel a2) ( a_App b1 Rel b2) ->
        Par G D a1 b1.

    Lemma Par_Path_consistent_AppIrrel : forall T G D a1 b1,
        Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->
        Par G D (a_App a1 Irrel a_Bullet) ( a_App b1 Irrel a_Bullet) ->
        Par G D a1 b1.

    Lemma Par_Path_consistent_CApp : forall T G D a1 b1,
        Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
        Par G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
        Par G D a1 b1.

    Lemma Par_Path_consistent_App2 : forall T G D a1 a2 b1 b2,
        Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
        Par G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->
        Par G D a2 b2.

    Lemma multipar_Path_consistent_App : forall G D a1 a2 b1 b2 T,
      multipar G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      multipar G D a1 b1.

    Lemma multipar_Path_consistent_AppIrrel : forall G D a1 b1 T,
      multipar G D (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->
      Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->
      multipar G D a1 b1.

     Lemma multipar_Path_consistent_App2 : forall G D a1 a2 b1 b2 T,
      multipar G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->
      multipar G D a2 b2.

    Lemma multipar_Path_consistent_CApp : forall G D a1 b1 T,
      multipar G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
      Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->
      multipar G D a1 b1.

Ltac binds_notbinds :=
    match goal with
    [ H0 : binds ?c (Ax ?T ?a) toplevel,
      H5 : forall (c : atom) a, not (binds c (Ax ?T a) an_toplevel) |- _  ] =>
      unfold not in H5; unfold toplevel in H0; unfold erase_sig in H0;
      apply binds_map_3 in H0; destruct H0 as (s' & EQ & B);
      destruct s'; simpl in EQ; inversion EQ; subst;
      apply H5 in B; contradiction
      end.

Lemma Par_Const : forall S D T b,
    Par S D (a_Const T) b -> b = a_Const T.

Lemma multipar_Const : forall S D T b,
    multipar S D (a_Const T) b ->
    (b = a_Const T).

Lemma multipar_Pi : forall S D rho A B, multipar S D A B -> forall A1 A2,
      A = a_Pi rho A1 A2 -> exists B1 B2, B = (a_Pi rho B1 B2).

Lemma multipar_CPi : forall S D A C, multipar S D A C -> forall A1 A2 A3 B, A = a_CPi (Eq A1 A2 A3) B -> exists B1 B2 B3 C2,
        C = (a_CPi (Eq B1 B2 B3) C2).

Lemma multipar_UAbs_Rel : forall S D a b x,
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm b ->
    multipar S D (a_UAbs Rel a) b ->
    (exists b2, b = (a_UAbs Rel b2))
    \/ (exists a1, exists a2, multipar S D (a_UAbs Rel a) (a_UAbs Rel a1) /\
               open_tm_wrt_tm a1 (a_Var_f x) = a_App a2 Rel (a_Var_f x)).

Lemma multipar_UAbs_Irrel : forall S D a b x,
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm b ->
    multipar S D (a_UAbs Irrel a) b ->
    (exists b2, b = (a_UAbs Irrel b2))
    \/ (exists a1, exists a2, multipar S D (a_UAbs Irrel a) (a_UAbs Irrel a1) /\
               open_tm_wrt_tm a1 (a_Var_f x) = a_App a2 Irrel a_Bullet).

Lemma multipar_CAbs : forall S D A C, multipar S D A C -> forall A1 A2 A3 B, A = a_CAbs (Eq A1 A2 A3) B -> exists B1 B2 B3 C2,
        C = (a_CAbs (Eq B1 B2 B3) C2).

Definition decide_Path : forall a, lc_tm a -> (exists T, Path T a) \/ (forall T, not (Path T a)).

Ltac step_left := apply consistent_a_Step_R; [auto |intro N; inversion N; inversion H0]; fail.
Ltac step_right := apply consistent_a_Step_L; [auto | intro N; inversion N; inversion H0]; fail.

Ltac multipar_step SIDE EQ :=
  match goal with
  | [ SIDE : multipar _ _ a_Star _ |- _ ] =>
    apply multipar_Star in SIDE; auto; rename SIDE into EQ
  | [ SIDE : multipar _ _ (a_Pi _ _ _) _ |- _ ] =>
    destruct (multipar_Pi SIDE eq_refl) as [b1' [b2' EQ]]
  | [ SIDE : multipar _ _ (a_CPi ?phi _) _ |- _ ] =>
    try (destruct phi); destruct (multipar_CPi SIDE eq_refl)
      as (B1' & B2' & C1' & C2' &  EQ)
  | [ SIDE : multipar _ _ (a_Const ?T) _ |- _ ] =>
    apply multipar_Const in SIDE; auto; rename SIDE into EQ
  | [ SIDE : Path_consistent _ _ _ |- _ ] =>
    rename SIDE into EQ
  end.

Lemma join_consistent : forall S D a b, joins S D a b -> consistent a b.

Lemma multipar_confluence_helper : forall S D a a1, Good S D -> erased_tm a -> multipar S D a a1
-> forall a2, Par S D a a2 -> exists e, Par S D a1 e /\ multipar S D a2 e.

Lemma multipar_confluence : forall S D a a1, Good S D -> erased_tm a -> multipar S D a a1
-> forall a2, multipar S D a a2 -> exists b, multipar S D a1 b /\ multipar S D a2 b.

Lemma multipar_append : forall S D a b c, multipar S D a b -> multipar S D b c -> multipar S D a c.

Lemma join_transitive : forall S D a b, Good S D -> joins S D a b -> forall c, joins S D b c -> joins S D a c.

Lemma join_symmetry: forall S D a b, joins S D a b -> joins S D b a.

Definition extends (G G2 : context) := exists G1, G = G1 ++ G2.

Lemma multipar_lc2: forall G D a1 a2, lc_tm a1 -> multipar G D a1 a2 -> lc_tm a2.

Hint Resolve multipar_context_independent : DB.

Lemma join_context_independent: forall G1 G2 D A B, erased_context G2 ->
                                             joins G1 D A B -> joins G2 D A B.

Lemma Good_NoAssn: forall c G D phi, erased_sort (Co phi) -> Good G D -> c `notin` D -> Good ((c, Co phi) :: G) D.

Hint Resolve Good_NoAssn.

Hint Resolve multipar_context_independent.

Lemma Good_add_tm: forall G D x A,
    erased_tm A -> Good G D -> Good ((x, Tm A)::G ) D.

Lemma Good_add_tm_2: forall G D x A, x `notin` dom G -> erased_tm A -> Good G D -> Good ((x, Tm A)::G ) (add x D).

Lemma multipar_app_left_Rel:
  forall a a' c' S D, lc_tm a -> multipar S D a' c' -> multipar S D (a_App a Rel a') (a_App a Rel c').

Lemma multipar_capp_left: forall a a' S D, multipar S D a a' -> multipar S D (a_CApp a g_Triv) (a_CApp a' g_Triv).

Lemma join_capp: forall a a' S D, joins S D a a' -> joins S D (a_CApp a g_Triv) (a_CApp a' g_Triv).

Lemma multipar_app_lr_Rel: forall a a' c c' S D, lc_tm a -> lc_tm a' -> multipar S D a c -> multipar S D a' c' -> multipar S D (a_App a Rel a') (a_App c Rel c').

Lemma multipar_app_lr_Irrel: forall a c S D, lc_tm a -> multipar S D a c -> multipar S D (a_App a Irrel a_Bullet) (a_App c Irrel a_Bullet).

Lemma join_app_Rel: forall a a' b b' S D, joins S D a b -> joins S D a' b' -> joins S D (a_App a Rel a') (a_App b Rel b').

Lemma join_app_Irrel: forall a b S D, joins S D a b -> joins S D (a_App a Irrel a_Bullet) (a_App b Irrel a_Bullet).

Lemma multipar_UAbs_exists :  ∀ (x : atom) (G : context) (D : available_props)
       (rho : relflag) (a a' : tm),
    x `notin` fv_tm_tm_tm a
       → multipar G D (open_tm_wrt_tm a (a_Var_f x)) a'
         → multipar G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma multipar_iapp : forall G D a c y L,
    y `notin` fv_tm_tm_tm a \u L ->
    (forall x, x `notin` L -> RhoCheck Irrel x (open_tm_wrt_tm a (a_Var_f x))) ->
    multipar G D (open_tm_wrt_tm a a_Bullet) c ->
    multipar G D (a_UAbs Irrel a) (a_UAbs Irrel (close_tm_wrt_tm y c)).

Lemma joins_iapp : forall S D a1 a2 L1 L2,
    (forall x, x `notin` L1 -> RhoCheck Irrel x (open_tm_wrt_tm a1 (a_Var_f x))) ->
    (forall x, x `notin` L2 -> RhoCheck Irrel x (open_tm_wrt_tm a2 (a_Var_f x))) ->
    joins S D (open_tm_wrt_tm a1 a_Bullet) (open_tm_wrt_tm a2 a_Bullet) ->
    joins S D (a_UAbs Irrel a1) (a_UAbs Irrel a2).

Lemma multipar_App_destruct_Rel : forall S D a1 a2 c,
    multipar S D (a_App a1 Rel a2) c ->
    (exists a1' a2',
        multipar S D (a_App a1 Rel a2) (a_App (a_UAbs Rel a1') Rel a2') /\
        multipar S D a1 (a_UAbs Rel a1') /\
        multipar S D a2 a2' /\
        multipar S D (open_tm_wrt_tm a1' a2') c) \/
    (exists a1' a2',
        multipar S D (a_App a1 Rel a2) (a_App a1' Rel a2') /\
        multipar S D a1 a1' /\
        multipar S D a2 a2').

Lemma multipar_App_destruct_Irrel : forall S D a1 c,
    multipar S D (a_App a1 Irrel a_Bullet) c ->
    (exists a1',
        multipar S D (a_App a1 Irrel a_Bullet) (a_App (a_UAbs Irrel a1') Irrel a_Bullet) /\
        multipar S D a1 (a_UAbs Irrel a1') /\ multipar S D (open_tm_wrt_tm a1' a_Bullet) c) \/
    (exists a1',
        multipar S D (a_App a1 Irrel a_Bullet) (a_App a1' Irrel a_Bullet) /\
        multipar S D a1 a1').

Lemma consistent_mutual:
  (forall S a A,   Typing S a A -> True) /\
  (forall S phi,   PropWff S phi -> True) /\
  (forall S D p1 p2, Iso S D p1 p2 -> Good S D -> (forall A1 B1 T1 A2 B2 T2, p1 = Eq A1 B1 T1 -> p2 = Eq A2 B2 T2-> (joins S D A1 A2 /\ joins S D B1 B2 /\ joins S D T1 T2))) /\
  (forall S D A B T,   DefEq S D A B T -> Good S D -> joins S D A B) /\
  (forall S,       Ctx S -> True).

Lemma consistent_defeq: forall S D A B T,   DefEq S D A B T -> Good S D -> joins S D A B.

Lemma no_aAbs : forall G rho A' a A, Typing G (a_Abs rho A' a) A -> False.

Lemma no_aCAbs : forall G A' a A, Typing G (a_CAbs A' a) A -> False.

Lemma Good_nil : forall D, Good nil D.

Lemma consistent_Star : forall A0,
    consistent a_Star A0 -> value_type A0 -> A0 = a_Star.

Definition irrelevant G D (a : tm) :=
  (forall x A, binds x (Tm A) G -> x `notin` fv_tm a) /\ Good G D.

Lemma irrelevant_Good : forall G D a, irrelevant G D a -> Good G D.

Ltac impossible_Path :=
  match goal with
     [H : Path ?T (a_Pi _ _ _) |- _] => inversion H
   | [H : Path ?T a_Star |- _] => inversion H
   | [H : Path ?T (a_CPi _ _) |- _] => inversion H
  end.

Ltac impossible_defeq :=
  let h0 := fresh in
  let VT := fresh in
  let VT2 := fresh in
  match goal with
  | [ H : DefEq ?G (dom ?G) ?B ?A ?C |- _ ] =>
    pose h0:= H; clearbody h0;
    apply consistent_defeq in h0; eauto;
    [apply join_consistent in h0;
     destruct (DefEq_lc H) as (l0 & l1 & l2); inversion l0; inversion l1; subst;
     have VT: value_type A; eauto;
     have VT2 : value_type B; eauto;
     inversion h0; subst; try impossible_Path;
     eauto; try done | eapply irrelevant_Good; eauto]
  end.

Lemma canonical_forms_Star : forall G a, irrelevant G (dom G) a ->
    Typing G a a_Star -> Value a -> value_type a.

Lemma DefEq_Star: forall A G D, Good G D -> value_type A -> DefEq G D A a_Star a_Star -> A = a_Star.

Lemma canonical_forms_Pi : forall G rho a A B, irrelevant G (dom G) a ->
    Typing G a (a_Pi rho A B) -> Value a ->
    (exists a1, a = a_UAbs rho a1) \/ (exists T, Path T a).

Lemma canonical_forms_CPi : forall G a phi B, irrelevant G (dom G) a ->
    Typing G a (a_CPi phi B) -> Value a ->
    (exists a1, a = a_UCAbs a1) \/ (exists T, Path T a).

Ltac show_irrelevant IR :=
        let x := fresh in
        let A0 := fresh in
        let B0 := fresh in
        let h0 := fresh in
        let h1 := fresh in
        unfold irrelevant in *;
        move: IR => [h0 h1]; split; auto;
        intros x A0 B0;  apply h0 in B0; simpl in B0; fsetdec.

Lemma notin_sub : forall x a b, x `notin` a -> b [<=] a -> x `notin` b.

Lemma progress : forall G a A, Typing G a A ->
                          irrelevant G (dom G) a ->
                          Value a \/ exists a', reduction_in_one a a'.

End ext_consist. *)

Require Import FcEtt.erase.
(* FcEtt.erase:
Require Import FcEtt.sigs.

Require Import FcEtt.utils.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.
Require Import FcEtt.imports.
Require Import FcEtt.tactics.
Require Import FcEtt.erase_syntax.
Require Import FcEtt.ext_red.  
Require Import FcEtt.fc_invert FcEtt.fc_unique.
Require Import FcEtt.ett_par.
Require Import FcEtt.toplevel.
Require Import FcEtt.fc_context_fv.

Module erase (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)
             (e_invert : ext_invert_sig).

Include e_invert.

Module e_red := ext_red e_invert.
Import e_red.

Import wf weak subst.

Module invert := fc_invert wf weak subst.
Module unique := fc_unique wf subst.
Import invert unique.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma Path_erase : forall T a, Path T a -> Path T (erase a).

Hint Constructors Typing PropWff Iso DefEq Ctx.

Ltac dispatch_rho  :=
  match goal with
  |  H11 : ∀ x : atom,
      ¬ x `in` ?L0 →
             RhoCheck ?rho x (erase_tm (open_tm_wrt_tm ?b1 (a_Var_f x)))
             |-
             ∀ x : atom,
               ¬ x `in` ?LL → RhoCheck ?rho x (open_tm_wrt_tm (erase_tm ?b1) (a_Var_f x))
           =>
   let Fr := fresh in
   let r' := fresh in
   intros x; intros;
   assert (FrL0 : x `notin` L0); eauto;
   move: (H11 x FrL0) => r';
   autorewcshyp r';
   rewrite -open_tm_erase_tm in r'; eapply r'
end.

Lemma erase_mutual :
  (forall G a A, AnnTyping G a A ->
          Typing (erase_context G) (erase a) (erase A)) /\
  (forall G phi, AnnPropWff G phi ->
          PropWff (erase_context G) (erase phi)) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
          Iso (erase_context G) D
              (erase_constraint p1) (erase_constraint p2)) /\
  (forall G D g a b,
      AnnDefEq G D g a b ->
      forall A, AnnTyping G a A ->
             DefEq (erase_context G) D (erase a) (erase b) (erase A)) /\
  (forall G, AnnCtx G -> Ctx (erase_context G) /\
    forall c t, binds c t G -> binds c (erase_sort t) (erase_context G)).

Definition AnnTyping_erase :
  (forall G a A, AnnTyping G a A ->
            Typing (erase_context G) (erase a) (erase A)) := first erase_mutual.
Definition AnnPropWff_erase :
  (forall G phi, AnnPropWff G phi ->
            PropWff (erase_context G) (erase phi)) := second erase_mutual.
Definition AnnIso_erase :
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
          Iso (erase_context G) D
              (erase_constraint p1) (erase_constraint p2)) := third erase_mutual.
Definition AnnDefEq_erase :
  (forall G D g a b,
      AnnDefEq G D g a b ->
      forall A, AnnTyping G a A ->
           DefEq (erase_context G) D (erase a) (erase b) (erase A)) := fourth erase_mutual.
Definition AnnCtx_erase :
  (forall G, AnnCtx G -> Ctx (erase_context G) /\
    forall c t, binds c t G -> binds c (erase_sort t) (erase_context G)) := fifth erase_mutual.

Lemma erasure_a_Star :
  forall G a A, AnnTyping G a A -> erase A = a_Star ->
           exists a', erase a = erase a' /\ AnnTyping G a' a_Star.

Lemma erasure_cvt :
    forall G a A, AnnTyping G a A -> forall B, erase A = erase B -> AnnTyping G B a_Star ->
                                    exists a', erase a = erase a' /\ AnnTyping G a' B.

Lemma AnnDefEq_invertb : forall G D g a b, AnnDefEq G D g a b ->
  exists A b' g, AnnTyping G a A /\ AnnTyping G b' A /\ erase b' = erase b /\ AnnDefEq G D g b b'.

Lemma erasure_AnnDefEq : forall G D g A'' B'' S A' B',
      AnnDefEq G D g A'' B'' ->
      AnnTyping G A'' S -> erase S = a_Star ->
      erase A'' = erase A' -> erase B'' = erase B' ->
      AnnTyping G A' a_Star -> AnnTyping G B' a_Star ->
      exists g', AnnDefEq G D g' A' B'.

Lemma AnnDefEq_invert_a_Star : forall G0 D g1 A1' A2' S,
      AnnDefEq G0 D g1 A1' A2' ->
      AnnTyping G0 A1' S ->
      erase S = a_Star ->
      exists A1'', exists A2'', exists g, erase A1'' = erase A1'
                       /\ erase A2'' = erase A2'
                       /\ AnnDefEq G0 D g A1'' A2''
                       /\ AnnTyping G0 A1'' a_Star
                       /\ AnnTyping G0 A2'' a_Star.

Lemma Path_to_Path : forall  a0, lc_tm a0 -> forall T a,
      Path T a -> erase a0 = a -> Path T a0.

Lemma annotation_mutual :
  (forall G a A, Typing G a A ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists a0 A0,
         (erase a0) = a /\
         (erase A0) = A /\
         AnnTyping G0 a0 A0) /\
  (forall G phi, PropWff G phi ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists phi0,
          erase_constraint phi0 = phi /\
          AnnPropWff G0 phi0) /\
  (forall G D p1 p2, Iso G D p1 p2 ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists g0 p1' p2',
       (erase_constraint p1') = p1 /\
       (erase_constraint p2') = p2 /\
       AnnIso G0 D g0 p1' p2') /\
  (forall G D a b A, DefEq G D a b A ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists g a0 b0 A0,
       (erase a0) = a /\
       (erase b0) = b /\
       (erase A0) = A /\
       AnnDefEq G0 D g a0 b0 /\ AnnTyping G0 a0 A0 /\ AnnTyping G0 b0 A0) /\
  (forall G, Ctx G -> True).

End erase. *)

Require Import FcEtt.fc_head_reduction.
(* FcEtt.fc_head_reduction:
Require Import FcEtt.sigs.
Require Import FcEtt.fc_wf.

Module fc_head_reduction (e_invert : ext_invert_sig)
       (wk: fc_weak_sig) (wf : fc_wf_sig) (sub : fc_subst_sig).

Import e_invert.
Import wk.
Import sub.

Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.tactics.

Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ett_par.
Require Export FcEtt.erase_syntax.

Require Import FcEtt.ext_red_one.
Module red1 := ext_red_one e_invert.
Import red1.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma weaken_head_reduction : forall G0 a a',
    head_reduction G0 a a' ->
    forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> head_reduction (F ++ E ++ G) a a'.

Lemma subst_head_reduction : forall G a a',
    head_reduction G a a' -> forall G1 G2 A b x,
       G = G1 ++ [(x, Tm A)] ++ G2
      -> AnnTyping G2 b A
      -> head_reduction (map (tm_subst_tm_sort b x) G1 ++ G2)
                       (tm_subst_tm_tm b x a)
                       (tm_subst_tm_tm b x a').

Ltac resolve_open a :=
    let s := fresh in
    match goal with
      [ x1 : ?b = open_tm_wrt_tm a (a_Var_f ?x) |- _ ] =>
      destruct a; inversion x1;
        [unfold open_tm_wrt_tm in x1;
         simpl in x1;
         match goal with [ n:nat |- _ ] =>
                         destruct (lt_eq_lt_dec n 0) as [s | [| s]];
                         try destruct s; inversion x1
         end | subst; unfold open_tm_wrt_tm in x1;
               unfold open_tm_wrt_tm; simpl in *; inversion x1; clear x1]
    end.

Lemma An_AbsTerm_exists : ∀ G x A (a a' : tm),
    x `notin` (fv_tm a \u fv_tm a' \u dom G) ->
    AnnTyping G A a_Star ->
    head_reduction ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
                                      (open_tm_wrt_tm a' (a_Var_f x))
    → head_reduction G (a_Abs Irrel A a) (a_Abs Irrel A a').

End fc_head_reduction. *)



Require Import FcEtt.fc_preservation.
(* FcEtt.fc_preservation:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Require Import FcEtt.ett_ott.
Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.

Require Import FcEtt.ett_par.
Require Import FcEtt.ext_invert.
Require Import FcEtt.ext_red.
Require Import FcEtt.ext_red_one.
Require Import FcEtt.erase_syntax.

Require Import FcEtt.fc_invert FcEtt.fc_unique.

Module fc_preservation (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)
        (e_subst : ext_subst_sig).

Import subst weak wf.

Module e_invert := ext_invert e_subst.
Import e_invert.

Module red := ext_red e_invert.
Import red.

Module red_one := ext_red_one e_invert.
Import red_one.

Module invert := fc_invert wf weak subst.
Module unique := fc_unique wf subst.
Import invert unique.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma open_a_Conv : forall a b g,
    open_tm_wrt_tm (a_Conv a g) b =
    a_Conv (open_tm_wrt_tm a b) (open_co_wrt_tm g b).

Lemma open_a_Conv_co : forall a b g,
    open_tm_wrt_co (a_Conv a g) b =
    a_Conv (open_tm_wrt_co a b) (open_co_wrt_co g b).

Ltac lc_erase_hyp :=
  match goal with
  | H : AnnTyping ?G ?a ?A0 |- lc_tm (erase_tm ?a) => eapply lc_erase; apply (AnnTyping_lc H)
  | H : AnnTyping ?G ?a ?A0 |- lc_tm ?a => apply (AnnTyping_lc1 H)
  | H : lc_tm ?a |- lc_tm (erase ?a) => eapply lc_erase; eauto
  | H : lc_tm (a_Abs ?r ?a ?b) |- lc_tm ?c => apply lc_erase in H; simpl in H; auto
  | H : lc_tm (a_CAbs ?a ?b) |- lc_tm ?c => apply lc_erase in H; simpl in H; auto
  end.

Lemma binds_toplevel: forall F a A,
  binds F (Ax a A) an_toplevel ->
  binds F (Ax (erase a) (erase A)) toplevel.

Ltac do_rho :=
  match goal with
    H : ∀ x : atom, x `notin` ?L → RhoCheck Irrel x (erase_tm (open_tm_wrt_tm ?b (a_Var_f x))) |-
                    ?x `notin` fv_tm_tm_tm (open_tm_wrt_tm (erase ?b) (a_Var_f ?x)) =>
    let h := fresh in
    let F := fresh in
    assert (F : x `notin` L); auto;
    move: (H x F) => h; inversion h; subst;
    replace (a_Var_f x) with (erase (a_Var_f x)); auto;
    rewrite open_tm_erase_tm; auto
  end.

Ltac eauto_lc := simpl; eauto using AnnTyping_lc1, Value_lc,
                        AnnDefEq_lc3, AnnPropWff_lc.

Lemma head_reduction_in_one : forall G a b,
    head_reduction G a b -> forall A,  AnnTyping G a A ->
    reduction_in_one (erase a) (erase b) \/ erase a = erase b.

Lemma head_reduction_erased : forall G a b, head_reduction G a b ->
    forall A, AnnTyping G a A ->  Par G (dom G) (erase a) (erase b).

Lemma preservation : forall G a A, AnnTyping G a A -> forall a', head_reduction G a a' -> AnnTyping G a' A.

End fc_preservation. *)

Require Import FcEtt.ext_subst.
(* FcEtt.ext_subst:
Require Import FcEtt.sigs.

Require Import FcEtt.tactics.
Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.fset_facts.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.

Require Export FcEtt.beta.
Require Export FcEtt.ext_wf.
Require Export FcEtt.ett_value.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Module ext_subst (weak : ext_weak_sig) <: ext_subst_sig.
  Include weak.

Lemma Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Lemma binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Lemma tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Lemma tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Lemma tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Lemma co_subst_fresh :
forall G phi a0 x s,
  PropWff G phi -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_constraint a0 x phi = phi.

Lemma bind_map_tm_subst_tm_sort: forall c F A B T x a,
    binds c (Co (Eq A B T)) F ->
    binds c (Co (Eq (tm_subst_tm_tm a x A)
                    (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T))) (map (tm_subst_tm_sort a x) F).

Lemma binds_map_4: forall x A F c0,
    binds x (Tm A) F ->
    binds x (Tm (co_subst_co_tm g_Triv c0 A)) (map (co_subst_co_sort g_Triv c0) F).

Lemma binds_map_5: forall c A B T F c1 ,
    binds c (Co (Eq A B T) ) F ->
    binds c (Co (Eq (co_subst_co_tm g_Triv c1 A) (co_subst_co_tm g_Triv c1 B) (co_subst_co_tm g_Triv c1 T)) ) (map (co_subst_co_sort g_Triv c1) F).

Lemma tm_subst_tm_tm_dom_invariance: forall x a F, dom F = dom (map (tm_subst_tm_sort a x) F).

Lemma subst_rho: forall L G a A x y b rho
    (T : Typing G a A)
    (Neq: x <> y)
    (Fr: y `notin` fv_tm_tm_tm a)
    (Fr2: y `notin` L)
    (K : (forall x, x `notin` L -> RhoCheck rho x (open_tm_wrt_tm b (a_Var_f x)))),
    RhoCheck rho y  (tm_subst_tm_tm a x (open_tm_wrt_tm b (a_Var_f y))).

Ltac rewrite_subst_context :=
  match goal with
  | [ |- context [([(?y, ?C (_ _ _ ?T))] ++ map ?sub ?F ++ ?G0)] ] =>
    rewrite_env (map sub ((y ~ (C T)) ++ F) ++ G0)
  end.

Ltac eapply_E_subst :=
  first [ eapply E_Star     |
          eapply E_App      |
          eapply E_IApp     |
          eapply E_CApp     |
          eapply E_Const    |
          eapply E_IsoConv  |
          eapply E_AppCong  |
          eapply E_IAppCong |
          eapply E_CAppCong |
          eapply E_PiSnd    |
          eapply E_CPiSnd].

Lemma tm_substitution_mutual :
  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Lemma Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Lemma co_subst_rho: forall L x y a rho
    (Neq: x <> y)
    (Fr2: y `notin` L)
    (K : (forall x, x `notin` L -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))),
    RhoCheck rho y  (co_subst_co_tm g_Triv x (open_tm_wrt_tm a (a_Var_f y))).

Lemma co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Lemma Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Lemma Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Lemma DefEq_swap : forall x1 x G A1 D b1 b2 B,
   x1 `notin` fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u fv_tm_tm_tm B
  -> x `notin` dom G \u {{ x1 }}
  -> DefEq ([(x1, Tm A1)] ++ G) D
          (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
          (open_tm_wrt_tm B (a_Var_f x1))
  -> DefEq ([(x, Tm A1)] ++ G) D
          (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
          (open_tm_wrt_tm B (a_Var_f x)).

Lemma E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Lemma E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst. *)



Set Implicit Arguments.

Set Bullet Behavior "Strict Subproofs".



Module fc_consist (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)

                  (e_invert : ext_invert_sig)(e_subst : ext_subst_sig).



Import wf weak.



Export subst.



Module invert := fc_invert wf weak subst.

Export invert.



Module consist := ext_consist e_invert wf.

Export consist.



Module erase' := erase wf weak subst e_invert.

Export erase'.



Module head := fc_head_reduction  e_invert weak wf subst.

Export head.



Module pres := fc_preservation wf weak subst e_subst.

Import pres.



Lemma erased_tm_erase_mutual :

  (forall G0 a B (H : AnnTyping G0 a B),

     erased_tm (erase a) /\ erased_tm (erase B)) /\

  (forall G0 phi (H : AnnPropWff G0 phi),

      forall a b A, phi = (Eq a b A) ->

                                         erased_tm (erase a) /\ erased_tm (erase b)

                                         /\ erased_tm (erase A)) /\

  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),

     True) /\

  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),

      True) /\

  (forall G0 (H : AnnCtx G0),

     forall x A, binds x (Tm A) G0 -> erased_tm (erase_tm A)

  ).

Proof.

 apply ann_typing_wff_iso_defeq_mutual; intros; simpl; repeat split; eauto.

 all: try solve [inversion H; eauto].

 all: try solve [inversion H1; eauto].

 all: try solve [inversion H0; eauto].

   

  - 

    erased_pick_fresh y. inversion H0. eauto using lc_erase.

    move: (H y) => h0. assert (W: y `notin` L). eauto.

    apply h0 in W. inversion W. rewrite <- open_tm_erase_tm in H1. eauto.

  - 

    destruct rho; eauto. 

    

    pick fresh x and apply erased_a_Abs. 

    replace (a_Var_f x) with (erase (a_Var_f x)); eauto.

    rewrite open_tm_erase_tm. assert (W: x `notin` L). auto. apply H0 in W.

    inversion W. auto. auto.

    

    pick fresh x and apply erased_a_Abs.

    replace (a_Var_f x) with (erase (a_Var_f x)); eauto.

    rewrite open_tm_erase_tm. assert (W: x `notin` L). auto. apply H0 in W.

    inversion W. auto.

    econstructor.

    assert (W: x `notin` L). auto.

    apply r in W. inversion W. simpl. 

    rewrite Rew.r_erase_tm.

    rewrite Rew.r_erase_tm in H1. rewrite -open_tm_erase_tm in H1.

    simpl in H1. auto.

  - 

    erased_pick_fresh y. inversion H. eauto using lc_erase.

    move: (H0 y) => h0. assert (W: y `notin` L). eauto.

    apply h0 in W. inversion W. clear h0 W. 

    rewrite <- open_tm_erase_tm in H2. eauto.

  - inversion H. inversion H0. destruct rho; simpl; eauto.

  - rewrite <- open_tm_erase_tm.

    set M := erase_tm B.

    inversion H. inversion H2; subst.

    pick fresh x.

    unfold M in Fr.

    rewrite (tm_subst_tm_tm_intro x); eauto.

    eapply subst_tm_erased. inversion H0. auto.

    eapply H7. fsetdec.

  - 

    destruct phi. destruct (H _ _ _ eq_refl) as (h0 & h1 & h2). simpl.

    eauto. erased_pick_fresh y; eauto using lc_erase.

    assert (W: y `notin` L). auto. apply H0 in W.

    rewrite Rew.r_erase_tm.

    erewrite open_co_erase_tm2. inversion W. apply H1.

  - 

    pick fresh y and apply erased_a_CAbs.

    assert (W: y `notin` L). auto. apply H0 in W.

    rewrite Rew.r_erase_tm.

    erewrite open_co_erase_tm2. inversion W. apply H1.

  - 

    destruct phi. destruct (H _ _ _ eq_refl) as (h0 & h1 & h2). simpl.

    eauto. erased_pick_fresh y; eauto using lc_erase.

    assert (W: y `notin` L). auto. apply H0 in W.

    rewrite Rew.r_erase_tm.

    erewrite open_co_erase_tm2. inversion W. apply H2.

  - rewrite <- open_co_erase_tm.

    set M := erase_tm B.

    inversion H. inversion H2; subst.

    pick fresh x.

    unfold M in Fr.

    assert (W: x `notin` L). fsetdec. apply H10 in W.

    erewrite open_co_erase_tm with (a := (g_Var_f x)).

    erewrite open_co_erase_tm2 in W. apply W.

  - inversion H1. subst. inversion H. auto.

  - inversion H1. subst. inversion H0. auto.

  - inversion H1. subst. inversion H. auto.

  - simpl in H1.

    apply binds_cons_iff in H1.

    inversion H1. inversion H2.

    + inversion H4; subst; auto.

      inversion H0; auto.

    + apply H in H2; auto.

  - simpl in H1.

    apply binds_cons_iff in H1.

    inversion H1. destruct phi.

    inversion H2. inversion H4. 

    apply H in H2; auto.

Qed.



Lemma erased_tm_erase : forall G0 a B, AnnTyping G0 a B -> erased_tm (erase a).

Proof.

  intros.

  destruct erased_tm_erase_mutual.

  apply H0 in H. inversion H. auto.

Qed.



Lemma erased_tm_erase_type : forall G0 a B, AnnTyping G0 a B -> erased_tm (erase B).

Proof.

  intros.

  destruct erased_tm_erase_mutual.

  apply H0 in H. inversion H. auto.

Qed.



Hint Resolve erased_tm_erase : erased.



Definition AnnGood G D := Good (erase_context G) D.



Lemma AnnGoodIsGood : forall G D, AnnGood G D -> Good (erase_context G) D.

Proof. intros. auto.

Qed.



Lemma AnnGoodnil : AnnGood nil AtomSetImpl.empty.

  unfold AnnGood. simpl. unfold Good. unfold erased_context.

  split. auto.

  intros.

  unfold binds in H. inversion H.

Qed.



Lemma AnnDefEq_consistent : forall S D g A B, AnnDefEq S D g A B -> AnnGood S D -> consistent (erase A) (erase B).

Proof.

  intros S D g A B H H0.

  pose S' := AnnGoodIsGood H0.

  destruct (AnnDefEq_regularity H) as (S1 & S2 & gs & TS1 & TS2 & ES).

  assert (DefEq (erase_context S) D (erase A) (erase B) (erase S1)).

  { apply (AnnDefEq_erase H).

    auto.

  }

  assert (C : consistent (erase A) (erase B)).

  eapply join_consistent.

  eapply consistent_defeq. eauto. eauto.

  inversion C; subst; auto.

Qed.



Lemma Paths_are_DataTy : forall T a,

    Path T a -> Value a -> forall G A, AnnTyping G a A -> DataTy A a_Star.

Proof.

  induction 1; intros.

  - inversion H0. subst.

    eapply (binds_to_type _ _ AnnSig_an_toplevel); eauto.

  - inversion H1. inversion H2. subst.

    move: (IHPath H8 _ _ H14) => h0.

    inversion h0. subst.

    pick fresh x.

    rewrite (tm_subst_tm_tm_intro x); eauto with lngen.

  - inversion H1. inversion H2. subst.

    move: (IHPath H7 _ _ H11) => h0.

    inversion h0. subst.

    pick fresh x.

    rewrite (co_subst_co_tm_intro x); eauto with lngen.

  - inversion H1.

Qed.



Lemma Paths_have_value_types : forall T a,

    Path T a -> Value a -> forall G A, AnnTyping G a A -> value_type A.

Proof. intros.

       eapply DataTy_value_type; eauto.

       eapply Paths_are_DataTy; eauto.

Qed.



Lemma values_have_value_types :

  forall G D a A, AnnGood G D ->  AnnTyping G a A -> Value a -> value_type A.

Proof.

  intros G D a A AN H V.

  move: (AnnTyping_regularity H) => h0.

  inversion H; subst; auto.

  all: try solve [inversion V; inversion H2].

  all: match goal with

  | [H : AnnTyping ?G ?b ?A |- value_type ?b] =>

    apply AnnTyping_lc in H; split_hyp; lc_inversion c;  eauto

       end.

  + inversion V.

    eapply (@Paths_have_value_types T (a_App b rho a0)); eauto.

  + inversion V.

    eapply (@Paths_have_value_types T (a_CApp a1 g)); eauto.

  + eapply DataTy_value_type.

    eapply (binds_to_type _ _ AnnSig_an_toplevel); eauto.

Qed.



Lemma canonical_forms_a_Pi :

  forall G D a rho A B, AnnGood G D ->

                   AnnTyping G a (a_Pi rho A B) -> Value a ->

                   (exists a', a = a_Abs rho A a') \/ (exists T, Path T a).

Proof.

  intros G D a rho A B AN H V.

  inversion V; subst; inversion H; subst; try solve [inversion H0].

  all: try solve [left; exists a0; auto].

  all: try solve [right; exists T; auto].

Qed.



Lemma canonical_forms_a_CPi :

  forall G D a phi B, AnnGood G D ->

                 AnnTyping G a (a_CPi phi B) -> Value a ->

                 (exists a', a = a_CAbs phi a') \/ (exists T, Path T a).

Proof.

  intros G D a phi B AN H V.

  inversion V; subst; inversion H; subst; try solve [inversion H0].

  all: try solve [left; exists a0; auto].

  all: try solve [right; exists T; auto].

Qed.



Lemma consistent_a_Pi :

  forall G A B C g rho,

    AnnGood G (dom G) -> value_type C ->

    AnnDefEq G (dom G) g C (a_Pi rho A B) -> exists A' B', C = a_Pi rho A' B'.

Proof.

  intros G A B C g rho AN VT DE.

  move: (AnnDefEq_consistent DE AN) => K;  simpl in K.

  inversion K.

  destruct C; destruct rho0; try destruct rho1; simpl in H; inversion H.

  - exists C1. exists C2. subst. auto.

  - subst. exists C1. exists C2. auto.

  - inversion VT.

  - inversion VT.

  - inversion H0.

  - assert False.

    apply AnnDefEq_lc in DE. split_hyp.

    match goal with

      [ H0 : ¬ value_type (a_Pi rho (erase_tm A) (erase_tm B)),

        H4 : lc_tm (a_Pi rho A B) |- _ ] =>

    apply H0; econstructor;

      pose M := H4; clearbody M; inversion M;

      eauto using lc_tm_erase;

      move: (lc_erase) => [h0 _]; apply h0 in H4; auto end.

    done.

  - subst.

    apply value_type_erase in VT. done.

Qed.



Lemma consistent_a_CPi :

  forall G phi B C g,

    AnnGood G (dom G) -> value_type C -> AnnDefEq G (dom G) g C (a_CPi phi B) -> exists phi' B', C = a_CPi phi' B'.

Proof.

  intros G phi B C g AN VT DE.

  move: (AnnDefEq_consistent DE AN) => K;  simpl in K.

  inversion K.

  destruct C; try destruct rho; simpl in H; inversion H;

  try solve [inversion VT; inversion H1].

  - subst. exists phi0. exists C.  auto.

  - inversion H0.

  - assert False.

    apply AnnDefEq_lc in DE. split_hyp.

    apply H0. econstructor.

    pose M := H4. inversion M.

    apply lc_erase. auto.

    move: (lc_erase) => [h0 _]. apply h0 in H4. apply H4.

    done.

  - subst.

    apply value_type_erase in VT. done.

Qed.



Definition irrelevant G D (a : tm) :=

  (forall x A, binds x (Tm A) G -> x `notin` fv_tm (erase a)) /\ AnnGood G D.



Lemma progress : forall G a A, irrelevant G (dom G) a -> AnnTyping G a A -> CoercedValue a \/ exists a', head_reduction G a a'.

Proof.

  intros G a A AN H.

  destruct AN as [IR AN].

  assert (M : AnnTyping G a A); auto.

  dependent induction H; destruct (AnnTyping_lc M) as [LCa LCA]; inversion LCa.

  - left; auto.

  - apply IR in H0. simpl in H0. fsetdec.

  - left; eauto.

  - destruct rho; try solve [left; eauto].

    pick fresh x.

    have: x `notin` L; auto => h0.

    move: (H2 x h0) => h1.

    inversion h1. subst. clear H2.

    destruct (H1 x h0) as [V | [a' R]].

    { move: (H0 x h0) => h2.

      have ctx: (AnnCtx ([(x, Tm A)] ++ G)) by eauto with ctx_wff.

      move: (AnnCtx_uniq ctx) => u. inversion u. subst.

      intros x0 A0 b0.

      apply binds_cons_uniq_1 in b0. destruct b0; split_hyp.

      ++ subst. auto.

      ++ move: (IR _ _ H2) => fr. simpl in fr.

         rewrite <- open_tm_erase_tm.

         eapply notin_sub; [idtac| eapply fv_tm_tm_tm_open_tm_wrt_tm_upper].

         simpl.

         fsetdec.

      ++ eauto. }

    { unfold AnnGood. simpl. eapply Good_add_tm_2; eauto.

      rewrite <- erase_dom. auto.

      eapply Typing_erased. eapply (AnnTyping_erase). eauto. }

    { eauto. }

    -- inversion V. subst.

       ++ left.

       econstructor.

       eapply Value_AbsIrrel_exists with (x := x); eauto.

       ++ resolve_open a.

       left. eapply CV.

       eapply Value_AbsIrrel_exists with (x:=x); eauto.

    -- right. exists (a_Abs Irrel A (close_tm_wrt_tm x a')).

       eapply An_AbsTerm_exists with (x := x).

         { eapply notin_union; auto.

           simpl. rewrite fv_tm_tm_tm_close_tm_wrt_tm. auto. }

         auto.

         rewrite open_tm_wrt_tm_close_tm_wrt_tm. auto.

  - destruct IHAnnTyping1; auto.

    + intros. move: (IR x A0 H6) => h0. destruct rho; simpl in h0. fsetdec. fsetdec.

    + inversion M. subst.

      match goal with

        H: CoercedValue b |- _ => inversion H

      end.

      -- 

        edestruct canonical_forms_a_Pi as [[ a1 EQ] | [T P]] ; eauto; subst.

        

        ++ right. 

           exists (open_tm_wrt_tm a1 a). eapply An_AppAbs; eauto.

      -- right. 

         subst.

         inversion H.

         subst.

         have VT: value_type A1. eapply values_have_value_types; eauto.

         edestruct consistent_a_Pi as (A' & B' & EQ); eauto. subst.

         edestruct canonical_forms_a_Pi as [[ a0' EQ] | [T P]]; eauto; subst.

    + subst.

      match goal with H : exists a' : tm, head_reduction G b a' |- _ => destruct H end.

      right. eexists. eapply An_AppLeft; eauto.

  - 

    subst. destruct IHAnnTyping1; auto.

    inversion H2.

    + subst. left; auto.

    + subst. right. inversion H4.

      eexists.  eapply An_Combine; eauto.

    + destruct H2. right. eexists. eapply An_ConvTerm; eauto.

  - left; auto.

  - left; auto.

  - destruct IHAnnTyping; auto.

    + intros. move: (IR x A H5) => h0. simpl in h0. fsetdec.

    + inversion M. subst.

      match goal with

        H : CoercedValue ?a1 |- _ => inversion H

      end.

      -- edestruct canonical_forms_a_CPi as [[a2 EQ]|[T p]]; eauto; subst.

         right. exists (open_tm_wrt_co a2 g). eapply An_CAppCAbs; eauto.

         destruct (AnnTyping_lc H) as [h0 h1]. inversion h0; auto.

      -- subst.  inversion H. subst.

         have VT: value_type A. eapply values_have_value_types; eauto.

        edestruct consistent_a_CPi as (A' & a2 & EQ); eauto. subst.

        edestruct canonical_forms_a_CPi as [[a0' EQ]|[T p]]; eauto; subst.

    + destruct H5. right. eexists. eapply An_CAppLeft. eauto. eauto.

  - left. eauto.

  - right. exists a. eauto.

Qed.



Inductive multi (rel : tm -> tm -> Prop) : tm -> tm -> Prop :=

| multi_refl : forall a, lc_tm a -> multi rel a a

| multi_step : forall a b c, rel a b -> multi rel b c -> multi rel a c.



Lemma multi_trans : forall r a b, multi r a b -> forall c, multi r b c -> multi r a c.

Proof.

  intros.

  dependent induction H. auto.

  eapply multi_step. eauto. auto.

Qed.



Lemma multi_An_AbsTerm_exists : ∀ (G : list (atom * sort)) (x : atom) (A a a' : tm),

       x `notin` union (fv_tm a) (union (fv_tm a') (dom G))

       → AnnTyping G A a_Star

         → multi (head_reduction ([(x, Tm A)] ++ G)) (open_tm_wrt_tm a (a_Var_f x))

             (open_tm_wrt_tm a' (a_Var_f x))

           → multi (head_reduction G) (a_Abs Irrel A a) (a_Abs Irrel A a').

Proof.

  intros.

  dependent induction H1.

  + apply open_tm_wrt_tm_inj in x; auto.

    subst.

    eapply multi_refl; eauto using AnnTyping_lc1.

  + eapply multi_step with (b := a_Abs Irrel A (close_tm_wrt_tm x b)); eauto.

    eapply An_AbsTerm_exists with (x:=x); auto.

    autorewrite with lngen. auto.

    autorewrite with lngen. auto.

    eapply IHmulti with (x0:=x); auto.

    autorewrite with lngen. auto.

    autorewrite with lngen. auto.

Qed.



Lemma multi_An_ConvTerm : ∀ (G : context) (a : tm) (g : co) (a' : tm),

    lc_co g → multi (head_reduction G) a a'

    → multi (head_reduction G) (a_Conv a g) (a_Conv a' g).

Proof.

  intros.

  dependent induction H0.

  - eapply multi_refl; eauto.

  - eapply multi_step with (b:= (a_Conv b g)); auto.

Qed.



Lemma multi_An_AppLeft : ∀ (G : context) (a b: tm) rho (a' : tm),

    lc_tm b → multi (head_reduction G) a a'

    → multi (head_reduction G) (a_App a rho b) (a_App a' rho b).

Proof.

  intros.

  dependent induction H0.

  - eapply multi_refl; eauto.

  - eapply multi_step with (b:= (a_App b0 rho b)); auto.

Qed.



Lemma multi_An_CAppLeft : ∀ (G : context) (a: tm) (g:co) (a' : tm),

    lc_co g → multi (head_reduction G) a a'

    → multi (head_reduction G) (a_CApp a g) (a_CApp a' g).

Proof.

  intros.

  dependent induction H0.

  - eapply multi_refl; eauto.

  - eapply multi_step with (b:= (a_CApp b g)); auto.

Qed.



Lemma multi_preservation : forall G a b A, multi (head_reduction G) a b ->

                                      AnnTyping G a A ->

                                      AnnTyping G b A.

Proof.

  induction 1.

  intros. auto.

  intros.

  eapply IHmulti.

  eapply preservation; eauto.

Qed.



Lemma erased_constraint_erase :

  forall G a b A, AnnPropWff G (Eq a b A) -> erased_tm (erase a) /\ erased_tm (erase b)

                                      /\ erased_tm (erase A).

Proof.

  move: erased_tm_erase_mutual => [_ [h [_ _]]].

  eauto.

Qed.



Lemma erased_context_erase :

  forall G, AnnCtx G -> erased_context (erase_context G).

       Proof.

         induction 1; simpl; unfold erased_context; rewrite Forall_forall.

         - intros. inversion H.

         - intros. destruct x0. inversion H2.

           -- inversion H3. destruct s. inversion H6. subst. 

              econstructor. eapply erased_tm_erase. eauto.

              inversion H6.

           -- unfold erased_context in IHAnnCtx.

              move: (Forall_forall (λ p : atom * sort, let (_, s) := p in erased_sort s) (erase_context G)) => [h0 h1].

              move: (h0 IHAnnCtx) => h2.

              eapply (h2 (a,s)). auto.

         - intros. destruct x. inversion H2.

           -- inversion H3. destruct s. inversion H6.

              inversion H6. subst.

              destruct phi.

              inversion H0.

              econstructor. 

              + eapply erased_tm_erase. eauto using AnnTyping_lc1.

              + eapply erased_tm_erase. eauto using AnnTyping_lc2.

              + eapply erased_tm_erase_type. eauto.

           -- unfold erased_context in IHAnnCtx.

              move: (Forall_forall (λ p : atom * sort, let (_, s) := p in erased_sort s) (erase_context G)) => [h0 h1].

              move: (h0 IHAnnCtx) => h2.

              eapply (h2 (a,s)). auto.

       Qed.



Lemma AnnGood_add_tm :

  forall G x A,  x `notin` dom G -> AnnTyping G A a_Star -> AnnGood G (dom G) -> AnnGood (x ~ Tm A ++ G) (dom (x ~ Tm A ++ G)).

Proof.

  intros G x A Fr AT GG.

  inversion GG.  econstructor. eapply erased_context_erase; eauto using AnnTyping_AnnCtx.

  intros.

  simpl in H1.

  apply binds_cons_1 in H1.

  destruct H1 as [[_ EQ] | BI1]. inversion EQ.

  edestruct (H0 c1) as (C & P1 & P2); eauto.

  move: (binds_In _ c1 _ _ BI1) => b0.

  unfold erase_context in b0. move: (dom_map _ _ erase_sort G) => DM. fsetdec.

  exists C. repeat split;

         eapply context_Par_irrelevance; eauto.

Qed.



Ltac eauto_lc := simpl; eauto using AnnTyping_lc1, Value_lc,

                        AnnDefEq_lc3, AnnPropWff_lc.



Lemma erased_Value_reduces_to_CoercedValue :

  forall G a0 A,

    AnnTyping G a0 A

    -> AnnGood G (dom G) -> forall a, erase a0 = a -> Value a

           -> exists av, multi (head_reduction G) a0 av /\ CoercedValue av /\ erase av = a.

Proof.

  intros G a0 A H. induction H.

  all: intros GG aa E V; simpl in E; inversion E; subst.

  all: try solve [inversion V].

  all: try solve [eexists; repeat split;

                  try eapply multi_refl; eauto_lc].

  + exists (a_Pi rho A B).

    have ?: lc_tm (a_Pi rho A B) by eauto_lc.

    repeat split; try eapply multi_refl; eauto_lc.



  + have ?: lc_tm (a_Abs rho A a) by eauto_lc.

    destruct rho.

    ++ exists (a_Abs Rel A a).

       repeat split; try eapply multi_refl; eauto_lc.

    ++ 

      inversion V. subst.

      match goal with

        [H5 : forall x, x `notin` ?L -> Value _ |- _ ] =>

        pick_fresh y; move: (H5 y ltac:(auto)) => Va; clear H5 end.



      have EE: erase (open_tm_wrt_tm a (a_Var_f y)) = open_tm_wrt_tm (erase_tm a) (a_Var_f y)

        by simpl_erase; auto.



       have G1 : AnnGood (y ~ Tm A ++ G) (dom (y ~ Tm A ++ G)) by  eapply AnnGood_add_tm; eauto.



       match goal with

         [ H1 : ∀ x : atom, x `notin` ?L → AnnGood _ _ -> _ |- _ ] =>

         move: (H1 y ltac:(auto) G1 _ EE Va) => [av [MS [VV EV]]] end.



       exists (a_Abs Irrel A (close_tm_wrt_tm y av)).

       repeat split.

       +++ eapply multi_An_AbsTerm_exists with (x:=y);

            autorewrite with lngen; eauto.

       +++ econstructor.

           eapply Value_AbsIrrel_exists with (x:=y); autorewrite with lngen; eauto_lc.

       +++ simpl_erase. rewrite EV.

           simpl. rewrite close_tm_wrt_tm_open_tm_wrt_tm; eauto using fv_tm_erase_tm.



  + destruct rho; simpl in V; inversion V; subst;

    move: (IHAnnTyping1 GG (erase b) eq_refl ltac:(auto)) => [av [MS [CV EE]]];

    inversion CV; subst.

    ++ exists (a_App av Rel a).

       repeat split. eapply multi_An_AppLeft; eauto_lc.

       repeat econstructor; eauto_lc.

       eapply Path_to_Path; eauto_lc.

       simpl. autorewcs. congruence.

    ++ move: (multi_preservation MS H) => TC. inversion TC.

       move: (values_have_value_types GG H9 H3) => VT.

       move: (consistent_a_Pi GG VT H11) => [A' [B' EQ]]. subst.

       pose VV := H3. clearbody VV.

       eapply An_Push with (b:=a) in H3; try eapply H11; try reflexivity.

       eexists.

       split. eapply multi_trans.

       eapply multi_An_AppLeft; eauto_lc.

       eapply multi_step; eauto_lc.

       eapply multi_refl; eauto_lc.

       repeat econstructor; eauto_lc.

       split.

       eapply CC; econstructor; eauto_lc.

       econstructor; eauto_lc.

       eapply Path_to_Path; eauto_lc.

       simpl in EE. simpl. congruence.

    ++ exists (a_App av Irrel a).

       repeat split. eapply multi_An_AppLeft; eauto_lc.

       repeat econstructor; eauto_lc.

       eapply Path_to_Path; eauto_lc.

       simpl. autorewcs. congruence.

    ++ move: (multi_preservation MS H) => TC. inversion TC.

       move: (values_have_value_types GG H9 H3) => VT.

       move: (consistent_a_Pi GG VT H11) => [A' [B' EQ]]. subst.

       pose VV := H3. clearbody VV.

       eapply An_Push with (b:=a) in H3; try eapply H11; try reflexivity.

       eexists.

       split. eapply multi_trans.

       eapply multi_An_AppLeft; eauto_lc.

       eapply multi_step; eauto_lc.

       eapply multi_refl; eauto_lc.

       repeat econstructor; eauto_lc.

       split.

       eapply CC; econstructor; eauto_lc.

       econstructor; eauto_lc.

       eapply Path_to_Path; eauto_lc.

       simpl in EE. simpl. congruence.



  + move: (IHAnnTyping1 GG _ eq_refl V) => [av [MS [CV EE]]].

    inversion CV.

    ++ subst.

      exists (a_Conv av g).

      repeat split.

      eapply multi_An_ConvTerm; eauto using AnnDefEq_lc3.

      eapply CC; eauto using AnnDefEq_lc3.

      simpl. autorewcs. auto.

    ++ subst.

      have ?: lc_tm a0 by eauto using Value_lc.

      have ?: lc_co g by eauto using AnnDefEq_lc3.

      exists (a_Conv a0 (g_Trans g0 g)).

      split.

      eapply multi_trans.

      eapply multi_An_ConvTerm; eauto.

      eapply multi_step.

      eapply An_Combine; eauto.

      eapply multi_refl; eauto.

      split. eapply CC; eauto.

      simpl. simpl in EE. auto.

  + exists (a_CPi phi B).

    have ?: lc_tm (a_CPi phi B) by eapply AnnTyping_lc1; eauto.

    repeat split; try eapply multi_refl; eauto using Value_lc;

      simpl; auto.

    econstructor; eauto using AnnTyping_lc1, AnnPropWff_lc.

  + exists (a_CAbs phi a).

    have ?: lc_tm (a_CAbs phi a). eapply AnnTyping_lc1; eauto.

    repeat split; try eapply multi_refl; eauto using Value_lc;

      simpl; auto.

    econstructor; eauto using AnnTyping_lc1, AnnPropWff_lc.

  + 

    simpl in V; inversion V; subst;

    move: (IHAnnTyping GG (erase a1) eq_refl ltac:(auto)) => [av [MS [CV EE]]];

    inversion CV; subst.

    ++ exists (a_CApp av g).

       repeat split.

       eapply multi_An_CAppLeft; eauto_lc.

       repeat econstructor; eauto_lc.

       eapply Path_to_Path; eauto_lc.

       simpl. autorewcs. congruence.

    ++ move: (multi_preservation MS H) => TC. inversion TC.

       move: (values_have_value_types GG H9 H3) => VT.

       move: (consistent_a_CPi GG VT H11) => [A' [B' EQ]]. subst.

       pose VV := H3. clearbody VV.

       eapply An_CPush with (g:=g0) in H3; try eapply H11; try reflexivity.

       eexists.

       split.

       eapply multi_trans.

       eapply multi_An_CAppLeft; eauto_lc.

       eapply multi_step; eauto_lc.

       eapply multi_refl; eauto_lc.

       repeat econstructor; eauto_lc.

       split.

       eapply CC; econstructor; eauto_lc.

       eapply Path_to_Path; eauto_lc.

       simpl in EE. simpl. congruence.

Qed.



Ltac solve_irrelevant y AA b0 h0 :=

  match goal with

    [ H1 : irrelevant _ _ _ |- _ ] => inversion H1 end;

  match goal with

    [ H4 : forall x A, binds x _ _ -> x `notin` _ |- _ ] =>

    simpl in H4; econstructor; eauto;

    try (intros y AA b0; move: (H4 y AA b0) => h0; fsetdec) end.



Lemma paths_arent_abs :

  forall a T, Path T a -> forall rho b, a = a_UAbs rho b -> False.

Proof.

  intros a T P.

  induction P; intros r b0 EQ;

    try  destruct rho; simpl in *; inversion EQ.

Qed.



Ltac no_paths:=

  match goal with

    [ EE : erase (a_App ?b0 ?rho ?a) = a_UAbs _ ?b, H : Path ?T ?b0 |- _ ] =>

    destruct rho; simpl in EE;

    match goal with

      [ FF : ?a = a_UAbs _ ?b |- _ ] =>

      have P: (Path T a); by eauto using lc_tm_erase end end.



Ltac induction_a0 :=

  let IR := fresh  in

  let a0' := fresh in

  let y := fresh in

  let AA := fresh in

  let b0 := fresh in

  let h0 := fresh in

  match goal with

    [ IHa0 : ∀ A0 : tm, irrelevant ?G (dom ?G) ?a0 → _,

        H1 : irrelevant ?G _ (a_Conv ?a0 ?g),

        H2 : AnnTyping ?G (a_Conv ?a0 ?g) ?A0 |- _ ] =>

    inversion H2; subst;

    (have IR: irrelevant G (dom G) a0 by solve_irrelevant y AA b0 h0);

    move: (IHa0 _ IR ltac:(eauto) ltac:(auto)) =>

    [a0' [? ?]];

    exists (a_Conv a0' g);

    split; [ eapply multi_An_ConvTerm; eauto with lc | simpl; auto ]

  end.



Lemma reduction_annotation : forall a a',

    reduction_in_one a a' ->

    forall G a0 A0, irrelevant G (dom G) a0 -> AnnTyping G a0 A0 -> erase a0 = a ->

    exists a0', multi (head_reduction G) a0 a0' /\ erase a0' = a'.

Proof.

  intros a a' H.

  induction H.

  - 

    intros.

    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst.

    + inversion H2. subst.

      pick fresh x for (L \u L0 \u (fv_tm a0_2) \u dom G \u fv_tm a').

      move: (H11 x ltac:(auto)) => RC. inversion RC. subst. clear H11.

      move: (H10 x ltac:(auto)) => T2. clear H10.

      inversion H1.

      have IR: irrelevant ((x ~ Tm a0_1) ++ G) (dom (x ~ Tm a0_1 ++ G))

                       (open_tm_wrt_tm a0_2 (a_Var_f x)).

      econstructor; eauto.

      { intros x0 A0 b0.

        destruct (binds_cons_1 _ x0 x _ _ _ b0).

        + split_hyp.

          inversion H9. subst.

          autorewcshyp H4.  auto.

        + move: (binds_In _ _ _ _ H7) => h0.

          have NE: x0 <> x. fsetdec.

          move: (H5 _ _ H7) => NI. simpl in NI.

          simpl_erase.

          move: (fv_tm_tm_tm_open_tm_wrt_tm_upper (erase a0_2) (a_Var_f x)) => h1.

          simpl in h1. fsetdec.

      }

      { eapply AnnGood_add_tm; eauto. }

      have h1: erase (open_tm_wrt_tm a0_2 (a_Var_f x)) =

               open_tm_wrt_tm (erase_tm a0_2) (a_Var_f x).

      simpl_erase. auto.

      move: (H0 x ltac:(auto) _ _ _ IR T2 h1) => [a0' [ms ee]].

      exists (a_Abs Irrel a0_1 (close_tm_wrt_tm x a0')).

      split.

      eapply multi_An_AbsTerm_exists with (x:=x);

        autorewrite with lngen; auto.

      simpl_erase. rewrite ee.

      simpl. autorewrite with lngen. auto.

    + inversion H2.

    + induction_a0.

  -  

    intros.

    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst.

    + inversion H1. simpl in H4.

      inversion H2. subst.

      have I1: irrelevant G (dom G) a0_1.

      solve_irrelevant y AA b0 h0.

      move: (IHreduction_in_one _ _ _ I1 H11 eq_refl) => [a0_1' [MS E']].

      exists (a_App a0_1' Rel a0_2).

      split.

      eapply multi_An_AppLeft; eauto using AnnTyping_lc1.

      simpl. autorewcs. congruence.

    + induction_a0.

  -  

    intros.

    dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst.

    + inversion H1. simpl in H4.

      inversion H2. subst.

      have I1: irrelevant G (dom G) a0_1.

      solve_irrelevant y AA b0 h0.

      move: (IHreduction_in_one _ _ _ I1 H8 eq_refl) => [a0_1' [MS E']].

      exists (a_App a0_1' Irrel a0_2).

      split.

      eapply multi_An_AppLeft; eauto using AnnTyping_lc1.

      simpl. autorewcs. congruence.

    + induction_a0.

  -  

    intros.

    match goal with

      [ H2 : erase ?a0 = _ |- _ ] =>

      dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst

    end.

    + induction_a0.

    + ann_invert_clear.

      have I: irrelevant G (dom G) a0. solve_irrelevant y AA b0 h0.

      match goal with

        [ H7 : AnnTyping ?G a0 ?A |- _ ] =>

        move: (IHreduction_in_one _ _ _ I H7 eq_refl) => [a0_1' [MS E']]

      end.

      exists (a_CApp a0_1' g).

      split. eapply multi_An_CAppLeft; eauto with lc.

      simpl. autorewcs. congruence.

  - 

    intros.

    

    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst.

    + 


      ann_invert_clear.

      inversion H1.

      have ?: Value (a_UAbs Rel v) by eauto.

      move: (erased_Value_reduces_to_CoercedValue H10 H4 H5 ltac:(auto)) =>

      [av ?]. split_hyp.

      move: (multi_preservation H6 H10) => Tav.

      

      match goal with [ H : CoercedValue av |- _ ] => inversion H; subst end.

      ++ 

         match goal with [ H10 : Value av , H9 : erase av = _ |- _ ] =>

            inversion Tav; subst; inversion H10; subst; simpl in H9; inversion H9 end.

         exists (open_tm_wrt_tm a a0_2).

         split.

         eapply multi_trans with (b:= a_App (a_Abs Rel A a) Rel a0_2).

         eapply multi_An_AppLeft; eauto_lc.

         eapply multi_step; eauto_lc.

         eapply multi_refl; eauto.

         { lc_inversion c. subst.

           pick fresh y.

           rewrite (tm_subst_tm_tm_intro y); auto.

           eapply tm_subst_tm_tm_lc_tm; eauto using AnnTyping_lc1. }

         rewrite open_tm_erase_tm. auto.

         

         no_paths.

      ++ 

         have LC: lc_tm a0_1 by eauto using AnnTyping_lc1.

         

         inversion H1.

         ann_invert_clear.

         match goal with

           [ H4 : AnnGood _ _,  H20 : AnnDefEq G (dom G) g A0 (a_Pi Rel A B),

             H18 : AnnTyping G a A0, H11: Value a |- _ ] =>

         move: (values_have_value_types H4 H18 H11) => VT;

         move: (consistent_a_Pi H4 VT H20) => [A' [B' EQ]]; subst;

         move: (An_Push _ _ _ _ a0_2 _ _ _ _ _ _ H11 H20 eq_refl eq_refl)=> RED end.

         have TA': AnnTyping G A' a_Star.

           { move: (AnnTyping_regularity H17) => T1. inversion T1. auto. }

         have Tb': AnnTyping G (a_Conv a0_2 (g_Sym (g_PiFst g))) A'.

           { eapply An_Conv; eauto.

             eapply An_Sym.  eauto. eauto using AnnTyping_regularity.

             eapply An_Refl; eauto. eauto with ctx_wff.

             eapply An_PiFst; eauto. }



         simpl in *.

         match goal with

           [ H10: Value ?a, H9 : erase_tm ?a = _ , Ta : AnnTyping G ?a _ |- _ ] =>

           inversion Ta; subst; inversion H10; subst; simpl in H9; inversion H9 end.



         eexists.

         split.

         

         eapply multi_trans with (b:= a_App (a_Conv (a_Abs Rel A' a0) g) Rel a0_2).

         eapply multi_An_AppLeft; eauto_lc.



         eapply (multi_step _ RED).



         eapply multi_step.

         eapply An_ConvTerm. eauto using AnnTyping_lc1, AnnDefEq_lc3.

         eapply An_AppAbs; eauto using AnnTyping_lc1.



         eapply multi_refl.

         { lc_inversion c. repeat econstructor; eauto_lc. }



         simpl_erase. auto.



         destruct rho.

         +++ have P: Path T (a_App (erase v) Rel (erase a0)); by eauto

                                                                    using lc_tm_erase.

         +++ have P: Path T (a_App (erase v) Irrel a_Bullet); by eauto using lc_tm_erase.

    + 

      induction_a0.

  - 

    intros.

    dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst.

    + 


      ann_invert_clear.

      inversion H0.

      match goal with [H12 : AnnTyping G a0_1 (a_Pi Irrel A B),

                       H4  : AnnGood G (dom G),

                       H6  : erase_tm a0_1 = a_UAbs Irrel v |- _ ] =>

      move: H12 => Ta01;

      move: (erased_Value_reduces_to_CoercedValue Ta01 H4 H6

             ltac:(auto)) => [av [RE ?]];

      split_hyp end.

      move: (multi_preservation RE Ta01) => Tav.

      

      match goal with [ H : CoercedValue av |- _ ] => inversion H; subst end.

      ++ 

         match goal with [ H10 : Value av , H9 : erase av = _ |- _ ] =>

            inversion Tav; subst; inversion H10; subst; simpl in H9; inversion H9 end.

         exists (open_tm_wrt_tm a a0_2).

         split.

         eapply multi_trans with (b:= a_App (a_Abs Irrel A a) Irrel a0_2).

         eapply multi_An_AppLeft; eauto_lc.

         eapply multi_step; eauto_lc.

         eapply multi_refl; eauto.

         { lc_inversion c. subst.

           pick fresh y.

           rewrite (tm_subst_tm_tm_intro y); auto.

           eapply tm_subst_tm_tm_lc_tm; eauto using AnnTyping_lc1. }

         {

         

           simpl_erase.

           pick fresh x.

           move: (H16 x ltac:(auto)) => RC. inversion RC.

           rewrite (tm_subst_tm_tm_intro x (erase a)).

           replace (a_Var_f x) with (erase (a_Var_f x)); auto.

           rewrite open_tm_erase_tm.

           rewrite tm_subst_tm_tm_fresh_eq; auto.

           rewrite (tm_subst_tm_tm_intro x (erase a)).

           replace (a_Var_f x) with (erase (a_Var_f x)); auto.

           rewrite open_tm_erase_tm.

           rewrite tm_subst_tm_tm_fresh_eq; auto.

           apply fv_tm_erase_tm; auto.

           apply fv_tm_erase_tm; auto.

         }



         no_paths.

      ++ 

         have LC: lc_tm a0_1 by eauto using AnnTyping_lc1.

         

         inversion H0.

         ann_invert_clear.

         match goal with

           [ H4 : AnnGood _ _,  H20 : AnnDefEq G (dom G) g A0 (a_Pi Irrel A B),

             H18 : AnnTyping G a A0, H11: Value a |- _ ] =>

         move: (values_have_value_types H4 H18 H11) => VT;

         move: (consistent_a_Pi H4 VT H20) => [A' [B' EQ]]; subst;

         move: (An_Push _ _ _ _ a0_2 _ _ _ _ _ _ H11 H20 eq_refl eq_refl)=> RED;

         have TA': AnnTyping G A' a_Star by

           (move: (AnnTyping_regularity H18) => T1; inversion T1; auto)

         end.

         have Tb': AnnTyping G (a_Conv a0_2 (g_Sym (g_PiFst g))) A'.

           { eapply An_Conv; eauto.

             eapply An_Sym.  eauto. eauto using AnnTyping_regularity.

             eapply An_Refl; eauto. eauto with ctx_wff.

             eapply An_PiFst; eauto. }



         simpl in *.

         match goal with

           [ H10: Value ?a, H9 : erase_tm ?a = _ , Ta : AnnTyping G ?a _ |- _ ] =>

           inversion Ta; subst; inversion H10; subst; simpl in H9; inversion H9 end.



         eexists.

         split.

         

         eapply multi_trans with (b:= a_App (a_Conv (a_Abs Irrel A' a0) g) Irrel a0_2).

         eapply multi_An_AppLeft; eauto_lc.



         eapply (multi_step _ RED).



         eapply multi_step.

         eapply An_ConvTerm. eauto using AnnTyping_lc1, AnnDefEq_lc3.

         eapply An_AppAbs; eauto using AnnTyping_lc1.



         eapply multi_refl.



         { lc_inversion c. repeat econstructor; eauto_lc.

           pick fresh y.

           move: (H22 y ltac:(auto)) => h0.

           rewrite (tm_subst_tm_tm_intro y); auto.

           apply tm_subst_tm_tm_lc_tm; eauto_lc.

         }



         {

           simpl_erase.

           pick fresh x.

           move: (H22 x ltac:(auto)) => RC. inversion RC.

           rewrite (tm_subst_tm_tm_intro x (erase a0)).

           replace (a_Var_f x) with (erase (a_Var_f x)); auto.

           rewrite open_tm_erase_tm.

           rewrite tm_subst_tm_tm_fresh_eq; auto.

           rewrite (tm_subst_tm_tm_intro x (erase a0)).

           replace (a_Var_f x) with (erase (a_Var_f x)); auto.

           rewrite open_tm_erase_tm.

           rewrite tm_subst_tm_tm_fresh_eq; auto.

           apply fv_tm_erase_tm; auto.

           apply fv_tm_erase_tm; auto.

         }



         destruct rho.

         +++ have P: Path T (a_App (erase v) Rel (erase a0)); by eauto

                                                                    using lc_tm_erase.

         +++ have P: Path T (a_App (erase v) Irrel a_Bullet); by eauto using lc_tm_erase.

    + 

      induction_a0.

  - 

    intros.

    match goal with

      [ H3 : erase a0 = _ |- _ ] =>

    dependent induction a0; try destruct rho; simpl in H3; inversion H3; subst

    end.

    +  

      induction_a0.



    + 

      clear IHa0.

      ann_invert_clear.

      match goal with

        [ H0 : irrelevant _ _ _ |- _ ] => inversion H0

      end.

      have ?: Value (a_UCAbs b) by eauto.

      match goal with

        [ H8 : AnnTyping G a0 _,

          H4 : AnnGood G (dom G),

          H5 : erase_tm a0 = _ |- _ ] =>

        move: (erased_Value_reduces_to_CoercedValue H8 H4 H5 ltac:(auto)) =>

        [av ?] ;  split_hyp end.

      match goal with

        [ H6 : multi (head_reduction G) a0 ?av,

          H8 : AnnTyping G a0 _ |- _ ] =>

        move: (multi_preservation H6 H8) => Tav

      end.

      

      match goal with [ H : CoercedValue av |- _ ] => inversion H; subst end.

      ++ 

        match goal with [ H10 : Value av , H9 : erase av = _ |- _ ] =>

        inversion Tav; subst; inversion H10; subst; try destruct rho;

        simpl in H9; inversion H9 end.

        subst.



        exists (open_tm_wrt_co a1 g).

        split.

        eapply multi_trans with (b := a_CApp (a_CAbs (Eq a b0 A1) a1) g).

        eapply multi_An_CAppLeft; eauto_lc.

        eapply multi_step.

        eapply An_CAppCAbs; eauto_lc.

        eapply multi_refl; eauto_lc.



        { invert_lc.

          eapply lc_body_tm_wrt_co; eauto_lc. }



        rewrite <- open_co_erase_tm2 with (g := g_Triv).

        auto.



      ++ 

         have LC: lc_tm a1 by eauto using Value_lc.

         

         match goal with

           [ H0 : irrelevant _ _ _ |- _ ] => inversion H0

         end.

         ann_invert_clear.

         match goal with

           [ H4 : AnnGood _ _,  H20 : AnnDefEq G (dom G) ?g0 A (a_CPi _ _),

             H18 : AnnTyping G a1 A, H11: Value a1 |- _ ] =>

         move: (values_have_value_types H4 H18 H11) => VT;

         move: (consistent_a_CPi H4 VT H20) => [phi' [B' EQ]]; subst;

         move : (An_CPush G a1 g0 g _ _ _ _ _ _ H11 H20 eq_refl eq_refl) => RED

         end.

         destruct phi' as [a' b' A'].

         have Tb':

           AnnDefEq G (dom G) (g_Cast g (g_Sym (g_CPiFst g0))) a' b'.

           { eapply An_Cast; eauto. }



         simpl in *.

         match goal with

           [ H10: Value ?a, H9 : erase_tm ?a = _ , Ta : AnnTyping G ?a _ |- _ ] =>

           inversion Ta; subst; inversion H10; subst; try destruct rho;

           simpl in H9; inversion H9 end.



         eexists.

         split.

         

         eapply multi_trans.



         eapply multi_An_CAppLeft; eauto_lc.



         eapply (multi_step _ RED).



         eapply multi_step.

         eapply An_ConvTerm. eauto using AnnTyping_lc1, AnnDefEq_lc3.

         eapply An_CAppCAbs; eauto_lc.



         eapply multi_refl.



         { lc_inversion c. repeat econstructor; eauto_lc. }



         simpl_erase.

         rewrite <- open_co_erase_tm2 with (g := g_Triv).

         auto.



  - 

    intros.

    dependent induction a0; try destruct rho; simpl in H2; inversion H2; subst.



    + unfold toplevel in H. unfold erase_sig in H.

      destruct (@binds_map_3 _ _ erase_csort F (Ax a A) an_toplevel H).

      split_hyp. destruct x; inversion H3. subst.



      exists a0. repeat split.

      eapply multi_step. eauto.

      eapply multi_refl.

      eauto using AnnTyping_lc1, an_toplevel_closed.



    + 

      induction_a0.



Unshelve. all: auto.

Qed.



End fc_consist.

