Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)



Require Import FcEtt.fc_dec_fuel.
(* FcEtt.fc_dec_fuel:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.

Require Import FcEtt.ett_ind.

Set Bullet Behavior "Strict Subproofs".

Module fc_dec_fuel (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).

Inductive fuel_tpg : tm -> Type :=
 | FT_Star :
    fuel_tpg a_Star
 | FT_Var_f : ∀ (x:tmvar),
    fuel_tpg (a_Var_f x)
 | FT_Pi : ∀ (rho:relflag) (A B:tm),
    (∀ x , x \notin  (fv_tm_tm_tm B) ->
      fuel_tpg (open_tm_wrt_tm B (a_Var_f x)))  ->
    fuel_tpg A ->
    fuel_tpg (a_Pi rho A B)
 | FT_Abs : ∀ (rho:relflag) (a A:tm),
    (∀ x , x \notin  (fv_tm_tm_tm a) ->
      fuel_tpg  (open_tm_wrt_tm a (a_Var_f x))) ->
    fuel_tpg A ->
    fuel_tpg (a_Abs rho A a)
 | FT_App : ∀ (rho:relflag) (b a:tm),
    fuel_tpg b ->
    fuel_tpg a ->
    fuel_tpg (a_App b rho a)
 | FT_Conv : ∀ (a:tm) g,
    fuel_tpg a ->
    fuel_deq g ->
    fuel_tpg (a_Conv a g)
 | FT_CPi : ∀ (phi:constraint) (B:tm),
    (∀ c, c \notin  (fv_co_co_tm B) -> fuel_tpg (open_tm_wrt_co B (g_Var_f c))) ->
    fuel_pwf phi ->
    fuel_tpg (a_CPi phi B)
 | FT_CAbs : ∀ (a:tm) (phi:constraint),
    (∀ c, c \notin (fv_co_co_constraint phi \u fv_co_co_tm a) -> fuel_tpg (open_tm_wrt_co a (g_Var_f c))) ->
    fuel_pwf phi ->
    fuel_tpg (a_CAbs phi a)
 | FT_CApp : ∀ (b:tm) g,
    fuel_tpg b ->
    fuel_deq g ->
    fuel_tpg (a_CApp b g)
 | FT_Const : ∀ (T:atom),
    fuel_tpg (a_Const T)
 | FT_Fam : forall (F:tyfam),
    fuel_tpg (a_Fam F)

 | FT_Var_b : forall n0,
     fuel_tpg (a_Var_b n0)
 | FT_UAbs : forall rho a,
     fuel_tpg (a_UAbs rho a)
 | FT_UCAbs : forall a,
     fuel_tpg (a_UCAbs a)
 | FT_DataCon : forall K,
     fuel_tpg (a_DataCon K)
 | FT_Case : forall a brs5,
     fuel_tpg (a_Case a brs5)
 | FT_Bullet :
     fuel_tpg a_Bullet

with fuel_pwf : constraint -> Type :=
  | FP_fuel_pwf : ∀ a b A,
    fuel_tpg a ->
    fuel_tpg b ->
    fuel_pwf (Eq a b A)

with fuel_iso : co -> Type :=
  | FI_Cong : ∀ (g1:co) (A:tm) (g2:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_iso (g_EqCong g1 A g2)
  | FI_CPiFst : ∀ (g:co),
    fuel_deq g ->
    fuel_iso (g_CPiFst g)
  | FI_IsoSym : ∀ (g:co),
    fuel_iso g ->
    fuel_iso (g_Sym g)
  | FI_IsoConv : ∀ (g:co) phi1 phi2,
    fuel_deq g ->
    fuel_pwf phi1 ->
    fuel_pwf phi2 ->
    fuel_iso (g_IsoConv phi1 phi2 g)

  | FI_Triv :
    fuel_iso g_Triv
  | FI_Var_b : forall n0,
    fuel_iso (g_Var_b n0)
  | FI_Var_f : ∀ (c:covar),
    fuel_iso (g_Var_f c)
  | FI_Refl : ∀ (a:tm),
    fuel_iso (g_Refl a)
  | FI_Refl2 : ∀ (a b:tm) (g:co),
    fuel_iso (g_Refl2 a b g)
  | FI_Trans : ∀ (g1 g2: co),
    fuel_iso (g_Trans g1 g2)
  | FI_Beta : ∀ (a1 a2:tm),
    fuel_iso (g_Beta a1 a2)
  | FI_PiCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_iso (g_PiCong rho g1 g2)
  | FI_AbsCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_iso ((g_AbsCong rho g1 g2))
  | FI_AppCong : ∀ (g1:co) (g2:co) (rho:relflag),
    fuel_iso (g_AppCong g1 rho g2)
  | FI_PiFst : ∀ (g:co),
    fuel_iso (g_PiFst g)
  | FI_PiSnd : ∀ (g1 g2:co),
    fuel_iso (g_PiSnd g1 g2)
  | FI_CPiCong : ∀ (g1 g3:co),
    fuel_iso ((g_CPiCong g1 g3))
  | FI_CAbsCong : ∀ (g1 g3 g4:co),
    fuel_iso ((g_CAbsCong g1 g3 g4))
  | FI_CAppCong : ∀  (g1 g2 g3:co),
    fuel_iso (g_CAppCong g1 g2 g3)
  | FI_CPiSnd : ∀  (g1 g2 g3:co),
    fuel_iso (g_CPiSnd g1 g2 g3)
  | FI_Cast : ∀  (g1 g2:co),
    fuel_iso (g_Cast g1 g2)
  | FI_IsoSnd : ∀  (g:co),
    fuel_iso (g_IsoSnd g)

  | FI_Eta : forall a,
    fuel_iso (g_Eta a)

  | FI_Left : forall g1 g2,
      fuel_iso (g_Left g1 g2)
  | FI_Right : forall g1 g2,
      fuel_iso (g_Right g1 g2)

with fuel_deq : co -> Type :=
  | FD_Assn : ∀ (c:covar),
    fuel_deq (g_Var_f c)
  | FD_Refl : ∀ (a:tm),
    fuel_tpg a ->
    fuel_deq (g_Refl a)
  | FD_Refl2 : ∀ (a b:tm) (g:co),
    fuel_tpg a ->
    fuel_tpg b ->
    fuel_deq g ->
    fuel_deq (g_Refl2 a b g)
  | FD_Sym : ∀ (g:co),
    fuel_deq g ->
    fuel_deq (g_Sym g)
  | FD_Trans : ∀ (g1 g2: co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq (g_Trans g1 g2)
  | FD_Beta : ∀ (a1 a2:tm),
    fuel_tpg a1 ->
    fuel_tpg a2 ->
    fuel_deq (g_Beta a1 a2)

  | FD_PiCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_deq g1 ->
    (∀ x, x \notin (fv_tm_tm_co g1 \u fv_tm_tm_co g2) ->
      fuel_deq (open_co_wrt_tm g2 (a_Var_f x))) ->
    fuel_deq (g_PiCong rho g1 g2)
  | FD_AbsCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_deq g1 ->
    (∀ x,
      x \notin (fv_tm_tm_co g1 \u fv_tm_tm_co g2) ->
      fuel_deq (open_co_wrt_tm g2 (a_Var_f x))) ->
    fuel_deq ((g_AbsCong rho g1 g2))
  | FD_AppCong : ∀ (g1:co) (g2:co) (rho:relflag),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq (g_AppCong g1 rho g2)
  | FD_PiFst : ∀ (g:co),
    fuel_deq g ->
    fuel_deq (g_PiFst g)
  | FD_PiSnd : ∀ (g1 g2:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq (g_PiSnd g1 g2)
  | FD_CPiCong : ∀ (g1 g3:co),
    fuel_iso g1 ->
    (∀ c,
      c \notin  (fv_co_co_co g1 \u fv_co_co_co g3) ->
      fuel_deq (open_co_wrt_co g3 (g_Var_f c))) ->
    fuel_deq ((g_CPiCong g1 g3))
  | FD_CAbsCong : ∀ (g1 g3 g4:co),
    fuel_iso g1 ->
    (∀ c,
      c \notin (fv_co_co_co g1 \u fv_co_co_co g3) ->
      fuel_deq (open_co_wrt_co g3 (g_Var_f c))) ->
    fuel_deq g4 ->
    fuel_deq ((g_CAbsCong g1 g3 g4))
  | FD_CAppCong : ∀  (g1 g2 g3:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq g3 ->
    fuel_deq (g_CAppCong g1 g2 g3)
  | FD_CPiSnd : ∀  (g1 g2 g3:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq g3 ->
    fuel_deq (g_CPiSnd g1 g2 g3)
  | FD_Cast : ∀  (g1 g2:co),
    fuel_deq g1 ->
    fuel_iso g2 ->
    fuel_deq (g_Cast g1 g2)
  | FD_IsoSnd : ∀  (g:co),
    fuel_iso g ->
    fuel_deq (g_IsoSnd g)

  | FD_Triv :
      fuel_deq g_Triv
  | FD_Var_b : forall n0,
      fuel_deq (g_Var_b n0)
  | FD_CPiFst : ∀ (g:co),
    fuel_deq (g_CPiFst g)
  | FD_Cong : ∀ (g1:co) (A:tm) (g2:co),
    fuel_deq (g_EqCong g1 A g2)
  | FD_IsoConv : ∀ (g:co) phi1 phi2,
      fuel_deq (g_IsoConv phi1 phi2 g)

  | FD_Eta : forall a,
      fuel_tpg a ->
      fuel_deq (g_Eta a)

  | FD_Left : forall g1 g2,
      fuel_deq g1 ->
      fuel_deq g2 ->
      fuel_deq (g_Left g1 g2)

  | FD_Right : forall g1 g2,
      fuel_deq g1 ->
      fuel_deq g2 ->
      fuel_deq (g_Right g1 g2)

.

Hint Constructors fuel_deq fuel_iso fuel_pwf fuel_tpg.

Scheme
     ind_fuel_tpg := Induction for fuel_tpg Sort Prop
with ind_fuel_pwf := Induction for fuel_pwf Sort Prop
with ind_fuel_iso := Induction for fuel_iso Sort Prop
with ind_fuel_deq := Induction for fuel_deq Sort Prop.

Combined Scheme fuel_mutind from ind_fuel_tpg, ind_fuel_pwf, ind_fuel_iso, ind_fuel_deq.

End fc_dec_fuel. *)

Require Import FcEtt.fc_dec_fun.
(* FcEtt.fc_dec_fun:
Require Import FcEtt.sigs.

Require Import FcEtt.fc_dec_fuel.
Require Import FcEtt.fc_dec_aux.

Require Import FcEtt.imports.
Require Export FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.
Require Export FcEtt.fc_invert.

Require Import FcEtt.dep_prog.

Require Import FcEtt.toplevel.

Require Import FcEtt.fc_get.
Require Import FcEtt.fc_context_fv.

Module fc_dec_fun (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).

Module invert := fc_invert wf weak subst.
Module fuel := fc_dec_fuel wf weak subst unique.
Module aux := fc_dec_aux wf weak subst unique.
Module get := fc_get wf weak subst unique.

Import fuel aux unique wf subst invert get.

Unset Implicit Arguments.

Ltac obtacpre :=
  intros; simpl in *.

Ltac obtacsolve :=
  intros; simpl in *; try solve [ok].

Lemma An_IsoConv': ∀ (G : context) (D : available_props)
                     (a1 a2 A a1' a2' B : tm) phi1 phi2 (g : co),
  phi1 =  (Eq a1 a2 A)  →
  phi2 = (Eq a1' a2' B) →
  AnnDefEq G D g A B  →
  AnnPropWff G phi1 →
  AnnPropWff G phi2 →
  erase_tm a1 = erase_tm a1' →
  erase_tm a2 = erase_tm a2' →
  AnnIso G D (g_IsoConv phi1 phi2 g) phi1 phi2.

Lemma get_tpg_correct' : ∀ {G : context} {a A : tm},
    AnnTyping G a A → A = get_tpg G a.

Lemma get_deq_correct' : ∀ {G : context} {D : available_props} {g : co} {A B},
    AnnDefEq G D g A B → get_deq G g = (A, B).

Lemma get_iso_correct' : ∀ {G : context} {D : available_props} {g : co} {phi1 phi2 : constraint}, AnnIso G D g phi1 phi2 → get_iso G g = (phi1, phi2).

Ltac clear_annoying :=
  repeat match goal with
    | [H: <<_>> = _ |- _ ] => clear H
    | [H: <<_, _>> = _ |- _ ] => clear H
    | [H: !! = _ |- _ ] => clear H
    | [H: yeah = _ |- _ ] => clear H
    | [H: nope = _ |- _ ] => clear H
    | [ H :     !! = _     |- _ ] => clear H
    | [ H :     _ + { _ } |- _ ] => clear H
    | [ H : { _ } + { _ } |- _ ] => clear H
    | [ H : { _ | _} + { _ } |- _ ] => clear H
    | [ H : { _, _ | _} + { _ } |- _ ] => clear H
  end.

Ltac intro_uniq_full H :=
    match type of H with
      | AnnTyping ?G ?a ?A =>
        let x := fresh "u" in
        move : (@AnnTyping_unique G a A H) => x;
        
        repeat match goal with
          | [H' : AnnTyping G a ?A' |- _ ] =>  move: (x _ H') => ?; wrap_hyp H'
        end
      | AnnDefEq ?G ?L ?g ?A1 ?A2 =>
        let x := fresh "u" in
        move : (@AnnDefEq_unique G L g A1 A2 H) => x;
        
        repeat match goal with
          | [H' : AnnDefEq G L g ?A1' ?A2' |- _ ] =>  move: (x _ _ H') => ?; wrap_hyp H'
        end
      | AnnIso ?G ?L ?g ?phi1 ?phi2 =>
        let x := fresh "u" in
        move : (@AnnIso_unique G L g phi1 phi2 H) => x;
        
        repeat match goal with
          | [H' : AnnIso G L g ?phi1' ?phi2' |- _ ] =>  move: (x _ _ H') => ?; wrap_hyp H'
        end
    end.

Ltac auto_uniq_full :=
  revert_all_with intro_uniq_full; intros; pcess_hyps.

Ltac terminator := auto_uniq_full; subst_forall; subst; cbn; pcess_hyps;
  
  try solve [try econstructor; intuition (subst; eauto 3) | intuition (subst; eauto 3 with smart_cons_exists)].

Ltac hacky :=
  do 3 (
    intros;
      try(
  try (multimatch goal with
    | [ |- ¬ _ ] => let H := fresh in intro H; inversion H; terminator
    | _ => idtac
  end);
  try (multimatch goal with
    | [ H : ¬ _ |-  _ ] => solve [edestruct H; terminator]
    | [ H : forall _, ¬ _ |-  _ ] => solve [edestruct H; terminator]
    | [ H : forall _ _, ¬ _ |-  _ ] => solve [edestruct H; terminator]
  end); terminator)).

Ltac clearbodies :=
  repeat match goal with
    | [ H := _ : _ |- _] => clearbody H
  end.

Ltac clearbodies' :=
  repeat match goal with
    | [ x := ?bdy : _ |- _] =>
      move: (eq_refl x);
      rewrite -{2}[x]/bdy;
      clearbody x;
      let eqname := fresh "eq" x in
      move => eqname
  end.

Ltac clean_fun :=
  match goal with
    | [
        AnnTyping_dec : Tactics.fix_proto (∀ (G : context) (t : tm), fuel_tpg t → AnnCtx G → {T : tm | AnnTyping G t T} + {(∀ T : tm, ¬ AnnTyping G t T)}),
        AnnPropWff_dec : Tactics.fix_proto (∀ (G : context) (phi : constraint), fuel_pwf phi → AnnCtx G → {AnnPropWff G phi} + {¬ AnnPropWff G phi}),
        AnnDefEq_dec : Tactics.fix_proto (∀ (G : context) (S : available_props) (g : co), fuel_deq g → AnnCtx G → {A, B | AnnDefEq G S g A B} + {(∀ A B : tm, ¬ AnnDefEq G S g A B)}),
        AnnIso_dec : Tactics.fix_proto (∀ (G : context) (S : available_props) (g : co), fuel_iso g → AnnCtx G → {phi1, phi2 | AnnIso G S g phi1 phi2} + {(∀ phi1 phi2 : constraint, ¬ AnnIso G S g phi1 phi2)})
      |- _ ] => clear AnnTyping_dec AnnPropWff_dec AnnDefEq_dec AnnIso_dec
  end.

Ltac clear_sums :=
  repeat match goal with
    | [ H :     !! = _     |- _ ] => clear H
    | [ H :     _ + { _ } |- _ ] => clear H
    | [ H : { _ } + { _ } |- _ ] => clear H
  end.

Ltac cleanup_param cbodies sbst:=
  clear_annoying;
  intros; simpl in *;
  cbodies;
  try solve [ok];
  try clean_fun;
  clear_sums;
  sbst. 

Ltac cleanup := cleanup_param clearbodies subst.
Ltac cleanup' := cleanup_param clearbodies' idtac.

Obligation Tactic := try solve [hacky].

Program Definition AnnPropWff_dec' (G: context) (a b A : tm) (A' B': tm) (H : AnnCtx G)
                                  (pA: AnnTyping G a A') (pB: AnnTyping G b B') : {AnnPropWff G (Eq a b A)} + {¬ AnnPropWff G (Eq a b A)} :=
  tm_eq_dec A A' >-->
  tm_eq_dec (erase A) (erase B') >-->
  yeah.

Obligation Tactic := obtacpre; first [match goal with [|- tm] => idtac end | eassumption].

Program Fixpoint AnnTyping_dec (G : context) (t : tm) (fuel : fuel_tpg t) (H : AnnCtx G) {struct fuel} : {T : tm | AnnTyping G t T } + {(forall T, ¬ AnnTyping G t T)}  :=
  match fuel with
    | FT_Star =>  << a_Star >>

    | FT_Var_f x =>
      A <- binds_dec_tm x G;
      << A >>

    | FT_Pi rho A B fB fA =>
      let (x, p) := atom_fresh (dom G \u fv_tm_tm_tm B) in
      KA <- AnnTyping_dec G A fA _;
      tm_eq_dec KA a_Star >--->
      KB <- AnnTyping_dec ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) (fB x _) _;
      tm_eq_dec KB a_Star >--->
      << a_Star >>

    | FT_Abs rho a A fa fA =>
      
      let (x, p) := atom_fresh (dom G \u fv_tm_tm_tm a) in
      KA <- AnnTyping_dec G A fA _;
      tm_eq_dec KA a_Star >--->
      B <- AnnTyping_dec ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (fa x _) _;
      RhoCheck_erase_dec rho x (open_tm_wrt_tm a (a_Var_f x)) _ >--->
      << a_Pi rho A (close_tm_wrt_tm x B )>>

    | FT_App rho b a fb fa =>
      A <- AnnTyping_dec G a fa _;
      Tf <- AnnTyping_dec G b fb _;
      match Tf with
        | a_Pi rho' A' B =>
          tm_eq_dec A' A >--->
          rho_eq_dec rho rho' >---> << open_tm_wrt_tm B a >>
        | _ => !!
      end

    | FT_Conv a g fa fg =>
      A <- AnnTyping_dec G a fa _;
      A' & B <- AnnDefEq_dec G (dom G) g fg _;
      let K := get_tpg G B in
  
      tm_eq_dec K a_Star >--->
      tm_eq_dec A A' >--->
      << B >>

    | FT_CApp b g fb fg =>
      TB <- AnnTyping_dec G b fb _ ;
      A1' & A2' <- AnnDefEq_dec G (dom G) g fg _;
      match TB with
        | (a_CPi (Eq A1 A2 K) B) =>
          tm_eq_dec A1 A1' >--->
          tm_eq_dec A2 A2' >--->
          << open_tm_wrt_co B g >>
        | _ => !!
      end

    | FT_Const T =>
      K <- binds_dec_cs T an_toplevel;
      (@DataTy_Star_dec K) _ >--->
      << K >>

    | FT_CPi phi B fB fphi =>
      AnnPropWff_dec G phi fphi _ >--->
      let (c, p) := atom_fresh (dom G \u fv_co_co_tm B) in
      KB <- AnnTyping_dec ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) (fB c _) _;
      tm_eq_dec KB a_Star >--->
      << a_Star >>

    | FT_CAbs a phi fa fphi =>
      AnnPropWff_dec G phi fphi _ >--->
      let (c, p) := atom_fresh (dom G \u fv_co_co_constraint phi \u fv_co_co_tm a) in
      Bc <- AnnTyping_dec ((c ~ Co  phi ) ++  G) (open_tm_wrt_co a (g_Var_f c)) (fa c _) _;
      << a_CPi phi (close_tm_wrt_co c Bc) >>

    | FT_UAbs _ _ => !!
    | FT_UCAbs _  => !!
    | FT_Bullet   => !!

    | FT_Var_b _ => !!
  
    | FT_DataCon _ => !!
    | FT_Case _ _ => !!

    | FT_Fam F =>
      a & A <- binds_dec_ax F an_toplevel;
        << A >>
  end

with AnnPropWff_dec (G: context) (phi : constraint) (fuel : fuel_pwf phi)
                    (H : AnnCtx G) {struct fuel} : {AnnPropWff G phi} + {¬ AnnPropWff G phi} :=
  match fuel with
    | FP_fuel_pwf a b K fa fb =>
      Ka <-- AnnTyping_dec G a fa _;
      Kb <-- AnnTyping_dec G b fb _;
      tm_eq_dec K Ka >-->
      tm_eq_dec (erase K) (erase Kb) >--> yeah
  end

with AnnDefEq_dec (G: context) (S : available_props) (g : co) (fuel : fuel_deq g)
                  (H: AnnCtx G) {struct fuel} : {A, B | AnnDefEq G S g A B} + {(forall A B, ¬ AnnDefEq G S g A B)} :=
  match fuel with
    | FD_Assn c =>
        in_dec c S >--->
        AB & K <- binds_dec_co c G;
        << fst AB, snd AB >>

    | FD_Refl a fa =>
        A <- AnnTyping_dec G a fa _;
        <<a, a>>

    | FD_Refl2 a b g fa fb fg =>
        A <- AnnTyping_dec G a fa _;
        B <- AnnTyping_dec G b fb _;
        tm_eq_dec (erase_tm a) (erase_tm b) >--->
        A' & B' <- AnnDefEq_dec G (dom G) g fg _;
        tm_eq_dec A A' >--->
        tm_eq_dec B B' >--->
        << a, b >>

    | FD_Sym g fg =>
        b & a <- AnnDefEq_dec G S g fg _;
        << a, b >>

    | FD_Trans g1 g2 fg1 fg2 =>
        a & c <- AnnDefEq_dec G S g1 fg1 _;
        d & b <- AnnDefEq_dec G S g2 fg2 _;
        tm_eq_dec c d >--->
        << a, b >>

    | FD_Beta a1 a2 fa1 fa2 =>
        A1 <- AnnTyping_dec G a1 fa1 _;
        A2 <- AnnTyping_dec G a2 fa2 _;
        tm_eq_dec (erase_tm A1) (erase_tm A2) >--->
        @beta_dec (erase_tm a1) (erase_tm a2) _ >--->
        << a1, a2 >>

    | FD_PiCong rho g1 g2 fg1 fg2 =>
      A1 & A2 <- AnnDefEq_dec G S g1 fg1 _;
      tm_eq_dec (get_tpg G A1) a_Star >--->
      tm_eq_dec (get_tpg G A2) a_Star >--->
      let (x, _) := atom_fresh (dom G \u fv_tm_tm_co g1 \u fv_tm_tm_co g2) in
      B1x & B2x <- AnnDefEq_dec ([(x, Tm A1)] ++ G) S (open_co_wrt_tm g2 (a_Var_f x)) (fg2 x _) _;
      let B1  := close_tm_wrt_tm x B1x in
      let B2  := close_tm_wrt_tm x B2x in
      let B3x := tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2x in
      let B3  := close_tm_wrt_tm x B3x in
      
      tm_eq_dec (get_tpg ([(x, Tm A1)] ++ G) B1x) a_Star >--->
      tm_eq_dec (get_tpg ([(x, Tm A1)] ++ G) B2x) a_Star >--->
      tm_eq_dec (get_tpg ([(x, Tm A2)] ++ G) B3x) a_Star >--->
      << a_Pi rho A1 B1, a_Pi rho A2 B3 >>

    | FD_AbsCong rho g1 g2 fg1 fg2 =>
      A1 & A2 <- AnnDefEq_dec G S g1 fg1 _;
      tm_eq_dec (get_tpg G A1) a_Star >--->
      tm_eq_dec (get_tpg G A2) a_Star >--->
      let (x, p) := atom_fresh (dom G \u fv_tm_tm_co g1 \u fv_tm_tm_co g2) in
      B1x & B2x <- AnnDefEq_dec ([(x, Tm A1)] ++ G) S (open_co_wrt_tm g2 (a_Var_f x)) (fg2 x _) _;
      let B1 := close_tm_wrt_tm x B1x in
      let B2 := close_tm_wrt_tm x B2x in
      let B3x := tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2x in
      let B3  := close_tm_wrt_tm x B3x in
      
      RhoCheck_erase_dec rho x B1x _ >--->
      RhoCheck_erase_dec rho x B3x _ >--->
      
      << a_Abs rho A1 B1, a_Abs rho A2 B3 >>

    | FD_AppCong g1 g2 rho fg1 fg2 =>
      a1 & a2 <- AnnDefEq_dec G S g1 fg1 _;
      b1 & b2 <- AnnDefEq_dec G S g2 fg2 _;
      let Ta1 := get_tpg G a1 in
      let Ta2 := get_tpg G a2 in
      let Tb1 := get_tpg G b1 in
      let Tb2 := get_tpg G b2 in
      match Ta1, Ta2 with
        | a_Pi rho1 A1 _, a_Pi rho2 A2 _ =>
          tm_eq_dec A1 Tb1 >--->
          tm_eq_dec A2 Tb2 >--->
          rho_eq_dec rho rho1 >--->
          rho_eq_dec rho rho2 >--->
          << a_App a1 rho b1, a_App a2 rho b2 >>
        | _, _ => !!
      end

    | FD_CPiCong g1 g3 fg1 fg3 =>
        phi1 & phi2 <- AnnIso_dec G S g1 fg1 _;
        let (c, _) := atom_fresh (S \u dom G \u fv_co_co_co g1 \u fv_co_co_co g3) in
        B1c & B2c <- AnnDefEq_dec ([(c, Co phi1)] ++ G) S (open_co_wrt_co g3 (g_Var_f c)) (fg3 c _) _;
        let B1  := close_tm_wrt_co c B1c in
        let B2  := close_tm_wrt_co c B2c in
        let B3c := open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)) in
        let B3  := close_tm_wrt_co c (B3c) in
        tm_eq_dec (get_tpg ([(c,Co phi1)] ++ G) B1c) a_Star >--->
        tm_eq_dec (get_tpg ([(c,Co phi2)] ++ G) B3c) a_Star >--->
        tm_eq_dec (get_tpg ([(c,Co phi1)] ++ G) B2c) a_Star >--->
        << a_CPi phi1 B1, a_CPi phi2 B3 >>

    | FD_CAbsCong g1 g3 g4 fg1 fg3 fg4 =>
        phi1 & phi2 <- AnnIso_dec G S g1 fg1 _;
        let (c, _) := atom_fresh (S \u dom G \u fv_co_co_co g1 \u fv_co_co_co g3) in
        a1c & a2c <- AnnDefEq_dec ([(c, Co phi1)] ++ G) S (open_co_wrt_co g3 (g_Var_f c)) (fg3 c _) _;
        let a1  := close_tm_wrt_co c a1c in
        let a2  := close_tm_wrt_co c a2c in
        let a3c := open_tm_wrt_co a2 (g_Cast (g_Var_f c) (g_Sym g1)) in
        let a3  := close_tm_wrt_co c a3c in
        let B1c := get_tpg ([(c, Co phi1)] ++ G) a1c in
        let B3c := get_tpg ([(c, Co phi2)] ++ G) a3c in
        CPi1 & CPi2 <- AnnDefEq_dec G (dom G) g4 fg4 _;
        tm_eq_dec CPi1 (a_CPi phi1 (close_tm_wrt_co c B1c)) >--->
        tm_eq_dec CPi2 (a_CPi phi2 (close_tm_wrt_co c B3c)) >--->
        << a_CAbs phi1 a1, a_CAbs phi2 a3 >>

    | FD_CAppCong g1 g2 g3 fg1 fg2 fg3 =>
      a1 & a2 <- AnnDefEq_dec G S g1 fg1 _;
      b1 & b2 <- AnnDefEq_dec G (dom G) g2 fg2 _;
      c1 & c2 <- AnnDefEq_dec G (dom G) g3 fg3 _;
      let Ta1 := get_tpg G a1 in
      let Ta2 := get_tpg G a2 in
      match Ta1, Ta2 with
        | a_CPi (Eq Ta11 Ta12 _) _, a_CPi (Eq Ta21 Ta22 _) _ =>
          
          tm_eq_dec Ta11 b1 >--->
          tm_eq_dec Ta12 b2 >--->
          tm_eq_dec Ta21 c1 >--->
          tm_eq_dec Ta22 c2 >--->
          << a_CApp a1 g2, a_CApp a2 g3 >>
        | _, _ => !!
      end

    | FD_CPiSnd g1 g2 g3 fg1 fg2 fg3 =>
      a1 & a2 <- AnnDefEq_dec G S g1 fg1 _;
      a & a' <- AnnDefEq_dec G (dom G) g2 fg2 _;
      b & b' <- AnnDefEq_dec G (dom G) g3 fg3 _;
      match a1, a2 with
        | a_CPi (Eq a_ a_' _) B1, a_CPi (Eq b_ b_' _) B2 =>
          tm_eq_dec a  a_  >--->
          tm_eq_dec a' a_' >--->
          tm_eq_dec b  b_  >--->
          tm_eq_dec b' b_' >--->
          << open_tm_wrt_co B1 g2, open_tm_wrt_co B2 g3 >>
        | _, _ => !!
      end

    | FD_Cast g1 g2 fg1 fg2 =>
      a & a' <- AnnDefEq_dec G S g1 fg1 _;
      phi1 & phi2 <- AnnIso_dec G S g2 fg2 _;
      match phi1, phi2 with
        | Eq a_ a'_ _, Eq b b' _ =>
          tm_eq_dec a  a_  >--->
          tm_eq_dec a' a'_ >--->
          << b, b' >>
      end

    | FD_PiFst g fg =>
      T1 & T2 <- AnnDefEq_dec G S g fg _;
      match T1, T2 with
        | a_Pi rho1 A1 B1, a_Pi rho2 A2 B2 => rho_eq_dec rho1 rho2 >---> << A1, A2 >>
        | _, _ => !!
      end

    | FD_PiSnd g1 g2 fg1 fg2 =>
        T1 & T2 <- AnnDefEq_dec G S g1 fg1 _;
        a1 & a2 <- AnnDefEq_dec G S g2 fg2 _;
             let A1 := get_tpg G a1 in
        let A2 := get_tpg G a2 in
        match T1 with
          | a_Pi rho A1' B1 =>
            tm_eq_dec A1 A1' >--->
            match T2 with
              | a_Pi rho' A2' B2 =>
                tm_eq_dec A2 A2' >--->
                rho_eq_dec rho rho' >--->
                << open_tm_wrt_tm B1 a1, open_tm_wrt_tm B2 a2 >>
              | _ => !!
            end
          | _ => !!
        end

    | FD_IsoSnd g fg =>
      phi1 & phi2 <- AnnIso_dec G S g fg _;
      match phi1, phi2 with
        | (Eq _ _ A), (Eq _ _ B) => << A, B>>
      end

    | FD_Eta b fb =>
      let (x, p) := atom_fresh (dom G \u fv_tm_tm_tm b) in
      T <- AnnTyping_dec G b fb _;
      match T with
      | a_Pi Rel A B =>
        << a_Abs Rel A (close_tm_wrt_tm x (a_App b Rel (a_Var_f x))), b >>
      | a_Pi Irrel A B =>
        << a_Abs Irrel A (close_tm_wrt_tm x (a_App b Irrel (a_Var_f x))), b >>
      | a_CPi phi B =>
        << a_CAbs phi (close_tm_wrt_co x (a_CApp b (g_Var_f x))), b >>
      | _ => !!
      end

    | FD_Left g1  g2 fg1 fg2  => !!
    | FD_Right _ _ _ _ => !!

    | FD_Triv          => !!
    | FD_Var_b _       => !!
    | FD_CPiFst _      => !!
    | FD_Cong _ _ _    => !!
    | FD_IsoConv _ _ _ => !!

  end

with AnnIso_dec (G: context) (S : available_props) (g : co) (fuel : fuel_iso g)
                (H: AnnCtx G) {struct fuel} : {phi1, phi2 | AnnIso G S g phi1 phi2} + {(forall phi1 phi2, ¬ AnnIso G S g phi1 phi2)} :=
  match fuel with
    | FI_Cong g1 A g2 fg1 fg2 =>
      A1 & A2 <- AnnDefEq_dec G S g1 fg1 _;
      B1 & B2 <- AnnDefEq_dec G S g2 fg2 _;
      AnnPropWff_dec' G A1 B1 A (get_tpg G A1) (get_tpg G B1) _ _ _ >--->
      AnnPropWff_dec' G A2 B2 A (get_tpg G A2) (get_tpg G B2) _ _ _ >--->
      << Eq A1 B1 A, Eq A2 B2 A >>

    | FI_CPiFst g fg =>
      pi1 & pi2 <- AnnDefEq_dec G S g fg _;
      match pi1, pi2 with
        | a_CPi phi1 _, a_CPi phi2 _ =>
          << phi1, phi2 >>
        | _, _ => !!
      end

    | FI_IsoSym g fg =>
      phi2 & phi1 <- AnnIso_dec G S g fg _;
      << phi1, phi2 >>

    | FI_IsoConv g phi1 phi2 fg fpwf1 fpwf2  =>
      A' & B' <- AnnDefEq_dec G S g fg _;
      AnnPropWff_dec G phi1 fpwf1 _ >--->
      AnnPropWff_dec G phi2 fpwf2 _ >--->
      match phi1, phi2 with
        | Eq a1 a2 A, Eq a1' a2' B =>
          tm_eq_dec (erase_tm  a1) (erase_tm  a1') >--->
          tm_eq_dec (erase_tm  a2) (erase_tm  a2') >--->
          tm_eq_dec A A' >--->
          tm_eq_dec B B' >--->
          << phi1, phi2 >>
      end

    | FI_Var_f c => !!
    | FI_Var_b _ => !!
    | FI_Refl a => !!
    | FI_Refl2 a b g => !!
    | FI_Trans g1 g2 =>  !!
    | FI_Beta a1 a2 => !!
    | FI_PiCong rho g1 g2 => !!
    | FI_AbsCong _ _ _ => !!
    | FI_AppCong g1 rho g2 => !!
    | FI_CAbsCong _ _ _ => !!
    | FI_CAppCong g1 g2 g3 => !!
    | FI_PiFst g => !!
    | FI_Cast g1 g2 => !!
    | FI_PiSnd g1 g2 => !!
    | FI_Triv => !!
    | FI_CPiCong _ _ => !!
    | FI_CPiSnd _ _ _ => !!
    | FI_IsoSnd _ => !!
    | FI_Eta _ => !!
    | FI_Left _ _ => !!
    | FI_Right _ _ => !!
  end

.

End fc_dec_fun. *)

Require Import FcEtt.fc_dec_aux.
(* FcEtt.fc_dec_aux:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.dep_prog.
Require Export FcEtt.ett_ind.
Require Export FcEtt.ett_par. 
Require Export FcEtt.erase_syntax.  

Module fc_dec_aux (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).

Import unique.

Lemma eq_relflag_dec : forall t1 t2 : relflag, {t1 = t2} +  {~ t1 = t2}.

Ltac nosub t2 :=  destruct t2; try solve[ left; auto]; right; done.

Ltac onesub t2 :=
    let h := fresh in
    destruct t2;
    try solve [right; done];
    match goal with
      [
         H0 : ∀ t2, {?B = t2} + {?B ≠ t2} |-
                    { ?C ?B = ?C ?e } + { ?F } ] =>
      destruct (H0 e); subst;
        try solve [left; auto];
        try solve [right; intro h; inversion h; done]
            end.
Ltac twosub t2 :=
    let h := fresh in
    destruct t2;
    try solve [right; done];
    match goal with
      [  H : ∀ t2, {?phi = t2} + {?phi ≠ t2},
         H0 : ∀ t2, {?B = t2} + {?B ≠ t2} |-
                    { ?C ?phi ?B = ?C ?d ?e } + { ?F } ] =>
      destruct (H d); subst; destruct (H0 e); subst;
        try solve [left; auto];
        try solve [right; intro h; inversion h; done]
         end.
Ltac threesub t2 :=
    let h := fresh in
    destruct t2;
    try solve [right; done];
    match goal with
      [  H : ∀ t2, {?phi = t2} + {?phi ≠ t2},
         H1 : ∀ t2, {?A = t2} + {?A ≠ t2},
         H0 : ∀ t2, {?B = t2} + {?B ≠ t2} |-
                    { ?C ?phi ?A ?B = ?C ?d ?e ?f} + { ?F } ] =>
      destruct (H d); subst; destruct (H1 e); subst;
      destruct (H0 f); subst;
        try solve [left; auto];
        try solve [right; intro h; inversion h; done]
         end.

Lemma tm_eq_dec_mutual :
  ((forall t1 t2 : tm, {t1 = t2} +  {~ t1 = t2}) *
   (forall t1 t2 : brs, {t1 = t2} +  {~ t1 = t2}) *
   (forall t1 t2 : co, {t1 = t2} +  {~ t1 = t2}) *
   (forall t1 t2 : constraint, {t1 = t2} +  {~ t1 = t2})).

Lemma tm_eq_dec : forall t1 t2 : tm, {t1 = t2} + {~ t1 = t2}.

Lemma const_eq_dec : forall (phi1 phi2 : constraint), {phi1 = phi2} + {¬ phi1 = phi2}.

Lemma co_eq_dec : forall g1 g2 : co, {g1 = g2} + {~ g1 = g2}.

Lemma in_dec : forall x L, {x `in` L} + {¬ x `in` L}.

Lemma not_in_dec : forall x L, {¬ x `in` L} + {x `in` L}.

Lemma uniq_binds_dec_tm : forall x G, uniq G -> {A | binds x (Tm A) G} + {(forall A, ¬ binds x (Tm A) G)}.

Lemma binds_dec_tm : forall x G, {A | binds x (Tm A) G} + {(forall A, ¬ binds x (Tm A) G)}.

Lemma binds_dec_co : forall x G, {AB, K | binds x (Co (Eq (fst AB) (snd AB) K)) G} + {(forall A B K, ¬ binds x (Co (Eq A B K)) G)}.

Lemma binds_dec_cs : forall x G, {C | binds x (Cs  C) G} + {(forall C, ¬ binds x (Cs  C) G)}.

Lemma Path_dec : forall a, lc_tm a -> { T | Path T a } + { (forall T, not (Path T a)) }.

Lemma Value_AbsIrrel_inversion : forall A a,
    Value (a_Abs Irrel A a)
    -> lc_tm A /\ forall x, x `notin` fv_tm a -> CoercedValue (open_tm_wrt_tm a (a_Var_f x)).

Lemma Value_UAbsIrrel_inversion : forall a,
    Value (a_UAbs Irrel a)
    -> forall x, x `notin` fv_tm a -> Value (open_tm_wrt_tm a (a_Var_f x)).

Ltac eauto_lc :=
  eauto using lc_tm_of_lc_set_tm,
  lc_co_of_lc_set_co,
  lc_constraint_of_lc_set_constraint.

Lemma decide_Value_mutual : forall a, lc_set_tm a -> ({ Value a } + { not (Value a) }) * ({ CoercedValue a } + { not (CoercedValue a) }).

Lemma Value_dec :  forall a, lc_tm a -> ({ Value a } + { not (Value a) }).

Lemma DataTy_Star_dec : forall A, lc_set_tm A -> { DataTy A a_Star } + { not (DataTy A a_Star) }.

Lemma binds_dec_ax : forall x G, {A, B | binds x (Ax A B) G} + {(forall A B, ¬ binds x (Ax A B) G)}.

Definition rho_eq_dec : forall rho rho' : relflag, {rho = rho'} + {rho <> rho'}.

Lemma beta_dec : forall a1 a2, lc_tm a1 -> {Beta a1 a2} + {¬ Beta a1 a2}.

Unset Implicit Arguments.

Program Fixpoint RhoCheck_erase_dec rho x a (_ : lc_tm a) : {RhoCheck rho x (erase_tm a)} + {¬ RhoCheck rho x (erase_tm a)} :=
  let a' := erase a in
  match rho with
    | Rel => yeah
    | Irrel =>  not_in_dec x (fv_tm_tm_tm a') >--> yeah
  end.

End fc_dec_aux. *)



Require Import FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)



Require Import FcEtt.ett_ind.
(* FcEtt.ett_ind:
Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Export FcEtt.fset_facts.
Require Export FcEtt.ett_inf.
Require Export FcEtt.tactics.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma tm_subst_tm_tm_var : forall a x, tm_subst_tm_tm a x (a_Var_f x) = a.

Lemma co_subst_co_co_var : forall a x, co_subst_co_co a x (g_Var_f x) = a.

Lemma tm_subst_tm_tm_var_neq : forall a x y, x <> y ->
    tm_subst_tm_tm a y (a_Var_f x) = (a_Var_f x).

Lemma co_subst_co_co_var_neq : forall a x y, x <> y ->
    co_subst_co_co a y (g_Var_f x) = (g_Var_f x).

Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm_var : subst_open_var.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co_var : open_subst_var.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co_var : open_subst_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_tm : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm : subst_open.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm : open_subst.

Ltac apply_lc_exists x :=
  pick fresh x;
  ( apply lc_a_Abs_exists      with (x1 := x)
  || apply lc_a_Pi_exists       with (x1 := x)
  || apply lc_a_CPi_exists      with (c1 := x)
  || apply lc_a_CAbs_exists     with (c1 := x)
  || apply lc_a_UAbs_exists     with (x1:= x)
  || apply lc_a_UCAbs_exists    with (c1 := x)
  || apply lc_g_PiCong_exists   with (x1 := x)
  || apply lc_g_AbsCong_exists  with (x1 := x)
  || apply lc_g_CPiCong_exists  with (c1 := x)
  || apply lc_g_CAbsCong_exists with (c1 := x)
  || fail "invalid case for apply_lc_exists" );
  eauto 2.

Ltac lc_solve_binds :=
  match goal with
  
  | [ H : binds ?x ?s nil |- _ ] => inversion H; clear H
  
  | [ H : binds _ ?s ([(_,_)] ++ _) |- _ ?s] =>
      destruct (binds_cons_1 _ _ _ _ _ _ H); basic_solve
  
  | [ b : binds ?x _ ?G, H : ∀ (x' : atom) _, binds x' _ ?G → _ |- _] =>
      by apply H in b; inversion b; try done;
          match goal with
            | [H' : lc_constraint _ |- _] => inversion H' ; clear H'
            | [H' : lc_tm         _ |- _] => inversion H' ; clear H'
          end
  end.

Ltac lc_inversion c :=
  repeat match goal with
    
  | [ H : forall x, (x `in` ?L -> False) -> lc_tm _ /\ _ |- _ ] =>
    destruct (H c ltac:(auto)); split_hyp; clear H
  
  | [ H : lc_constraint (_ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Abs _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_App _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Pi _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Conv _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CPi _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UCAbs _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CApp _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Case _ _) |- _ ] =>
    inversion H; clear H
 end.

Ltac apply_lc_body :=
  match goal with
  | |- lc_tm (open_tm_wrt_tm ?a ?b) => eapply lc_body_tm_wrt_tm; auto
  | |- lc_tm (open_tm_wrt_co ?a ?b) => eapply lc_body_tm_wrt_co; auto
  end.

Lemma co_subst_co_tm_lc_tm_inverse
  : ∀ (g1 : co) (c1 : covar),
      lc_co g1 ->
      (forall A,
          lc_tm A -> forall XX, A = (co_subst_co_tm g1 c1 XX) -> lc_tm XX)
      /\
      (forall b1,
          lc_brs b1 -> forall XX, b1 = (co_subst_co_brs g1 c1 XX) -> lc_brs XX)
      /\
      (forall co,
          lc_co co -> forall XX, co = (co_subst_co_co g1 c1 XX) -> lc_co XX)
      /\
      (forall phi,
          lc_constraint phi -> forall XX, phi = (co_subst_co_constraint g1 c1 XX) ->
          lc_constraint XX).

Ltac invert_syntactic_equality :=
  repeat match goal with
  | [ H : a_Var_f _  = a_Var_f _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Abs _ _ = a_Abs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UAbs _ _ = a_UAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Pi _ _ _ = a_Pi _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_App _ _ _ = a_App _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Fam _  = a_Fam _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Const _  = a_Const _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Conv _ _ = a_Conv _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UCAbs _ = a_UCAbs _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CAbs + _ = a_CAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CApp _ _  = a_CApp _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CPi _ _ = a_CPi _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : Eq _ _ _ = Eq _ _ _ |- _ ] =>
    inversion H; subst; clear H
  end.

Ltac ann_invert_clear :=
  match goal with
  | H : AnnTyping _ a_Star _ |- _ => inversion H; subst; clear H
  | H : AnnTyping _ (_ _) _ |- _ =>  inversion H; subst; clear H
  | H : AnnPropWff _ _ |- _ => inversion H; subst; clear H
  | H : AnnIso _ _ (_ _) _ _ |- _ => inversion H; subst; clear H
  | H : AnnDefEq _ _ (_ _) _ _  |- _ => inversion H; subst; clear H
  | H : AnnCtx ([(_,_)] ++ _) |- _ => inversion H; subst; clear H
  | H : AnnCtx (_ :: _) |- _ => inversion H; subst; clear H
  end.

Lemma lc_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x0)).

Lemma fv_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    x0 `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0)).

Scheme typing_ind' := Induction for Typing Sort Prop
   with wff_ind'   := Induction for PropWff Sort Prop
   with iso_ind'   := Induction for Iso Sort Prop
   with defeq_ind' := Induction for DefEq Sort Prop
   with ctx_ind'   := Induction for Ctx Sort Prop.

Combined Scheme typing_wff_iso_defeq_mutual from typing_ind', wff_ind', iso_ind', defeq_ind', ctx_ind'.

Scheme ann_typing_ind' := Induction for AnnTyping Sort Prop
   with ann_wff_ind'   := Induction for AnnPropWff Sort Prop
   with ann_iso_ind'   := Induction for AnnIso Sort Prop
   with ann_defeq_ind' := Induction for AnnDefEq Sort Prop
   with ann_ctx_ind'   := Induction for AnnCtx Sort Prop.

Combined Scheme ann_typing_wff_iso_defeq_mutual
from ann_typing_ind', ann_wff_ind', ann_iso_ind',
     ann_defeq_ind', ann_ctx_ind'.

Scheme CoercedValue_ind' := Induction for CoercedValue Sort Prop
                            with Value_ind' := Induction for Value Sort Prop.
Combined Scheme CoercedValue_Value_mutual from CoercedValue_ind', Value_ind'.

Ltac ext_induction CON :=
    apply typing_wff_iso_defeq_mutual;
    [ pose CON :=  E_Star       |
      pose CON :=  E_Var        |
      pose CON :=  E_Pi         |
      pose CON :=  E_Abs        |
      pose CON :=  E_App        |
      pose CON :=  E_IApp       |
      pose CON :=  E_Conv       |
      pose CON :=  E_CPi        |
      pose CON :=  E_CAbs       |
      pose CON :=  E_CApp       |
      pose CON :=  E_Const      |
      pose CON :=  E_Fam        |
      pose CON :=  E_Wff        |
      pose CON :=  E_PropCong   |
      pose CON :=  E_IsoConv    |
      pose CON :=  E_CPiFst     |
      pose CON :=  E_Assn       |
      pose CON :=  E_Refl       |
      pose CON :=  E_Sym        |
      pose CON :=  E_Trans      |
      pose CON :=  E_Beta       |
      pose CON :=  E_PiCong     |
      pose CON :=  E_AbsCong    |
      pose CON :=  E_AppCong    |
      pose CON :=  E_IAppCong   |
      pose CON :=  E_PiFst      |
      pose CON :=  E_PiSnd      |
      pose CON :=  E_CPiCong    |
      pose CON :=  E_CAbsCong   |
      pose CON :=  E_CAppCong   |
      pose CON :=  E_CPiSnd     |
      pose CON :=  E_Cast       |
      pose CON :=  E_EqConv     |
      pose CON :=  E_IsoSnd     |
      pose CON :=  E_EtaRel     |
      pose CON :=  E_EtaIrrel   |
      pose CON :=  E_EtaC       |

      pose CON :=  E_Empty      |
      pose CON :=  E_ConsTm     |
      pose CON :=  E_ConsCo     ].

Ltac ann_induction CON :=
    apply ann_typing_wff_iso_defeq_mutual;
    [ pose CON :=  An_Star       |
      pose CON :=  An_Var        |
      pose CON :=  An_Pi         |
      pose CON :=  An_Abs        |
      pose CON :=  An_App        |
      pose CON :=  An_Conv       |
      pose CON :=  An_CPi        |
      pose CON :=  An_CAbs       |
      pose CON :=  An_CApp       |
      pose CON :=  An_Const      |
      pose CON :=  An_Fam        |
      pose CON :=  An_Wff        |
      pose CON :=  An_PropCong   |
      pose CON :=  An_CPiFst     |
      pose CON :=  An_IsoSym     |
      pose CON :=  An_IsoConv    |
      pose CON :=  An_Assn       |
      pose CON :=  An_Refl       |
      pose CON :=  An_EraseEq      |
      pose CON :=  An_Sym        |
      pose CON :=  An_Trans      |
      pose CON :=  An_Beta       |
      pose CON :=  An_PiCong     |
      pose CON :=  An_AbsCong    |
      pose CON :=  An_AppCong    |
      pose CON :=  An_PiFst      |
      pose CON :=  An_PiSnd      |
      pose CON :=  An_CPiCong    |
      pose CON :=  An_CAbsCong   |
      pose CON :=  An_CAppCong   |
      pose CON :=  An_CPiSnd     |
      pose CON :=  An_Cast       |
      pose CON :=  An_IsoSnd     |
      pose CON :=  An_Eta        |
      pose CON :=  An_EtaC       |

      pose CON :=  An_Empty      |
      pose CON :=  An_ConsTm     |
      pose CON :=  An_ConsCo     ].

Ltac ensure_case C :=
  match goal with [ CON := C : ?A |- _ ] => idtac end.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let C1 := gather_atoms_with (fun x : context => dom x) in
  let D1 := gather_atoms_with (fun x => fv_tm_tm_tm x) in
  let D2 := gather_atoms_with (fun x => fv_tm_tm_co x) in
  let D3 := gather_atoms_with (fun x => fv_tm_tm_constraint x) in
  let D4 := gather_atoms_with (fun x => fv_tm_tm_sort x) in
  let D5 := gather_atoms_with (fun x => fv_tm_tm_brs x) in
  let D6 := gather_atoms_with (fun x => fv_co_co_tm x) in
  let D7 := gather_atoms_with (fun x => fv_co_co_co x) in
  let D8 := gather_atoms_with (fun x => fv_co_co_constraint x) in
  let D9 := gather_atoms_with (fun x => fv_co_co_sort x) in
  let D10 := gather_atoms_with (fun x => fv_co_co_brs x) in
  constr:(A \u B \u C1 \u D1 \u D2 \u D3 \u D4 \u D5 \u D6 \u D7 \u D8 \u D9 \u D10).

Ltac rewrite_body :=
  match goal with
  | [ e : ∀ x : atom, (x `in` ?L → False)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
     rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ c : atom, (c `notin` ?L)
      → open_tm_wrt_co _ (g_Var_f c) =
        open_tm_wrt_co _ (g_Cast (g_Var_f c) (g_Sym _)) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `in` ?L → False) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `notin` ?L) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto

  end.

Ltac lc_solve :=
  let c := fresh in
  try lc_solve_binds;
  try apply_lc_exists c;
  lc_inversion c; auto;
  try rewrite_body;
  try apply_lc_body;
  eauto with lc.

Hint Resolve lc_a_Pi_exists
     lc_a_CPi_exists lc_a_Abs_exists lc_a_CAbs_exists lc_a_UAbs_exists.

Hint Resolve lc_body_tm_wrt_tm lc_body_tm_wrt_co. 

Lemma rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)) ->
    RhoCheck rho x0 (open_tm_wrt_tm a (a_Var_f x0)).

Lemma eta_swap: forall x y a' b rho,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b rho (a_Var_f x) ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b rho (a_Var_f y).

Lemma eta_swap_irrel: forall x y a' b,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b Irrel a_Bullet ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b Irrel a_Bullet.

Lemma eta_swap_c: forall x y a' b,
    x `notin` fv_co_co_tm a' \u fv_co_co_tm b ->
    open_tm_wrt_co a' (g_Var_f x) = a_CApp b g_Triv ->
    open_tm_wrt_co a' (g_Var_f y) = a_CApp b g_Triv.

Ltac auto_rew_env :=
  multimatch goal with
    | [ |- context [([(?x, ?T)] ++ ?G1 ++ ?G2 ++ ?G3)] ] => rewrite_env (((x ~ (T)) ++ G1) ++ G2 ++ G3)
  end.

Ltac E_pick_fresh x :=
  match goal with
    | [ |- Typing _ ?shape _ ] =>
      let v := match shape with
            | a_Pi _ _ _ => E_Pi
            | a_UAbs _ _ => E_Abs
            | a_CPi _ _  => E_CPi
            | a_CAbs _ _ => E_CAbs
            | a_UCAbs _  => E_CAbs
           end
      in pick fresh x and apply v
    | [ |- DefEq _ _ ?shape ?s2 _ ] =>
      let v := match shape with
               | a_Pi _ _ _ => E_PiCong
               | a_UAbs Rel _ => match s2 with
                                | a_UAbs _ _ => E_AbsCong
                                | _ => E_EtaRel
                                end
               | a_UAbs Irrel _ => match s2 with 
                                | a_UAbs _ _ =>  E_AbsCong
                                | _ => E_EtaIrrel
                                end
               | a_CPi _ _  => E_CPiCong
               | a_CAbs _ _ => E_CAbsCong
               | a_UCAbs _  => match s2 with 
                                | a_UCAbs _ =>  E_CAbsCong
                                | _ => E_EtaC
                                end
               end
      in pick fresh x and apply v
  end.

Ltac Par_pick_fresh x :=
  match goal with
    | [ |- Par _ _ ?shape ?s2 ] =>
      let v := match shape with
            | a_Pi _ _ _ => Par_Pi
            | a_UAbs Rel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_Eta
                                end
            | a_UAbs Irrel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_EtaIrrel
                                end
            | a_UAbs _ _ =>  Par_Abs
            | a_CPi _ _  => Par_CPi
            | a_CAbs _ _ => Par_CAbs
            | a_UCAbs _  => match s2 with
                                | a_UCAbs _ => Par_CAbs
                                | _ => Par_EtaC
                                end
           end
      in pick fresh x and apply v
  end.

Ltac An_pick_fresh x :=
  let shape := match goal with
                 | [ |- AnnTyping _   ?shape _    ] => shape
                 | [ |- AnnDefEq  _ _ ?shape _  _ ] => shape
               end in
  let ctor  := match shape with
    | a_Pi     _ _ _ => An_Pi
    | a_Abs    _ _ _ => An_Abs
    | a_CPi      _ _ => An_CPi
    | a_CAbs     _ _ => An_CAbs
    | g_PiCong _ _ _ => An_PiCong
    | g_AbsCong _ _ _  => An_AbsCong
    | g_CPiCong  _ _   => An_CPiCong
    | g_CAbsCong _ _ _ => An_CAbsCong
    | g_Eta _          => An_Eta
               end in
  pick fresh x and apply ctor.

Ltac RhoCheck_inversion y :=
  match goal with
  | [ K : ∀ x : atom, x `notin` ?L → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  | [ K : ∀ x : atom, (x `in` ?L -> False) → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  end.

Lemma lc_open_switch_co :
  forall g t, lc_co g ->
  lc_tm (open_tm_wrt_co t g_Triv) ->
  lc_tm (open_tm_wrt_co t g).

Hint Resolve lc_open_switch_co.

Lemma tm_subst_cast : forall a x g,
    tm_subst_tm_tm a x (a_Conv (a_Var_f x) g) = a_Conv a (tm_subst_tm_co a x g).

Hint Rewrite tm_subst_cast. *)

Require Export FcEtt.fc_invert.



Require Import Coq.Init.Specif.

Require Import Coq.micromega.Lia.



Module fc_dec (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).



Module invert := fc_invert wf weak subst.

Module fuel := fc_dec_fuel wf weak subst unique.

Module tc_fun := fc_dec_fun wf weak subst unique.

Module aux := fc_dec_aux wf weak subst unique.



Import tc_fun fuel aux unique wf subst invert.



Definition fuel_at n : Type :=

    (∀ a, size_tm a <= n ->  fuel_tpg a) *

    (∀ phi, size_constraint phi <= n -> fuel_pwf phi) *

    (∀ gamma, size_co gamma <= n -> fuel_iso gamma) *

    (∀ gamma, size_co gamma <= n -> fuel_deq gamma).



Ltac wfind :=

  match goal with

    | [ Hind: ∀ z : nat, z < ?x → fuel_at z |- fuel_tpg ?a ] => eapply (Hind (size_tm a))

    | [ Hind: ∀ z : nat, z < ?x → fuel_at z |- fuel_deq ?g ] => eapply (Hind (size_co g))

    | [ Hind: ∀ z : nat, z < ?x → fuel_at z |- fuel_iso ?g ] => eapply (Hind (size_co g))

    | [ Hind: ∀ z : nat, z < ?x → fuel_at z |- fuel_pwf ?g ] => eapply (Hind (size_constraint g))

  end.



Lemma fuel_all : ∀ n, fuel_at n.

Proof.

  intro n. eapply (well_founded_induction_type lt_wf). clear n. intros.

  repeat split.

  + intros a sz.

    destruct a; auto; unfold size_tm in sz; fold size_tm in sz; fold size_co in sz; fold size_constraint in sz.



    all: try econstructor; intros.

    all: try wfind.

    all: try rewrite size_tm_open_tm_wrt_tm_var; try rewrite size_tm_open_tm_wrt_co_var.

    all: try lia.



  + intros phi sz.

    destruct phi; auto; unfold size_constraint in sz; fold size_tm in sz; fold size_co in sz; fold size_constraint in sz.

    econstructor; intros.

    all: wfind.

    all: try lia.



  + intros g sz.

    destruct g; auto; unfold size_co in sz; unfold size_tm in sz; fold size_tm in sz; fold size_co in sz; fold size_constraint in sz.



    all: try econstructor; intros.

    all: try wfind.

    all: try rewrite size_tm_open_tm_wrt_tm_var; try rewrite size_tm_open_tm_wrt_co_var.

    all: try lia.



  + intros g sz.

    destruct g; auto; unfold size_co in sz; unfold size_tm in sz; fold size_tm in sz; fold size_co in sz; fold size_constraint in sz.

    all: econstructor; intros.

    all: try wfind.

    all: try

      solve [ lia

            | rewrite size_co_open_co_wrt_co_var; lia

            | rewrite size_tm_open_tm_wrt_co_var; lia

            | rewrite size_co_open_co_wrt_tm_var; lia

            | rewrite size_tm_open_tm_wrt_tm_var; lia].

Qed.



Definition gaspump : ∀ t : tm, fuel_tpg t.

Proof.

  move => t.

  move: (fuel_all (size_tm t)) => f.

  do 3 move: f => [f _].

  apply f.

  done.

Qed.



Definition FC_typechecker : ∀ t : tm, {T : tm | AnnTyping nil t T } + {(forall T, ¬ AnnTyping nil t T)} :=

  fun t => AnnTyping_dec nil t (gaspump t) An_Empty.



Theorem FC_typechecking_decidable : ∀ t : tm, (exists T : tm, AnnTyping nil t T) \/ (∀ T, ¬ AnnTyping nil t T).

Proof.

  intros t.

  case: (FC_typechecker t).

  - intros [T p]. left. exists T. exact p.

  - intros n. right. intros T. apply n.

Qed.



End fc_dec.

