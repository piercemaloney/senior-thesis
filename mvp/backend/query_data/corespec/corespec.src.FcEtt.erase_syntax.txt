Require Export FcEtt.ett_inf_cs.
(* FcEtt.ett_inf_cs:
Require Import FcEtt.ett_inf.
Require Import FcEtt.imports.

Module Operators.

  Module Close.

    Record class1 (ssort : Type) (vartype : Type) :=  Class1 {close_ : vartype -> ssort -> ssort; close_rec_ : nat -> vartype -> ssort -> ssort}.

    Record class (ssort : Type) := Class {class_tm : class1 ssort tmvar; class_co : class1 ssort covar}.

    Arguments Class {ssort} class_tm class_co.
    Arguments Class1 {ssort vartype} close_ close_rec_.

  End Close.

  Module Open.

  End Open.

  Module Erase.

    Record class (ssort : Type) := Class {erase_ssort : ssort -> ssort}.

    Arguments Class {ssort} erase_ssort.

  End Erase.

  Module FV.

    Record class (ssort : Type) := Class {fv_tm : ssort -> atoms; fv_co : ssort -> atoms}.

    Arguments Class {ssort} fv_tm fv_co.

  End FV.

  Structure type := Pack {stxsort : Type; class_close : Close.class stxsort; class_Erase : Erase.class stxsort; class_Fv : FV.class stxsort}.

  Definition close_tm' (e : type) : tmvar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class (Close.Class1 c _) _) _ _ := e return tmvar -> stxsort e -> stxsort e in c.

  Definition close_tm_rec' (e : type) : nat -> tmvar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class (Close.Class1 _ c) _) _ _ := e return nat -> tmvar -> stxsort e -> stxsort e in c.

  Definition close_co' (e : type) : covar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class _ (Close.Class1 c _)) _ _ := e return covar -> stxsort e -> stxsort e in c.

  Definition close_co_rec' (e : type) : nat -> covar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class _ (Close.Class1 _ c)) _ _ := e return nat -> covar -> stxsort e -> stxsort e in c.

  Definition erase' (e : type) : stxsort e -> stxsort e :=
    let 'Pack _ _ (Erase.Class c) _ := e in c.

  Definition fv_tm' (e : type) : stxsort e -> atoms :=
    let 'Pack _ _ _ (FV.Class c _) := e in c.

  Definition fv_co' (e : type) : stxsort e -> atoms :=
    let 'Pack _ _ _ (FV.Class _ c) := e in c.

  Arguments close_tm' {e} s v : simpl nomatch.
  Arguments close_tm_rec' {e} k s v : simpl nomatch.
  Arguments close_co' {e} s v : simpl nomatch.
  Arguments close_co_rec' {e} k s v : simpl nomatch.
  Arguments erase' {e} s : simpl nomatch.
  Arguments fv_tm' {e} s : simpl nomatch.
  Arguments fv_co' {e} s : simpl nomatch.

  Module Theory.

    Notation close_tm := close_tm'.
    Notation close_tm_rec := close_tm_rec'.
    Notation close_co := close_co'.
    Notation close_co_rec := close_co_rec'.

    Notation erase := erase'.

    Notation fv_tm := fv_tm'.
    Notation fv_co := fv_co'.

  End Theory.

End Operators.

Export Operators.Theory.

Definition tm_Closecl         : Operators.Close.class tm         := Operators.Close.Class (Operators.Close.Class1 close_tm_wrt_tm close_tm_wrt_tm_rec)                 (Operators.Close.Class1 close_tm_wrt_co close_tm_wrt_co_rec).
Definition co_Closecl         : Operators.Close.class co         := Operators.Close.Class (Operators.Close.Class1 close_co_wrt_tm close_co_wrt_tm_rec)                 (Operators.Close.Class1 close_co_wrt_co close_co_wrt_co_rec).
Definition brs_Closecl        : Operators.Close.class brs        := Operators.Close.Class (Operators.Close.Class1 close_brs_wrt_tm close_brs_wrt_tm_rec)               (Operators.Close.Class1 close_brs_wrt_co close_brs_wrt_co_rec).
Definition constraint_Closecl : Operators.Close.class constraint := Operators.Close.Class (Operators.Close.Class1 close_constraint_wrt_tm close_constraint_wrt_tm_rec) (Operators.Close.Class1 close_constraint_wrt_co close_constraint_wrt_co_rec).

Definition erase_co (_ : co) := g_Triv.

Definition tm_Erasecl         : Operators.Erase.class tm         := Operators.Erase.Class erase_tm.
Definition co_Erasecl         : Operators.Erase.class co         := Operators.Erase.Class erase_co.
Definition brs_Erasecl        : Operators.Erase.class brs        := Operators.Erase.Class erase_brs.
Definition constraint_Erasecl : Operators.Erase.class constraint := Operators.Erase.Class erase_constraint.

Definition tm_FVcl         : Operators.FV.class tm         := Operators.FV.Class fv_tm_tm_tm         fv_co_co_tm.
Definition co_FVcl         : Operators.FV.class co         := Operators.FV.Class fv_tm_tm_co         fv_co_co_co.
Definition brs_FVcl        : Operators.FV.class brs        := Operators.FV.Class fv_tm_tm_brs        fv_co_co_brs.
Definition constraint_FVcl : Operators.FV.class constraint := Operators.FV.Class fv_tm_tm_constraint fv_co_co_constraint.

Canonical Structure tm_OpsTy         : Operators.type := Operators.Pack tm_Closecl         tm_Erasecl         tm_FVcl.
Canonical Structure co_OpsTy         : Operators.type := Operators.Pack co_Closecl         co_Erasecl         co_FVcl.
Canonical Structure brs_OpsTy        : Operators.type := Operators.Pack brs_Closecl        brs_Erasecl        brs_FVcl.
Canonical Structure constraint_OpsTy : Operators.type := Operators.Pack constraint_Closecl constraint_Erasecl constraint_FVcl.

Module Test.

End Test.

Module Rew.
  Definition r_erase_tm         : forall x, erase_tm x = erase x         := fun _ => eq_refl.
  Definition r_erase_co         : forall x, erase_co x = erase x         := fun _ => eq_refl.
  Definition r_erase_brs        : forall x, erase_brs x = erase x        := fun _ => eq_refl.
  Definition r_erase_constraint : forall x, erase_constraint x = erase x := fun _ => eq_refl.

  Definition r_close_tm_tm         : forall x t, close_tm_wrt_tm x t = close_tm x t         := fun _ _ => eq_refl.
  Definition r_close_tm_co         : forall x t, close_co_wrt_tm x t = close_tm x t         := fun _ _ => eq_refl.
  Definition r_close_tm_brs        : forall x t, close_brs_wrt_tm x t = close_tm x t        := fun _ _ => eq_refl.
  Definition r_close_tm_constraint : forall x t, close_constraint_wrt_tm x t = close_tm x t := fun _ _ => eq_refl.

  Definition r_close_co_tm         : forall x t, close_tm_wrt_co x t = close_co x t         := fun _ _ => eq_refl.
  Definition r_close_co_co         : forall x t, close_co_wrt_co x t = close_co x t         := fun _ _ => eq_refl.
  Definition r_close_co_brs        : forall x t, close_brs_wrt_co x t = close_co x t        := fun _ _ => eq_refl.
  Definition r_close_co_constraint : forall x t, close_constraint_wrt_co x t = close_co x t := fun _ _ => eq_refl.

  Module Exprt.
    Hint Rewrite -> r_erase_tm r_erase_co r_erase_brs r_erase_constraint : rewdb_cs.

    Ltac autorewcs :=
      rewrite ? r_erase_tm;
      rewrite ? r_erase_co;
      rewrite ? r_erase_brs;
      rewrite ? r_erase_constraint;

      rewrite ? r_close_tm_tm;
      rewrite ? r_close_tm_co;
      rewrite ? r_close_tm_brs;
      rewrite ? r_close_tm_constraint;

      rewrite ? r_close_co_tm;
      rewrite ? r_close_co_co;
      rewrite ? r_close_co_brs;
      rewrite ? r_close_co_constraint.

    Ltac autorewcshyp H :=
      rewrite ? r_erase_tm in H;
      rewrite ? r_erase_co in H;
      rewrite ? r_erase_brs in H;
      rewrite ? r_erase_constraint in H;

      rewrite ? r_close_tm_tm in H;
      rewrite ? r_close_tm_co in H;
      rewrite ? r_close_tm_brs in H;
      rewrite ? r_close_tm_constraint in H;

      rewrite ? r_close_co_tm in H;
      rewrite ? r_close_co_co in H;
      rewrite ? r_close_co_brs in H;
      rewrite ? r_close_co_constraint in H.
  End Exprt.
End Rew.

Export Rew.Exprt. *)
Require Export FcEtt.ett_ind.
(* FcEtt.ett_ind:
Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Export FcEtt.fset_facts.
Require Export FcEtt.ett_inf.
Require Export FcEtt.tactics.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma tm_subst_tm_tm_var : forall a x, tm_subst_tm_tm a x (a_Var_f x) = a.

Lemma co_subst_co_co_var : forall a x, co_subst_co_co a x (g_Var_f x) = a.

Lemma tm_subst_tm_tm_var_neq : forall a x y, x <> y ->
    tm_subst_tm_tm a y (a_Var_f x) = (a_Var_f x).

Lemma co_subst_co_co_var_neq : forall a x y, x <> y ->
    co_subst_co_co a y (g_Var_f x) = (g_Var_f x).

Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm_var : subst_open_var.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co_var : open_subst_var.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co_var : open_subst_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_tm : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm : subst_open.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm : open_subst.

Ltac apply_lc_exists x :=
  pick fresh x;
  ( apply lc_a_Abs_exists      with (x1 := x)
  || apply lc_a_Pi_exists       with (x1 := x)
  || apply lc_a_CPi_exists      with (c1 := x)
  || apply lc_a_CAbs_exists     with (c1 := x)
  || apply lc_a_UAbs_exists     with (x1:= x)
  || apply lc_a_UCAbs_exists    with (c1 := x)
  || apply lc_g_PiCong_exists   with (x1 := x)
  || apply lc_g_AbsCong_exists  with (x1 := x)
  || apply lc_g_CPiCong_exists  with (c1 := x)
  || apply lc_g_CAbsCong_exists with (c1 := x)
  || fail "invalid case for apply_lc_exists" );
  eauto 2.

Ltac lc_solve_binds :=
  match goal with
  
  | [ H : binds ?x ?s nil |- _ ] => inversion H; clear H
  
  | [ H : binds _ ?s ([(_,_)] ++ _) |- _ ?s] =>
      destruct (binds_cons_1 _ _ _ _ _ _ H); basic_solve
  
  | [ b : binds ?x _ ?G, H : ∀ (x' : atom) _, binds x' _ ?G → _ |- _] =>
      by apply H in b; inversion b; try done;
          match goal with
            | [H' : lc_constraint _ |- _] => inversion H' ; clear H'
            | [H' : lc_tm         _ |- _] => inversion H' ; clear H'
          end
  end.

Ltac lc_inversion c :=
  repeat match goal with
    
  | [ H : forall x, (x `in` ?L -> False) -> lc_tm _ /\ _ |- _ ] =>
    destruct (H c ltac:(auto)); split_hyp; clear H
  
  | [ H : lc_constraint (_ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Abs _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_App _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Pi _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Conv _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CPi _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UCAbs _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CApp _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Case _ _) |- _ ] =>
    inversion H; clear H
 end.

Ltac apply_lc_body :=
  match goal with
  | |- lc_tm (open_tm_wrt_tm ?a ?b) => eapply lc_body_tm_wrt_tm; auto
  | |- lc_tm (open_tm_wrt_co ?a ?b) => eapply lc_body_tm_wrt_co; auto
  end.

Lemma co_subst_co_tm_lc_tm_inverse
  : ∀ (g1 : co) (c1 : covar),
      lc_co g1 ->
      (forall A,
          lc_tm A -> forall XX, A = (co_subst_co_tm g1 c1 XX) -> lc_tm XX)
      /\
      (forall b1,
          lc_brs b1 -> forall XX, b1 = (co_subst_co_brs g1 c1 XX) -> lc_brs XX)
      /\
      (forall co,
          lc_co co -> forall XX, co = (co_subst_co_co g1 c1 XX) -> lc_co XX)
      /\
      (forall phi,
          lc_constraint phi -> forall XX, phi = (co_subst_co_constraint g1 c1 XX) ->
          lc_constraint XX).

Ltac invert_syntactic_equality :=
  repeat match goal with
  | [ H : a_Var_f _  = a_Var_f _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Abs _ _ = a_Abs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UAbs _ _ = a_UAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Pi _ _ _ = a_Pi _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_App _ _ _ = a_App _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Fam _  = a_Fam _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Const _  = a_Const _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Conv _ _ = a_Conv _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UCAbs _ = a_UCAbs _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CAbs + _ = a_CAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CApp _ _  = a_CApp _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CPi _ _ = a_CPi _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : Eq _ _ _ = Eq _ _ _ |- _ ] =>
    inversion H; subst; clear H
  end.

Ltac ann_invert_clear :=
  match goal with
  | H : AnnTyping _ a_Star _ |- _ => inversion H; subst; clear H
  | H : AnnTyping _ (_ _) _ |- _ =>  inversion H; subst; clear H
  | H : AnnPropWff _ _ |- _ => inversion H; subst; clear H
  | H : AnnIso _ _ (_ _) _ _ |- _ => inversion H; subst; clear H
  | H : AnnDefEq _ _ (_ _) _ _  |- _ => inversion H; subst; clear H
  | H : AnnCtx ([(_,_)] ++ _) |- _ => inversion H; subst; clear H
  | H : AnnCtx (_ :: _) |- _ => inversion H; subst; clear H
  end.

Lemma lc_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x0)).

Lemma fv_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    x0 `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0)).

Scheme typing_ind' := Induction for Typing Sort Prop
   with wff_ind'   := Induction for PropWff Sort Prop
   with iso_ind'   := Induction for Iso Sort Prop
   with defeq_ind' := Induction for DefEq Sort Prop
   with ctx_ind'   := Induction for Ctx Sort Prop.

Combined Scheme typing_wff_iso_defeq_mutual from typing_ind', wff_ind', iso_ind', defeq_ind', ctx_ind'.

Scheme ann_typing_ind' := Induction for AnnTyping Sort Prop
   with ann_wff_ind'   := Induction for AnnPropWff Sort Prop
   with ann_iso_ind'   := Induction for AnnIso Sort Prop
   with ann_defeq_ind' := Induction for AnnDefEq Sort Prop
   with ann_ctx_ind'   := Induction for AnnCtx Sort Prop.

Combined Scheme ann_typing_wff_iso_defeq_mutual
from ann_typing_ind', ann_wff_ind', ann_iso_ind',
     ann_defeq_ind', ann_ctx_ind'.

Scheme CoercedValue_ind' := Induction for CoercedValue Sort Prop
                            with Value_ind' := Induction for Value Sort Prop.
Combined Scheme CoercedValue_Value_mutual from CoercedValue_ind', Value_ind'.

Ltac ext_induction CON :=
    apply typing_wff_iso_defeq_mutual;
    [ pose CON :=  E_Star       |
      pose CON :=  E_Var        |
      pose CON :=  E_Pi         |
      pose CON :=  E_Abs        |
      pose CON :=  E_App        |
      pose CON :=  E_IApp       |
      pose CON :=  E_Conv       |
      pose CON :=  E_CPi        |
      pose CON :=  E_CAbs       |
      pose CON :=  E_CApp       |
      pose CON :=  E_Const      |
      pose CON :=  E_Fam        |
      pose CON :=  E_Wff        |
      pose CON :=  E_PropCong   |
      pose CON :=  E_IsoConv    |
      pose CON :=  E_CPiFst     |
      pose CON :=  E_Assn       |
      pose CON :=  E_Refl       |
      pose CON :=  E_Sym        |
      pose CON :=  E_Trans      |
      pose CON :=  E_Beta       |
      pose CON :=  E_PiCong     |
      pose CON :=  E_AbsCong    |
      pose CON :=  E_AppCong    |
      pose CON :=  E_IAppCong   |
      pose CON :=  E_PiFst      |
      pose CON :=  E_PiSnd      |
      pose CON :=  E_CPiCong    |
      pose CON :=  E_CAbsCong   |
      pose CON :=  E_CAppCong   |
      pose CON :=  E_CPiSnd     |
      pose CON :=  E_Cast       |
      pose CON :=  E_EqConv     |
      pose CON :=  E_IsoSnd     |
      pose CON :=  E_EtaRel     |
      pose CON :=  E_EtaIrrel   |
      pose CON :=  E_EtaC       |

      pose CON :=  E_Empty      |
      pose CON :=  E_ConsTm     |
      pose CON :=  E_ConsCo     ].

Ltac ann_induction CON :=
    apply ann_typing_wff_iso_defeq_mutual;
    [ pose CON :=  An_Star       |
      pose CON :=  An_Var        |
      pose CON :=  An_Pi         |
      pose CON :=  An_Abs        |
      pose CON :=  An_App        |
      pose CON :=  An_Conv       |
      pose CON :=  An_CPi        |
      pose CON :=  An_CAbs       |
      pose CON :=  An_CApp       |
      pose CON :=  An_Const      |
      pose CON :=  An_Fam        |
      pose CON :=  An_Wff        |
      pose CON :=  An_PropCong   |
      pose CON :=  An_CPiFst     |
      pose CON :=  An_IsoSym     |
      pose CON :=  An_IsoConv    |
      pose CON :=  An_Assn       |
      pose CON :=  An_Refl       |
      pose CON :=  An_EraseEq      |
      pose CON :=  An_Sym        |
      pose CON :=  An_Trans      |
      pose CON :=  An_Beta       |
      pose CON :=  An_PiCong     |
      pose CON :=  An_AbsCong    |
      pose CON :=  An_AppCong    |
      pose CON :=  An_PiFst      |
      pose CON :=  An_PiSnd      |
      pose CON :=  An_CPiCong    |
      pose CON :=  An_CAbsCong   |
      pose CON :=  An_CAppCong   |
      pose CON :=  An_CPiSnd     |
      pose CON :=  An_Cast       |
      pose CON :=  An_IsoSnd     |
      pose CON :=  An_Eta        |
      pose CON :=  An_EtaC       |

      pose CON :=  An_Empty      |
      pose CON :=  An_ConsTm     |
      pose CON :=  An_ConsCo     ].

Ltac ensure_case C :=
  match goal with [ CON := C : ?A |- _ ] => idtac end.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let C1 := gather_atoms_with (fun x : context => dom x) in
  let D1 := gather_atoms_with (fun x => fv_tm_tm_tm x) in
  let D2 := gather_atoms_with (fun x => fv_tm_tm_co x) in
  let D3 := gather_atoms_with (fun x => fv_tm_tm_constraint x) in
  let D4 := gather_atoms_with (fun x => fv_tm_tm_sort x) in
  let D5 := gather_atoms_with (fun x => fv_tm_tm_brs x) in
  let D6 := gather_atoms_with (fun x => fv_co_co_tm x) in
  let D7 := gather_atoms_with (fun x => fv_co_co_co x) in
  let D8 := gather_atoms_with (fun x => fv_co_co_constraint x) in
  let D9 := gather_atoms_with (fun x => fv_co_co_sort x) in
  let D10 := gather_atoms_with (fun x => fv_co_co_brs x) in
  constr:(A \u B \u C1 \u D1 \u D2 \u D3 \u D4 \u D5 \u D6 \u D7 \u D8 \u D9 \u D10).

Ltac rewrite_body :=
  match goal with
  | [ e : ∀ x : atom, (x `in` ?L → False)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
     rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ c : atom, (c `notin` ?L)
      → open_tm_wrt_co _ (g_Var_f c) =
        open_tm_wrt_co _ (g_Cast (g_Var_f c) (g_Sym _)) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `in` ?L → False) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `notin` ?L) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto

  end.

Ltac lc_solve :=
  let c := fresh in
  try lc_solve_binds;
  try apply_lc_exists c;
  lc_inversion c; auto;
  try rewrite_body;
  try apply_lc_body;
  eauto with lc.

Hint Resolve lc_a_Pi_exists
     lc_a_CPi_exists lc_a_Abs_exists lc_a_CAbs_exists lc_a_UAbs_exists.

Hint Resolve lc_body_tm_wrt_tm lc_body_tm_wrt_co. 

Lemma rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)) ->
    RhoCheck rho x0 (open_tm_wrt_tm a (a_Var_f x0)).

Lemma eta_swap: forall x y a' b rho,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b rho (a_Var_f x) ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b rho (a_Var_f y).

Lemma eta_swap_irrel: forall x y a' b,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b Irrel a_Bullet ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b Irrel a_Bullet.

Lemma eta_swap_c: forall x y a' b,
    x `notin` fv_co_co_tm a' \u fv_co_co_tm b ->
    open_tm_wrt_co a' (g_Var_f x) = a_CApp b g_Triv ->
    open_tm_wrt_co a' (g_Var_f y) = a_CApp b g_Triv.

Ltac auto_rew_env :=
  multimatch goal with
    | [ |- context [([(?x, ?T)] ++ ?G1 ++ ?G2 ++ ?G3)] ] => rewrite_env (((x ~ (T)) ++ G1) ++ G2 ++ G3)
  end.

Ltac E_pick_fresh x :=
  match goal with
    | [ |- Typing _ ?shape _ ] =>
      let v := match shape with
            | a_Pi _ _ _ => E_Pi
            | a_UAbs _ _ => E_Abs
            | a_CPi _ _  => E_CPi
            | a_CAbs _ _ => E_CAbs
            | a_UCAbs _  => E_CAbs
           end
      in pick fresh x and apply v
    | [ |- DefEq _ _ ?shape ?s2 _ ] =>
      let v := match shape with
               | a_Pi _ _ _ => E_PiCong
               | a_UAbs Rel _ => match s2 with
                                | a_UAbs _ _ => E_AbsCong
                                | _ => E_EtaRel
                                end
               | a_UAbs Irrel _ => match s2 with 
                                | a_UAbs _ _ =>  E_AbsCong
                                | _ => E_EtaIrrel
                                end
               | a_CPi _ _  => E_CPiCong
               | a_CAbs _ _ => E_CAbsCong
               | a_UCAbs _  => match s2 with 
                                | a_UCAbs _ =>  E_CAbsCong
                                | _ => E_EtaC
                                end
               end
      in pick fresh x and apply v
  end.

Ltac Par_pick_fresh x :=
  match goal with
    | [ |- Par _ _ ?shape ?s2 ] =>
      let v := match shape with
            | a_Pi _ _ _ => Par_Pi
            | a_UAbs Rel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_Eta
                                end
            | a_UAbs Irrel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_EtaIrrel
                                end
            | a_UAbs _ _ =>  Par_Abs
            | a_CPi _ _  => Par_CPi
            | a_CAbs _ _ => Par_CAbs
            | a_UCAbs _  => match s2 with
                                | a_UCAbs _ => Par_CAbs
                                | _ => Par_EtaC
                                end
           end
      in pick fresh x and apply v
  end.

Ltac An_pick_fresh x :=
  let shape := match goal with
                 | [ |- AnnTyping _   ?shape _    ] => shape
                 | [ |- AnnDefEq  _ _ ?shape _  _ ] => shape
               end in
  let ctor  := match shape with
    | a_Pi     _ _ _ => An_Pi
    | a_Abs    _ _ _ => An_Abs
    | a_CPi      _ _ => An_CPi
    | a_CAbs     _ _ => An_CAbs
    | g_PiCong _ _ _ => An_PiCong
    | g_AbsCong _ _ _  => An_AbsCong
    | g_CPiCong  _ _   => An_CPiCong
    | g_CAbsCong _ _ _ => An_CAbsCong
    | g_Eta _          => An_Eta
               end in
  pick fresh x and apply ctor.

Ltac RhoCheck_inversion y :=
  match goal with
  | [ K : ∀ x : atom, x `notin` ?L → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  | [ K : ∀ x : atom, (x `in` ?L -> False) → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  end.

Lemma lc_open_switch_co :
  forall g t, lc_co g ->
  lc_tm (open_tm_wrt_co t g_Triv) ->
  lc_tm (open_tm_wrt_co t g).

Hint Resolve lc_open_switch_co.

Lemma tm_subst_cast : forall a x g,
    tm_subst_tm_tm a x (a_Conv (a_Var_f x) g) = a_Conv a (tm_subst_tm_co a x g).

Hint Rewrite tm_subst_cast. *)

Require Import FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)
Require Import FcEtt.tactics.
(* FcEtt.tactics:
Require Import FcEtt.imports.

Require Import FcEtt.ett_inf.

Inductive Dyn : Type := dyn : forall {T : Type}, T -> Dyn.

Ltac unwrap_dyn d :=
  match d with
    | dyn ?v => v
  end.

Ltac split_hyp :=
  repeat (
      match goal with
        | [ H : _ /\ _ |- _ ] => destruct H
      end).

Ltac rewrite_and_clear eq :=
  first [rewrite -> eq | rewrite <- eq]; clear eq.

Ltac try_rewrite_and_clear eq :=
  first [rewrite -> ! eq | rewrite <- ! eq | idtac]; clear eq.

Ltac try_rewrite_and_clear_f eq :=
  first [rewrite ! eq | idtac]; clear eq.

Ltac find_eq_rew_clear :=
  match goal with
    | [ eq : forall t1,                _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2,             _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3,          _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4,       _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5,    _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5 t6, _ = _ |- _ ] => rewrite_and_clear eq
  end.

Ltac subst_forall :=
  repeat find_eq_rew_clear.

Tactic Notation "basic_nosolve_n"     int_or_var(n) :=
  intuition (subst; eauto n).
Tactic Notation "basic_nosolve_n'"    int_or_var(n) :=
  intuition (subst; simpl in *; subst; eauto n; try done).
Tactic Notation "basic_nosolve_fo_n"  int_or_var(n) :=
  firstorder (subst; eauto n).
Tactic Notation "basic_nosolve_fo_n'" int_or_var(n) :=
  firstorder (subst_forall; simpl in *; subst_forall; eauto n; try done).

Tactic Notation "basic_solve_n"     int_or_var(n) := try solve [basic_nosolve_n     n].
Tactic Notation "basic_solve_n'"    int_or_var(n) := try solve [basic_nosolve_n'    n].
Tactic Notation "basic_solve_fo_n"  int_or_var(n) := try solve [basic_nosolve_fo_n  n].
Tactic Notation "basic_solve_fo_n'" int_or_var(n) := try solve [basic_nosolve_fo_n' n].

Ltac basic_nosolve     := basic_nosolve_n     5.
Ltac basic_nosolve'    := basic_nosolve_n'    5.
Ltac basic_nosolve_fo  := basic_nosolve_fo_n  5.
Ltac basic_nosolve_fo' := basic_nosolve_fo_n' 5.

Ltac basic_solve     := try solve [basic_nosolve].
Ltac basic_solve'    := try solve [basic_nosolve'].
Ltac basic_solve_fo  := try solve [basic_nosolve_fo].
Ltac basic_solve_fo' := try solve [basic_nosolve_fo'].

Ltac solve_by_inv_hyp_about A :=
  multimatch goal with
    | [ H : context [?A] |- _ ] => solve [inversion H; basic_solve]
  end.

Ltac revert_all :=
  repeat match goal with
      | [ H : _ |- _ ] => revert H
    end.

Ltac revert_all_with t :=
  repeat match goal with
      | [ H : _ |- _ ] => try t H; revert dependent H
    end.

Ltac intro_all_with t :=
  repeat
    (let x := fresh in intro x; try (t x)).

Ltac disjunction_assumption :=
  match goal with
    | [H : ?P |- ?P]     => exact H
    | [H : ?P |- ?P ∨ _] => left; exact H
    | [       |- _  ∨ _] => right; disjunction_assumption
  end.

Ltac invert_and_clear H := inversion H; clear H.

Definition wrap : forall P : Prop, P -> P * True := fun _ p => (p, I).
Ltac wrap_hyp H := apply wrap in H.

Lemma AnnCtx_uniq G : AnnCtx G -> uniq G.

Ltac prove_this stmt name :=

  match stmt with
    | uniq ?G =>
      match goal with
      | [ HG : AnnCtx G |- _ ] =>
        
        move: (AnnCtx_uniq HG) => name 
      end
    end.

Ltac find_invertible_hyps :=
  repeat (
  match goal with
    
    | [ H : AnnIso _ _ (g_EqCong _ _ _) _ _ |- _ ] => invert_and_clear H
    
    | [ H : AnnIso _ _ (_ _) _ _ |- _ ] => inversion H; wrap_hyp H

    | [ H : AnnTyping _ (_ _) _ |- _ ] => inversion H; wrap_hyp H

  end).

Ltac pair_coupled_hyps :=
  repeat match goal with
    | [ H1 : binds ?T _ ?G, H2 : binds ?T _ ?G |- _ ] =>
      let unG := fresh "uniq" G in
      prove_this (uniq G) unG;
      move: (binds_unique _ _ _ _ _ H1 H2 unG) => ?; wrap_hyp H2

  end.

Ltac pcess_hyps :=
  find_invertible_hyps;

  pair_coupled_hyps;

  repeat (
    match goal with
      | [ H : _ /\ _       |- _ ] => destruct H

      | [ H : exists x, _  |- _ ] => destruct H

      | [ H : _ * True  |- _      ] => destruct H as [H _]

      | [ H :                   ?A = ?A |- _ ] => clear H
      | [ H : forall _,         ?A = ?A |- _ ] => clear H
      | [ H : forall _ _,       ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _,     ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _,   ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _ _, ?A = ?A |- _ ] => clear H
      
      | [ H : ?P |- _ ] => clear H; let x := fresh in assert (x : P) by solve [assumption | trivial]; clear x

      | [ H : ?C _                         = ?C _                         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _                       = ?C _ _                       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _                     = ?C _ _ _                     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _                   = ?C _ _ _ _                   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _                 = ?C _ _ _ _ _                 |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ |- _ ] => injection H; clear H; intros; try subst

    end).

Ltac pre :=
  repeat (intros; try split);
  
  unfold "~" in *.

Ltac pre' :=
  repeat (intros; try split);
  pcess_hyps;
  unfold "~" in *.

Ltac prove_eq_same_head :=
  solve [subst; reflexivity | f_equal; basic_solve].

Ltac break_union :=
  repeat match goal with
  
    | [ H : ~ ?x `in` union _ _ |- _ ] =>
        move: (notin_union_1 _ _ _ H) (notin_union_2 _ _ _ H) => ??; clear H
  end.

Ltac fsetdec_fast := solve [break_union; basic_solve_n 3].

Ltac autofresh_fixed x :=
   repeat match goal with
     | [ H : ∀ x' : atom, x' `notin` ?L -> _ |- _] =>
       let xL := fresh x L in
       (have xL : x `notin` L by first [fsetdec_fast | fsetdec]);
       specialize (H x xL);
       clear xL 
   end.

 Ltac autofresh :=
   let x := fresh "x" in
   pick fresh x;
   autofresh_fixed x.

Ltac autotype :=
  pcess_hyps;

  repeat match goal with
    | [ |- _ /\ _ ] => split

    | [ |- _ `in` _   ] => try fsetdec_fast; first [fsetdec | fail 2] 
    | [ |- ¬ _ `in` _ ] => try fsetdec_fast; first [fsetdec | fail 2]

    | [ |- _ [=] _  ] => first [fsetdec | fail 2]
    | [ |- _ [<=] _ ] => first [fsetdec | fail 2]

    | [ |- ?C _                         = ?C _                         ] => prove_eq_same_head
    | [ |- ?C _ _                       = ?C _ _                       ] => prove_eq_same_head
    | [ |- ?C _ _ _                     = ?C _ _ _                     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _                   = ?C _ _ _ _                   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _                 = ?C _ _ _ _ _                 ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ ] => prove_eq_same_head

    | _ => try done; basic_solve; fail 0

    | [ |- ex _ ] => eexists

    | [ |- AnnTyping _   (_ _) _   ] => econstructor; pcess_hyps
    | [ |- AnnDefEq  _ _ (_ _) _ _ ] => econstructor; pcess_hyps
    | [ |- AnnIso    _ _ (_ _) _ _ ] => econstructor; pcess_hyps
  end.

Ltac ok := autotype.
Ltac depind x := dependent induction x. *)

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).
Proof.
  move=> a.
  eapply tm_brs_co_constraint_mutind;
  intros; simpl; auto;
  try (rewrite H; try rewrite H0; auto).
  case (lt_eq_lt_dec n k);
    try (move=> []); simpl; auto.
  all: f_equal; eauto 1.
  destruct rho.
  + simpl; auto. autorewcs. rewrite H0.  rewrite H. auto.
  + simpl; auto. rewrite H.  auto.
Qed.

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).
Proof.
  move=> a b.
  case (open_tm_erase_rec b).
  unfold open_tm_wrt_tm.
  eauto.
Qed.

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).
Proof.
  move=> a.
  eapply tm_brs_co_constraint_mutind;
  intros; unfold Operators.erase'; simpl; auto; 
    try (rewrite <- H; try rewrite <- H0; auto).
  all: f_equal; eauto 2.
Qed.

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).
Proof.
  move=> a b.
  destruct (open_co_erase_rec a).
  unfold open_tm_wrt_co.
  eauto.
Qed.

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).
Proof.
  move=> a.
  eapply tm_brs_co_constraint_mutind;
  intros; try (destruct rho); unfold Operators.erase'; simpl; auto;
  f_equal; auto;
    try (autorewcs; rewrite <- H; try rewrite <- H0; auto).
Qed.

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).
Proof.
  move=> a b.
  case (open_co_erase2_rec a).
  unfold open_tm_wrt_co.
  eauto.
Qed.

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.
 Proof.
  intros.
  rewrite (open_co_erase_tm2 g_Triv).
  rewrite <- open_co_erase_tm.
  done.
Qed.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).
Proof.
  move => x; simpl;
  apply tm_brs_co_constraint_mutind;
  basic_nosolve_fo'.
  - case (lt_ge_dec n k); done.
  - move eqe : (x == x0) => [] // .
  - destruct rho; basic_solve_fo'.
Qed.

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).
Proof.
  move => x; simpl;
  apply tm_brs_co_constraint_mutind;
  basic_nosolve_fo';
  solve [case (lt_ge_dec n k); done | move eqe : (x == x0) => [] // | destruct rho; basic_solve_fo'].
Qed.

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).
Proof.
  intros. eapply close_tm_rec_erase_tm.
Qed.

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).
Proof.
  intros. eapply close_co_rec_erase_tm.
Qed.

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).
Proof.
  move => x; simpl;
  apply tm_brs_co_constraint_mutind;
  basic_nosolve_fo';
  solve [case (lt_ge_dec n k); done | move eqe : (x == x0) => [] // | destruct rho; basic_solve_fo'].
Qed.

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.
Proof.
  intros x a.
  eapply (close_co_erase_rec x).
Qed.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).
Proof.
  move=> x.
  
  cut ((∀ a : tm, x `notin` fv_tm a -> x `notin` fv_tm (erase a)) /\
       (∀ a : brs, x `notin` fv_tm a -> x `notin` fv_tm (erase a)) /\
       (∀ a : co, x `notin` fv_tm a -> x `notin` fv_tm (erase a)) /\
       (∀ a : constraint, x `notin` fv_tm a -> x `notin` fv_tm (erase a))).
    by move=> [a _].
    eapply tm_brs_co_constraint_mutind; try (destruct rho); basic_solve_fo'.
Qed.

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).
Proof.
  move=> x.
  
  cut ((∀ a : tm, x `notin` fv_co a -> x `notin` fv_co (erase a)) /\
       (∀ a : brs, x `notin` fv_co a -> x `notin` fv_co (erase a)) /\
       (∀ a : co, x `notin` fv_co a -> x `notin` fv_co (erase a)) /\
       (∀ a : constraint, x `notin` fv_co a -> x `notin` fv_co (erase a))).
    by move=> [a _].
    eapply tm_brs_co_constraint_mutind; try (destruct rho); basic_solve_fo'.
Qed.

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).
Proof.
  move=> a x.
  eapply tm_brs_co_constraint_mutind;
  intros; simpl; auto;
  try (rewrite H; try rewrite H0; auto).
  destruct (x0 == x); simpl; auto.
  all: f_equal; eauto 2.
  destruct rho; simpl; f_equal; eauto 2.
Qed.

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).
Proof.
  intros a x.
  eapply tm_brs_co_constraint_mutind;
  intros;  unfold Operators.erase'; simpl; autorewcs; auto;
    try (rewrite <- H; try rewrite <- H0; auto).
  all: f_equal; eauto 2.
Qed.

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).
Proof.
  intros a x.
  destruct (subst_tm_erase a x).
  eauto.
Qed.

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).
Proof.
  intros a x.
  destruct (subst_co_erase a x).
  eauto.
Qed.

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).
Proof.
  apply tm_brs_co_constraint_mutind  =>
    //
    
    [ 
    | i | y
    | rho ty IHty body IHbody | rho e IH | e1 IH1 rho e2 IH2
    | f | k
    | rho A1 IH1 A2 IH2
    
    | g IHg A IHA | g IHg e IHe | e IH | e IHe g IHg
    | 
    | con | e IH Bs IHBs
    
    | 
    | con e IHe Bs IHBs
    
    | A IHA B IHB ].
  all: match goal with
       | |- constraint → _ =>
         case => [A' B']
       | |- tm         → _ =>
         elim =>  [ 
                 | i' | y'
                 | rho' ty' IHty' body' IHbody' | rho' e' IH' | e1' IH1' rho' e2' IH2'
                 | f' | k'
                 | rho' A1' IH1' A2' IH2'
                 | e' IHe' g'
                 | g' A' IHA' | g' e' IHe' | e' IH' | e' IHe' g'
                 | 
                 | con' | e' IH' Bs'
                 ]
       | |- brs        → _ =>
         case => [ | con' e' Bs' ]
       | |- _ => idtac
       end.
  all: try (try (destruct rho); try (destruct rho'); move=> //= [] *; try subst; f_equal; eauto).
  all: intros.
  all: destruct phi2.
  all: simpl.
  all: simpl in H0.
  all: inversion H0; subst.
  all: try erewrite IHB; eauto.
  all: try erewrite IHA; eauto.
  all: simpl in H.
  all: try erewrite H; eauto.
Qed.

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).
Proof. move: (erase_subst_mutual a x) => ?; split_hyp; auto. Qed.

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).
Proof. move: (erase_subst_mutual a x) => ?; split_hyp; auto. Qed.

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).
Proof. move: (erase_subst_mutual a x) => ?; split_hyp; auto. Qed.

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).
Proof.
  apply tm_brs_co_constraint_mutind =>
    //
    
    [ 
    | i | y
    | rho ty IHty body IHbody | rho e IH | e1 IH1 rho e2 IH2
    | f | k
    | rho A1 IH1 A2 IH2
    
    | g IHg A IHA | g IHg e IHe | e IH | e IHe g IHg
    | 
    | con | e IH Bs IHBs
    
    | 
    | con e IHe Bs IHBs
    
    | A IHA B IHB ].
  all: match goal with
       | |- constraint → _ =>
         case => [A' B']
       | |- tm         → _ =>
         elim => [ 
                 | i' | y'
                 | rho' ty' IHty' body' IHbody' | rho' e' IH' | e1' IH1' rho' e2' IH2'
                 | f' | k'
                 | rho' A1' IH1' A2' IH2'
                 | e' IHe' g'
                 | g' A' IHA' | g' e' IHe' | e' IH' | e' IHe' g'
                 | 
                 | con' | e' IH' Bs'
                 ]
       | |- brs        → _ =>
         case => [ | con' e' Bs' ]
       end.
  all: try solve [try destruct rho; try destruct rho'; move=> //= [] *; try subst; f_equal; eauto].
  all: intros.
  all: try destruct phi2.
  all: simpl.
  all: try simpl in H0.
  all: try inversion H0; subst.
  all: try erewrite IHB; eauto.
  all: try erewrite IHA; eauto.
  all: simpl in H.
  all: try erewrite H; eauto.
Qed.

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).
Proof. move: (erase_co_subst_co_mutual a x) => ?; split_hyp; auto. Qed.

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).
Proof. move: (erase_co_subst_co_mutual a x) => ?; split_hyp; auto. Qed.

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).
Proof. move: (erase_co_subst_co_mutual a x) => ?; split_hyp; auto. Qed.

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).
Proof.
  eapply lc_tm_lc_brs_lc_co_lc_constraint_mutind.
  all: intros.
  all: try solve [try destruct rho; simpl; eauto].
  - apply lc_a_UAbs. auto.
    intro x.
    assert (HV : erase (a_Var_f x) = a_Var_f x). auto.
    rewrite <- HV.
    rewrite open_tm_erase_tm. auto.
  - apply lc_a_UAbs. auto.
    intro x.
    assert (HV : erase (a_Var_f x) = a_Var_f x). auto.
    rewrite <- HV.
    rewrite open_tm_erase_tm. auto.
  - apply lc_a_Pi. auto.
    intro x.
    assert (HV : erase (a_Var_f x) = a_Var_f x). auto.
    rewrite <- HV.
    rewrite open_tm_erase_tm. auto.
  - apply lc_a_CPi. auto.
    intro c.
    rewrite (open_co_erase_tm2 (g_Var_f c)).
    auto.
  - apply lc_a_UCAbs. auto.
    intro c.
    rewrite (open_co_erase_tm2 (g_Var_f c)).
    auto.
  - apply lc_a_UCAbs. auto.
    intro c.
    rewrite (open_co_erase_tm2 (g_Var_f c)).
    auto.
Qed.

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).
intros. eapply lc_erase. auto. Qed.

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).
intros. eapply lc_erase. auto. Qed.

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).
intros. eapply lc_erase. auto. Qed.

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).
Proof.
  intros.
  replace (a_Var_f x) with (erase (a_Var_f x)); auto.
  rewrite open_tm_erase_tm.
  apply lc_erase. auto.
Qed.

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).
Proof.
  intros.
  rewrite (open_co_erase_tm2 (g_Var_f x)).
  eauto with lc.
Qed.

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).
Proof.
  intros.
  rewrite <- open_tm_erase_tm.
  rewrite <- open_tm_erase_tm.
  simpl.
  auto.
Qed.

Lemma erase_dom : forall G, dom G = dom (erase_context G).
Proof.
  induction G. simpl. auto.
  destruct a. simpl. rewrite IHG. eauto.
Qed.

Lemma path_erase : forall T p, Path T p -> Path T (erase p).
Proof.
  intros. induction H; simpl; eauto.
  - destruct rho; simpl; autorewcs; eauto with lc.
Qed.

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).
Proof. apply CoercedValue_Value_mutual; eauto.
  all: intros.
  all: try destruct rho.
  all: try match goal with [H : lc_tm (?a ?b) |- _ ] =>
                           apply lc_tm_erase in H; simpl in * end.
  all: simpl; autorewcs; eauto using path_erase, lc_tm_erase, lc_constraint_erase.

  all: try solve [econstructor; intros x Fr;
  replace (a_Var_f x) with (erase (a_Var_f x)); auto;
  rewrite open_tm_erase_tm; eauto].
Qed.

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).
Proof. eapply CoercedValueValue_erase. Qed.

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).
Proof. eapply CoercedValueValue_erase. Qed.

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).
Proof.
  intros a H2.
  induction H2; simpl in *; lc_inversion c; subst; eauto with lc.
  econstructor; eauto with lc.
  econstructor; eauto with lc.
  destruct rho; simpl; eauto using path_erase, lc_tm_erase.
  eauto using path_erase, lc_tm_erase, Value_erase.
  eauto using path_erase, lc_tm_erase, Value_erase.
  eauto using path_erase, lc_tm_erase, Value_erase.
Qed.

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).
Proof.
  intros rho x x0 a F1 F2 H0.
  inversion H0; subst; constructor.
  + auto. 
  + autorewcs. rewrite -open_tm_erase_tm. simpl.
    autorewcshyp H. rewrite -open_tm_erase_tm in H. simpl in H.
    eapply fv_swap with (x:=x); eauto.
Qed.

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end.
