Set Bullet Behavior "Strict Subproofs".

Set Implicit Arguments.



Require Export FcEtt.tactics.

Require Export FcEtt.imports.

Require Export FcEtt.ett_inf.

Require Export FcEtt.ett_ott.

Require Export FcEtt.ett_ind.



Require Export FcEtt.ext_context_fv.



Require Import FcEtt.ext_wf.
(* FcEtt.ext_wf:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Import FcEtt.imports.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.
Require Import FcEtt.tactics.

Require Import FcEtt.utils.

Require Import FcEtt.sigs.
Require Import FcEtt.toplevel.

Lemma Path_lc : forall T a, Path T a -> lc_tm a.

Hint Resolve Path_lc : lc.

Lemma DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.
Hint Resolve DataTy_lc : lc.

Lemma CoercedValue_Value_lc_mutual: (forall A, CoercedValue A -> lc_tm A) /\
                                    (forall A, Value A -> lc_tm A).

Lemma Value_lc : forall A, Value A -> lc_tm A.
Lemma CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

Hint Resolve Value_lc CoercedValue_lc : lc.

Lemma ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Definition Typing_Ctx  := first  ctx_wff_mutual.
Definition PropWff_Ctx := second ctx_wff_mutual.
Definition Iso_Ctx     := third  ctx_wff_mutual.
Definition DefEq_Ctx   := fourth ctx_wff_mutual.

Hint Resolve Typing_Ctx PropWff_Ctx Iso_Ctx DefEq_Ctx.

Lemma Ctx_uniq : forall G, Ctx G -> uniq G.

Hint Resolve Ctx_uniq.

Lemma lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi, PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T, DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Definition Typing_lc  := first lc_mutual.
Definition PropWff_lc := second lc_mutual.
Definition Iso_lc     := third lc_mutual.
Definition DefEq_lc   := fourth lc_mutual.
Definition Ctx_lc     := fifth lc_mutual.

Lemma Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Lemma Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Lemma Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Lemma Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.
Lemma DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.

Lemma DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Lemma DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Hint Resolve Typing_lc1 Typing_lc2 Iso_lc1 Iso_lc2 DefEq_lc1 DefEq_lc2 DefEq_lc3 Ctx_lc : lc.

Lemma Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s. *)

Import ext_wf.



Require Import FcEtt.fc_wf.
(* FcEtt.fc_wf:
Require Import FcEtt.sigs.

Require Export FcEtt.imports.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.

Require Import FcEtt.tactics.

Require Import FcEtt.toplevel.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma ann_ctx_wff_mutual :
  (forall G0 a A, AnnTyping G0 a A -> AnnCtx G0) /\
  (forall G0 phi,   AnnPropWff G0 phi -> AnnCtx G0) /\
  (forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0) /\
  (forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0) /\
  (forall G0, AnnCtx G0 -> True).

Definition AnnTyping_AnnCtx  := first  ann_ctx_wff_mutual.
Definition AnnPropWff_AnnCtx := second ann_ctx_wff_mutual.
Definition AnnIso_AnnCtx     := third  ann_ctx_wff_mutual.
Definition AnnDefEq_AnnCtx   := fourth ann_ctx_wff_mutual.

Hint Resolve AnnTyping_AnnCtx AnnPropWff_AnnCtx AnnIso_AnnCtx
     AnnDefEq_AnnCtx : ctx_wff.

Ltac sort_inversion :=
  let h0 := fresh in
  match goal with
  | [ H : AnnTyping ([(?x,?s)] ++ ?G) _ _ |- _ ] =>
    have h0: AnnCtx (x ~ s ++ G); eauto with ctx_wff;
    inversion h0; subst; auto
  | [ H : AnnDefEq ([(?x,?s)] ++ ?G) _ _ _ |- _ ] =>
    have h0: AnnCtx (x ~ s ++ G); eauto with ctx_wff;
    inversion h0; subst; auto
  | [ H : AnnIso ([(?x,?s)] ++ ?G) _ _ _ |- _ ] =>
    have h0: AnnCtx (x ~ s ++ G); eauto with ctx_wff;
    inversion h0; subst; auto
  end.

Lemma AnnCtx_uniq G : AnnCtx G -> uniq G.

Hint Resolve AnnCtx_uniq.

Hint Resolve lc_open_switch_co : lc.

Lemma lc_mutual :
  (forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g) /\
  (forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g) /\
  (forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s).

Definition AnnTyping_lc  := first lc_mutual.
Definition AnnPropWff_lc := second lc_mutual.
Definition AnnIso_lc     := third lc_mutual.
Definition AnnDefEq_lc   := fourth lc_mutual.
Definition AnnCtx_lc     := fifth lc_mutual.

Lemma AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Lemma AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.

Lemma AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Lemma AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Lemma AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Lemma AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Lemma AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Lemma AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Hint Resolve AnnTyping_lc1 AnnTyping_lc2 AnnIso_lc1 AnnIso_lc2 AnnIso_lc3 AnnDefEq_lc1 AnnDefEq_lc2 AnnDefEq_lc3 AnnCtx_lc : lc.

Lemma AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s. *)

Import fc_wf.



Require Import FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)

Require Import FcEtt.erase_syntax.
(* FcEtt.erase_syntax:
Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).

Lemma erase_dom : forall G, dom G = dom (erase_context G).

Lemma path_erase : forall T p, Path T p -> Path T (erase p).

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end. *)

Require Export FcEtt.toplevel.

Require Import FcEtt.ett_value.
(* FcEtt.ett_value:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ext_context_fv.

Require Import FcEtt.ext_wf.
Import ext_wf.

Require Import FcEtt.utils.
Require Import FcEtt.erase_syntax.
Require Export FcEtt.toplevel.

Lemma Path_tm_subst_tm_tm : forall T a x b, Path T a -> lc_tm b -> Path T (tm_subst_tm_tm b x a).

Lemma Path_co_subst_co_tm : forall T a x b, Path T a -> lc_co b -> Path T (co_subst_co_tm b x a).

Hint Resolve Path_tm_subst_tm_tm Path_co_subst_co_tm : lngen.

Lemma Path_unique : forall T1 T2 a, Path T1 a -> Path T2 a -> T1 = T2.

Lemma DataTy_tm_subst_tm_tm : forall b x A,
    DataTy A a_Star -> lc_tm b -> DataTy (tm_subst_tm_tm b x A) a_Star.

Lemma DataTy_co_subst_co_tm : forall b x A,
    DataTy A a_Star -> lc_co b -> DataTy (co_subst_co_tm b x A) a_Star.

Hint Resolve DataTy_tm_subst_tm_tm DataTy_co_subst_co_tm : lngen.

Definition decide_Path : forall a, lc_tm a -> (exists T, Path T a) \/ (forall T, not (Path T a)).

Lemma tm_subst_tm_tm_Value_mutual :
  (forall v,  CoercedValue v -> forall b x,  lc_tm b -> CoercedValue (tm_subst_tm_tm b x v)) /\
  (forall v, Value v -> forall b x,  lc_tm b -> Value (tm_subst_tm_tm b x v)).

Lemma Value_tm_subst_tm_tm :
  (forall v b x, Value v -> lc_tm b -> Value (tm_subst_tm_tm b x v)).

Lemma CoercedValue_tm_subst_tm_tm :
  (forall v b x, CoercedValue v -> lc_tm b -> CoercedValue (tm_subst_tm_tm b x v)).

Lemma Value_UAbsIrrel_exists : ∀ x (a : tm),
    x `notin` fv_tm a
    → (Value (open_tm_wrt_tm a (a_Var_f x)))
    → Value (a_UAbs Irrel a).

Lemma Value_AbsIrrel_exists : ∀ x (A a : tm),
    x `notin` fv_tm a
    -> lc_tm A
    → (CoercedValue (open_tm_wrt_tm a (a_Var_f x)))
    → Value (a_Abs Irrel A a).

Lemma co_subst_co_tm_Value_mutual :
  (forall v,  CoercedValue v -> forall b x,  lc_co b -> CoercedValue (co_subst_co_tm b x v)) /\
  (forall v, Value v -> forall b x,  lc_co b -> Value (co_subst_co_tm b x v)).

Lemma Value_co_subst_co_tm :
  (forall v b x, Value v -> lc_co b -> Value (co_subst_co_tm b x v)).

Lemma CoercedValue_co_subst_co_tm :
  (forall v b x, CoercedValue v -> lc_co b -> CoercedValue (co_subst_co_tm b x v)).

Lemma decide_Value_mutual : forall a,
    lc_tm a ->
    (Value a \/ not (Value a)) /\ (CoercedValue a \/ (not (CoercedValue a))).

Lemma decide_Value : forall a, lc_tm a -> (Value a \/ not (Value a)).

Lemma decide_CoercedValue : forall a, lc_tm a -> (CoercedValue a \/ not (CoercedValue a)).

Lemma DataTy_value_type : forall A, DataTy A a_Star -> value_type A. *)



Lemma Beta_lc1 : forall a a' , Beta a a' -> lc_tm a.

  intros.  induction H; auto.

  eapply Value_lc in H. eauto.

Qed.



Lemma Beta_lc2 : forall a a' , Beta a a' -> lc_tm a'.

intros.  induction H; auto.

- inversion H. apply lc_body_tm_wrt_tm; auto.

- apply Value_lc in H. inversion H.

  apply lc_body_tm_wrt_tm; auto.

- inversion H. apply lc_body_tm_wrt_co; auto.

- apply Toplevel_lc in H. inversion H. auto.

Qed.



Lemma cf : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b.

  intros. f_equal.

  auto.

Qed.

Lemma Beta_tm_subst : forall a a' b x, Beta a a' -> lc_tm b -> Beta (tm_subst_tm_tm b x a) (tm_subst_tm_tm b x a').

Proof.

  intros.

  destruct H.

  - simpl.

    rewrite tm_subst_tm_tm_open_tm_wrt_tm; eauto 2.

    econstructor; eauto using tm_subst_tm_tm_lc_tm.

    apply tm_subst_tm_tm_lc_tm with (a2 := b) (x1:=x) in H; auto.

  - simpl.

    rewrite tm_subst_tm_tm_open_tm_wrt_tm; eauto 2.

    econstructor; eauto using tm_subst_tm_tm_lc_tm.

    eapply Value_tm_subst_tm_tm in H; eauto.

  - simpl.

    rewrite tm_subst_tm_tm_open_tm_wrt_co; eauto 2.

    simpl.

    econstructor.

    apply tm_subst_tm_tm_lc_tm with (a2 := b) (x1:=x) in H; auto.

  - move: (toplevel_closed H) => h.

    simpl.

    rewrite tm_subst_tm_tm_fresh_eq. eauto.

    move: (first context_fv_mutual _ _ _ h) => Fr. simpl in Fr.

    fsetdec.

Qed.



Lemma Beta_co_subst : forall a a' b x, Beta a a' -> lc_co b -> Beta (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Proof.

  intros.

  destruct H.

  - simpl.

    rewrite co_subst_co_tm_open_tm_wrt_tm; eauto 2.

    econstructor; eauto using co_subst_co_tm_lc_tm.

    apply co_subst_co_tm_lc_tm with (g1 := b) (c1:=x) in H; auto.

  - simpl.

    rewrite co_subst_co_tm_open_tm_wrt_tm; eauto 2.

    econstructor; eauto using co_subst_co_tm_lc_tm.

    eapply Value_co_subst_co_tm in H; eauto.

  - simpl.

    rewrite co_subst_co_tm_open_tm_wrt_co; eauto 2.

    simpl.

    econstructor.

    apply co_subst_co_tm_lc_tm with (g1 := b) (c1:=x) in H; auto.

  - move: (toplevel_closed H) => h.

    simpl.

    rewrite co_subst_co_tm_fresh_eq. eauto.

    move: (first context_fv_mutual _ _ _ h) => Fr. simpl in Fr.

    fsetdec.

Qed.

