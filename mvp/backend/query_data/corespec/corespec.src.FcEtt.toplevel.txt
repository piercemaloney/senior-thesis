Set Bullet Behavior "Strict Subproofs".

Set Implicit Arguments.



Require Export FcEtt.tactics.

Require Export FcEtt.imports.

Require Export FcEtt.ett_inf.

Require Export FcEtt.ett_ott.

Require Export FcEtt.ett_ind.

Require Import FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)



Require Export FcEtt.fix_typing.



Lemma uniq_an_toplevel : uniq an_toplevel.

Proof.

 induction AnnSig_an_toplevel; auto.

Qed.

Lemma uniq_toplevel : uniq toplevel.

Proof.

  induction Sig_toplevel; auto.

Qed.



Lemma toplevel_closed : forall F a A, binds F (Ax a A) toplevel ->

                                 Typing nil a A.

Proof.

  have st: Sig toplevel by apply Sig_toplevel.

  induction st.

  - intros. inversion H.

  - intros. inversion H2. inversion H3. eauto.

  - intros. inversion H2. inversion H3. subst. auto.

    eauto.

Qed.



Lemma toplevel_to_const : forall T A, binds T (Cs A) toplevel -> Typing nil A a_Star.

Proof.

  have st: Sig toplevel by apply Sig_toplevel.

  induction st.

  - intros. inversion H.

  - intros. inversion H2. inversion H3. subst. auto.

    eapply IHst. eauto.

  - intros. inversion H2. inversion H3.

    eauto.

Qed.



Lemma an_toplevel_closed : forall F a A, binds F (Ax a A) an_toplevel ->

                                    AnnTyping nil a A.

Proof.

  have st: AnnSig an_toplevel by apply AnnSig_an_toplevel.

  induction st.

  - intros. inversion H.

  - intros. inversion H2. inversion H3. eauto.

  - intros. inversion H2. inversion H3. subst. eauto. eauto.

Qed.



Lemma an_toplevel_to_const : forall T A, binds T (Cs A) an_toplevel -> AnnTyping nil A a_Star.

Proof.

  have st: AnnSig an_toplevel by apply AnnSig_an_toplevel.

  induction st.

  - intros. inversion H.

  - intros. inversion H2. inversion H3. subst. auto.

    eapply IHst. eauto.

  - intros. inversion H2. inversion H3.

    eauto.

Qed.



Lemma binds_to_type : forall S T A, AnnSig S -> binds T (Cs A) S -> DataTy A a_Star.

Proof. induction 1. intros. inversion H.

       intros. destruct H3. inversion H3. subst. auto.

       eauto.

       intros. destruct H3. inversion H3. eauto.

Qed.

