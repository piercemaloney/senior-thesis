Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)



Require Import FcEtt.fc_dec_fuel.
(* FcEtt.fc_dec_fuel:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.

Require Import FcEtt.ett_ind.

Set Bullet Behavior "Strict Subproofs".

Module fc_dec_fuel (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).

Inductive fuel_tpg : tm -> Type :=
 | FT_Star :
    fuel_tpg a_Star
 | FT_Var_f : ∀ (x:tmvar),
    fuel_tpg (a_Var_f x)
 | FT_Pi : ∀ (rho:relflag) (A B:tm),
    (∀ x , x \notin  (fv_tm_tm_tm B) ->
      fuel_tpg (open_tm_wrt_tm B (a_Var_f x)))  ->
    fuel_tpg A ->
    fuel_tpg (a_Pi rho A B)
 | FT_Abs : ∀ (rho:relflag) (a A:tm),
    (∀ x , x \notin  (fv_tm_tm_tm a) ->
      fuel_tpg  (open_tm_wrt_tm a (a_Var_f x))) ->
    fuel_tpg A ->
    fuel_tpg (a_Abs rho A a)
 | FT_App : ∀ (rho:relflag) (b a:tm),
    fuel_tpg b ->
    fuel_tpg a ->
    fuel_tpg (a_App b rho a)
 | FT_Conv : ∀ (a:tm) g,
    fuel_tpg a ->
    fuel_deq g ->
    fuel_tpg (a_Conv a g)
 | FT_CPi : ∀ (phi:constraint) (B:tm),
    (∀ c, c \notin  (fv_co_co_tm B) -> fuel_tpg (open_tm_wrt_co B (g_Var_f c))) ->
    fuel_pwf phi ->
    fuel_tpg (a_CPi phi B)
 | FT_CAbs : ∀ (a:tm) (phi:constraint),
    (∀ c, c \notin (fv_co_co_constraint phi \u fv_co_co_tm a) -> fuel_tpg (open_tm_wrt_co a (g_Var_f c))) ->
    fuel_pwf phi ->
    fuel_tpg (a_CAbs phi a)
 | FT_CApp : ∀ (b:tm) g,
    fuel_tpg b ->
    fuel_deq g ->
    fuel_tpg (a_CApp b g)
 | FT_Const : ∀ (T:atom),
    fuel_tpg (a_Const T)
 | FT_Fam : forall (F:tyfam),
    fuel_tpg (a_Fam F)

 | FT_Var_b : forall n0,
     fuel_tpg (a_Var_b n0)
 | FT_UAbs : forall rho a,
     fuel_tpg (a_UAbs rho a)
 | FT_UCAbs : forall a,
     fuel_tpg (a_UCAbs a)
 | FT_DataCon : forall K,
     fuel_tpg (a_DataCon K)
 | FT_Case : forall a brs5,
     fuel_tpg (a_Case a brs5)
 | FT_Bullet :
     fuel_tpg a_Bullet

with fuel_pwf : constraint -> Type :=
  | FP_fuel_pwf : ∀ a b A,
    fuel_tpg a ->
    fuel_tpg b ->
    fuel_pwf (Eq a b A)

with fuel_iso : co -> Type :=
  | FI_Cong : ∀ (g1:co) (A:tm) (g2:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_iso (g_EqCong g1 A g2)
  | FI_CPiFst : ∀ (g:co),
    fuel_deq g ->
    fuel_iso (g_CPiFst g)
  | FI_IsoSym : ∀ (g:co),
    fuel_iso g ->
    fuel_iso (g_Sym g)
  | FI_IsoConv : ∀ (g:co) phi1 phi2,
    fuel_deq g ->
    fuel_pwf phi1 ->
    fuel_pwf phi2 ->
    fuel_iso (g_IsoConv phi1 phi2 g)

  | FI_Triv :
    fuel_iso g_Triv
  | FI_Var_b : forall n0,
    fuel_iso (g_Var_b n0)
  | FI_Var_f : ∀ (c:covar),
    fuel_iso (g_Var_f c)
  | FI_Refl : ∀ (a:tm),
    fuel_iso (g_Refl a)
  | FI_Refl2 : ∀ (a b:tm) (g:co),
    fuel_iso (g_Refl2 a b g)
  | FI_Trans : ∀ (g1 g2: co),
    fuel_iso (g_Trans g1 g2)
  | FI_Beta : ∀ (a1 a2:tm),
    fuel_iso (g_Beta a1 a2)
  | FI_PiCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_iso (g_PiCong rho g1 g2)
  | FI_AbsCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_iso ((g_AbsCong rho g1 g2))
  | FI_AppCong : ∀ (g1:co) (g2:co) (rho:relflag),
    fuel_iso (g_AppCong g1 rho g2)
  | FI_PiFst : ∀ (g:co),
    fuel_iso (g_PiFst g)
  | FI_PiSnd : ∀ (g1 g2:co),
    fuel_iso (g_PiSnd g1 g2)
  | FI_CPiCong : ∀ (g1 g3:co),
    fuel_iso ((g_CPiCong g1 g3))
  | FI_CAbsCong : ∀ (g1 g3 g4:co),
    fuel_iso ((g_CAbsCong g1 g3 g4))
  | FI_CAppCong : ∀  (g1 g2 g3:co),
    fuel_iso (g_CAppCong g1 g2 g3)
  | FI_CPiSnd : ∀  (g1 g2 g3:co),
    fuel_iso (g_CPiSnd g1 g2 g3)
  | FI_Cast : ∀  (g1 g2:co),
    fuel_iso (g_Cast g1 g2)
  | FI_IsoSnd : ∀  (g:co),
    fuel_iso (g_IsoSnd g)

  | FI_Eta : forall a,
    fuel_iso (g_Eta a)

  | FI_Left : forall g1 g2,
      fuel_iso (g_Left g1 g2)
  | FI_Right : forall g1 g2,
      fuel_iso (g_Right g1 g2)

with fuel_deq : co -> Type :=
  | FD_Assn : ∀ (c:covar),
    fuel_deq (g_Var_f c)
  | FD_Refl : ∀ (a:tm),
    fuel_tpg a ->
    fuel_deq (g_Refl a)
  | FD_Refl2 : ∀ (a b:tm) (g:co),
    fuel_tpg a ->
    fuel_tpg b ->
    fuel_deq g ->
    fuel_deq (g_Refl2 a b g)
  | FD_Sym : ∀ (g:co),
    fuel_deq g ->
    fuel_deq (g_Sym g)
  | FD_Trans : ∀ (g1 g2: co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq (g_Trans g1 g2)
  | FD_Beta : ∀ (a1 a2:tm),
    fuel_tpg a1 ->
    fuel_tpg a2 ->
    fuel_deq (g_Beta a1 a2)

  | FD_PiCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_deq g1 ->
    (∀ x, x \notin (fv_tm_tm_co g1 \u fv_tm_tm_co g2) ->
      fuel_deq (open_co_wrt_tm g2 (a_Var_f x))) ->
    fuel_deq (g_PiCong rho g1 g2)
  | FD_AbsCong : ∀ (rho:relflag) (g1 g2:co),
    fuel_deq g1 ->
    (∀ x,
      x \notin (fv_tm_tm_co g1 \u fv_tm_tm_co g2) ->
      fuel_deq (open_co_wrt_tm g2 (a_Var_f x))) ->
    fuel_deq ((g_AbsCong rho g1 g2))
  | FD_AppCong : ∀ (g1:co) (g2:co) (rho:relflag),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq (g_AppCong g1 rho g2)
  | FD_PiFst : ∀ (g:co),
    fuel_deq g ->
    fuel_deq (g_PiFst g)
  | FD_PiSnd : ∀ (g1 g2:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq (g_PiSnd g1 g2)
  | FD_CPiCong : ∀ (g1 g3:co),
    fuel_iso g1 ->
    (∀ c,
      c \notin  (fv_co_co_co g1 \u fv_co_co_co g3) ->
      fuel_deq (open_co_wrt_co g3 (g_Var_f c))) ->
    fuel_deq ((g_CPiCong g1 g3))
  | FD_CAbsCong : ∀ (g1 g3 g4:co),
    fuel_iso g1 ->
    (∀ c,
      c \notin (fv_co_co_co g1 \u fv_co_co_co g3) ->
      fuel_deq (open_co_wrt_co g3 (g_Var_f c))) ->
    fuel_deq g4 ->
    fuel_deq ((g_CAbsCong g1 g3 g4))
  | FD_CAppCong : ∀  (g1 g2 g3:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq g3 ->
    fuel_deq (g_CAppCong g1 g2 g3)
  | FD_CPiSnd : ∀  (g1 g2 g3:co),
    fuel_deq g1 ->
    fuel_deq g2 ->
    fuel_deq g3 ->
    fuel_deq (g_CPiSnd g1 g2 g3)
  | FD_Cast : ∀  (g1 g2:co),
    fuel_deq g1 ->
    fuel_iso g2 ->
    fuel_deq (g_Cast g1 g2)
  | FD_IsoSnd : ∀  (g:co),
    fuel_iso g ->
    fuel_deq (g_IsoSnd g)

  | FD_Triv :
      fuel_deq g_Triv
  | FD_Var_b : forall n0,
      fuel_deq (g_Var_b n0)
  | FD_CPiFst : ∀ (g:co),
    fuel_deq (g_CPiFst g)
  | FD_Cong : ∀ (g1:co) (A:tm) (g2:co),
    fuel_deq (g_EqCong g1 A g2)
  | FD_IsoConv : ∀ (g:co) phi1 phi2,
      fuel_deq (g_IsoConv phi1 phi2 g)

  | FD_Eta : forall a,
      fuel_tpg a ->
      fuel_deq (g_Eta a)

  | FD_Left : forall g1 g2,
      fuel_deq g1 ->
      fuel_deq g2 ->
      fuel_deq (g_Left g1 g2)

  | FD_Right : forall g1 g2,
      fuel_deq g1 ->
      fuel_deq g2 ->
      fuel_deq (g_Right g1 g2)

.

Hint Constructors fuel_deq fuel_iso fuel_pwf fuel_tpg.

Scheme
     ind_fuel_tpg := Induction for fuel_tpg Sort Prop
with ind_fuel_pwf := Induction for fuel_pwf Sort Prop
with ind_fuel_iso := Induction for fuel_iso Sort Prop
with ind_fuel_deq := Induction for fuel_deq Sort Prop.

Combined Scheme fuel_mutind from ind_fuel_tpg, ind_fuel_pwf, ind_fuel_iso, ind_fuel_deq.

End fc_dec_fuel. *)

Require Import FcEtt.fc_dec_aux.
(* FcEtt.fc_dec_aux:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.dep_prog.
Require Export FcEtt.ett_ind.
Require Export FcEtt.ett_par. 
Require Export FcEtt.erase_syntax.  

Module fc_dec_aux (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).

Import unique.

Lemma eq_relflag_dec : forall t1 t2 : relflag, {t1 = t2} +  {~ t1 = t2}.

Ltac nosub t2 :=  destruct t2; try solve[ left; auto]; right; done.

Ltac onesub t2 :=
    let h := fresh in
    destruct t2;
    try solve [right; done];
    match goal with
      [
         H0 : ∀ t2, {?B = t2} + {?B ≠ t2} |-
                    { ?C ?B = ?C ?e } + { ?F } ] =>
      destruct (H0 e); subst;
        try solve [left; auto];
        try solve [right; intro h; inversion h; done]
            end.
Ltac twosub t2 :=
    let h := fresh in
    destruct t2;
    try solve [right; done];
    match goal with
      [  H : ∀ t2, {?phi = t2} + {?phi ≠ t2},
         H0 : ∀ t2, {?B = t2} + {?B ≠ t2} |-
                    { ?C ?phi ?B = ?C ?d ?e } + { ?F } ] =>
      destruct (H d); subst; destruct (H0 e); subst;
        try solve [left; auto];
        try solve [right; intro h; inversion h; done]
         end.
Ltac threesub t2 :=
    let h := fresh in
    destruct t2;
    try solve [right; done];
    match goal with
      [  H : ∀ t2, {?phi = t2} + {?phi ≠ t2},
         H1 : ∀ t2, {?A = t2} + {?A ≠ t2},
         H0 : ∀ t2, {?B = t2} + {?B ≠ t2} |-
                    { ?C ?phi ?A ?B = ?C ?d ?e ?f} + { ?F } ] =>
      destruct (H d); subst; destruct (H1 e); subst;
      destruct (H0 f); subst;
        try solve [left; auto];
        try solve [right; intro h; inversion h; done]
         end.

Lemma tm_eq_dec_mutual :
  ((forall t1 t2 : tm, {t1 = t2} +  {~ t1 = t2}) *
   (forall t1 t2 : brs, {t1 = t2} +  {~ t1 = t2}) *
   (forall t1 t2 : co, {t1 = t2} +  {~ t1 = t2}) *
   (forall t1 t2 : constraint, {t1 = t2} +  {~ t1 = t2})).

Lemma tm_eq_dec : forall t1 t2 : tm, {t1 = t2} + {~ t1 = t2}.

Lemma const_eq_dec : forall (phi1 phi2 : constraint), {phi1 = phi2} + {¬ phi1 = phi2}.

Lemma co_eq_dec : forall g1 g2 : co, {g1 = g2} + {~ g1 = g2}.

Lemma in_dec : forall x L, {x `in` L} + {¬ x `in` L}.

Lemma not_in_dec : forall x L, {¬ x `in` L} + {x `in` L}.

Lemma uniq_binds_dec_tm : forall x G, uniq G -> {A | binds x (Tm A) G} + {(forall A, ¬ binds x (Tm A) G)}.

Lemma binds_dec_tm : forall x G, {A | binds x (Tm A) G} + {(forall A, ¬ binds x (Tm A) G)}.

Lemma binds_dec_co : forall x G, {AB, K | binds x (Co (Eq (fst AB) (snd AB) K)) G} + {(forall A B K, ¬ binds x (Co (Eq A B K)) G)}.

Lemma binds_dec_cs : forall x G, {C | binds x (Cs  C) G} + {(forall C, ¬ binds x (Cs  C) G)}.

Lemma Path_dec : forall a, lc_tm a -> { T | Path T a } + { (forall T, not (Path T a)) }.

Lemma Value_AbsIrrel_inversion : forall A a,
    Value (a_Abs Irrel A a)
    -> lc_tm A /\ forall x, x `notin` fv_tm a -> CoercedValue (open_tm_wrt_tm a (a_Var_f x)).

Lemma Value_UAbsIrrel_inversion : forall a,
    Value (a_UAbs Irrel a)
    -> forall x, x `notin` fv_tm a -> Value (open_tm_wrt_tm a (a_Var_f x)).

Ltac eauto_lc :=
  eauto using lc_tm_of_lc_set_tm,
  lc_co_of_lc_set_co,
  lc_constraint_of_lc_set_constraint.

Lemma decide_Value_mutual : forall a, lc_set_tm a -> ({ Value a } + { not (Value a) }) * ({ CoercedValue a } + { not (CoercedValue a) }).

Lemma Value_dec :  forall a, lc_tm a -> ({ Value a } + { not (Value a) }).

Lemma DataTy_Star_dec : forall A, lc_set_tm A -> { DataTy A a_Star } + { not (DataTy A a_Star) }.

Lemma binds_dec_ax : forall x G, {A, B | binds x (Ax A B) G} + {(forall A B, ¬ binds x (Ax A B) G)}.

Definition rho_eq_dec : forall rho rho' : relflag, {rho = rho'} + {rho <> rho'}.

Lemma beta_dec : forall a1 a2, lc_tm a1 -> {Beta a1 a2} + {¬ Beta a1 a2}.

Unset Implicit Arguments.

Program Fixpoint RhoCheck_erase_dec rho x a (_ : lc_tm a) : {RhoCheck rho x (erase_tm a)} + {¬ RhoCheck rho x (erase_tm a)} :=
  let a' := erase a in
  match rho with
    | Rel => yeah
    | Irrel =>  not_in_dec x (fv_tm_tm_tm a') >--> yeah
  end.

End fc_dec_aux. *)



Require Import FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)

Require Export FcEtt.ett_inf_cs.

Require Import FcEtt.ett_ind.
(* FcEtt.ett_ind:
Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Export FcEtt.fset_facts.
Require Export FcEtt.ett_inf.
Require Export FcEtt.tactics.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma tm_subst_tm_tm_var : forall a x, tm_subst_tm_tm a x (a_Var_f x) = a.

Lemma co_subst_co_co_var : forall a x, co_subst_co_co a x (g_Var_f x) = a.

Lemma tm_subst_tm_tm_var_neq : forall a x y, x <> y ->
    tm_subst_tm_tm a y (a_Var_f x) = (a_Var_f x).

Lemma co_subst_co_co_var_neq : forall a x y, x <> y ->
    co_subst_co_co a y (g_Var_f x) = (g_Var_f x).

Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm_var : subst_open_var.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co_var : open_subst_var.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co_var : open_subst_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_tm : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm : subst_open.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm : open_subst.

Ltac apply_lc_exists x :=
  pick fresh x;
  ( apply lc_a_Abs_exists      with (x1 := x)
  || apply lc_a_Pi_exists       with (x1 := x)
  || apply lc_a_CPi_exists      with (c1 := x)
  || apply lc_a_CAbs_exists     with (c1 := x)
  || apply lc_a_UAbs_exists     with (x1:= x)
  || apply lc_a_UCAbs_exists    with (c1 := x)
  || apply lc_g_PiCong_exists   with (x1 := x)
  || apply lc_g_AbsCong_exists  with (x1 := x)
  || apply lc_g_CPiCong_exists  with (c1 := x)
  || apply lc_g_CAbsCong_exists with (c1 := x)
  || fail "invalid case for apply_lc_exists" );
  eauto 2.

Ltac lc_solve_binds :=
  match goal with
  
  | [ H : binds ?x ?s nil |- _ ] => inversion H; clear H
  
  | [ H : binds _ ?s ([(_,_)] ++ _) |- _ ?s] =>
      destruct (binds_cons_1 _ _ _ _ _ _ H); basic_solve
  
  | [ b : binds ?x _ ?G, H : ∀ (x' : atom) _, binds x' _ ?G → _ |- _] =>
      by apply H in b; inversion b; try done;
          match goal with
            | [H' : lc_constraint _ |- _] => inversion H' ; clear H'
            | [H' : lc_tm         _ |- _] => inversion H' ; clear H'
          end
  end.

Ltac lc_inversion c :=
  repeat match goal with
    
  | [ H : forall x, (x `in` ?L -> False) -> lc_tm _ /\ _ |- _ ] =>
    destruct (H c ltac:(auto)); split_hyp; clear H
  
  | [ H : lc_constraint (_ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Abs _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_App _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Pi _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Conv _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CPi _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UCAbs _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CApp _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Case _ _) |- _ ] =>
    inversion H; clear H
 end.

Ltac apply_lc_body :=
  match goal with
  | |- lc_tm (open_tm_wrt_tm ?a ?b) => eapply lc_body_tm_wrt_tm; auto
  | |- lc_tm (open_tm_wrt_co ?a ?b) => eapply lc_body_tm_wrt_co; auto
  end.

Lemma co_subst_co_tm_lc_tm_inverse
  : ∀ (g1 : co) (c1 : covar),
      lc_co g1 ->
      (forall A,
          lc_tm A -> forall XX, A = (co_subst_co_tm g1 c1 XX) -> lc_tm XX)
      /\
      (forall b1,
          lc_brs b1 -> forall XX, b1 = (co_subst_co_brs g1 c1 XX) -> lc_brs XX)
      /\
      (forall co,
          lc_co co -> forall XX, co = (co_subst_co_co g1 c1 XX) -> lc_co XX)
      /\
      (forall phi,
          lc_constraint phi -> forall XX, phi = (co_subst_co_constraint g1 c1 XX) ->
          lc_constraint XX).

Ltac invert_syntactic_equality :=
  repeat match goal with
  | [ H : a_Var_f _  = a_Var_f _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Abs _ _ = a_Abs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UAbs _ _ = a_UAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Pi _ _ _ = a_Pi _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_App _ _ _ = a_App _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Fam _  = a_Fam _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Const _  = a_Const _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Conv _ _ = a_Conv _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UCAbs _ = a_UCAbs _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CAbs + _ = a_CAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CApp _ _  = a_CApp _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CPi _ _ = a_CPi _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : Eq _ _ _ = Eq _ _ _ |- _ ] =>
    inversion H; subst; clear H
  end.

Ltac ann_invert_clear :=
  match goal with
  | H : AnnTyping _ a_Star _ |- _ => inversion H; subst; clear H
  | H : AnnTyping _ (_ _) _ |- _ =>  inversion H; subst; clear H
  | H : AnnPropWff _ _ |- _ => inversion H; subst; clear H
  | H : AnnIso _ _ (_ _) _ _ |- _ => inversion H; subst; clear H
  | H : AnnDefEq _ _ (_ _) _ _  |- _ => inversion H; subst; clear H
  | H : AnnCtx ([(_,_)] ++ _) |- _ => inversion H; subst; clear H
  | H : AnnCtx (_ :: _) |- _ => inversion H; subst; clear H
  end.

Lemma lc_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x0)).

Lemma fv_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    x0 `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0)).

Scheme typing_ind' := Induction for Typing Sort Prop
   with wff_ind'   := Induction for PropWff Sort Prop
   with iso_ind'   := Induction for Iso Sort Prop
   with defeq_ind' := Induction for DefEq Sort Prop
   with ctx_ind'   := Induction for Ctx Sort Prop.

Combined Scheme typing_wff_iso_defeq_mutual from typing_ind', wff_ind', iso_ind', defeq_ind', ctx_ind'.

Scheme ann_typing_ind' := Induction for AnnTyping Sort Prop
   with ann_wff_ind'   := Induction for AnnPropWff Sort Prop
   with ann_iso_ind'   := Induction for AnnIso Sort Prop
   with ann_defeq_ind' := Induction for AnnDefEq Sort Prop
   with ann_ctx_ind'   := Induction for AnnCtx Sort Prop.

Combined Scheme ann_typing_wff_iso_defeq_mutual
from ann_typing_ind', ann_wff_ind', ann_iso_ind',
     ann_defeq_ind', ann_ctx_ind'.

Scheme CoercedValue_ind' := Induction for CoercedValue Sort Prop
                            with Value_ind' := Induction for Value Sort Prop.
Combined Scheme CoercedValue_Value_mutual from CoercedValue_ind', Value_ind'.

Ltac ext_induction CON :=
    apply typing_wff_iso_defeq_mutual;
    [ pose CON :=  E_Star       |
      pose CON :=  E_Var        |
      pose CON :=  E_Pi         |
      pose CON :=  E_Abs        |
      pose CON :=  E_App        |
      pose CON :=  E_IApp       |
      pose CON :=  E_Conv       |
      pose CON :=  E_CPi        |
      pose CON :=  E_CAbs       |
      pose CON :=  E_CApp       |
      pose CON :=  E_Const      |
      pose CON :=  E_Fam        |
      pose CON :=  E_Wff        |
      pose CON :=  E_PropCong   |
      pose CON :=  E_IsoConv    |
      pose CON :=  E_CPiFst     |
      pose CON :=  E_Assn       |
      pose CON :=  E_Refl       |
      pose CON :=  E_Sym        |
      pose CON :=  E_Trans      |
      pose CON :=  E_Beta       |
      pose CON :=  E_PiCong     |
      pose CON :=  E_AbsCong    |
      pose CON :=  E_AppCong    |
      pose CON :=  E_IAppCong   |
      pose CON :=  E_PiFst      |
      pose CON :=  E_PiSnd      |
      pose CON :=  E_CPiCong    |
      pose CON :=  E_CAbsCong   |
      pose CON :=  E_CAppCong   |
      pose CON :=  E_CPiSnd     |
      pose CON :=  E_Cast       |
      pose CON :=  E_EqConv     |
      pose CON :=  E_IsoSnd     |
      pose CON :=  E_EtaRel     |
      pose CON :=  E_EtaIrrel   |
      pose CON :=  E_EtaC       |

      pose CON :=  E_Empty      |
      pose CON :=  E_ConsTm     |
      pose CON :=  E_ConsCo     ].

Ltac ann_induction CON :=
    apply ann_typing_wff_iso_defeq_mutual;
    [ pose CON :=  An_Star       |
      pose CON :=  An_Var        |
      pose CON :=  An_Pi         |
      pose CON :=  An_Abs        |
      pose CON :=  An_App        |
      pose CON :=  An_Conv       |
      pose CON :=  An_CPi        |
      pose CON :=  An_CAbs       |
      pose CON :=  An_CApp       |
      pose CON :=  An_Const      |
      pose CON :=  An_Fam        |
      pose CON :=  An_Wff        |
      pose CON :=  An_PropCong   |
      pose CON :=  An_CPiFst     |
      pose CON :=  An_IsoSym     |
      pose CON :=  An_IsoConv    |
      pose CON :=  An_Assn       |
      pose CON :=  An_Refl       |
      pose CON :=  An_EraseEq      |
      pose CON :=  An_Sym        |
      pose CON :=  An_Trans      |
      pose CON :=  An_Beta       |
      pose CON :=  An_PiCong     |
      pose CON :=  An_AbsCong    |
      pose CON :=  An_AppCong    |
      pose CON :=  An_PiFst      |
      pose CON :=  An_PiSnd      |
      pose CON :=  An_CPiCong    |
      pose CON :=  An_CAbsCong   |
      pose CON :=  An_CAppCong   |
      pose CON :=  An_CPiSnd     |
      pose CON :=  An_Cast       |
      pose CON :=  An_IsoSnd     |
      pose CON :=  An_Eta        |
      pose CON :=  An_EtaC       |

      pose CON :=  An_Empty      |
      pose CON :=  An_ConsTm     |
      pose CON :=  An_ConsCo     ].

Ltac ensure_case C :=
  match goal with [ CON := C : ?A |- _ ] => idtac end.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let C1 := gather_atoms_with (fun x : context => dom x) in
  let D1 := gather_atoms_with (fun x => fv_tm_tm_tm x) in
  let D2 := gather_atoms_with (fun x => fv_tm_tm_co x) in
  let D3 := gather_atoms_with (fun x => fv_tm_tm_constraint x) in
  let D4 := gather_atoms_with (fun x => fv_tm_tm_sort x) in
  let D5 := gather_atoms_with (fun x => fv_tm_tm_brs x) in
  let D6 := gather_atoms_with (fun x => fv_co_co_tm x) in
  let D7 := gather_atoms_with (fun x => fv_co_co_co x) in
  let D8 := gather_atoms_with (fun x => fv_co_co_constraint x) in
  let D9 := gather_atoms_with (fun x => fv_co_co_sort x) in
  let D10 := gather_atoms_with (fun x => fv_co_co_brs x) in
  constr:(A \u B \u C1 \u D1 \u D2 \u D3 \u D4 \u D5 \u D6 \u D7 \u D8 \u D9 \u D10).

Ltac rewrite_body :=
  match goal with
  | [ e : ∀ x : atom, (x `in` ?L → False)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
     rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ c : atom, (c `notin` ?L)
      → open_tm_wrt_co _ (g_Var_f c) =
        open_tm_wrt_co _ (g_Cast (g_Var_f c) (g_Sym _)) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `in` ?L → False) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `notin` ?L) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto

  end.

Ltac lc_solve :=
  let c := fresh in
  try lc_solve_binds;
  try apply_lc_exists c;
  lc_inversion c; auto;
  try rewrite_body;
  try apply_lc_body;
  eauto with lc.

Hint Resolve lc_a_Pi_exists
     lc_a_CPi_exists lc_a_Abs_exists lc_a_CAbs_exists lc_a_UAbs_exists.

Hint Resolve lc_body_tm_wrt_tm lc_body_tm_wrt_co. 

Lemma rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)) ->
    RhoCheck rho x0 (open_tm_wrt_tm a (a_Var_f x0)).

Lemma eta_swap: forall x y a' b rho,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b rho (a_Var_f x) ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b rho (a_Var_f y).

Lemma eta_swap_irrel: forall x y a' b,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b Irrel a_Bullet ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b Irrel a_Bullet.

Lemma eta_swap_c: forall x y a' b,
    x `notin` fv_co_co_tm a' \u fv_co_co_tm b ->
    open_tm_wrt_co a' (g_Var_f x) = a_CApp b g_Triv ->
    open_tm_wrt_co a' (g_Var_f y) = a_CApp b g_Triv.

Ltac auto_rew_env :=
  multimatch goal with
    | [ |- context [([(?x, ?T)] ++ ?G1 ++ ?G2 ++ ?G3)] ] => rewrite_env (((x ~ (T)) ++ G1) ++ G2 ++ G3)
  end.

Ltac E_pick_fresh x :=
  match goal with
    | [ |- Typing _ ?shape _ ] =>
      let v := match shape with
            | a_Pi _ _ _ => E_Pi
            | a_UAbs _ _ => E_Abs
            | a_CPi _ _  => E_CPi
            | a_CAbs _ _ => E_CAbs
            | a_UCAbs _  => E_CAbs
           end
      in pick fresh x and apply v
    | [ |- DefEq _ _ ?shape ?s2 _ ] =>
      let v := match shape with
               | a_Pi _ _ _ => E_PiCong
               | a_UAbs Rel _ => match s2 with
                                | a_UAbs _ _ => E_AbsCong
                                | _ => E_EtaRel
                                end
               | a_UAbs Irrel _ => match s2 with 
                                | a_UAbs _ _ =>  E_AbsCong
                                | _ => E_EtaIrrel
                                end
               | a_CPi _ _  => E_CPiCong
               | a_CAbs _ _ => E_CAbsCong
               | a_UCAbs _  => match s2 with 
                                | a_UCAbs _ =>  E_CAbsCong
                                | _ => E_EtaC
                                end
               end
      in pick fresh x and apply v
  end.

Ltac Par_pick_fresh x :=
  match goal with
    | [ |- Par _ _ ?shape ?s2 ] =>
      let v := match shape with
            | a_Pi _ _ _ => Par_Pi
            | a_UAbs Rel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_Eta
                                end
            | a_UAbs Irrel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_EtaIrrel
                                end
            | a_UAbs _ _ =>  Par_Abs
            | a_CPi _ _  => Par_CPi
            | a_CAbs _ _ => Par_CAbs
            | a_UCAbs _  => match s2 with
                                | a_UCAbs _ => Par_CAbs
                                | _ => Par_EtaC
                                end
           end
      in pick fresh x and apply v
  end.

Ltac An_pick_fresh x :=
  let shape := match goal with
                 | [ |- AnnTyping _   ?shape _    ] => shape
                 | [ |- AnnDefEq  _ _ ?shape _  _ ] => shape
               end in
  let ctor  := match shape with
    | a_Pi     _ _ _ => An_Pi
    | a_Abs    _ _ _ => An_Abs
    | a_CPi      _ _ => An_CPi
    | a_CAbs     _ _ => An_CAbs
    | g_PiCong _ _ _ => An_PiCong
    | g_AbsCong _ _ _  => An_AbsCong
    | g_CPiCong  _ _   => An_CPiCong
    | g_CAbsCong _ _ _ => An_CAbsCong
    | g_Eta _          => An_Eta
               end in
  pick fresh x and apply ctor.

Ltac RhoCheck_inversion y :=
  match goal with
  | [ K : ∀ x : atom, x `notin` ?L → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  | [ K : ∀ x : atom, (x `in` ?L -> False) → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  end.

Lemma lc_open_switch_co :
  forall g t, lc_co g ->
  lc_tm (open_tm_wrt_co t g_Triv) ->
  lc_tm (open_tm_wrt_co t g).

Hint Resolve lc_open_switch_co.

Lemma tm_subst_cast : forall a x g,
    tm_subst_tm_tm a x (a_Conv (a_Var_f x) g) = a_Conv a (tm_subst_tm_co a x g).

Hint Rewrite tm_subst_cast. *)

Require Export FcEtt.fc_invert.



Require Import FcEtt.dep_prog.
(* FcEtt.dep_prog:
Require FcEtt.imports.

Notation "f >-> g" := (fun x => (g (f x))) (at level 70).

Inductive sig2el (A:Type) (B:Type) (P : A -> B -> Prop) : Type :=
    exist2el : forall (x : A) (y : B), P x y -> sig2el P.

Notation "{ x , y | P }" := (sig2el (fun x y => P)) (at level 0, x at level 99, y at level 99) : type_scope.

Notation "'yeah'"      := (left _ _).
Notation "'nope'"      := (right _ _).

Notation "<< x >>"     := (inleft _ (exist _ x _)).

Notation "<< x , y >>" := (inleft _ (exist2el _ x y _)).
Notation "!!"          := (inright _ _).

Hint Resolve inleft inright left right.

Notation "x <- e1 ; e2" :=
  (match e1 with
     | inright _ => !!
     | inleft (exist x _) => e2
   end)
(right associativity, at level 60).

Notation "x <~ e1 ; e2" :=
  (match e1 with
     | inright _ => !!
     | inleft (exist x _) => e2
   end)
(right associativity, at level 60).

Notation "x <-- e1 ; e2" :=
  (match e1 with
     | inright _ => nope
     | inleft (exist x _) => e2
   end)
(right associativity, at level 60).

Notation "x & y <- e1 ; e2" :=
  (match e1 with
     | inright _ => !!
     | inleft (exist2el x y _) => e2
   end)
(right associativity, at level 60, y at level 0).

Notation "x & y <-- e1 ; e2" :=
  (match e1 with
     | inright _ => nope
     | inleft (exist2el x y _) => e2
   end)
(right associativity, at level 60, y at level 0).

Notation "e1 >--> e2" :=
  (match e1 with
     | right _ => nope
     | left _ => e2
   end)
(right associativity, at level 60).

Notation "e1 >---> e2" :=
  (match e1 with
     | right _ => !!
     | left _ => e2
   end)
(right associativity, at level 60). *)



Require Import FcEtt.toplevel.
(* FcEtt.toplevel:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.
Require Import FcEtt.utils.

Require Export FcEtt.fix_typing.

Lemma uniq_an_toplevel : uniq an_toplevel.
Lemma uniq_toplevel : uniq toplevel.

Lemma toplevel_closed : forall F a A, binds F (Ax a A) toplevel ->
                                 Typing nil a A.

Lemma toplevel_to_const : forall T A, binds T (Cs A) toplevel -> Typing nil A a_Star.

Lemma an_toplevel_closed : forall F a A, binds F (Ax a A) an_toplevel ->
                                    AnnTyping nil a A.

Lemma an_toplevel_to_const : forall T A, binds T (Cs A) an_toplevel -> AnnTyping nil A a_Star.

Lemma binds_to_type : forall S T A, AnnSig S -> binds T (Cs A) S -> DataTy A a_Star. *)



Require Import FcEtt.fc_get.
(* FcEtt.fc_get:
Require Import FcEtt.fc_invert.
Require Import Omega.
Require Import Coq.Arith.Wf_nat.
Require Import FcEtt.toplevel.

Require Import FcEtt.erase_syntax.
Require Import FcEtt.sigs.
Require Import FcEtt.fc_unique.
Require Import FcEtt.fc_invert.
Require Import FcEtt.fc_context_fv.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Module fc_get (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).
Import wf weak subst.

Module invert := fc_invert wf weak subst.
Import invert.

Fixpoint get_tpg_n (n : nat) (G : context) (a : tm) { struct n } : tm :=
match n with
| 0 => a_Star
| S m =>
  match a with
  | a_Star => a_Star
  | a_Var_f x =>
    match binds_lookup _ x G with
    | inl (exist (Tm A) _) => A
    | _ => a_Star
    end
  | a_Pi  rho A B => a_Star
  | a_Abs rho A a =>
    let (x,_) := atom_fresh (dom G) in
    a_Pi rho A (close_tm_wrt_tm x (get_tpg_n m ((x,Tm A)::G) (open_tm_wrt_tm a (a_Var_f x))))
  | a_App a1 rho a2 =>
    match get_tpg_n m G a1 with
      | a_Pi rho A B => open_tm_wrt_tm B a2
      | _ => a_Star
    end
  | a_Conv a g => let (_,b) := get_deq_n m G g in b
  | a_CPi phi B => a_Star
  | a_CAbs phi a => let (x,_) := atom_fresh (dom G) in
                   a_CPi phi (close_tm_wrt_co x (get_tpg_n m ((x,Co phi)::G) (open_tm_wrt_co a (g_Var_f x))))
  | a_Fam F =>
    match binds_lookup _ F an_toplevel with
    | inl (exist (Ax a A) _) => A
    | _ => a_Star
    end
  | a_CApp a1 g2 =>
    match get_tpg_n m G a1 with
      | a_CPi phi B => open_tm_wrt_co B g2
      | _ => a_Star
    end
  | a_Const T =>
     match binds_lookup _ T an_toplevel with
    | inl (exist (Cs A) _) => A
    | _ => a_Star
    end
  | _ => a_Star
  end
end
with
get_iso_n (n : nat) (G : context) (g : co) : (constraint * constraint) :=
  match n with
  | 0 => (Eq a_Star a_Star a_Star,Eq a_Star a_Star a_Star)
  | S m =>
    match g with
    | (g_EqCong g1 A g2) =>
      let (A1, A2) := get_deq_n m G g1 in
      let (B1, B2) := get_deq_n m G g2 in
      (Eq A1 B1 A, Eq A2 B2 A)
    | g_CPiFst g =>
      let (T1,T2) := get_deq_n m G g in
      match (T1, T2) with
      | (a_CPi phi1 A2, a_CPi phi2 B2) => (phi1, phi2)
      | _ => (Eq a_Star a_Star a_Star,Eq a_Star a_Star a_Star)
      end
    | g_Sym g =>
      let (phi2, phi1) := get_iso_n m G g in
      (phi1, phi2)
    | g_IsoConv (Eq a1 a2 A) (Eq a1' a2' B) g =>
      (Eq a1 a2 A, Eq a1' a2' B)
    | _ => (Eq a_Star a_Star a_Star,Eq a_Star a_Star a_Star)
    end
  end
with
get_deq_n (n : nat) (G : context) (g : co) : (tm * tm) :=
  match n with
  | 0 => (a_Star, a_Star)
  | S m =>
    match g with
    | g_Var_f c => match binds_lookup _ c G with
                  | inl (exist (Co (Eq a b A)) _) => (a,b)
                  | _ => (a_Star, a_Star)
                  end
    | g_Refl a => (a,a)
    | g_Refl2 a b g => (a,b)
    | g_Beta a b => (a,b)
    | g_Sym g => let (a,b) := get_deq_n m G g in
                (b,a)
    | g_Trans g1 g2 =>
      let (a,c1) := get_deq_n m G g1 in
      let (c2, b) := get_deq_n m G g2 in
      (a,b)
    | g_PiCong rho g1 g2 =>
      let (x,_) := atom_fresh (dom G) in
      let (A1,A2) := get_deq_n m G g1 in
      let (B1,B2) := get_deq_n m ([(x, Tm A1)] ++ G) (open_co_wrt_tm g2 (a_Var_f x)) in
      let B3 := tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2 in
      (a_Pi rho A1 (close_tm_wrt_tm x B1), a_Pi rho A2 (close_tm_wrt_tm x B3))
    | g_AbsCong rho g1 g2 =>
      let (x,_) := atom_fresh (dom G) in
      let (A1,A2) := get_deq_n m G g1 in
      let (b1,b2) := get_deq_n m ([(x,Tm A1)] ++ G) (open_co_wrt_tm g2 (a_Var_f x)) in
      let b3 := tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x b2 in
      (a_Abs rho A1 (close_tm_wrt_tm x b1), a_Abs rho A2 (close_tm_wrt_tm x b3))
    | g_AppCong g1 rho g2 =>
      let (a1, b1) := get_deq_n m G g1 in
      let (a2, b2) := get_deq_n m G g2 in
      (a_App a1 rho a2, a_App b1 rho b2)
    | g_PiFst g =>
      let (a,b) := get_deq_n m G g in
      match (a,b) with
      | (a_Pi rho1 A1 B1, a_Pi rho2 A2 B2) => (A1, A2)
      | (_,_) => (a_Star, a_Star)
      end
    | g_PiSnd g1 g2 =>
      let (T1,T2) := get_deq_n m G g1 in
      let (a1,a2) := get_deq_n m G g2 in
      match (T1,T2) with
      | (a_Pi rho1 A1 B1, a_Pi rho2 A2 B2) =>
        (open_tm_wrt_tm B1 a1, open_tm_wrt_tm B2 a2)
      | (_,_) => (a_Star, a_Star)
      end
    | g_CPiCong g1 g3 =>
      let (phi1,phi2) := get_iso_n m G g1 in
      let (x,_) := atom_fresh (dom G) in
      let (B1,B2) := get_deq_n m ([(x,Co phi1)] ++ G)
                               (open_co_wrt_co g3 (g_Var_f x)) in
      let B3 := co_subst_co_tm (g_Cast (g_Var_f x) (g_Sym g1)) x B2 in
      (a_CPi phi1 (close_tm_wrt_co x B1), a_CPi phi2 (close_tm_wrt_co x B3))
    | g_CAbsCong g1 g2 g3 =>
      let (phi1,phi2) := get_iso_n m G g1 in
      let (x,_) := atom_fresh (dom G) in
      let (b1,b2) := get_deq_n m ([(x,Co phi1)] ++ G)
                               (open_co_wrt_co g2 (g_Var_f x)) in
      let b3 := co_subst_co_tm (g_Cast (g_Var_f x) (g_Sym g1)) x b2 in
      (a_CAbs phi1 (close_tm_wrt_co x b1), a_CAbs phi2 (close_tm_wrt_co x b3))

    | (g_CAppCong g1 g2 g3) =>
      let (a1, b1) := get_deq_n m G g1 in
      (a_CApp a1 g2,a_CApp b1 g3)
    | (g_CPiSnd g1 g2 g3) =>
      match get_deq_n m G g1 with
      | (a_CPi (Eq a a' A) B1, a_CPi (Eq b b' B) B2) =>
         (open_tm_wrt_co  B1   g2, open_tm_wrt_co  B2   g3 )
      | (_,_) => (a_Star, a_Star)
      end
    | (g_Cast g1 g2) =>
      match get_iso_n m G g2 with
      | (Eq a a' A, Eq b b' B) => (b,b')
      end
    |  (g_IsoSnd g) =>
       match get_iso_n m G g with
       | (Eq a a' A, Eq b b' B) => (A, B)
       end
    | (g_Eta b) =>
      let (x,_) := atom_fresh (dom G) in
      match get_tpg_n m G b with
      | (a_Pi rho A B) => (a_Abs rho A (close_tm_wrt_tm x (a_App b rho (a_Var_f x))), b)
      | (a_CPi phi _) =>  (a_CAbs phi (close_tm_wrt_co x (a_CApp b (g_Var_f x))), b)
      | _ => (a_Star, a_Star)
      end
         | _ => (a_Star, a_Star)
    end
  end.

Definition get_tpg (G : context) (a:tm) : tm :=
  get_tpg_n (size_tm a) G a.
Definition get_deq (G : context) (g:co) : (tm*tm) :=
  get_deq_n (size_co g) G g.
Definition get_iso (G : context) (g:co) : (constraint*constraint) :=
  get_iso_n (size_co g) G g.

Lemma get_n_correct : forall n,
    (forall G a A B, size_tm a <= n -> AnnTyping G a A -> get_tpg_n n G a = B -> A = B) /\
    (forall G D g A B A' B', size_co g <= n -> AnnDefEq G D g A B ->
                        get_deq_n n G g = (A',B') -> A = A' /\ B = B') /\
    (forall G D g A B A' B', size_co g <= n -> AnnIso G D g A B ->
                        get_iso_n n G g = (A',B') -> A = A' /\ B = B').

Lemma get_tpg_correct : (forall G a A B, AnnTyping G a A -> get_tpg G a = B -> A = B).

Lemma get_deq_correct: (forall G D g A B A' B',  AnnDefEq G D g A B ->
                                            get_deq G g = (A',B') -> A = A' /\ B = B').

Lemma get_iso_correct: (forall G D g A B A' B',  AnnIso G D g A B ->
                                            get_iso G g = (A',B') -> A = A' /\ B = B').

Lemma An_PiCong_exists2: forall x1 x2 (G:context) D rho
                           (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
    x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
    -> x2 `notin` (dom G \u singleton x1 \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
    -> AnnDefEq G D g1 A1 A2
    → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
               (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
    → (open_tm_wrt_tm B3 (a_Var_f x2) =
       open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
    → get_tpg G A1 = a_Star
    → get_tpg ([(x1,Tm A1)] ++ G) (open_tm_wrt_tm B1 (a_Var_f x1)) = a_Star
    → get_tpg ([(x1,Tm A1)] ++ G) (open_tm_wrt_tm B2 (a_Var_f x1)) = a_Star
    → get_tpg G A2 = a_Star
    → get_tpg ([(x1,Tm A2)] ++ G) (open_tm_wrt_tm B3 (a_Var_f x1)) = a_Star
    → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

Lemma An_PiCong_exists3: forall x (G:context) D rho
                           (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
    x `notin` (dom G \u fv_tm_tm_co g2 \u fv_tm_tm_co g1)
    -> AnnDefEq G D g1 A1 A2
    → AnnDefEq ([(x, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) B1 B2
    → B3 = tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2
    → get_tpg G A1 = a_Star
    → get_tpg ([(x,Tm A1)] ++ G) B1 = a_Star
    → get_tpg ([(x,Tm A1)] ++ G) B2 = a_Star
    → get_tpg G A2 = a_Star
    → get_tpg ([(x,Tm A2)] ++ G) B3 = a_Star
    → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 (close_tm_wrt_tm x B1)) (a_Pi rho A2 (close_tm_wrt_tm x B3)).

Lemma An_AbsCong_exists3: forall x (G:context) D rho
                           (g1 g2 : co) (A1 B1 A2 B3 B2 B: tm),
    x `notin` (dom G \u fv_tm_tm_co g2 \u fv_tm_tm_co g1)
    -> AnnDefEq G D g1 A1 A2
    → AnnDefEq ([(x, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) B1 B2
    → B3 = tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2
    → get_tpg G A1 = a_Star
    → get_tpg ([(x,Tm A1)] ++ G) B2 = B 
    → get_tpg G A2 = a_Star
    → RhoCheck rho x (erase_tm B1)
    → RhoCheck rho x (erase_tm B3)
    → AnnDefEq G D (g_AbsCong rho g1 g2)
               (a_Abs rho A1 (close_tm_wrt_tm x B1))
               (a_Abs rho A2 (close_tm_wrt_tm x B3)).

Lemma An_CPiCong_exists_3 :  ∀ c (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
     c `notin` dom G \u D \u fv_co_co_co g3 \u fv_co_co_co g1
    -> AnnIso G D g1 phi1 phi2
    → AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c)) B1 B2
    → B3 = co_subst_co_tm (g_Cast (g_Var_f c) (g_Sym g1)) c B2
    -> get_tpg ([(c,Co phi1)] ++ G) B1 = a_Star
    -> get_tpg ([(c,Co phi2)] ++ G) B3 = a_Star
    -> get_tpg ([(c,Co phi1)] ++ G) B2 = a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 (close_tm_wrt_co c B1))
               (a_CPi phi2 (close_tm_wrt_co c B3)).

Lemma An_CAbsCong_exists3 :
        ∀ (c : atom) (G : context) (D : available_props)
           (g1 g3 g4 : co) (phi1 : constraint) (a1 : tm)
           (phi2 : constraint) (a3 a2 B1 B3 : tm),
    AnnIso G D g1 phi1 phi2
    → c `notin` dom G \u D \u (fv_co_co_co g3) \u (fv_co_co_co g1)
        \u fv_co_co_co g4
    → AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c)) a1 a2
    → a3 = co_subst_co_tm (g_Cast (g_Var_f c) (g_Sym g1)) c a2
    → get_tpg ([(c, Co phi1)] ++ G) a1 = B1
    -> get_tpg ([(c, Co phi2)] ++ G) a3 = B3
    → AnnDefEq G (dom G) g4 (a_CPi phi1 (close_tm_wrt_co c B1))
               (a_CPi phi2 (close_tm_wrt_co c B3))
    → AnnDefEq G D (g_CAbsCong g1 g3 g4)
               (a_CAbs phi1 (close_tm_wrt_co c a1))
               (a_CAbs phi2 (close_tm_wrt_co c a3))
                             .

End fc_get. *)

Require Import FcEtt.fc_context_fv.
(* FcEtt.fc_context_fv:
Require Export FcEtt.tactics.
Require Export FcEtt.ett_inf.

Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Import FcEtt.ett_ind.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Hint Resolve AnnCtx_uniq.
Hint Unfold AtomSetImpl.Subset.

Ltac solve_binds :=
  match goal with
    | [ b : binds ?v _ ?G
      , H : forall v' _, binds v' _ ?G -> _ [<=] dom ?G ∧ _ [<=] dom ?G
      |- _ ] =>
      apply H in b; simpl in b; split_hyp; (done || fsetdec)
  end.

Theorem ann_context_fv_mutual :
  (forall G (a : tm) A (H: AnnTyping G a A),
      fv_tm_tm_tm a [<=] dom G /\ fv_co_co_tm a [<=] dom G /\
      fv_tm_tm_tm A [<=] dom G /\ fv_co_co_tm A [<=] dom G)
  /\
  (forall G phi (H : AnnPropWff G phi),
      fv_tm_tm_constraint phi [<=] dom G /\ fv_co_co_constraint phi [<=] dom G)
  /\
  (forall G D g p1 p2 (H : AnnIso G D g p1 p2),
      fv_tm_tm_co         g  [<=] dom G /\ fv_co_co_co         g  [<=] dom G /\
      fv_tm_tm_constraint p1 [<=] dom G /\ fv_co_co_constraint p1 [<=] dom G /\
      fv_tm_tm_constraint p2 [<=] dom G /\ fv_co_co_constraint p2 [<=] dom G)
  /\
  (forall G D g A B (H : AnnDefEq G D g A B),
      fv_tm_tm_co g [<=] dom G /\ fv_co_co_co g [<=] dom G /\
      fv_tm_tm_tm A [<=] dom G /\ fv_co_co_tm A [<=] dom G /\
      fv_tm_tm_tm B [<=] dom G /\ fv_co_co_tm B [<=] dom G)
  /\
  (forall G (H : AnnCtx G),
      (forall x A,
          binds x (Tm A)   G ->
          fv_tm_tm_tm         A   [<=] dom G /\ fv_co_co_tm         A   [<=] dom G) /\
      (forall c phi,
          binds c (Co phi) G ->
          fv_tm_tm_constraint phi [<=] dom G /\ fv_co_co_constraint phi [<=] dom G)).

Definition AnnTyping_context_fv  := @first  _ _ _ _ _ ann_context_fv_mutual.
Definition AnnPropWff_context_fv := @second _ _ _ _ _ ann_context_fv_mutual.
Definition AnnIso_context_fv     := @third  _ _ _ _ _ ann_context_fv_mutual.
Definition AnnDefEq_context_fv   := @fourth _ _ _ _ _ ann_context_fv_mutual.
Definition AnnCtx_context_fv     := @fifth  _ _ _ _ _ ann_context_fv_mutual. *)



Module fc_dec_fun (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig) (unique: fc_unique_sig).



Module invert := fc_invert wf weak subst.

Module fuel := fc_dec_fuel wf weak subst unique.

Module aux := fc_dec_aux wf weak subst unique.

Module get := fc_get wf weak subst unique.



Import fuel aux unique wf subst invert get.



Unset Implicit Arguments.



Ltac obtacpre :=

  intros; simpl in *.



Ltac obtacsolve :=

  intros; simpl in *; try solve [ok].



Lemma An_IsoConv': ∀ (G : context) (D : available_props)

                     (a1 a2 A a1' a2' B : tm) phi1 phi2 (g : co),

  phi1 =  (Eq a1 a2 A)  →

  phi2 = (Eq a1' a2' B) →

  AnnDefEq G D g A B  →

  AnnPropWff G phi1 →

  AnnPropWff G phi2 →

  erase_tm a1 = erase_tm a1' →

  erase_tm a2 = erase_tm a2' →

  AnnIso G D (g_IsoConv phi1 phi2 g) phi1 phi2.

Proof.

  intros.

  subst phi1 phi2.

  eauto.

Qed.



Lemma get_tpg_correct' : ∀ {G : context} {a A : tm},

    AnnTyping G a A → A = get_tpg G a.

Proof.

  move => G a A tpg.

  by rewrite (@get_tpg_correct _ _ _(get_tpg G a) tpg _).

Defined.



Lemma get_deq_correct' : ∀ {G : context} {D : available_props} {g : co} {A B},

    AnnDefEq G D g A B → get_deq G g = (A, B).

Proof.

  move => G ? g A B deq.

  have eq: get_deq G g = (fst (get_deq G g), snd (get_deq G g)) by destruct (get_deq G g).

  by move: (@get_deq_correct _ _ _ _ _ (fst (get_deq G g)) (snd (get_deq G g)) deq eq) => [-> ->].

Defined.



Lemma get_iso_correct' : ∀ {G : context} {D : available_props} {g : co} {phi1 phi2 : constraint}, AnnIso G D g phi1 phi2 → get_iso G g = (phi1, phi2).

Proof.

  move => G ? g phi1 phi2 iso.

  have eq: get_iso G g = (fst (get_iso G g), snd (get_iso G g)) by destruct (get_iso G g).

  by move: (@get_iso_correct _ _ _ _ _ (fst (get_iso G g)) (snd (get_iso G g)) iso eq) => [-> ->].

Defined.



Ltac clear_annoying :=

  repeat match goal with

    | [H: <<_>> = _ |- _ ] => clear H

    | [H: <<_, _>> = _ |- _ ] => clear H

    | [H: !! = _ |- _ ] => clear H

    | [H: yeah = _ |- _ ] => clear H

    | [H: nope = _ |- _ ] => clear H

    | [ H :     !! = _     |- _ ] => clear H

    | [ H :     _ + { _ } |- _ ] => clear H

    | [ H : { _ } + { _ } |- _ ] => clear H

    | [ H : { _ | _} + { _ } |- _ ] => clear H

    | [ H : { _, _ | _} + { _ } |- _ ] => clear H

  end.



Ltac intro_uniq_full H :=

    match type of H with

      | AnnTyping ?G ?a ?A =>

        let x := fresh "u" in

        move : (@AnnTyping_unique G a A H) => x;

        

        repeat match goal with

          | [H' : AnnTyping G a ?A' |- _ ] =>  move: (x _ H') => ?; wrap_hyp H'

        end

      | AnnDefEq ?G ?L ?g ?A1 ?A2 =>

        let x := fresh "u" in

        move : (@AnnDefEq_unique G L g A1 A2 H) => x;

        

        repeat match goal with

          | [H' : AnnDefEq G L g ?A1' ?A2' |- _ ] =>  move: (x _ _ H') => ?; wrap_hyp H'

        end

      | AnnIso ?G ?L ?g ?phi1 ?phi2 =>

        let x := fresh "u" in

        move : (@AnnIso_unique G L g phi1 phi2 H) => x;

        

        repeat match goal with

          | [H' : AnnIso G L g ?phi1' ?phi2' |- _ ] =>  move: (x _ _ H') => ?; wrap_hyp H'

        end

    end.



Ltac auto_uniq_full :=

  revert_all_with intro_uniq_full; intros; pcess_hyps.



Ltac terminator := auto_uniq_full; subst_forall; subst; cbn; pcess_hyps;

  

  try solve [try econstructor; intuition (subst; eauto 3) | intuition (subst; eauto 3 with smart_cons_exists)].



Ltac hacky :=

  do 3 (

    intros;

    
  try(

  try (multimatch goal with

    | [ |- ¬ _ ] => let H := fresh in intro H; inversion H; terminator

    | _ => idtac

  end);

  try (multimatch goal with

    | [ H : ¬ _ |-  _ ] => solve [edestruct H; terminator]

    | [ H : forall _, ¬ _ |-  _ ] => solve [edestruct H; terminator]

    | [ H : forall _ _, ¬ _ |-  _ ] => solve [edestruct H; terminator]

  end); terminator)).



Ltac clearbodies :=

  repeat match goal with

    | [ H := _ : _ |- _] => clearbody H

  end.



Ltac clearbodies' :=

  repeat match goal with

    | [ x := ?bdy : _ |- _] =>

      move: (eq_refl x);

      rewrite -{2}[x]/bdy;

      clearbody x;

      let eqname := fresh "eq" x in

      move => eqname

  end.



Ltac clean_fun :=

  match goal with

    | [

        AnnTyping_dec : Tactics.fix_proto (∀ (G : context) (t : tm), fuel_tpg t → AnnCtx G → {T : tm | AnnTyping G t T} + {(∀ T : tm, ¬ AnnTyping G t T)}),

        AnnPropWff_dec : Tactics.fix_proto (∀ (G : context) (phi : constraint), fuel_pwf phi → AnnCtx G → {AnnPropWff G phi} + {¬ AnnPropWff G phi}),

        AnnDefEq_dec : Tactics.fix_proto (∀ (G : context) (S : available_props) (g : co), fuel_deq g → AnnCtx G → {A, B | AnnDefEq G S g A B} + {(∀ A B : tm, ¬ AnnDefEq G S g A B)}),

        AnnIso_dec : Tactics.fix_proto (∀ (G : context) (S : available_props) (g : co), fuel_iso g → AnnCtx G → {phi1, phi2 | AnnIso G S g phi1 phi2} + {(∀ phi1 phi2 : constraint, ¬ AnnIso G S g phi1 phi2)})

      |- _ ] => clear AnnTyping_dec AnnPropWff_dec AnnDefEq_dec AnnIso_dec

  end.



Ltac clear_sums :=

  repeat match goal with

    | [ H :     !! = _     |- _ ] => clear H

    | [ H :     _ + { _ } |- _ ] => clear H

    | [ H : { _ } + { _ } |- _ ] => clear H

  end.



Ltac cleanup_param cbodies sbst:=

  clear_annoying;

  intros; simpl in *;

  cbodies;

  try solve [ok];

  try clean_fun;

  clear_sums;

  sbst. 



Ltac cleanup := cleanup_param clearbodies subst.

Ltac cleanup' := cleanup_param clearbodies' idtac.



Obligation Tactic := try solve [hacky].



Program Definition AnnPropWff_dec' (G: context) (a b A : tm) (A' B': tm) (H : AnnCtx G)

                                  (pA: AnnTyping G a A') (pB: AnnTyping G b B') : {AnnPropWff G (Eq a b A)} + {¬ AnnPropWff G (Eq a b A)} :=

  tm_eq_dec A A' >-->

  tm_eq_dec (erase A) (erase B') >-->

  yeah.



Obligation Tactic := obtacpre; first [match goal with [|- tm] => idtac end | eassumption].



Program Fixpoint AnnTyping_dec (G : context) (t : tm) (fuel : fuel_tpg t) (H : AnnCtx G) {struct fuel} : {T : tm | AnnTyping G t T } + {(forall T, ¬ AnnTyping G t T)}  :=

  match fuel with

    | FT_Star =>  << a_Star >>



    | FT_Var_f x =>

      A <- binds_dec_tm x G;

      << A >>



    | FT_Pi rho A B fB fA =>

      let (x, p) := atom_fresh (dom G \u fv_tm_tm_tm B) in

      KA <- AnnTyping_dec G A fA _;

      tm_eq_dec KA a_Star >--->

      KB <- AnnTyping_dec ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) (fB x _) _;

      tm_eq_dec KB a_Star >--->

      << a_Star >>



    | FT_Abs rho a A fa fA =>

      

      let (x, p) := atom_fresh (dom G \u fv_tm_tm_tm a) in

      KA <- AnnTyping_dec G A fA _;

      tm_eq_dec KA a_Star >--->

      B <- AnnTyping_dec ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (fa x _) _;

      RhoCheck_erase_dec rho x (open_tm_wrt_tm a (a_Var_f x)) _ >--->

      << a_Pi rho A (close_tm_wrt_tm x B )>>



    | FT_App rho b a fb fa =>

      A <- AnnTyping_dec G a fa _;

      Tf <- AnnTyping_dec G b fb _;

      match Tf with

        | a_Pi rho' A' B =>

          tm_eq_dec A' A >--->

          rho_eq_dec rho rho' >---> << open_tm_wrt_tm B a >>

        | _ => !!

      end



    | FT_Conv a g fa fg =>

      A <- AnnTyping_dec G a fa _;

      A' & B <- AnnDefEq_dec G (dom G) g fg _;

      let K := get_tpg G B in

  

      tm_eq_dec K a_Star >--->

      tm_eq_dec A A' >--->

      << B >>



    | FT_CApp b g fb fg =>

      TB <- AnnTyping_dec G b fb _ ;

      A1' & A2' <- AnnDefEq_dec G (dom G) g fg _;

      match TB with

        | (a_CPi (Eq A1 A2 K) B) =>

          tm_eq_dec A1 A1' >--->

          tm_eq_dec A2 A2' >--->

          << open_tm_wrt_co B g >>

        | _ => !!

      end



    | FT_Const T =>

      K <- binds_dec_cs T an_toplevel;

      (@DataTy_Star_dec K) _ >--->

      << K >>



    | FT_CPi phi B fB fphi =>

      AnnPropWff_dec G phi fphi _ >--->

      let (c, p) := atom_fresh (dom G \u fv_co_co_tm B) in

      KB <- AnnTyping_dec ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) (fB c _) _;

      tm_eq_dec KB a_Star >--->

      << a_Star >>



    | FT_CAbs a phi fa fphi =>

      AnnPropWff_dec G phi fphi _ >--->

      let (c, p) := atom_fresh (dom G \u fv_co_co_constraint phi \u fv_co_co_tm a) in

      Bc <- AnnTyping_dec ((c ~ Co  phi ) ++  G) (open_tm_wrt_co a (g_Var_f c)) (fa c _) _;

      << a_CPi phi (close_tm_wrt_co c Bc) >>



    | FT_UAbs _ _ => !!

    | FT_UCAbs _  => !!

    | FT_Bullet   => !!



    | FT_Var_b _ => !!

  

    | FT_DataCon _ => !!

    | FT_Case _ _ => !!



    | FT_Fam F =>

      a & A <- binds_dec_ax F an_toplevel;

        << A >>

  end



with AnnPropWff_dec (G: context) (phi : constraint) (fuel : fuel_pwf phi)

                    (H : AnnCtx G) {struct fuel} : {AnnPropWff G phi} + {¬ AnnPropWff G phi} :=

  match fuel with

    | FP_fuel_pwf a b K fa fb =>

      Ka <-- AnnTyping_dec G a fa _;

      Kb <-- AnnTyping_dec G b fb _;

      tm_eq_dec K Ka >-->

      tm_eq_dec (erase K) (erase Kb) >--> yeah

  end



with AnnDefEq_dec (G: context) (S : available_props) (g : co) (fuel : fuel_deq g)

                  (H: AnnCtx G) {struct fuel} : {A, B | AnnDefEq G S g A B} + {(forall A B, ¬ AnnDefEq G S g A B)} :=

  match fuel with

    | FD_Assn c =>

        in_dec c S >--->

        AB & K <- binds_dec_co c G;

        << fst AB, snd AB >>



    | FD_Refl a fa =>

        A <- AnnTyping_dec G a fa _;

        <<a, a>>



    | FD_Refl2 a b g fa fb fg =>

        A <- AnnTyping_dec G a fa _;

        B <- AnnTyping_dec G b fb _;

        tm_eq_dec (erase_tm a) (erase_tm b) >--->

        A' & B' <- AnnDefEq_dec G (dom G) g fg _;

        tm_eq_dec A A' >--->

        tm_eq_dec B B' >--->

        << a, b >>



    | FD_Sym g fg =>

        b & a <- AnnDefEq_dec G S g fg _;

        << a, b >>



    | FD_Trans g1 g2 fg1 fg2 =>

        a & c <- AnnDefEq_dec G S g1 fg1 _;

        d & b <- AnnDefEq_dec G S g2 fg2 _;

        tm_eq_dec c d >--->

        << a, b >>



    | FD_Beta a1 a2 fa1 fa2 =>

        A1 <- AnnTyping_dec G a1 fa1 _;

        A2 <- AnnTyping_dec G a2 fa2 _;

        tm_eq_dec (erase_tm A1) (erase_tm A2) >--->

        @beta_dec (erase_tm a1) (erase_tm a2) _ >--->

        << a1, a2 >>



    | FD_PiCong rho g1 g2 fg1 fg2 =>

      A1 & A2 <- AnnDefEq_dec G S g1 fg1 _;

      tm_eq_dec (get_tpg G A1) a_Star >--->

      tm_eq_dec (get_tpg G A2) a_Star >--->

      let (x, _) := atom_fresh (dom G \u fv_tm_tm_co g1 \u fv_tm_tm_co g2) in

      B1x & B2x <- AnnDefEq_dec ([(x, Tm A1)] ++ G) S (open_co_wrt_tm g2 (a_Var_f x)) (fg2 x _) _;

      let B1  := close_tm_wrt_tm x B1x in

      let B2  := close_tm_wrt_tm x B2x in

      let B3x := tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2x in

      let B3  := close_tm_wrt_tm x B3x in

      

      tm_eq_dec (get_tpg ([(x, Tm A1)] ++ G) B1x) a_Star >--->

      tm_eq_dec (get_tpg ([(x, Tm A1)] ++ G) B2x) a_Star >--->

      tm_eq_dec (get_tpg ([(x, Tm A2)] ++ G) B3x) a_Star >--->

      << a_Pi rho A1 B1, a_Pi rho A2 B3 >>



    | FD_AbsCong rho g1 g2 fg1 fg2 =>

      A1 & A2 <- AnnDefEq_dec G S g1 fg1 _;

      tm_eq_dec (get_tpg G A1) a_Star >--->

      tm_eq_dec (get_tpg G A2) a_Star >--->

      let (x, p) := atom_fresh (dom G \u fv_tm_tm_co g1 \u fv_tm_tm_co g2) in

      B1x & B2x <- AnnDefEq_dec ([(x, Tm A1)] ++ G) S (open_co_wrt_tm g2 (a_Var_f x)) (fg2 x _) _;

      let B1 := close_tm_wrt_tm x B1x in

      let B2 := close_tm_wrt_tm x B2x in

      let B3x := tm_subst_tm_tm (a_Conv (a_Var_f x) (g_Sym g1)) x B2x in

      let B3  := close_tm_wrt_tm x B3x in

      

      RhoCheck_erase_dec rho x B1x _ >--->

      RhoCheck_erase_dec rho x B3x _ >--->

      

      << a_Abs rho A1 B1, a_Abs rho A2 B3 >>



    | FD_AppCong g1 g2 rho fg1 fg2 =>

      a1 & a2 <- AnnDefEq_dec G S g1 fg1 _;

      b1 & b2 <- AnnDefEq_dec G S g2 fg2 _;

      let Ta1 := get_tpg G a1 in

      let Ta2 := get_tpg G a2 in

      let Tb1 := get_tpg G b1 in

      let Tb2 := get_tpg G b2 in

      match Ta1, Ta2 with

        | a_Pi rho1 A1 _, a_Pi rho2 A2 _ =>

          tm_eq_dec A1 Tb1 >--->

          tm_eq_dec A2 Tb2 >--->

          rho_eq_dec rho rho1 >--->

          rho_eq_dec rho rho2 >--->

          << a_App a1 rho b1, a_App a2 rho b2 >>

        | _, _ => !!

      end



    | FD_CPiCong g1 g3 fg1 fg3 =>

        phi1 & phi2 <- AnnIso_dec G S g1 fg1 _;

        let (c, _) := atom_fresh (S \u dom G \u fv_co_co_co g1 \u fv_co_co_co g3) in

        B1c & B2c <- AnnDefEq_dec ([(c, Co phi1)] ++ G) S (open_co_wrt_co g3 (g_Var_f c)) (fg3 c _) _;

        let B1  := close_tm_wrt_co c B1c in

        let B2  := close_tm_wrt_co c B2c in

        let B3c := open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)) in

        let B3  := close_tm_wrt_co c (B3c) in

        tm_eq_dec (get_tpg ([(c,Co phi1)] ++ G) B1c) a_Star >--->

        tm_eq_dec (get_tpg ([(c,Co phi2)] ++ G) B3c) a_Star >--->

        tm_eq_dec (get_tpg ([(c,Co phi1)] ++ G) B2c) a_Star >--->

        << a_CPi phi1 B1, a_CPi phi2 B3 >>



    | FD_CAbsCong g1 g3 g4 fg1 fg3 fg4 =>

        phi1 & phi2 <- AnnIso_dec G S g1 fg1 _;

        let (c, _) := atom_fresh (S \u dom G \u fv_co_co_co g1 \u fv_co_co_co g3) in

        a1c & a2c <- AnnDefEq_dec ([(c, Co phi1)] ++ G) S (open_co_wrt_co g3 (g_Var_f c)) (fg3 c _) _;

        let a1  := close_tm_wrt_co c a1c in

        let a2  := close_tm_wrt_co c a2c in

        let a3c := open_tm_wrt_co a2 (g_Cast (g_Var_f c) (g_Sym g1)) in

        let a3  := close_tm_wrt_co c a3c in

        let B1c := get_tpg ([(c, Co phi1)] ++ G) a1c in

        let B3c := get_tpg ([(c, Co phi2)] ++ G) a3c in

        CPi1 & CPi2 <- AnnDefEq_dec G (dom G) g4 fg4 _;

        tm_eq_dec CPi1 (a_CPi phi1 (close_tm_wrt_co c B1c)) >--->

        tm_eq_dec CPi2 (a_CPi phi2 (close_tm_wrt_co c B3c)) >--->

        << a_CAbs phi1 a1, a_CAbs phi2 a3 >>



    | FD_CAppCong g1 g2 g3 fg1 fg2 fg3 =>

      a1 & a2 <- AnnDefEq_dec G S g1 fg1 _;

      b1 & b2 <- AnnDefEq_dec G (dom G) g2 fg2 _;

      c1 & c2 <- AnnDefEq_dec G (dom G) g3 fg3 _;

      let Ta1 := get_tpg G a1 in

      let Ta2 := get_tpg G a2 in

      match Ta1, Ta2 with

        | a_CPi (Eq Ta11 Ta12 _) _, a_CPi (Eq Ta21 Ta22 _) _ =>

          

          tm_eq_dec Ta11 b1 >--->

          tm_eq_dec Ta12 b2 >--->

          tm_eq_dec Ta21 c1 >--->

          tm_eq_dec Ta22 c2 >--->

          << a_CApp a1 g2, a_CApp a2 g3 >>

        | _, _ => !!

      end



    | FD_CPiSnd g1 g2 g3 fg1 fg2 fg3 =>

      a1 & a2 <- AnnDefEq_dec G S g1 fg1 _;

      a & a' <- AnnDefEq_dec G (dom G) g2 fg2 _;

      b & b' <- AnnDefEq_dec G (dom G) g3 fg3 _;

      match a1, a2 with

        | a_CPi (Eq a_ a_' _) B1, a_CPi (Eq b_ b_' _) B2 =>

          tm_eq_dec a  a_  >--->

          tm_eq_dec a' a_' >--->

          tm_eq_dec b  b_  >--->

          tm_eq_dec b' b_' >--->

          << open_tm_wrt_co B1 g2, open_tm_wrt_co B2 g3 >>

        | _, _ => !!

      end



    | FD_Cast g1 g2 fg1 fg2 =>

      a & a' <- AnnDefEq_dec G S g1 fg1 _;

      phi1 & phi2 <- AnnIso_dec G S g2 fg2 _;

      match phi1, phi2 with

        | Eq a_ a'_ _, Eq b b' _ =>

          tm_eq_dec a  a_  >--->

          tm_eq_dec a' a'_ >--->

          << b, b' >>

      end



    | FD_PiFst g fg =>

      T1 & T2 <- AnnDefEq_dec G S g fg _;

      match T1, T2 with

        | a_Pi rho1 A1 B1, a_Pi rho2 A2 B2 => rho_eq_dec rho1 rho2 >---> << A1, A2 >>

        | _, _ => !!

      end



    | FD_PiSnd g1 g2 fg1 fg2 =>

        T1 & T2 <- AnnDefEq_dec G S g1 fg1 _;

        a1 & a2 <- AnnDefEq_dec G S g2 fg2 _;

     
        let A1 := get_tpg G a1 in

        let A2 := get_tpg G a2 in

        match T1 with

          | a_Pi rho A1' B1 =>

            tm_eq_dec A1 A1' >--->

            match T2 with

              | a_Pi rho' A2' B2 =>

                tm_eq_dec A2 A2' >--->

                rho_eq_dec rho rho' >--->

                << open_tm_wrt_tm B1 a1, open_tm_wrt_tm B2 a2 >>

              | _ => !!

            end

          | _ => !!

        end



    | FD_IsoSnd g fg =>

      phi1 & phi2 <- AnnIso_dec G S g fg _;

      match phi1, phi2 with

        | (Eq _ _ A), (Eq _ _ B) => << A, B>>

      end



    | FD_Eta b fb =>

      let (x, p) := atom_fresh (dom G \u fv_tm_tm_tm b) in

      T <- AnnTyping_dec G b fb _;

      match T with

      | a_Pi Rel A B =>

        << a_Abs Rel A (close_tm_wrt_tm x (a_App b Rel (a_Var_f x))), b >>

      | a_Pi Irrel A B =>

        << a_Abs Irrel A (close_tm_wrt_tm x (a_App b Irrel (a_Var_f x))), b >>

      | a_CPi phi B =>

        << a_CAbs phi (close_tm_wrt_co x (a_CApp b (g_Var_f x))), b >>

      | _ => !!

      end



    | FD_Left g1  g2 fg1 fg2  => !!

    | FD_Right _ _ _ _ => !!



    | FD_Triv          => !!

    | FD_Var_b _       => !!

    | FD_CPiFst _      => !!

    | FD_Cong _ _ _    => !!

    | FD_IsoConv _ _ _ => !!



  end



with AnnIso_dec (G: context) (S : available_props) (g : co) (fuel : fuel_iso g)

                (H: AnnCtx G) {struct fuel} : {phi1, phi2 | AnnIso G S g phi1 phi2} + {(forall phi1 phi2, ¬ AnnIso G S g phi1 phi2)} :=

  match fuel with

    | FI_Cong g1 A g2 fg1 fg2 =>

      A1 & A2 <- AnnDefEq_dec G S g1 fg1 _;

      B1 & B2 <- AnnDefEq_dec G S g2 fg2 _;

      AnnPropWff_dec' G A1 B1 A (get_tpg G A1) (get_tpg G B1) _ _ _ >--->

      AnnPropWff_dec' G A2 B2 A (get_tpg G A2) (get_tpg G B2) _ _ _ >--->

      << Eq A1 B1 A, Eq A2 B2 A >>



    | FI_CPiFst g fg =>

      pi1 & pi2 <- AnnDefEq_dec G S g fg _;

      match pi1, pi2 with

        | a_CPi phi1 _, a_CPi phi2 _ =>

          << phi1, phi2 >>

        | _, _ => !!

      end



    | FI_IsoSym g fg =>

      phi2 & phi1 <- AnnIso_dec G S g fg _;

      << phi1, phi2 >>



    | FI_IsoConv g phi1 phi2 fg fpwf1 fpwf2  =>

      A' & B' <- AnnDefEq_dec G S g fg _;

      AnnPropWff_dec G phi1 fpwf1 _ >--->

      AnnPropWff_dec G phi2 fpwf2 _ >--->

      match phi1, phi2 with

        | Eq a1 a2 A, Eq a1' a2' B =>

          tm_eq_dec (erase_tm  a1) (erase_tm  a1') >--->

          tm_eq_dec (erase_tm  a2) (erase_tm  a2') >--->

          tm_eq_dec A A' >--->

          tm_eq_dec B B' >--->

          << phi1, phi2 >>

      end



    | FI_Var_f c => !!

    | FI_Var_b _ => !!

    | FI_Refl a => !!

    | FI_Refl2 a b g => !!

    | FI_Trans g1 g2 =>  !!

    | FI_Beta a1 a2 => !!

    | FI_PiCong rho g1 g2 => !!

    | FI_AbsCong _ _ _ => !!

    | FI_AppCong g1 rho g2 => !!

    | FI_CAbsCong _ _ _ => !!

    | FI_CAppCong g1 g2 g3 => !!

    | FI_PiFst g => !!

    | FI_Cast g1 g2 => !!

    | FI_PiSnd g1 g2 => !!

    | FI_Triv => !!

    | FI_CPiCong _ _ => !!

    | FI_CPiSnd _ _ _ => !!

    | FI_IsoSnd _ => !!

    | FI_Eta _ => !!

    | FI_Left _ _ => !!

    | FI_Right _ _ => !!

  end



.



Obligation Tactic :=

  obtacsolve.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

Defined.

Next Obligation.

  hacky.

Defined.



Next Obligation.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

Defined.



Next Obligation.

  hacky.

Defined.



Obligation Tactic := obtacpre.



Next Obligation.

  eauto using An_Sym2.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  subst.

  eauto using An_Trans2.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  move: lc_erase => [h0 _].

  eapply h0.

  move: (AnnTyping_lc wildcard'0) => [h1 _].

  auto.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup.

Defined.



  Ltac reg H :=

  match type of H with

    | AnnTyping _ ?a ?A =>

      first

        [ let tpgA := fresh "tpg" A in move: (AnnTyping_regularity H) => tpgA

        | let tpgA := fresh "tpg"   in move: (AnnTyping_regularity H) => tpgA]

    | AnnDefEq _ _ ?g ?A ?B =>

      let KA := fresh "K" A in

      let KB := fresh "K" B in

      let g' := fresh "g" in

      let tpgA := fresh "tpg" A in

      let tpgB := fresh "tpg" B in

      

      move: (AnnDefEq_regularity H) => [KA [KB [g' [tpgA [tpgB  _]]]]]

    
    | AnnDefEq _ _ ?g ?A ?B =>

      let KA := fresh "K" in

      let KB := fresh "K" in

      let g' := fresh "g" in

      let tpgA := fresh "tpg" in

      let tpgB := fresh "tpg" in

      

      move: (AnnDefEq_regularity H) => [KA [KB [g' [tpgA [tpgB  _]]]]]



    | AnnIso _ _ ?g ?phi1 ?phi2 =>

      let pwfp1 := fresh "pwf" phi1 in

      let pwfp2 := fresh "pwf" phi2 in

      move: (AnnIso_regularity H) => [pwfp1 pwfp2]

  end.



Ltac cleanup_getcor :=

  repeat match goal with

    | [ _: get_tpg _ _ = get_tpg _ _ |- _ ] => fail

    | [ eq: _ = get_tpg _ _ |- _ ] => symmetry in eq

  end.



Ltac getcor a :=

  cleanup_getcor;

  match goal with

    | [ eq: get_tpg ?G a = _,

        tpg : AnnTyping ?G a ?A |- _ ] =>

          let t := fresh tpg in

          move: (get_tpg_correct tpg eq) => t; subst A

  end.



Ltac autoreg :=

  repeat match goal with

    | [ H: AnnDefEq _ _ _ _ _ |- _ ] =>

      reg H; wrap_hyp H

    | [ H: AnnIso _ _ _ _ _ |- _ ] =>

      reg H; wrap_hyp H

  end;

  pcess_hyps.



Ltac clearget :=

  cleanup_getcor;

  repeat match goal with

    | [ H: get_tpg _ _ = get_tpg _ _ |- _ ] => fail

    | [ eqTa : get_tpg ?G ?a = ?Ta,

        tpga : AnnTyping ?G ?a ?Ta' |- _ ] =>

      let eq := fresh in

      

      move:(get_tpg_correct' tpga); move=> eq; rewrite <- eq in *; clear eq; subst Ta'

  end.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup.

  inversion 1.

  auto_uniq_full.

  apply wildcard'.

  have: A0 = A1 by done. move => <-.

  inversion H9.

  by move: (get_tpg_correct' H21) => <-.

Defined.

Next Obligation.

  cleanup.

  inversion 1.

  auto_uniq_full.

  apply wildcard'.

  have: A3 = A2 by done. move => <-.

  inversion H12.

  by move: (get_tpg_correct' H21) => <-.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation. 

  econstructor; try eassumption.

  - cleanup.

    reg wildcard'0.

    by getcor A1.

  - fsetdec.

Defined.

Next Obligation.

  cleanup.

  move /An_PiCong_inversion.

  move => [a1 [b1 [a2 [b2 [b3 [eqA [eqB [tpg1 [tpg2 [tpg3 [defeq h]]]]]]]]]]].

  apply: wildcard'.

  have xnotin: x `notin` dom G by fsetdec.

  move: (h _ xnotin) => [h' _].

  auto_uniq_full; subst.

  by apply: h'.

Defined.

Next Obligation.

  cleanup'.

  move /An_PiCong_inversion.

  move => [a1 [b1 [a2 [b2 [b3 [eqA [eqB [tpg1 [tpg2 [tpg3 [defeq h]]]]]]]]]]].

  eapply wildcard'.

  have xG: x `notin` dom G by fsetdec.

  move: (h _ xG) => /= [h' _].

  have: A1 = a1 by cleanup; auto_uniq_full. move => ?; subst A1.

  auto_uniq_full.

  move: (An_Pi_inversion tpg1) => [_ [_]] /(_ _ xG).

  by move: (u3 _ _ wildcard'3) => [<- _] => /(get_tpg_correct') ->.

Defined.

Next Obligation.

  cleanup'.

  move /An_PiCong_inversion.

  move => [a1 [b1 [a2 [b2 [b3 [eqA [eqB [tpg1 [tpg2 [tpg3 [defeq h]]]]]]]]]]].

  eapply wildcard'.

  have xG: x `notin` dom G by fsetdec.

  move: (h _ xG) => /= [h' _].

  have: A1 = a1 by cleanup; auto_uniq_full. move => ?; subst A1.

  clearbodies'.

  auto_uniq_full.

  move: (An_Pi_inversion tpg3) => [_ [_]] /(_ _ xG).

  by move: (u3 _ _ wildcard'3) => [_ <-] => /(get_tpg_correct') ->.

Defined.

Next Obligation.

  cleanup'.

  move /An_PiCong_inversion.

  move => [a1 [b1 [a2 [b2 [b3 [eqA [eqB [tpg1 [tpg2 [tpg3 [defeq h]]]]]]]]]]].

  eapply wildcard'.

  have xG: x `notin` dom G by fsetdec.

  move: (h _ xG) => /= [h' eqb3].

  have: A1 = a1 by cleanup; auto_uniq_full. move => ?; subst A1.

  have: A2 = a2 by cleanup; auto_uniq_full. move => ?; subst A2.

  clearbodies'.

  auto_uniq_full.

  move: (An_Pi_inversion tpg2) => [_ [_]] /(_ _ xG).

  have realeq : B3x = open_tm_wrt_tm B2 (a_Conv (a_Var_f x) (g_Sym g1)) by rewrite eqB3x eqB2 tm_subst_tm_tm_spec.

  move: realeq eqb3 eqB2 H2 => -> -> -> <-. rewrite close_tm_wrt_tm_open_tm_wrt_tm.

  - by move => /(get_tpg_correct') ->.

  -  

    move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _  tpg3) /= [htmco [hcoco [htmtm hcotm ] ] ].

    by fsetdec.

Defined.

Next Obligation.

  cleanup'.

  rewrite eqB1 eqB3.

  eapply An_PiCong_exists3 with (x := x); try eassumption.

  fsetdec.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup.

  move /An_AbsCong_inversion => [a1' [a2' [b1' [b2' [b3' [B' h]]]]]].

  move: h => [eqA [eqB [tpga1' [tpga2' [defg1 [tpga1b2' h]]]]]].

  apply: wildcard'.

  have: A1 = a1' by auto_uniq_full.

  move=> ->.

  by rewrite (get_tpg_correct' tpga1').

Defined.

Next Obligation.

  cleanup.

  move /An_AbsCong_inversion => [a1' [a2' [b1' [b2' [b3' [B' h]]]]]].

  move: h => [eqA [eqB [tpga1' [tpga2' [defg1 [tpga1b2' h]]]]]].

  apply: wildcard'.

  have: A2 = a2' by auto_uniq_full.

  move=> ->.

  by rewrite (get_tpg_correct' tpga2').

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation. 

  econstructor; try eassumption.

  - cleanup.

    reg wildcard'0.

    by getcor A1.

  - fsetdec.

Defined.

Next Obligation.

  cleanup.

  move /An_AbsCong_inversion => [a1' [a2' [b1' [b2' [b3' [B' h]]]]]].

  move: h => [eqA [eqB [tpga1' [tpga2' [defg1 [tpga1b2' h]]]]]].

  apply: wildcard'.

  auto_uniq_full.

  have: A1 = a1' /\ A2 = a2' by split; congruence.

  move=> [? ?]. subst A1 A2.

  have xG: x `notin` dom G by fsetdec.

  move: (h x xG) => [tpgg2 [_ [h' _] ] ].

  eassumption.

Defined.

Next Obligation.

  by move: (wf.AnnDefEq_lc1 wildcard').

Defined.

Next Obligation.

  cleanup.

  move /An_AbsCong_inversion => [a1' [a2' [b1' [b2' [b3' [B' h]]]]]].

  move: h => [eqA [eqB [tpga1' [tpga2' [defg1 [tpga1b2' h]]]]]].

  have p': x `notin` dom G by fsetdec.

  move: (h x p') => [tpgg2 [_ [h' _] ] ].

  apply wildcard'.

  suff eq: B1x = open_tm_wrt_tm b1' (a_Var_f x) by rewrite eq.

  auto_uniq_full.

  move: (u2 _ _ wildcard'0) => [eqA1 _].

  rewrite eqA1 in tpgg2.

  by move: (u _ _ tpgg2) => [->].

Defined.

Next Obligation.

  cleanup'.

  move: (wf.AnnDefEq_lc2 wildcard'3).

  rewrite eqB3x => ?.

  apply: tm_subst_tm_tm_lc_tm => /=.

  + done.

  + apply lc_a_Conv.

    - done.

    - move: (wf.AnnDefEq_lc3 wildcard'0) => ?.

      econstructor; eassumption.

Defined.

Next Obligation.

  clear dependent filtered_var.

  cleanup'.

  move=> tpgg1g2. move: (tpgg1g2).

  move /An_AbsCong_inversion => [a1' [a2' [b1' [b2' [b3' [B' h]]]]]].

  move: h => [eqA [eqB [tpga1' [tpga2' [defg1 [tpga1b2' h]]]]]].

  apply wildcard'.

  have p': x `notin` dom G by fsetdec.

  move: (h x p') => [tpgg2 [eqb3' [_ h'] ] ].

  suff eq: B3x = open_tm_wrt_tm b3' (a_Var_f x) by rewrite eq.

  auto_uniq_full.

  have: A1 = a1' /\ A2 = a2' by split; congruence.

  move=> [? ?]. subst A1 A2.

  rewrite eqB3x.

  move: (u5 _ _ wildcard'3) => [_ eqb2'].

  rewrite -eqb2' eqb3' tm_subst_tm_tm_spec close_tm_wrt_tm_open_tm_wrt_tm.

  - done.

  - 

    move: ann_context_fv_mutual => [h''' [_ [_ [_ _] ] ] ]; move: h''' => /(_ _ _ _ tpga1b2') /= [htmco'' [hcoco'' [htmtm'' hcotm'' ] ] ].

    by fsetdec.

Defined.

Next Obligation.

  clear dependent filtered_var.

  cleanup'.

  rewrite eqB1 eqB3.

  eapply An_AbsCong_exists3; try eassumption.

  - fsetdec.

  - reflexivity.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  inversion 1.

  apply wildcard'.

  reg wildcard'2.

  reg wildcard'1.

  getcor a1.

  getcor b1.

  subst Ta1 Tb1.

  auto_uniq_full.

  intro_uniq_full wildcard'2. 

  intro_uniq_full wildcard'1. 

  have: a0 = a1 by congruence => [-> _].

  move=> ?.

  subst a0. subst a3.

  inversion H8.

  intro_uniq_full H19. 

  have: A1 = A3 by congruence. move => ->.

  by move: (get_tpg_correct' H21).

Defined.

Next Obligation.

  cleanup'.

  inversion 1.

  apply wildcard'.

  reg wildcard'2.

  reg wildcard'1.

  getcor a2.

  getcor b2.

  subst Ta2 Tb2.

  auto_uniq_full.

  intro_uniq_full wildcard'2. 

  intro_uniq_full wildcard'1. 

  have: a0 = a1 by congruence => [-> _].

  move=> ?.

  subst b0. subst b2.

  inversion H11.

  intro_uniq_full H20. 

  have: A2 = A3 by congruence. move => ->.

  by move: (get_tpg_correct' H21).

Defined.

Next Obligation.

  cleanup'.

  cleanup_getcor.

  autoreg.

  clearget.

  inversion 1. inversion H8.

  apply: wildcard'.

  auto_uniq_full. subst a0.

  move: (u9 _ tpga1).

  congruence.

Defined.

Next Obligation.

  cleanup'.

  cleanup_getcor.

  autoreg.

  clearget.

  inversion 1. inversion H11.

  apply: wildcard'.

  auto_uniq_full. subst b0.

  move: (u9 _ tpga2).

  congruence.

Defined.

Next Obligation.

  

  clear dependent filtered_var.

  clear dependent filtered_var1.

  clear dependent filtered_var0.

  clear dependent filtered_var2.

  clear dependent filtered_var4.

  clear dependent filtered_var3. subst. clear dependent fuel.

  clean_fun. clearbodies'.



  autoreg.

  clearget.

  auto_uniq_full.

  eapply An_AppCong2; try eassumption.

  all: econstructor;

  eauto using An_AppCong2.

  subst Ta1. eassumption.

  subst Ta2. eassumption.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  hacky.

Defined.



Ltac discr_pat_match :=

  solve [obtacpre; solve [ let eq1 := fresh in let eq2 := fresh in move=> [eq1 eq2]; try discriminate eq1; discriminate eq2

                         | subst; inversion 1 ] ].



Solve Obligations of AnnDefEq_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation.

  econstructor.

  - eassumption.

  - cleanup'. by autoreg.

  - fsetdec.

Defined.

Next Obligation.

  cleanup.

  move /An_CPiCong_inversion.

  move => [ph1 [ph2 [b1 [b2 [b3 [eqA [eqB [isoph1 [tpgp1 [tpgp2 [tpg3 h]]]]]]]]]]].

  apply: wildcard'.

  have cG: c `notin` dom G by ok.

  move: (h _ cG) => /= [h' _].

  auto_uniq_full; subst.

  by apply: h'.

Defined.

Next Obligation.

  cleanup'.

  pcess_hyps.

  move /An_CPiCong_inversion.

  move => [ph1 [ph2 [b1 [b2 [b3 [eqA [eqB [isoph1 [tpgp1 [tpgp2 [tpg3 h]]]]]]]]]]].

  apply: wildcard'.

  auto_uniq_full.

  have cG: c `notin` dom G by ok.

  have: phi1 = ph1 by congruence. move=> eqphi. rewrite eqphi.

  move: (An_CPi_inversion tpgp1). do 2 move=> [_]. move => /(_ c cG) h'.

  move: (get_tpg_correct' h') => ->.

  suff: B1c = (open_tm_wrt_co b1 (g_Var_f c)) by move=> ->.

  move: (h _ cG) => /= [h'' _].

  auto_uniq_full.

  

  move: ann_context_fv_mutual => [h''' [_ [_ [_ _] ] ] ]; move: h''' => /(_ _ _ _ tpgp1) /= [? [? [? ?]]].

  rewrite eqphi in wildcard'1.

  by move:  (u10 _ _ wildcard'1) => [<- _].

Defined.

Next Obligation.

  cleanup'.

  move /An_CPiCong_inversion.

  move => [ph1 [ph2 [b1 [b2 [b3 [eqA [eqB [isoph1 [tpgp1 [tpgp2 [tpg3 h]]]]]]]]]]].

  apply: wildcard'.

  auto_uniq_full.

  have cG: c `notin` dom G by ok.

  have: phi1 = ph1 by congruence. move=> eqph1.

  have: phi2 = ph2 by congruence. move=> eqph2. rewrite eqph2.

  move: (An_CPi_inversion tpgp2). do 2 move=> [_]. move => /(_ c cG) h'.

  move: (get_tpg_correct' h') => ->.

  suff: B3c = (open_tm_wrt_co b3 (g_Var_f c)) by move=> ->.

  move: (h _ cG) => /= [h'' eqb3].

  auto_uniq_full.

  

  move: ann_context_fv_mutual => [h''' [_ [_ [_ _] ] ] ]; move: h''' => /(_ _ _ _ tpg3) /= [? [? [? ?]]].

  rewrite eqph1 in wildcard'2.

  rewrite eqB3c eqB2 eqb3.

  subst phi1.

  move:  (u10 _ _ wildcard'1) => [_ <-].

  rewrite close_tm_wrt_co_open_tm_wrt_co; by [|fsetdec].

Defined.

Next Obligation.

  cleanup'.

  move /An_CPiCong_inversion.

  move => [ph1 [ph2 [b1 [b2 [b3 [eqA [eqB [isoph1 [tpgp1 [tpgp2 [tpg3 h]]]]]]]]]]].

  apply: wildcard'.

  auto_uniq_full.

  have cG: c `notin` dom G by ok.

  have: phi1 = ph1 by congruence. move=> eqph1.

  have: phi2 = ph2 by congruence. move=> eqph2. rewrite eqph1.

  move: (An_CPi_inversion tpg3). do 2 move=> [_]. move => /(_ c cG) h'.

  move: (get_tpg_correct' h') => ->.

  suff: B2c = (open_tm_wrt_co b2 (g_Var_f c)) by move=> ->.

  move: (h _ cG) => /= [h'' eqb3].

  auto_uniq_full.

  

  move: ann_context_fv_mutual => [h''' [_ [_ [_ _] ] ] ]; move: h''' => /(_ _ _ _ tpg3) /= [? [? [? ?]]].

  rewrite eqph1 in wildcard'2.

  subst ph1.

  by move:  (u10 _ _ wildcard'1) => [_ <-].

Defined.

Next Obligation.

  cleanup'.

  

  move: ann_context_fv_mutual => [_ [_ [_ [h''' _] ] ] ]; move: h''' => /(_ _ _ _  _ _ wildcard'1) /= [? [? [? ?]]].

  autoreg.

  rewrite eqB1 eqB3.

  eapply An_CPiCong_exists_3 with (c := c) (B2 := B2c);

    try eassumption.

  - fsetdec.

  - move: co_subst_co_tm_spec. congruence.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation. 

  cleanup'.

  autoreg.

  econstructor; try eassumption.

  fsetdec.

Defined.

Next Obligation.

  cleanup.

  move /An_CAbsCong_inversion.

  move => [ph1 [ph2 [a1' [a2' [a3' [B1' [B2' [B3' [eqA [eqB [isoph12 [tpg1 [tpg2 [tpg3 [defeq4 h]]]]]]]]]]]]]]].

  have cG: c `notin` dom G by ok.

  move: (h _ cG) => /= [defeq3 eq23].

  apply: wildcard'.

  auto_uniq_full; subst.

  by apply: defeq3.

Defined.

Next Obligation.

  eassumption.

Defined.

Next Obligation.

  cleanup_param clearbodies' idtac.

  move /An_CAbsCong_inversion.

  move => [ph1 [ph2 [a1' [a2' [a3' [B1' [B2' [B3' [eqA [eqB [isoph12 [tpg1 [tpg2 [tpg3 [defeq4 h]]]]]]]]]]]]]]].

  

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg1) /= [? [? [? ?] ] ].

  have cG: c `notin` dom G by ok.

  move: (h _ cG) => /= [defeq3 eq23].

  apply: wildcard'.

  auto_uniq_full. 

  have eqphi1: phi1 = ph1 by move: (u0 _ _ wildcard'0) => [-> _].

  suff: a1 = a1' by move: (eqphi1) => [-> ->]; eassumption.

  rewrite eqphi1 in wildcard'1.

  move: (eqa1) (u5 _ _ wildcard'1) close_tm_wrt_co_open_tm_wrt_co => -> [<- _] ->; ok.

Defined.

Next Obligation.

  cleanup'.

  move /An_CAbsCong_inversion.

  move => [ph1 [ph2 [a1' [a2' [a3' [B1' [B2' [B3' [eqA [eqB [isoph12 [tpg1 [tpg2 [tpg3 [defeq4 h]]]]]]]]]]]]]]].

  

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg1) /= [? [? [? ?] ] ].

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg2) /= [? [? [? ?] ] ].

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg3) /= [? [? [? ?] ] ].

  have cG: c `notin` dom G by ok.

  move: (h _ cG) => /= [defeq3 eq23].

  apply: wildcard'.

  auto_uniq_full. 

  have [eqphi1 eqphi2] : phi1 = ph1 /\ phi2 = ph2 by move: (u0 _ _ wildcard'0) => [-> ->]. subst ph1 ph2.



  subst CPi1.

  have: a1 = a1' by move: eqa1 (u _ _ defeq3) => -> [-> _]; autorewrite with lngen.

  intros; subst a1'.

  rewrite eqB1c.

  move: (An_CAbs_inversion tpg1) => [B0 [tmp h'']]. injection tmp.

  intros; subst B0.

  move: (h'' c cG) => [_ tpga1].

  move: (get_tpg_correct' tpga1).

  rewrite eqa1. autorewrite with lngen.

  move=> <-.

  by autorewrite with lngen.

Defined.

Next Obligation.

  cleanup'.

  move /An_CAbsCong_inversion.

  move => [ph1 [ph2 [a1' [a2' [a3' [B1' [B2' [B3' [eqA [eqB [isoph12 [tpg1 [tpg2 [tpg3 [defeq4 h]]]]]]]]]]]]]]].

  

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg1) /= [? [? [? ?] ] ].

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg2) /= [? [? [? ?] ] ].

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ tpg3) /= [? [? [? ?] ] ].

  have cG: c `notin` dom G by ok.

  move: (h _ cG) => /= [defeq3 eq23].

  apply: wildcard'.

  auto_uniq_full. 

  have [eqphi1 eqphi2] : phi1 = ph1 /\ phi2 = ph2 by move: (u0 _ _ wildcard'0) => [-> ->]. subst ph1 ph2.



  subst CPi2.

  have: a2 = a2' by move: eqa2 (u _ _ defeq3) => -> [_ ->]; autorewrite with lngen.

  intros; subst a2'.

  have: a3 = a3' by rewrite eqa3 eqa3c -eq23; autorewrite with lngen.

  intros; subst a3'.

  rewrite eqB3c.

  move: (An_CAbs_inversion tpg2) => [B0 [tmp h'']]. injection tmp.

  intros; subst B0.

  move: (h'' c cG) => [_ tpga2].

  move: (get_tpg_correct' tpga2).

  rewrite eqa3. autorewrite with lngen.

  move=> <-.

  by autorewrite with lngen.

Defined.

Next Obligation.

  cleanup'.

  

  move: ann_context_fv_mutual => [_ [_ [_ [h''' _]]]]; move: h''' => /(_ _ _ _  _ _ wildcard'2) /= [? [? [? ?]]].

  rewrite eqa1 eqa3.

  autoreg.

  

  eapply An_CAbsCong_exists3 with (c := c) (a2 := a2c) (B1 := B1c) (B3 := B3c); try eassumption; try congruence.

  - fsetdec.

  - rewrite co_subst_co_tm_spec.

    congruence.

  - by rewrite eqB1c.

  - by rewrite eqB3c.

Defined.

Next Obligation.

  hacky.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  subst Ta1 Ta2.



  inversion 1.

  have: a0 = a1 /\ b0 = a2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a0 b0; clear H4.

  have: a3 = b1 /\ b3 = b2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a3 b3; clear H5.



  apply wildcard'.

  inversion H9.

  have: Ta11 = a0 by auto_uniq_full; congruence.

  move=> ?; subst a0.

  by auto_uniq_full.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  subst Ta1 Ta2.



  inversion 1.

  have: a0 = a1 /\ b0 = a2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a0 b0; clear H4.

  have: a3 = b1 /\ b3 = b2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a3 b3; clear H5.



  apply wildcard'.

  inversion H9.

  have: Ta12 = b2 by auto_uniq_full; congruence.

  move=> ?; subst b2.

  by auto_uniq_full.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  subst Ta1 Ta2.



  inversion 1.

  have: a0 = a1 /\ b0 = a2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a0 b0; clear H4.

  have: a3 = b1 /\ b3 = b2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a3 b3; clear H5.



  apply wildcard'.

  inversion H12.

  have: Ta21 = c1 by auto_uniq_full; congruence.

  move=> ?; subst c1.

  by auto_uniq_full.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  subst Ta1 Ta2.



  inversion 1.

  have: a0 = a1 /\ b0 = a2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a0 b0; clear H4.

  have: a3 = b1 /\ b3 = b2 by auto_uniq_full; split; congruence.

  move=> [? ?]; subst a3 b3; clear H5.



  apply wildcard'.

  inversion H12.

  have: Ta22 = c2 by auto_uniq_full; congruence.

  move=> ?; subst c2.

  by auto_uniq_full.

Defined.

Next Obligation.

  

  clear dependent filtered_var.

  clear dependent filtered_var2.

  clear dependent filtered_var1.

  clear dependent filtered_var0.

  clear dependent filtered_var4.

  clear dependent filtered_var3. subst. clear dependent fuel.

  clean_fun. clearbodies'.



  autoreg.

  clearget.

  subst.



  apply: An_CAppCong2;

    try econstructor; eassumption.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  hacky.

Defined.



Solve Obligations of AnnDefEq_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Solve Obligations of AnnDefEq_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Solve Obligations of AnnDefEq_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  apply: An_PiSnd;

    subst; eauto.

Defined.

Next Obligation.

  hacky.

Defined.



Solve Obligations of AnnDefEq_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.



Solve Obligations of AnnDefEq_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  eapply An_Eta with (L := dom G)(B := B).

  subst. auto.

  intros.

  rewrite -tm_subst_tm_tm_spec.

  simpl. destruct eq_dec; try done.

  rewrite tm_subst_tm_tm_fresh_eq. auto.

  auto.

Defined. 

Next Obligation.

  eapply An_Eta with (L := dom G)(B := B).

  subst. auto.

  intros.

  rewrite -tm_subst_tm_tm_spec.

  simpl. edestruct eq_dec; try done.

  rewrite tm_subst_tm_tm_fresh_eq. auto.

  auto.

Defined.

Next Obligation. 

  eapply An_EtaC with (L := dom G).

  subst. eapply wildcard'.

  intros.

  rewrite -co_subst_co_tm_spec.

  simpl. edestruct eq_dec; try done.

  rewrite co_subst_co_tm_fresh_eq. auto.

  move: (AnnTyping_context_fv wildcard') => h0.

  fsetdec.

Defined. 

Next Obligation.

  cleanup. inversion 1; subst;

  inversion H0; clear H0;

  inversion H4; clear H4.

  destruct rho.

  move: (H5 A0 B0) => h0.

  destruct h0.

  eapply AnnTyping_unique. eauto. eauto.

  move: (H2 A0 B0) => h0.

  destruct h0.

  eapply AnnTyping_unique. eauto. eauto.

  move: (H0 phi) => h0.

  edestruct h0.

  eapply AnnTyping_unique. eauto. eauto.

Defined. 



Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.

Next Obligation.

  unfold wildcard'.

  repeat split; intros; discriminate.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  erewrite <- get_tpg_correct'; eassumption.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  erewrite <- get_tpg_correct'; eassumption.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  eassumption.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  erewrite <- get_tpg_correct'; eassumption.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  erewrite <- get_tpg_correct'; eassumption.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  eauto.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Solve Obligations of AnnIso_dec with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  eauto.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  rewrite Heq_phi1 Heq_phi2.

  subst A' B'.

  eapply An_IsoConv'.

   rewrite -Heq_phi1. reflexivity.

   rewrite -Heq_phi2. reflexivity.

  all: try eassumption.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Next Obligation.

  hacky.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation. 

  cleanup'.

  autoreg.

  subst.

  econstructor; eauto.

Defined.

Next Obligation.

  move /An_Pi_inversion => [_ [_] ].

  have xG: x `notin` dom G by fsetdec.

  move /(_ x xG).

  ok.

Defined.

Next Obligation.

  move /An_Pi_inversion => [? ?].

  cleanup.

  apply: wildcard'.

  auto_uniq_full.

  ok.

Defined.

Next Obligation.

  apply An_Pi_exists2 with (x := x); ok.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation. 

  cleanup'.

  autoreg.

  subst.

  econstructor; eauto.

Defined.

Next Obligation.

  cleanup.

  move /An_Abs_inversion => [? [_ [_] ] ].

  have xG: x `notin` dom G by fsetdec.

  move /(_ x xG).

  ok.

Defined.

Next Obligation.

  by move: (wf.AnnTyping_lc1 wildcard').

Defined.

Next Obligation.

  cleanup.

  move /An_Abs_inversion => [? [_ [_] ] ].

  have xG: x `notin` dom G by fsetdec.

  move /(_ x xG) => [h _].

  by apply wildcard'.

Defined.

Next Obligation.

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ wildcard'2) /= [? [? [? ?] ] ].

  eapply An_Abs_exists with (x := x); try done.

  - autorewrite with lngen. fsetdec.

  - by subst.

  - by autorewrite with lngen.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  subst.

  apply: An_App; eassumption.

Defined.

Next Obligation.

  hacky.

Defined.



Solve All Obligations with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  hacky.

Defined.

Next Obligation.

  hacky.

  Unshelve.

  all: apply a_Star.

Defined.

Next Obligation.

  cleanup'.

  autoreg.

  clearget.

  subst.

  apply: An_Conv; eassumption.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  hacky.

Defined.

Next Obligation.

  subst.

  apply: An_CApp; eassumption.

Defined.

Next Obligation.

  hacky.

Defined.



Solve All Obligations with discr_pat_match.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  move: (an_toplevel_to_const wildcard') => AT.

  move: (AnnTyping_lc AT) => [lc1 lc2].

  eapply lc_set_tm_of_lc_tm. eauto.

Defined.

Next Obligation.

  inversion 1.

  

  move: (binds_unique _ _ _ _ _ H3 wildcard'0 uniq_an_toplevel).

  intro h0. inversion h0. subst.

  move: (binds_to_type _ _ AnnSig_an_toplevel H3) => h1. done.

Defined.

Next Obligation.

  subst.

  apply: An_Const; eauto.

  eapply an_toplevel_to_const; eauto.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation.

  cleanup'.

  econstructor; try eassumption.

  fsetdec.

Defined.

Next Obligation.

  move /An_CPi_inversion => [_ [_] ].

  have cG: c `notin` dom G by fsetdec.

  move /(_ c cG).

  ok.

Defined.

Next Obligation.

  move /An_CPi_inversion => [_ [_] ].

  have cG: c `notin` dom G by fsetdec.

  move /(_ c cG) => /= h.

  apply wildcard'.

  auto_uniq_full.

  by move: (u0 _ wildcard'1) => ->.

Defined.

Next Obligation.

  apply An_CPi_exists with (c := c);

  ok.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation. 

  fsetdec.

Defined.

Next Obligation.

  cleanup'.

  econstructor; try eassumption.

  fsetdec.

Defined.

Next Obligation.

  move /An_CAbs_inversion => [? [? ] ].

  have cG: c `notin` dom G by fsetdec.

  move /(_ _ cG).

  ok.

Defined.

Next Obligation.

  move: ann_context_fv_mutual => [h'' [_ [_ [_ _] ] ] ]; move: h'' => /(_ _ _ _ wildcard') /= [? [? [? ?] ] ].

  apply An_CAbs_exists with (c := c); try eassumption.

  - autorewrite with lngen. fsetdec.

  - autorewrite with lngen. eassumption.

Defined.



Next Obligation.

  hacky.

Defined.

Next Obligation.

  clear_annoying.

  subst.

  move: (an_toplevel_closed wildcard') => tpg.

  autoreg. 

  move: (AnnTyping_regularity tpg) => kdg.

  econstructor; eassumption.

Defined.



End fc_dec_fun.

