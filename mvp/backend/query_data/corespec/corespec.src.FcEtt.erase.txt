Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)

Require Import FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)
Require Import FcEtt.ett_inf_cs.
(* FcEtt.ett_inf_cs:
Require Import FcEtt.ett_inf.
Require Import FcEtt.imports.

Module Operators.

  Module Close.

    Record class1 (ssort : Type) (vartype : Type) :=  Class1 {close_ : vartype -> ssort -> ssort; close_rec_ : nat -> vartype -> ssort -> ssort}.

    Record class (ssort : Type) := Class {class_tm : class1 ssort tmvar; class_co : class1 ssort covar}.

    Arguments Class {ssort} class_tm class_co.
    Arguments Class1 {ssort vartype} close_ close_rec_.

  End Close.

  Module Open.

  End Open.

  Module Erase.

    Record class (ssort : Type) := Class {erase_ssort : ssort -> ssort}.

    Arguments Class {ssort} erase_ssort.

  End Erase.

  Module FV.

    Record class (ssort : Type) := Class {fv_tm : ssort -> atoms; fv_co : ssort -> atoms}.

    Arguments Class {ssort} fv_tm fv_co.

  End FV.

  Structure type := Pack {stxsort : Type; class_close : Close.class stxsort; class_Erase : Erase.class stxsort; class_Fv : FV.class stxsort}.

  Definition close_tm' (e : type) : tmvar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class (Close.Class1 c _) _) _ _ := e return tmvar -> stxsort e -> stxsort e in c.

  Definition close_tm_rec' (e : type) : nat -> tmvar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class (Close.Class1 _ c) _) _ _ := e return nat -> tmvar -> stxsort e -> stxsort e in c.

  Definition close_co' (e : type) : covar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class _ (Close.Class1 c _)) _ _ := e return covar -> stxsort e -> stxsort e in c.

  Definition close_co_rec' (e : type) : nat -> covar -> stxsort e -> stxsort e :=
    let 'Pack _ (Close.Class _ (Close.Class1 _ c)) _ _ := e return nat -> covar -> stxsort e -> stxsort e in c.

  Definition erase' (e : type) : stxsort e -> stxsort e :=
    let 'Pack _ _ (Erase.Class c) _ := e in c.

  Definition fv_tm' (e : type) : stxsort e -> atoms :=
    let 'Pack _ _ _ (FV.Class c _) := e in c.

  Definition fv_co' (e : type) : stxsort e -> atoms :=
    let 'Pack _ _ _ (FV.Class _ c) := e in c.

  Arguments close_tm' {e} s v : simpl nomatch.
  Arguments close_tm_rec' {e} k s v : simpl nomatch.
  Arguments close_co' {e} s v : simpl nomatch.
  Arguments close_co_rec' {e} k s v : simpl nomatch.
  Arguments erase' {e} s : simpl nomatch.
  Arguments fv_tm' {e} s : simpl nomatch.
  Arguments fv_co' {e} s : simpl nomatch.

  Module Theory.

    Notation close_tm := close_tm'.
    Notation close_tm_rec := close_tm_rec'.
    Notation close_co := close_co'.
    Notation close_co_rec := close_co_rec'.

    Notation erase := erase'.

    Notation fv_tm := fv_tm'.
    Notation fv_co := fv_co'.

  End Theory.

End Operators.

Export Operators.Theory.

Definition tm_Closecl         : Operators.Close.class tm         := Operators.Close.Class (Operators.Close.Class1 close_tm_wrt_tm close_tm_wrt_tm_rec)                 (Operators.Close.Class1 close_tm_wrt_co close_tm_wrt_co_rec).
Definition co_Closecl         : Operators.Close.class co         := Operators.Close.Class (Operators.Close.Class1 close_co_wrt_tm close_co_wrt_tm_rec)                 (Operators.Close.Class1 close_co_wrt_co close_co_wrt_co_rec).
Definition brs_Closecl        : Operators.Close.class brs        := Operators.Close.Class (Operators.Close.Class1 close_brs_wrt_tm close_brs_wrt_tm_rec)               (Operators.Close.Class1 close_brs_wrt_co close_brs_wrt_co_rec).
Definition constraint_Closecl : Operators.Close.class constraint := Operators.Close.Class (Operators.Close.Class1 close_constraint_wrt_tm close_constraint_wrt_tm_rec) (Operators.Close.Class1 close_constraint_wrt_co close_constraint_wrt_co_rec).

Definition erase_co (_ : co) := g_Triv.

Definition tm_Erasecl         : Operators.Erase.class tm         := Operators.Erase.Class erase_tm.
Definition co_Erasecl         : Operators.Erase.class co         := Operators.Erase.Class erase_co.
Definition brs_Erasecl        : Operators.Erase.class brs        := Operators.Erase.Class erase_brs.
Definition constraint_Erasecl : Operators.Erase.class constraint := Operators.Erase.Class erase_constraint.

Definition tm_FVcl         : Operators.FV.class tm         := Operators.FV.Class fv_tm_tm_tm         fv_co_co_tm.
Definition co_FVcl         : Operators.FV.class co         := Operators.FV.Class fv_tm_tm_co         fv_co_co_co.
Definition brs_FVcl        : Operators.FV.class brs        := Operators.FV.Class fv_tm_tm_brs        fv_co_co_brs.
Definition constraint_FVcl : Operators.FV.class constraint := Operators.FV.Class fv_tm_tm_constraint fv_co_co_constraint.

Canonical Structure tm_OpsTy         : Operators.type := Operators.Pack tm_Closecl         tm_Erasecl         tm_FVcl.
Canonical Structure co_OpsTy         : Operators.type := Operators.Pack co_Closecl         co_Erasecl         co_FVcl.
Canonical Structure brs_OpsTy        : Operators.type := Operators.Pack brs_Closecl        brs_Erasecl        brs_FVcl.
Canonical Structure constraint_OpsTy : Operators.type := Operators.Pack constraint_Closecl constraint_Erasecl constraint_FVcl.

Module Test.

End Test.

Module Rew.
  Definition r_erase_tm         : forall x, erase_tm x = erase x         := fun _ => eq_refl.
  Definition r_erase_co         : forall x, erase_co x = erase x         := fun _ => eq_refl.
  Definition r_erase_brs        : forall x, erase_brs x = erase x        := fun _ => eq_refl.
  Definition r_erase_constraint : forall x, erase_constraint x = erase x := fun _ => eq_refl.

  Definition r_close_tm_tm         : forall x t, close_tm_wrt_tm x t = close_tm x t         := fun _ _ => eq_refl.
  Definition r_close_tm_co         : forall x t, close_co_wrt_tm x t = close_tm x t         := fun _ _ => eq_refl.
  Definition r_close_tm_brs        : forall x t, close_brs_wrt_tm x t = close_tm x t        := fun _ _ => eq_refl.
  Definition r_close_tm_constraint : forall x t, close_constraint_wrt_tm x t = close_tm x t := fun _ _ => eq_refl.

  Definition r_close_co_tm         : forall x t, close_tm_wrt_co x t = close_co x t         := fun _ _ => eq_refl.
  Definition r_close_co_co         : forall x t, close_co_wrt_co x t = close_co x t         := fun _ _ => eq_refl.
  Definition r_close_co_brs        : forall x t, close_brs_wrt_co x t = close_co x t        := fun _ _ => eq_refl.
  Definition r_close_co_constraint : forall x t, close_constraint_wrt_co x t = close_co x t := fun _ _ => eq_refl.

  Module Exprt.
    Hint Rewrite -> r_erase_tm r_erase_co r_erase_brs r_erase_constraint : rewdb_cs.

    Ltac autorewcs :=
      rewrite ? r_erase_tm;
      rewrite ? r_erase_co;
      rewrite ? r_erase_brs;
      rewrite ? r_erase_constraint;

      rewrite ? r_close_tm_tm;
      rewrite ? r_close_tm_co;
      rewrite ? r_close_tm_brs;
      rewrite ? r_close_tm_constraint;

      rewrite ? r_close_co_tm;
      rewrite ? r_close_co_co;
      rewrite ? r_close_co_brs;
      rewrite ? r_close_co_constraint.

    Ltac autorewcshyp H :=
      rewrite ? r_erase_tm in H;
      rewrite ? r_erase_co in H;
      rewrite ? r_erase_brs in H;
      rewrite ? r_erase_constraint in H;

      rewrite ? r_close_tm_tm in H;
      rewrite ? r_close_tm_co in H;
      rewrite ? r_close_tm_brs in H;
      rewrite ? r_close_tm_constraint in H;

      rewrite ? r_close_co_tm in H;
      rewrite ? r_close_co_co in H;
      rewrite ? r_close_co_brs in H;
      rewrite ? r_close_co_constraint in H.
  End Exprt.
End Rew.

Export Rew.Exprt. *)
Require Import FcEtt.ett_ind.
(* FcEtt.ett_ind:
Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Export FcEtt.fset_facts.
Require Export FcEtt.ett_inf.
Require Export FcEtt.tactics.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma tm_subst_tm_tm_var : forall a x, tm_subst_tm_tm a x (a_Var_f x) = a.

Lemma co_subst_co_co_var : forall a x, co_subst_co_co a x (g_Var_f x) = a.

Lemma tm_subst_tm_tm_var_neq : forall a x y, x <> y ->
    tm_subst_tm_tm a y (a_Var_f x) = (a_Var_f x).

Lemma co_subst_co_co_var_neq : forall a x y, x <> y ->
    co_subst_co_co a y (g_Var_f x) = (g_Var_f x).

Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm_var : subst_open_var.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co_var : open_subst_var.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co_var : open_subst_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_tm : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm : subst_open.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm : open_subst.

Ltac apply_lc_exists x :=
  pick fresh x;
  ( apply lc_a_Abs_exists      with (x1 := x)
  || apply lc_a_Pi_exists       with (x1 := x)
  || apply lc_a_CPi_exists      with (c1 := x)
  || apply lc_a_CAbs_exists     with (c1 := x)
  || apply lc_a_UAbs_exists     with (x1:= x)
  || apply lc_a_UCAbs_exists    with (c1 := x)
  || apply lc_g_PiCong_exists   with (x1 := x)
  || apply lc_g_AbsCong_exists  with (x1 := x)
  || apply lc_g_CPiCong_exists  with (c1 := x)
  || apply lc_g_CAbsCong_exists with (c1 := x)
  || fail "invalid case for apply_lc_exists" );
  eauto 2.

Ltac lc_solve_binds :=
  match goal with
  
  | [ H : binds ?x ?s nil |- _ ] => inversion H; clear H
  
  | [ H : binds _ ?s ([(_,_)] ++ _) |- _ ?s] =>
      destruct (binds_cons_1 _ _ _ _ _ _ H); basic_solve
  
  | [ b : binds ?x _ ?G, H : ∀ (x' : atom) _, binds x' _ ?G → _ |- _] =>
      by apply H in b; inversion b; try done;
          match goal with
            | [H' : lc_constraint _ |- _] => inversion H' ; clear H'
            | [H' : lc_tm         _ |- _] => inversion H' ; clear H'
          end
  end.

Ltac lc_inversion c :=
  repeat match goal with
    
  | [ H : forall x, (x `in` ?L -> False) -> lc_tm _ /\ _ |- _ ] =>
    destruct (H c ltac:(auto)); split_hyp; clear H
  
  | [ H : lc_constraint (_ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Abs _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_App _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Pi _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Conv _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CPi _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UCAbs _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CApp _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Case _ _) |- _ ] =>
    inversion H; clear H
 end.

Ltac apply_lc_body :=
  match goal with
  | |- lc_tm (open_tm_wrt_tm ?a ?b) => eapply lc_body_tm_wrt_tm; auto
  | |- lc_tm (open_tm_wrt_co ?a ?b) => eapply lc_body_tm_wrt_co; auto
  end.

Lemma co_subst_co_tm_lc_tm_inverse
  : ∀ (g1 : co) (c1 : covar),
      lc_co g1 ->
      (forall A,
          lc_tm A -> forall XX, A = (co_subst_co_tm g1 c1 XX) -> lc_tm XX)
      /\
      (forall b1,
          lc_brs b1 -> forall XX, b1 = (co_subst_co_brs g1 c1 XX) -> lc_brs XX)
      /\
      (forall co,
          lc_co co -> forall XX, co = (co_subst_co_co g1 c1 XX) -> lc_co XX)
      /\
      (forall phi,
          lc_constraint phi -> forall XX, phi = (co_subst_co_constraint g1 c1 XX) ->
          lc_constraint XX).

Ltac invert_syntactic_equality :=
  repeat match goal with
  | [ H : a_Var_f _  = a_Var_f _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Abs _ _ = a_Abs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UAbs _ _ = a_UAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Pi _ _ _ = a_Pi _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_App _ _ _ = a_App _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Fam _  = a_Fam _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Const _  = a_Const _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Conv _ _ = a_Conv _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UCAbs _ = a_UCAbs _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CAbs + _ = a_CAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CApp _ _  = a_CApp _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CPi _ _ = a_CPi _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : Eq _ _ _ = Eq _ _ _ |- _ ] =>
    inversion H; subst; clear H
  end.

Ltac ann_invert_clear :=
  match goal with
  | H : AnnTyping _ a_Star _ |- _ => inversion H; subst; clear H
  | H : AnnTyping _ (_ _) _ |- _ =>  inversion H; subst; clear H
  | H : AnnPropWff _ _ |- _ => inversion H; subst; clear H
  | H : AnnIso _ _ (_ _) _ _ |- _ => inversion H; subst; clear H
  | H : AnnDefEq _ _ (_ _) _ _  |- _ => inversion H; subst; clear H
  | H : AnnCtx ([(_,_)] ++ _) |- _ => inversion H; subst; clear H
  | H : AnnCtx (_ :: _) |- _ => inversion H; subst; clear H
  end.

Lemma lc_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x0)).

Lemma fv_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    x0 `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0)).

Scheme typing_ind' := Induction for Typing Sort Prop
   with wff_ind'   := Induction for PropWff Sort Prop
   with iso_ind'   := Induction for Iso Sort Prop
   with defeq_ind' := Induction for DefEq Sort Prop
   with ctx_ind'   := Induction for Ctx Sort Prop.

Combined Scheme typing_wff_iso_defeq_mutual from typing_ind', wff_ind', iso_ind', defeq_ind', ctx_ind'.

Scheme ann_typing_ind' := Induction for AnnTyping Sort Prop
   with ann_wff_ind'   := Induction for AnnPropWff Sort Prop
   with ann_iso_ind'   := Induction for AnnIso Sort Prop
   with ann_defeq_ind' := Induction for AnnDefEq Sort Prop
   with ann_ctx_ind'   := Induction for AnnCtx Sort Prop.

Combined Scheme ann_typing_wff_iso_defeq_mutual
from ann_typing_ind', ann_wff_ind', ann_iso_ind',
     ann_defeq_ind', ann_ctx_ind'.

Scheme CoercedValue_ind' := Induction for CoercedValue Sort Prop
                            with Value_ind' := Induction for Value Sort Prop.
Combined Scheme CoercedValue_Value_mutual from CoercedValue_ind', Value_ind'.

Ltac ext_induction CON :=
    apply typing_wff_iso_defeq_mutual;
    [ pose CON :=  E_Star       |
      pose CON :=  E_Var        |
      pose CON :=  E_Pi         |
      pose CON :=  E_Abs        |
      pose CON :=  E_App        |
      pose CON :=  E_IApp       |
      pose CON :=  E_Conv       |
      pose CON :=  E_CPi        |
      pose CON :=  E_CAbs       |
      pose CON :=  E_CApp       |
      pose CON :=  E_Const      |
      pose CON :=  E_Fam        |
      pose CON :=  E_Wff        |
      pose CON :=  E_PropCong   |
      pose CON :=  E_IsoConv    |
      pose CON :=  E_CPiFst     |
      pose CON :=  E_Assn       |
      pose CON :=  E_Refl       |
      pose CON :=  E_Sym        |
      pose CON :=  E_Trans      |
      pose CON :=  E_Beta       |
      pose CON :=  E_PiCong     |
      pose CON :=  E_AbsCong    |
      pose CON :=  E_AppCong    |
      pose CON :=  E_IAppCong   |
      pose CON :=  E_PiFst      |
      pose CON :=  E_PiSnd      |
      pose CON :=  E_CPiCong    |
      pose CON :=  E_CAbsCong   |
      pose CON :=  E_CAppCong   |
      pose CON :=  E_CPiSnd     |
      pose CON :=  E_Cast       |
      pose CON :=  E_EqConv     |
      pose CON :=  E_IsoSnd     |
      pose CON :=  E_EtaRel     |
      pose CON :=  E_EtaIrrel   |
      pose CON :=  E_EtaC       |

      pose CON :=  E_Empty      |
      pose CON :=  E_ConsTm     |
      pose CON :=  E_ConsCo     ].

Ltac ann_induction CON :=
    apply ann_typing_wff_iso_defeq_mutual;
    [ pose CON :=  An_Star       |
      pose CON :=  An_Var        |
      pose CON :=  An_Pi         |
      pose CON :=  An_Abs        |
      pose CON :=  An_App        |
      pose CON :=  An_Conv       |
      pose CON :=  An_CPi        |
      pose CON :=  An_CAbs       |
      pose CON :=  An_CApp       |
      pose CON :=  An_Const      |
      pose CON :=  An_Fam        |
      pose CON :=  An_Wff        |
      pose CON :=  An_PropCong   |
      pose CON :=  An_CPiFst     |
      pose CON :=  An_IsoSym     |
      pose CON :=  An_IsoConv    |
      pose CON :=  An_Assn       |
      pose CON :=  An_Refl       |
      pose CON :=  An_EraseEq      |
      pose CON :=  An_Sym        |
      pose CON :=  An_Trans      |
      pose CON :=  An_Beta       |
      pose CON :=  An_PiCong     |
      pose CON :=  An_AbsCong    |
      pose CON :=  An_AppCong    |
      pose CON :=  An_PiFst      |
      pose CON :=  An_PiSnd      |
      pose CON :=  An_CPiCong    |
      pose CON :=  An_CAbsCong   |
      pose CON :=  An_CAppCong   |
      pose CON :=  An_CPiSnd     |
      pose CON :=  An_Cast       |
      pose CON :=  An_IsoSnd     |
      pose CON :=  An_Eta        |
      pose CON :=  An_EtaC       |

      pose CON :=  An_Empty      |
      pose CON :=  An_ConsTm     |
      pose CON :=  An_ConsCo     ].

Ltac ensure_case C :=
  match goal with [ CON := C : ?A |- _ ] => idtac end.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let C1 := gather_atoms_with (fun x : context => dom x) in
  let D1 := gather_atoms_with (fun x => fv_tm_tm_tm x) in
  let D2 := gather_atoms_with (fun x => fv_tm_tm_co x) in
  let D3 := gather_atoms_with (fun x => fv_tm_tm_constraint x) in
  let D4 := gather_atoms_with (fun x => fv_tm_tm_sort x) in
  let D5 := gather_atoms_with (fun x => fv_tm_tm_brs x) in
  let D6 := gather_atoms_with (fun x => fv_co_co_tm x) in
  let D7 := gather_atoms_with (fun x => fv_co_co_co x) in
  let D8 := gather_atoms_with (fun x => fv_co_co_constraint x) in
  let D9 := gather_atoms_with (fun x => fv_co_co_sort x) in
  let D10 := gather_atoms_with (fun x => fv_co_co_brs x) in
  constr:(A \u B \u C1 \u D1 \u D2 \u D3 \u D4 \u D5 \u D6 \u D7 \u D8 \u D9 \u D10).

Ltac rewrite_body :=
  match goal with
  | [ e : ∀ x : atom, (x `in` ?L → False)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
     rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ c : atom, (c `notin` ?L)
      → open_tm_wrt_co _ (g_Var_f c) =
        open_tm_wrt_co _ (g_Cast (g_Var_f c) (g_Sym _)) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `in` ?L → False) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `notin` ?L) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto

  end.

Ltac lc_solve :=
  let c := fresh in
  try lc_solve_binds;
  try apply_lc_exists c;
  lc_inversion c; auto;
  try rewrite_body;
  try apply_lc_body;
  eauto with lc.

Hint Resolve lc_a_Pi_exists
     lc_a_CPi_exists lc_a_Abs_exists lc_a_CAbs_exists lc_a_UAbs_exists.

Hint Resolve lc_body_tm_wrt_tm lc_body_tm_wrt_co. 

Lemma rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)) ->
    RhoCheck rho x0 (open_tm_wrt_tm a (a_Var_f x0)).

Lemma eta_swap: forall x y a' b rho,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b rho (a_Var_f x) ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b rho (a_Var_f y).

Lemma eta_swap_irrel: forall x y a' b,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b Irrel a_Bullet ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b Irrel a_Bullet.

Lemma eta_swap_c: forall x y a' b,
    x `notin` fv_co_co_tm a' \u fv_co_co_tm b ->
    open_tm_wrt_co a' (g_Var_f x) = a_CApp b g_Triv ->
    open_tm_wrt_co a' (g_Var_f y) = a_CApp b g_Triv.

Ltac auto_rew_env :=
  multimatch goal with
    | [ |- context [([(?x, ?T)] ++ ?G1 ++ ?G2 ++ ?G3)] ] => rewrite_env (((x ~ (T)) ++ G1) ++ G2 ++ G3)
  end.

Ltac E_pick_fresh x :=
  match goal with
    | [ |- Typing _ ?shape _ ] =>
      let v := match shape with
            | a_Pi _ _ _ => E_Pi
            | a_UAbs _ _ => E_Abs
            | a_CPi _ _  => E_CPi
            | a_CAbs _ _ => E_CAbs
            | a_UCAbs _  => E_CAbs
           end
      in pick fresh x and apply v
    | [ |- DefEq _ _ ?shape ?s2 _ ] =>
      let v := match shape with
               | a_Pi _ _ _ => E_PiCong
               | a_UAbs Rel _ => match s2 with
                                | a_UAbs _ _ => E_AbsCong
                                | _ => E_EtaRel
                                end
               | a_UAbs Irrel _ => match s2 with 
                                | a_UAbs _ _ =>  E_AbsCong
                                | _ => E_EtaIrrel
                                end
               | a_CPi _ _  => E_CPiCong
               | a_CAbs _ _ => E_CAbsCong
               | a_UCAbs _  => match s2 with 
                                | a_UCAbs _ =>  E_CAbsCong
                                | _ => E_EtaC
                                end
               end
      in pick fresh x and apply v
  end.

Ltac Par_pick_fresh x :=
  match goal with
    | [ |- Par _ _ ?shape ?s2 ] =>
      let v := match shape with
            | a_Pi _ _ _ => Par_Pi
            | a_UAbs Rel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_Eta
                                end
            | a_UAbs Irrel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_EtaIrrel
                                end
            | a_UAbs _ _ =>  Par_Abs
            | a_CPi _ _  => Par_CPi
            | a_CAbs _ _ => Par_CAbs
            | a_UCAbs _  => match s2 with
                                | a_UCAbs _ => Par_CAbs
                                | _ => Par_EtaC
                                end
           end
      in pick fresh x and apply v
  end.

Ltac An_pick_fresh x :=
  let shape := match goal with
                 | [ |- AnnTyping _   ?shape _    ] => shape
                 | [ |- AnnDefEq  _ _ ?shape _  _ ] => shape
               end in
  let ctor  := match shape with
    | a_Pi     _ _ _ => An_Pi
    | a_Abs    _ _ _ => An_Abs
    | a_CPi      _ _ => An_CPi
    | a_CAbs     _ _ => An_CAbs
    | g_PiCong _ _ _ => An_PiCong
    | g_AbsCong _ _ _  => An_AbsCong
    | g_CPiCong  _ _   => An_CPiCong
    | g_CAbsCong _ _ _ => An_CAbsCong
    | g_Eta _          => An_Eta
               end in
  pick fresh x and apply ctor.

Ltac RhoCheck_inversion y :=
  match goal with
  | [ K : ∀ x : atom, x `notin` ?L → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  | [ K : ∀ x : atom, (x `in` ?L -> False) → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  end.

Lemma lc_open_switch_co :
  forall g t, lc_co g ->
  lc_tm (open_tm_wrt_co t g_Triv) ->
  lc_tm (open_tm_wrt_co t g).

Hint Resolve lc_open_switch_co.

Lemma tm_subst_cast : forall a x g,
    tm_subst_tm_tm a x (a_Conv (a_Var_f x) g) = a_Conv a (tm_subst_tm_co a x g).

Hint Rewrite tm_subst_cast. *)
Require Import FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)
Require Import FcEtt.tactics.
(* FcEtt.tactics:
Require Import FcEtt.imports.

Require Import FcEtt.ett_inf.

Inductive Dyn : Type := dyn : forall {T : Type}, T -> Dyn.

Ltac unwrap_dyn d :=
  match d with
    | dyn ?v => v
  end.

Ltac split_hyp :=
  repeat (
      match goal with
        | [ H : _ /\ _ |- _ ] => destruct H
      end).

Ltac rewrite_and_clear eq :=
  first [rewrite -> eq | rewrite <- eq]; clear eq.

Ltac try_rewrite_and_clear eq :=
  first [rewrite -> ! eq | rewrite <- ! eq | idtac]; clear eq.

Ltac try_rewrite_and_clear_f eq :=
  first [rewrite ! eq | idtac]; clear eq.

Ltac find_eq_rew_clear :=
  match goal with
    | [ eq : forall t1,                _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2,             _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3,          _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4,       _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5,    _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5 t6, _ = _ |- _ ] => rewrite_and_clear eq
  end.

Ltac subst_forall :=
  repeat find_eq_rew_clear.

Tactic Notation "basic_nosolve_n"     int_or_var(n) :=
  intuition (subst; eauto n).
Tactic Notation "basic_nosolve_n'"    int_or_var(n) :=
  intuition (subst; simpl in *; subst; eauto n; try done).
Tactic Notation "basic_nosolve_fo_n"  int_or_var(n) :=
  firstorder (subst; eauto n).
Tactic Notation "basic_nosolve_fo_n'" int_or_var(n) :=
  firstorder (subst_forall; simpl in *; subst_forall; eauto n; try done).

Tactic Notation "basic_solve_n"     int_or_var(n) := try solve [basic_nosolve_n     n].
Tactic Notation "basic_solve_n'"    int_or_var(n) := try solve [basic_nosolve_n'    n].
Tactic Notation "basic_solve_fo_n"  int_or_var(n) := try solve [basic_nosolve_fo_n  n].
Tactic Notation "basic_solve_fo_n'" int_or_var(n) := try solve [basic_nosolve_fo_n' n].

Ltac basic_nosolve     := basic_nosolve_n     5.
Ltac basic_nosolve'    := basic_nosolve_n'    5.
Ltac basic_nosolve_fo  := basic_nosolve_fo_n  5.
Ltac basic_nosolve_fo' := basic_nosolve_fo_n' 5.

Ltac basic_solve     := try solve [basic_nosolve].
Ltac basic_solve'    := try solve [basic_nosolve'].
Ltac basic_solve_fo  := try solve [basic_nosolve_fo].
Ltac basic_solve_fo' := try solve [basic_nosolve_fo'].

Ltac solve_by_inv_hyp_about A :=
  multimatch goal with
    | [ H : context [?A] |- _ ] => solve [inversion H; basic_solve]
  end.

Ltac revert_all :=
  repeat match goal with
      | [ H : _ |- _ ] => revert H
    end.

Ltac revert_all_with t :=
  repeat match goal with
      | [ H : _ |- _ ] => try t H; revert dependent H
    end.

Ltac intro_all_with t :=
  repeat
    (let x := fresh in intro x; try (t x)).

Ltac disjunction_assumption :=
  match goal with
    | [H : ?P |- ?P]     => exact H
    | [H : ?P |- ?P ∨ _] => left; exact H
    | [       |- _  ∨ _] => right; disjunction_assumption
  end.

Ltac invert_and_clear H := inversion H; clear H.

Definition wrap : forall P : Prop, P -> P * True := fun _ p => (p, I).
Ltac wrap_hyp H := apply wrap in H.

Lemma AnnCtx_uniq G : AnnCtx G -> uniq G.

Ltac prove_this stmt name :=

  match stmt with
    | uniq ?G =>
      match goal with
      | [ HG : AnnCtx G |- _ ] =>
        
        move: (AnnCtx_uniq HG) => name 
      end
    end.

Ltac find_invertible_hyps :=
  repeat (
  match goal with
    
    | [ H : AnnIso _ _ (g_EqCong _ _ _) _ _ |- _ ] => invert_and_clear H
    
    | [ H : AnnIso _ _ (_ _) _ _ |- _ ] => inversion H; wrap_hyp H

    | [ H : AnnTyping _ (_ _) _ |- _ ] => inversion H; wrap_hyp H

  end).

Ltac pair_coupled_hyps :=
  repeat match goal with
    | [ H1 : binds ?T _ ?G, H2 : binds ?T _ ?G |- _ ] =>
      let unG := fresh "uniq" G in
      prove_this (uniq G) unG;
      move: (binds_unique _ _ _ _ _ H1 H2 unG) => ?; wrap_hyp H2

  end.

Ltac pcess_hyps :=
  find_invertible_hyps;

  pair_coupled_hyps;

  repeat (
    match goal with
      | [ H : _ /\ _       |- _ ] => destruct H

      | [ H : exists x, _  |- _ ] => destruct H

      | [ H : _ * True  |- _      ] => destruct H as [H _]

      | [ H :                   ?A = ?A |- _ ] => clear H
      | [ H : forall _,         ?A = ?A |- _ ] => clear H
      | [ H : forall _ _,       ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _,     ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _,   ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _ _, ?A = ?A |- _ ] => clear H
      
      | [ H : ?P |- _ ] => clear H; let x := fresh in assert (x : P) by solve [assumption | trivial]; clear x

      | [ H : ?C _                         = ?C _                         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _                       = ?C _ _                       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _                     = ?C _ _ _                     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _                   = ?C _ _ _ _                   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _                 = ?C _ _ _ _ _                 |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ |- _ ] => injection H; clear H; intros; try subst

    end).

Ltac pre :=
  repeat (intros; try split);
  
  unfold "~" in *.

Ltac pre' :=
  repeat (intros; try split);
  pcess_hyps;
  unfold "~" in *.

Ltac prove_eq_same_head :=
  solve [subst; reflexivity | f_equal; basic_solve].

Ltac break_union :=
  repeat match goal with
  
    | [ H : ~ ?x `in` union _ _ |- _ ] =>
        move: (notin_union_1 _ _ _ H) (notin_union_2 _ _ _ H) => ??; clear H
  end.

Ltac fsetdec_fast := solve [break_union; basic_solve_n 3].

Ltac autofresh_fixed x :=
   repeat match goal with
     | [ H : ∀ x' : atom, x' `notin` ?L -> _ |- _] =>
       let xL := fresh x L in
       (have xL : x `notin` L by first [fsetdec_fast | fsetdec]);
       specialize (H x xL);
       clear xL 
   end.

 Ltac autofresh :=
   let x := fresh "x" in
   pick fresh x;
   autofresh_fixed x.

Ltac autotype :=
  pcess_hyps;

  repeat match goal with
    | [ |- _ /\ _ ] => split

    | [ |- _ `in` _   ] => try fsetdec_fast; first [fsetdec | fail 2] 
    | [ |- ¬ _ `in` _ ] => try fsetdec_fast; first [fsetdec | fail 2]

    | [ |- _ [=] _  ] => first [fsetdec | fail 2]
    | [ |- _ [<=] _ ] => first [fsetdec | fail 2]

    | [ |- ?C _                         = ?C _                         ] => prove_eq_same_head
    | [ |- ?C _ _                       = ?C _ _                       ] => prove_eq_same_head
    | [ |- ?C _ _ _                     = ?C _ _ _                     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _                   = ?C _ _ _ _                   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _                 = ?C _ _ _ _ _                 ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ ] => prove_eq_same_head

    | _ => try done; basic_solve; fail 0

    | [ |- ex _ ] => eexists

    | [ |- AnnTyping _   (_ _) _   ] => econstructor; pcess_hyps
    | [ |- AnnDefEq  _ _ (_ _) _ _ ] => econstructor; pcess_hyps
    | [ |- AnnIso    _ _ (_ _) _ _ ] => econstructor; pcess_hyps
  end.

Ltac ok := autotype.
Ltac depind x := dependent induction x. *)
Require Import FcEtt.erase_syntax.
(* FcEtt.erase_syntax:
Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).

Lemma erase_dom : forall G, dom G = dom (erase_context G).

Lemma path_erase : forall T p, Path T p -> Path T (erase p).

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end. *)
Require Import FcEtt.ext_red.  
(* FcEtt.ext_red:
Require Import FcEtt.sigs.
Require Import FcEtt.imports.
Require Import FcEtt.ett_ott.

Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_par.

Require Import FcEtt.ett_ind.

Require Import FcEtt.ext_wf.

Require Import FcEtt.ext_red_one.

Require Import FcEtt.tactics.

Module ext_red (invert : ext_invert_sig).

  Export invert.

Module red_one := ext_red_one invert.
Export red_one.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma Beta_preservation : forall a b, Beta a b -> forall G A, Typing G a A -> Typing G b A.

Lemma E_Beta2 :  ∀ (G : context) (D : available_props) (a1 a2 B : tm),
       Typing G a1 B → Beta a1 a2 → DefEq G D a1 a2 B.

Lemma reduction_in_Par : forall a a', reduction_in_one a a' -> forall G D, Par G D a a'.

Lemma reduction_in_one_fv_preservation: forall x a b, reduction_in_one a b ->
                                        x `notin` fv_tm_tm_tm a ->
                                        x `notin` fv_tm_tm_tm b.

Lemma reduction_rhocheck : forall a a' rho x, reduction_in_one a a' -> RhoCheck rho x a -> RhoCheck rho x a'.

Lemma reduction_preservation : forall a a', reduction_in_one a a' -> forall G A, Typing G a A -> Typing G a' A.

Ltac par_with_context_tail :=
  match goal with
  | _ : _ |- Par ([?s] ++ ?G ) (dom ([?s] ++ ?G)) ?a ?b =>
    eapply context_Par_irrelevance with (G1 := G) (D1 := dom G); eauto
  end.

Ltac ind_hyp a k1 k2 :=
  match goal with
    [ H : ∀ a' : tm, Ctx ?G → Par ?G ?D a a' → Typing ?G a' ?A ∧ DefEq ?G empty a a' ?A,
        H1 : Par ?G ?D a ?a',
        H2 : Ctx ?G |- _ ] =>
    move: (@H a' H2 H1) => [k1 k2]

  end.

Ltac ind_hyp_open x B k1 k2 :=
  match goal with
    [ H : forall x, x `notin` ?L -> forall a', Ctx ([(x, ?s)] ++ ?G) -> Par ([(x, ?s)] ++ ?G) ?D (open_tm_wrt_tm B (a_Var_f x)) a' -> ?P,
        H1 : Ctx ?G,
        H10 :  forall x : atom, x `notin` ?L0 → Par ?G ?D0 (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm ?B' (a_Var_f x))
                          |- _ ] =>
    move: (H x ltac:(auto) (open_tm_wrt_tm B' (a_Var_f x)) ltac:(auto)
                (context_Par_irrelevance ([(x, s)] ++ G) (dom ([(x,s)] ++ G)) (H10 x ltac:(auto)))) => [k0 k1]
      end.

End  ext_red. *)
Require Import FcEtt.fc_invert FcEtt.fc_unique.
(* FcEtt.fc_invert:
Require Import FcEtt.sigs.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.
Require Import FcEtt.fset_facts.

Require Import FcEtt.ett_ott.
Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_inf_cs.
Require Import FcEtt.ett_ind.

Require Import FcEtt.erase_syntax.
Require Export Metalib.CoqEqDec.
Require Import Coq.Logic.Decidable.
Require Import Metalib.Metatheory.
Require Import FcEtt.fc_unique.

Require Import FcEtt.fc_wf.
Require Import FcEtt.toplevel.
Require Import FcEtt.fc_context_fv.

Module fc_invert (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig).
Import weak subst.

Module unique := fc_unique wf subst.
Import unique.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma AnnTyping_regularity :
  (forall G a A, AnnTyping G a A -> AnnTyping G A a_Star).

Lemma AnnPropWff_regularity :
  forall G A B A1, AnnPropWff G (Eq A B A1) -> exists B1 g,
      AnnTyping G A A1 /\ AnnTyping G B B1 /\ AnnDefEq G empty g A1 B1.

Lemma erase_pi : forall G AB0 rho A B S, erase AB0 = (a_Pi rho A B) -> AnnTyping G AB0 S ->
  exists A1 B0, erase AB0 = erase (a_Pi rho A1 B0) /\ erase A1 = A /\ erase B0 = B /\ AnnTyping G (a_Pi rho A1 B0) a_Star.

Lemma erase_cpi : forall AB0 A B G S,
    erase AB0 = (a_CPi A B) -> AnnTyping G AB0 S ->
    exists A1 B0, erase AB0 = erase (a_CPi A1 B0) /\ erase_constraint A1 = A /\ erase B0 = B
             /\ AnnTyping G (a_CPi A1 B0) a_Star.

Lemma erase_app_Rel :
  forall AB0 A B C G, erase AB0 = (a_App A Rel B) -> AnnTyping G AB0 C ->
  exists A1 B0 g D, erase AB0 = erase (a_App A1 Rel B0) /\ erase A1 = A /\ erase B0 = B /\
          AnnTyping G (a_App A1 Rel B0) D /\ AnnDefEq G (dom G) g C D.

Lemma erase_app_Irrel :
  forall AB0 A C G, erase AB0 = (a_App A Irrel a_Bullet) -> AnnTyping G AB0 C ->
  exists A1 B0 g D, erase AB0 = erase (a_App A1 Irrel B0) /\ erase A1 = A /\
          AnnTyping G (a_App A1 Irrel B0) D /\ AnnDefEq G (dom G) g C D.

Lemma erasure_compatible : forall G a A (H1 :AnnTyping G a A),
    forall b B (H2 : AnnTyping G b B)
      (E : erase a = erase b)
      (F : erase A = erase B),
    exists g1, AnnDefEq G (dom G) g1 a b.

Lemma AnnDefEqAnnIso_regularity :
  (forall G0 a A, AnnTyping G0 a A -> True ) /\
  (forall G0 phi,   AnnPropWff G0 phi -> True ) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 AnnPropWff G p1 /\ AnnPropWff G p2) /\
  (forall G D g A B,   AnnDefEq G D g A B ->
           exists C1 C2 g', AnnTyping G A C1 /\ AnnTyping G B C2 /\ AnnDefEq G (dom G) g' C1 C2) /\
  (forall G0, AnnCtx G0 -> True).

Definition  AnnDefEq_regularity :
    (forall G D g A B,   AnnDefEq G D g A B ->
                    exists C1 C2 g', AnnTyping G A C1 /\ AnnTyping G B C2
                                /\ AnnDefEq G (dom G) g' C1 C2) :=
  fourth AnnDefEqAnnIso_regularity.

Definition AnnIso_regularity :
  forall G D g phi1 phi2, AnnIso G D g phi1 phi2 ->
                     AnnPropWff G phi1 /\ AnnPropWff G phi2 :=
  third AnnDefEqAnnIso_regularity.

  Lemma An_Sym2
    : ∀ (G : context) (D : available_props) (g : co) (a b : tm),
      AnnDefEq G D g b a → AnnDefEq G D (g_Sym g) a b.

Lemma An_Trans2
     : ∀ (G : context) (D : available_props) (g1 g2 : co)
       (a b a1 : tm),
       AnnDefEq G D g1 a a1
       → AnnDefEq G D g2 a1 b
       → AnnDefEq G D (g_Trans g1 g2) a b .

Lemma erase_a_Const : forall G0 a0 A0 A1 T,
       erase a0 = a_Const T ->
       binds T (Cs A1) an_toplevel ->
       AnnTyping G0 a0 A0   ->
       exists g, AnnDefEq G0 (dom G0) g A0 A1.

Lemma erase_capp :
  forall AB0 C G, AnnTyping G AB0 C -> forall A, erase AB0 = (a_CApp A g_Triv) ->
  exists a1 g0 g D, erase AB0 = erase (a_CApp a1 g0) /\ erase a1 = A /\
          AnnTyping G (a_CApp a1 g0) D /\ AnnDefEq G (dom G) g C D.

Lemma An_AppCong2 : ∀ (G : context) (D : available_props) rho (g1 g2 : co)
       (a1 a2 b1 b2 A B : tm),
       AnnDefEq G D g1 a1 b1
       → AnnDefEq G D g2 a2 b2
         → AnnTyping G (a_App a1 rho a2) A
           → AnnTyping G (a_App b1 rho b2) B
           → AnnDefEq G D (g_AppCong g1 rho g2) (a_App a1 rho a2) (a_App b1 rho b2).

Lemma An_CAppCong2 :
      ∀ (G : context) (D : available_props) (g1 g2 g3 : co) (a1 b1 a2 b2 a3 b3 A B : tm),
       AnnDefEq G D g1 a1 b1
       → AnnDefEq G (dom G) g2 a2 b2
       → AnnDefEq G (dom G) g3 a3 b3
       → AnnTyping G (a_CApp a1 g2) A
       → AnnTyping G (a_CApp b1 g3) B
       → AnnDefEq G D (g_CAppCong g1 g2 g3) (a_CApp a1 g2) (a_CApp b1 g3).

Lemma An_Trans'
     : ∀ (G : context) (D : available_props) (g1 g2 : co)
       (a b a1 : tm),
       AnnDefEq G D g1 a a1
       → AnnDefEq G D g2 a1 b
       → exists g, AnnDefEq G D g a b .

Lemma An_Sym'
   : ∀ (G : context) (D : available_props) (g : co) (a b : tm),
       AnnDefEq G D g b a → exists g, AnnDefEq G D g a b.

Lemma An_Refl_Star : forall G D a b A,
     erase a = erase b -> AnnTyping G b a_Star ->
     AnnTyping G a A -> erase A = a_Star ->
     exists g, AnnDefEq G D g a b.

Lemma An_IsoRefl2_derivable  : ∀ (G : context) (D : available_props) (phi1 phi2 : constraint),
       AnnPropWff G phi1
       → AnnPropWff G phi2
       → erase_constraint phi1 = erase_constraint phi2 →
       exists g,
       AnnIso G D g phi1 phi2.

Lemma An_Pi_exists2
     : ∀ (x : atom) (G : list (atom * sort)) (rho : relflag) (A B : tm),
       x `notin` union (dom G) (fv_tm_tm_tm B)
       → AnnTyping ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
       → AnnTyping G (a_Pi rho A B) a_Star.

Lemma An_Abs_exists2
  : ∀ (x : atom) (G : context) (rho : relflag) (A a B : tm),
    x `notin` union (dom G) (union (fv_tm_tm_tm a) (fv_tm_tm_tm B))
    → AnnTyping ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    → RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x)))
    → AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

Lemma An_CPi_exists2
  : ∀ (c : atom) (G : context) (phi : constraint) (B : tm),
       c `notin` union (dom G) (fv_co_co_tm B)
       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
       → AnnTyping G (a_CPi phi B) a_Star.

Lemma An_CAbs_exists2
   : ∀ (c : atom) (G : context) (phi : constraint) (a B : tm),
       c `notin` union (dom G) (union (fv_co_co_tm a) (fv_co_co_tm B))
       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c))
       → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

Lemma An_Fam2 :  ∀ (G : context) (F : tyfam) (A a : tm),
       AnnCtx G
       → binds F (Ax a A) an_toplevel
       → AnnTyping G (a_Fam F) A.

Lemma An_AbsCong_exists2
      : ∀ (x1 x2 : atom) (G : context) (D : available_props) (rho : relflag) (g1 g2 : co)
        (A1 b1 A2 b3 b2 B : tm),
        x1 `notin` union (dom G) (union (fv_tm_tm_tm b1) (union (fv_tm_tm_tm b2) (fv_tm_tm_co g2)))
        → x2 `notin` union (dom G) (union (fv_tm_tm_tm b2) (union (fv_tm_tm_tm b3) (fv_tm_tm_co g1)))
          → AnnDefEq G D g1 A1 A2
            → AnnDefEq ([(x1, Tm A1)]++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
              → open_tm_wrt_tm b3 (a_Var_f x2) = open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1))
                  → AnnTyping G A2 a_Star
                    → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
                      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
                        → AnnTyping G (a_Abs rho A1 b2) B
                          → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

 Lemma An_CPiCong_exists2
      : ∀ (c : atom) (G : context) (D : available_props)
        (g1 g3 : co) (phi1 : constraint) (B1 : tm)
        (phi2 : constraint) (B3 B2 : tm),
        AnnIso G D g1 phi1 phi2
        → c
          `notin` (union (dom G)
                   (union D
                    (union (fv_co_co_tm B2)
                       (union (fv_co_co_tm B1)
                          (union (fv_co_co_co g3)
                              (union (fv_co_co_co g1)
                                     (fv_co_co_tm B3)))))))
          → AnnDefEq ([(c, Co phi1)] ++ G) D
                     (open_co_wrt_co g3 (g_Var_f c))
                     (open_tm_wrt_co B1 (g_Var_f c))
                     (open_tm_wrt_co B2 (g_Var_f c))
          → open_tm_wrt_co B3 (g_Var_f c) =
            open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1))
          → AnnTyping G (a_CPi phi1 B1) a_Star
          → AnnTyping G (a_CPi phi1 B2) a_Star
          → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1) (a_CPi phi2 B3).

End fc_invert. *)
(* FcEtt.fc_unique:
Require Import FcEtt.sigs.

Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.
Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Require Import FcEtt.ett_par.

Module fc_unique (wf : fc_wf_sig) (subst : fc_subst_sig) <: fc_unique_sig.
Import wf subst.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Hint Resolve AnnCtx_uniq.
Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Ltac apply_ind a :=
  match goal with
  | H : (forall A2 : tm, AnnTyping ?G a A2 -> ?B = A2), Y : AnnTyping ?G a ?C |- _  =>
    apply H in Y; inversion Y
  | H : forall A B, AnnDefEq ?G ?D a A B -> ?A1 = A /\ ?B1 = B, Y : AnnDefEq ?G ?D a ?A2 ?B2 |- _ =>
    apply H in Y; split_hyp; subst
  | H : ∀ q1 q2 : constraint, AnnIso ?G ?D a q1 q2 → ?phi1 = q1 ∧ ?phi2 = q2,
    Y : AnnIso ?G ?D a ?q1 ?q2 |- _ =>
apply H in Y; split_hyp; subst

end.

Ltac apply_ind_var c a :=
      match goal with
        | H7 : ∀ c : atom,
            ¬ c `in` ?L0
                   → AnnTyping ?G (open_tm_wrt_co a (g_Var_f c)) ?B,
          H0 : ∀ c : atom,
            ¬ c `in` ?L
             → ∀ A2 : tm,
          AnnTyping ?G (open_tm_wrt_co a (g_Var_f c)) A2 → ?C = A2 |- _ =>
  specialize H7 with c; apply H0 in H7; eauto
       | H8 : ∀ x : atom,
       ¬ x `in` ?L0
       → AnnDefEq ?G ?D (open_co_wrt_tm a (a_Var_f x)) ?B0 ?B5,
        H0 : ∀ x : atom,
       ¬ x `in` ?L
       → ∀ a1 b1 : tm,
         AnnDefEq ?G ?D (open_co_wrt_tm a (a_Var_f x)) a1 b1
         → ?B1 = a1 ∧ ?B2  = b1 |- _ =>
  specialize H8 with c; edestruct (H0 c); eauto
  end.

Ltac equate_bodies x :=
      match goal with
        H11 : ∀ x : atom,
          ¬ x `in` ?L0 → open_tm_wrt_tm ?B4 (a_Var_f x) = open_tm_wrt_tm ?B2 ?C,
    e : ∀ x : atom, ¬ x `in` ?L → open_tm_wrt_tm ?B3 (a_Var_f x) =
                                  open_tm_wrt_tm ?B2 ?C
    |- _ =>
        let FR := fresh in
        let FR2 := fresh in
        specialize H11 with x;
        assert (FR: ¬ x `in` L0); eauto; apply H11 in FR;
        specialize e with x;
        assert (FR2 : ¬ x `in` L); eauto; apply e in FR2;
        rewrite -FR in FR2;
        apply open_tm_wrt_tm_inj in FR2; try fsetdec_fast
        end.

Ltac resolve_binds_unique :=
  let EQ := fresh in
  let h  := fresh in
  match goal with
  |   b : binds ?c ?A ?G,  H4 : binds ?c ?B ?G  |- _  =>
      assert (EQ : uniq G); eauto using AnnCtx_uniq,uniq_an_toplevel;
      move: (binds_unique _ _ _ _ _ b H4 EQ) => h; inversion h
  end.

Lemma unique_mutual :
  (forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2) /\
  (forall G phi, AnnPropWff G phi -> True) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 -> forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2) /\
  (forall G D g a b, AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1) /\
  (forall G, AnnCtx G -> True).

Definition AnnTyping_unique := first unique_mutual.
Definition AnnDefEq_unique  := fourth unique_mutual.
Definition AnnIso_unique    := third unique_mutual.

Ltac resolve_unique_subst  :=
  match goal with
  |   _ : AnnTyping ?G ?a ?A,  H :AnnTyping ?G ?a ?B  |- _  =>
      assert (A = B); try (eapply (first unique_mutual); eauto 1); subst; clear H
  |   H1 : AnnDefEq ?G ?D ?g ?A1 ?B1,  H2 :AnnDefEq ?G ?D ?g ?A2 ?B2  |- _  =>
      destruct (fourth unique_mutual _ _ _ _ _ H1 _ _ H2); subst; clear H2
  end.

Ltac resolve_unique_nosubst  :=
  match goal with
  |   H1 : AnnTyping ?G ?a ?A,  H2 :AnnTyping ?G ?a ?B  |- _  =>
      assert (A = B); [ eapply (first unique_mutual);
                          [eapply H1 | eapply H2]|]; subst B; clear H2
  |   H1 : AnnDefEq ?G ?D ?g ?A1 ?B1,  H2 :AnnDefEq ?G ?D ?g ?A2 ?B2  |- _  =>
      destruct (fourth unique_mutual _ _ _ _ _ H1 _ _ H2);
      try subst A2; try subst B2; try subst A1; try subst B1;
      clear H2
  end.

Lemma no_reduction_mutual :
  (forall a, CoercedValue a -> forall G b, not (head_reduction G a b)) /\
  (forall a, Value a -> forall G b, not (head_reduction G a b)).
Lemma no_Value_reduction : forall a, Value a -> forall G b, not (head_reduction G a b).
Lemma no_CoercedValue_reduction : forall a, CoercedValue a -> forall G b, not (head_reduction G a b).

Lemma head_reduction_deterministic :
  forall G a a1, head_reduction G a a1 -> forall a2, head_reduction G a a2 -> a1 = a2.

End fc_unique. *)
Require Import FcEtt.ett_par.
(* FcEtt.ett_par:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Import FcEtt.utils.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ext_context_fv.

Require Import FcEtt.ext_wf.
Import ext_wf.

Require Import FcEtt.erase_syntax.

Require Export FcEtt.toplevel.

Require Export FcEtt.ett_value.

Inductive multipar S D ( a : tm) : tm -> Prop :=
| mp_refl : multipar S D a a
| mp_step : forall b c, Par S D a b -> multipar S D b c -> multipar S D a c.

Hint Constructors multipar.

Ltac erased_pick_fresh x :=
  match goal with
    [ |- erased_tm ?s ] =>
    let v := match s with
             | a_UAbs _ _  => erased_a_Abs
             | a_Pi _ _ _  => erased_a_Pi
             | a_CPi _ _   => erased_a_CPi
             | a_UCAbs _   => erased_a_CAbs
             end
    in pick fresh x and apply v
  end.

Ltac erased_inversion :=
  repeat match goal with
  | [H : erased_tm (a_UAbs _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_App _ _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_Pi _ _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_CPi _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_UCAbs _ ) |- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_CApp _ _)|- _ ] =>
    inversion H; subst; clear H
end.

Ltac erased_case :=
  let x := fresh in
  let h0 := fresh in
  erased_pick_fresh x; eauto using lc_erase;
  match goal with
    [ H : forall x, erased_tm (erase (open_tm_wrt_tm ?b (a_Var_f x))) |- _ ] =>
    move: (H x) => h0; rewrite <- open_tm_erase_tm in h0; eauto
  | [ H : ∀ c, erased_tm (erase (open_tm_wrt_co ?b (g_Var_f c))) |- _ ] =>
    move: (H x) => h0; rewrite <- open_co_erase_tm2 with (g := (g_Var_f x)) in h0; auto
  end.

Inductive erased_sort : sort -> Prop :=
| erased_Tm : forall a, erased_tm a -> erased_sort (Tm a)
| erased_Co : forall a b A, erased_tm a -> erased_tm b -> erased_tm A -> erased_sort (Co (Eq a b A)).

Definition erased_context : context -> Prop :=
  Forall (fun p => match p with (a,s) => erased_sort s end).

Definition joins S D a b := exists c, erased_context S /\ erased_tm a /\ erased_tm b /\
                               multipar S D a c /\ multipar S D b c.

Lemma erased_lc : forall a, erased_tm a -> lc_tm a.

Hint Resolve erased_lc : lc.

Lemma subst_tm_erased : forall x b, erased_tm b -> forall a , erased_tm a -> erased_tm (tm_subst_tm_tm b x a).

Lemma erased_a_Abs_exists : ∀  (rho : relflag) (a : tm) x,
                x `notin` fv_tm_tm_tm a
              → erased_tm (open_tm_wrt_tm a (a_Var_f x))
              → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
              → erased_tm (a_UAbs rho a).

Lemma erased_a_Abs_inversion : forall rho a, 
     erased_tm (a_UAbs rho a) -> forall x, x `notin` fv_tm_tm_tm a 
  -> erased_tm (open_tm_wrt_tm a (a_Var_f x)) /\ RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)).

Lemma subst_co_erased : forall c g a , lc_co g -> erased_tm a -> erased_tm (co_subst_co_tm g c a).

Hint Resolve subst_tm_erased subst_co_erased : erased.

Lemma erased_a_CAbs_inversion : forall b, 
     erased_tm (a_UCAbs b) -> forall c, c `notin` fv_co_co_tm b 
  -> erased_tm (open_tm_wrt_co b (g_Var_f c)).

Lemma Par_lc1 : forall G D a a' , Par G D a a' -> lc_tm a.

Ltac lc_toplevel_inversion :=
  match goal with
  | [ b : binds ?F _ toplevel |- _ ] =>
    apply Toplevel_lc in b; inversion b; auto
end.

Lemma Par_lc2 : forall G D a a' , Par G D a a' -> lc_tm a'.

Hint Resolve Par_lc1 Par_lc2 : lc.

Lemma typing_erased_mutual:
    (forall G b A, Typing G b A -> erased_tm b) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall A B T, phi = Eq A B T -> erased_tm A /\ erased_tm B /\ erased_tm T) /\
     (forall G0 D p1 p2 (H : Iso G0 D p1 p2), True ) /\
     (forall G0 D A B T (H : DefEq G0 D A B T), True) /\
     (forall G0 (H : Ctx G0), True).

Lemma Typing_erased: forall G b A, Typing G b A -> erased_tm b.

Hint Resolve Typing_erased : erased.

Lemma typing_erased_type_mutual:
    (forall G b A, Typing G b A -> erased_tm A) /\
    (forall G0 phi (H : PropWff G0 phi), True) /\
     (forall G0 D p1 p2 (H : Iso G0 D p1 p2), True ) /\
     (forall G0 D A B T (H : DefEq G0 D A B T), True) /\
     (forall G0 (H : Ctx G0), erased_context G0).

Lemma Typing_erased_type : forall G b A, Typing G b A -> erased_tm A.

Hint Resolve Typing_erased_type : erased.

Lemma toplevel_erased1 : forall F a A, binds F (Ax a A) toplevel -> erased_tm a.
Lemma toplevel_erased2 : forall F a A, binds F (Ax a A) toplevel -> erased_tm A.

Hint Resolve toplevel_erased1 toplevel_erased2 : erased.

Ltac erased_body x Ea :=
    match goal with
     | [ H4 : ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_tm ?a (a_Var_f x))
                         |- _ ] =>
      move: (H4 x ltac:(auto)) => Ea; clear H4
     | [ H4 : ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_co ?a (g_Var_f x))
                         |- _ ] =>
      move: (H4 x ltac:(auto)) => Ea; clear H4
    end.

Ltac eta_eq y EQ :=
   match goal with
     | [ H : ∀ x : atom, x `notin` ?L → open_tm_wrt_tm ?a (a_Var_f x) =
                           a_App ?b ?rho _ |- _ ] =>
        move: (H y ltac:(auto)) =>  EQ
end.

Lemma Par_fv_preservation: forall G D x a b, Par G D a b ->
                                        x `notin` fv_tm_tm_tm a ->
                                        x `notin` fv_tm_tm_tm b.
Proof.
  intros.
  induction H; eauto 2; simpl.
  all: simpl in H0.
  all: try solve [move => h0; apply AtomSetFacts.union_iff in h0; case: h0 => h0; eauto; apply IHreduction_in_one; auto].
  all: try auto.
  - simpl in *.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_tm a' b') => h0.
    apply fv_tm_tm_tm_open_tm_wrt_tm_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec_fast.
    fsetdec_fast.
    auto.
  - rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper.
    fsetdec.
  - have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a' g_Triv) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec.
    auto.
  - pick fresh x0.
    assert (Fl : x0 `notin` L). auto.
    assert (Fa : x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0))).
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper. auto.
    move: (H1 x0 Fl Fa) => h0.
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto. 
  - pick fresh x0.
    have na': x `notin` fv_tm_tm_tm A'. eauto.
    have nb: x `notin` fv_tm_tm_tm (open_tm_wrt_tm B (a_Var_f x0)).
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper. eauto.
    have nob': x `notin` fv_tm_tm_tm (open_tm_wrt_tm B' (a_Var_f x0)). eauto.
    have nb': x `notin` fv_tm_tm_tm B'.
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto.
    eauto.
  - pick_fresh c0.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have K:= H1 c0 ltac:(auto) h0.
    move => h1.
    apply K. auto.
    apply fv_tm_tm_tm_open_tm_wrt_co_lower; auto.
  - pick fresh c0 for L.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have h2: x `notin` fv_tm_tm_tm (open_tm_wrt_co a' (g_Var_f c0)). eauto.
    move: (fv_tm_tm_tm_open_tm_wrt_co_lower a' (g_Var_f c0)) => h3.
    have h4: x `notin` fv_tm_tm_tm a'. fsetdec.

    move => h1.
    apply AtomSetFacts.union_iff in h1.
    case: h1 => h1; eauto.
    apply AtomSetFacts.union_iff in h1.

Lemma Par_fv_co_preservation: forall G D x a b, Par G D a b ->
                                        x `notin` fv_co_co_tm a ->
                                        x `notin` fv_co_co_tm b.
Proof.
  intros.
  induction H; eauto 2; simpl.
  all: simpl in H0.
  all: try solve [move => h0; apply AtomSetFacts.union_iff in h0; case: h0 => h0; eauto; apply IHreduction_in_one; auto].
  all: try auto.
  - simpl in *.
    have: x `notin` fv_co_co_tm (open_tm_wrt_tm a' b') => h0.
    apply fv_co_co_tm_open_tm_wrt_tm_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec_fast.
    fsetdec_fast.
    auto.
  - rewrite fv_co_co_tm_open_tm_wrt_tm_upper.
    fsetdec.
  - have: x `notin` fv_co_co_tm (open_tm_wrt_co a' g_Triv) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec.
    auto.
  - pick fresh x0.
    assert (Fl : x0 `notin` L). auto.
    assert (Fa : x `notin` fv_co_co_tm (open_tm_wrt_tm a (a_Var_f x0))).
    rewrite fv_co_co_tm_open_tm_wrt_tm_upper. auto.
    move: (H1 x0 Fl Fa) => h0.
    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto. 
  - pick fresh x0.
    have na': x `notin` fv_co_co_tm A'. eauto.
    have nb: x `notin` fv_co_co_tm (open_tm_wrt_tm B (a_Var_f x0)).
    rewrite fv_co_co_tm_open_tm_wrt_tm_upper. eauto.
    have nob': x `notin` fv_co_co_tm (open_tm_wrt_tm B' (a_Var_f x0)). eauto.
    have nb': x `notin` fv_co_co_tm B'.
    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto.
    eauto.
  - pick_fresh c0.
    have: x `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have K:= H1 c0 ltac:(auto) h0.
    move => h1.
    apply K. auto.
    apply fv_co_co_tm_open_tm_wrt_co_lower; auto.
  - pick fresh c0.
    have: x `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0. assert (Q: c0 `notin` singleton x). fsetdec. clear Fr.
    fsetdec.
    have h2: x `notin` fv_co_co_tm (open_tm_wrt_co a' (g_Var_f c0)). eauto.
    move: (fv_co_co_tm_open_tm_wrt_co_lower a' (g_Var_f c0)) => h3.
    have h4: x `notin` fv_co_co_tm a'. fsetdec.
    move => h1.
    apply AtomSetFacts.union_iff in h1.
    case: h1 => h1; eauto.
    apply AtomSetFacts.union_iff in h1.

Lemma Par_erased_tm : forall G D a a', Par G D a a' -> erased_tm a -> erased_tm a'.

Hint Resolve Par_erased_tm : erased. 

Lemma subst1 : forall b S D a a' x, Par S D a a' -> erased_tm b ->
                           Par S D (tm_subst_tm_tm a x b) (tm_subst_tm_tm a' x b).

Lemma open1 : forall b S D a a' L, Par S D a a'
  -> (forall x, x `notin` L -> erased_tm (open_tm_wrt_tm b (a_Var_f x)))
  -> Par S D (open_tm_wrt_tm b a) (open_tm_wrt_tm b a').

Lemma subst2 : forall S D b x, lc_tm b ->
  forall a a', Par S D a a' -> Par S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b x a').

Lemma subst3 : forall S D b b' x,
    Par S D b b' ->
    forall a a', erased_tm a -> Par S D a a' ->
    Par S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b' x a').

Lemma subst4 : forall S D b x, lc_co b ->
    forall a a', Par S D a a' ->
    Par S D (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Lemma multipar_subst3 : forall S D b b' x, erased_tm b ->
    multipar S D b b' ->
    forall a a', erased_tm a -> multipar S D a a' ->
    multipar S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b' x a').

Lemma multipar_subst4 : forall S D b x, lc_co b ->
    forall a a', multipar S D a a' ->
    multipar S D (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Lemma erased_tm_open_tm_wrt_tm: forall a x, erased_tm a -> erased_tm (open_tm_wrt_tm a (a_Var_f x)).

Hint Resolve erased_tm_open_tm_wrt_tm : erased.

Lemma Par_Pi_exists: ∀ x (G : context) D rho (A B A' B' : tm),
    x `notin` fv_tm_tm_tm B -> Par G D A A'
    → Par G D (open_tm_wrt_tm B (a_Var_f x)) B'
    → Par G D (a_Pi rho A B) (a_Pi rho A' (close_tm_wrt_tm x B')).

Lemma Par_CPi_exists:  ∀ c (G : context) D (A B a A' B' a' T T': tm),
       c `notin` fv_co_co_tm a -> Par G D A A'
       → Par G D B B' -> Par G D T T'
         → Par G D (open_tm_wrt_co a (g_Var_f c)) (a')
         → Par G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') (close_tm_wrt_co c a')).

Lemma Par_Abs_exists: ∀ x (G : context) D rho (a a' : tm),
    x `notin` fv_tm_tm_tm a
    → Par G D (open_tm_wrt_tm a (a_Var_f x)) a'
    → Par G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma Par_CAbs_exists: forall c (G : context) D (a a': tm),
       c `notin` fv_co_co_tm a
       -> Par G D (open_tm_wrt_co a (g_Var_f c)) a'
       → Par G D (a_UCAbs a) (a_UCAbs (close_tm_wrt_co c a')).

Lemma Par_EtaRel_exists : forall (G: context) D a b b' x,
   x `notin` union (fv_tm_tm_tm a) (fv_tm_tm_tm b) ->
   Par G D b b' ->
   (open_tm_wrt_tm a (a_Var_f x)) = a_App b Rel (a_Var_f x) ->
   Par G D (a_UAbs Rel a) b'.

Lemma Par_EtaRel_close : forall (G: context) D b b' x,
   x `notin` fv_tm_tm_tm b ->
   Par G D b b' ->
   Par G D (a_UAbs Rel (close_tm_wrt_tm x (a_App b Rel (a_Var_f x)))) b'.

Lemma Par_open_tm_wrt_co_preservation: forall G D B1 B2 c, Par G D (open_tm_wrt_co B1 (g_Var_f c)) B2 -> exists B', B2 = open_tm_wrt_co B' (g_Var_f c) /\ Par G D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B' (g_Var_f c)).

Lemma Par_open_tm_wrt_tm_preservation: forall G D B1 B2 x, Par G D (open_tm_wrt_tm B1 (a_Var_f x)) B2 -> exists B', B2 = open_tm_wrt_tm B' (a_Var_f x) /\ Par G D (open_tm_wrt_tm B1 (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x)).

Lemma multipar_Pi_exists: ∀ x (G : context) D rho (A B A' B' : tm),
       lc_tm (a_Pi rho A B) -> x `notin` fv_tm_tm_tm B -> multipar G D A A'
       → multipar G D (open_tm_wrt_tm B (a_Var_f x)) B'
       → multipar G D (a_Pi rho A B) (a_Pi rho A' (close_tm_wrt_tm x B')).

Lemma multipar_Pi_A_proj: ∀ (G : context) D rho (A B A' B' : tm),
    lc_tm A -> multipar G D (a_Pi rho A B) (a_Pi rho A' B')
    -> multipar G D A A'.

Lemma multipar_Pi_B_proj: ∀ (G : context) D rho (A B A' B' : tm),
    multipar G D (a_Pi rho A B) (a_Pi rho A' B')
    → (exists L, forall x, x `notin` L -> multipar G D (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x))).

Lemma multipar_CPi_exists:  ∀ c (G : context) D (A B a T A' B' a' T': tm),
       lc_tm (a_CPi (Eq A B T) a) -> c `notin` fv_co_co_tm a -> multipar G D A A'
       → multipar G D B B' -> multipar G D T T'
         → multipar G D (open_tm_wrt_co a (g_Var_f c)) a'
         → multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') (close_tm_wrt_co c a')).

Lemma multipar_CPi_B_proj:  ∀ (G : context) D (A B a A' B' a' T T': tm),
    multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') a')
  → (exists L, forall c, c `notin` L -> multipar G D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c))).

Lemma multipar_CPi_phi_proj:  ∀ (G : context) D (A B a A' B' a' T T': tm),
    multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') a')
    -> (multipar G D A A'/\ multipar G D B B' /\ multipar G D T T').

Lemma multipar_Abs_exists: ∀ x (G : context) D rho (a a' : tm),
       lc_tm (a_UAbs rho a) -> x `notin` fv_tm_tm_tm a
       → multipar G D (open_tm_wrt_tm a (a_Var_f x)) a'
       → multipar G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma multipar_CAbs_exists: forall c (G : context) D (a a': tm),
       lc_tm (a_UCAbs a) -> c `notin` fv_co_co_tm a
       -> multipar G D (open_tm_wrt_co a (g_Var_f c)) a'
       → multipar G D (a_UCAbs a) (a_UCAbs (close_tm_wrt_co c a')).

Lemma multipar_open_tm_wrt_co_preservation: forall G D B1 B2 c, multipar G D (open_tm_wrt_co B1 (g_Var_f c)) B2 -> exists B', B2 = open_tm_wrt_co B' (g_Var_f c) /\ multipar G D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B' (g_Var_f c)).

Lemma multipar_open_tm_wrt_tm_preservation: forall G D B1 B2 x, multipar G D (open_tm_wrt_tm B1 (a_Var_f x)) B2 -> exists B', B2 = open_tm_wrt_tm B' (a_Var_f x) /\ multipar G D (open_tm_wrt_tm B1 (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x)).

Lemma context_Par_irrelevance: forall G1 G2 D1 D2 a a',
                                             Par G1 D1 a a' -> Par G2 D2 a a'.

Lemma multipar_context_independent: forall G1 G2 D A B,  multipar G1 D A B -> multipar G2 D A B.

Lemma Par_weaken_available :
  forall G D a b, Par G D a b -> forall D', D [<=] D' -> Par G D' a b.

Lemma Par_respects_atoms:
  forall G D a b, Par G D a b -> forall D', D [=] D' -> Par G D' a b.

Lemma Par_availability_independence: forall G D1 D2 a b, Par G D1 a b -> Par G D2 a b.

Lemma Par_remove_available:
  forall G D a b, Par G D a b -> Par G (AtomSetImpl.inter D (dom G)) a b.

Lemma Par_weakening :
  forall G0 D a b, Par G0 D a b ->
  forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) ->  Par (F ++ E ++ G) D a b. *)
Require Import FcEtt.toplevel.
(* FcEtt.toplevel:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.
Require Import FcEtt.utils.

Require Export FcEtt.fix_typing.

Lemma uniq_an_toplevel : uniq an_toplevel.
Lemma uniq_toplevel : uniq toplevel.

Lemma toplevel_closed : forall F a A, binds F (Ax a A) toplevel ->
                                 Typing nil a A.

Lemma toplevel_to_const : forall T A, binds T (Cs A) toplevel -> Typing nil A a_Star.

Lemma an_toplevel_closed : forall F a A, binds F (Ax a A) an_toplevel ->
                                    AnnTyping nil a A.

Lemma an_toplevel_to_const : forall T A, binds T (Cs A) an_toplevel -> AnnTyping nil A a_Star.

Lemma binds_to_type : forall S T A, AnnSig S -> binds T (Cs A) S -> DataTy A a_Star. *)
Require Import FcEtt.fc_context_fv.
(* FcEtt.fc_context_fv:
Require Export FcEtt.tactics.
Require Export FcEtt.ett_inf.

Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Import FcEtt.ett_ind.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Hint Resolve AnnCtx_uniq.
Hint Unfold AtomSetImpl.Subset.

Ltac solve_binds :=
  match goal with
    | [ b : binds ?v _ ?G
      , H : forall v' _, binds v' _ ?G -> _ [<=] dom ?G ∧ _ [<=] dom ?G
      |- _ ] =>
      apply H in b; simpl in b; split_hyp; (done || fsetdec)
  end.

Theorem ann_context_fv_mutual :
  (forall G (a : tm) A (H: AnnTyping G a A),
      fv_tm_tm_tm a [<=] dom G /\ fv_co_co_tm a [<=] dom G /\
      fv_tm_tm_tm A [<=] dom G /\ fv_co_co_tm A [<=] dom G)
  /\
  (forall G phi (H : AnnPropWff G phi),
      fv_tm_tm_constraint phi [<=] dom G /\ fv_co_co_constraint phi [<=] dom G)
  /\
  (forall G D g p1 p2 (H : AnnIso G D g p1 p2),
      fv_tm_tm_co         g  [<=] dom G /\ fv_co_co_co         g  [<=] dom G /\
      fv_tm_tm_constraint p1 [<=] dom G /\ fv_co_co_constraint p1 [<=] dom G /\
      fv_tm_tm_constraint p2 [<=] dom G /\ fv_co_co_constraint p2 [<=] dom G)
  /\
  (forall G D g A B (H : AnnDefEq G D g A B),
      fv_tm_tm_co g [<=] dom G /\ fv_co_co_co g [<=] dom G /\
      fv_tm_tm_tm A [<=] dom G /\ fv_co_co_tm A [<=] dom G /\
      fv_tm_tm_tm B [<=] dom G /\ fv_co_co_tm B [<=] dom G)
  /\
  (forall G (H : AnnCtx G),
      (forall x A,
          binds x (Tm A)   G ->
          fv_tm_tm_tm         A   [<=] dom G /\ fv_co_co_tm         A   [<=] dom G) /\
      (forall c phi,
          binds c (Co phi) G ->
          fv_tm_tm_constraint phi [<=] dom G /\ fv_co_co_constraint phi [<=] dom G)).

Definition AnnTyping_context_fv  := @first  _ _ _ _ _ ann_context_fv_mutual.
Definition AnnPropWff_context_fv := @second _ _ _ _ _ ann_context_fv_mutual.
Definition AnnIso_context_fv     := @third  _ _ _ _ _ ann_context_fv_mutual.
Definition AnnDefEq_context_fv   := @fourth _ _ _ _ _ ann_context_fv_mutual.
Definition AnnCtx_context_fv     := @fifth  _ _ _ _ _ ann_context_fv_mutual. *)

Module erase (wf : fc_wf_sig) (weak : fc_weak_sig) (subst : fc_subst_sig)
             (e_invert : ext_invert_sig).

Include e_invert.

Module e_red := ext_red e_invert.
Import e_red.

Import wf weak subst.

Module invert := fc_invert wf weak subst.
Module unique := fc_unique wf subst.
Import invert unique.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma Path_erase : forall T a, Path T a -> Path T (erase a).
Proof. induction 1; try destruct rho; simpl; auto.
       autorewcs.
       eauto with lc.
Qed.

Hint Constructors Typing PropWff Iso DefEq Ctx.

Ltac dispatch_rho  :=
  match goal with
  |  H11 : ∀ x : atom,
      ¬ x `in` ?L0 →
             RhoCheck ?rho x (erase_tm (open_tm_wrt_tm ?b1 (a_Var_f x)))
             |-
             ∀ x : atom,
               ¬ x `in` ?LL → RhoCheck ?rho x (open_tm_wrt_tm (erase_tm ?b1) (a_Var_f x))
           =>
   let Fr := fresh in
   let r' := fresh in
   intros x; intros;
   assert (FrL0 : x `notin` L0); eauto;
   move: (H11 x FrL0) => r';
   autorewcshyp r';
   rewrite -open_tm_erase_tm in r'; eapply r'
end.

Lemma erase_mutual :
  (forall G a A, AnnTyping G a A ->
          Typing (erase_context G) (erase a) (erase A)) /\
  (forall G phi, AnnPropWff G phi ->
          PropWff (erase_context G) (erase phi)) /\
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
          Iso (erase_context G) D
              (erase_constraint p1) (erase_constraint p2)) /\
  (forall G D g a b,
      AnnDefEq G D g a b ->
      forall A, AnnTyping G a A ->
             DefEq (erase_context G) D (erase a) (erase b) (erase A)) /\
  (forall G, AnnCtx G -> Ctx (erase_context G) /\
    forall c t, binds c t G -> binds c (erase_sort t) (erase_context G)).
Proof.
  eapply ann_typing_wff_iso_defeq_mutual.
  all:  intros; split_hyp; try solve [simpl; split_hyp; auto; eauto 2].
  - eapply E_Var; auto.
    rewrite -[Tm (erase _)]/(erase_sort (Tm _)) /erase_context.
    apply binds_map_2.
    auto.
  - simpl. pick fresh x and apply E_Pi; auto.
    replace (a_Var_f x) with (erase (a_Var_f x)); auto.
    rewrite open_tm_erase_tm.
    rewrite_env (erase_context ((x ~ Tm A) ++ G)).
    eapply H. auto.
  - simpl.
    pick fresh x and apply E_Abs; auto.
    assert (FrL : x `notin` L). auto.
    pose (J := H0 x FrL).
    rewrite <- open_tm_erase_tm in J.
    rewrite <- open_tm_erase_tm in J.
    unfold erase_context in J.
    rewrite map_app in J.
    simpl in J. auto.
    assert (FrL : x `notin` L). auto.
    move: (r x FrL) => r'.
    autorewcshyp r'.
    rewrite -open_tm_erase_tm in r'.
    eapply r'.
  - rewrite -open_tm_erase_tm.
    simpl in H. simpl.
    destruct rho; simpl; eauto.
  - 
    simpl. autorewcs.
    eapply E_Conv; eauto 1.
    rewrite <- erase_dom.
    pose KA := AnnTyping_regularity a0. clearbody KA.
    eapply (H0 a_Star).
    auto.
  - simpl. pick fresh x and apply E_CPi; eauto.
    autorewcs.
    rewrite (open_co_erase_tm2 (g_Var_f x)).
    rewrite_env (erase_context ((x ~ Co phi) ++ G)).
    eauto.
  - pick fresh x and apply E_CAbs; auto.
    assert (FrL : x `notin` L). auto.
    pose (J := H0 x FrL).
    rewrite (open_co_erase_tm2 (g_Var_f x)).
    rewrite (open_co_erase_tm2 (g_Var_f x)).
    auto.
  - rewrite -(open_co_erase_tm2 _ _ g_Triv) /=.
    pose K := AnnTyping_regularity a0. clearbody K. inversion K. inversion H4. subst.
    eapply E_CApp. simpl in H. eauto.
    rewrite <- erase_dom.
    eapply H0; eauto.
  - simpl. eapply E_Const; eauto.
    unfold toplevel.
    unfold erase_sig.
    replace (Cs (erase_tm A)) with (erase_csort (Cs A)). eapply binds_map. auto. auto.
  - simpl. eapply E_Fam; eauto.
    unfold toplevel.
    unfold erase_sig.
    replace (Ax (erase_tm a) (erase_tm A)) with (erase_csort (Ax a A)); auto.
  - simpl.
    econstructor; autorewcs.
    + eauto.
    + autorewcshyp e.
        by rewrite e.
    + eapply Typing_regularity; eauto 1.
  - assert (Ctx (erase_context G)). eauto.
    simpl in *. inversion a1. inversion a2. subst.
    eapply E_PropCong. eapply H; eauto. rewrite H10. eapply H0; eauto.
  - destruct (AnnDefEq_regularity a) as [S1 [S2 [g' [AT1 [AT2 _]]]]].
    inversion AT1. inversion AT2. subst.
    destruct phi1. destruct phi2. simpl in *.
    eapply E_CPiFst. eapply (H a_Star); eauto.
  - eapply sym_iso. auto.
  - simpl. rewrite e. rewrite e0.
    inversion a0.
    inversion H0. subst.
    simpl in *. eapply E_IsoConv; eauto 1.
    eapply (H a_Star).  eapply AnnTyping_regularity. eauto.
    inversion H1. subst.
    eapply E_Wff; eauto 1. eapply E_Conv; eauto 1.
    eapply E_Sym. eapply DefEq_weaken_available. eapply (H a_Star). eauto 1.
    eapply AnnTyping_regularity. eauto.
     eapply E_Conv; eauto 1.
    eapply E_Sym. eapply DefEq_weaken_available. eapply (H a_Star). eauto 1.
    eapply AnnTyping_regularity. eauto.
  - pose K:= (binds_to_AnnPropWff _ _ _ _ a0 b0). clearbody K. inversion K. subst.
    resolve_unique_nosubst.
    pose M := H1 c (Co (Eq a b A0)) b0.
    eapply E_Assn; eauto.
  - simpl.
    resolve_unique_nosubst.
    subst.
    eapply E_Refl; auto.
  - resolve_unique_nosubst.
    assert (K :Ctx (erase_context G)) . eauto.
    pose R1 := AnnTyping_regularity a0.
    pose R2 := AnnTyping_regularity a1.
    simpl. rewrite -e.
    eapply E_Refl; eauto.
  - eapply E_Sym.
    resolve_unique_nosubst.
    pose R1 := AnnTyping_regularity a0.
    pose R2 := AnnTyping_regularity a1.
    pose K1 := H1 a_Star R1. clearbody K1. simpl in K1.
    pose K2 := H2 B a0. clearbody K2.
    eapply DefEq_conv. eauto.
  rewrite <- erase_dom. auto.
  - 
    destruct (AnnDefEq_regularity a0) as [S1 [S2 [g4 [T1 [T2 DE]]]]].
    destruct (AnnDefEq_regularity a2) as [S1' [S2' [g4' [T1' [T2' DE']]]]].
    resolve_unique_nosubst.
    resolve_unique_nosubst.
    resolve_unique_nosubst.
    resolve_unique_nosubst.
    eapply E_Trans. eauto.
    eapply DefEq_conv. eauto.
    rewrite <- erase_dom.
    eapply E_Sym. eapply (H3 a_Star).
    eapply AnnTyping_regularity. eauto.
  - simpl.
    assert (Ctx (erase_context G)). eauto.
    resolve_unique_nosubst.
    eapply E_Beta. auto. auto. rewrite e. eauto. eauto.
  - 
    assert (A = a_Star). eapply AnnTyping_unique; eauto. subst.
    simpl.
    inversion a1. subst.
    eapply (E_PiCong (L \u L0)); try solve [simpl in *; eauto 2].
    + eapply (H a_Star). auto.
    + intros x Fr. assert (FrL : x `notin` L). auto.
      pose K := H0 x FrL a_Star. clearbody K. clear H0.
      rewrite -open_tm_erase_tm in K.
      simpl.
      simpl in K.
      have: a_Var_f x  = erase (a_Var_f x) by done.
      move=> ->.
      rewrite (open_tm_erase_tm B3) e.
      rewrite -(open_tm_erase_tm B2). simpl.
      have: a_Var_f x  = erase (a_Var_f x) by done.
      move=> ->.
      rewrite (open_tm_erase_tm B2).
      simpl.
      eapply K.
      eapply H8. auto. auto.
   + simpl in H1. eapply invert_a_Pi. eauto.
  - simpl.
    inversion H4. subst. simpl.
    eapply (E_AbsCong (L \u L0)) ; auto.
    intros x Fr.
    assert (FrL : x `notin` L). auto. assert (FrL0 : x `notin` L0). auto.
    assert (EQ: (erase (open_tm_wrt_tm b3 (a_Var_f x))) =
                (erase (open_tm_wrt_tm b2 (a_Var_f x)))).
       rewrite e.
       rewrite <- open_tm_erase_tm.
       rewrite <- open_tm_erase_tm.
       simpl. auto. auto.
    replace (a_Var_f x) with (erase (a_Var_f x)).
    rewrite open_tm_erase_tm.
    rewrite open_tm_erase_tm.
    rewrite open_tm_erase_tm.
    rewrite EQ.
    eapply (H0 x FrL (open_tm_wrt_tm B0 (a_Var_f x))).
    eapply H11; simpl; auto.
    simpl. auto.
    dispatch_rho.
    dispatch_rho.
  - simpl in *.
    resolve_unique_nosubst.
    destruct rho.
    + inversion a3. subst.
    rewrite <- open_tm_erase_tm.
    eapply E_AppCong.
    eapply (H (a_Pi Rel A0 B0)). eauto.
    eapply H0. auto.
    + inversion a3. subst.
      rewrite <- open_tm_erase_tm.
      move: (H _ H9) => h0.
      move: (H0 _ H10) => h1.
      move: (DefEq_regularity h1) => p1.
      inversion p1.
      eapply E_IAppCong; eauto.
  - simpl in *.

    destruct (AnnDefEq_regularity a) as [S1 [S2 [g' [TA1 [TA2 _]]]]].
    inversion TA1. subst.
    resolve_unique_nosubst.
    inversion TA2. subst.
    simpl.
    eapply E_PiFst. eapply (H a_Star). eauto.
  - rewrite <- open_tm_erase_tm.
    rewrite <- open_tm_erase_tm.
    simpl in *.
    destruct (AnnDefEq_regularity a) as [S1 [S2 [g' [TA1 [TA2 _]]]]].
    inversion TA1.
    assert (AnnTyping G (open_tm_wrt_tm B1 a1) a_Star).
    { pick fresh y.
      rewrite (tm_subst_tm_tm_intro y).
      replace a_Star with (tm_subst_tm_tm a1 y a_Star).
      eapply AnnTyping_tm_subst; auto.
      simpl. auto. auto. }
    resolve_unique_nosubst.
    eapply E_PiSnd; eauto 1.
    eapply (H a_Star). eauto.
    eapply (H0 A1). eauto.
  - 
    simpl.
    assert (a_Star = A). eapply (AnnTyping_unique a1). eauto. subst. clear H3.
    inversion a1.
    inversion a2. subst.
    eapply (E_CPiCong (L \u dom G \u L0 \u L1)); try solve [simpl in *; eauto 2].
    + intros c Fr. assert (FrL : c `notin` L). auto.
      pose K := a0 c FrL. clearbody K.
      rewrite (open_co_erase_tm2 (g_Var_f c)).
      rewrite (open_co_erase_tm2 g_Triv).
      assert (EQ: (erase (open_tm_wrt_co B3 (g_Var_f c))) =
                  (erase (open_tm_wrt_co B2 (g_Var_f c)))).
      rewrite e.
      rewrite <- open_co_erase_tm.
      rewrite <- open_co_erase_tm. auto. auto.
      rewrite <- (open_co_erase_tm2 g_Triv B3 (g_Var_f c)).
      rewrite (open_co_erase_tm2 (g_Var_f c)).
      rewrite EQ.
      eapply (H0 c FrL a_Star); auto.
    + simpl in H1. eapply invert_a_CPi. eauto.
  - simpl.
    inversion H5. subst.
    simpl.
    eapply (E_CAbsCong (L \u dom G \u L0)).
    + intros c Fr. assert (FrL : c `notin` L). auto.
      pose K := a0 c FrL. clearbody K.
      rewrite (open_co_erase_tm2 (g_Var_f c)).
      rewrite (open_co_erase_tm2 g_Triv).
      assert (EQ: (erase (open_tm_wrt_co a3 (g_Var_f c))) =
                  (erase (open_tm_wrt_co a2 (g_Var_f c)))).
      rewrite e.
      rewrite <- open_co_erase_tm.
      rewrite <- open_co_erase_tm. auto. auto.
      rewrite <- (open_co_erase_tm2 g_Triv a3 (g_Var_f c)).
      rewrite (open_co_erase_tm2 (g_Var_f c)).
      rewrite EQ.
      rewrite (open_co_erase_tm2 (g_Var_f c) B0).
      eapply (H0 c FrL (open_tm_wrt_co B0 (g_Var_f c))).
      eauto.
    + simpl in H1.
      have CT: Ctx (erase_context G) by eauto 2.
      move: (Typing_regularity H1) => TCPi.
      destruct (invert_a_CPi TCPi) as (_ & _ & P).
      eauto.
  - simpl.

    inversion H5. subst.
    inversion a5. subst.
    resolve_unique_subst.
    resolve_unique_subst.

    inversion H6. subst. clear H6. clear H7. clear H11.
    inversion a6. subst.
    autorewcs.
    rewrite <- (open_co_erase_tm2 _ _ g_Triv).
    apply AnnDefEq_weaken_available in a0.
    apply AnnDefEq_weaken_available in a4.
    resolve_unique_subst.
    resolve_unique_subst.
    pose K := AnnTyping_regularity H9. clearbody K.  inversion K.
    inversion H10. subst.
    pose K1 := AnnTyping_regularity H8. clearbody K1. inversion K1.
    inversion H12. subst.
    eapply E_CAppCong.
    move: (H _ H9) => h0. eapply h0. fold erase_tm.
    eapply DefEq_weaken_available. eauto.
  - simpl in H.
    rewrite <- (@open_co_erase_tm2  _ _ g_Triv).
    rewrite <- (@open_co_erase_tm2  _ _ g_Triv).
    simpl.
    destruct (AnnDefEq_regularity a0) as [S1 [S2 [g [AT1 [AT2 _]]]]].
    inversion AT1. subst.
    inversion H6. subst.
     assert (AnnTyping G (open_tm_wrt_co B1 g2) a_Star).
    { pick fresh y.
      rewrite (co_subst_co_tm_intro y).
      replace a_Star with (co_subst_co_tm g2 y a_Star).
      eapply AnnTyping_co_subst; auto.
      simpl. eauto. simpl. auto. auto. }
    resolve_unique_nosubst.
    eapply E_CPiSnd.
    eapply (H a_Star). auto. rewrite -erase_dom. auto.
    inversion AT2. inversion H7.
    rewrite -erase_dom. auto.
  - destruct (AnnIso_regularity a1) as [W1 W2]. inversion W1.  inversion W2. subst.
    resolve_unique_nosubst.
    eapply E_Cast. eauto. eauto.
  - destruct (AnnIso_regularity a0) as [W1 W2]. inversion W1.  inversion W2. subst.
    move: (AnnTyping_regularity H5) => ?.
    resolve_unique_nosubst. simpl.
    eapply E_IsoSnd. eauto.
  - simpl in *.
    destruct (An_Abs_inversion H0) as (B0 & h0 & h1 & h2). subst.
    pick fresh x. destruct (h2 x ltac:(auto)) as [RC h3].
    rewrite e in h3; auto.
    inversion h3. subst.
    have h4: AnnCtx G by eauto with ctx_wff.
    have h5: AnnCtx (nil ++ (x ~ Tm A) ++ G) by econstructor; eauto with ctx_wff.
    move: (AnnTyping_weakening a0 (x ~ Tm A) nil G eq_refl ltac:(auto)) => h0.
    simpl_env in h0.
    resolve_unique_subst. inversion H1. subst.
    apply open_tm_wrt_tm_inj in H6; auto. subst.
    simpl. destruct rho.
    + eapply E_EtaRel with (L := L \u {{x}}); auto.
    intros.
    replace (a_Var_f x0) with (erase (a_Var_f x0)).
    rewrite open_tm_erase_tm.
    rewrite e; auto.
    simpl; auto.
    + eapply E_EtaIrrel with (L := L \u {{x}}); auto.
    intros.
    replace (a_Var_f x0) with (erase (a_Var_f x0)).
    rewrite open_tm_erase_tm.
    rewrite e; auto.
    simpl; auto.
  - simpl in *.
    destruct (An_CAbs_inversion H0) as (B0 & h0 & h1). subst.
    pick fresh x. destruct (h1 x ltac:(auto)) as [RC h3].
    rewrite e in h3; auto.
    inversion h3. subst.
    have h4: AnnCtx G by eauto with ctx_wff.
    have h5: AnnCtx (nil ++ (x ~ Co phi) ++ G) by econstructor; eauto with ctx_wff.
    move: (AnnTyping_weakening a0 (x ~ Co phi) nil G eq_refl ltac:(auto)) => h0.
    simpl_env in h0. clear h4 h5.
    resolve_unique_subst. inversion H1. subst.
    apply open_tm_wrt_co_inj in H4; auto. subst.
    simpl. eapply E_EtaC with (L := L \u {{x}}); auto.
    intros.
    erewrite open_co_erase_tm2. 
    erewrite e; auto.

  - rewrite <- dom_map with (f:=erase_sort) in n.
    unfold erase_context in *.
    split.
    eapply E_ConsTm; auto.
    intros.
    destruct (@binds_cons_1 _ c x _ (Tm A) G H2) as [[E1 E2] | E3].
    + subst. simpl. eauto.
    + simpl. eapply binds_cons_3. auto.
  - rewrite <- dom_map with (f:=erase_sort) in n.
    unfold erase_context in *.
    split.
    eapply E_ConsCo; auto.
    intros.
    destruct (@binds_cons_1 _ c0 c _ (Co phi) G H2) as [[E1 E2] | E3].
    + subst. simpl. eauto.
    + simpl. eapply binds_cons_3. auto.
Qed.

Definition AnnTyping_erase :
  (forall G a A, AnnTyping G a A ->
            Typing (erase_context G) (erase a) (erase A)) := first erase_mutual.
Definition AnnPropWff_erase :
  (forall G phi, AnnPropWff G phi ->
            PropWff (erase_context G) (erase phi)) := second erase_mutual.
Definition AnnIso_erase :
  (forall G D g p1 p2, AnnIso G D g p1 p2 ->
          Iso (erase_context G) D
              (erase_constraint p1) (erase_constraint p2)) := third erase_mutual.
Definition AnnDefEq_erase :
  (forall G D g a b,
      AnnDefEq G D g a b ->
      forall A, AnnTyping G a A ->
           DefEq (erase_context G) D (erase a) (erase b) (erase A)) := fourth erase_mutual.
Definition AnnCtx_erase :
  (forall G, AnnCtx G -> Ctx (erase_context G) /\
    forall c t, binds c t G -> binds c (erase_sort t) (erase_context G)) := fifth erase_mutual.

Lemma erasure_a_Star :
  forall G a A, AnnTyping G a A -> erase A = a_Star ->
           exists a', erase a = erase a' /\ AnnTyping G a' a_Star.
Proof.
  intros G a A H H0.
  remember (g_Refl2 A a_Star (g_Refl a_Star)) as g.
  pose K := AnnTyping_regularity H.
  have L: AnnCtx G by eauto with ctx_wff.
  assert (AnnDefEq G (dom G) g A a_Star).
  { rewrite Heqg. eauto. }
  assert (AnnTyping G a_Star a_Star). eauto.
  exists (a_Conv a g). repeat split. eauto.
Qed.

Lemma erasure_cvt :
    forall G a A, AnnTyping G a A -> forall B, erase A = erase B -> AnnTyping G B a_Star ->
                                    exists a', erase a = erase a' /\ AnnTyping G a' B.
  Proof.
    intros G a A H B e TB.
    pose K := AnnTyping_regularity H. clearbody K.
    remember (g_Refl2 A B (g_Refl a_Star)) as g.
    assert (AnnDefEq G (dom G) g A B).
    { rewrite Heqg. eapply An_EraseEq. eauto. eauto. eauto. eapply An_Refl. eapply An_Star.
      eauto with ctx_wff. }
    remember (a_Conv a (g_Refl2 A B (g_Refl a_Star))) as a0'.
    assert (ATA' : AnnTyping G a0' B).
    { rewrite Heqa0'. rewrite <- Heqg. eapply An_Conv. eauto. eauto. eauto. }
    exists (a_Conv a g). eauto.
  Qed.

Lemma AnnDefEq_invertb : forall G D g a b, AnnDefEq G D g a b ->
  exists A b' g, AnnTyping G a A /\ AnnTyping G b' A /\ erase b' = erase b /\ AnnDefEq G D g b b'.
  Proof.
    intros G D g a b DE.
    destruct (AnnDefEq_regularity DE) as [SA [SB [g4 [AT0' [ATB0' SAB]]]]].
    exists SA. eexists. eexists.
    assert (AnnTyping G (a_Conv b (g_Sym g4)) SA).
    {     eapply An_Conv. eapply ATB0'.
          eapply An_Sym.
          eapply AnnTyping_regularity. eauto.
          eapply AnnTyping_regularity. eauto.
          eapply An_Refl. eapply An_Star.
          eauto with ctx_wff. eauto.
          eapply AnnTyping_regularity. eauto.
    }
    split. auto. split. eauto.
    split. simpl. auto.
    eapply An_EraseEq. eauto. eauto. simpl. eauto.
    eapply An_Sym.
    eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto.
    eapply An_Refl. eapply An_Star.
    eauto with ctx_wff. eauto.
  Qed.

Lemma erasure_AnnDefEq : forall G D g A'' B'' S A' B',
      AnnDefEq G D g A'' B'' ->
      AnnTyping G A'' S -> erase S = a_Star ->
      erase A'' = erase A' -> erase B'' = erase B' ->
      AnnTyping G A' a_Star -> AnnTyping G B' a_Star ->
      exists g', AnnDefEq G D g' A' B'.
Proof.
  intros G D g A'' B'' S A' B' H H0 H1 H2 H3 H4 H5.
  destruct (AnnDefEq_invertb H) as (S' & b'' & g' & TA'' & Tb' & Eb' & DEB).
  resolve_unique_nosubst.
  move :(AnnTyping_regularity H0) => R0.
  move :(AnnTyping_regularity Tb') => R1.
  have CTX : AnnCtx G by eauto with ctx_wff.
  assert (TEMP : exists g, AnnDefEq G D g A' A'').
  { eexists.
    eapply An_EraseEq. eauto. eauto. eauto.
    eapply An_EraseEq. eapply An_Star. auto. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct TEMP as (gA & DEA).
  assert (TEMP : exists g, AnnDefEq G D g b'' B').
  { eexists.
    eapply An_EraseEq. eauto. eauto. autorewcs. congruence.
    eapply An_EraseEq. eauto. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct TEMP as (gB & DEB2).
  destruct (An_Trans' DEA H) as [gX TR1].
  destruct (An_Trans' TR1 DEB) as [gX2 TR2].
  destruct (An_Trans' TR2 DEB2) as [gX3 TR3].
  exists gX3. exact TR3.
Qed.

Lemma AnnDefEq_invert_a_Star : forall G0 D g1 A1' A2' S,
      AnnDefEq G0 D g1 A1' A2' ->
      AnnTyping G0 A1' S ->
      erase S = a_Star ->
      exists A1'', exists A2'', exists g, erase A1'' = erase A1'
                       /\ erase A2'' = erase A2'
                       /\ AnnDefEq G0 D g A1'' A2''
                       /\ AnnTyping G0 A1'' a_Star
                       /\ AnnTyping G0 A2'' a_Star.
  Proof.
    intros G0 D g1 A1' A2' S DE T EA3.
  destruct (erasure_a_Star T EA3) as (A1'' & EA1'' & TA1').
  assert (exists g, AnnDefEq G0 D g A1'' A1').
  { eexists. eapply An_EraseEq with (A := a_Star); eauto 1.
    assert (AnnCtx G0). eauto with ctx_wff.
    eapply An_EraseEq with (A := a_Star). eauto.
    eapply AnnTyping_regularity; eauto 1.
    eauto. eapply An_Refl.  eauto.
  }

  destruct H as [g2 DE1].
  destruct (An_Trans' DE1 DE) as [g3 DE2].
  destruct (AnnDefEq_invertb DE2) as (A1''' & A2'' & g4 & ? & T2 & E1 & DE3).
  resolve_unique_nosubst.
  destruct (An_Trans' DE2 DE3) as [g5 DE4].
  exists A1'', A2'', g5.
  repeat split; eauto.
  Qed.

Lemma Path_to_Path : forall  a0, lc_tm a0 -> forall T a,
      Path T a -> erase a0 = a -> Path T a0.
Proof.
  intros a0. induction a0.
  all: intros LC T1 a P H.
  all: inversion P; subst.
  all: try destruct rho; simpl in *; try done.
  all: lc_inversion c.
  all: invert_syntactic_equality.
  all: econstructor; eauto.
Qed.

Lemma annotation_mutual :
  (forall G a A, Typing G a A ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists a0 A0,
         (erase a0) = a /\
         (erase A0) = A /\
         AnnTyping G0 a0 A0) /\
  (forall G phi, PropWff G phi ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists phi0,
          erase_constraint phi0 = phi /\
          AnnPropWff G0 phi0) /\
  (forall G D p1 p2, Iso G D p1 p2 ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists g0 p1' p2',
       (erase_constraint p1') = p1 /\
       (erase_constraint p2') = p2 /\
       AnnIso G0 D g0 p1' p2') /\
  (forall G D a b A, DefEq G D a b A ->
     forall G0, erase_context G0 = G -> AnnCtx G0 ->
     exists g a0 b0 A0,
       (erase a0) = a /\
       (erase b0) = b /\
       (erase A0) = A /\
       AnnDefEq G0 D g a0 b0 /\ AnnTyping G0 a0 A0 /\ AnnTyping G0 b0 A0) /\
  (forall G, Ctx G -> True).
Proof.
  eapply typing_wff_iso_defeq_mutual; intros; auto.
- exists a_Star. exists a_Star.
  repeat split. auto.
- rename H0 into EQ.
  unfold erase_context in EQ.
  rewrite <- EQ in b.
  apply binds_map_3 in b.
  destruct b as [s' [EQ2 b]].
  destruct s'; simpl in EQ2; inversion EQ2.
  exists (a_Var_f x).
  exists A0.
  unfold erase_context.
  simpl. split; auto.
- 
  clear t. clear t0.
  pick fresh x.
  assert (FrL : x `notin` L). auto.
  destruct (H0 G0 H1 H2) as [A0 [S0 [EQ1 [EQ2 AT]]]]. clear H0.
  destruct (erasure_a_Star AT EQ2) as [A0' [EQ3 AS]].
  assert (EQA : erase A0' = A). rewrite <- EQ3. auto.
  assert (AN: AnnCtx ((x ~ Tm A0') ++ G0)). eauto with ctx_wff.
  assert (E : erase_context ([(x, Tm A0')] ++ G0) = [(x, Tm A)] ++ G).
  { unfold erase_context. simpl in *.
    unfold erase_context in H1. congruence. }
  destruct (H x FrL _ E AN) as [B0 [S [E2 [E3 AT2]]]]. clear H. clear E. clear AN.
  destruct (erasure_a_Star AT2 E3) as [B0' [E4 AT4]].
  exists (a_Pi rho A0' (close_tm_wrt_tm x B0')).
  exists a_Star.
  repeat split.
  { simpl.  f_equal; auto. autorewcs.
    rewrite <- (close_tm_erase_tm x B0').
    rewrite <- E4. rewrite E2. simpl.
    rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto. }
  { eapply An_Pi_exists with (x:=x); eauto.
    autorewrite with lngen. fsetdec.
    rewrite open_tm_wrt_tm_close_tm_wrt_tm.
    eauto. }
- 
  destruct (H0 G0 H1 H2) as [A0 [s0 [E1 [E2 AT]]]]. clear H0.
  destruct (erasure_a_Star AT E2) as [A0' [EQ3 AS]].
  assert (EQA : erase A0' = A). rewrite <- EQ3. auto.
  pick fresh x. assert (FrL : x `notin` L). auto.
  assert (AN: AnnCtx ((x ~ Tm A0') ++ G0)). eauto with ctx_wff.
  assert (E : erase_context ([(x, Tm A0')] ++ G0) = [(x, Tm A)] ++ G).
     rewrite <- H1. unfold erase_context. simpl in *. congruence.
  destruct (H x FrL _ E AN) as [b0 [B0 [E3 [E4 AT_2]]]]. clear H. clear E.
  exists (a_Abs rho A0' (close_tm_wrt_tm x b0)).
  exists (a_Pi rho A0' (close_tm_wrt_tm x B0)).
  split. simpl in *. subst. f_equal.
  
  set (k := close_tm_erase_tm). simpl in k. unfold close_tm_wrt_tm.
  rewrite <- k; auto. rewrite E3.
  
  rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto.
  split.
  simpl. subst. f_equal. autorewcs. congruence.
  
  rewrite <- close_tm_erase_tm. rewrite E4. simpl.
  
  rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto.
  apply An_Abs_exists with (x := x); auto.
  apply notin_union_3; auto.
  apply notin_union_3; auto.
  autorewrite with lngen; auto.
  autorewrite with lngen; auto.
  rewrite open_tm_wrt_tm_close_tm_wrt_tm; auto.
  rewrite open_tm_wrt_tm_close_tm_wrt_tm; auto.
  rewrite open_tm_wrt_tm_close_tm_wrt_tm; auto.
  autorewcs. rewrite E3.
  eapply r; auto.
- 
  destruct (H G0 H1 H2) as [a0 [AB0 [F1 [F2 Ty2]]]]. clear H.
  destruct (H0 G0 H1 H2) as [b0 [A0 [M1 [M2 Ty3]]]]. clear H0.
  assert (K : AnnTyping G0 AB0 a_Star). eapply AnnTyping_regularity; eauto.
  destruct (erase_pi F2 K) as [PA [PB [EAB [EPA [EPB TYB]]]]].
  inversion TYB. subst.

  assert (N : AnnTyping G0 A0 a_Star). eapply AnnTyping_regularity; eauto.
  destruct (erasure_cvt Ty2 EAB) as [a0' [g ATA']]; eauto.
  destruct (erasure_cvt Ty3 (symmetry EPA)) as [b0' [g' ATB']]; eauto.
  exists (a_App a0' Rel b0').
  exists (open_tm_wrt_tm PB b0').
  simpl. rewrite <- open_tm_erase_tm.
  simpl in *.
  repeat split.
  congruence.
  congruence.
  eauto.
- 
  destruct (H G0 H1 H2) as [a0 [AB0 [F1 [F2 Ty2]]]]. clear H.
  destruct (H0 G0 H1 H2) as [b0 [A0 [M1 [M2 Ty3]]]]. clear H0.
  assert (K : AnnTyping G0 AB0 a_Star). eapply AnnTyping_regularity; eauto.
  destruct (erase_pi F2 K) as [PA [PB [EAB [EPA [EPB TYB]]]]].
  inversion TYB. subst.
  assert (N : AnnTyping G0 A0 a_Star). eapply AnnTyping_regularity; eauto.
  destruct (erasure_cvt Ty2 EAB) as [a0' [g ATA']]; eauto.
  destruct (erasure_cvt Ty3 (symmetry EPA)) as [b0' [g' ATB']]; eauto.
  exists (a_App a0' Irrel b0').
  exists (open_tm_wrt_tm PB b0').
  simpl. rewrite <- open_tm_erase_tm.
  simpl in *.
  repeat split.
  congruence.
  congruence.
  eauto.
- 
  destruct (H G0 H2) as [a0 [A0 [E1 [E2 Ty]]]]; auto. clear H.
  destruct (H0 G0 H2 H3) as
      [g [A0' [B0' [S [Ea [Eb [Es [DE [Z Z']]]]]]]]]; auto; clear H0.
  subst.
  replace a_Star with (erase a_Star) in Es; [|simpl;auto].
  destruct (erasure_cvt Z Es) as [A0'' [AS1 AS2]]. eapply An_Star. assumption.
  assert (Ea' : erase A0 = erase A0''). rewrite -AS1. auto.
  destruct (erasure_cvt Ty Ea') as [a'' [Ea0 Ta0]]. eauto.
  destruct (AnnDefEq_invertb DE) as [SA [B0'' [g5 [AT1 [AT2 [Eb SS]]]]]].
  resolve_unique_nosubst.

  destruct (erasure_a_Star AT2 Es) as (B0 & EB0 & TB0).

  pose A0S := AnnTyping_regularity Ty. clearbody A0S.
  rewrite -erase_dom in DE.
  assert (E1 :exists g, AnnDefEq G0 (dom G0) g A0 A0').
  { eexists.
    eapply An_EraseEq. eauto. eauto. eauto.
    eapply An_EraseEq. eauto. eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto.
  }
  destruct E1.
  assert (E2 : exists g, AnnDefEq G0 (dom G0) g A0' A0'').
  { eexists.
    eapply An_EraseEq. eauto. eapply AnnTyping_regularity. eauto.
    eauto.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply An_Star. eauto.
    eauto.
    eapply An_Refl. eauto.
  }
  destruct E2.
  assert (E3 : exists g, AnnDefEq G0 (dom G0) g A0'' B0'').
  {
    destruct (An_Sym' H0).
    rewrite -erase_dom in SS.
    destruct (An_Trans' DE SS); try eassumption.
    eapply An_Trans' with (a1 := A0'); try eassumption.
  }
  destruct E3 as [g'' EQ].
  assert (E4 : exists g, AnnDefEq G0 (dom G0) g B0'' B0).
  {
    eexists. eapply An_EraseEq. eauto. eauto. eauto.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply An_Star. eauto. eauto.
    eapply An_Refl; eauto.
  }
  destruct E4 as (gg & EE).
  destruct (An_Trans' EQ EE).
  eexists (a_Conv a'' x1). eexists B0.
  split. eauto. split. congruence.
  eapply An_Conv. eauto. eauto. eauto.
- 
  pick fresh c. assert (FrL : c `notin` L). auto.
  destruct (H0 G0 H1 H2) as [phi0 [EQ1 AT]]. clear H0.
  assert (AN: AnnCtx ((c ~ Co phi0) ++ G0)). eauto with ctx_wff.
  assert (E : erase_context ([(c, Co phi0)] ++ G0) = [(c, Co phi)] ++ G).
  unfold erase_context. simpl. rewrite EQ1.
  unfold erase_context in H1. rewrite H1. auto.
  destruct (H c FrL _ E AN) as [b0 [S0 [E2 [E3 AT2]]]]. clear H.
  clear E. clear AN.
  destruct (erasure_a_Star AT2) as [b0' [EB N1]]; eauto.
  exists (a_CPi phi0 (close_tm_wrt_co c b0')).
  exists a_Star.
  split.
  simpl. f_equal. auto.
  autorewcs.
  rewrite <- close_co_erase_tm.
  rewrite <- EB. rewrite E2. simpl.
  rewrite close_tm_wrt_co_open_tm_wrt_co; auto.
  split. auto.
  eapply An_CPi_exists with (c := c); eauto.
  apply notin_union_3; auto.
  pose K := fv_co_co_tm_close_tm_wrt_co b0' c. clearbody K.
  unfold AtomSetImpl.Equal in K.
  rewrite K. fsetdec.
  rewrite open_tm_wrt_co_close_tm_wrt_co.
  auto.
- 
  destruct (H0 G0 H1 H2) as [A0 [E1 AT]]. clear H0. clear t.
  pick fresh x. assert (FrL : x `notin` L). auto.
  assert (AN: AnnCtx ((x ~ Co A0) ++ G0)). eauto with ctx_wff.
  assert (E : erase_context ([(x, Co A0)] ++ G0) = [(x, Co phi)] ++ G).
     rewrite <- H1. unfold erase_context. simpl. rewrite E1. auto.
  destruct (H x FrL _ E AN) as [b0 [B0 [E3 [E4 AT_2]]]]. clear H. clear E.
  exists (a_CAbs A0 (close_tm_wrt_co x b0)).
  exists (a_CPi A0 (close_tm_wrt_co x B0)).
  split. simpl. subst. f_equal. autorewcs.
  rewrite <- close_co_erase_tm; auto. rewrite E3.
  simpl.
  rewrite close_tm_wrt_co_open_tm_wrt_co; auto.
  split.
  simpl. subst. f_equal. autorewcs.
  rewrite <- close_co_erase_tm. rewrite E4.
  simpl.
  rewrite close_tm_wrt_co_open_tm_wrt_co; auto.
  apply An_CAbs_exists with (c := x); auto.
  { apply notin_union_3; auto.
    apply notin_union_3; auto.
    pose K := fv_co_co_tm_close_tm_wrt_co b0 x. clearbody K.
    unfold AtomSetImpl.Equal in K.
    rewrite K. auto.
    pose K := fv_co_co_tm_close_tm_wrt_co B0 x. clearbody K.
    unfold AtomSetImpl.Equal in K.
    rewrite K. auto.
  }
  rewrite open_tm_wrt_co_close_tm_wrt_co; auto.
  rewrite open_tm_wrt_co_close_tm_wrt_co; auto.
- 
  clear d. clear t.
  destruct (H G0 H1 H2) as [a0 [A0 [E1 [E2 Ty]]]]. clear H.
  destruct (H0 G0 H1 H2) as [g [A0' [B0' [Ea' [Eb DE ]]]]]. clear H0.
  destruct DE as [Eb0 [EA [EQ [AT _]]]].
  pose K := AnnTyping_regularity Ty.
  destruct (erase_cpi E2 K) as [phi2 [B2 [E3 [Ep [EB2 AP]]]]].
  destruct phi2.
  simpl in *. inversion Ep. clear Ep.
  subst.
  rename A1 into A2.
  rename a2 into A1.
  rename b0 into B.
  destruct (erasure_cvt Ty) with (B := a_CPi (Eq A1 B A2) B2) as [a0' [TA' EA']]; eauto.
  inversion AP. inversion H4. subst.
  inversion H6. subst.
  assert (K1 : exists g, AnnDefEq G0 (dom G0) g A1 B0'). {
    eapply An_Trans' with (a1 := A0').
    eapply An_EraseEq. eauto. eauto. eauto.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eauto.
    rewrite -erase_dom in EQ.
    eapply EQ.
  }
  destruct K1.
  destruct (AnnDefEq_regularity H) as [C1 [C2 [gB [T1 [T2 DE2]]]]].
  resolve_unique_subst.
  destruct (An_Sym' DE2).
  assert (K3 : exists g, AnnDefEq G0 (dom G0) g C2 B0). {
    eapply An_Trans' with (a1 := C1).
    eauto.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto. eauto.
  }
  destruct K3.
  assert (K4 : exists g, AnnDefEq G0 (dom G0) g B0' B). {
    eexists. eapply An_EraseEq. eapply T2. eapply H11. eauto.
    eauto.
  }
  destruct K4.
  assert (K2 : exists g, AnnDefEq G0 (dom G0) g A1 B). {
    eapply An_Trans' with (a1 := B0').
    eauto. eauto.
  }
  destruct K2 as [g' Y].
  exists (a_CApp a0' g').
  exists (open_tm_wrt_co B2 g').
  subst. simpl.
  rewrite <- open_co_erase_tm.
  rewrite no_co_in_erased_tm.
  repeat split. autorewcs. congruence.
  eauto.
- exists (a_Const T).
  destruct (H0 nil eq_refl) as (a0 & A0 & E1 & E2 & Ty). auto. clear H0.
  unfold toplevel in b. unfold erase_sig in b.
  destruct (@binds_map_3 _ _ erase_csort T (Cs A) an_toplevel).
   eauto.
  split_hyp. destruct x; simpl in H0; inversion H0.
  subst.
  exists A1.  simpl.
  split; eauto.
  split; eauto.
  econstructor; eauto.
  eapply an_toplevel_to_const; eauto.
- destruct (H0 nil eq_refl) as (a0 & A0 & E1 & E2 & Ty). auto.
  unfold toplevel in b. unfold erase_sig in b.
  destruct (@binds_map_3 _ _ erase_csort F (Ax a A) an_toplevel). eauto.
  split_hyp. destruct x; inversion H3.
  exists (a_Fam F). exists A1. repeat split; auto.
  eapply An_Fam; eauto.
  eapply AnnTyping_regularity.
  eapply an_toplevel_closed. eauto.
- destruct (H G0 H2 H3) as [a0 [A0 [E1 [E2 Ty]]]]. clear H.
  destruct (H0 G0 H2 H3) as [b0 [A1 [E3 [E4 TyB]]]]. clear H0.
  clear H1.
  subst.
  exists (Eq a0 b0 A0). simpl. split. auto. eauto.
- 
  clear d. clear d0.
  rename A1 into a0. rename A2 into b0.
  rename B1 into a1. rename B2 into b1.
  destruct (H G0 H1 H2) as [g0 [a0' [b0' [A' [Ea0 [Eb0 [EA0 [DE0 [T0 _]]]]]]]]]. clear H.
  destruct (H0 G0 H1 H2) as [g1 [a1' [b1' [B' [Ea1 [Eb1 [EA1 [DE1 [T1 _]]]]]]]]]. clear H0.
  move :(AnnTyping_regularity T0) => R0.
  move :(AnnTyping_regularity T1) => R1.

  assert (TEMP: exists g, AnnDefEq G0 (dom G0) g A' B').
  { eexists.  eapply An_EraseEq. eauto. eauto.
    autorewcs. congruence.
    eapply An_Refl. eauto. }
  destruct TEMP as (gX & EqA'B').

  destruct (An_Sym' EqA'B') as (gY & EqB'A').
  remember (a_Conv a1' gY) as a1''.
  assert (AnnTyping G0 a1'' A'). rewrite Heqa1''; eapply An_Conv; eassumption.
  assert (erase a1'' = a1). rewrite Heqa1''. simpl. autorewcs. congruence.
  assert (AnnPropWff G0 (Eq a0' a1'' A')). {
    econstructor. eauto. eauto. autorewcs. congruence.
  }

  destruct (AnnDefEq_invertb DE0) as [AA0' [b0'' [gb0 [TA0 [TB0 [E DE0']]]]]].
  resolve_unique_nosubst.

  assert (TEMP : exists g, AnnDefEq G0 D g a1'' a1'). {
    eexists.
    eapply An_EraseEq. eauto. eauto. autorewcs. congruence. eauto.
  }
  destruct TEMP as (gZ & Eqa1''a1').
  destruct (An_Trans' Eqa1''a1' DE1) as (gY1 & Eqa1''b1').
  destruct (AnnDefEq_invertb Eqa1''b1') as [AA1'' [b1'' [gb1 [TA1 [TB1 [E1 DE1']]]]]].
  resolve_unique_nosubst.

  assert (AnnPropWff G0 (Eq b0'' b1'' A')). econstructor. eauto. eauto. autorewcs. congruence.

  assert (TEMP : exists g, AnnDefEq G0 D g a0' b0''). eapply (An_Trans' DE0 DE0').
  destruct TEMP as [gY2 Eqa0'b0''].

  assert (TEMP : exists g, AnnDefEq G0 D g a1'' b1''). eapply (An_Trans' Eqa1''b1' DE1').
  destruct TEMP as [gY3 Eqa1''b1''].

  eexists. exists (Eq a0' a1'' A'). exists (Eq b0'' b1'' A').
  split.
  simpl. autorewcs. f_equal; auto.
  split. simpl. autorewcs. f_equal; try congruence.
  simpl. autorewcs. f_equal; auto.
  econstructor; eauto.
- clear d. clear p0. clear p.
  destruct (H G0 H2 H3) as (g & A' & B' & S & EA & EB & ES & DE & TA & TB). clear H.
  destruct (H0 G0 H2 H3) as (phi0 & Ep0 & WF0). clear H0.
  destruct (H1 G0 H2 H3) as (phi1 & Ep1 & WF1). clear H1.
  destruct phi0 as [A1a A2a A''].
  destruct phi1 as [A1b A2b B''].
  simpl in Ep0. inversion Ep0. clear Ep0.
  simpl in Ep1. inversion Ep1. clear Ep1.
  inversion WF0. subst.
  inversion WF1. subst.
  move: (AnnTyping_regularity H8) => R1.
  move: (AnnTyping_regularity H9) => R2.
  move: (AnnTyping_regularity H11) => R3.
  move: (AnnTyping_regularity H12) => R4.

  destruct (AnnDefEq_invert_a_Star DE TA ES) as
      (A''' & B''' & g2 & EA2 & EB2 & DE2 & TAS & TBS).

  simpl in *.
  destruct (erasure_cvt H12) with (B:= A'')   as (A2a' & E2a & T2a); eauto 1.
  
  assert (TMP: exists g, AnnDefEq G0 D g A''' A'').
  { eexists.
    eapply An_EraseEq; eauto 1. congruence. eapply An_Refl; eauto 2. }
  destruct TMP as (ga & EAAA).

  assert (TMP : exists g, AnnDefEq G0 D g B'' A'').
  { eexists. eapply An_Trans2 with (a1 := B''').
    eapply An_EraseEq; eauto 1. congruence. eapply An_Refl; eauto 2.
    eapply An_Trans2 with (a1 := A''').
    eapply An_Sym2; eauto 1.
    eapply An_EraseEq; eauto 1. congruence. eapply An_Refl; eauto 2. }
  destruct TMP as (gb & EBA).

  assert (TMP : exists g, AnnDefEq G0 D g B A'').
  { eexists. eapply An_Trans2 with (a1 := B''); eauto 1.
    eapply An_EraseEq; eauto 1. eapply An_Refl; eauto 2. }
  destruct TMP as (gc & EBBA).

  eexists. exists (Eq A1a A2a A''). exists (Eq A1b A2b B'').
  repeat split; auto.
  simpl; auto.
  f_equal. congruence. congruence.
  eapply An_IsoConv.
  eapply An_Sym2. eauto 1.
  eapply An_Wff; eauto 1.
  eapply An_Wff; eauto 1.
  congruence.
  congruence.
- 
  clear d.
  destruct (H G0 H0 H1) as [g [a0 [b0 [A0' [E1 [E2 [E3 [DE [Ty UT]]]]]]]]]. clear H.
  subst.
  destruct (AnnDefEq_regularity DE) as [A0 [B0 [g0 [TA0 [TB0 DE0]]]]].
  destruct (erase_cpi E1 TA0) as [phi1' [B1' [E [Ephi [EB T1]]]]].
  destruct (erase_cpi E2 TB0) as [phi2' [B2' [E' [Ephi' [EB' T2]]]]].
  resolve_unique_nosubst.
  resolve_unique_nosubst.
  destruct (An_Refl_Star D E T1 Ty E3).
  assert (TB1 : AnnTyping G0 (a_Conv b0 (g_Sym g0)) A0').
  { eapply An_Conv. eauto. eapply An_Sym.
    eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto.
    eapply An_Refl. eapply An_Star.
    eauto.
    eauto.
    eapply AnnTyping_regularity. eauto.
  }
  assert (E4 : erase (a_Conv b0 (g_Sym g0)) = erase (a_CPi phi2' B2')).
  { simpl. autorewcs. rewrite E'. auto. }
  destruct (An_Refl_Star D E4 T2 TB1 E3).
  assert (exists g, AnnDefEq G0 D g (a_CPi phi1' B1') (a_CPi phi2' B2')).
  { eapply erasure_AnnDefEq with (A'' := a0) (B'' := b0); auto.
    eauto. eauto. eauto.  }
  destruct H2.
  destruct phi1. destruct phi2.
  eexists.
  exists phi1', phi2'.
  destruct phi1'. destruct phi2'. simpl in *.
  repeat split. congruence. congruence.
  eapply An_CPiFst. eapply H2.
- 
  rewrite <- H0 in b0.
  unfold erase_context in b0.
  destruct (binds_map_3 _ _ erase_sort c (Co (Eq a b A)) G0) as [s [E2 E3]]. eauto. 
  destruct s; try (simpl in E2; inversion E2).
  destruct phi. simpl in E2. inversion E2.
  subst. clear E2.
  move: (binds_to_AnnPropWff _ _ _ _ H1 E3) => K.
  inversion K. subst.
  move: (AnnTyping_regularity H6) => TA1.
  move: (AnnTyping_regularity H7) => TB0.

  assert (exists g, AnnDefEq G0 (dom G0) g B A0). {
    eexists. eapply An_EraseEq; eauto 1.
    eapply An_Refl; eauto 2.
  }
  destruct H0 as [g' DE].
  assert (AnnTyping G0 (a_Conv b1 g') A0).  eapply An_Conv; eauto 1.
  eexists. exists a0, (a_Conv b1 g'), A0. repeat split.
  eapply An_Trans2 with (a1 := b1); eauto 1.
  eapply An_Assn; eauto.
  eapply An_EraseEq; eauto.
  eauto.
  eauto.
- 
  destruct (H G0 H0 H1) as [a0' [A0 [E1 [E2 Ty ]]]]. clear H.
  eexists. exists a0', a0', A0. repeat split; auto. eapply An_Refl. eauto.
- 
  destruct (H G0 H0 H1) as [g [a0 [b0 [A0 [E1 [E2 [E3 [DE [Ty TU]]]]]]]]]. clear H.
  destruct (AnnDefEq_invertb DE) as [A0' [b0' [g' [T1 [T2 [T3 T4]]]]]].
  resolve_unique_nosubst.
  assert (exists g, AnnDefEq G0 D g b0' a0).  {
    destruct (An_Sym' DE).
    destruct (An_Sym' T4).
    eapply (An_Trans' H2 H).
  }
  destruct H.
  eexists. exists b0'. exists a0. exists A0. repeat split; auto. congruence. eassumption.
- 
  destruct (H G0 H1 H2) as (g0 & a' & a1' & A0 & E1 & E2 & E3 & DE & Ty & TyU). clear H.
  destruct (H0 G0 H1 H2) as (g1 & a1'' & b' & A1 & E4 & E5 & E6 & DE1 & Ty1 & TyU1). clear H0.
  destruct (AnnDefEq_invertb DE) as (A' & a1''' & g2 & T1 & T2 & E7 & DE2).
  destruct (AnnDefEq_invertb DE1) as (B' & b'' & g3 & T3 & T4 & E8 & DE3).
  subst.
  destruct (An_Trans' DE DE2).
  destruct (An_Trans' DE1 DE3).
  resolve_unique_nosubst.
  resolve_unique_nosubst.
  assert (exists g, AnnDefEq G0 D g a1''' a1'').
  {
    eexists.
    eapply An_EraseEq. eauto. eauto. autorewcs. congruence.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
     eapply AnnTyping_regularity. eauto. eauto.
     eauto.
  }
  destruct H1.
  destruct (An_Trans' H H1).
  destruct (An_Trans' H3 H0).
  destruct (AnnDefEq_invertb H4) as (? & b''' & ? & T3' & T4' & E8' & DE3').
  resolve_unique_nosubst.
  eexists. exists a'. exists b'''. exists A0. repeat split; auto. congruence.
  eapply An_Trans2 with (a1 := b''); eauto 1.
- 
  destruct (H G0 H1 H2) as [a1' [A1 [E1 [E2 Ty]]]]. clear H.
  destruct (H0 G0 H1 H2) as [a2' [A2 [E1' [E2' Ty']]]]. clear H0.
  subst.
  assert (exists g, AnnDefEq G0 D g A2 A1).
  { eexists. eapply An_EraseEq.  eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto 1.
    eapply An_Refl. eauto 2. }
  destruct H.
  assert (AnnTyping G0 (a_Conv a2' x) A1).
  { eapply An_Conv; eauto 1.
    eapply AnnDefEq_weaken_available; eauto 1.
    eapply AnnTyping_regularity. eauto. }
  eexists. exists a1', (a_Conv a2' x), A1.
  repeat split; eauto 1.
  eapply An_Beta; eauto 1.
- 
  clear d. clear d0.
  clear H1. rename H2 into H1. rename H3 into H2. rename H4 into H3. rename H5 into H4.
  destruct (H G0 H3 H4) as (g1 & A1' & A2' & S & EA1 & EA2 & EA3 & DE & T & U). clear H.
  clear H1. clear H2.
  destruct (AnnDefEq_invert_a_Star DE T EA3) as (A1'' & A2'' & g5 & EA5 & EA4 & DE4 & TA1' & TA2').
  assert (erase A1'' = A1). congruence.
  assert (erase A2'' = A2). congruence.

  clear dependent A1'. clear dependent A2'. clear dependent S.

  pick fresh x1.
  assert (FrL : x1 `notin` L). auto.
  assert (CTX1 : AnnCtx ([(x1, Tm A1'')] ++ G0)). eauto with ctx_wff.

  destruct (H0 x1 FrL ([(x1,Tm A1'')] ++ G0)) as (g2 & B1' & B2' & S & EB1 & EB2 & ES & DEB & DT & _); auto.
  { simpl. autorewcs. congruence. } clear H0.

  destruct (AnnDefEq_invert_a_Star DEB DT ES)  as (B1'' & B2'' & g6 & EB3 & EB4 & DE5 & TB1' & TB2'); auto.
  assert (erase B1'' = open_tm_wrt_tm B1 (a_Var_f x1)). congruence.
  assert (erase B2'' = open_tm_wrt_tm B2 (a_Var_f x1)). congruence.
  clear dependent B1'. clear dependent B2'. clear dependent S.

  pick fresh x2.
  remember (close_tm_wrt_tm x1 B2'') as CB2.
  remember (open_tm_wrt_tm CB2 (a_Conv (a_Var_f x2) (g_Sym g5))) as B3.

  assert (CTX2 : AnnCtx ([(x2, Tm A2'')] ++ G0)). eauto with ctx_wff.
  assert (CTX3 : AnnCtx ([(x2, Tm A2'')] ++ [(x1, Tm A1'')] ++ G0)).
  {  eapply An_ConsTm; eauto with ctx_wff.
     eapply (AnnTyping_weakening _ [(x1, Tm A1'')] nil); simpl; eauto with ctx_wff. }

  assert (AnnTyping G0 (a_Pi rho A1'' (close_tm_wrt_tm x1 B1'')) a_Star).
  { eapply An_Pi_exists with (x := x1).
    autorewrite with lngen. clear dependent x2. auto.
    autorewrite with lngen. auto.
    auto. }

  assert (AnnTyping G0 (a_Pi rho A2'' (close_tm_wrt_tm x2 B3)) a_Star).
  { eapply An_Pi_exists with (x := x2).
       autorewrite with lngen. auto.
       rewrite HeqB3. rewrite HeqCB2.
       autorewrite with lngen.
       rewrite -tm_subst_tm_tm_spec.
       replace a_Star with (tm_subst_tm_tm (a_Conv (a_Var_f x2) (g_Sym g5)) x1 a_Star); [|simpl; auto].
       eapply AnnTyping_tm_subst; eauto.
       eapply AnnTyping_weakening with (F := ([(x1, Tm A1'')])); eauto.
       eapply An_ConsTm; eauto.
       eapply AnnTyping_weakening with (F := nil); eauto.
       eapply An_Conv; eauto.
       eapply AnnDefEq_weakening with (F := nil)(G0 := G0).
       eapply (fourth ann_weaken_available_mutual) with (D := dom G0).
       eapply AnnDefEq_weaken_available.
       eauto.
       simpl. clear Fr. clear Fr0. fsetdec.
       eauto. simpl_env. auto.
       eapply AnnTyping_weakening with (F := nil); eauto.
       eauto. }

  exists (g_PiCong rho g5 (close_co_wrt_tm x1 g6)),
  (a_Pi rho A1'' (close_tm_wrt_tm x1 B1'')),
  (a_Pi rho A2'' (close_tm_wrt_tm x2 B3)),
  a_Star.

  repeat split; auto.
  + simpl. rewrite <- close_tm_erase_tm; auto. rewrite H0.
    simpl. rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto. rewrite -H. auto.
  + simpl. f_equal. auto. rewrite <- close_tm_erase_tm; auto. rewrite HeqB3.
    rewrite HeqCB2.
    rewrite <- open_tm_erase_tm.
    rewrite <- close_tm_erase_tm.
    rewrite H2. simpl.
    rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto.
    rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto.
    autorewrite with lngen.
    apply notin_remove_2.
    pose KK := fv_tm_tm_tm_open_tm_wrt_tm_upper B2 (a_Var_f x1). clearbody KK.
    unfold AtomSetImpl.Subset in KK. unfold not.
    intros NN. apply KK in NN.
    apply notin_union in NN. inversion NN. clear KK.
    simpl. auto. auto.
  + eapply An_PiCong_exists with (x1 := x1) (x2 := x2) (B2 := CB2); auto.
    ++ rewrite HeqCB2. autorewrite with lngen. auto.
    ++ rewrite HeqB3. rewrite HeqCB2. autorewrite with lngen.
      apply notin_union; auto.
    ++ rewrite HeqCB2. autorewrite with lngen. auto.
    ++ autorewrite with lngen. auto.
    ++ rewrite HeqCB2. autorewrite with lngen.
       move: (AnnDefEq_context_fv DE5) => /= ?.
       clear Fr Fr0.
       apply An_Pi_exists with (x:=x1).
       +++ apply notin_union. inversion CTX1. auto.
           autorewrite with lngen. fsetdec.
       +++ autorewrite with lngen. auto.
       +++ auto.
- 
  clear d. rename H1 into H3. rename H2 into H4.
  destruct (H0 G0 H3 H4) as (A1' & S1 & EA1 & ES & AT). clear H0.
  subst.
  destruct (erasure_a_Star AT ES) as (A1 & EA5 & AT1).
    pick fresh x1.
  assert (FrL : x1 `notin` L). auto.
  destruct (H x1 FrL ([(x1,Tm A1)] ++ G0)) as (g2 & b1' & b2' & B' & EB1 & EB2 & S & DEB & TB & TB2); auto. simpl. autorewcs. congruence.

  pick fresh x2.
  remember (close_tm_wrt_tm x1 b2') as b2''.
  remember (g_Refl A1) as gg.
  assert (AnnDefEq G0 D gg A1 A1). { rewrite Heqgg. eauto 3. }
  remember (open_tm_wrt_tm b2'' (a_Conv (a_Var_f x2) (g_Sym gg))) as b3.
  remember (open_tm_wrt_tm (close_tm_wrt_tm x1 B')
                           (a_Conv (a_Var_f x2) (g_Sym gg))) as B3.

  assert (AnnTyping G0 (a_Abs rho A1 (close_tm_wrt_tm x1 b1'))
                    (a_Pi rho A1 (close_tm_wrt_tm x1 B'))).
  { eapply An_Abs_exists with (x := x1).
    + autorewrite with lngen. clear dependent x2. auto.
    + auto.
    + autorewrite with lngen. auto.
    + autorewrite with lngen. autorewcs. rewrite EB1. auto.
  }

  assert (CTX2 : AnnCtx ([(x2, Tm A1)] ++ G0)). eauto with ctx_wff.
  assert (CTX3 : AnnCtx ([(x2, Tm A1)] ++ [(x1, Tm A1)] ++ G0)).
  {  eapply An_ConsTm; eauto.
     eapply (AnnTyping_weakening _ [(x1, Tm A1)] nil); simpl; eauto with ctx_wff.
  }

  assert (AnnTyping G0 (a_Abs rho A1 (close_tm_wrt_tm x2 b3))
                    (a_Pi rho A1 (close_tm_wrt_tm x2 B3))).
  { eapply An_Abs_exists with (x := x2).
    + autorewrite with lngen. auto.
    + auto.
    + rewrite Heqb3. rewrite HeqB3. rewrite Heqb2''. autorewrite with lngen.
      rewrite (tm_subst_tm_tm_intro x1).
      rewrite -(tm_subst_tm_tm_spec B').
      eapply AnnTyping_tm_subst; eauto 1.
      autorewrite with lngen.
      eapply AnnTyping_weakening; eauto 1.
      eapply An_ConsTm; eauto 1.
      eapply AnnTyping_weakening with (F:=nil); eauto 1.
      simpl. eauto.
      eapply An_Conv. eapply An_Var; eauto.
      eapply An_Sym2.
      eapply AnnDefEq_weakening with (F:=nil); eauto 1.
      simpl.
      eapply (fourth ann_weaken_available_mutual) with (D:= dom G0).
      eapply AnnDefEq_weaken_available. eauto.
      clear Fr Fr0. fsetdec.
      eapply AnnTyping_weakening with (F:=nil); eauto 1.
      autorewrite with lngen. eauto.
    + rewrite Heqb3.  rewrite Heqb2''. autorewrite with lngen.
      rewrite (tm_subst_tm_tm_intro x1); auto.
      autorewrite with lngen.
      autorewcs. rewrite -subst_tm_erase_tm; auto. simpl.
      autorewcs. rewrite EB2.
      rewrite -(tm_subst_tm_tm_intro x1); auto.
      autorewrite with lngen. auto.
  }
  assert (TMP: exists g, AnnDefEq G0 D g (a_Pi rho A1 (close_tm_wrt_tm x1 B'))
                        (a_Pi rho A1 (close_tm_wrt_tm x2 B3))).
  { eexists. eapply An_PiCong_exists with (x1:=x1) (x2:=x2)
                                                   (B2 := close_tm_wrt_tm x1 B')
    (g1:= gg) (g2 := (close_co_wrt_tm x1 (g_Refl B'))).
    + simpl. autorewrite with lngen. clear Fr0. auto.
    + autorewrite with lngen.
      apply notin_union. auto.
      rewrite Heqgg. auto.
    + auto.
    + autorewrite with lngen.
      eapply An_Refl.
      eapply AnnTyping_regularity. eauto 1.
    + autorewrite with lngen. auto.
    + eapply AnnTyping_regularity. eauto 1.
    + eapply AnnTyping_regularity. eauto 1.
    + autorewrite with lngen.
      move: (AnnTyping_context_fv TB) => /= ?.
      clear Fr Fr0.
      apply An_Pi_exists with (x := x1).
      apply notin_union. inversion CTX3. inversion H7. auto.
      autorewrite with lngen. fsetdec.
      autorewrite with lngen.
      eapply AnnTyping_regularity. eauto.
      inversion CTX2. auto.
  }
  destruct TMP as [gpi Epipi].
  assert (AnnTyping G0 (a_Conv (a_Abs rho A1 (close_tm_wrt_tm x2 b3)) (g_Sym gpi))
                    (a_Pi rho A1 (close_tm_wrt_tm x1 B'))).
  { eapply An_Conv. eauto 1. eapply An_Sym2.
    eapply AnnDefEq_weaken_available; eauto 1.
    eapply AnnTyping_regularity. eauto 1. }
 eexists. exists
  (a_Abs rho A1 (close_tm_wrt_tm x1 b1')),
  (a_Conv (a_Abs rho A1 (close_tm_wrt_tm x2 b3)) (g_Sym gpi)),
  (a_Pi rho A1 (close_tm_wrt_tm x1 B')).
  repeat split; eauto 1.
  { simpl. f_equal. rewrite <- close_tm_erase_tm; auto. rewrite EB1.
    simpl. rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto. }
  { simpl. f_equal. auto. rewrite <- close_tm_erase_tm; auto.
           rewrite Heqb3. rewrite Heqb2''.
           rewrite <- open_tm_erase_tm.
           rewrite <- close_tm_erase_tm.
           rewrite EB2. simpl.
           rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto.
           rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto.
           autorewrite with lngen.
           apply notin_remove_2.
           pose KK := fv_tm_tm_tm_open_tm_wrt_tm_upper b2 (a_Var_f x1). clearbody KK.
           unfold AtomSetImpl.Subset in KK. unfold not.
           intros NN. apply KK in NN.
           apply notin_union in NN. inversion NN. clear KK.
           simpl. auto. auto.
  }
  { simpl. f_equal. autorewcs. congruence.
    autorewcs. rewrite -close_tm_erase_tm; auto. rewrite S.
    simpl. rewrite close_tm_wrt_tm_open_tm_wrt_tm; auto. }
  { eapply An_Trans2 with (a1 := (a_Abs rho A1 (close_tm_wrt_tm x2 b3))).
    { eapply An_AbsCong_exists with (x1:=x1)(x2:=x2)(b2 := b2'')
          (g1 := gg) (g2 := (close_co_wrt_tm x1 g2))
          (B := a_Pi rho A1 (close_tm_wrt_tm x1 B')).
    + rewrite Heqb2''. autorewrite with lngen. auto.
    + rewrite Heqb3. rewrite Heqb2''. autorewrite with lngen.
      apply notin_union; auto. rewrite Heqgg. auto.
    + auto.
    + rewrite Heqb2''.
      autorewrite with lngen. auto.
    + autorewrite with lngen. auto.
    + auto.
    + auto.
    + autorewrite with lngen. autorewcs. rewrite EB1. auto.
    + rewrite Heqb3. rewrite Heqb2''.
      autorewrite with lngen.
      rewrite (tm_subst_tm_tm_intro x1); auto.
      autorewrite with lngen.
      autorewcs. rewrite -subst_tm_erase_tm; auto. simpl.
      autorewcs. rewrite EB2.
      rewrite -(tm_subst_tm_tm_intro x1); auto.
      autorewrite with lngen. auto.
    + rewrite Heqb2''. autorewrite with lngen.
      clear Fr Fr0.
      move: (AnnTyping_context_fv TB2) => /= ?.
      inversion CTX3. inversion H8. subst.
      eapply An_Abs_exists with (x:= x1).
      autorewrite with lngen.
      fsetdec.
      auto.
      autorewrite with lngen.
      auto.
      autorewrite with lngen.
      { apply An_Abs_inversion in H2.
        destruct H2 as [BB [h0 [h1 h2]]].
        move: (h2 x1 ltac:(auto)) => [h3 _].
        rewrite <- open_tm_erase_tm in h3.
        rewrite <- close_tm_erase_tm in h3.
        rewrite <- open_tm_erase_tm in h3.
        rewrite <- close_tm_erase_tm in h3.
        simpl in h3.
        replace (a_Var_f x2) with (erase_tm (a_Var_f x2)) in h3.
        replace (a_Var_f x1) with (erase_tm (a_Var_f x1)) in h3.
        autorewcshyp h3.
        rewrite close_tm_erase_tm in h3.
        rewrite open_tm_erase_tm in h3.
        replace (a_Var_f x2) with (erase_tm (a_Var_f x2)) in h3.
        rewrite close_tm_erase_tm in h3.
        rewrite open_tm_erase_tm in h3.
        simpl in h3.
        rewrite close_tm_wrt_tm_open_tm_wrt_tm in h3.
        rewrite open_tm_wrt_tm_close_tm_wrt_tm in h3.
        auto.
        autorewrite with lngen.
        move: (AnnTyping_context_fv TB2) => [h5 _].
        simpl in h5. rewrite h5.
        simpl in H10.
        fsetdec.
        auto.
        auto.
        auto.
      }
    }
    eapply An_EraseEq; eauto 1.
    eapply An_Sym. eauto 1.
    eapply AnnTyping_regularity. eauto 1.
    eapply AnnTyping_regularity. eauto 1.
    eapply An_Refl; eauto 2.
    eapply AnnDefEq_weaken_available; eauto 1.
  }
  Unshelve.
  eauto.
  eauto.
- 
  destruct (H G0 H1 H2) as [g1 [a1' [b1' [AB1 [EA1 [EA2 [ET1 [DE1 [TAB1 _]]]]]]]]]. clear H.
  destruct (H0 G0 H1 H2) as [g2 [a2' [b2' [A1 [EA3 [EA4 [ET2 [DE2 [TA1 _]]]]]]]]]. clear H0.
  move: (AnnTyping_regularity TAB1) => TPi.
  destruct (erase_pi ET1 TPi) as (A' & B' & E1 & E2 & E3 & TP).
  inversion  TP. subst.

  destruct (AnnDefEq_regularity DE2) as (A2' & B2' & g3 & ? & Tb2' & DEa2b1).
  resolve_unique_nosubst.

  destruct (erasure_cvt TAB1 E1) as (a1'' & E5 & Ta1''); eauto.
  assert (exists g, AnnDefEq G0 D g a1'' a1').
  { eexists. eapply An_EraseEq. eauto.  eauto. autorewcs. congruence.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H as [g4 DEa1''a1'].
  move: (An_Trans2 DEa1''a1' DE1) => DE4.

  destruct (erasure_cvt TA1) with (B := A') as (a2'' & E4 & Ta2''); eauto.
  assert (exists g, AnnDefEq G0 D g a2'' a2').
  { eexists. eapply An_EraseEq. eauto.  eauto. autorewcs. congruence.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H as [g5 DEa2''a2'].
  move: (An_Trans2 DEa2''a2' DE2) => DE3.

  destruct (AnnDefEq_invertb DE4) as (AB1' & b1'' & g6 & TA1' & TB1' & EB & DE5).
  resolve_unique_nosubst.

  destruct (AnnDefEq_invertb DE3) as (A1'' & b2'' & g7 & TA1'' & TB2'' & EB1 & DE6).
  resolve_unique_nosubst.

  assert (TT : AnnTyping G0 (a_App a1'' Rel a2'') (open_tm_wrt_tm B' a2'')).
  { eapply An_App. eauto. eauto. }

  assert (AnnTyping G0 (a_App b1'' Rel b2'') (open_tm_wrt_tm B' b2'')).
  { eapply An_App. eauto. eauto. }

  assert (exists g, AnnDefEq G0 D g a2'' b2'').
  { eexists. eapply An_Trans2. eauto. eauto. }
  destruct H0 as [g8 Eab].

  assert (exists g, AnnDefEq G0 D g (open_tm_wrt_tm B' a2'') (open_tm_wrt_tm B' b2'')).
  { eexists. eapply An_PiSnd; eauto 1.
    eapply An_Refl. eapply AnnTyping_regularity. eauto 1. }
  destruct H0 as [g9 HBB].

  assert (AnnTyping G0 (a_Conv (a_App b1'' Rel b2'') (g_Sym g9)) (open_tm_wrt_tm B' a2'')).
  { eapply An_Conv; eauto 1. eapply An_Sym2.
    eapply AnnDefEq_weaken_available; eauto 1.
    eapply AnnTyping_regularity. eauto. }

  eexists.
  exists (a_App a1'' Rel a2'').
  exists (a_Conv (a_App b1'' Rel b2'') (g_Sym g9)).
  exists (open_tm_wrt_tm B' a2'').
  repeat split.
  simpl. autorewcs. congruence.
  simpl. autorewcs. congruence.
  rewrite -open_tm_erase_tm.
  f_equal. auto.
  { eapply An_Trans2 with (a1 := (a_App b1'' Rel b2'')).
    eapply An_AppCong; eauto 1.
    eapply An_Trans2 with (a1 := b1'); eauto 2.
    eapply AnnDefEq_weaken_available; eauto 1.
    eapply An_EraseEq; eauto 2.
    eapply An_Sym.
    eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto.
    eapply An_Refl. eauto 2.
    eapply AnnDefEq_weaken_available; eauto 1.
    }
  eauto.
  eauto.
- 
  destruct (H G0 H1 H2) as [g1 [a1' [b1' [AB1 [EA1 [EA2 [ET1 [DE1 [TAB1 _]]]]]]]]]. clear H.
  destruct (H0 G0 H1 H2) as (a2' & A1 & EA3 & ET2 & TA1). clear H0.
  move: (AnnTyping_regularity TAB1) => TPi.
  destruct (erase_pi ET1 TPi) as (A' & B' & E1 & E2 & E3 & TP).
  inversion  TP. subst.

  destruct (erasure_cvt TAB1 E1) as (a1'' & E5 & Ta1''); eauto.
  assert (exists g, AnnDefEq G0 D g a1'' a1').
  { eexists. eapply An_EraseEq. eauto.  eauto. autorewcs. congruence.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H as [g4 DEa1''a1'].
  move: (An_Trans2 DEa1''a1' DE1) => DE4.

  destruct (erasure_cvt TA1) with (B := A') as (a2'' & E4 & Ta2''); eauto.
  assert (exists g, AnnDefEq G0 D g a2'' a2').
  { eexists. eapply An_EraseEq. eauto.  eauto. autorewcs. congruence.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H as [g5 DEa2''a2'].

  destruct (AnnDefEq_invertb DE4) as (AB1' & b1'' & g6 & TA1' & TB1' & EB & DE5).
  resolve_unique_nosubst.

  assert (TT : AnnTyping G0 (a_App a1'' Irrel a2'') (open_tm_wrt_tm B' a2'')).
  { eapply An_App. eauto. eauto. }

  assert (AnnTyping G0 (a_App b1'' Irrel a2'') (open_tm_wrt_tm B' a2'')).
  { eapply An_App. eauto. eauto. }

  eexists.
  exists (a_App a1'' Irrel a2'').
  exists (a_App b1'' Irrel a2'').
  exists (open_tm_wrt_tm B' a2'').
  repeat split.
  simpl. autorewcs. congruence.
  simpl. autorewcs. congruence.
  rewrite -open_tm_erase_tm.
  f_equal. auto.
  { eapply An_Trans2 with (a1 := (a_App b1'' Irrel a2'')).
    eapply An_AppCong; eauto 1.
    eapply An_Trans2 with (a1 := b1'); eauto 2.
    eapply An_Refl; eauto 2.
    eapply An_Refl; eauto 2.
    eapply AnnTyping_regularity. eauto 2.
    eapply An_Refl; eauto 2.
    }
  eauto.
  eauto.
- destruct (H G0 H0 H1) as [g [AB1 [AB2 [S1 [E1 [E2 [E3 [DE [T1 _]]]]]]]]].
  clear H.
  destruct (AnnDefEq_regularity DE) as [S2 [S2' [g1 [T2 [T3 DE2]]]]].
  resolve_unique_nosubst.
  destruct (erase_pi E1 T1) as [A1' [B1' [F1 [F2 [F3 AT]]]]].
  destruct (erase_pi E2 T3) as [A2' [B2' [F1' [F2' [F3' AT']]]]].
  subst.
  destruct (erasure_AnnDefEq DE T1 E3 F1 F1' AT AT')
    as (g2 & DE3).
  inversion AT. inversion AT'. subst.
  eexists. exists A1', A2', a_Star.
  repeat split. eauto. eauto. auto.
- 
  clear d. clear d0.
  destruct (H G0 H1 H2) as [g [AB1 [AB2 [S1 [E1 [E2 [E3 [DE1 [AT1 _]]]]]]]]]. clear H.
  destruct (H0 G0 H1 H2) as [g1 [a1' [a2' [S2 [E1' [E2' [E3' [DE2 [AT2 _]]]]]]]]]. clear H0.
  destruct (AnnDefEq_regularity DE1) as [SS1 [SS2 [g4 [T3 [T4 DE3]]]]].
  destruct (erase_pi E1 T3) as [A14 [A24 [F1 [F2 [F3 AT]]]]].
  destruct (erase_pi E2 T4) as [A15 [A25 [F1' [F2' [F3' AT']]]]].
  inversion AT. subst.
  inversion AT'. subst.

  destruct (erasure_AnnDefEq DE1 AT1 E3 F1 F1' AT) as (g6 & DE5). eauto.
  resolve_unique_nosubst.

  destruct (erasure_cvt AT2 (symmetry F2)) as [a1 [EA1 TA1]]. eauto.
  
  destruct (AnnDefEq_invertb DE2) as (S3 & a2'' & g7 & T5 & T6 & ? & DE6).
  resolve_unique_nosubst.
  destruct (erasure_cvt T6 (symmetry F2)) as [a2''' [EA2 TA2]]. eauto.
  assert (AnnDefEq G0 D (g_PiFst g6) A14 A15).
  { eapply An_PiFst. eauto. }
  remember (a_Conv a2''' (g_PiFst g6)) as a2.
  assert (AnnTyping G0 a2 A15).
  { rewrite Heqa2. eapply An_Conv; eauto.
    eapply AnnDefEq_weaken_available. eauto. }
  
  assert (TEMP : exists g, AnnDefEq G0 D g a1 a1').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_EraseEq; eauto 1.
    eapply AnnTyping_regularity; eauto.
    eapply An_Refl. eauto. }
  destruct TEMP as (? & Ha1a1').

  assert (TEMP : exists g, AnnDefEq G0 D g a2'' a2''').
  {  eexists.
    eapply An_EraseEq; eauto 1.
    eapply An_EraseEq; eauto 1.
    eapply AnnTyping_regularity; eauto.
    eapply An_Refl. eauto. }
  destruct TEMP as (? & Ha2''a2''').
  assert (TEMP : exists g, AnnDefEq G0 D g a2''' a2).
  { rewrite Heqa2.
    eexists.
    eapply An_EraseEq. eauto.
    rewrite -Heqa2. eauto.
    eauto.
    eapply AnnDefEq_weaken_available. eauto.
  }
  destruct TEMP as (? & Ha2'''a2).
  move: (An_Trans2 Ha1a1' DE2) => Ha1a2'.
  move: (An_Trans2 Ha1a2' DE6) => Ha1a2''.
  move: (An_Trans2 Ha1a2'' Ha2''a2''') => Ha1a2'''.
  move: (An_Trans2 Ha1a2''' Ha2'''a2) => Ha1a2.
  eexists.
  exists (open_tm_wrt_tm  A24 a1).
  exists (open_tm_wrt_tm  A25 a2).
  exists a_Star.
  repeat split.
  rewrite <- open_tm_erase_tm. congruence.
  rewrite <-  open_tm_erase_tm. rewrite Heqa2. simpl.
  f_equal. autorewcs. congruence.
  eapply An_PiSnd; eauto.
  pick fresh x2 for (L \u fv_tm_tm_tm A24).
  rewrite (tm_subst_tm_tm_intro x2); auto.
  replace a_Star with (tm_subst_tm_tm a1 x2 a_Star).
  eapply AnnTyping_tm_subst.
  eapply H4. auto. auto. simpl. auto.
  pick fresh x2 for (L0 \u fv_tm_tm_tm A25).
  rewrite (tm_subst_tm_tm_intro x2); auto.
  replace a_Star with (tm_subst_tm_tm a2 x2 a_Star).
  eapply AnnTyping_tm_subst.
  eapply H3. auto. auto. simpl. auto.
- 
  idtac. rename A into B1. rename B into B2.
  clear H1. rename H2 into H1. rename H3 into H2. rename H4 into H3. rename H5 into H4.
  clear d. clear i.
  destruct (H G0 H3 H4) as (g1 & phi1' & phi2' & EP1 & EP2 & IP). clear H.
  clear H1 H2. rename H3 into H1. rename H4 into H2.
  destruct (AnnIso_regularity IP) as [WFF1 WFF2].
  inversion WFF1. inversion WFF2. subst.

  move: (AnnTyping_regularity H) => ?.
  move: (AnnTyping_regularity H7) => ?.
  move: (AnnTyping_regularity H3) => ?.
  move: (AnnTyping_regularity H8) => ?.

  assert (exists g, AnnDefEq G0 D g A0 B0).
  { eexists. eapply An_EraseEq; eauto 1. eauto. }
  destruct H1 as [g2 EA0B0].
  assert (exists g, AnnDefEq G0 D g A B).
  { eexists. eapply An_EraseEq; eauto 1. eauto. }
  destruct H1 as [g3 EAB].

  pick fresh x1.
  assert (FrL : x1 `notin` L). auto.
  assert (CTX1 : AnnCtx ([(x1, Co (Eq a b A))] ++ G0)). eauto with ctx_wff.

  destruct (H0 x1 FrL ([(x1,Co (Eq a b A))] ++ G0)) as (g4 & B1' & B2' & S & EB1 & EB2 & ES & DEB & DT & _); auto.
  clear H0.

  destruct (AnnDefEq_invert_a_Star DEB DT ES)  as (B1'' & B2'' & g6 & EB3 & EB4 & DE5 & TB1' & TB2'); auto.
  assert (erase B1'' = open_tm_wrt_co B1 (g_Var_f x1)). congruence.
  assert (erase B2'' = open_tm_wrt_co B2 (g_Var_f x1)). congruence.
  clear dependent B1'. clear dependent B2'. clear dependent S.

  pose AVOID := erase B2''.
  pick fresh x2.
  remember (close_tm_wrt_co x1 B2'') as CB2.
  remember (open_tm_wrt_co CB2 (g_Cast (g_Var_f x2) (g_Sym g1))) as B3.

  assert (CTX2 : AnnCtx ([(x2, Co (Eq a0 b0 A0))] ++ G0)). eauto with ctx_wff.
  assert (CTX3 : AnnCtx ([(x2, Co (Eq a0 b0 A0))] ++ [(x1, Co (Eq a b A))] ++ G0)).
  {  eapply An_ConsCo; eauto.
     eapply (AnnPropWff_weakening _ [(x1, Co (Eq a b A))] nil); simpl; eauto. }

  assert (AnnTyping G0 (a_CPi (Eq a b A) (close_tm_wrt_co x1 B1'')) a_Star).
  { eapply An_CPi_exists with (c := x1).
    autorewrite with lngen. clear dependent x2. auto.
    autorewrite with lngen. auto.
    autorewrite with lngen. eauto.
  }

  assert (AnnTyping G0 (a_CPi (Eq a0 b0 A0) (close_tm_wrt_co x2 B3)) a_Star).
  { eapply An_CPi_exists with (c := x2).
    autorewrite with lngen. auto.
    eauto.
    rewrite HeqB3. rewrite HeqCB2.
    autorewrite with lngen.
    rewrite -co_subst_co_tm_spec.
    replace a_Star with (co_subst_co_tm (g_Cast (g_Var_f x2) (g_Sym g1)) x1 a_Star); [|simpl; auto].
    eapply AnnTyping_co_subst with (D := dom ([(x2, Co (Eq a0 b0 A0))] ++ G0)); eauto.
    eapply AnnTyping_weakening with (F := ([(x1, Co (Eq a b A))])); eauto 1.
    eapply An_ConsCo; eauto.
    eapply AnnPropWff_weakening with (F := nil); eauto.
    eapply An_Cast; eauto 2.
    eapply An_Assn; eauto.
    simpl. simpl_env.
    eapply AnnIso_weakening with (F := nil)(G0 := G0).
    eapply (third ann_weaken_available_mutual) with (D := dom G0).
    eapply AnnIso_weaken_available.
    eauto.
    simpl. clear Fr Fr0. fsetdec.
    eauto. simpl_env. auto.
 }

  exists (g_CPiCong g1 (close_co_wrt_co x1 g6)),
  (a_CPi (Eq a b A) (close_tm_wrt_co x1 B1'')),
  (a_CPi (Eq a0 b0 A0) (close_tm_wrt_co x2 B3)),
  a_Star.

  repeat split.
  + simpl. rewrite <- close_co_erase_tm; auto. rewrite H0.
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co; auto.
  + simpl. f_equal. rewrite <- close_co_erase_tm; auto. rewrite HeqB3.
    rewrite HeqCB2.
    rewrite <- (open_co_erase_tm2 _ _ (g_Var_f x2)).
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co.
    rewrite <- close_co_erase_tm.
    rewrite H1.
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co.
    auto.
    clear Fr0. auto.
    rewrite <- close_co_erase_tm.
    autorewrite with lngen.
    apply notin_remove_2.
    auto.
  + eapply An_CPiCong_exists with (c1 := x1) (c2 := x2) (B2 := CB2).
    ++ auto.
    ++ rewrite HeqCB2. autorewrite with lngen. auto.
    ++ rewrite HeqB3. rewrite HeqCB2. autorewrite with lngen.
      apply notin_union; auto.
    ++ rewrite HeqCB2. autorewrite with lngen. auto.
    ++ rewrite HeqB3. rewrite HeqCB2. autorewrite with lngen.
       auto.
    ++ auto.
    ++ auto.
    ++ rewrite HeqCB2. autorewrite with lngen.
       clear Fr Fr0.
       move: (AnnDefEq_context_fv DE5) => /= ?.
       inversion CTX1. subst.
       eapply An_CPi_exists with (c:=x1).
       autorewrite with lngen.
       fsetdec.
       auto.
       autorewrite with lngen.
       auto.
  + auto.
  + auto.
- 
  rename a into B1. rename b into B2. rename B into S.
  
  destruct (H0 G0 H1 H2) as (phi1' & EP1 & WFF1). clear H0.
  inversion WFF1. subst.

  move: (AnnTyping_regularity H0) => ?.
  move: (AnnTyping_regularity H3) => ?.

  assert (exists g, AnnDefEq G0 D g A B).
  { eexists. eapply An_EraseEq; eauto 1. eauto. }
  destruct H1 as [g3 EAB].

  pick fresh x1.
  assert (FrL : x1 `notin` L). auto.
  assert (CTX1 : AnnCtx ([(x1, Co (Eq a b A))] ++ G0)). eauto with ctx_wff.

  destruct (H x1 FrL ([(x1,Co (Eq a b A))] ++ G0)) as (g4 & B1' & B2' & C1 & EB1 & EB2 & ES & DEB & DT & DU); auto.
  clear H.

  destruct (AnnDefEq_regularity DEB) as (? & C2 & g &  ? & TB2 & DEC).
  resolve_unique_nosubst.
  resolve_unique_nosubst.

  pose AVOID := erase B2'.
  pick fresh x2.
  remember (close_tm_wrt_co x1 B2') as CB2.
  have refl: exists g, AnnIso G0 D g (Eq a b A) (Eq a b A).
  { eexists. apply An_PropCong. eapply An_Refl. eassumption. eapply An_Refl. eassumption.
    apply WFF1. apply WFF1. }
    destruct refl as [g1 refl].
    remember (open_tm_wrt_co CB2 (g_Cast (g_Var_f x2) (g_Sym g1))) as B3.
    remember (open_tm_wrt_co (close_tm_wrt_co x1 C1)
                           (g_Cast (g_Var_f x2) (g_Sym g1))) as C3.

  assert (CTX2 : AnnCtx ([(x2, Co (Eq a b A))] ++ G0)). eauto 2 with ctx_wff.
  assert (CTX3 : AnnCtx ([(x2, Co (Eq a b A))] ++ [(x1, Co (Eq a b A))] ++ G0)).
  {  eapply An_ConsCo; eauto 1.
     eapply (AnnPropWff_weakening _ [(x1, Co (Eq a b A))] nil); simpl; eauto. }

    assert (AnnTyping G0 (a_CAbs (Eq a b A)
                               (close_tm_wrt_co x1 B1')) (a_CPi (Eq a b A) (close_tm_wrt_co x1 C1))).
  { eapply An_CAbs_exists with (c := x1).
    autorewrite with lngen. clear dependent x2.
    apply notin_union; auto.
    auto.
    autorewrite with lngen. auto.
  }

  assert (AnnTyping G0 (a_CAbs (Eq a b A) (close_tm_wrt_co x2 B3))
                      (a_CPi (Eq a b A) (close_tm_wrt_co x2 C3))).
  { eapply An_CAbs_exists with (c := x2).
    autorewrite with lngen. auto.
    eauto.
    rewrite HeqB3. rewrite HeqCB2. rewrite HeqC3.
    autorewrite with lngen.
    rewrite -co_subst_co_tm_spec.
    rewrite -co_subst_co_tm_spec.
    eapply AnnTyping_co_subst with (D := dom ([(x2, Co (Eq a b A))] ++ G0)); eauto.
    eapply AnnTyping_weakening with (F := ([(x1, Co (Eq a b A))])); eauto 1.
    eapply An_ConsCo; eauto.
    eapply AnnPropWff_weakening with (F := nil); eauto.
    eapply An_Cast; eauto 2.
    eapply An_Assn; eauto.
    simpl; eauto 2.
    simpl_env.
    eapply AnnIso_weakening with (F := nil)(G0 := G0).
    eapply (third ann_weaken_available_mutual) with (D := dom G0).
    eapply AnnIso_weaken_available.
    eauto.
    simpl. clear Fr Fr0. fsetdec.
    eauto. simpl_env. auto.
  }

  assert (exists g, AnnDefEq ([(x1, Co (Eq a b A))] ++ G0) (dom G0) g C1 C1).
  { eexists. eapply An_Refl.
    eapply AnnTyping_regularity. eauto 1. }
  destruct H5 as [ grefl EC1C1].
  assert (exists g, AnnDefEq G0 (dom G0) g
                        (a_CPi (Eq a b A) (close_tm_wrt_co x1 C1))
                        (a_CPi (Eq a b A) (close_tm_wrt_co x2 C3))).
  {
    eexists. eapply An_CPiCong_exists with
             (c1 := x1)
               (c2 := x2)
               (B2 := close_tm_wrt_co x1 C1)
               (g3 := close_co_wrt_co x1 grefl).
    + eapply AnnIso_weaken_available. eauto 1.
    + simpl. autorewrite with lngen. clear Fr0. auto.
    + autorewrite with lngen.
      apply notin_union.
      pose M := AnnIso_context_fv refl.
      clearbody M.
      destruct M as [_ [h4 _]].
      unfold "[<=]" in h4.
      move => h6.
      have h1: x2 `notin` dom G0; auto.
      auto 3.
    + autorewrite with lngen. eauto 1.
    + rewrite HeqC3. autorewrite with lngen. auto.
    + eapply AnnTyping_regularity; eauto 1.
    + eapply AnnTyping_regularity; eauto 1.
    + autorewrite with lngen.
      clear Fr Fr0.
      move: (AnnTyping_context_fv DT) => /= ?.
      inversion CTX3. inversion H8. subst.
      eapply An_CPi_exists with (c:=x1).
      autorewrite with lngen.
      fsetdec.
      auto.
      autorewrite with lngen.
      eapply AnnTyping_regularity. eauto.
  }
  destruct H5 as [g5 Epipi].

  assert (AnnTyping G0
                    (a_Conv (a_CAbs (Eq a b A) (close_tm_wrt_co x2 B3))
                            (g_Sym g5))
                    (a_CPi (Eq a b A) (close_tm_wrt_co x1 C1))).
  { eapply An_Conv; eauto 1.
    eapply An_Sym2; auto.
    eapply AnnTyping_regularity; eauto 1. }

  eexists.
  exists (a_CAbs (Eq a b A) (close_tm_wrt_co x1 B1')),
  (a_Conv (a_CAbs (Eq a b A) (close_tm_wrt_co x2 B3)) (g_Sym g5)),
  (a_CPi (Eq a b A) (close_tm_wrt_co x1 C1)).

  repeat split.
  + simpl. rewrite <- close_co_erase_tm; auto. rewrite EB1.
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co; auto.
  + simpl. f_equal. rewrite <- close_co_erase_tm; auto. rewrite HeqB3.
    rewrite HeqCB2.
    rewrite <- (open_co_erase_tm2 _ _ (g_Var_f x2)).
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co.
    rewrite <- close_co_erase_tm.
    rewrite EB2.
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co.
    auto.
    clear Fr0. auto.
    rewrite <- close_co_erase_tm.
    autorewrite with lngen.
    apply notin_remove_2.
    auto.
  + simpl. f_equal.
    rewrite <- close_co_erase_tm; auto. rewrite ES.
    simpl. rewrite close_tm_wrt_co_open_tm_wrt_co; auto.

  + eapply An_Trans2 with (a1 := (a_CAbs (Eq a b A)(close_tm_wrt_co x2 B3))).
    eapply An_CAbsCong_exists with (c1 := x1) (c2 := x2) (a2 := CB2)
       (g3 := close_co_wrt_co x1 g4)
       (B := a_CPi (Eq a b A) (close_tm_wrt_co x1 C1));
      eauto 1.
    ++ rewrite HeqCB2. autorewrite with lngen. auto.
    ++ autorewrite with lngen.
       apply notin_union.
       pose M := AnnIso_context_fv refl.
       clearbody M.
       destruct M as [_ [h4 _]].
       unfold "[<=]" in h4.
       move => h6.
       have h1: x2 `notin` dom G0; auto.
       rewrite HeqCB2. autorewrite with lngen.
       auto 3.
    ++ rewrite HeqCB2. autorewrite with lngen. auto.
    ++ rewrite HeqB3. rewrite HeqCB2. autorewrite with lngen.
       auto.
    ++ autorewrite with lngen.
       clear Fr Fr0.
       subst CB2.
       inversion CTX3. inversion H9. subst.
       eapply An_CAbs_exists with (c:=x1).
       autorewrite with lngen. fsetdec.
       auto.
       autorewrite with lngen. auto.
    ++ eapply An_EraseEq; eauto 1.
       eapply An_Sym2; eauto 1.
  + eauto 1.
  + eauto 1.
    Unshelve.
    eauto 1.
    eauto 1.
- 
  clear d.

  destruct (H G0 H1 H2) as [g1 [a1' [b1' [AB1 [EA1 [EA2 [ET1 [DE1 [TAB1 _]]]]]]]]]. clear H.
  move: (AnnTyping_regularity TAB1) => TPi.
  destruct (erase_cpi ET1 TPi) as (A' & B' & E1 & E2 & E3 & TP).
  inversion  TP.

  destruct A' as [a2'' b2'']. simpl in E2. inversion E2. clear E2.
  inversion H5.

  destruct (H0 G0 H1 H2) as [g2 [a2' [b2' [A1' [EA3 [EA4 [ET2 [DE2 [TA1 _]]]]]]]]]. clear H0.
  subst.

  move: (AnnTyping_regularity H14) => SA1.
  move: (AnnTyping_regularity H15) => ?.
  move: (AnnTyping_regularity TA1) => SA1'.

 destruct (erasure_cvt TAB1 E1) as (a1'' & E5 & Ta1''); eauto.
  assert (exists g, AnnDefEq G0 D g a1'' a1').
  { eexists. eapply An_EraseEq. eauto.  eauto. autorewcs. congruence.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H as [g4 DEa1''a1'].
  move: (An_Trans2 DEa1''a1' DE1) => DE4.

  destruct (AnnDefEq_regularity DE2) as (? & B2' & g3 & ? & Tb2' & DEa2b1).
  move: (AnnTyping_regularity Tb2') => ?.
  resolve_unique_nosubst.

  assert (exists g, AnnDefEq G0 (dom G0) g a2'' a2').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_EraseEq; eauto 1. eapply An_Refl. eauto. }
  destruct H as [g5 Ea2''a2'].

  assert (exists g, AnnDefEq G0 (dom G0) g A0 B1).
  { eexists. eapply An_EraseEq; eauto 1. eapply An_Refl. eauto. }
  destruct H as [g6 EA1B1].

  assert (exists g, AnnDefEq G0 (dom G0) g A1' A0).
  { eexists. eapply An_EraseEq; eauto 1. eapply An_Refl. eauto. }
  destruct H as [g7 EA1'A1].

  assert (exists g, AnnDefEq G0 (dom G0) g b2' b2'').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_Trans2 with (a1 := A1').
    eapply An_Sym2; eauto 1.
    eapply An_Trans2 with (a1 := A0);
      eauto 1.
      }
  destruct H as [g8 Eb2'b2''].

  rewrite -erase_dom in DE2.
  move: (An_Trans2 Ea2''a2' (An_Trans2 DE2 Eb2'b2'')) => Ea2''b2''.
  remember (g_Trans g5 (g_Trans g2 g8)) as g9.

  destruct (AnnDefEq_invertb DE4) as (? & b1'' & g10 & ? & Tb1'' & E6 & DEBB).
  resolve_unique_nosubst.

  assert (TT : AnnTyping G0 (a_CApp a1'' g9) (open_tm_wrt_co B' g9)).
  { eapply An_CApp. eauto. eauto. }

  assert (AnnTyping G0 (a_CApp b1'' g9) (open_tm_wrt_co B' g9)).
  { eapply An_CApp. eauto. eauto. }

  eexists.
  exists (a_CApp a1'' g9).
  exists (a_CApp b1'' g9).
  exists (open_tm_wrt_co B' g9).
  repeat split.
  simpl. f_equal. eauto 1.
  simpl. f_equal. eauto 2.
  rewrite <- (open_co_erase_tm2 _ _ g_Triv). auto.

  eapply An_CAppCong; eauto 2.
  eapply An_Trans2 with (a1 := b1'); eauto 1.
  eapply An_Refl. eapply AnnTyping_regularity; eauto 1.
  assumption.
  assumption.
- 
  clear d. clear d1. clear d0.
  rename a1' into b1. rename a2' into b2. rename A' into B.
  destruct (H G0 H2 H3) as [g [AB1 [AB2 [S1 [E1 [E2 [E3 [DE1 [T1 _]]]]]]]]]. clear H.
  destruct (H0 G0 H2 H3) as [g1 [a1' [a2' [A' [EA11 [EA21 [E31 [DEA [T1A _]]]]]]]]]. clear H0.
  destruct (H1 G0 H2 H3) as [g1' [b1' [b2' [B' [EA11' [EA21' [E31' [DEA' [T1A' _]]]]]]]]]. clear H1.

  destruct (AnnDefEq_regularity DE1) as [S1' [S2' [g4 [T3 [T4 DE3]]]]].
  destruct (AnnDefEq_regularity DEA) as [S1'' [S2'' [g5 [T3' [T4' DE3']]]]].
  destruct (AnnDefEq_regularity DEA') as [S1''' [S2''' [g5' [T3'' [T4'' DE3'']]]]].
  resolve_unique_nosubst.
  resolve_unique_nosubst.
  resolve_unique_nosubst.

  move: (AnnTyping_regularity T1A) => ?.
  move: (AnnTyping_regularity T1A') => ?.
  move: (AnnTyping_regularity T4) => ?.
  move: (AnnTyping_regularity T4') => ?.

  destruct (erase_cpi E1 T1) as [phi1' [B1' [F1 [F2 [F3 AT]]]]].
  destruct (erase_cpi E2 T4) as [phi2' [B2' [F1' [F2' [F3' AT']]]]].
  destruct phi1' as [a1'' a2'' A'']. simpl in F2. inversion F2. clear F2.
  destruct phi2' as [b1'' b2'' B'']. simpl in F2'. inversion F2'. clear F2'.

  destruct (erasure_AnnDefEq DE1 T1 E3  F1 F1' AT AT') as [g2 DE2].
  inversion AT. inversion AT'.
  inversion H10. inversion H15.
  subst.

  assert (TMP : exists g, AnnDefEq G0 D g a1'' a1').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g3 Ea1''a1'].
  assert (TMP : exists g, AnnDefEq G0 (dom G0) g A'' B4).
  { eexists. eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g6 EA''B4].
 assert (TMP : exists g, AnnDefEq G0 (dom G0) g A' A'').
  { eexists. eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g7 EA'A''].

  move: (An_Trans2 (An_Sym2 DE3') (An_Trans2 EA'A'' EA''B4)) => ?.
  assert (TMP : exists g, AnnDefEq G0 D g a2' a2'').
  { eexists. eapply An_EraseEq; eauto 1. }
  destruct TMP as [g8 Ea2'a2''].

  move: (AnnDefEq_weaken_available Ea1''a1') => y.
  rewrite erase_dom in y.
  move: (AnnDefEq_weaken_available Ea2'a2'') => x.
  rewrite erase_dom in x.
  move: (An_Trans2 y (An_Trans2 DEA x)) => Ea1''a2''.

  assert (TMP : exists g, AnnDefEq G0 D g b1'' b1').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g9 Eb1'Eb1''].
  
  assert (TMP : exists g, AnnDefEq G0 (dom G0) g B'' B5).
  { eexists. eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g10 EB''B5].
 assert (TMP : exists g, AnnDefEq G0 (dom G0) g B' B'').
  { eexists. eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g11 EB'B''].

  move: (An_Trans2 (An_Sym2 DE3'') (An_Trans2 EB'B'' EB''B5)) => ?.
  assert (TMP : exists g, AnnDefEq G0 D g b2' b2'').
  { eexists. eapply An_EraseEq; eauto 1. }
  destruct TMP as [g12 Eb2'b2''].

  assert (TMP : exists g, AnnDefEq G0 D g b1'' b1').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_EraseEq.
    eapply AnnTyping_regularity; eauto 1.
    eapply AnnTyping_regularity; eauto 1.
    eauto 1.
    eapply An_Refl; eauto 2. }
  destruct TMP as [g13 Eb1''b1'].

  move: (AnnDefEq_weaken_available Eb2'b2'') => y1.
  rewrite erase_dom in y1.
  move: (AnnDefEq_weaken_available Eb1''b1') => x1.
  rewrite erase_dom in x1.

  move: (An_Trans2 x1 (An_Trans2 DEA' y1)) => Eb1''b2''.
  clear x1. clear y1.
  eexists.
  exists
    (open_tm_wrt_co B1' (g_Trans g3 (g_Trans g1 g8))),
    (open_tm_wrt_co B2' (g_Trans g13 (g_Trans g1' g12))), a_Star.
  repeat split.
  + simpl. rewrite <- open_co_erase_tm2 with (g := g_Triv). auto.
  + simpl. rewrite <- open_co_erase_tm2 with (g := g_Triv). auto.
  + eapply An_CPiSnd; eauto. rewrite erase_dom. auto.
    rewrite erase_dom. auto.
  + pick fresh x1 for (L \u fv_co_co_tm B1').
    rewrite (co_subst_co_tm_intro x1).
    replace a_Star with (co_subst_co_tm (g_Trans g3 (g_Trans g1 g8)) x1 a_Star).
    eapply AnnTyping_co_subst.
    eauto.
    eauto.
    simpl. auto. auto.
  + pick fresh x1 for (L0 \u fv_co_co_tm B2').
    rewrite (co_subst_co_tm_intro x1).
    replace a_Star with (co_subst_co_tm (g_Trans g13 (g_Trans g1' g12)) x1 a_Star).
    eapply AnnTyping_co_subst.
    eapply H16; eauto 1.
    eauto 1.
    simpl. auto.
    auto.
- 
  clear i. clear d.
  destruct (H G0 H1 H2) as [g [a0' [b0' [A0' [EA [EB [S2 [DE [T1 _]]]]]]]]]. clear H.
  destruct (H0 G0 H1 H2) as [g1 [phi' [phi2' [EP1 [EP2 IP]]]]]. clear H0.
  destruct (AnnIso_regularity IP) as [WFF1 WFF2].
  inversion WFF1. inversion WFF2. subst.
  move: (AnnTyping_regularity H) => ?.
  move: (AnnTyping_regularity H0) => ?.
  move: (AnnTyping_regularity H6) => ?.
  move: (AnnTyping_regularity H7) => ?.
  assert (EA0A1 : AnnDefEq G0 D (g_IsoSnd g1) A0 A1).
  {  eapply An_IsoSnd. eauto. }
  assert (exists g, AnnDefEq G0 D g B B0).
  { eapply (erasure_AnnDefEq EA0A1); eauto 1. }
  destruct H1 as [g2 EBB0].

  destruct (AnnDefEq_regularity DE) as [C [D1 [g3 [TC [TD CD]]]]].
  simpl in EP1. inversion EP1.
  simpl in EP2. inversion EP2. subst. clear EP2. clear EP1.
  resolve_unique_nosubst.

  assert (exists g, AnnDefEq G0 D g a0 a0').
  { eexists.
    eapply An_EraseEq. eauto. eauto. eauto.
    eapply An_EraseEq. eapply AnnTyping_regularity. eauto.
    eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H1 as [g4 Ea0a0'].

  assert (exists g, AnnDefEq G0 D g B0 A1).
  { eexists.
    eapply An_EraseEq. eauto. eapply AnnTyping_regularity. eauto. eauto.
    eapply An_Refl. eauto. }
  destruct H1 as [g5 EB0A1].

  assert (exists g, AnnDefEq G0 D g A0 A0').
  { eexists.
    eapply An_EraseEq. eauto. eapply AnnTyping_regularity. eauto. eauto.
    eauto. }
  destruct H1 as [g6 EA0A0'].

  move: (An_Trans2 (An_Trans2 EB0A1 (An_Sym2 EA0A1)) EA0A0') => EB0A0'.
  move: (An_Trans2 (AnnDefEq_weaken_available EB0A0') CD) => EB0D1.
  move: (An_Trans2 (AnnDefEq_weaken_available EBB0) EB0D1) => EBD1.

  assert (exists g, AnnDefEq G0 D g b0 b0').
  { eexists.
    eapply An_EraseEq. eauto. eauto. eauto. eauto.
  }
  destruct H1 as [g7 Eb0b0'].
  
  eexists. exists a1, (a_Conv b1 g5), A1.
  repeat split.
  eapply An_Trans2 with (a1 := b1).
  eapply (An_Cast _ _ _ _ _ _ _ _ _ _ _ IP); eauto 1.
  eapply An_EraseEq. eauto 1.
  eapply An_Conv with (B := A1); eauto 1.
  eapply AnnDefEq_weaken_available; eauto 1.
  simpl. auto.
  eapply AnnDefEq_weaken_available; eauto 1.
  eauto 1.
  eapply An_Conv with (B := A1); eauto 1.
  eapply AnnDefEq_weaken_available; eauto 1.
  Unshelve.
  Focus 2.
  eapply (An_Trans2 (An_Trans2 Ea0a0' DE) (An_Sym2 Eb0b0')).
- 
  clear d. clear d0.
  destruct (H G0 H1 H2) as [g [a0' [b0' [A0' [EA [EB [S2 [DE [T1 U1]]]]]]]]]. clear H.
  destruct (H0 G0 H1 H2) as [g1 [A' [B' [S' [EP1 [EP2 [ES [DE2 [T2 U2]]]]]]]]]. clear H0.
  subst. rewrite -erase_dom in DE2.

  assert (exists g, AnnDefEq G0 D g A0' A').
  { eexists.
    eapply An_EraseEq. eauto. eapply AnnTyping_regularity. eauto. eauto.
    eauto.  eapply An_EraseEq.
    eapply An_Star. eauto 1. eapply AnnTyping_regularity. eauto.
    autorewcs. eauto 1.
    eapply An_Refl. eauto. }
  destruct H as [g2 EA0'A'].

  move: (An_Trans2 (AnnDefEq_weaken_available EA0'A') DE2) => EA0'B'.
  move: (AnnTyping_regularity T1) => TA0'.
  destruct (AnnDefEq_invertb EA0'B') as (S'' & B'' & g3 & TS & TB & EB & DB'B'').
  resolve_unique_nosubst.

  move: (An_Trans2 EA0'B' DB'B'') => EA0'B''.
  assert (exists g, AnnDefEq G0 D g (a_Conv a0' (g_Trans (g_Trans g2 g1) g3)) a0').
  { eexists. eapply An_EraseEq; eauto 1.
    eapply An_Conv; eauto 1. eapply An_Sym2. eauto.
  }
  destruct H as [g4 Ea0'].
  eexists. exists (a_Conv a0' (g_Trans (g_Trans g2 g1) g3)),
              (a_Conv b0' (g_Trans (g_Trans g2 g1) g3)), B''.
  repeat split; auto.
  eapply An_Trans2 with (a1 := a0'); eauto 1.
  eapply An_Trans2 with (a1 := b0'); eauto 1.
  eapply An_EraseEq; eauto 1. eapply An_Conv; eauto 1.
  eapply An_Conv; eauto 1.
  eapply An_Conv; eauto 1.
- clear i.
  destruct (H G0 H0 H1) as [g1 [phi' [phi2' [EP1 [EP2 IP]]]]]. clear H.
  destruct (AnnIso_regularity IP) as [WFF1 WFF2].
  inversion WFF1. inversion WFF2. subst.
  move: (AnnTyping_regularity H) => ?.
  move: (AnnTyping_regularity H6) => ?.
  simpl in EP1. inversion EP1.
  simpl in EP2. inversion EP2. subst. clear EP2. clear EP1.

  eexists. exists A0, A1, a_Star.
  repeat split; eauto 1.
  eapply An_IsoSnd. eauto.
- destruct (H _ H0 H1) as (a0 & A0 & E1 & E2 & AT).
  clear H.
  move: (AnnTyping_regularity AT) => h0.
  destruct (erase_pi E2 h0) as (A1 & B1 & E3 & E4 & E5 & AT1).
  have h1: (exists g, AnnDefEq G0 (dom G0) g A0 (a_Pi Rel A1 B1)).
  {
    eexists. eapply An_EraseEq; eauto.
  }
  move: h1 => [g TT].
  have h1: AnnTyping G0 (a_Conv a0 g) (a_Pi Rel A1 B1) by eauto.
  subst.
  have h2: erase a0 = erase (a_Conv a0 g) by simpl; auto.
  pick fresh y.
  move: (e y ltac:(auto)) => e0. rewrite h2 in e0.
  replace (a_App (erase (a_Conv a0 g)) Rel (a_Var_f y)) with
  (erase (a_App (a_Conv a0 g) Rel (a_Var_f y))) in e0.
  move: (An_Pi_inversion AT1) => h3. split_hyp.
  eexists.
  exists (a_Abs Rel A1 (close_tm_wrt_tm y (a_App (a_Conv a0 g) Rel (a_Var_f y)))).
  exists (a_Conv a0 g). exists (a_Pi Rel A1 B1).
  split.
  replace (erase
    (a_Abs Rel A1
            (close_tm_wrt_tm y (a_App (a_Conv a0 g) Rel (a_Var_f y)))))
  with
  (a_UAbs Rel
     (erase (close_tm_wrt_tm y
                             (a_App (a_Conv a0 g) Rel (a_Var_f y))))).
  autorewcs. rewrite -close_tm_erase_tm.
  rewrite -e0.
  autorewrite with lngen.
  auto.
  simpl; auto.
  repeat split; simpl; eauto 2.
  eapply An_Eta with (L := L \u dom G0 \u {{y}} ). eauto.
  intros.
  rewrite -tm_subst_tm_tm_spec.
  simpl.
  rewrite tm_subst_tm_tm_fresh_eq; auto.
  rewrite tm_subst_tm_co_fresh_eq; auto.
  destruct eq_dec; try done.
  eapply (@An_Abs_exists y); autorewrite with lngen; eauto 2.
  + fsetdec.
  + econstructor.
      eapply AnnTyping_weakening with (F:=nil); eauto with ctx_wff.
      simpl_env; eauto.
    + simpl; auto.
- destruct (H _ H0 H1) as (a0 & A0 & E1 & E2 & AT).
  clear H.
  move: (AnnTyping_regularity AT) => h0.
  destruct (erase_pi E2 h0) as (A1 & B1 & E3 & E4 & E5 & AT1).
  have h1: (exists g, AnnDefEq G0 (dom G0) g A0 (a_Pi Irrel A1 B1)).
  {
    eexists. eapply An_EraseEq; eauto.
  }
  move: h1 => [g TT].
  have h1: AnnTyping G0 (a_Conv a0 g) (a_Pi Irrel A1 B1) by eauto.
  subst.
  have h2: erase a0 = erase (a_Conv a0 g) by simpl; auto.
  pick fresh y.
  move: (e y ltac:(auto)) => e0. rewrite h2 in e0.
  replace (a_App (erase (a_Conv a0 g)) Irrel a_Bullet) with
  (erase (a_App (a_Conv a0 g) Irrel (a_Var_f y))) in e0.
  move: (An_Pi_inversion AT1) => h3. split_hyp.
  eexists. 
  exists (a_Abs Irrel A1 (close_tm_wrt_tm y (a_App (a_Conv a0 g) Irrel (a_Var_f y)))).
  exists (a_Conv a0 g). exists (a_Pi Irrel A1 B1).
  split.
  replace (erase
    (a_Abs Irrel A1
            (close_tm_wrt_tm y (a_App (a_Conv a0 g) Irrel (a_Var_f y)))))
  with
  (a_UAbs Irrel
     (erase (close_tm_wrt_tm y
                             (a_App (a_Conv a0 g) Irrel (a_Var_f y))))).
  autorewcs. rewrite -close_tm_erase_tm. simpl. simpl in e0.
  rewrite -e0.
  autorewrite with lngen.
  auto.
  simpl; auto.
  repeat split; simpl; eauto 2.
  eapply An_Eta with (L := L \u dom G0 \u {{y}} ). eauto.
  intros.
  rewrite -tm_subst_tm_tm_spec.
  simpl.
  rewrite tm_subst_tm_tm_fresh_eq; auto.
  rewrite tm_subst_tm_co_fresh_eq; auto.
  destruct eq_dec; try done.
  eapply (@An_Abs_exists y); autorewrite with lngen; eauto 2.
  + fsetdec.
  + econstructor.
      eapply AnnTyping_weakening with (F:=nil); eauto with ctx_wff.
      simpl_env; eauto.
    + simpl; auto. constructor. simpl.
      apply union_notin_iff. split.
      apply fv_tm_erase_tm. fsetdec. eauto.
    + simpl. auto.
 - destruct (H _ H0 H1) as (a0 & A0 & E1 & E2 & AT).
  clear H.
  move: (AnnTyping_regularity AT) => h0.
  destruct (erase_cpi E2 h0) as (A1 & B1 & E3 & E4 & E5 & AT1).
  have h1: (exists g, AnnDefEq G0 (dom G0) g A0 (a_CPi A1 B1)).
  {
    eexists. eapply An_EraseEq; eauto.
    
  } 
  move: h1 => [g TT].
  have h1: AnnTyping G0 (a_Conv a0 g) (a_CPi A1 B1) by eauto.
  subst.
  have h2: erase a0 = erase (a_Conv a0 g) by simpl; auto.
  pick fresh y.
  move: (e y ltac:(auto)) => e0. rewrite h2 in e0.
  replace (a_CApp (erase (a_Conv a0 g)) g_Triv) with
  (erase (a_CApp (a_Conv a0 g) g_Triv)) in e0; eauto.
  move: (An_CPi_inversion AT1) => h3. split_hyp.
  eexists. exists (a_CAbs A1 (close_tm_wrt_co y (a_CApp (a_Conv a0 g) (g_Var_f y)))).
  exists (a_Conv a0 g). exists (a_CPi A1 B1).
  split.
  replace (erase
    (a_CAbs A1
            (close_tm_wrt_co y (a_CApp (a_Conv a0 g) (g_Var_f y)))))
  with
  (a_UCAbs
     (erase (close_tm_wrt_co y
                             (a_CApp (a_Conv a0 g) (g_Var_f y))))).
  autorewcs. rewrite -close_co_erase_tm. simpl. simpl in e0.
  rewrite -e0.
  autorewrite with lngen.
  auto.
  simpl; auto.
  repeat split; simpl; eauto 2. 
  eapply An_EtaC with (L := L \u dom G0 \u {{y}} ). eauto.
  intros. rewrite -co_subst_co_tm_spec.
  simpl. rewrite co_subst_co_tm_fresh_eq; auto.
  rewrite co_subst_co_co_fresh_eq; auto. auto.
  destruct eq_dec; try done.
  eapply (@An_CAbs_exists y); autorewrite with lngen; eauto 2.
  + fsetdec.
  + destruct A1. eapply An_CApp. 
      eapply AnnTyping_weakening with (F:=nil); eauto with ctx_wff.
      eapply An_Assn; eauto.
Qed.

End erase.
