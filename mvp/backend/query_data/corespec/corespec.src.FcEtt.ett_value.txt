Set Bullet Behavior "Strict Subproofs".

Set Implicit Arguments.



Require Export FcEtt.tactics.

Require Export FcEtt.imports.

Require Export FcEtt.ett_inf.

Require Export FcEtt.ett_ott.

Require Export FcEtt.ett_ind.



Require Export FcEtt.ext_context_fv.



Require Import FcEtt.ext_wf.
(* FcEtt.ext_wf:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Import FcEtt.imports.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.
Require Import FcEtt.tactics.

Require Import FcEtt.utils.

Require Import FcEtt.sigs.
Require Import FcEtt.toplevel.

Lemma Path_lc : forall T a, Path T a -> lc_tm a.

Hint Resolve Path_lc : lc.

Lemma DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.
Hint Resolve DataTy_lc : lc.

Lemma CoercedValue_Value_lc_mutual: (forall A, CoercedValue A -> lc_tm A) /\
                                    (forall A, Value A -> lc_tm A).

Lemma Value_lc : forall A, Value A -> lc_tm A.
Lemma CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

Hint Resolve Value_lc CoercedValue_lc : lc.

Lemma ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Definition Typing_Ctx  := first  ctx_wff_mutual.
Definition PropWff_Ctx := second ctx_wff_mutual.
Definition Iso_Ctx     := third  ctx_wff_mutual.
Definition DefEq_Ctx   := fourth ctx_wff_mutual.

Hint Resolve Typing_Ctx PropWff_Ctx Iso_Ctx DefEq_Ctx.

Lemma Ctx_uniq : forall G, Ctx G -> uniq G.

Hint Resolve Ctx_uniq.

Lemma lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi, PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T, DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Definition Typing_lc  := first lc_mutual.
Definition PropWff_lc := second lc_mutual.
Definition Iso_lc     := third lc_mutual.
Definition DefEq_lc   := fourth lc_mutual.
Definition Ctx_lc     := fifth lc_mutual.

Lemma Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Lemma Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Lemma Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Lemma Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.
Lemma DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.

Lemma DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Lemma DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Hint Resolve Typing_lc1 Typing_lc2 Iso_lc1 Iso_lc2 DefEq_lc1 DefEq_lc2 DefEq_lc3 Ctx_lc : lc.

Lemma Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s. *)

Import ext_wf.



Require Import FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)

Require Import FcEtt.erase_syntax.
(* FcEtt.erase_syntax:
Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).

Lemma erase_dom : forall G, dom G = dom (erase_context G).

Lemma path_erase : forall T p, Path T p -> Path T (erase p).

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end. *)

Require Export FcEtt.toplevel.



Lemma Path_tm_subst_tm_tm : forall T a x b, Path T a -> lc_tm b -> Path T (tm_subst_tm_tm b x a).

Proof. induction 1; try destruct rho; simpl; eauto with lngen.

Qed.



Lemma Path_co_subst_co_tm : forall T a x b, Path T a -> lc_co b -> Path T (co_subst_co_tm b x a).

Proof. induction 1; try destruct rho; simpl; eauto with lngen.

Qed.



Hint Resolve Path_tm_subst_tm_tm Path_co_subst_co_tm : lngen.



Lemma Path_unique : forall T1 T2 a, Path T1 a -> Path T2 a -> T1 = T2.

Proof.

  induction 1; intros P; inversion P; auto.

Qed.



Lemma DataTy_tm_subst_tm_tm : forall b x A,

    DataTy A a_Star -> lc_tm b -> DataTy (tm_subst_tm_tm b x A) a_Star.

Proof.

  intros. dependent induction H; simpl; eauto.

  - pick fresh y and apply DT_Pi.

    eauto with lngen.

    autorewrite with subst_open_var; eauto.

  - pick fresh y and apply DT_CPi.

    eauto with lngen.

    autorewrite with subst_open_var; eauto.

Qed.



Lemma DataTy_co_subst_co_tm : forall b x A,

    DataTy A a_Star -> lc_co b -> DataTy (co_subst_co_tm b x A) a_Star.

Proof.

  intros. dependent induction H; simpl; eauto.

  - pick fresh y and apply DT_Pi.

    eauto with lngen.

    autorewrite with subst_open_var; eauto.

  - pick fresh y and apply DT_CPi.

    eauto with lngen.

    autorewrite with subst_open_var; eauto.

Qed.



Hint Resolve DataTy_tm_subst_tm_tm DataTy_co_subst_co_tm : lngen.



Definition decide_Path : forall a, lc_tm a -> (exists T, Path T a) \/ (forall T, not (Path T a)).

Proof.

  induction a; intro lc.

  all: try solve [left; eauto].

  all: try solve [right; move => T h1; inversion h1].

  - lc_inversion c. destruct IHa1 as [[T h0]|n].

    auto.

    left; eauto.

    right. move => T h1. inversion h1.

    subst. unfold not in n. eauto.

  - lc_inversion c. destruct IHa as [[T h0]|n].

    auto.

    left; eauto.

    right. intros T h; inversion h; subst; unfold not in n; eauto.

  - lc_inversion c. destruct IHa as [[T h0]|n].

    auto.

    left. exists T. auto.

    right. intros T h; inversion h; subst; unfold not in n; eauto.

Qed.



Lemma tm_subst_tm_tm_Value_mutual :

  (forall v,  CoercedValue v -> forall b x,  lc_tm b -> CoercedValue (tm_subst_tm_tm b x v)) /\

  (forall v, Value v -> forall b x,  lc_tm b -> Value (tm_subst_tm_tm b x v)).

Proof.

  apply CoercedValue_Value_mutual; simpl.

  all: try solve [inversion 1 | econstructor; eauto]; eauto.

  all: try solve [intros;

                  eauto using tm_subst_tm_tm_lc_tm,

                  tm_subst_tm_constraint_lc_constraint,

                  tm_subst_tm_co_lc_co,

                  Path_tm_subst_tm_tm].

  all: try solve [intros;

    constructor; eauto using tm_subst_tm_tm_lc_tm,  tm_subst_tm_constraint_lc_constraint;

    match goal with [H: lc_tm (?a1 ?a2), K : lc_tm ?b |- _ ] =>

                    move: (tm_subst_tm_tm_lc_tm _ _ x H K) => h0; auto end].



  - intros L a v H b x H0.

    econstructor; eauto.

    instantiate (1 := L \u singleton x) => x0 h0.

    rewrite tm_subst_tm_tm_open_tm_wrt_tm_var; auto.

  - intros L A a l c H b x H0.

    econstructor; eauto.

    apply tm_subst_tm_tm_lc_tm; auto.

    instantiate (1 := L \u singleton x) => x0 h0.

    rewrite tm_subst_tm_tm_open_tm_wrt_tm_var; auto.

Qed.



Lemma Value_tm_subst_tm_tm :

  (forall v b x, Value v -> lc_tm b -> Value (tm_subst_tm_tm b x v)).

Proof.

  intros v b x H H0.

  apply tm_subst_tm_tm_Value_mutual; auto.

Qed.



Lemma CoercedValue_tm_subst_tm_tm :

  (forall v b x, CoercedValue v -> lc_tm b -> CoercedValue (tm_subst_tm_tm b x v)).

Proof.

  intros v b x H H0.

  destruct (tm_subst_tm_tm_Value_mutual); auto.

Qed.



Lemma Value_UAbsIrrel_exists : ∀ x (a : tm),

    x `notin` fv_tm a

    → (Value (open_tm_wrt_tm a (a_Var_f x)))

    → Value (a_UAbs Irrel a).

Proof.

  intros.

  eapply (Value_UAbsIrrel ({{x}})); eauto.

  intros.

  rewrite (tm_subst_tm_tm_intro x); eauto.

  eapply Value_tm_subst_tm_tm; auto.

Qed.



Lemma Value_AbsIrrel_exists : ∀ x (A a : tm),

    x `notin` fv_tm a

    -> lc_tm A

    → (CoercedValue (open_tm_wrt_tm a (a_Var_f x)))

    → Value (a_Abs Irrel A a).

Proof.

  intros.

  eapply (Value_AbsIrrel ({{x}})); eauto.

  intros.

  rewrite (tm_subst_tm_tm_intro x); eauto.

  eapply CoercedValue_tm_subst_tm_tm; auto.

Qed.



Lemma co_subst_co_tm_Value_mutual :

  (forall v,  CoercedValue v -> forall b x,  lc_co b -> CoercedValue (co_subst_co_tm b x v)) /\

  (forall v, Value v -> forall b x,  lc_co b -> Value (co_subst_co_tm b x v)).

Proof.

  apply CoercedValue_Value_mutual; simpl.

  all: try solve [inversion 1 | econstructor; eauto]; eauto.

  all: try solve [intros;

                  eauto using co_subst_co_tm_lc_tm,

                  co_subst_co_constraint_lc_constraint,

                  co_subst_co_co_lc_co,

                  Path_co_subst_co_tm].

  all: try solve [intros;

    constructor; eauto using co_subst_co_tm_lc_tm,

                              co_subst_co_constraint_lc_constraint;

    match goal with [H: lc_tm (?a1 ?a2), K : lc_co ?b |- _ ] =>

                    move: (co_subst_co_tm_lc_tm _ _ x H K) => h0; auto end].

  - intros.

    pick fresh y.

    eapply Value_UAbsIrrel_exists with (x:=y).

    eapply fv_tm_tm_tm_co_subst_co_tm_notin; eauto.

    move: (H y ltac:(eauto) b x H0) => h0.

    rewrite co_subst_co_tm_open_tm_wrt_tm in h0.

    simpl in h0. auto. auto.

  - intros.

    pick fresh y.

    eapply Value_AbsIrrel_exists with (x:=y).

    eapply fv_tm_tm_tm_co_subst_co_tm_notin; eauto.

    eapply co_subst_co_tm_lc_tm; eauto.

    move: (H y ltac:(eauto) b x H0) => h0.

    rewrite co_subst_co_tm_open_tm_wrt_tm in h0; auto.

Qed.



Lemma Value_co_subst_co_tm :

  (forall v b x, Value v -> lc_co b -> Value (co_subst_co_tm b x v)).

Proof.

  intros v b x H H0.

  apply co_subst_co_tm_Value_mutual; auto.

Qed.



Lemma CoercedValue_co_subst_co_tm :

  (forall v b x, CoercedValue v -> lc_co b -> CoercedValue (co_subst_co_tm b x v)).

Proof.

  intros v b x H H0.

  destruct (co_subst_co_tm_Value_mutual); auto.

Qed.



Lemma decide_Value_mutual : forall a,

    lc_tm a ->

    (Value a \/ not (Value a)) /\ (CoercedValue a \/ (not (CoercedValue a))).

Proof.

  induction 1; try destruct rho.

  all: try solve [split; left; auto].

  all: try solve [split; right; intro h; inversion h; try inversion H;

                  try inversion H1].

  - pick fresh x.

    destruct (H1 x) as [[V|NV][CV|NCV]].

    all: try solve [split; left; eauto using Value_AbsIrrel_exists].

    + split;

      right; intro h; inversion h; try inversion H2; subst;

      apply NCV;

      pick fresh y;

      rewrite (tm_subst_tm_tm_intro y); eauto;

      eapply CoercedValue_tm_subst_tm_tm; eauto.

  - pick fresh x.

    destruct (H0 x) as [[V|NV]_].

    all: try solve [split; left; eauto using Value_UAbsIrrel_exists].

    split.

    all: right; intro h; inversion h; try inversion H1; subst; apply NV;

      pick fresh y;

      rewrite (tm_subst_tm_tm_intro y); eauto;

        eapply Value_tm_subst_tm_tm; eauto.

  - destruct (IHlc_tm1) as [[V|NV][CV|NCV]];

      destruct (decide_Path H) as [[T P]|NP].

    all: split.

    all: try solve [left; eauto].

    all: try solve [right; intro h; inversion h; try inversion H1; eapply NP; eauto].

    all: try solve [right; intro h; inversion h; try inversion H1; done].

  - destruct (IHlc_tm1) as [[V|NV][CV|NCV]];

      destruct (decide_Path H) as [[T P]|NP].

    all: split.

    all: try solve [left; eauto].

    all: try solve [right; intro h; inversion h; try inversion H1; eapply NP; eauto].

    all: try solve [right; intro h; inversion h; try inversion H1; done].

  - destruct (IHlc_tm) as [[V|NV][CV|NCV]].

    all: split.

    all: try solve [left; eauto].

    all: try solve [right; intro h; inversion h].

    right. intro h; inversion h. inversion H1. done.

    right. intro h; inversion h. inversion H1. done.

  - destruct (IHlc_tm) as [[V|NV][CV|NCV]];

      destruct (decide_Path H) as [[T P]|NP].

    all: split.

    all: try solve [left; eauto].

    all: try solve [right; intro h; inversion h; try inversion H1; eapply NP; eauto].

    all: try solve [right; intro h; inversion h; try inversion H1; done].

Qed.



Lemma decide_Value : forall a, lc_tm a -> (Value a \/ not (Value a)).

Proof.

  intros a.

  eapply decide_Value_mutual.

Qed.



Lemma decide_CoercedValue : forall a, lc_tm a -> (CoercedValue a \/ not (CoercedValue a)).

Proof.

  intros a.

  eapply decide_Value_mutual.

Qed.



Lemma DataTy_value_type : forall A, DataTy A a_Star -> value_type A.

Proof.

  intros A H.

  dependent induction H; eauto with lc.

Qed.

