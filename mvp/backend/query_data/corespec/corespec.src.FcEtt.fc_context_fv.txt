Require Export FcEtt.tactics.

Require Export FcEtt.ett_inf.



Require Import FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)

Require Import FcEtt.imports.
(* FcEtt.imports:
Require Export Coq.Unicode.Utf8.

Require Export Coq.Program.Basics.
Require Export Coq.Program.Equality.

Require Export Metalib.Metatheory.
Require Export Metalib.LibLNgen.

Require Export FcEtt.ett_ott.

Require Export mathcomp.ssreflect.ssreflect.
Close Scope boolean_if_scope.
Global Open Scope general_if_scope.

Global Set Implicit Arguments.
Global Set Bullet Behavior "Strict Subproofs".

Notation sort := sort (only parsing). *)



Require Import FcEtt.ett_ind.
(* FcEtt.ett_ind:
Require Import FcEtt.utils.
Require Import FcEtt.imports.

Require Export FcEtt.fset_facts.
Require Export FcEtt.ett_inf.
Require Export FcEtt.tactics.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma tm_subst_tm_tm_var : forall a x, tm_subst_tm_tm a x (a_Var_f x) = a.

Lemma co_subst_co_co_var : forall a x, co_subst_co_co a x (g_Var_f x) = a.

Lemma tm_subst_tm_tm_var_neq : forall a x y, x <> y ->
    tm_subst_tm_tm a y (a_Var_f x) = (a_Var_f x).

Lemma co_subst_co_co_var_neq : forall a x y, x <> y ->
    co_subst_co_co a y (g_Var_f x) = (g_Var_f x).

Hint Rewrite tm_subst_tm_tm_var co_subst_co_co_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_co_open_co_wrt_tm_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co_var : subst_open_var.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm_var : subst_open_var.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm_var : open_subst_var.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co_var : open_subst_var.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co_var : open_subst_var.

Hint Rewrite tm_subst_tm_tm_open_tm_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_tm_open_tm_wrt_co : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_tm : subst_open.
Hint Rewrite tm_subst_tm_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_co : subst_open.
Hint Rewrite co_subst_co_co_open_co_wrt_tm : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_co : subst_open.
Hint Rewrite co_subst_co_tm_open_tm_wrt_tm : subst_open.

Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- tm_subst_tm_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_co_open_co_wrt_tm : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_co : open_subst.
Hint Rewrite <- co_subst_co_tm_open_tm_wrt_tm : open_subst.

Ltac apply_lc_exists x :=
  pick fresh x;
  ( apply lc_a_Abs_exists      with (x1 := x)
  || apply lc_a_Pi_exists       with (x1 := x)
  || apply lc_a_CPi_exists      with (c1 := x)
  || apply lc_a_CAbs_exists     with (c1 := x)
  || apply lc_a_UAbs_exists     with (x1:= x)
  || apply lc_a_UCAbs_exists    with (c1 := x)
  || apply lc_g_PiCong_exists   with (x1 := x)
  || apply lc_g_AbsCong_exists  with (x1 := x)
  || apply lc_g_CPiCong_exists  with (c1 := x)
  || apply lc_g_CAbsCong_exists with (c1 := x)
  || fail "invalid case for apply_lc_exists" );
  eauto 2.

Ltac lc_solve_binds :=
  match goal with
  
  | [ H : binds ?x ?s nil |- _ ] => inversion H; clear H
  
  | [ H : binds _ ?s ([(_,_)] ++ _) |- _ ?s] =>
      destruct (binds_cons_1 _ _ _ _ _ _ H); basic_solve
  
  | [ b : binds ?x _ ?G, H : ∀ (x' : atom) _, binds x' _ ?G → _ |- _] =>
      by apply H in b; inversion b; try done;
          match goal with
            | [H' : lc_constraint _ |- _] => inversion H' ; clear H'
            | [H' : lc_tm         _ |- _] => inversion H' ; clear H'
          end
  end.

Ltac lc_inversion c :=
  repeat match goal with
    
  | [ H : forall x, (x `in` ?L -> False) -> lc_tm _ /\ _ |- _ ] =>
    destruct (H c ltac:(auto)); split_hyp; clear H
  
  | [ H : lc_constraint (_ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Abs _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_App _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Pi _ _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Conv _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CPi _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CAbs _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_UCAbs _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_CApp _ _) |- _ ] =>
    inversion H; clear H
  | [ H : lc_tm (a_Case _ _) |- _ ] =>
    inversion H; clear H
 end.

Ltac apply_lc_body :=
  match goal with
  | |- lc_tm (open_tm_wrt_tm ?a ?b) => eapply lc_body_tm_wrt_tm; auto
  | |- lc_tm (open_tm_wrt_co ?a ?b) => eapply lc_body_tm_wrt_co; auto
  end.

Lemma co_subst_co_tm_lc_tm_inverse
  : ∀ (g1 : co) (c1 : covar),
      lc_co g1 ->
      (forall A,
          lc_tm A -> forall XX, A = (co_subst_co_tm g1 c1 XX) -> lc_tm XX)
      /\
      (forall b1,
          lc_brs b1 -> forall XX, b1 = (co_subst_co_brs g1 c1 XX) -> lc_brs XX)
      /\
      (forall co,
          lc_co co -> forall XX, co = (co_subst_co_co g1 c1 XX) -> lc_co XX)
      /\
      (forall phi,
          lc_constraint phi -> forall XX, phi = (co_subst_co_constraint g1 c1 XX) ->
          lc_constraint XX).

Ltac invert_syntactic_equality :=
  repeat match goal with
  | [ H : a_Var_f _  = a_Var_f _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Abs _ _ = a_Abs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UAbs _ _ = a_UAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Pi _ _ _ = a_Pi _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_App _ _ _ = a_App _ _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Fam _  = a_Fam _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Const _  = a_Const _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_Conv _ _ = a_Conv _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_UCAbs _ = a_UCAbs _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CAbs + _ = a_CAbs _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CApp _ _  = a_CApp _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : a_CPi _ _ = a_CPi _ _ |- _ ] =>
    inversion H; subst; clear H
  | [ H : Eq _ _ _ = Eq _ _ _ |- _ ] =>
    inversion H; subst; clear H
  end.

Ltac ann_invert_clear :=
  match goal with
  | H : AnnTyping _ a_Star _ |- _ => inversion H; subst; clear H
  | H : AnnTyping _ (_ _) _ |- _ =>  inversion H; subst; clear H
  | H : AnnPropWff _ _ |- _ => inversion H; subst; clear H
  | H : AnnIso _ _ (_ _) _ _ |- _ => inversion H; subst; clear H
  | H : AnnDefEq _ _ (_ _) _ _  |- _ => inversion H; subst; clear H
  | H : AnnCtx ([(_,_)] ++ _) |- _ => inversion H; subst; clear H
  | H : AnnCtx (_ :: _) |- _ => inversion H; subst; clear H
  end.

Lemma lc_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    lc_tm (open_tm_wrt_tm a (a_Var_f x0)).

Lemma fv_swap : forall x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->
    x0 `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0)).

Scheme typing_ind' := Induction for Typing Sort Prop
   with wff_ind'   := Induction for PropWff Sort Prop
   with iso_ind'   := Induction for Iso Sort Prop
   with defeq_ind' := Induction for DefEq Sort Prop
   with ctx_ind'   := Induction for Ctx Sort Prop.

Combined Scheme typing_wff_iso_defeq_mutual from typing_ind', wff_ind', iso_ind', defeq_ind', ctx_ind'.

Scheme ann_typing_ind' := Induction for AnnTyping Sort Prop
   with ann_wff_ind'   := Induction for AnnPropWff Sort Prop
   with ann_iso_ind'   := Induction for AnnIso Sort Prop
   with ann_defeq_ind' := Induction for AnnDefEq Sort Prop
   with ann_ctx_ind'   := Induction for AnnCtx Sort Prop.

Combined Scheme ann_typing_wff_iso_defeq_mutual
from ann_typing_ind', ann_wff_ind', ann_iso_ind',
     ann_defeq_ind', ann_ctx_ind'.

Scheme CoercedValue_ind' := Induction for CoercedValue Sort Prop
                            with Value_ind' := Induction for Value Sort Prop.
Combined Scheme CoercedValue_Value_mutual from CoercedValue_ind', Value_ind'.

Ltac ext_induction CON :=
    apply typing_wff_iso_defeq_mutual;
    [ pose CON :=  E_Star       |
      pose CON :=  E_Var        |
      pose CON :=  E_Pi         |
      pose CON :=  E_Abs        |
      pose CON :=  E_App        |
      pose CON :=  E_IApp       |
      pose CON :=  E_Conv       |
      pose CON :=  E_CPi        |
      pose CON :=  E_CAbs       |
      pose CON :=  E_CApp       |
      pose CON :=  E_Const      |
      pose CON :=  E_Fam        |
      pose CON :=  E_Wff        |
      pose CON :=  E_PropCong   |
      pose CON :=  E_IsoConv    |
      pose CON :=  E_CPiFst     |
      pose CON :=  E_Assn       |
      pose CON :=  E_Refl       |
      pose CON :=  E_Sym        |
      pose CON :=  E_Trans      |
      pose CON :=  E_Beta       |
      pose CON :=  E_PiCong     |
      pose CON :=  E_AbsCong    |
      pose CON :=  E_AppCong    |
      pose CON :=  E_IAppCong   |
      pose CON :=  E_PiFst      |
      pose CON :=  E_PiSnd      |
      pose CON :=  E_CPiCong    |
      pose CON :=  E_CAbsCong   |
      pose CON :=  E_CAppCong   |
      pose CON :=  E_CPiSnd     |
      pose CON :=  E_Cast       |
      pose CON :=  E_EqConv     |
      pose CON :=  E_IsoSnd     |
      pose CON :=  E_EtaRel     |
      pose CON :=  E_EtaIrrel   |
      pose CON :=  E_EtaC       |

      pose CON :=  E_Empty      |
      pose CON :=  E_ConsTm     |
      pose CON :=  E_ConsCo     ].

Ltac ann_induction CON :=
    apply ann_typing_wff_iso_defeq_mutual;
    [ pose CON :=  An_Star       |
      pose CON :=  An_Var        |
      pose CON :=  An_Pi         |
      pose CON :=  An_Abs        |
      pose CON :=  An_App        |
      pose CON :=  An_Conv       |
      pose CON :=  An_CPi        |
      pose CON :=  An_CAbs       |
      pose CON :=  An_CApp       |
      pose CON :=  An_Const      |
      pose CON :=  An_Fam        |
      pose CON :=  An_Wff        |
      pose CON :=  An_PropCong   |
      pose CON :=  An_CPiFst     |
      pose CON :=  An_IsoSym     |
      pose CON :=  An_IsoConv    |
      pose CON :=  An_Assn       |
      pose CON :=  An_Refl       |
      pose CON :=  An_EraseEq      |
      pose CON :=  An_Sym        |
      pose CON :=  An_Trans      |
      pose CON :=  An_Beta       |
      pose CON :=  An_PiCong     |
      pose CON :=  An_AbsCong    |
      pose CON :=  An_AppCong    |
      pose CON :=  An_PiFst      |
      pose CON :=  An_PiSnd      |
      pose CON :=  An_CPiCong    |
      pose CON :=  An_CAbsCong   |
      pose CON :=  An_CAppCong   |
      pose CON :=  An_CPiSnd     |
      pose CON :=  An_Cast       |
      pose CON :=  An_IsoSnd     |
      pose CON :=  An_Eta        |
      pose CON :=  An_EtaC       |

      pose CON :=  An_Empty      |
      pose CON :=  An_ConsTm     |
      pose CON :=  An_ConsCo     ].

Ltac ensure_case C :=
  match goal with [ CON := C : ?A |- _ ] => idtac end.

Ltac gather_atoms ::=
  let A := gather_atoms_with (fun x : vars => x) in
  let B := gather_atoms_with (fun x : var => {{ x }}) in
  let C1 := gather_atoms_with (fun x : context => dom x) in
  let D1 := gather_atoms_with (fun x => fv_tm_tm_tm x) in
  let D2 := gather_atoms_with (fun x => fv_tm_tm_co x) in
  let D3 := gather_atoms_with (fun x => fv_tm_tm_constraint x) in
  let D4 := gather_atoms_with (fun x => fv_tm_tm_sort x) in
  let D5 := gather_atoms_with (fun x => fv_tm_tm_brs x) in
  let D6 := gather_atoms_with (fun x => fv_co_co_tm x) in
  let D7 := gather_atoms_with (fun x => fv_co_co_co x) in
  let D8 := gather_atoms_with (fun x => fv_co_co_constraint x) in
  let D9 := gather_atoms_with (fun x => fv_co_co_sort x) in
  let D10 := gather_atoms_with (fun x => fv_co_co_brs x) in
  constr:(A \u B \u C1 \u D1 \u D2 \u D3 \u D4 \u D5 \u D6 \u D7 \u D8 \u D9 \u D10).

Ltac rewrite_body :=
  match goal with
  | [ e : ∀ x : atom, (x `in` ?L → False)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
     rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L)
      → open_tm_wrt_tm _ (a_Var_f x) = open_tm_wrt_tm _ (_ (a_Var_f x) _) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ c : atom, (c `notin` ?L)
      → open_tm_wrt_co _ (g_Var_f c) =
        open_tm_wrt_co _ (g_Cast (g_Var_f c) (g_Sym _)) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `in` ?L → False) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Var_f x) |- _ ] =>
    rewrite e; auto
  | [ e : ∀ x : atom, (x `notin` ?L) →  _ _ (a_Var_f x) = _ _ _ (a_Bullet) |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `in` ?L → False) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto
  | [ e: ∀ c : atom,
    (c `notin` ?L) → _ _ (g_Var_f c) = a_CApp _ _ |- _ ] =>
    rewrite e; auto

  end.

Ltac lc_solve :=
  let c := fresh in
  try lc_solve_binds;
  try apply_lc_exists c;
  lc_inversion c; auto;
  try rewrite_body;
  try apply_lc_body;
  eauto with lc.

Hint Resolve lc_a_Pi_exists
     lc_a_CPi_exists lc_a_Abs_exists lc_a_CAbs_exists lc_a_UAbs_exists.

Hint Resolve lc_body_tm_wrt_tm lc_body_tm_wrt_co. 

Lemma rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm a ->
    x0 `notin` fv_tm_tm_tm a ->
    RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)) ->
    RhoCheck rho x0 (open_tm_wrt_tm a (a_Var_f x0)).

Lemma eta_swap: forall x y a' b rho,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b rho (a_Var_f x) ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b rho (a_Var_f y).

Lemma eta_swap_irrel: forall x y a' b,
    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm b ->
    open_tm_wrt_tm a' (a_Var_f x) = a_App b Irrel a_Bullet ->
    open_tm_wrt_tm a' (a_Var_f y) = a_App b Irrel a_Bullet.

Lemma eta_swap_c: forall x y a' b,
    x `notin` fv_co_co_tm a' \u fv_co_co_tm b ->
    open_tm_wrt_co a' (g_Var_f x) = a_CApp b g_Triv ->
    open_tm_wrt_co a' (g_Var_f y) = a_CApp b g_Triv.

Ltac auto_rew_env :=
  multimatch goal with
    | [ |- context [([(?x, ?T)] ++ ?G1 ++ ?G2 ++ ?G3)] ] => rewrite_env (((x ~ (T)) ++ G1) ++ G2 ++ G3)
  end.

Ltac E_pick_fresh x :=
  match goal with
    | [ |- Typing _ ?shape _ ] =>
      let v := match shape with
            | a_Pi _ _ _ => E_Pi
            | a_UAbs _ _ => E_Abs
            | a_CPi _ _  => E_CPi
            | a_CAbs _ _ => E_CAbs
            | a_UCAbs _  => E_CAbs
           end
      in pick fresh x and apply v
    | [ |- DefEq _ _ ?shape ?s2 _ ] =>
      let v := match shape with
               | a_Pi _ _ _ => E_PiCong
               | a_UAbs Rel _ => match s2 with
                                | a_UAbs _ _ => E_AbsCong
                                | _ => E_EtaRel
                                end
               | a_UAbs Irrel _ => match s2 with 
                                | a_UAbs _ _ =>  E_AbsCong
                                | _ => E_EtaIrrel
                                end
               | a_CPi _ _  => E_CPiCong
               | a_CAbs _ _ => E_CAbsCong
               | a_UCAbs _  => match s2 with 
                                | a_UCAbs _ =>  E_CAbsCong
                                | _ => E_EtaC
                                end
               end
      in pick fresh x and apply v
  end.

Ltac Par_pick_fresh x :=
  match goal with
    | [ |- Par _ _ ?shape ?s2 ] =>
      let v := match shape with
            | a_Pi _ _ _ => Par_Pi
            | a_UAbs Rel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_Eta
                                end
            | a_UAbs Irrel _ =>  match s2 with
                                | a_UAbs _ _ => Par_Abs
                                | _ => Par_EtaIrrel
                                end
            | a_UAbs _ _ =>  Par_Abs
            | a_CPi _ _  => Par_CPi
            | a_CAbs _ _ => Par_CAbs
            | a_UCAbs _  => match s2 with
                                | a_UCAbs _ => Par_CAbs
                                | _ => Par_EtaC
                                end
           end
      in pick fresh x and apply v
  end.

Ltac An_pick_fresh x :=
  let shape := match goal with
                 | [ |- AnnTyping _   ?shape _    ] => shape
                 | [ |- AnnDefEq  _ _ ?shape _  _ ] => shape
               end in
  let ctor  := match shape with
    | a_Pi     _ _ _ => An_Pi
    | a_Abs    _ _ _ => An_Abs
    | a_CPi      _ _ => An_CPi
    | a_CAbs     _ _ => An_CAbs
    | g_PiCong _ _ _ => An_PiCong
    | g_AbsCong _ _ _  => An_AbsCong
    | g_CPiCong  _ _   => An_CPiCong
    | g_CAbsCong _ _ _ => An_CAbsCong
    | g_Eta _          => An_Eta
               end in
  pick fresh x and apply ctor.

Ltac RhoCheck_inversion y :=
  match goal with
  | [ K : ∀ x : atom, x `notin` ?L → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  | [ K : ∀ x : atom, (x `in` ?L -> False) → RhoCheck ?rho x ?b |- _ ] =>
    move: (K y ltac:(auto)); inversion 1; subst; clear K
  end.

Lemma lc_open_switch_co :
  forall g t, lc_co g ->
  lc_tm (open_tm_wrt_co t g_Triv) ->
  lc_tm (open_tm_wrt_co t g).

Hint Resolve lc_open_switch_co.

Lemma tm_subst_cast : forall a x g,
    tm_subst_tm_tm a x (a_Conv (a_Var_f x) g) = a_Conv a (tm_subst_tm_co a x g).

Hint Rewrite tm_subst_cast. *)



Set Bullet Behavior "Strict Subproofs".

Set Implicit Arguments.



Hint Resolve AnnCtx_uniq.

Hint Unfold AtomSetImpl.Subset.



Ltac solve_binds :=

  match goal with

    | [ b : binds ?v _ ?G

      , H : forall v' _, binds v' _ ?G -> _ [<=] dom ?G ∧ _ [<=] dom ?G

      |- _ ] =>

      apply H in b; simpl in b; split_hyp; (done || fsetdec)

  end.



Theorem ann_context_fv_mutual :

  (forall G (a : tm) A (H: AnnTyping G a A),

      fv_tm_tm_tm a [<=] dom G /\ fv_co_co_tm a [<=] dom G /\

      fv_tm_tm_tm A [<=] dom G /\ fv_co_co_tm A [<=] dom G)

  /\

  (forall G phi (H : AnnPropWff G phi),

      fv_tm_tm_constraint phi [<=] dom G /\ fv_co_co_constraint phi [<=] dom G)

  /\

  (forall G D g p1 p2 (H : AnnIso G D g p1 p2),

      fv_tm_tm_co         g  [<=] dom G /\ fv_co_co_co         g  [<=] dom G /\

      fv_tm_tm_constraint p1 [<=] dom G /\ fv_co_co_constraint p1 [<=] dom G /\

      fv_tm_tm_constraint p2 [<=] dom G /\ fv_co_co_constraint p2 [<=] dom G)

  /\

  (forall G D g A B (H : AnnDefEq G D g A B),

      fv_tm_tm_co g [<=] dom G /\ fv_co_co_co g [<=] dom G /\

      fv_tm_tm_tm A [<=] dom G /\ fv_co_co_tm A [<=] dom G /\

      fv_tm_tm_tm B [<=] dom G /\ fv_co_co_tm B [<=] dom G)

  /\

  (forall G (H : AnnCtx G),

      (forall x A,

          binds x (Tm A)   G ->

          fv_tm_tm_tm         A   [<=] dom G /\ fv_co_co_tm         A   [<=] dom G) /\

      (forall c phi,

          binds c (Co phi) G ->

          fv_tm_tm_constraint phi [<=] dom G /\ fv_co_co_constraint phi [<=] dom G)).



Proof.

  eapply ann_typing_wff_iso_defeq_mutual.

  all: autounfold.

  

  all: intros; repeat match goal with |- _ ∧ _ => split end; split_hyp; simpl.

  all: eauto 1.

  

  all: try (intros x0 A0 BI).

  all: try solve [inversion BI].

  all: try (match goal with |- _ ∧ _ => split end).

  all: try solve

  [intros y h1; inversion BI; [inversion H5; subst; clear H5; eauto|

                               destruct (H x0 _ H5); eauto]].

  all: try solve

  [intros y h1; inversion BI; [inversion H5; subst; clear H5; eauto|

                              destruct (H4 x0 _ H5); eauto]].

  all: try solve

  [intros y h1; inversion BI; [inversion H3; subst; clear H3; eauto|

                              destruct (H x0 _ H3); eauto]].

  all: try solve

  [intros y h1; inversion BI; [inversion H3; subst; clear H3; eauto|

                               destruct (H2 x0 _ H3); eauto]].



  all: intros y IN.



  all: try match goal with

    [ H7 : ?y `in` union ?A ?B |- _ ] =>

    apply F.union_iff in H7; destruct H7; eauto end.



  all: try solve [ apply notin_empty_1 in IN; contradiction].

  all: try solve [ assert (x = y) by fsetdec; subst; eapply binds_In; eauto ].

  all: try solve [ destruct (H _ _ b); eauto ].



  all: try solve [apply H1; eauto; simpl; auto].

  all: try solve [apply H2; eauto; simpl; auto].

  all: try solve [apply H3; eauto; simpl; auto].

  all: try solve [apply H4; eauto; simpl; auto].



  all: try match goal with

    [ H5 : forall x : atom, (x `in` ?L -> False) -> ( _ /\ _ ) |- _ ] =>

    pick fresh x; destruct (H5 x); eauto; split_hyp

           end.



  all: try match goal with

    [ H4 : ?y `in` fv_tm_tm_tm ?B,

      H5 : ∀ a : atom,

       a `in` fv_tm_tm_tm (open_tm_wrt_tm ?B (a_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; auto;

    eapply fv_tm_tm_tm_open_tm_wrt_tm_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.

  all: try match goal with

    [ H4 : ?y `in` fv_co_co_tm ?B,

      H5 : ∀ a : atom,

       a `in` fv_co_co_tm (open_tm_wrt_tm ?B (a_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_co_co_tm_open_tm_wrt_tm_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.

  all: try match goal with

    [ H4 : ?y `in` fv_tm_tm_tm ?B,

      H5 : ∀ a : atom,

       a `in` fv_tm_tm_tm (open_tm_wrt_co ?B (g_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_tm_tm_tm_open_tm_wrt_co_lower; auto);

    simpl in h0; apply F.add_neq_iff in h0; auto

           end.

  all: try match goal with

    [ H4 : ?y `in` fv_co_co_tm ?B,

      H5 : ∀ a : atom,

       a `in` fv_co_co_tm (open_tm_wrt_co ?B (g_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_co_co_tm_open_tm_wrt_co_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.



  all: try (simpl in *; eapply fv_tm_tm_tm_open_tm_wrt_tm_upper in IN;

    apply F.union_iff in IN; destruct IN; eauto).

  all: try (simpl in *; eapply fv_co_co_tm_open_tm_wrt_tm_upper in IN;

    apply F.union_iff in IN; destruct IN; eauto).

  all: try (simpl in *; eapply fv_tm_tm_tm_open_tm_wrt_co_upper in IN;

    apply F.union_iff in IN; destruct IN; eauto).

  all: try (simpl in *; eapply fv_co_co_tm_open_tm_wrt_co_upper in IN;

    apply F.union_iff in IN; destruct IN; eauto).



  all: try (apply H0 in IN; apply notin_empty_1 in IN; contradiction).

  all: try (apply H1 in IN; apply notin_empty_1 in IN; contradiction).



  all: try match goal with

    [ H7 : ?y `in` union ?A ?B |- _ ] =>

    apply F.union_iff in H7; destruct H7; eauto end.



  all: try solve [apply H1; eauto; simpl; auto].

  all: try solve [apply H2; eauto; simpl; auto].

  all: try solve [apply H3; eauto; simpl; auto].

  all: try solve [apply H4; eauto; simpl; auto].

  all: try solve [apply H5; eauto; simpl; auto].



  all: try match goal with

    [IN : ?y `in` singleton ?c |- _ ] =>

                assert (c = y) by fsetdec; subst; eapply binds_In; eauto

     end.

  all: try solve [ destruct (H0 _ _ b0); simpl in *; eauto].



  all: try  match goal with

    [ H4 : ?y `in` fv_tm_tm_co ?B,

      H5 : ∀ a : atom,

       a `in` fv_tm_tm_co (open_co_wrt_tm ?B (a_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_tm_tm_co_open_co_wrt_tm_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.



  all: try match goal with

    [ H4 : ?y `in` fv_co_co_co ?B,

      H5 : ∀ a : atom,

       a `in` fv_co_co_co (open_co_wrt_tm ?B (a_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_co_co_co_open_co_wrt_tm_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.



  all: try match goal with

    [ H4 : ?y `in` fv_tm_tm_co ?B,

      H5 : ∀ a : atom,

       a `in` fv_tm_tm_co (open_co_wrt_co ?B (g_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_tm_tm_co_open_co_wrt_co_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.



  all: try match goal with

    [ H4 : ?y `in` fv_co_co_co ?B,

      H5 : ∀ a : atom,

       a `in` fv_co_co_co (open_co_wrt_co ?B (g_Var_f ?x))

            → a `in` dom ([(?x, ?s)] ++ ?G) |- _ ] =>

    assert (h0: y `in` dom ([(x,s)] ++ G)) by

    (eapply H5; eauto;

    eapply fv_co_co_co_open_co_wrt_co_lower; auto);

      simpl in h0; apply F.add_neq_iff in h0; auto

           end.



  all: try match goal with 

      [ IN : ?y `in` ?fv_tm_tm_tm ?a, 

        H : ∀ a : atom, a `in` ?fv_tm_tm_tm ?b → a `in` dom ?G,

        e : ∀ x : atom,

            (x `in` ?L → False) → 

            ?open_tm_wrt_tm ?a (a_Var_f x) = ?c

       |- _ ] => 

      eapply H; pick fresh x; move: (e x ltac:(auto)) => h0;

      assert (x <> y); [ fsetdec|];

      clear Fr;

      have h1: y `in` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x));

      [ move: (fv_tm_tm_tm_open_tm_wrt_tm_lower a (a_Var_f x)) => ?;

        move: (fv_co_co_tm_open_tm_wrt_tm_lower a (a_Var_f x)) => ?;

        fsetdec|

      rewrite h0 in h1; 

      simpl in h1;

      fsetdec ]

    end.



  all: try match goal with 

      [ IN : ?y `in` ?fv_tm_tm_tm ?a, 

        H : ∀ a : atom, a `in` ?fv_tm_tm_tm ?b → a `in` dom ?G,

        e : ∀ x : atom,

            (x `in` ?L → False) → 

            ?open_tm_wrt_tm ?a (g_Var_f x) = ?c

       |- _ ] => 

      eapply H; pick fresh x; move: (e x ltac:(auto)) => h0;

      assert (x <> y); [ fsetdec|];

      clear Fr;

      have h1: y `in` fv_tm_tm_tm (open_tm_wrt_tm a (g_Var_f x));

      [ move: (fv_tm_tm_tm_open_tm_wrt_co_lower a (g_Var_f x)) => ?;

        move: (fv_co_co_tm_open_tm_wrt_co_lower a (g_Var_f x)) => ?;

        fsetdec|];

      rewrite h0 in h1; 

      simpl in h1;

      fsetdec

    end.



  - assert (FR1 : x `notin` L) by auto. assert (FR2 : x <> y) by auto.

    clear Fr. clear H0. clear r. clear r0.

    clear H19. clear H20. clear H22. clear H24.

    clear H10 H12 H13 H7 H4 H9 H6.

    move: (e x FR1) => EX.

    match goal with

      [H18 :  y `in` fv_tm_tm_tm b3 |- _ ] =>

       erewrite fv_tm_tm_tm_open_tm_wrt_tm_lower  in H18;

       erewrite EX in H18;

       erewrite fv_tm_tm_tm_open_tm_wrt_tm_upper  in H18;

       apply F.union_iff in H18; destruct H18 as [h2 | h3]

       end.

    simpl in h2.

    apply F.union_iff in h2; destruct h2 as [h4 | h5].

    fsetdec.

    eauto.



    assert (y `in` dom ((x ~ Tm A1) ++ G)). eapply H23.

    eapply fv_tm_tm_tm_open_tm_wrt_tm_lower.  auto.

    simpl in H0; apply F.add_neq_iff in H0; auto.

  - assert (FR1 : x `notin` L) by auto. assert (FR2 : x <> y) by auto.

    clear Fr. clear H0. clear r. clear r0.

    move: (e x FR1) => EX.

    match goal with

      [H14 : y `in` fv_co_co_tm b3 |- _ ] =>

      erewrite fv_co_co_tm_open_tm_wrt_tm_lower  in H14;

        erewrite EX in H14;

        erewrite fv_co_co_tm_open_tm_wrt_tm_upper  in H14;

        apply F.union_iff in H14; destruct H14 as [h2 | h3]

    end.

    simpl in h2.

    apply F.union_iff in h2; destruct h2 as [h4 | h5].

    fsetdec.

    eauto.



    assert (y `in` dom ((x ~ Tm A1) ++ G)). eapply H24.

    eapply fv_co_co_tm_open_tm_wrt_tm_lower.  auto.

    simpl in H0; apply F.add_neq_iff in H0; auto.

Qed.



Definition AnnTyping_context_fv  := @first  _ _ _ _ _ ann_context_fv_mutual.

Definition AnnPropWff_context_fv := @second _ _ _ _ _ ann_context_fv_mutual.

Definition AnnIso_context_fv     := @third  _ _ _ _ _ ann_context_fv_mutual.

Definition AnnDefEq_context_fv   := @fourth _ _ _ _ _ ann_context_fv_mutual.

Definition AnnCtx_context_fv     := @fifth  _ _ _ _ _ ann_context_fv_mutual.

