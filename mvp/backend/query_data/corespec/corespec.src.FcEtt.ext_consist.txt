

Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)



Require Import Omega.



Require Export FcEtt.imports.

Require Import FcEtt.utils.
(* FcEtt.utils:
Require Import FcEtt.imports.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Definition first :=
  fun (A B C D  E: Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj H _ => H
    end.
Definition second :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj H _) => H
    end.
Definition third :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj H _)) => H
    end.
Definition fourth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj H _))) => H
    end.
Definition fifth :=
  fun (A B C D E : Prop) (p : A /\ B /\ C /\ D /\ E) =>
    match p with
      | conj _ (conj _ (conj _ (conj _ H))) => H
    end.

Lemma dom_subst_inv: forall (G: context) (f: sort -> sort), dom G = dom (map f G).

Lemma binds_map_3 :
   forall a b x s (f : a -> b) G, binds x s (map f G) ->
    exists s', f s' = s /\ binds x s' G.

Lemma binds_cases: forall G F x A y B,
    uniq (F ++ [(y, B)] ++ G) ->
    @binds sort x A (F ++ [(y, B)] ++ G) ->
    (binds x A F /\ x <> y /\ x `notin` dom G) \/ (x = y /\ A = B) \/ (binds x A G /\ x <> y /\ x `notin` dom F).

Lemma binds_concat: forall G F E x A, binds x (Tm A) (F ++ E ++ G) <-> binds x (Tm A) (F) \/ binds x (Tm A) (E) \/ binds x (Tm A) (G).

Lemma fun_cong : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b. *)

Require Export FcEtt.tactics.

Require Export FcEtt.ett_ott.

Require Export FcEtt.ett_inf.

Require Export FcEtt.ett_ind.

Require Export FcEtt.ett_par.

Require Export FcEtt.erase_syntax.

Require Import FcEtt.ext_red_one.
(* FcEtt.ext_red_one:
Require Import FcEtt.sigs.

Require Export FcEtt.imports.
Require Import FcEtt.utils.
Require Export FcEtt.tactics.

Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ett_par.
Require Export FcEtt.erase_syntax.

Module ext_red_one (invert : ext_invert_sig).
  Import invert.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma reduction_in_one_lc : forall a a', reduction_in_one a a' -> lc_tm a -> lc_tm a'.

Ltac subst_helper x x0 b0 :=
  replace (a_Var_f x) with (tm_subst_tm_tm b0 x0 (a_Var_f x));
  [idtac| rewrite tm_subst_tm_tm_var_neq; auto];
  replace (g_Var_f x) with (tm_subst_tm_co b0 x0 (g_Var_f x));
  [idtac| simpl; auto];
  try (rewrite <- tm_subst_tm_tm_open_tm_wrt_co; eauto);
  try (rewrite <- tm_subst_tm_tm_open_tm_wrt_co; eauto);
  try (rewrite <- tm_subst_tm_tm_open_tm_wrt_tm; eauto);
  try (rewrite <- tm_subst_tm_tm_open_tm_wrt_tm; eauto);
  eauto using tm_subst_tm_tm_lc_tm.

Ltac lc_subst_case x0 b0  :=
  let x:= fresh in
  lc_inversion x; subst;
  try (rewrite tm_subst_tm_tm_open_tm_wrt_tm; eauto);
  try (rewrite tm_subst_tm_tm_open_tm_wrt_co; eauto);

  econstructor; eauto using Value_lc,
                      tm_subst_tm_tm_lc_tm, tm_subst_tm_co_lc_co,
                tm_subst_tm_constraint_lc_constraint;
    apply_lc_exists x;
      eauto using tm_subst_tm_tm_lc_tm, tm_subst_tm_co_lc_co,
              Value_lc, tm_subst_tm_constraint_lc_constraint;
    subst_helper x x0 b0.

Lemma subst_reduction_in_one : forall a a',
  reduction_in_one a a' -> forall b x, lc_tm b ->
  reduction_in_one (tm_subst_tm_tm b x a)
                   (tm_subst_tm_tm b x a').

Lemma E_AbsTerm_exists : ∀ x (a a' : tm),
    x `notin` (fv_tm a \u fv_tm a') ->
     reduction_in_one (open_tm_wrt_tm a (a_Var_f x))
                       (open_tm_wrt_tm a' (a_Var_f x))
    → reduction_in_one (a_UAbs Irrel a) (a_UAbs Irrel a').

Lemma no_Value_reduction :
  (forall a, Value a -> forall b, not (reduction_in_one a b)).

Lemma reduction_in_one_deterministic :
  forall a a1, reduction_in_one a a1 -> forall a2, reduction_in_one a a2 -> a1 = a2.

End ext_red_one. *)

Require Import FcEtt.ext_red.
(* FcEtt.ext_red:
Require Import FcEtt.sigs.
Require Import FcEtt.imports.
Require Import FcEtt.ett_ott.

Require Import FcEtt.ett_inf.
Require Import FcEtt.ett_par.

Require Import FcEtt.ett_ind.

Require Import FcEtt.ext_wf.

Require Import FcEtt.ext_red_one.

Require Import FcEtt.tactics.

Module ext_red (invert : ext_invert_sig).

  Export invert.

Module red_one := ext_red_one invert.
Export red_one.

Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Lemma Beta_preservation : forall a b, Beta a b -> forall G A, Typing G a A -> Typing G b A.

Lemma E_Beta2 :  ∀ (G : context) (D : available_props) (a1 a2 B : tm),
       Typing G a1 B → Beta a1 a2 → DefEq G D a1 a2 B.

Lemma reduction_in_Par : forall a a', reduction_in_one a a' -> forall G D, Par G D a a'.

Lemma reduction_in_one_fv_preservation: forall x a b, reduction_in_one a b ->
                                        x `notin` fv_tm_tm_tm a ->
                                        x `notin` fv_tm_tm_tm b.

Lemma reduction_rhocheck : forall a a' rho x, reduction_in_one a a' -> RhoCheck rho x a -> RhoCheck rho x a'.

Lemma reduction_preservation : forall a a', reduction_in_one a a' -> forall G A, Typing G a A -> Typing G a' A.

Ltac par_with_context_tail :=
  match goal with
  | _ : _ |- Par ([?s] ++ ?G ) (dom ([?s] ++ ?G)) ?a ?b =>
    eapply context_Par_irrelevance with (G1 := G) (D1 := dom G); eauto
  end.

Ltac ind_hyp a k1 k2 :=
  match goal with
    [ H : ∀ a' : tm, Ctx ?G → Par ?G ?D a a' → Typing ?G a' ?A ∧ DefEq ?G empty a a' ?A,
        H1 : Par ?G ?D a ?a',
        H2 : Ctx ?G |- _ ] =>
    move: (@H a' H2 H1) => [k1 k2]

  end.

Ltac ind_hyp_open x B k1 k2 :=
  match goal with
    [ H : forall x, x `notin` ?L -> forall a', Ctx ([(x, ?s)] ++ ?G) -> Par ([(x, ?s)] ++ ?G) ?D (open_tm_wrt_tm B (a_Var_f x)) a' -> ?P,
        H1 : Ctx ?G,
        H10 :  forall x : atom, x `notin` ?L0 → Par ?G ?D0 (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm ?B' (a_Var_f x))
                          |- _ ] =>
    move: (H x ltac:(auto) (open_tm_wrt_tm B' (a_Var_f x)) ltac:(auto)
                (context_Par_irrelevance ([(x, s)] ++ G) (dom ([(x,s)] ++ G)) (H10 x ltac:(auto)))) => [k0 k1]
      end.

End  ext_red. *)



Require Import FcEtt.ext_wf.
(* FcEtt.ext_wf:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Import FcEtt.imports.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ind.
Require Import FcEtt.tactics.

Require Import FcEtt.utils.

Require Import FcEtt.sigs.
Require Import FcEtt.toplevel.

Lemma Path_lc : forall T a, Path T a -> lc_tm a.

Hint Resolve Path_lc : lc.

Lemma DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.
Hint Resolve DataTy_lc : lc.

Lemma CoercedValue_Value_lc_mutual: (forall A, CoercedValue A -> lc_tm A) /\
                                    (forall A, Value A -> lc_tm A).

Lemma Value_lc : forall A, Value A -> lc_tm A.
Lemma CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

Hint Resolve Value_lc CoercedValue_lc : lc.

Lemma ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Definition Typing_Ctx  := first  ctx_wff_mutual.
Definition PropWff_Ctx := second ctx_wff_mutual.
Definition Iso_Ctx     := third  ctx_wff_mutual.
Definition DefEq_Ctx   := fourth ctx_wff_mutual.

Hint Resolve Typing_Ctx PropWff_Ctx Iso_Ctx DefEq_Ctx.

Lemma Ctx_uniq : forall G, Ctx G -> uniq G.

Hint Resolve Ctx_uniq.

Lemma lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi, PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T, DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Definition Typing_lc  := first lc_mutual.
Definition PropWff_lc := second lc_mutual.
Definition Iso_lc     := third lc_mutual.
Definition DefEq_lc   := fourth lc_mutual.
Definition Ctx_lc     := fifth lc_mutual.

Lemma Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Lemma Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Lemma Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Lemma Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.
Lemma DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.

Lemma DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Lemma DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Hint Resolve Typing_lc1 Typing_lc2 Iso_lc1 Iso_lc2 DefEq_lc1 DefEq_lc2 DefEq_lc3 Ctx_lc : lc.

Lemma Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s. *)



Module ext_consist (invert : ext_invert_sig)(fc_wf: fc_wf_sig).

Import invert.

Import fc_wf.



Module red_one := ext_red_one invert.

Export red_one.



Module red := ext_red invert.

Export red.



Set Implicit Arguments.

Set Bullet Behavior "Strict Subproofs".



Definition Good (G : context) (D : available_props):=

  erased_context G /\

  forall c1 A B1 T1,

    binds c1 (Co (Eq A B1 T1)) G

    -> c1 `in` D

    -> exists C, Par G D A C /\ Par G D B1 C.



Lemma open2 :

  forall x b b' S D a a',

    x `notin` fv_tm_tm_tm a' \u fv_tm_tm_tm a ->

    erased_tm b ->

    erased_tm (open_tm_wrt_tm a (a_Var_f x)) ->

    Par S D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)) ->

    Par S D b b' ->

    Par S D (open_tm_wrt_tm a b) (open_tm_wrt_tm a' b').

Proof.

  intros x b b'. intros.

  rewrite (tm_subst_tm_tm_intro x); auto.

  rewrite [(_ _ b')] (tm_subst_tm_tm_intro x); auto.

  apply subst3; auto.

Qed.



Lemma a_Pi_head : forall S G b A rho B,

    Par S G (a_Pi rho A B) b -> exists A' B' L,

      b = a_Pi rho A' B' /\ Par S G A A' /\

      (forall x, x `notin` L -> Par S G (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x))).

Proof.

  intros. inversion H. subst. inversion H0.  exists A , B, empty. split; auto.

  subst.

  exists A', B', L.  split; auto.

Qed.



Lemma Par_Abs_inversion : forall G D a b rho,

    Par G D (a_UAbs rho a) b ->

    (exists a', b = (a_UAbs rho a') /\

          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->

               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))

    \/

    (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->

          open_tm_wrt_tm a (a_Var_f x) = a_App a' rho (a_Var_f x)) /\ rho = Rel)

    \/ (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->

          open_tm_wrt_tm a (a_Var_f x) = a_App a' rho a_Bullet) /\ rho = Irrel). 



Proof.

  intros G D a a' rho P.

  inversion P; subst.

  + left. exists a. inversion H; eauto.

  + left. exists a'0. split. auto.

    intros x Fr.

    pick fresh y.

    rewrite (tm_subst_tm_tm_intro y); eauto.

    rewrite (tm_subst_tm_tm_intro y a'0); eauto.

    apply subst2; eauto.

  + right. left. 

    exists b. split. auto.

    split; eauto.

    intros x Fr.

    pick fresh y.

    rewrite (tm_subst_tm_tm_intro y); eauto.

    rewrite H5; eauto.

    simpl.

    rewrite tm_subst_tm_tm_fresh_eq; auto.

    destruct eq_dec. auto.

    done. 

  + right. right.

    exists b. split. auto.

    split; eauto.

    intros x Fr.

    pick fresh y.

    rewrite (tm_subst_tm_tm_intro y); eauto.

    rewrite H5; eauto.

    simpl.

    rewrite tm_subst_tm_tm_fresh_eq; auto. 

Qed.



Lemma Par_Abs_inversion_Rel : forall G D a b,

    Par G D (a_UAbs Rel a) b ->

    (exists a', b = (a_UAbs Rel a') /\

          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->

               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))

    \/

    (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->

          open_tm_wrt_tm a (a_Var_f x) = a_App a' Rel (a_Var_f x))).

Proof.

  intros G D a b H. eapply Par_Abs_inversion in H. inversion H; eauto.

  inversion H0; eauto.

  - right. inversion H1. inversion H2. inversion H4. eauto.

  - inversion H1. inversion H2. inversion H4. inversion H6.

Qed. 



Lemma Par_Abs_inversion_Irrel : forall G D a b,

    Par G D (a_UAbs Irrel a) b ->

    (exists a', b = (a_UAbs Irrel a') /\

          forall x, x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm a' ->

               Par G D (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm a' (a_Var_f x)))

    \/ (exists a', Par G D a' b /\ (forall x, x `notin`  fv_tm_tm_tm a ->

          open_tm_wrt_tm a (a_Var_f x) = a_App a' Irrel a_Bullet)). 

Proof.

  intros G D a b H. eapply Par_Abs_inversion in H. inversion H; eauto.

  inversion H0; eauto.

  - right. inversion H1. inversion H2. inversion H4. inversion H6.

  - right. inversion H1. inversion H2. inversion H4. eauto.

Qed.



Lemma Par_CAbs_inversion : forall G D a b,

    Par G D (a_UCAbs a) b ->

    (exists a', b = (a_UCAbs a') /\

          forall c, c `notin` fv_co_co_tm a \u fv_co_co_tm a' ->

               Par G D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c)))

    \/ (exists a', Par G D a' b /\ (forall c, c `notin`  fv_co_co_tm a ->

          open_tm_wrt_co a (g_Var_f c) = a_CApp a' g_Triv)). 

Proof.

  intros G D a b H. inversion H; subst.

  - left. exists a. inversion H0; eauto.

  - left. exists a'. split. auto.

    intros c Fr. 

    pick fresh y.

    rewrite (co_subst_co_tm_intro y); eauto.

    rewrite (co_subst_co_tm_intro y a'); eauto.

    apply subst4; eauto.

  - right. exists b0. split; auto.

    intros c Fr. pick fresh y. 

    rewrite (co_subst_co_tm_intro y); eauto.

    rewrite H4; eauto. simpl. 

    rewrite co_subst_co_tm_fresh_eq; auto.

Qed.



Lemma copen2 :

  forall c (b: co) S D a a',

    lc_co b ->

    c `notin` fv_co_co_tm a' \u fv_co_co_tm a ->

    Par S D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c)) ->

    Par S D (open_tm_wrt_co a b) (open_tm_wrt_co a' b).

Proof.

  intros x b b'. intros.

  rewrite (co_subst_co_tm_intro x); auto.

  rewrite [(_ _ b)] (co_subst_co_tm_intro x); auto.

  apply subst4; auto.

Qed.



Ltac try_refl :=

  try match goal with

      | [ P2 : Par _ _ _ ?b |- _ ] =>

        exists b; assert (lc_tm b); try eapply Par_lc2; eauto; try split; eauto; fail

      end.



Ltac invert_equality :=

  match goal with

  | [ H : _ = _ |- _ ] =>

    inversion H

  end.



  Ltac try_refl_left :=

  try match goal with

      | [ P2 : Par _ _ ?b ?b |- exists cc:tm, Par ?S ?D ?b cc /\ Par ?S ?D ?a2 cc ] =>

        exists a2; assert (lc_tm a2); try eapply Par_lc2; eauto; try split; eauto; fail

      end.

  Ltac try_refl_right :=

  try match goal with

      | [ P2 : Par _ _ ?b ?b |- exists cc:tm, Par ?S ?D ?a2 cc /\ Par ?S ?D ?b cc ] =>

        exists a2; assert (lc_tm a2); try eapply Par_lc2; eauto; try split; eauto; fail

      end.



  Ltac invert_erased :=

    match goal with

    | [ H : erased_tm ?a |- _ ] => inversion H; subst; clear H

    end.



  Ltac invert_erased_tm b :=

        let h0 := fresh in

        match goal with

          [ h : Par ?G ?D ?a b, h1: erased_tm ?a |- _ ] =>

          assert (h0 : erased_tm b);

          [ eapply (Par_erased_tm h); eauto | inversion h0; subst]

        end.



      Ltac eta_expand x :=

        let h1 := fresh in

      match goal with

       | [ H18 : ∀ x : atom,

              x `notin` ?L0

              → open_tm_wrt_tm ?a (a_Var_f x) = a_App ?b0 ?rho (a_Var_f x)

              |- _ ] =>

        pick fresh x for (L0 \u  fv_tm_tm_tm a \u fv_tm_tm_tm b0);

        move: (H18 x ltac:(auto)) => h1; clear H18;

        rewrite (@tm_subst_tm_tm_intro x a); auto; rewrite h1;

        simpl; destruct (@eq_dec tmvar _ x x); try done;

        rewrite tm_subst_tm_tm_fresh_eq; auto

       | [ H18 : ∀ x : atom,

              x `notin` ?L0

              → open_tm_wrt_tm ?a (a_Var_f x) = a_App ?b0 ?rho a_Bullet

              |- _ ] =>

        pick fresh x for (L0 \u  fv_tm_tm_tm a \u fv_tm_tm_tm b0);

        move: (H18 x ltac:(auto)) => h1; clear H18;

        rewrite (@tm_subst_tm_tm_intro x a); auto; rewrite h1;

        simpl; destruct (@eq_dec tmvar _ x x); try done;

        rewrite tm_subst_tm_tm_fresh_eq; auto

       | [ H18 : ∀ x : atom,

              x `notin` ?L0

              → open_tm_wrt_co ?a (g_Var_f x) = a_CApp ?b0 g_Triv

              |- _ ] =>

        pick fresh x for (L0 \u  fv_co_co_tm a \u fv_co_co_tm b0);

        move: (H18 x ltac:(auto)) => h1; clear H18;

        rewrite (@co_subst_co_tm_intro x a); auto; rewrite h1;

        simpl; destruct (@eq_dec tmvar _ x x); try done;

        rewrite co_subst_co_tm_fresh_eq; auto

      end.



      Ltac eta_case a'0 Y2 :=

         let x:= fresh in

         pick fresh x;

         rewrite (tm_subst_tm_tm_intro x a'0); auto;

         rewrite Y2; auto; simpl;

         rewrite (tm_subst_tm_tm_fresh_eq); auto;

         destruct eq_dec; try done;

         eauto; clear x.



Ltac invert_lc :=

  match goal with

    | [ H : lc_tm ?a |- _ ] => inversion H; subst; clear H

  end.



  Ltac use_size_induction a ac Par1 Par2 :=

  match goal with

  | [   IH : forall y: nat, ?T,

        H2 : Good ?G ?D,

        H3 : erased_tm a,

        H : Par ?G ?D a ?b0,

        H4 : Par ?G ?D a ?b1 |- _ ] =>

      move: (@IH (size_tm a) ltac:(omega) a ltac:(auto) _ _ _ H2 H3 H _ H4) => [ ac [Par1 Par2]]

  end.



  Ltac use_size_induction_open a0 x ac Par1 Par2 :=

      let h0 := fresh in

      let h1 := fresh in

      let h2 := fresh in

      let EQ1 := fresh in

      let EQ2 := fresh in

      match goal with

        | [  H : ∀ x : atom,

              x `notin` ?L

              → Par ?S ?D (?open_tm_wrt_tm a0 (?a_Var_f x)) ?b,

             H4: ∀ x : atom,

                 x `notin` ?L0

                 → Par ?S ?D (?open_tm_wrt_tm a0 (?a_Var_f x)) ?c,

             H1 : ∀ x : atom, x `notin` ?L1 →

    erased_tm (?open_tm_wrt_tm a0 (?a_Var_f x)) |- _ ] =>

    move: (H x ltac:(auto)) => h0; clear H;

    move: (H4 x ltac:(auto)) => h1; clear H4;

                               move: (H1 x ltac:(auto)) => h2; clear H1;

    move: (size_tm_open_tm_wrt_tm_var a0 x) => EQ1;

    move: (size_tm_open_tm_wrt_co_var a0 x) => EQ2;



    use_size_induction (open_tm_wrt_tm a0 (a_Var_f x)) ac Par1 Par2;

    clear h0; clear h1; clear h2; clear EQ1; clear EQ2

    end.



Ltac par_erased_open x J Par4 :=

  let K := fresh in

  let KK := fresh in

  let h0 := fresh in

  match goal with

  | [H13 : ∀ x : atom, x `notin` ?L →

                       Par ?G ?D (open_tm_wrt_tm ?a (a_Var_f x)) ?b,

     H4 : ∀ x : atom, x `notin` ?L1 → erased_tm  (open_tm_wrt_tm ?a (a_Var_f x))

       |- _ ] =>

    have: x `notin` L; auto => h0;

    pose K:= H13 x h0; clearbody K; clear h0;

    have: x `notin` L1; auto => h0;

    pose KK := H4 x h0; clearbody KK;

    pose J := subst3 x Par4 KK K;

    clearbody J;

    repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in J; [auto;

    simpl in J;

    destruct eq_dec; try congruence;

    repeat rewrite tm_subst_tm_tm_fresh_eq in J; auto

    | try apply (Par_lc2 Par4); auto

    | apply (Par_lc1 Par4); auto]

  end.



      Ltac finish_open_co a'0 :=

        let K := fresh in

        let J := fresh in

        let h0 := fresh in

      match goal with

      | H12 : forall c, c `notin` ?L -> Par ?G ?D (open_tm_wrt_co a'0 (g_Var_f c)) (open_tm_wrt_co ?b (g_Var_f c)) |- _ =>

        pick_fresh c;

        have: c `notin` L; auto => h0;

        pose K := H12 c h0; clearbody K;

        pose J := subst4 c lc_g_Triv K;

        clearbody J;

        repeat rewrite co_subst_co_tm_open_tm_wrt_co in J; eauto;

        simpl in J;

        destruct eq_dec; try congruence;

        repeat rewrite co_subst_co_tm_fresh_eq in J; eauto with lc



      end.



Lemma open_tm_wrt_tm_bullet_var_eq: forall a x, 

    x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x)) ->

    open_tm_wrt_tm a (a_Bullet) = open_tm_wrt_tm a (a_Var_f x).

Proof.

  intros.  

  rewrite (tm_subst_tm_tm_intro x a a_Bullet); auto.

  rewrite tm_subst_tm_tm_fresh_eq. auto.

  auto.

  rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower.

  eauto.

Qed.



Lemma open_tm_wrt_tm_inj_irrel: forall(a2 a1 : tm) (x1 : atom),

x1 `notin` fv_tm_tm_tm (open_tm_wrt_tm a2 (a_Var_f x1)) 

-> x1 `notin` fv_tm_tm_tm (open_tm_wrt_tm a1 (a_Var_f x1))

  -> open_tm_wrt_tm a2 a_Bullet = open_tm_wrt_tm a1 (a_Var_f x1)

    -> a2 = a1.

Proof. 

  intros. erewrite open_tm_wrt_tm_bullet_var_eq in H1; eauto.

  eapply open_tm_wrt_tm_inj; eauto. rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto. 

  rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto. 

Qed.



Lemma open_tm_wrt_co_triv_var_eq: forall a c, 

    c `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c)) ->

    open_tm_wrt_co a g_Triv = open_tm_wrt_co a (g_Var_f c).

Proof.

  intros.  

  rewrite (co_subst_co_tm_intro c a g_Triv); auto.

  rewrite co_subst_co_tm_fresh_eq. auto.

  auto.

  rewrite fv_co_co_tm_open_tm_wrt_co_lower.

  eauto.

Qed.



Lemma open_tm_wrt_co_inj: forall(a2 a1 : tm) (c : atom),

c `notin` fv_co_co_tm (open_tm_wrt_co a2 (g_Var_f c)) 

-> c `notin` fv_co_co_tm (open_tm_wrt_co a1 (g_Var_f c))

  -> open_tm_wrt_co a2 g_Triv = open_tm_wrt_co a1 (g_Var_f c)

    -> a2 = a1.

Proof.

  intros. erewrite open_tm_wrt_co_triv_var_eq in H1; eauto.

  eapply open_tm_wrt_co_inj; eauto. rewrite fv_co_co_tm_open_tm_wrt_co_lower. eauto. 

  rewrite fv_co_co_tm_open_tm_wrt_co_lower. eauto.

Qed.



Lemma erased_fv_co: forall a x, erased_tm a -> x `notin` fv_co_co_tm a.

Proof. 

  intros. induction H. all: simpl. all: try fsetdec.

  - pick fresh y. move: (H0 y ltac:(auto)) =>  h1.

    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto.

  - pick fresh y. move: (H1 y ltac:(auto)) => h1.

    apply union_notin_iff. split; eauto.

    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto.

  - pick fresh y. move: (H3 y ltac:(auto)) => h1.

    apply union_notin_iff. split. clear Fr. fsetdec.

    rewrite fv_co_co_tm_open_tm_wrt_co_lower. eauto.

  - pick fresh y. move: (H0 y ltac:(auto)) =>  h1.

    rewrite fv_co_co_tm_open_tm_wrt_co_lower. eauto.

Qed.



Lemma confluence_size : forall n a, size_tm a <= n ->  forall S D a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

Proof.

  pose confluence_size_def n :=

      forall a, size_tm a <= n ->  forall S D a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

  intro n. fold (confluence_size_def n).  eapply (well_founded_induction_type lt_wf).

  clear n. intros n IH. unfold confluence_size_def in *. clear confluence_size_def.

  intros a SZ S D a1 Gs Ea P1 a2 P2.

  inversion P1; inversion P2; subst.

  all: try solve [invert_equality].

  

  all: try_refl_left.

  all: try_refl_right.

  all: try invert_syntactic_equality.

  all: simpl in SZ; destruct n; try solve [ inversion SZ ].

  all: invert_erased; inversion Gs.



  - 

    use_size_induction a0 ac Par1 Par2.

    use_size_induction b bc Par3 Par4.

    destruct (Par_Abs_inversion_Rel Par1) as [[a'' [EQ h0]] | [X1]]; subst;

    destruct (Par_Abs_inversion_Rel Par2) as [[a''' [EQ2 h1]]| [Y1]]; subst.

    -- inversion EQ2. subst.

       exists (open_tm_wrt_tm a''' bc).

       split. pick fresh x; eapply open2; eauto using Par_erased_tm.

       pick fresh x; eapply open2; eauto using Par_erased_tm.

    -- exists (open_tm_wrt_tm a'' bc).

       split. pick fresh x; eapply open2; eauto using Par_erased_tm.

       inversion H7.

       eta_expand x.

    -- exists (open_tm_wrt_tm a''' bc).

       split. inversion H7. eta_expand x. 

       pick fresh x; eapply open2; eauto using Par_erased_tm.

    -- exists (a_App ac Rel bc).

       split. inversion H7. eta_expand x0.

       inversion H8. eta_expand x0.

  - 

    use_size_induction a0 ac Par1 Par2.

    use_size_induction b bc Par3 Par4.

    invert_erased_tm (a_UAbs Rel a').

    inversion Par1; subst; clear Par1.

    -- exists (open_tm_wrt_tm a' bc); auto.

      split; eauto.

      apply open1 with (L:=L); eauto.

    -- exists (open_tm_wrt_tm a'1 bc); auto.

      split; eauto.

      pick_fresh x.

      par_erased_open x J Par3.

    -- exists (a_App ac Rel bc).

      split.

      eta_expand x. 

      eauto.

  - 

    use_size_induction a0 ac Par1 Par2.

    invert_erased_tm (a_UAbs Irrel a');

    invert_erased_tm (a_UAbs Irrel a'0).

    destruct (Par_Abs_inversion_Irrel Par1) as [ [a'' [EQ X]] | W ];

    destruct (Par_Abs_inversion_Irrel Par2) as [ [a''' [EQ' X']] | W'].

    * subst.

      exists (open_tm_wrt_tm a''' a_Bullet).

      split; eauto. 

      pick fresh x; eapply open2; eauto. inversion EQ'; subst.

      apply X. fsetdec. 

      pick fresh x; eapply open2; eauto.

    * subst. 

      exists (open_tm_wrt_tm a'' a_Bullet). 

      split. pick fresh x; eapply open2; eauto.

      destruct W' as [ax [Par5 K]].

      eta_expand x.

    * exists (open_tm_wrt_tm a''' a_Bullet). split. 

      destruct W as [ax [Par5 K]]. 

      inversion EQ'; subst. eta_expand x. 

      pick fresh x; eapply open2; eauto.

    * exists (a_App ac Irrel a_Bullet). split.

      destruct W as [ax [Par5 K]].

      eta_expand x. destruct W' as [z [Par5 K]].

      eta_expand x.

  

   - use_size_induction a0 ac Par1 Par2.

    invert_erased_tm (a_UAbs Irrel a').

    inversion Par1; subst; clear Par1.

    -- exists (open_tm_wrt_tm a' a_Bullet); auto.

      split; eauto.

      apply open1 with (L:=L); eauto.

    -- exists (open_tm_wrt_tm a'1 a_Bullet); auto.

      split; eauto.

      pick_fresh x; eapply open2; eauto.

    -- exists (a_App ac Irrel a_Bullet).

      split. eta_expand x. 

      eauto.

   

  - use_size_induction a0 ac Par1 Par2.

    use_size_induction b bc Par3 Par4.

    invert_erased_tm (a_UAbs Rel a'0).

    inversion Par2; subst; clear Par2.

    -- exists (open_tm_wrt_tm a'0 bc); auto.

      split; eauto.

      apply open1 with (L:=L); eauto.

    -- exists (open_tm_wrt_tm a'1 bc); auto.

      split; eauto.

      pick_fresh x.

      par_erased_open x J Par4.

    -- exists (a_App ac Rel bc).

      split. eauto.

      eta_expand x.

  - 

    use_size_induction a0 ac Par1 Par2.

    use_size_induction b bc Par3 Par4.

    exists (a_App ac Rel bc).

    split. eauto. eauto.

  - 

    use_size_induction a0 ac Par1 Par2.

    invert_erased_tm (a_UAbs Irrel a'0).

    inversion Par2; subst; clear Par2.

    -- exists (open_tm_wrt_tm a'0 a_Bullet); auto.

      split; eauto.

      apply open1 with (L:=L); eauto.

    -- exists (open_tm_wrt_tm a'1 a_Bullet); auto.

      split; eauto. pick_fresh x; eapply open2; eauto.

    -- exists (a_App ac Irrel a_Bullet).

      split. eauto.

      eta_expand x.

  - 

    use_size_induction a0 ac Par1 Par2.

    exists (a_App ac Irrel a_Bullet).

    split. eauto. eauto.

  - 

    use_size_induction a0 ac Par1 Par2.

    invert_erased_tm (a_UCAbs a').

    invert_erased_tm (a_UCAbs a'0).

    destruct (Par_CAbs_inversion Par1) as [ [a'' [EQ X]] | W ];

    destruct (Par_CAbs_inversion Par2) as [ [a''' [EQ' X']] | W']. 

    -- subst.

      exists (open_tm_wrt_co a''' g_Triv).

      split; eauto. pick fresh x; eapply copen2; eauto.

      inversion EQ'; subst.

      apply X. fsetdec.

      pick fresh x; eapply copen2; eauto.

    -- subst. 

      exists (open_tm_wrt_co a'' g_Triv). 

      split. pick fresh x; eapply copen2; eauto.

      destruct W' as [ax [Par5 K]].

      eta_expand c.

    -- exists (open_tm_wrt_co a''' g_Triv). split. 

      destruct W as [ax [Par5 K]]. 

      inversion EQ'; subst. eta_expand c. 

      pick fresh x; eapply copen2; eauto.

    -- exists (a_CApp ac g_Triv). split.

      destruct W as [ax [Par5 K]].

      eta_expand c. destruct W' as [z [Par5 K]].

      eta_expand c.

  - 

    use_size_induction a0 ac Par1 Par2.

    destruct (Par_CAbs_inversion Par1) as [ [a'' [EQ X]] | W ].

    inversion P2; subst; clear P2.

    + exists (open_tm_wrt_co a'' g_Triv).

      split; eauto. pick fresh x; eapply copen2; eauto.

    + exists (open_tm_wrt_co a'' g_Triv).

      split; eauto. pick fresh x; eapply copen2; eauto.

      rewrite H7. eauto.

    + exists (open_tm_wrt_co a'' g_Triv).

      split; eauto. pick fresh x; eapply copen2; eauto.

    + exists (a_CApp ac g_Triv). split; eauto.

      destruct W as [ax [Par5 K]]. eta_expand c.

  - 

    use_size_induction a0 ac Par1 Par2.

    destruct (Par_CAbs_inversion Par2) as [ [a'' [EQ X]] | W ].

    inversion P2; subst; eauto; clear P2.

    + exists (open_tm_wrt_co a'' g_Triv).

      split; eauto. rewrite H3. pick fresh x; eapply copen2; eauto.

    + exists (open_tm_wrt_co a'' g_Triv).

      split; eauto. rewrite H7. pick fresh x; eapply copen2; eauto.

    + exists (open_tm_wrt_co a'' g_Triv).

      split; eauto. rewrite H7. pick fresh x; eapply copen2; eauto.

    + exists (a_CApp ac g_Triv). split; eauto.

      destruct W as [ax [Par5 K]]. eta_expand c.

  - 

    use_size_induction a0 ac Par1 Par2.

    exists (a_CApp ac g_Triv). auto.

  - 

    pick fresh x.

    use_size_induction_open a0 x ac Par1 Par2.

    exists (a_UAbs rho (close_tm_wrt_tm x ac)).

    split; eauto; try solve [apply (@Par_Abs_exists x); eauto].

  - 

    pick fresh x.

    move: (H x ltac:(auto)) => h1. clear H. rewrite H5 in h1.

    

    inversion h1.

    + subst. 

      exists a2. split.

            pick fresh y and apply Par_Eta; eauto.

      apply eta_swap with (x:=x); eauto.

      eauto using Par_lc2.

    + subst. 

      inversion H11. subst.

      apply open_tm_wrt_tm_inj in H9; auto. subst. 

      move: (H5 x ltac:(auto)) => h2.

      match goal with

        [ H : ?a = ?b |- _ ] =>

        assert (h3 : size_tm a = size_tm b) end.

      rewrite h2; auto.

      simpl in h3.

      rewrite size_tm_open_tm_wrt_tm_var in h3.

      assert (size_tm b <= size_tm a0). omega.

      move: (H2 x ltac:(auto)) => h4. rewrite h2 in h4. inversion h4.

      use_size_induction b bb Par1 Par2.

      exists bb. eauto.

      eapply Par_fv_preservation in H10. simpl in H10. eauto. eauto.

    + subst. 

      rewrite -H9 in h1.

      inversion H11. subst. clear H11.

      move: (H5 x ltac:(auto)) =>  h2.

      move: (H2 x ltac:(auto)) => h3.

      rewrite h2 in h3. inversion h3. subst.

      match goal with

        [ H : ?a = a_App ?b ?rho ?x |- _ ] =>

        assert (h4 : size_tm a = size_tm (a_App b rho x)) end.

      rewrite h2; auto.

      simpl in h4.

      rewrite size_tm_open_tm_wrt_tm_var in h4.

      assert (size_tm b <= size_tm a0). omega.

      use_size_induction b bb Par1 Par2.

      move: (@Par_fv_preservation _ _ x _ _ H10 ltac:(eauto)) => h5.

      exists bb.

      split.

      pick fresh y and apply Par_Eta. eapply Par2.

      eapply eta_swap with (x:=x); eauto.

      eauto.

    + eauto.

  - 

    pick fresh x. move: (H3 x ltac:(auto)) => h5. inversion h5; subst.

    move: (H x ltac:(auto)) => h1. rewrite H5 in h1.

    

    inversion h1.

    + subst. 

      exists a2. split.

            pick fresh y and apply Par_EtaIrrel; eauto.

      apply eta_swap_irrel with (x:=x); eauto.

      eauto using Par_lc2.

    + subst.

      move: (H2 x ltac:(auto)) => k1.

      rewrite H5 in k1.

      inversion k1.

      assert (erased_tm (a_UAbs Irrel a'0)). eapply Par_erased_tm. eauto. auto.

      eapply erased_a_Abs_inversion in H9.

      inversion H9; clear H9.

      assert (x `notin` fv_tm_tm_tm (open_tm_wrt_tm a'0 (a_Var_f x))).

      inversion H13; eauto.

      apply open_tm_wrt_tm_inj_irrel in H10; subst.

      move: (H5 x ltac:(auto)) => h2.

      match goal with

        [ H : ?a = ?b |- _ ] =>

        assert (h3 : size_tm a = size_tm b) end.

      rewrite h2; auto.

      simpl in h3.

      rewrite size_tm_open_tm_wrt_tm_var in h3.

      assert (size_tm b <= size_tm a0). omega.

      move: (H2 x ltac:(auto)) => h4. rewrite h2 in h4. inversion h4.

      use_size_induction b bb Par1 Par2.

      exists bb. split; eauto. auto.

      move: (@Par_fv_preservation _ _ x _ _ h1 ltac:(eauto)) => h6. eauto.

      move: (@Par_fv_preservation _ _ _ _ _ H11 ltac:(eauto)) => h7. eauto.

       apply union_notin_iff in Fr. fsetdec.

    + subst. 

      rewrite -H10 in h1.

      move: (H5 x ltac:(auto)) =>  h2.

      move: (H2 x ltac:(auto)) => h3.

      rewrite h2 in h3. inversion h3. subst.

      match goal with

        [ H : ?a = a_App ?b ?rho ?x |- _ ] =>

        assert (h4 : size_tm a = size_tm (a_App b rho x)) end.

      rewrite h2; auto.

      simpl in h4.

      rewrite size_tm_open_tm_wrt_tm_var in h4.

      assert (size_tm b <= size_tm a0). omega.

      use_size_induction b bb Par1 Par2.

      move: (@Par_fv_preservation _ _ x _ _ h1 ltac:(eauto)) => h6.

      exists bb.

      split. 

      pick fresh y and apply Par_EtaIrrel. eapply Par2.

      eapply eta_swap_irrel with (x:=x); eauto.

      eapply Par_erased_tm in h1; eauto. simpl in h6.

       apply union_notin_iff in Fr.

      inversion Fr. clear Fr.  clear Fr0. fsetdec.

      eauto.

    + eauto.

  - 

    pick fresh x.

    use_size_induction A ac Par1 Par2.

    use_size_induction_open B x bc Par3 Par4.

    exists (a_Pi rho ac (close_tm_wrt_tm x bc)).

    split; eauto; try solve [apply (@Par_Pi_exists x); eauto].

  - 

    pick fresh c.

    use_size_induction_open a0 c ac Par1 Par2.

    exists (a_UCAbs (close_tm_wrt_co c ac)).

    split; eauto; try solve [apply (@Par_CAbs_exists c); eauto].

  - 

    pick fresh x.

    move: (H x ltac:(auto)) => h1. clear H. rewrite H5 in h1.

    

    inversion h1.

    + subst. 

      exists a2. split.

            pick fresh y and apply Par_EtaC; eauto.

      apply eta_swap_c with (x:=x); eauto.

      eauto using Par_lc2.

    + subst.

      move: (H5 x ltac:(auto)) => h2.

      match goal with

        [ H : ?a = ?b |- _ ] =>

        assert (h3 : size_tm a = size_tm b) end.

      rewrite h2; auto.

      simpl in h3.

      rewrite size_tm_open_tm_wrt_co_var in h3.

      assert (size_tm b <= size_tm a0). omega.

      move: (H1 x ltac:(auto)) => h4. rewrite h2 in h4. inversion h4.

      use_size_induction b bb Par1 Par2.

      exists bb. 

      split; eauto.

      eapply open_tm_wrt_co_inj in H7. subst; auto.

      Focus 2. move: (@Par_fv_co_preservation _ _ x _ _ h1 ltac:(eauto)) => h5. eauto.

      apply erased_fv_co. eapply erased_a_CAbs_inversion.

      move: (@Par_erased_tm _ _ _ _ H8 ltac:(eauto)) => h6; eauto.

      move: (@Par_fv_co_preservation _ _ x _ _ H8 ltac:(eauto)) => h5. 

      simpl in h5; eauto.

    + subst. 

      rewrite -H7 in h1.

      

      move: (H5 x ltac:(auto)) =>  h2.

      move: (H1 x ltac:(auto)) => h3.

      rewrite h2 in h3. inversion h3. subst.

      match goal with

        [ H : ?a = a_CApp ?b ?x |- _ ] =>

        assert (h4 : size_tm a = size_tm (a_CApp b x)) end.

      rewrite h2; auto.

      simpl in h4.

      rewrite size_tm_open_tm_wrt_co_var in h4.

      assert (size_tm b <= size_tm a0). omega.

      use_size_induction b bb Par1 Par2.

      move: (@Par_fv_preservation _ _ x _ _ H8 ltac:(eauto)) => h5.

      exists bb.

      split; eauto.

      pick fresh y and apply Par_EtaC; eauto.

      eapply eta_swap_c with (x:=x); eauto. clear Fr0.

      move: (@Par_fv_co_preservation _ _ x _ _ h1 ltac:(eauto)) => h6.

      simpl in h6. rewrite union_notin_iff. split. 

      apply union_notin_iff in Fr. inversion Fr. clear Fr. fsetdec.

      clear Fr. fsetdec.

    + eauto.

  - 

    use_size_induction A AC Par1 Par2.

    use_size_induction B BC Par3 Par4.

    use_size_induction A1 AC1 Par5 Par6.

    pick fresh c.

    use_size_induction_open a0 c ac Par7 Par8.

    exists (a_CPi (Eq AC BC AC1) (close_tm_wrt_co c ac)).

    split; eauto; try solve [apply (@Par_CPi_exists c); eauto].

  - 

    have E: (Ax a1 A = Ax a2 A0). eapply binds_unique; eauto using uniq_toplevel.

    inversion E. subst. clear E.

    have LC: lc_tm a2. apply Toplevel_lc in H. inversion H. auto.

    exists a2. split; eauto.

  - 

    pick fresh x.

    match goal with

      [ H5 : ∀ x : atom,

            x `notin` ?L0

            → Par ?S ?D (open_tm_wrt_tm ?a0 (a_Var_f x))

                  (open_tm_wrt_tm ?a' (a_Var_f x)),

        H :  ∀ x : atom,

            x `notin` ?L → open_tm_wrt_tm ?a0 (a_Var_f x) = a_App ?b ?rho (a_Var_f x)

            |- _ ] =>

      move: (H x ltac:(auto)) => h0;

      move: (H5 x ltac:(auto)) => h1; clear H5; rewrite h0 in h1

    end.

  

    inversion h1; subst.

    + exists a1. split. eauto using Par_lc2.

       pick fresh y and apply Par_Eta; eauto.

       apply eta_swap with (x:=x); eauto.

    + 

      match goal with

        [  H8 : Par ?S ?D ?b (a_UAbs ?rho ?a'0),

          H11 : Par ?S ?D (a_Var_f x) ?b',

          H10 : open_tm_wrt_tm a'0 ?b' = open_tm_wrt_tm ?a' (a_Var_f x)

          |- _ ] =>

        inversion H11; subst;

          move: (@Par_fv_preservation S D x _ _ H8 ltac:(auto)) => h2; simpl in h2; eauto;

          apply open_tm_wrt_tm_inj in H10; auto; subst; clear H11

      end.

      match goal with

        [ H : ?a = ?b |- _ ] =>

        assert (h3 : size_tm a = size_tm b) end.

      rewrite h0; auto.

      simpl in h3.

      rewrite size_tm_open_tm_wrt_tm_var in h3.

      assert (size_tm b <= size_tm a0). omega.

      let h4 := fresh in

      match goal with

        [ H2 :  ∀ x : atom, x `notin` ?L1 → erased_tm (open_tm_wrt_tm ?a0 (a_Var_f x)) |- _ ] =>

        move: (H2 x ltac:(auto)) => h4; rewrite h0 in h4; inversion h4; subst

      end.

      use_size_induction b bb Par1 Par2.

      exists bb. eauto.

    + subst. 

      rewrite -H9 in h1.

      inversion H11. subst. clear H11.

      move: (H0 x ltac:(auto)) =>  h2.

      move: (H3 x ltac:(auto)) => h3.

      rewrite h2 in h3. inversion h3. subst.

      match goal with

        [ H : ?a = a_App ?b ?rho ?x |- _ ] =>

        assert (h4 : size_tm a = size_tm (a_App b rho x)) end.

      rewrite h2; auto.

      simpl in h4.

      rewrite size_tm_open_tm_wrt_tm_var in h4.

      assert (size_tm b <= size_tm a0). omega.

      use_size_induction b bb Par1 Par2.

      move: (@Par_fv_preservation _ _ x _ _ H10 ltac:(eauto)) => h5.

      exists bb.

      split.

      eauto.

      pick fresh y and apply Par_Eta. eapply Par2.

      eapply eta_swap with (x:=x); eauto.

  - 

    pick fresh x for (L \u L0 \u L1).

    move: (H0 x ltac:(auto)) => E1.

    move: (H6 x ltac:(auto)) => E2.

    move: (H3 x ltac:(auto)) => Eb.

    rewrite E2 in E1.

    inversion E1. subst.

    rewrite E2 in Eb. inversion Eb. subst.

    move: (size_tm_open_tm_wrt_tm_var a0 x) => Sb.

    match goal with

      [ H : open_tm_wrt_tm ?a ?x = ?b |- _ ] =>

      assert (K : size_tm (open_tm_wrt_tm a x) = size_tm b);

        [rewrite H; auto| simpl in K]

    end.

    use_size_induction b ac Par1 Par2.

    exists ac. auto.

  - 

    pick fresh x.

    match goal with

      [ H5 : ∀ x : atom,

            x `notin` ?L0

            → Par ?S ?D (open_tm_wrt_tm ?a0 (a_Var_f x))

                  (open_tm_wrt_tm ?a' (a_Var_f x)),

        H :  ∀ x : atom,

            x `notin` ?L → open_tm_wrt_tm ?a0 (a_Var_f x) = a_App ?b ?rho a_Bullet

            |- _ ] =>

      move: (H x ltac:(auto)) => h0;

      move: (H5 x ltac:(auto)) => h1; clear H5; rewrite h0 in h1

    end.

  

    inversion h1; subst.

    + exists a1. split. eauto using Par_lc2.

       pick fresh y and apply Par_EtaIrrel; eauto.

       apply eta_swap_irrel with (x:=x); eauto.

    + 

      assert (h3: size_tm (open_tm_wrt_tm a0 (a_Var_f x)) 

              = size_tm (a_App b Irrel a_Bullet)). rewrite h0; auto.

      rewrite size_tm_open_tm_wrt_tm_var in h3.

      simpl in h3.

      assert (size_tm b <= size_tm a0). omega.

      let h4 := fresh in

      match goal with

        [ H2 :  ∀ x : atom, x `notin` ?L1 → erased_tm (open_tm_wrt_tm ?a0 (a_Var_f x)) |- _ ] =>

        move: (H2 x ltac:(auto)) => h4; rewrite h0 in h4; inversion h4; subst

      end.

      use_size_induction b bb Par1 Par2.

      exists bb. split; eauto.

      apply open_tm_wrt_tm_inj_irrel in H8; subst; eauto.

      Focus 2. move: (@Par_fv_preservation _ _ x _ _ h1 ltac:(eauto)) => h5.

      auto.

      assert (erased_tm (a_UAbs Irrel a'0)). eapply Par_erased_tm. eauto. auto.

      eapply erased_a_Abs_inversion in H7.

      inversion H7; clear H7.

      assert (x `notin` fv_tm_tm_tm (open_tm_wrt_tm a'0 (a_Var_f x))).

      inversion H12; eauto. auto.

      move: (@Par_fv_preservation _ _ x _ _ H9 ltac:(eauto)) => h6.

      simpl in h6. auto.

    + subst. 

      rewrite -H8 in h1.

      move: (H0 x ltac:(auto)) =>  h2.

      move: (H3 x ltac:(auto)) => h3.

      rewrite h2 in h3. inversion h3. subst.

      match goal with

        [ H : ?a = a_App ?b ?rho ?x |- _ ] =>

        assert (h4 : size_tm a = size_tm (a_App b rho x)) end.

      rewrite h2; auto.

      simpl in h4.

      rewrite size_tm_open_tm_wrt_tm_var in h4.

      assert (size_tm b <= size_tm a0). omega.

      use_size_induction b bb Par1 Par2.

      exists bb.

      split.

      eauto.

      pick fresh y and apply Par_EtaIrrel. eapply Par2.

      eapply eta_swap_irrel with (x:=x); eauto.

      move: (@Par_fv_preservation _ _ x _ _ h1 ltac:(eauto)) => h5.

      simpl in h5. clear Fr0. apply union_notin_iff in Fr. 

      inversion Fr. rewrite union_notin_iff. split; auto.

  -  

    pick fresh x for (L \u L0 \u L1).

    move: (H0 x ltac:(auto)) => E1.

    move: (H6 x ltac:(auto)) => E2.

    move: (H3 x ltac:(auto)) => Eb.

    rewrite E2 in E1.

    inversion E1. subst.

    rewrite E2 in Eb. inversion Eb. subst.

    move: (size_tm_open_tm_wrt_tm_var a0 x) => Sb.

    match goal with

      [ H : open_tm_wrt_tm ?a ?x = ?b |- _ ] =>

      assert (K : size_tm (open_tm_wrt_tm a x) = size_tm b);

        [rewrite H; auto| simpl in K]

    end.

    use_size_induction b ac Par1 Par2.

    exists ac. auto.

  - 

    pick fresh x.

    match goal with

      [ H5 : ∀ c : atom,

            c `notin` ?L0

            → Par ?S ?D (open_tm_wrt_co ?a0 (g_Var_f c))

                  (open_tm_wrt_co ?a' (g_Var_f c)),

        H :  ∀ c : atom,

            c `notin` ?L → open_tm_wrt_co ?a0 (g_Var_f c) = a_CApp ?b g_Triv

            |- _ ] =>

      move: (H x ltac:(auto)) => h0;

      move: (H5 x ltac:(auto)) => h1; clear H5; rewrite h0 in h1

    end.

  

    inversion h1; subst.

    + exists a1. split. eauto using Par_lc2.

       pick fresh y and apply Par_EtaC; eauto.

       apply eta_swap_c with (x:=x); eauto.

    + 

      subst.

      move: (H2 x ltac:(auto)) => h2.

      assert (h3 : size_tm (open_tm_wrt_co a0 (g_Var_f x)) = size_tm (a_CApp b g_Triv)).

      rewrite h0; auto.

      simpl in h3.

      rewrite size_tm_open_tm_wrt_co_var in h3.

      assert (size_tm b <= size_tm a0). omega.

      move: (H0 x ltac:(auto)) => h4. rewrite h4 in h2. inversion h2.

      use_size_induction b bb Par1 Par2.

      exists bb. 

      split; eauto.

      eapply open_tm_wrt_co_inj in H7. subst; auto.

      Focus 2. move: (@Par_fv_co_preservation _ _ x _ _ h1 ltac:(eauto)) => h5. eauto.

      apply erased_fv_co. eapply erased_a_CAbs_inversion.

      move: (@Par_erased_tm _ _ _ _ H8 ltac:(eauto)) => h6; eauto.

      move: (@Par_fv_co_preservation _ _ x _ _ H8 ltac:(eauto)) => h5. 

      simpl in h5; eauto.

    + subst. 

      rewrite -H7 in h1.

      

      move: (H2 x ltac:(auto)) =>  h2.

      move: (H0 x ltac:(auto)) => h3.

      rewrite h3 in h2. inversion h2. subst.

      match goal with

        [ H : ?a = a_CApp ?b ?x |- _ ] =>

        assert (h4 : size_tm a = size_tm (a_CApp b x)) end.

      rewrite h3; auto.

      simpl in h4.

      rewrite size_tm_open_tm_wrt_co_var in h4.

      assert (size_tm b <= size_tm a0). omega.

      use_size_induction b bb Par1 Par2.

      exists bb.

      split; eauto.

      pick fresh y and apply Par_EtaC; eauto.

      eapply eta_swap_c with (x:=x); eauto. clear Fr0.

      move: (@Par_fv_co_preservation _ _ x _ _ h1 ltac:(eauto)) => h6.

      simpl in h6. rewrite union_notin_iff. split. 

      apply union_notin_iff in Fr. inversion Fr. clear Fr. fsetdec.

      clear Fr. fsetdec.

  - 

    pick fresh x for (L \u L0 \u L1).

    move: (H0 x ltac:(auto)) => E1.

    move: (H6 x ltac:(auto)) => E2.

    move: (H2 x ltac:(auto)) => Eb.

    rewrite E2 in E1.

    inversion E1. subst.

    rewrite E2 in Eb. inversion Eb. subst.

    move: (size_tm_open_tm_wrt_co_var a0 x) => Sb.

    match goal with

      [ H : open_tm_wrt_co ?a ?x = ?b |- _ ] =>

      assert (K : size_tm (open_tm_wrt_co a x) = size_tm b);

        [rewrite H; auto| simpl in K]

    end. 

    use_size_induction b ac Par1 Par2.

    exists ac. auto.

Qed.



Lemma confluence : forall S D a a1, Good S D -> erased_tm a -> Par S D a a1 -> forall a2, Par S D a a2 -> exists b, Par S D a1 b /\ Par S D a2 b.

Proof.

  intros.

  eapply confluence_size; eauto.

Qed.



Lemma multipar_Star : forall S D A B, multipar S D A B -> A = a_Star -> B = a_Star.

Proof.

  intros S D A B H. induction H. auto.

  inversion H; intro K; auto; try inversion K.

Qed.



Lemma multipar_Bullet : forall S D B, multipar S D a_Bullet B -> B = a_Bullet.

Proof.

  intros S D B H. dependent induction H. auto.

  inversion H; auto; try inversion K.

Qed.



Inductive Path_consistent : const -> tm -> tm -> Prop :=

  PC_Const : forall T, Path_consistent T (a_Const T) (a_Const T)

| PC_App   : forall T a1 a2 b1 b2,

    erased_tm a2 -> erased_tm b2 ->

    Path_consistent T a1 b1 ->

    Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2)

| PC_AppIrrel : forall T a1 b1,

    Path_consistent T a1 b1 ->

    Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet)

| PC_CApp  : forall T a1 b1,

    Path_consistent T a1 b1 ->

    Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv).

Hint Constructors Path_consistent.



Lemma Path_consistent_Path1 : forall T a b, Path_consistent T a b -> Path T a.

Proof. induction 1; eauto using erased_lc. Qed.

Lemma Path_consistent_Path2 : forall T a b, Path_consistent T a b -> Path T b.

Proof. induction 1; eauto using erased_lc. Qed.



Lemma Path_consistent_erased1 : forall T a b, Path_consistent T a b -> erased_tm a.

Proof. induction 1; eauto. Qed.

Lemma Path_consistent_erased2 : forall T a b, Path_consistent T a b -> erased_tm b.

Proof. induction 1; auto. Qed.

Hint Resolve Path_consistent_erased1 Path_consistent_erased2 : erased.



Lemma Path_consistent_Refl :

  forall a T, Path T a -> erased_tm a -> Path_consistent T a a.

Proof. induction 1; intro h; inversion h; auto. Qed.



Lemma Path_consistent_Trans_aux :

  forall b T,  Path T b -> forall a c, Path_consistent T a b -> Path_consistent T b c -> Path_consistent T a c.

Proof. induction 1.

       all: intros a0 c0 h1 h2.

       all: inversion h1; inversion h2; subst; auto.

    - inversion h1; inversion h2; subst; auto.

    - inversion h1; inversion h2; subst; auto.

Qed.



Lemma Path_consistent_Trans : forall T a b c,

  Path_consistent T a b -> Path_consistent T b c -> Path_consistent T a c.

Proof. intros. eapply Path_consistent_Trans_aux with (b:=b). eapply Path_consistent_Path2; auto.

       eauto. eauto. eauto.

Qed.



Lemma Path_consistent_Sym :

  forall T a b, Path_consistent T a b -> Path_consistent T b a.

Proof.

  induction 1; eauto.

Qed.



Lemma Par_Path_consistent :

  forall S D a b T, Par S D a b -> Path T a -> erased_tm a -> Path_consistent T a b.

Proof.

  induction 1; intros P E; inversion E; inversion P; subst; eauto with lc;

    eauto using Path_consistent_Refl with erased.

  - move: (IHPar1 H10 H3) => h0.

    inversion h0.

  - move: (IHPar H7 H1) => h0.

    inversion h0.

  - move: (IHPar H6 H1) => h0.

    inversion h0.

Qed.



Lemma multipar_Path_consistent :

  forall S D a b T, multipar S D a b -> Path T a -> erased_tm a -> Path_consistent T a b.

Proof.

  intros S D a b T H. induction H.

  eauto using Path_consistent_Refl.

  intros h0 e0.

  move: (Par_Path_consistent H h0 e0) => h1.

  eapply Path_consistent_Trans with (b:=b); eauto;

  eauto using Path_consistent_Path2 with erased.

Qed.



Lemma Par_Path :

  forall S D a b T, Par S D a b -> Path T a -> Path T b.

Proof.

  induction 1; intros P; inversion P; subst; eauto with lc.

  - move: (IHPar1 H6) => h0.

    inversion h0.

  - move: (IHPar H5) => h0.

    inversion h0.

  - move: (IHPar H4) => h0.

    inversion h0.

Qed.



Lemma multipar_Path : forall S D a b T ,

    multipar S D a b -> Path T a -> Path T b.

Proof.

  intros S D a b T H. induction H. induction 1; intros; eauto.

  intros. eauto using Par_Path.

Qed.



    Lemma Par_Path_consistent_App : forall T G D a1 a2 b1 b2,

        Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->

        Par G D (a_App a1 Rel a2) ( a_App b1 Rel b2) ->

        Par G D a1 b1.

    Proof.

      intros. inversion H. subst.

      inversion H0; subst.

      - lc_inversion c. auto.

      - move: (Par_Path_consistent H9 (Path_consistent_Path1 H8) ltac: (eauto with erased)) => h0.

        inversion h0.

      - auto.

    Qed.



    Lemma Par_Path_consistent_AppIrrel : forall T G D a1 b1,

        Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->

        Par G D (a_App a1 Irrel a_Bullet) ( a_App b1 Irrel a_Bullet) ->

        Par G D a1 b1.

    Proof.

      intros. inversion H. subst.

      inversion H0; subst.

      - lc_inversion c. auto.

      - move: (Par_Path_consistent H6 (Path_consistent_Path1 H4) ltac: (eauto with erased)) => h0.

        inversion h0.

      - auto.

    Qed.



    Lemma Par_Path_consistent_CApp : forall T G D a1 b1,

        Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->

        Par G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->

        Par G D a1 b1.

    Proof.

      intros. inversion H. subst.

      inversion H0; subst.

      - lc_inversion c. auto.

      - move: (Par_Path_consistent H6 (Path_consistent_Path1 H4) ltac: (eauto with erased)) => h0.

        inversion h0.

      - auto.

    Qed.



    Lemma Par_Path_consistent_App2 : forall T G D a1 a2 b1 b2,

        Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->

        Par G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->

        Par G D a2 b2.

    Proof.

      intros. inversion H. subst.

      inversion H0; subst.

      - lc_inversion c. auto.

      - move: (Par_Path_consistent H9 (Path_consistent_Path1 H8) ltac: (eauto with erased)) => h0.

        inversion h0.

      - auto.

    Qed.



    Lemma multipar_Path_consistent_App : forall G D a1 a2 b1 b2 T,

      multipar G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->

      Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->

      multipar G D a1 b1.

    Proof.

      intros.

      dependent induction H.

      - eauto.

      - move: (Par_Path_consistent H (Path_consistent_Path1 H1) ltac:(eauto 2 with erased)) => h0.

        inversion h0. subst.

        move: (Par_Path_consistent_App h0 H) => h1.

        eapply mp_step with (b:= b0). auto.

        eapply IHmultipar; eauto 2.

        eapply Path_consistent_Trans with (b := a_App a1 Rel a2).

        eapply Path_consistent_Sym; auto.

        auto.

    Qed.



    Lemma multipar_Path_consistent_AppIrrel : forall G D a1 b1 T,

      multipar G D (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->

      Path_consistent T (a_App a1 Irrel a_Bullet) (a_App b1 Irrel a_Bullet) ->

      multipar G D a1 b1.

    Proof.

      intros.

      dependent induction H.

      - eauto.

      - move: (Par_Path_consistent H (Path_consistent_Path1 H1) ltac:(eauto 2 with erased)) => h0.

        inversion h0. subst.

        move: (Par_Path_consistent_AppIrrel h0 H) => h1.

        eapply mp_step with (b:= b0). auto.

        eapply IHmultipar; eauto 2.

        eapply Path_consistent_Trans with (b := a_App a1 Irrel a_Bullet).

        eapply Path_consistent_Sym; auto.

        auto.

    Qed.



     Lemma multipar_Path_consistent_App2 : forall G D a1 a2 b1 b2 T,

      multipar G D (a_App a1 Rel a2) (a_App b1 Rel b2) ->

      Path_consistent T (a_App a1 Rel a2) (a_App b1 Rel b2) ->

      multipar G D a2 b2.

    Proof.

      intros.

      dependent induction H.

      - eauto.

      - move: (Par_Path_consistent H (Path_consistent_Path1 H1) ltac:(eauto 2 with erased)) => h0.

        inversion h0. subst.

        move: (Par_Path_consistent_App2 h0 H) => h1.

        eapply mp_step with (b:= b3). auto.

        eapply IHmultipar; eauto 2.

        eapply Path_consistent_Trans with (b := a_App a1 Rel a2).

        eapply Path_consistent_Sym; auto.

        auto.

    Qed.



    Lemma multipar_Path_consistent_CApp : forall G D a1 b1 T,

      multipar G D (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->

      Path_consistent T (a_CApp a1 g_Triv) (a_CApp b1 g_Triv) ->

      multipar G D a1 b1.

    Proof.

      intros.

      dependent induction H.

      - eauto.

      - move: (Par_Path_consistent H (Path_consistent_Path1 H1) ltac:(eauto 2 with erased)) => h0.

        inversion h0. subst.

        move: (Par_Path_consistent_CApp h0 H) => h1.

        eapply mp_step with (b:= b0). auto.

        eapply IHmultipar; eauto 2.

        eapply Path_consistent_Trans with (b := a_CApp a1 g_Triv).

        eapply Path_consistent_Sym; auto.

        auto.

    Qed.



Ltac binds_notbinds :=

    match goal with

    [ H0 : binds ?c (Ax ?T ?a) toplevel,

      H5 : forall (c : atom) a, not (binds c (Ax ?T a) an_toplevel) |- _  ] =>

      unfold not in H5; unfold toplevel in H0; unfold erase_sig in H0;

      apply binds_map_3 in H0; destruct H0 as (s' & EQ & B);

      destruct s'; simpl in EQ; inversion EQ; subst;

      apply H5 in B; contradiction

      end.



Lemma Par_Const : forall S D T b,

    Par S D (a_Const T) b -> b = a_Const T.

Proof.

  intros. dependent induction H; eauto.

Qed.



Lemma multipar_Const : forall S D T b,

    multipar S D (a_Const T) b ->

    (b = a_Const T).

Proof.

  intros S D T b H. dependent induction H; eauto using Par_Const.

Qed.



Lemma multipar_Pi : forall S D rho A B, multipar S D A B -> forall A1 A2,

      A = a_Pi rho A1 A2 -> exists B1 B2, B = (a_Pi rho B1 B2).

intros S D rho A B H. induction H. intros. subst. exists A1, A2. auto.

intros. subst.

inversion H; subst; destruct (IHmultipar _ _ eq_refl) as [B1 [B2 EQ]]; auto;

exists B1, B2; auto.

Qed.



Lemma multipar_CPi : forall S D A C, multipar S D A C -> forall A1 A2 A3 B, A = a_CPi (Eq A1 A2 A3) B -> exists B1 B2 B3 C2,

        C = (a_CPi (Eq B1 B2 B3) C2).

Proof.

  intros S D A C H. induction H; intros; subst.

  exists A1, A2, A3, B. auto.

  inversion H; subst; destruct (IHmultipar _ _ _ _ eq_refl) as [B1 [B2 [C2 EQ]]];

    auto; exists B1, B2, C2; auto.

Qed.



Lemma multipar_UAbs_Rel : forall S D a b x,

    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm b ->

    multipar S D (a_UAbs Rel a) b ->

    (exists b2, b = (a_UAbs Rel b2))

    \/ (exists a1, exists a2, multipar S D (a_UAbs Rel a) (a_UAbs Rel a1) /\

               open_tm_wrt_tm a1 (a_Var_f x) = a_App a2 Rel (a_Var_f x)).

Proof.

    intros S D a b x Fr H. dependent induction H.

    - left. exists a. auto.

    - destruct (Par_Abs_inversion_Rel H); subst.

      + destruct H1 as [ a' [K W]]. rewrite K in H.

      assert (h0 : x `notin` fv_tm_tm_tm (a_UAbs Rel a')). eapply Par_fv_preservation; eauto.

      simpl in h0.

      destruct (IHmultipar a' ltac:(eauto)) as [ [b2 EQ2] | [a1 [a2 [mp1 F2]]] ]; subst; clear IHmultipar.

      auto. left. exists b2. auto. right. exists a1, a2. split. eauto. auto.

      + destruct H1 as [ a' [K W]]. right. exists a, a'. split; eauto.

Qed.



Lemma multipar_UAbs_Irrel : forall S D a b x,

    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm b ->

    multipar S D (a_UAbs Irrel a) b ->

    (exists b2, b = (a_UAbs Irrel b2))

    \/ (exists a1, exists a2, multipar S D (a_UAbs Irrel a) (a_UAbs Irrel a1) /\

               open_tm_wrt_tm a1 (a_Var_f x) = a_App a2 Irrel a_Bullet).

Proof.

    intros S D a b x Fr H. dependent induction H.

    - left. exists a. auto.

    - destruct (Par_Abs_inversion_Irrel H); subst.

      + destruct H1 as [ a' [K W]]. rewrite K in H.

      assert (h0 : x `notin` fv_tm_tm_tm (a_UAbs Rel a')). eapply Par_fv_preservation; eauto.

      simpl in h0.

      destruct (IHmultipar a' ltac:(eauto)) as [ [b2 EQ2] | [a1 [a2 [mp1 F2]]] ]; subst; clear IHmultipar.

      auto. left. exists b2. auto. right. exists a1, a2. split. eauto. auto.

      + destruct H1 as [ a' [K W]]. right. exists a, a'. split; eauto.

Qed.



Lemma multipar_CAbs : forall S D A C, multipar S D A C -> forall A1 A2 A3 B, A = a_CAbs (Eq A1 A2 A3) B -> exists B1 B2 B3 C2,

        C = (a_CAbs (Eq B1 B2 B3) C2).

Proof.

  intros S D A C H. induction H; intros; subst.

  exists A1, A2, A3, B. auto.

  inversion H; subst; destruct (IHmultipar _ _ _ _ eq_refl) as [B1 [B2 [C2 EQ]]];

    auto; exists B1, B2, C2; auto.

Qed.



Definition decide_Path : forall a, lc_tm a -> (exists T, Path T a) \/ (forall T, not (Path T a)).

Proof.

  induction a; intro lc.

  all: try solve [left; eauto].

  all: try solve [right; move => T h1; inversion h1].

  - lc_inversion c. destruct IHa1 as [[T h0]|n].

    auto.

    left; eauto.

    right. move => T h1. inversion h1.

    subst. unfold not in n. eauto.

  - lc_inversion c. destruct IHa as [[T h0]|n].

    auto.

    left; eauto.

    right. intros T h; inversion h; subst; unfold not in n; eauto.

  - lc_inversion c. destruct IHa as [[T h0]|n].

    auto.

    left. exists T. auto.

    right. intros T h; inversion h; subst; unfold not in n; eauto.

Qed.



Ltac step_left := apply consistent_a_Step_R; [auto |intro N; inversion N; inversion H0]; fail.

Ltac step_right := apply consistent_a_Step_L; [auto | intro N; inversion N; inversion H0]; fail.



Ltac multipar_step SIDE EQ :=

  match goal with

  | [ SIDE : multipar _ _ a_Star _ |- _ ] =>

    apply multipar_Star in SIDE; auto; rename SIDE into EQ

  | [ SIDE : multipar _ _ (a_Pi _ _ _) _ |- _ ] =>

    destruct (multipar_Pi SIDE eq_refl) as [b1' [b2' EQ]]

  | [ SIDE : multipar _ _ (a_CPi ?phi _) _ |- _ ] =>

    try (destruct phi); destruct (multipar_CPi SIDE eq_refl)

      as (B1' & B2' & C1' & C2' &  EQ)

  | [ SIDE : multipar _ _ (a_Const ?T) _ |- _ ] =>

    apply multipar_Const in SIDE; auto; rename SIDE into EQ

  | [ SIDE : Path_consistent _ _ _ |- _ ] =>

    rename SIDE into EQ

  end.



Lemma join_consistent : forall S D a b, joins S D a b -> consistent a b.

Proof.

  intros.

  all: destruct H as (TT & Es & Ea & Eb & MSL & MSR).

  all: move: (erased_lc Ea) => lc_a.

  all: move: (erased_lc Eb) => lc_b.

  destruct a; try step_right; destruct b; try step_left; auto.

  

  all: repeat

         let T  := fresh in

         let h0 := fresh in

         match goal with

           [ SIDE : multipar _ _ (a_App ?b1 ?rho ?b2) _,

               Eb : erased_tm (a_App ?b1 ?rho ?b2)  |- _ ] =>

           destruct (decide_Path (erased_lc Eb)) as [ [T h0] | NP ];

             [ eapply multipar_Path_consistent in SIDE; eauto | idtac ];

             clear Eb end.

    all: repeat

         let T  := fresh in

         let h0 := fresh in

         match goal with

           [ SIDE : multipar _ _ (a_CApp ?b1 ?b2) _, Eb: erased_tm (a_CApp ?b1 ?b2)  |- _ ] =>

           destruct (decide_Path (erased_lc Eb)) as [ [T h0] | NP ];

             [ eapply multipar_Path_consistent in SIDE; eauto | idtac ];

             clear Eb

         end.

  all: try solve [inversion Ea].

  all: try solve [inversion Eb].



  all: try multipar_step MSL EQ1.

  all: try multipar_step MSR EQ2.

  all: try solve [rewrite EQ1 in EQ2; inversion EQ2; try inversion H; auto].

  all: try solve [eapply consistent_a_Step_R; [auto | intros h0; inversion h0; unfold not in NP; eauto]].

  all: try solve [eapply consistent_a_Step_L; [auto | intros h0; inversion h0; unfold not in NP; eauto]].



  all: try match goal with

             [ H1: Path_consistent ?T1 ?a ?c, H2: Path_consistent ?T2 ?b ?c |- _ ] =>

             move: (Path_consistent_Path2 H1) => h0;

             move: (Path_consistent_Path2 H2) => h1;

    have EQ3: (T1 = T2); eauto using Path_unique; subst; eauto

  end.

  - rewrite EQ1 in EQ2; inversion EQ2. eauto.



  - destruct (multipar_Pi MSL eq_refl) as (B1 & B2 & EQ).

    destruct (multipar_Pi MSR eq_refl) as (B1' & B2' & EQ').

    subst.

    inversion EQ. inversion EQ'.

    subst. econstructor; eauto.

    inversion lc_a. auto.

    inversion lc_b. auto.

  - destruct phi.

    destruct (multipar_CPi MSL eq_refl) as (B1 & B2 & EQ).

    destruct (multipar_CPi MSR eq_refl) as (B1'' & B2'' & EQ').

    subst.

    inversion EQ. inversion EQ'.

    subst. econstructor; eauto.

    inversion lc_a. auto.

    inversion lc_b. auto.



Qed.



Lemma multipar_confluence_helper : forall S D a a1, Good S D -> erased_tm a -> multipar S D a a1

-> forall a2, Par S D a a2 -> exists e, Par S D a1 e /\ multipar S D a2 e.

Proof.

  intros S D a a1 Es E H. induction H.

  - intros. exists a2. split; eauto.

  - intros. destruct (confluence Es E H H1) as [d [L R]].

      inversion Es.

      assert (erased_tm b). eapply Par_erased_tm; eauto.

      destruct (IHmultipar H4 d) as [e [LL RR]]; auto.

      exists e. split; eauto.

Qed.



Lemma multipar_confluence : forall S D a a1, Good S D -> erased_tm a -> multipar S D a a1

-> forall a2, multipar S D a a2 -> exists b, multipar S D a1 b /\ multipar S D a2 b.

Proof.

  intros S D a a1 Es Ea MP. induction MP.

intros.

 - exists a2. split. eauto. eauto.

 - intros.

   destruct (multipar_confluence_helper Es Ea H0 H) as [d [L R]].

   inversion Es.

   assert (Eb : erased_tm b). eapply Par_erased_tm; eauto.

   destruct (IHMP Eb d) as [e [LL RR]]; auto.

   exists e. split; eauto.

Qed.



Lemma multipar_append : forall S D a b c, multipar S D a b -> multipar S D b c -> multipar S D a c.

Proof.

  intros.

  induction H. auto.

  eauto.

Qed.



Lemma join_transitive : forall S D a b, Good S D -> joins S D a b -> forall c, joins S D b c -> joins S D a c.

Proof.

  intros S D a b G H. destruct H as [ab [ES [Ea [Eb [Aab Bab]]]]].

  intros c H. destruct H as [bc [_ [_ [Ec [Bbc Cbc]]]]].

  destruct (multipar_confluence G Eb Bab Bbc) as [d [Babd Bbcd]].

  unfold joins.

  exists d. split. eauto. split. auto.

  split. auto. split; eapply multipar_append; eauto.

Qed.



Lemma join_symmetry: forall S D a b, joins S D a b -> joins S D b a.

Proof.

  intros S D a b H.

  destruct H as [ac h0].

  split_hyp.

  exists ac; eauto.

Qed.



Definition extends (G G2 : context) := exists G1, G = G1 ++ G2.



Lemma multipar_lc2: forall G D a1 a2, lc_tm a1 -> multipar G D a1 a2 -> lc_tm a2.

  induction 2; eauto.

  apply IHmultipar.

  eapply Par_lc2; apply H0.

Qed.



Hint Resolve multipar_context_independent : DB.



Lemma join_context_independent: forall G1 G2 D A B, erased_context G2 ->

                                             joins G1 D A B -> joins G2 D A B.

Proof.

  intros G1 G2 D A B E H.

  destruct H.

  split_hyp.

  unfold joins.

  exists x.

  repeat split; eauto with DB.

Qed.



Lemma Good_NoAssn: forall c G D phi, erased_sort (Co phi) -> Good G D -> c `notin` D -> Good ((c, Co phi) :: G) D.

Proof.

  intros c G D phi E H Fr.

  unfold Good in *.

  destruct H as (Es & M).

  split.

  + unfold erased_context in *.

    apply Forall_forall.

    intros x0 IN. destruct x0 as (y, s).

    inversion IN.

    - destruct phi. inversion H. subst. auto.

    - eapply Forall_forall in H; eauto.

      simpl in H. auto.

  + intros c1 c2. intros.

    assert (c <> c1). fsetdec.

    apply binds_cons_1 in H.

    destruct H as [[EQ _] | BI1]. fsetdec.

    edestruct (M c1) as (C & P1 & P2); eauto.

    exists C.

    repeat split;

      apply context_Par_irrelevance with (G1 := G)(D1 := D)(D2 := D); auto; try fsetdec;

        unfold sub_Axiom;

        intros;

        apply binds_cons; auto.

Qed.



Hint Resolve Good_NoAssn.



Hint Resolve multipar_context_independent.



Lemma Good_add_tm: forall G D x A,

    erased_tm A -> Good G D -> Good ((x, Tm A)::G ) D.

Proof.

  intros G D x A E H.

  unfold Good in *.

  split.

  + unfold erased_context in *.

    apply Forall_forall.

    intros x0 IN. destruct x0 as (y, s).

    inversion IN.

    - inversion H0. subst. apply erased_Tm. auto.

    - split_hyp.

      eapply Forall_forall in H; eauto.

      simpl in H. auto.

  + intros c1 A1 B1 T1 BI1 I1.

  destruct H as (Es & M).

  apply binds_cons_1 in BI1.

  destruct BI1 as [[_ EQ] | BI1]. inversion EQ.

  edestruct (M c1) as (C & P1 & P2); eauto.

  exists C. repeat split;

    apply context_Par_irrelevance with (G1 := G)(D1 := D); auto; try fsetdec;

    unfold sub_Axiom;

    intros;

    apply binds_cons; auto.

Qed.



Lemma Good_add_tm_2: forall G D x A, x `notin` dom G -> erased_tm A -> Good G D -> Good ((x, Tm A)::G ) (add x D).

Proof.

  intros G D x A FR E H.

  unfold Good in *.

  split.

  + unfold erased_context in *.

    apply Forall_forall.

    intros x0 IN. destruct x0 as (y, s).

    inversion IN.

    - inversion H0. subst. apply erased_Tm. auto.

    - split_hyp.

      eapply Forall_forall in H; eauto.

      simpl in H. auto.

  + intros c1 A1 B1 T1 BI1 I1.

  destruct H as (Es & M).

  apply binds_cons_1 in BI1.

  destruct BI1 as [[_ EQ] | BI1]. inversion EQ.

  edestruct (M c1) as (C & P1 & P2); eauto.

  move: (binds_In _ c1 _ _ BI1) => b0. fsetdec.

  exists C. repeat split;

    apply context_Par_irrelevance with (G1 := G)(D1 := D); auto; try fsetdec;

    unfold sub_Axiom;

    intros;

    apply binds_cons; auto.

Qed.



Lemma multipar_app_left_Rel:

  forall a a' c' S D, lc_tm a -> multipar S D a' c' -> multipar S D (a_App a Rel a') (a_App a Rel c').

Proof.

  induction 2; eauto; try done.

Qed.



Lemma multipar_capp_left: forall a a' S D, multipar S D a a' -> multipar S D (a_CApp a g_Triv) (a_CApp a' g_Triv).

Proof.

  induction 1; eauto; try done.

  Unshelve. auto.

Qed.



Lemma join_capp: forall a a' S D, joins S D a a' -> joins S D (a_CApp a g_Triv) (a_CApp a' g_Triv).

Proof.

  unfold joins.

  intros a a' S D H.

  destruct H as [ac h0].

  split_hyp.

  exists (a_CApp ac g_Triv).

  repeat split; eauto.

  apply multipar_capp_left; auto.

  apply multipar_capp_left; auto.

Qed.



Lemma multipar_app_lr_Rel: forall a a' c c' S D, lc_tm a -> lc_tm a' -> multipar S D a c -> multipar S D a' c' -> multipar S D (a_App a Rel a') (a_App c Rel c').

Proof.

  induction 3; eauto; try done.

  intros H1.

  apply multipar_app_left_Rel; auto.

  intros H3.

  apply (@mp_step S D _ (a_App b Rel a')); eauto.

  (have: lc_tm b by eapply Par_lc2; eauto); eauto.

  Unshelve. auto. auto.

Qed.



Lemma multipar_app_lr_Irrel: forall a c S D, lc_tm a -> multipar S D a c -> multipar S D (a_App a Irrel a_Bullet) (a_App c Irrel a_Bullet).

Proof.

  induction 2; eauto; try done.

  apply (@mp_step S D _ (a_App b Irrel a_Bullet)); eauto.

  (have: lc_tm b by eapply Par_lc2; eauto); eauto.

Qed.



Lemma join_app_Rel: forall a a' b b' S D, joins S D a b -> joins S D a' b' -> joins S D (a_App a Rel a') (a_App b Rel b').

Proof.

  unfold joins.

  intros a a' b b' S D H H0.

  destruct H as [ac h0].

  destruct H0 as [ac' h1].

  split_hyp.

  exists (a_App ac Rel ac').

  repeat split; eauto.

  apply multipar_app_lr_Rel; auto; try solve [eapply erased_lc; eauto].

  apply multipar_app_lr_Rel; auto; try solve [eapply erased_lc; eauto].

Qed.



Lemma join_app_Irrel: forall a b S D, joins S D a b -> joins S D (a_App a Irrel a_Bullet) (a_App b Irrel a_Bullet).

Proof.

  unfold joins.

  intros a b S D H.

  destruct H as [ac h0].

  split_hyp.

  exists (a_App ac Irrel a_Bullet).

  repeat split; eauto.

  apply multipar_app_lr_Irrel; auto; try solve [eapply erased_lc; eauto].

  apply multipar_app_lr_Irrel; auto; try solve [eapply erased_lc; eauto].

Qed.



Lemma multipar_UAbs_exists :  ∀ (x : atom) (G : context) (D : available_props)

       (rho : relflag) (a a' : tm),

    x `notin` fv_tm_tm_tm a

       → multipar G D (open_tm_wrt_tm a (a_Var_f x)) a'

         → multipar G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Proof.

  intros.

  dependent induction H0.

  autorewrite with lngen. auto.

  eapply mp_step.

  eapply Par_Abs_exists with (x:=x); eauto.

  eapply IHmultipar; eauto. autorewrite with lngen. auto.

  autorewrite with lngen. auto.

Qed.



Lemma multipar_iapp : forall G D a c y L,

    y `notin` fv_tm_tm_tm a \u L ->

    (forall x, x `notin` L -> RhoCheck Irrel x (open_tm_wrt_tm a (a_Var_f x))) ->

    multipar G D (open_tm_wrt_tm a a_Bullet) c ->

    multipar G D (a_UAbs Irrel a) (a_UAbs Irrel (close_tm_wrt_tm y c)).

Proof.

  intros.

  eapply multipar_UAbs_exists; auto.

  move: (H0 y ltac:(auto)) => h0.

  inversion h0.

  rewrite -(tm_subst_tm_tm_fresh_eq (open_tm_wrt_tm a (a_Var_f y)) a_Bullet y); eauto.

  rewrite - tm_subst_tm_tm_intro; eauto.

Qed.



Lemma joins_iapp : forall S D a1 a2 L1 L2,

    (forall x, x `notin` L1 -> RhoCheck Irrel x (open_tm_wrt_tm a1 (a_Var_f x))) ->

    (forall x, x `notin` L2 -> RhoCheck Irrel x (open_tm_wrt_tm a2 (a_Var_f x))) ->

    joins S D (open_tm_wrt_tm a1 a_Bullet) (open_tm_wrt_tm a2 a_Bullet) ->

    joins S D (a_UAbs Irrel a1) (a_UAbs Irrel a2).

Proof.

  intros.

  destruct H1 as (C & ES & T1 & T2 & P1 & P2).

  unfold joins.

  pick fresh y.

  exists (a_UAbs Irrel (close_tm_wrt_tm y C)).

  repeat split; eauto.

  eapply (@erased_a_Abs L1).

  intros.

  move: (H x H1) => RC. inversion RC.

  rewrite -(tm_subst_tm_tm_fresh_eq (open_tm_wrt_tm a1 (a_Var_f x)) a_Bullet x); eauto.

  rewrite - tm_subst_tm_tm_intro; eauto.

  move: (fv_tm_tm_tm_open_tm_wrt_tm_lower a1 (a_Var_f x)) => h0. fsetdec. auto.

  eapply (@erased_a_Abs L2).

  intros.

  move: (H0 x H1) => RC. inversion RC.

  rewrite -(tm_subst_tm_tm_fresh_eq (open_tm_wrt_tm a2 (a_Var_f x)) a_Bullet x); eauto.

  rewrite - tm_subst_tm_tm_intro; eauto.

  move: (fv_tm_tm_tm_open_tm_wrt_tm_lower a2 (a_Var_f x)) => h0. fsetdec.

  auto.

  eapply (multipar_iapp _ _ H). eauto.

  eapply (multipar_iapp _ _ H0). eauto.

  Unshelve. eauto. eauto.

Qed.



Lemma multipar_App_destruct_Rel : forall S D a1 a2 c,

    multipar S D (a_App a1 Rel a2) c ->

    (exists a1' a2',

        multipar S D (a_App a1 Rel a2) (a_App (a_UAbs Rel a1') Rel a2') /\

        multipar S D a1 (a_UAbs Rel a1') /\

        multipar S D a2 a2' /\

        multipar S D (open_tm_wrt_tm a1' a2') c) \/

    (exists a1' a2',

        multipar S D (a_App a1 Rel a2) (a_App a1' Rel a2') /\

        multipar S D a1 a1' /\

        multipar S D a2 a2').

Proof.

  intros. dependent induction H.

  right.

  exists a1, a2. split; auto.

  inversion H.

  + subst. eauto.

  + subst. left.

    exists a', b'. split; auto.

    assert (lc_tm a1). eapply Par_lc1. eauto.

    assert (lc_tm a2). eapply Par_lc1. eauto.

    eapply multipar_app_lr_Rel; eauto.

    split.

    eapply mp_step; eauto.

    split; eauto.

  +

    assert (lc_tm a1). eapply Par_lc1. eauto.

    assert (lc_tm a2). eapply Par_lc1. eauto.

    subst. destruct (IHmultipar a' b') as [[a1' [a2' [P1 [P2 [P3 P4]]]]] |

                                                [a1' [a2' [P1 [P2 P3]]]]] ; auto.

    ++ clear IHmultipar. left.

       exists a1', a2'.

       repeat split; eauto.

    ++ clear IHmultipar. right.



       exists a1', a2'.

       repeat split; eauto.

Unshelve.

all: exact S.

Qed.



Lemma multipar_App_destruct_Irrel : forall S D a1 c,

    multipar S D (a_App a1 Irrel a_Bullet) c ->

    (exists a1',

        multipar S D (a_App a1 Irrel a_Bullet) (a_App (a_UAbs Irrel a1') Irrel a_Bullet) /\

        multipar S D a1 (a_UAbs Irrel a1') /\ multipar S D (open_tm_wrt_tm a1' a_Bullet) c) \/

    (exists a1',

        multipar S D (a_App a1 Irrel a_Bullet) (a_App a1' Irrel a_Bullet) /\

        multipar S D a1 a1').

Proof.

  intros. dependent induction H.

  right.

  exists a1. split; auto.

  inversion H.

  + subst. eauto.

  + subst. left.

    exists a'. split; auto.

    assert (lc_tm a1). eapply Par_lc1. eauto.

    eapply multipar_app_lr_Irrel; eauto.

    split.

    eapply mp_step; eauto.

    eauto.

  +

    assert (lc_tm a1). eapply Par_lc1. eauto.

    subst. edestruct (IHmultipar a'); auto.

    ++ clear IHmultipar. left. destruct H1 as [a1' K].

       exists a1'. inversion K. clear K. inversion H2. clear H2.

       repeat split; eauto.

    ++ clear IHmultipar. right. destruct H1 as [a1' K].

       exists a1'. inversion K. clear K.

       repeat split; eauto.

Unshelve.

all: exact S.

Qed.



Lemma consistent_mutual:

  (forall S a A,   Typing S a A -> True) /\

  (forall S phi,   PropWff S phi -> True) /\

  (forall S D p1 p2, Iso S D p1 p2 -> Good S D -> (forall A1 B1 T1 A2 B2 T2, p1 = Eq A1 B1 T1 -> p2 = Eq A2 B2 T2-> (joins S D A1 A2 /\ joins S D B1 B2 /\ joins S D T1 T2))) /\

  (forall S D A B T,   DefEq S D A B T -> Good S D -> joins S D A B) /\

  (forall S,       Ctx S -> True).

Proof.

  apply typing_wff_iso_defeq_mutual; eauto; try done.

  - intros G D A1 B1 A A2 B2 d H d0 H0 H1 A0 B0 T1 A3 B3 T2 H2 H3.

    inversion H2; subst; clear H2.

    inversion H3; subst; clear H3.

    repeat split; eauto.

    exists T2; eauto.

    have et: erased_tm T2.

    apply DefEq_regularity in d.

    pose K := (second typing_erased_mutual) _ _ d A0 A3 T2.

    apply K; auto.

    repeat split; auto.

    have C: Ctx G by eauto.

    unfold erased_context.

    apply Forall_forall.

    intros. destruct x. destruct s.

    apply binds_to_Typing in H2.

    apply Typing_erased in H2.

    eapply erased_Tm. auto. auto.

    destruct phi. apply binds_to_PropWff in H2.

    inversion H2.

    eapply erased_Co; eauto using Typing_erased. auto.

  - intros G D A1 A2 A B d H p H0 p0 H1 H2 A0 B1 T1 A3 B2 T2 H3 H4.

    inversion H4; subst; clear H4.

    inversion H3; subst; clear H3.

    inversion p; subst.

    inversion H2.

    have lc1: lc_tm A0 by eapply Typing_lc in H7; split_hyp; eauto.

    have lc2: lc_tm B1 by eapply Typing_lc in H8; split_hyp; eauto.

    repeat split; eauto.

    + exists A0.

      repeat split; eauto; try solve [eapply (Typing_erased); eauto]; eauto.

    + exists B1.

      repeat split; eauto; try solve [eapply (Typing_erased); eauto]; eauto.

  - intros G D5 phi1 phi2 B1 B2 d H H0 A1 B0 T1 A2 B3 T2 H1 H2.

    destruct phi1.

    destruct phi2.

    inversion H1; subst; clear H1.

    inversion H2; subst; clear H2.

    destruct H as [Bc h0]; auto.

    split_hyp.

    pose K1 := multipar_CPi H3 eq_refl.

    destruct K1 as [B1' [B2' [B3' [Bc' h0]]]].

    subst.

    pose K1 := multipar_CPi_phi_proj H3.

    pose K2 := multipar_CPi_phi_proj H4.

    split_hyp.

    repeat split; eauto.

    + exists B1'.

      inversion H2; subst; clear H2.

      inversion H1; subst; clear H1.

      repeat split; eauto.

    + exists B2'.

      inversion H2; subst; clear H2.

      inversion H1; subst; clear H1.

      repeat split; eauto.

    + exists B3'.

      inversion H2; subst; clear H2.

      inversion H1; subst; clear H1.

      repeat split; eauto.

  - 

    intros G D a b A c c0 H b0 i H0.

    destruct H0 as (Es & M).

    edestruct (M c); eauto.

    split_hyp.

    unfold erased_context in Es.

    move:

      (@Forall_forall _ (λ (p : (atom*sort)), let (_, s) := p in erased_sort s) G) => [h0 _].

    move: (h0 Es _ b0) => h1.

    inversion h1.

    unfold joins. exists x. repeat split; eauto.

  - 

    intros G D a A t H H0.

    inversion H0.

    unfold joins. exists a.

    repeat split; try solve [eapply (Typing_erased); eauto]; eauto.

  - 

    intros G D a b A d H H0.

    unfold joins in *. destruct H as [c [L R]]; auto.

    exists c. tauto.

  - 

    intros. eapply join_transitive; auto.

  - 

    intros G. intros.

    inversion H1.

    unfold joins in *. subst.

    have p: Par G D a1 a2.

    { inversion b.

      eapply Par_Beta; eauto 2. eauto using Value_lc.

      eapply Par_CBeta; eauto 2.

      eapply Par_Axiom; eauto 2.

      }

    destruct (confluence H1 (Typing_erased t) p p) as [ac [h0 h1]].

    exists ac; eauto.

    pose K2 := Typing_erased t0.

    repeat split; eauto.

    eapply Typing_erased; eauto.

  - 

    intros L G D rho A1 B1 A2 B2 d H d0 H0 _ _ t H1 t0 H2 H3.

    inversion H3.

    have e0: erased_tm (a_Pi rho A1 B1). eapply Typing_erased; eauto.

    inversion e0. subst.

    pose Ih1 := H H3.

    pick fresh x for (L \u (fv_tm_tm_tm B1) \u (fv_tm_tm_tm B2) \u dom G).

    assert (G' : Good ([(x, Tm A1)] ++ G) D).

    { apply Good_add_tm; auto. }

    have: x `notin` L; auto => fr.

    pose Ih2 := H0 x fr G'.

    destruct H as [A'' h1]; auto; subst.

    destruct Ih2 as [B'' h2].

    split_hyp.

    exists (a_Pi rho A'' (close_tm_wrt_tm x B'')); eauto.

    repeat split; eauto 1.

    + apply (@erased_a_Pi L); try solve [apply h2; auto]; try solve [apply h1; auto]; eauto.

      intros x0 h4.

      assert (G'' : Good ([(x0, Tm A1)] ++ G) D).

      apply Good_add_tm; auto.

      pose Ih2 := H0 x0 h4 G''.

      destruct Ih2 as [C'' h3]; eauto.

      apply h3.

    + apply multipar_Pi_exists; auto.

      apply (lc_a_Pi_exists x); apply erased_lc; auto.

      eapply multipar_context_independent; eauto.

    + apply multipar_Pi_exists; auto.

      apply (lc_a_Pi_exists x); apply erased_lc; auto.

      eapply multipar_context_independent; eauto.

  - 

    intros L G D rho b1 b2 A1 B IHDefEq H1 t _ RC1 RC2 GOOD.

    inversion GOOD.

    have e0: erased_tm A1. eapply Typing_erased; eauto.

    pick fresh x for (L \u (fv_tm_tm_tm b1) \u (fv_tm_tm_tm b2)).

    assert (G' : Good ([(x, Tm A1)] ++ G) D).

    apply Good_add_tm; auto.

    have: x `notin` L; auto => fr.

    pose Ih2 := H1 x fr G'.

    destruct Ih2 as [B'' h2].

    split_hyp.

    exists (a_UAbs rho (close_tm_wrt_tm x B'')); eauto.

    repeat split; eauto 1.

    + apply (@erased_a_Abs L); try solve [apply h2; auto]; try solve [apply h1; auto]; eauto.

      intros x0 h4.

      assert (G'' : Good ([(x0, Tm A1)] ++ G) D).

      apply Good_add_tm; auto.

      pose Ih2 := H1 x0 h4 G''.

      destruct Ih2 as [C'' h3]; eauto.

      apply h3.

    + apply (@erased_a_Abs L); try solve [apply h2; auto]; try solve [apply h1; auto]; eauto.

      intros x0 h4.

      assert (G'' : Good ([(x0, Tm A1)] ++ G) D).

      apply Good_add_tm; auto.

      pose Ih2 := H1 x0 h4 G''.

      destruct Ih2 as [C'' h3]; eauto.

      apply h3.

    + apply multipar_Abs_exists; auto.

      apply (lc_a_UAbs_exists x); apply erased_lc; auto.

      eapply multipar_context_independent; eauto.

    + apply multipar_Abs_exists; auto.

      apply (lc_a_UAbs_exists x); apply erased_lc; auto.

      eapply multipar_context_independent; eauto.

  - intros G D a1 a2 b1 b2 d H d0 H0 p H1 H2.

    apply join_app_Rel; auto.

  - intros G D a1 b1 B a A d H t H0 H1.

    inversion H1.

    apply join_app_Irrel; auto.

  - intros G D A1 A2 rho B1 B2 H IHDefEq GOOD.

    inversion GOOD.

    destruct IHDefEq; auto.

    split_hyp.

    pose K1 := multipar_Pi H5 eq_refl.

    destruct K1 as [A' [B' h0]].

    subst.

    inversion H3; inversion H4; subst.

    apply multipar_Pi_A_proj in H5.

    apply multipar_Pi_A_proj in H6.

    exists A'; eauto.

    apply erased_lc; eauto.

    apply erased_lc; eauto.

  - intros G D B1 a1 B2 a2 rho A1 A2 H IHDefEq1 H0 IHDefEq2 GOOD.

    inversion GOOD.

    destruct IHDefEq1; auto.

    destruct IHDefEq2 as [ac h0]; auto.

    split_hyp.

    pose K1 := multipar_Pi H11 eq_refl.

    destruct K1 as [A' [B' h0]].

    subst.

    inversion H9.

    inversion H10; subst.

    apply (multipar_Pi_B_proj) in H11.

    apply (multipar_Pi_B_proj) in H12.

    destruct H11 as [L1 h9].

    destruct H12 as [L2 h10].

    pick_fresh x.

    exists (open_tm_wrt_tm B' ac).



Ltac subst_tm_erased_open x :=

  let K := fresh in

  let h0 := fresh in

  match goal with

  | [H16 : ∀ x : atom, x `notin` ?L0 →

                       erased_tm  (open_tm_wrt_tm ?B (a_Var_f x)),

     H2 : erased_tm ?a

     |- erased_tm (open_tm_wrt_tm ?B ?a) ] =>

    have: x `notin` L0; auto => h0;

    pose K := subst_tm_erased x H2 (H16 x h0);

    clearbody K;

    repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in K; auto; try solve [apply erased_lc; auto];

    simpl in K;

    destruct eq_dec; try congruence;

    rewrite tm_subst_tm_tm_fresh_eq in K; auto

  end.



Ltac multipar_subst_open x :=

  let K := fresh in

  let h1 := fresh in

  let h0 := fresh in

  let h2 := fresh in

  let lc1 := fresh in

  match goal with

    [

      H2 : erased_tm ?a1,

      H4 : multipar ?G ?D ?a1 ?ac,

      H18: ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_tm ?B1 (a_Var_f x)),

      H9 : ∀ x : atom,

       x `notin` ?L1

       → multipar ?G ?D (open_tm_wrt_tm ?B1 (a_Var_f x)) (open_tm_wrt_tm ?B' (a_Var_f x))

    |-

    multipar ?G ?D (open_tm_wrt_tm ?B1 ?a1) (open_tm_wrt_tm ?B' ?ac) ] =>

      have: x `notin` L0; auto => h0;

      have: x `notin` L1; auto => h1;



      pose K := multipar_subst3 x H2 H4 (H18 x h0) (H9 x h1);

      clearbody K;

      (have: lc_tm a1 by eapply erased_lc; eauto) => lc1;

      repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in K;

      eauto;try solve [eapply multipar_lc2; eauto | eapply multipar_lc2; eauto];

      simpl in K;

      destruct eq_dec; try congruence;

      repeat rewrite tm_subst_tm_tm_fresh_eq in K; auto

   end.



  repeat split; eauto.

    + subst_tm_erased_open x.

    + subst_tm_erased_open x.

    + multipar_subst_open x.

    + multipar_subst_open x.

  - 

    intros L G D phi1 A phi2 B H hi0 H1 IHDefEq H2 _ _ t _ _ GOOD .

    destruct phi1.

    destruct phi2.

    pick_fresh c.

    match goal with

      | [ H : Iso G D (Eq a b A0) (Eq a0 b0 A1) |- _ ] =>

        destruct (hi0 GOOD a b A0 a0 b0 A1) as [hi1 [hi2 hi3]]; auto

    end.

    have EC : erased_sort (Co (Eq a b A0)).

    { inversion H2. apply erased_Co; eapply Typing_erased; eauto. }

    destruct (IHDefEq c) as [Ac h1]; eauto.

    + apply Good_NoAssn; auto.

    + split_hyp.

      unfold joins in *.

      destruct hi1 as [Aco h0'].

      destruct hi2 as [Bco h1'].

      destruct hi3 as [Tco h2'].

      split_hyp.

      exists (a_CPi (Eq Aco Bco Tco) (close_tm_wrt_co c Ac)); eauto.

      repeat split; eauto 1.

      * apply (@erased_a_CPi (L \u D)); eauto.

        intros c0 Hi5.

        destruct (IHDefEq c0) as [Ac' h2']; auto; subst.

        apply Good_NoAssn; auto.

        apply h2'.

      * apply (@erased_a_CPi (L \u D)); eauto.

        intros c0 Hi5.

        destruct (IHDefEq c0) as [Ac' h2']; auto; subst.

        apply Good_NoAssn; auto.

        apply h2'.

      * 



        Ltac multipar_CPi c :=

        apply multipar_CPi_exists; auto;

        [ apply (lc_a_CPi_exists c); try constructor; apply erased_lc; auto |

          eapply multipar_context_independent; eauto].

        multipar_CPi c.

      * multipar_CPi c.

  - intros L G D a b phi1 B hi0 IHDefEq H1 _ GOOD.

    destruct phi1.

    pick_fresh c.

    have EC : erased_sort (Co (Eq a0 b0 A)).

    { inversion H1. apply erased_Co; eapply Typing_erased; eauto. }

    inversion GOOD.

    destruct (IHDefEq c) as [Ac h1]; auto.

    + apply Good_NoAssn; auto.

    + split_hyp.

      unfold joins in *.

      exists (a_UCAbs (close_tm_wrt_co c Ac)); eauto.

      split_hyp.

      repeat split; eauto 1.

      * apply (@erased_a_CAbs (L \u D)); eauto.

        intros c0 Hi6.

        destruct (IHDefEq c0) as [Ac' h2']; auto; subst.

        apply Good_NoAssn; auto.

        apply h2'.

      * apply (@erased_a_CAbs (L \u D)); eauto.

        intros c0 Hi5.

        destruct (IHDefEq c0) as [Ac' h2']; auto; subst.

        apply Good_NoAssn; auto.

        apply h2'.

      * apply multipar_CAbs_exists; auto.

        apply (lc_a_UCAbs_exists c); try constructor; apply erased_lc; auto.

        eapply multipar_context_independent; eauto.

      * apply multipar_CAbs_exists; auto.

        apply (lc_a_UCAbs_exists c); try constructor; apply erased_lc; auto.

        eapply multipar_context_independent; eauto.

  - intros G D a1 b1 B a b A d H p H0 H1.

    apply join_capp; auto.

  - intros G D B1 B2 A1 A2 A A1' A2' A' H0 IHDefEq hi1 IHDefEq2 hi0 IHDefEq3 GOOD.

    destruct IHDefEq as [Ac h0]; eauto.

    split_hyp.

    inversion GOOD.

    match goal with

      [ H1 : erased_tm (a_CPi (Eq A1 A2 A) B1),

        H2 : erased_tm (a_CPi (Eq A1' A2' A') B2),

        H3 :  multipar G D (a_CPi (Eq A1 A2 A) B1) Ac,

        H4 : multipar G D (a_CPi (Eq A1' A2' A') B2) Ac |- _ ] =>

      pose K1 := multipar_CPi H3 eq_refl;

      destruct K1 as [B1' [B2' [B3' [Bc' h0]]]];

      subst;

      inversion H1;

      inversion H2; subst;

      apply multipar_CPi_B_proj in H3;

      apply multipar_CPi_B_proj in H4;

      destruct H3 as [L1 H3];

      destruct H4 as [L2 H4]

    end.

    pick_fresh c.

    exists (open_tm_wrt_co Bc' g_Triv).

    have: c `notin` L; auto => h.

    have: c `notin` L0; auto => h0.

    repeat split; eauto 1.

    + Ltac erased_open_tm_wrt_co c B1 :=

        let K:= fresh in

        match goal with

        [ h : c `notin` ?L, H11 :  ∀ c : atom, c `notin` ?L → erased_tm (open_tm_wrt_co B1 (g_Var_f c)) |- _ ] =>

        pose K := subst_co_erased c lc_g_Triv (H11 c h);

        clearbody K;

        repeat rewrite co_subst_co_tm_open_tm_wrt_co in K; auto;

        simpl in K;

        destruct eq_dec; try congruence;

        rewrite co_subst_co_tm_fresh_eq in K; auto

        end.

      erased_open_tm_wrt_co c B1.

    + erased_open_tm_wrt_co c B2.

    + Ltac multipar_open_tm_wrt_co c B1 :=

        let K:= fresh in

        let h1:= fresh in

        match goal with

        [ H3 : ∀ c : atom, c `notin` ?L1 →

                           multipar ?G ?D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co ?Bc' (g_Var_f c))

          |- _ ] =>

        have: c `notin` L1; auto => h1;

        pose K := multipar_subst4 c lc_g_Triv (H3 c h1);

        clearbody K;

        repeat rewrite co_subst_co_tm_open_tm_wrt_co in K; eauto;

        simpl in K;

        destruct eq_dec; try congruence;

          repeat rewrite co_subst_co_tm_fresh_eq in K; auto

        end.

      multipar_open_tm_wrt_co c B1.

    + multipar_open_tm_wrt_co c B2.

  - intros G D A' B' a' A B a d H i H0 H1.

    destruct (H0 H1 A B a A' B' a'); auto.

    move: (H H1) => h0.

    split_hyp.

    have h1 : joins G D A' B; eauto.

    apply join_transitive with (b := A); eauto.

    apply join_symmetry; auto.

    apply join_transitive with (b := B); eauto.

  - intros G D A A' a b a' b' i H H0.

    destruct (H H0 a b A a' b' A'); auto.

    destruct H2; auto.

    Unshelve. all: auto.

  - intros.

    inversion H0.

    unfold joins.

    have: Par G D b b. eauto using Typing_lc1. move => Pb.

    exists b. repeat split; eauto 2 using Typing_erased.

    + pick fresh x and apply erased_a_Abs.

      rewrite e; auto. eauto 3 using Typing_erased. eauto.

    + eapply mp_step with (b := b); eauto.

  - intros.

    inversion H0.

    unfold joins.

    have: Par G D b b. eauto using Typing_lc1. move => Pb.

    exists b. repeat split; eauto 2 using Typing_erased.

    + pick fresh x and apply erased_a_Abs.

      rewrite e; auto. eauto 3 using Typing_erased. erewrite e.

      constructor. simpl. fsetdec. fsetdec.

    + eapply mp_step with (b := b); eauto.

  - intros.

    inversion H0.

    unfold joins.

    have: Par G D b b. eauto using Typing_lc1. move => Pb.

    exists b. repeat split; eauto 2 using Typing_erased.

    + pick fresh x and apply erased_a_CAbs.

      rewrite e; auto. eauto 3 using Typing_erased.

    + eapply mp_step with (b := b); eauto.



Qed.



Lemma consistent_defeq: forall S D A B T,   DefEq S D A B T -> Good S D -> joins S D A B.

Proof.

  apply consistent_mutual.

Qed.



Lemma no_aAbs : forall G rho A' a A, Typing G (a_Abs rho A' a) A -> False.

Proof.

  intros. dependent induction H. by apply: IHTyping1.

Qed.



Lemma no_aCAbs : forall G A' a A, Typing G (a_CAbs A' a) A -> False.

Proof.

  intros. dependent induction H; by apply: IHTyping1.

Qed.



Lemma Good_nil : forall D, Good nil D.

Proof.

  intro D.

  unfold Good. split.  done.

  intros. inversion H.

Qed.



Lemma consistent_Star : forall A0,

    consistent a_Star A0 -> value_type A0 -> A0 = a_Star.

Proof.

  intros A0 C V.

  destruct A0; try destruct rho;

    simpl in *; inversion C; inversion V.

  all: subst; auto.

  all: try solve [inversion H].

  all: try solve [inversion H2].

  all: done.

Qed.



Definition irrelevant G D (a : tm) :=

  (forall x A, binds x (Tm A) G -> x `notin` fv_tm a) /\ Good G D.



Lemma irrelevant_Good : forall G D a, irrelevant G D a -> Good G D.

intros. inversion H.

auto.

Qed.



Ltac impossible_Path :=

  match goal with

     [H : Path ?T (a_Pi _ _ _) |- _] => inversion H

   | [H : Path ?T a_Star |- _] => inversion H

   | [H : Path ?T (a_CPi _ _) |- _] => inversion H

  end.



Ltac impossible_defeq :=

  let h0 := fresh in

  let VT := fresh in

  let VT2 := fresh in

  match goal with

  | [ H : DefEq ?G (dom ?G) ?B ?A ?C |- _ ] =>

    pose h0:= H; clearbody h0;

    apply consistent_defeq in h0; eauto;

    [apply join_consistent in h0;

     destruct (DefEq_lc H) as (l0 & l1 & l2); inversion l0; inversion l1; subst;

     have VT: value_type A; eauto;

     have VT2 : value_type B; eauto;

     inversion h0; subst; try impossible_Path;

     eauto; try done | eapply irrelevant_Good; eauto]

  end.



Lemma canonical_forms_Star : forall G a, irrelevant G (dom G) a ->

    Typing G a a_Star -> Value a -> value_type a.

Proof.

  intros G a IR H V. induction V; auto.

  - subst. assert False. eapply no_aAbs. eauto 2. done.

  - subst. apply invert_a_UAbs in H; eauto.

    destruct H as [A1 [B2 [H _]]].

    impossible_defeq.

  - subst. apply invert_a_UAbs in H; eauto.

    destruct H as (A1 & A2 & DE & TA1 & TA2).

    impossible_defeq.

  - subst. assert False. eapply  no_aAbs. eauto 2. done.

  - subst.  assert False. eapply no_aCAbs. eauto 2. done.

  - subst. apply invert_a_UCAbs in H; eauto.

    destruct H as [a0 [b [T [B1 [_ [H _]]]]]].

    impossible_defeq.

  - eauto.

  - eauto.

Qed.



Lemma DefEq_Star: forall A G D, Good G D -> value_type A -> DefEq G D A a_Star a_Star -> A = a_Star.

Proof.

  intros A G D Good H0 H.

  apply consistent_defeq in H; eauto.

  apply join_consistent in H.

  inversion H;  eauto; subst; try done.

  impossible_Path.

Qed.



Lemma canonical_forms_Pi : forall G rho a A B, irrelevant G (dom G) a ->

    Typing G a (a_Pi rho A B) -> Value a ->

    (exists a1, a = a_UAbs rho a1) \/ (exists T, Path T a).

Proof.

  intros G rho a A B IR H H0.

  inversion H0; subst; eauto.

  - apply invert_a_Star in H; eauto.

    impossible_defeq.

  - eapply invert_a_Pi in H; eauto.

    destruct H as [H _]; eauto.

    impossible_defeq.

  - eapply invert_a_CPi in H; eauto.

    destruct H as [H _].

    impossible_defeq.

  - assert False. eapply no_aAbs. eauto 2. done.

  - eapply invert_a_UAbs in H; eauto.

    destruct H as (A1 & A2 & H & _); eauto.

    impossible_defeq.

  - eapply invert_a_UAbs in H; eauto.

    destruct H as (A1 & B1 & H & _); eauto.

    impossible_defeq.

  - assert False. eapply no_aAbs. eauto 2. done.

  - assert False. eapply no_aCAbs. eauto 2. done.

  - eapply invert_a_UCAbs in H; eauto.

    destruct H as [a [b [T [B1 [_ [H _]]]]]]; eauto.

    impossible_defeq.

Qed.



Lemma canonical_forms_CPi : forall G a phi B, irrelevant G (dom G) a ->

    Typing G a (a_CPi phi B) -> Value a ->

    (exists a1, a = a_UCAbs a1) \/ (exists T, Path T a).

Proof.

  intros G a phi B IR H H0.

  inversion H0; subst; eauto.

  - apply invert_a_Star in H; eauto.

    impossible_defeq.

  - eapply invert_a_Pi in H; eauto.

    destruct H as [H _]; eauto.

    impossible_defeq.

  - eapply invert_a_CPi in H; eauto.

    destruct H as [H _].

    impossible_defeq.

  - assert False. eapply no_aAbs. eauto 2. done.

  - eapply invert_a_UAbs in H; eauto.

    destruct H as [A1 [A2 [H _]]]; eauto.

    impossible_defeq.

  - eapply invert_a_UAbs in H; eauto.

    destruct H as [A1 [A2 [H _]]]; eauto.

    impossible_defeq.

  - assert False. eapply no_aAbs. eauto 2. done.

  - assert False. eapply no_aCAbs. eauto 2. done.

Qed.



Ltac show_irrelevant IR :=

        let x := fresh in

        let A0 := fresh in

        let B0 := fresh in

        let h0 := fresh in

        let h1 := fresh in

        unfold irrelevant in *;

        move: IR => [h0 h1]; split; auto;

        intros x A0 B0;  apply h0 in B0; simpl in B0; fsetdec.



Lemma notin_sub : forall x a b, x `notin` a -> b [<=] a -> x `notin` b.

  intros. fsetdec.

Qed.



Lemma progress : forall G a A, Typing G a A ->

                          irrelevant G (dom G) a ->

                          Value a \/ exists a', reduction_in_one a a'.

  induction 1; intros IR; subst; eauto; try done.

  - unfold irrelevant in *.

    move: IR => [H1 _].

    apply H1 in H0. simpl in H0. fsetdec.

  - left; eauto.

    constructor.

    apply (Typing_lc H1); eauto.

    pick_fresh x.

    have: x `notin` L; auto => h0.

    apply (lc_a_Pi_exists x).

    apply (Typing_lc H1); eauto.

    apply (Typing_lc (H x h0)); eauto.

  - destruct rho.

    + left.

    constructor; eauto.

    pick_fresh x.

    have: x `notin` L; auto => h0.

    apply (lc_a_UAbs_exists x).

    apply (Typing_lc (H x h0)); eauto.

    + pick fresh x.

      assert (x `notin` L). auto.

      move: (H2 x H3) => h0.

      inversion h0. subst.

      destruct (H0 x H3) as [V | [a' R]].

      { move: (H x H3) => h1.

      unfold irrelevant in *.

      destruct IR as [h2 h3].

      have ctx: (Ctx ([(x, Tm A)] ++ G)) by eauto.

      move: (Ctx_uniq ctx) => u. inversion u. subst.

      split. intros x0 A0 b0.

      apply binds_cons_uniq_1 in b0. destruct b0.

      ++ split_hyp. subst. auto.

      ++ split_hyp.

         move: (h2 _ _ H5) => fr. simpl in fr.

         eapply notin_sub; [idtac|eapply fv_tm_tm_tm_open_tm_wrt_tm_upper].

         simpl.

         fsetdec.

      ++ eauto.

      ++ simpl. eapply Good_add_tm_2; eauto using Typing_erased. }

      -- left.

         eapply Value_UAbsIrrel_exists with (x := x); eauto.

      -- right. exists (a_UAbs Irrel (close_tm_wrt_tm x a')).

         eapply E_AbsTerm_exists with (x := x).

         { eapply notin_union; auto.

           simpl. rewrite fv_tm_tm_tm_close_tm_wrt_tm. auto. }

         rewrite open_tm_wrt_tm_close_tm_wrt_tm. auto.

  - destruct IHTyping1 as [V | [b' h0]].

    + show_irrelevant IR.

    + apply canonical_forms_Pi in H; auto.

      destruct H as [[a1 e1]|[T P]]; subst.

      ++ right.

         exists (open_tm_wrt_tm a1 a); eauto.

         apply E_AppAbs; eauto.

         eauto using Value_lc.

         apply (Typing_lc H0); eauto.

      ++ left. eauto with lc.

      ++ show_irrelevant IR.

    + right.

      exists (a_App b' Rel a); eauto.

      apply E_AppLeft; eauto.

      apply (Typing_lc H0); eauto.

  - case IHTyping1; auto.

    + show_irrelevant IR.

    + move => h1.

      apply canonical_forms_Pi in H; auto.

      destruct H as [[a1 e1]|[T P]]; subst.

      ++ right.

      exists (open_tm_wrt_tm a1 a_Bullet); eauto.

      ++ left. eauto with lc.

      ++ show_irrelevant IR.

    + move => h1.

      destruct h1 as [b' h0].

      right.

      exists (a_App b' Irrel a_Bullet); eauto.

  - left.

    constructor; eauto.

    apply (PropWff_lc H1); eauto.

    pick_fresh c.

    have: c `notin` L; auto => h0.

    apply (lc_a_CPi_exists c); eauto 1.

    apply (PropWff_lc H1); eauto.

    apply (Typing_lc (H c h0)); eauto.

  - left.

    constructor; eauto.

    pick_fresh c.

    have h0: c `notin` L; auto.

    apply (lc_a_UCAbs_exists c); eauto 0.

    apply (Typing_lc (H c h0)); eauto.

  - case IHTyping; auto.

    + show_irrelevant IR.

    + move => h1.

      apply canonical_forms_CPi in H; auto.

      destruct H as [[a2 e1]|[T P]]; subst.

      ++

        right. exists (open_tm_wrt_co a2 g_Triv); eauto.

        eapply E_CAppCAbs; eauto.

        eauto using Value_lc.

      ++ left. eauto with lc.

      ++ show_irrelevant IR.

    + intros H1.

      destruct H1 as [a' h0].

      right.

      exists (a_CApp a' g_Triv); eauto.

Qed.



End ext_consist.

