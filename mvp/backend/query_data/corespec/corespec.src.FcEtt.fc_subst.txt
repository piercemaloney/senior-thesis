Require Import FcEtt.sigs.
(* FcEtt.sigs:
Require Import FcEtt.imports.

Require Export FcEtt.ett_ott.
Require Export FcEtt.utils.

Module Type ext_wf_sig.

Axiom ctx_wff_mutual :
  (forall G0 a A, Typing G0 a A -> Ctx G0) /\
  (forall G0 phi,   PropWff G0 phi -> Ctx G0) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> Ctx G0) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> Ctx G0) /\
  (forall G0, Ctx G0 -> True).

Axiom lc_mutual :
  (forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A) /\
  (forall G0 phi,   PropWff G0 phi -> lc_constraint phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T) /\
  (forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s).

Axiom Typing_lc  : forall G0 a A, Typing G0 a A -> lc_tm a /\ lc_tm A.
Axiom PropWff_lc : forall G0 phi,   PropWff G0 phi -> lc_constraint phi.
Axiom Iso_lc : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1 /\ lc_constraint p2.
Axiom DefEq_lc : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A /\ lc_tm B /\ lc_tm T.

Axiom Typing_lc1 : forall G0 a A, Typing G0 a A -> lc_tm a.
Axiom Typing_lc2 : forall G0 a A, Typing G0 a A -> lc_tm A.

Axiom Iso_lc1 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p1.
Axiom Iso_lc2 : forall G0 D p1 p2, Iso G0 D p1 p2 -> lc_constraint p2.

Axiom DefEq_lc1 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm A.
Axiom DefEq_lc2 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm B.
Axiom DefEq_lc3 : forall G0 D A B T,   DefEq G0 D A B T -> lc_tm T.

Axiom Ctx_lc : forall G0, Ctx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom Ctx_uniq : forall G, Ctx G -> uniq G.

Axiom Toplevel_lc : forall c s, binds c s toplevel -> lc_sig_sort s.

Axiom Path_lc : forall T a, Path T a -> lc_tm a.

Axiom DataTy_lc : forall A, DataTy A a_Star -> lc_tm A.

Axiom Value_lc : forall A, Value A -> lc_tm A.

Axiom CoercedValue_lc : forall A, CoercedValue A -> lc_tm A.

End ext_wf_sig.

Module Type ext_weak_sig.

Include ext_wf_sig.

Axiom weaken_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 -> forall D', D [<=] D' -> Iso G1 D' p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T -> forall D', D [<=] D' -> DefEq G1 D' A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom respects_atoms_eq_mutual :
  (forall G a A,     Typing  G a A       -> True) /\
  (forall G phi,     PropWff G phi       -> True) /\
  (forall G D p1 p2, Iso G D p1 p2 -> forall D', D [=] D' -> Iso G D' p1 p2) /\
  (forall G D A B T,   DefEq G D A B T  -> forall D', D [=] D' -> DefEq G D' A B T) /\
  (forall G,           Ctx G           -> True).

Axiom remove_available_mutual:
  (forall G1  a A,   Typing G1 a A -> True) /\
  (forall G1  phi,   PropWff G1 phi -> True) /\
  (forall G1 D p1 p2, Iso G1 D p1 p2 ->
                   Iso G1 (AtomSetImpl.inter D (dom G1)) p1 p2) /\
  (forall G1 D A B T,   DefEq G1 D A B T ->
                   DefEq G1 (AtomSetImpl.inter D (dom G1)) A B T) /\
  (forall G1 ,       Ctx G1 -> True).

Axiom DefEq_weaken_available :
  forall G D A B T, DefEq G D A B T -> DefEq G (dom G) A B T.

Axiom Iso_weaken_available :
  forall G D A B, Iso G D A B -> Iso G (dom G) A B.

Axiom typing_weakening_mutual:
  (forall G0 a A,   Typing G0 a A ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Typing (F ++ E ++ G) a A) /\
  (forall G0 phi,   PropWff G0 phi ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> PropWff (F ++ E ++ G) phi) /\
  (forall G0 D p1 p2, Iso G0 D p1 p2 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Iso (F ++ E ++ G) D p1 p2) /\
  (forall G0 D A B T,   DefEq G0 D A B T ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> DefEq (F ++ E ++ G) D A B T) /\
  (forall G0,       Ctx G0 ->
     forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) -> Ctx (F ++ E ++ G)).

Definition Typing_weakening  := first  typing_weakening_mutual.
Definition PropWff_weakening := second typing_weakening_mutual.
Definition Iso_weakening     := third  typing_weakening_mutual.
Definition DefEq_weakening   := fourth typing_weakening_mutual.

End ext_weak_sig.

Module Type ext_subst_sig.
Include ext_weak_sig.

Axiom Ctx_strengthen : forall G1 G2, Ctx (G2 ++ G1) -> Ctx G1.

Axiom binds_to_PropWff: forall G0 A B T c,
    Ctx G0 ->
    binds c (Co (Eq A B T)) G0 -> PropWff G0 (Eq A B T).

Axiom tm_subst_tm_tm_dom_invariance: forall x a F,
    dom F = dom (map (tm_subst_tm_sort a x) F).

Axiom tm_subst_fresh_1 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Axiom tm_subst_fresh_2 :
forall G a A a0 x s,
  Typing G a A -> Ctx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Axiom tm_subst_co_fresh_1 :
forall G a A a0 c s,
  Typing G a A -> Ctx ((c ~ s) ++ G) -> co_subst_co_tm a0 c A = A.

Axiom tm_substitution_mutual :  (forall G0 b B (H : Typing G0 b B),
      forall G a A, Typing G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      Typing (map (tm_subst_tm_sort a x) F ++ G)
                             (tm_subst_tm_tm a x b)
                             (tm_subst_tm_tm a x B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        PropWff (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_constraint a x phi)) /\
    (forall G0 D p1 p2 (H : Iso G0 D p1 p2),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                Iso (map (tm_subst_tm_sort a x) F ++ G) D
                    (tm_subst_tm_constraint a x p1)
                    (tm_subst_tm_constraint a x p2)) /\
    (forall G0 D A B T (H : DefEq G0 D A B T),
       forall G a A0, Typing G a A0 ->
                 forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                        DefEq (map (tm_subst_tm_sort a x) F ++ G) D
                              (tm_subst_tm_tm a x A)
                              (tm_subst_tm_tm a x B) (tm_subst_tm_tm a x T)) /\
    (forall G0 (H : Ctx G0),
        forall G a A, Typing G a A ->
                 forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                        Ctx (map (tm_subst_tm_sort a x) F ++ G)).

Axiom Typing_tm_subst : forall G x A b B (H : Typing ((x ~ Tm A) ++ G) b B),
  forall a, Typing G a A ->
       Typing G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Axiom co_substitution_mutual :
    (forall G0 b B (H : Typing G0 b B),
        forall G D A1 A2 T F c ,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Typing (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B)) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall G D A1 A2 T F c,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> PropWff (map (co_subst_co_sort g_Triv c) F ++ G) (co_subst_co_constraint g_Triv c phi)) /\
    (forall G0 D0 p1 p2 (H : Iso G0 D0 p1 p2),
          forall G D A1 A2 T F c,
            G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
            -> DefEq G D A1 A2 T
            -> Iso (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                    (co_subst_co_constraint g_Triv c p1)
                    (co_subst_co_constraint g_Triv c p2)) /\
    (forall G0 D0 A B T (H : DefEq G0 D0 A B T),
        forall G D F c A1 A2 T1,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T1) ) ++ G)
          -> DefEq G D A1 A2 T1
          -> DefEq (map (co_subst_co_sort g_Triv c) F ++ G) (union D (remove c D0))
                  (co_subst_co_tm g_Triv c A) (co_subst_co_tm g_Triv c B)
                  (co_subst_co_tm g_Triv c T)) /\
    (forall G0 (H : Ctx G0),
        forall G D F c A1 A2 T,
          G0 = (F ++ (c ~ Co (Eq A1 A2 T) ) ++ G)
          -> DefEq G D A1 A2 T
          -> Ctx (map (co_subst_co_sort g_Triv c) F ++ G)).

Axiom Typing_co_subst:
   forall G D c a1 a2 A b B (H : Typing (c ~ (Co (Eq a1 a2 A)) ++ G) b B),
     DefEq G D a1 a2 A ->
     Typing G (co_subst_co_tm g_Triv c b) (co_subst_co_tm g_Triv c B).

Axiom Typing_swap : forall x1 x G a A B,
      x1 `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> x `notin` dom G \u {{ x1 }}
    -> Typing ([(x1, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x1))
             (open_tm_wrt_tm B (a_Var_f x1))
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x))
             (open_tm_wrt_tm B (a_Var_f x)).

Axiom E_Pi_exists : forall x (G : context) (rho : relflag) (A B : tm),
      x `notin` dom G \u fv_tm_tm_tm B
      -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star
      -> Typing G A a_Star -> Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs_exists :  forall x (G : context) (rho : relflag) (a A B : tm),
    x `notin` fv_tm_tm_tm a \u fv_tm_tm_tm B
    -> Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x))
    -> Typing G A a_Star
    -> RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
    -> Typing G (a_UAbs rho a) (a_Pi rho A B).

End ext_subst_sig.

Module Type ext_invert_sig.
  Include ext_subst_sig.

Axiom binds_to_Typing: forall G T A, Ctx G -> binds T (Tm A) G -> Typing G A a_Star.

Axiom invert_a_Const : forall G T A,
    Typing G (a_Const T) A ->
    exists B, DataTy B a_Star /\ DefEq G (dom G) A B  a_Star
         /\ binds T (Cs B) toplevel.

Axiom invert_a_Pi: forall G rho A0 A B0,
    Typing G (a_Pi rho A0 B0) A ->
    DefEq G (dom G) A a_Star a_Star /\ (exists L, forall x, x `notin` L -> Typing ([(x, Tm A0)] ++ G) (open_tm_wrt_tm B0 (a_Var_f x)) a_Star) /\ Typing G A0 a_Star.

Axiom invert_a_CPi: forall G phi A B0,
    Typing G (a_CPi phi B0) A ->
      DefEq G (dom G) A a_Star a_Star /\ (exists L, forall c, c `notin` L -> Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B0 (g_Var_f c) ) a_Star) /\ PropWff G phi.

Axiom invert_a_App_Rel : forall G a b C,
    Typing G (a_App a Rel b) C ->
    exists A B, Typing G a (a_Pi Rel A B) /\
           Typing G b A /\
           DefEq G (dom G) C (open_tm_wrt_tm B b) a_Star.

Axiom invert_a_App_Irrel : forall G a b C,
    Typing G (a_App a Irrel b) C ->
    exists A B b0, Typing G a (a_Pi Irrel A B) /\
              Typing G b0 A /\
              DefEq G (dom G) C (open_tm_wrt_tm B b0) a_Star.

Axiom invert_a_CApp : forall G a g A,
    Typing G (a_CApp a g) A ->
    g = g_Triv /\
    exists a1 b1 A1 B, Typing G a (a_CPi (Eq a1 b1 A1) B) /\
             DefEq G (dom G) a1 b1 A1 /\
             DefEq G (dom G) A (open_tm_wrt_co B g_Triv) a_Star.

Axiom invert_a_UAbs:
  forall G rho A b0,
    Typing G (a_UAbs rho b0) A
    -> exists A1 B1, DefEq G (dom G) A (a_Pi rho A1 B1) a_Star
               /\ (exists L, forall x, x `notin` L ->
                            Typing ([(x, Tm A1)] ++ G)
                                   (open_tm_wrt_tm b0 (a_Var_f x))
                                   (open_tm_wrt_tm B1 (a_Var_f x))
                            /\ Typing ([(x, Tm A1)] ++ G)
                                     (open_tm_wrt_tm B1 (a_Var_f x)) a_Star
                            /\ RhoCheck rho x (open_tm_wrt_tm b0 (a_Var_f x)))
               /\ Typing G A1 a_Star.

Axiom invert_a_UCAbs: forall G A b0,
    Typing G (a_UCAbs b0) A ->
    exists a b T B1, PropWff G (Eq a b T)
                /\ DefEq G (dom G) A (a_CPi (Eq a b T) B1) a_Star /\
                (exists L, forall c, c `notin` L ->
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co b0 (g_Var_f c))
                                  (open_tm_wrt_co B1 (g_Var_f c)) /\
                           Typing ([(c, Co (Eq a b T))] ++ G)
                                  (open_tm_wrt_co B1 (g_Var_f c)) a_Star).

Axiom invert_a_Var :
  forall G x A, Typing G (a_Var_f x) A -> exists A', binds x (Tm A') G /\ DefEq G (dom G) A A' a_Star.

Axiom invert_a_Star: forall A G, Typing G a_Star A -> DefEq G (dom G) A a_Star a_Star.

Axiom invert_a_Fam : forall G F A,
    Typing G (a_Fam F) A ->
    exists a B, DefEq G (dom G) A B a_Star /\
           binds F (Ax a B) toplevel /\ Typing nil B a_Star.

Inductive context_DefEq : available_props -> context -> context -> Prop :=
| Nul_Eqcontext: forall D, context_DefEq D nil nil
| Factor_Eqcontext_tm: forall G1 G2 D A A' x,
    context_DefEq D G1 G2 ->
    DefEq G1 D A A' a_Star ->
    DefEq G2 D A A' a_Star ->
    context_DefEq D ([(x, Tm A)] ++ G1) ([(x, Tm A')] ++ G2)
| Factor_Eqcontext_co: forall D G1 G2 Phi1 Phi2 c,
    context_DefEq D G1 G2 ->
    Iso G1 D Phi1 Phi2 ->
    Iso G2 D Phi1 Phi2 ->
    context_DefEq D ([(c, Co Phi1)] ++ G1) ([(c, Co Phi2)] ++ G2).

Axiom refl_context_defeq: forall G D, Ctx G -> context_DefEq D G G.

Axiom context_DefEq_weaken_available :
  forall D G1 G2, context_DefEq D G1 G2 -> context_DefEq (dom G1) G1 G2.

Axiom context_DefEq_typing:
  (forall G1  a A, Typing G1 a A -> forall D G2, Ctx G2 -> context_DefEq D G1 G2 -> Typing G2 a A).

Axiom Typing_regularity: forall e A G, Typing G e A -> Typing G A a_Star.

Axiom DefEq_regularity :
  forall G D A B T, DefEq G D A B T -> PropWff G (Eq A B T).

Axiom Iso_regularity :
  forall G D phi1 phi2, Iso G D phi1 phi2 -> PropWff G phi1 /\ PropWff G phi2.

Axiom PropWff_regularity :
  forall G A B T, PropWff G (Eq A B T) ->  Typing G A T /\ Typing  G B T.

Axiom DefEq_conv : forall G D a b A B, DefEq G D a b A -> DefEq G (dom G) A B a_Star -> DefEq G D a b B.

Axiom refl_iso: forall G D phi, PropWff G phi -> Iso G D phi phi.

Axiom sym_iso: forall G D phi1 phi2, Iso G D phi1 phi2 -> Iso G D phi2 phi1.

Axiom trans_iso : forall G D phi1 phi2 phi3, Iso G D phi1 phi2 -> Iso G D phi2 phi3 -> Iso G D phi1 phi3.

Axiom iso_cong : forall G D A A' B B' T T', DefEq G D A A' T -> DefEq G D B B' T -> DefEq G D T T' a_Star ->
                     Iso G D (Eq A B T) (Eq A' B' T').

Axiom E_PiCong2 :  ∀ (L : atoms) (G : context) (D : available_props) rho (A1 B1 A2 B2 : tm),
    DefEq G D A1 A2 a_Star
    → (∀ x : atom,
          x `notin` L
          → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm B1 (a_Var_f x))
                  (open_tm_wrt_tm B2 (a_Var_f x)) a_Star)
    → DefEq G D (a_Pi rho A1 B1) (a_Pi rho A2 B2) a_Star.

Axiom E_CPiCong2  : ∀ (L : atoms) (G : context) (D : available_props) (phi1 : constraint)
                      (A : tm) (phi2 : constraint) (B : tm),
    Iso G D phi1 phi2
    → (∀ c : atom,
          c `notin` L
              → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co A (g_Var_f c))
                      (open_tm_wrt_co B (g_Var_f c)) a_Star)
    → DefEq G D (a_CPi phi1 A) (a_CPi phi2 B) a_Star.

Axiom E_Pi2 : forall L G rho A B,
    (∀ x : atom, x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star) ->
    Typing G (a_Pi rho A B) a_Star.

Axiom E_Abs2 : ∀ (L : atoms) (G : context) (rho : relflag) (a A B : tm),
    (∀ x : atom,
        x `notin` L → Typing ([(x, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f x)) (open_tm_wrt_tm B (a_Var_f x)))
    → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)))
    → Typing G (a_UAbs rho a) (a_Pi rho A B).

Axiom E_Conv2 : ∀ (G : context) (a B A : tm),
    Typing G a A → DefEq G (dom G) A B a_Star →
    Typing G a B.

Axiom E_CPi2 :  ∀ (L : atoms) (G : context) (phi : constraint) (B : tm),
    (∀ c : atom, c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star) ->
    Typing G (a_CPi phi B) a_Star.

Axiom E_CAbs2 : ∀ (L : atoms) (G : context) (a : tm) (phi : constraint) (B : tm),
       (∀ c : atom,
        c `notin` L → Typing ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co B (g_Var_f c)))
       → Typing G (a_UCAbs a) (a_CPi phi B).

Axiom E_AbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (rho : relflag) (b1 b2 A1 B : tm),
       (∀ x : atom,
        x `notin` L
        → DefEq ([(x, Tm A1)] ++ G) D (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x))
            (open_tm_wrt_tm B (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b1 (a_Var_f x)))
       → (∀ x : atom, x `notin` L → RhoCheck rho x (open_tm_wrt_tm b2 (a_Var_f x)))
       → DefEq G D (a_UAbs rho b1) (a_UAbs rho b2) (a_Pi rho A1 B).

Axiom E_CAbsCong2
     : ∀ (L : atoms) (G : context) (D : available_props) (a b : tm) (phi1 : constraint)
       (B : tm),
       (∀ c : atom,
        c `notin` L
        → DefEq ([(c, Co phi1)] ++ G) D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co b (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))) → DefEq G D (a_UCAbs a) (a_UCAbs b) (a_CPi phi1 B).

End ext_invert_sig.

Module Type fc_wf_sig.

Axiom AnnTyping_AnnCtx  : forall G0 a A, AnnTyping G0 a A -> AnnCtx G0.
Axiom AnnPropWff_AnnCtx : forall G0 phi, AnnPropWff G0 phi -> AnnCtx G0.
Axiom AnnIso_AnnCtx     : forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> AnnCtx G0.
Axiom AnnDefEq_AnnCtx   : forall G0 D g A B,   AnnDefEq G0 D g A B -> AnnCtx G0.

Axiom AnnCtx_uniq : forall G, AnnCtx G -> uniq G.

Axiom AnnTyping_lc  :  forall G0 a A, AnnTyping G0 a A -> lc_tm a /\ lc_tm A.
Axiom AnnPropWff_lc : forall G0 phi, AnnPropWff G0 phi -> lc_constraint phi.
Axiom AnnIso_lc :  forall G0 D g p1 p2, AnnIso G0 D g p1 p2 -> lc_constraint p1 /\ lc_constraint p2 /\ lc_co g.
Axiom AnnDefEq_lc : forall G0 D g A B,  AnnDefEq G0 D g A B -> lc_tm A /\ lc_tm B /\ lc_co g.
Axiom AnnCtx_lc : forall G0, AnnCtx G0 -> forall x s , binds x s G0 -> lc_sort s.

Axiom AnnTyping_lc1 : forall G a A, AnnTyping G a A -> lc_tm a.
Axiom AnnTyping_lc2 : forall G a A, AnnTyping G a A -> lc_tm A.
Axiom AnnIso_lc1 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p1.
Axiom AnnIso_lc2 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_constraint p2.
Axiom AnnIso_lc3 : forall G D g p1 p2, AnnIso G D g p1 p2 -> lc_co g.
Axiom AnnDefEq_lc1 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm A.
Axiom AnnDefEq_lc2 : forall G D g A B,  AnnDefEq G D g A B -> lc_tm B.
Axiom AnnDefEq_lc3 : forall G D g A B,  AnnDefEq G D g A B -> lc_co g.

Axiom AnnToplevel_lc : forall c s, binds c s an_toplevel -> lc_sig_sort s.

End fc_wf_sig.

Module Type fc_weak_sig.

Axiom ann_respects_atoms_eq_mutual :
  (forall G a A,       AnnTyping  G a A       -> True) /\
  (forall G phi,       AnnPropWff G phi       -> True) /\
  (forall G D g p1 p2, AnnIso     G D g p1 p2 -> forall D', D [=] D' -> AnnIso   G D' g p1 p2) /\
  (forall G D g A B,   AnnDefEq   G D g A B   -> forall D', D [=] D' -> AnnDefEq G D' g A B) /\
  (forall G,           AnnCtx     G           -> True).

Definition AnnIso_respects_atoms_eq   := third  ann_respects_atoms_eq_mutual.
Definition AnnDefEq_respects_atoms_eq := fourth ann_respects_atoms_eq_mutual.

Axiom ann_strengthen_noncovar:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall x, not (exists phi, binds x (Co phi) G1) ->
                     AnnIso G1 (remove x D) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->  forall x, not (exists phi, binds x (Co phi) G1) ->
                    AnnDefEq G1 (remove x D) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_strengthen_available_tm :
  forall G D g A B, AnnDefEq G D g A B ->  forall x A', binds x (Tm A') G ->
                    forall D', D' [=] remove x D ->
                    AnnDefEq G D' g A B.

Axiom ann_weaken_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 -> forall D', D [<=] D' -> AnnIso G1 D' g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B -> forall D', D [<=] D' -> AnnDefEq G1 D' g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom ann_remove_available_mutual:
  (forall G1  a A,   AnnTyping G1 a A -> True) /\
  (forall G1  phi,   AnnPropWff G1 phi -> True) /\
  (forall G1 D g p1 p2, AnnIso G1 D g p1 p2 ->
                   AnnIso G1 (AtomSetImpl.inter D (dom G1)) g p1 p2) /\
  (forall G1 D g A B,   AnnDefEq G1 D g A B ->
                   AnnDefEq G1 (AtomSetImpl.inter D (dom G1)) g A B) /\
  (forall G1 ,       AnnCtx G1 -> True).

Axiom AnnDefEq_weaken_available :
  forall G D g A B, AnnDefEq G D g A B -> AnnDefEq G (dom G) g A B.

Axiom AnnIso_weaken_available :
  forall G D g A B, AnnIso G D g A B -> AnnIso G (dom G) g A B.

Axiom ann_typing_weakening_mutual:
  (forall G0 a A,       AnnTyping  G0 a A       ->
     forall E F G, (G0 = F ++ G) -> AnnCtx (F ++ E ++ G) -> AnnTyping (F ++ E ++ G) a A) /\
  (forall G0 phi,       AnnPropWff G0 phi       ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnPropWff (F ++ E ++ G) phi) /\
  (forall G0 D g p1 p2, AnnIso     G0 D g p1 p2 ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnIso (F ++ E ++ G) D g p1 p2) /\
  (forall G0 D g A B,   AnnDefEq   G0 D g A B   ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnDefEq (F ++ E ++ G) D g A B) /\
  (forall G0,           AnnCtx     G0           ->
     forall E F G, (G0 = F ++ G) ->
        AnnCtx (F ++ E ++ G) -> AnnCtx (F ++ E ++ G)).

Definition AnnTyping_weakening  := first  ann_typing_weakening_mutual.
Definition AnnPropWff_weakening := second ann_typing_weakening_mutual.
Definition AnnIso_weakening     := third  ann_typing_weakening_mutual.
Definition AnnDefEq_weakening   := fourth ann_typing_weakening_mutual.
Definition AnnCtx_weakening     := fifth  ann_typing_weakening_mutual.

End fc_weak_sig.

Module Type fc_subst_sig.

  Axiom AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

  Axiom binds_to_AnnTyping :
    forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

  Axiom binds_to_AnnPropWff: forall G0 a b A c,
      AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  Axiom tm_subst_fresh_1 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

  Axiom tm_subst_fresh_2 :
  forall G a A a0 x s,
    AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

  Axiom ann_tm_substitution_mutual :
  (forall G0 b B (H : AnnTyping G0 b B),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)
                                (tm_subst_tm_tm a x b)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 phi (H : AnnPropWff G0 phi),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)
                                 (tm_subst_tm_constraint a x phi)) /\
  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),
      forall G a A, AnnTyping G a A ->
               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)
                             D
                             (tm_subst_tm_co a x g)
                             (tm_subst_tm_constraint a x p1)
                             (tm_subst_tm_constraint a x p2)) /\
  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),
      forall G a A0, AnnTyping G a A0 ->
                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->
                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)
                                D
                                (tm_subst_tm_co a x g)
                                (tm_subst_tm_tm a x A)
                                (tm_subst_tm_tm a x B)) /\
  (forall G0 (H : AnnCtx G0),
  forall G a A, AnnTyping G a A ->
  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->
                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).

  Axiom AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),
    forall a, AnnTyping G a A ->
         AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

  Axiom AnnTyping_tm_subst_nondep : forall L G a A b B,
      AnnTyping G a A ->
      (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_tm b a) B.

  Axiom AnnTyping_co_subst : forall G x A1 A2 A3 b B
                               (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),
    forall D a, AnnDefEq G D a A1 A2 ->
         AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

  Axiom AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,
      AnnDefEq G D g A1 A2 ->
      (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->
      AnnTyping G (open_tm_wrt_co b g) B.

  Axiom An_Pi_exists : forall x G rho A B,
      x `notin` dom G \u fv_tm_tm_tm B
    → AnnTyping ([(x, Tm A)] ++ G)
                (open_tm_wrt_tm B (a_Var_f x)) a_Star
    → AnnTyping G A a_Star
    → AnnTyping G (a_Pi rho A B) a_Star.

  Axiom An_Abs_exists :   forall x (G:context) rho (A a B:tm),
       x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->
       AnnTyping G A a_Star ->
       AnnTyping  (( x ~ Tm  A) ++ G) (open_tm_wrt_tm a (a_Var_f x))
                  (open_tm_wrt_tm B (a_Var_f x))  ->
       RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
        AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

  Axiom An_CPi_exists :  ∀ c (G : context) (phi : constraint) (B : tm),
          c \notin dom G \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star
         → AnnTyping G (a_CPi phi B) a_Star.

  Axiom An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),
      c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B ->
         AnnPropWff G phi
         → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                (open_tm_wrt_co B (g_Var_f c))
         → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

  Axiom An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),
    AnnTyping G (a_CAbs phi a) A ->
      exists B, A = (a_CPi phi B) /\
      forall c, c  `notin` dom G  ->
        AnnPropWff G phi /\
        AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
                  (open_tm_wrt_co B (g_Var_f c)).

  Axiom An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
                  (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))
      → (open_tm_wrt_tm b3 (a_Var_f x2) =
         open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G A1 a_Star
      → AnnTyping G A2 a_Star
      → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))
      → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))
      → AnnTyping G (a_Abs rho A1 b2) B
      → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

  Axiom An_AbsCong_inversion :
    forall G D rho g1 g2 B1 B2,
      AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->
    exists A1 A2 b1 b2 b3 B,
      B1 = (a_Abs rho A1 b1) /\
      B2 = (a_Abs rho A2 b3) /\
      AnnTyping G A1 a_Star  /\
      AnnTyping G A2 a_Star  /\
      AnnDefEq G D g1 A1 A2  /\
      AnnTyping G (a_Abs rho A1 b2) B /\
      (forall x, x \notin dom G   ->
          AnnDefEq  (( x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm b1 (a_Var_f x))  ((open_tm_wrt_tm b2 (a_Var_f x))) /\
          (open_tm_wrt_tm b3 (a_Var_f x)) = (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\
          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

  Axiom An_CPiCong_exists : ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)
       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    → (open_tm_wrt_co B3 (g_Var_f c2) =
       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CPi phi1 B1) a_Star
    → AnnTyping G (a_CPi phi2 B3) a_Star
    -> AnnTyping G (a_CPi phi1 B2) a_Star
    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)
               (a_CPi phi2 B3).

  Axiom An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co) (A1 A2 : tm),
    AnnDefEq G D (g_CPiCong g1 g3) A1 A2 ->
      exists phi1 phi2 B1 B2 B3,
        A1 = (a_CPi phi1 B1) /\
        A2 = (a_CPi phi2 B3) /\
        AnnIso G D g1 phi1 phi2 /\
        AnnTyping G (a_CPi phi1 B1) a_Star /\
        AnnTyping G (a_CPi phi2 B3) a_Star /\
        AnnTyping G (a_CPi phi1 B2) a_Star /\
        (forall c, c `notin` dom G  →
          (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
          (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\
          (open_tm_wrt_co B3 (g_Var_f c) = open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

  Axiom An_PiCong_exists : forall x1 x2 (G:context) D rho
                             (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),
      x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)
      -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)
      ->  AnnDefEq G D g1 A1 A2
      → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))
                 (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))
      → (open_tm_wrt_tm B3 (a_Var_f x2) =
         open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))
      → AnnTyping G (a_Pi rho A1 B1) a_Star
      → AnnTyping G (a_Pi rho A2 B3) a_Star
      → AnnTyping G (a_Pi rho A1 B2) a_Star
      → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

  Axiom An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),
    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2 ->
      exists A1 B1 A2 B2 B3,
      C1 = (a_Pi rho A1 B1) /\
      C2 = (a_Pi rho A2 B3) /\
      AnnTyping G (a_Pi rho A1 B1) a_Star /\
      AnnTyping G (a_Pi rho A2 B3) a_Star /\
      AnnTyping G (a_Pi rho A1 B2) a_Star /\
      AnnDefEq G D g1 A1 A2 /\
      (forall x , x \notin dom G  ->
            AnnDefEq  ((x ~ Tm  A1) ++ G) D (open_co_wrt_tm g2 (a_Var_f x)) (open_tm_wrt_tm B1 (a_Var_f x)) ((open_tm_wrt_tm B2 (a_Var_f x)))  /\
            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2 (a_Conv (a_Var_f x) (g_Sym g1))))).

  Axiom An_CAbsCong_exists :
  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)
    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B: tm),
    AnnIso G D g1 phi1 phi2
    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3
    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))
    → (open_tm_wrt_co a3 (g_Var_f c2) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))
    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)
    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)
    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)
    -> AnnTyping G (a_CAbs phi1 a2) B
    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

  Axiom An_CAbsCong_inversion :
  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,
    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2
    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,
      A1 = (a_CAbs phi1 a1) /\
      A2 = (a_CAbs phi2 a3) /\
      AnnIso G D g1 phi1 phi2 /\
      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\
      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\
      AnnTyping G (a_CAbs phi1 a2) B /\
      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\
 forall c1,
      c1`notin` dom G 
    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\
      (open_tm_wrt_co a3 (g_Var_f c1) =
       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

  Axiom An_Pi_inversion :
    ∀ (G:context) rho A B T,
      AnnTyping G (a_Pi rho A B) T ->
      T = a_Star /\
      AnnTyping G A a_Star /\
      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

  Axiom An_Abs_inversion :
    ∀ (G:context) rho (a:tm) A A1,
    AnnTyping G (a_Abs rho A a) A1 ->
    (exists B, A1 = a_Pi rho A B /\
    AnnTyping G A a_Star /\
    ∀ x, x \notin dom G ->
      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\
      AnnTyping (( x ~ Tm  A) ++ G)
                (open_tm_wrt_tm a (a_Var_f x))
                (open_tm_wrt_tm B (a_Var_f x))).

  Axiom An_CPi_inversion :
    ∀ (G:context) (phi : constraint) (B T : tm),
      AnnTyping G (a_CPi phi B) T ->
      T = a_Star /\
      AnnPropWff G phi /\
      ∀ c, c \notin dom G -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

  Axiom AnnTyping_tm_swap : forall c c0 B G a A,
    c `notin` fv_tm_tm_tm A ->
    c `notin` fv_tm_tm_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))
         (open_tm_wrt_tm A (a_Var_f c)) ->
    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))
                  (open_tm_wrt_tm A (a_Var_f c0)).

  Axiom AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,
   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2
  -> x `notin` dom G \u {{ x1 }}
  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))
             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))
  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))
             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

 Axiom AnnTyping_co_swap : forall c c0 phi G a A,
    c `notin` fv_co_co_tm A ->
    c `notin` fv_co_co_tm a ->
    c0 `notin` dom G \u {{ c }} ->
    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))
         (open_tm_wrt_co A (g_Var_f c)) ->
    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))
                  (open_tm_wrt_co A (g_Var_f c0)).

  Axiom AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,
    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->
    c `notin` dom G \u {{ c1 }} ->
    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))
              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))
    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))
              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

  Create HintDb smart_cons_exists discriminated.
  Hint Resolve An_Pi_exists An_Abs_exists An_CPi_exists An_CAbs_exists An_AbsCong_exists An_CPiCong_exists An_CAbsCong_exists : smart_cons_exists.

End fc_subst_sig.

Module Type fc_unique_sig.

Axiom AnnTyping_unique :
    forall G a A1, AnnTyping G a A1 -> forall {A2}, AnnTyping G a A2 -> A1 = A2.
Axiom AnnIso_unique  :
  forall G D g p1 p2, AnnIso G D g p1 p2 ->
                 forall {q1 q2}, AnnIso G D g q1 q2 -> p1 = q1 /\ p2 = q2.
Axiom AnnDefEq_unique    :
  forall G D g a b,
      AnnDefEq G D g a b -> forall {a1 b1}, AnnDefEq G D g a1 b1 -> a = a1 /\ b = b1.

End fc_unique_sig. *)



Require Import FcEtt.tactics.
(* FcEtt.tactics:
Require Import FcEtt.imports.

Require Import FcEtt.ett_inf.

Inductive Dyn : Type := dyn : forall {T : Type}, T -> Dyn.

Ltac unwrap_dyn d :=
  match d with
    | dyn ?v => v
  end.

Ltac split_hyp :=
  repeat (
      match goal with
        | [ H : _ /\ _ |- _ ] => destruct H
      end).

Ltac rewrite_and_clear eq :=
  first [rewrite -> eq | rewrite <- eq]; clear eq.

Ltac try_rewrite_and_clear eq :=
  first [rewrite -> ! eq | rewrite <- ! eq | idtac]; clear eq.

Ltac try_rewrite_and_clear_f eq :=
  first [rewrite ! eq | idtac]; clear eq.

Ltac find_eq_rew_clear :=
  match goal with
    | [ eq : forall t1,                _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2,             _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3,          _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4,       _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5,    _ = _ |- _ ] => rewrite_and_clear eq
    | [ eq : forall t1 t2 t3 t4 t5 t6, _ = _ |- _ ] => rewrite_and_clear eq
  end.

Ltac subst_forall :=
  repeat find_eq_rew_clear.

Tactic Notation "basic_nosolve_n"     int_or_var(n) :=
  intuition (subst; eauto n).
Tactic Notation "basic_nosolve_n'"    int_or_var(n) :=
  intuition (subst; simpl in *; subst; eauto n; try done).
Tactic Notation "basic_nosolve_fo_n"  int_or_var(n) :=
  firstorder (subst; eauto n).
Tactic Notation "basic_nosolve_fo_n'" int_or_var(n) :=
  firstorder (subst_forall; simpl in *; subst_forall; eauto n; try done).

Tactic Notation "basic_solve_n"     int_or_var(n) := try solve [basic_nosolve_n     n].
Tactic Notation "basic_solve_n'"    int_or_var(n) := try solve [basic_nosolve_n'    n].
Tactic Notation "basic_solve_fo_n"  int_or_var(n) := try solve [basic_nosolve_fo_n  n].
Tactic Notation "basic_solve_fo_n'" int_or_var(n) := try solve [basic_nosolve_fo_n' n].

Ltac basic_nosolve     := basic_nosolve_n     5.
Ltac basic_nosolve'    := basic_nosolve_n'    5.
Ltac basic_nosolve_fo  := basic_nosolve_fo_n  5.
Ltac basic_nosolve_fo' := basic_nosolve_fo_n' 5.

Ltac basic_solve     := try solve [basic_nosolve].
Ltac basic_solve'    := try solve [basic_nosolve'].
Ltac basic_solve_fo  := try solve [basic_nosolve_fo].
Ltac basic_solve_fo' := try solve [basic_nosolve_fo'].

Ltac solve_by_inv_hyp_about A :=
  multimatch goal with
    | [ H : context [?A] |- _ ] => solve [inversion H; basic_solve]
  end.

Ltac revert_all :=
  repeat match goal with
      | [ H : _ |- _ ] => revert H
    end.

Ltac revert_all_with t :=
  repeat match goal with
      | [ H : _ |- _ ] => try t H; revert dependent H
    end.

Ltac intro_all_with t :=
  repeat
    (let x := fresh in intro x; try (t x)).

Ltac disjunction_assumption :=
  match goal with
    | [H : ?P |- ?P]     => exact H
    | [H : ?P |- ?P ∨ _] => left; exact H
    | [       |- _  ∨ _] => right; disjunction_assumption
  end.

Ltac invert_and_clear H := inversion H; clear H.

Definition wrap : forall P : Prop, P -> P * True := fun _ p => (p, I).
Ltac wrap_hyp H := apply wrap in H.

Lemma AnnCtx_uniq G : AnnCtx G -> uniq G.

Ltac prove_this stmt name :=

  match stmt with
    | uniq ?G =>
      match goal with
      | [ HG : AnnCtx G |- _ ] =>
        
        move: (AnnCtx_uniq HG) => name 
      end
    end.

Ltac find_invertible_hyps :=
  repeat (
  match goal with
    
    | [ H : AnnIso _ _ (g_EqCong _ _ _) _ _ |- _ ] => invert_and_clear H
    
    | [ H : AnnIso _ _ (_ _) _ _ |- _ ] => inversion H; wrap_hyp H

    | [ H : AnnTyping _ (_ _) _ |- _ ] => inversion H; wrap_hyp H

  end).

Ltac pair_coupled_hyps :=
  repeat match goal with
    | [ H1 : binds ?T _ ?G, H2 : binds ?T _ ?G |- _ ] =>
      let unG := fresh "uniq" G in
      prove_this (uniq G) unG;
      move: (binds_unique _ _ _ _ _ H1 H2 unG) => ?; wrap_hyp H2

  end.

Ltac pcess_hyps :=
  find_invertible_hyps;

  pair_coupled_hyps;

  repeat (
    match goal with
      | [ H : _ /\ _       |- _ ] => destruct H

      | [ H : exists x, _  |- _ ] => destruct H

      | [ H : _ * True  |- _      ] => destruct H as [H _]

      | [ H :                   ?A = ?A |- _ ] => clear H
      | [ H : forall _,         ?A = ?A |- _ ] => clear H
      | [ H : forall _ _,       ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _,     ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _,   ?A = ?A |- _ ] => clear H
      | [ H : forall _ _ _ _ _, ?A = ?A |- _ ] => clear H
      
      | [ H : ?P |- _ ] => clear H; let x := fresh in assert (x : P) by solve [assumption | trivial]; clear x

      | [ H : ?C _                         = ?C _                         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _                       = ?C _ _                       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _                     = ?C _ _ _                     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _                   = ?C _ _ _ _                   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _                 = ?C _ _ _ _ _                 |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   |- _ ] => injection H; clear H; intros; try subst
      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ |- _ ] => injection H; clear H; intros; try subst

    end).

Ltac pre :=
  repeat (intros; try split);
  
  unfold "~" in *.

Ltac pre' :=
  repeat (intros; try split);
  pcess_hyps;
  unfold "~" in *.

Ltac prove_eq_same_head :=
  solve [subst; reflexivity | f_equal; basic_solve].

Ltac break_union :=
  repeat match goal with
  
    | [ H : ~ ?x `in` union _ _ |- _ ] =>
        move: (notin_union_1 _ _ _ H) (notin_union_2 _ _ _ H) => ??; clear H
  end.

Ltac fsetdec_fast := solve [break_union; basic_solve_n 3].

Ltac autofresh_fixed x :=
   repeat match goal with
     | [ H : ∀ x' : atom, x' `notin` ?L -> _ |- _] =>
       let xL := fresh x L in
       (have xL : x `notin` L by first [fsetdec_fast | fsetdec]);
       specialize (H x xL);
       clear xL 
   end.

 Ltac autofresh :=
   let x := fresh "x" in
   pick fresh x;
   autofresh_fixed x.

Ltac autotype :=
  pcess_hyps;

  repeat match goal with
    | [ |- _ /\ _ ] => split

    | [ |- _ `in` _   ] => try fsetdec_fast; first [fsetdec | fail 2] 
    | [ |- ¬ _ `in` _ ] => try fsetdec_fast; first [fsetdec | fail 2]

    | [ |- _ [=] _  ] => first [fsetdec | fail 2]
    | [ |- _ [<=] _ ] => first [fsetdec | fail 2]

    | [ |- ?C _                         = ?C _                         ] => prove_eq_same_head
    | [ |- ?C _ _                       = ?C _ _                       ] => prove_eq_same_head
    | [ |- ?C _ _ _                     = ?C _ _ _                     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _                   = ?C _ _ _ _                   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _                 = ?C _ _ _ _ _                 ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   ] => prove_eq_same_head
    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ ] => prove_eq_same_head

    | _ => try done; basic_solve; fail 0

    | [ |- ex _ ] => eexists

    | [ |- AnnTyping _   (_ _) _   ] => econstructor; pcess_hyps
    | [ |- AnnDefEq  _ _ (_ _) _ _ ] => econstructor; pcess_hyps
    | [ |- AnnIso    _ _ (_ _) _ _ ] => econstructor; pcess_hyps
  end.

Ltac ok := autotype.
Ltac depind x := dependent induction x. *)



Require Export FcEtt.imports.

Require Export FcEtt.utils.



Require Export FcEtt.ett_inf.

Require Export FcEtt.ett_ind.

Require Export FcEtt.fset_facts.



Require Import FcEtt.erase_syntax.
(* FcEtt.erase_syntax:
Require Export FcEtt.ett_inf_cs.
Require Export FcEtt.ett_ind.

Require Import FcEtt.imports.
Require Import FcEtt.tactics.

Set Implicit Arguments.
Set Bullet Behavior "Strict Subproofs".

Lemma open_tm_erase_rec : forall a,
  (forall b k, open_tm_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_tm_wrt_tm_rec k a b)) /\
  (forall b k, open_brs_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_brs_wrt_tm_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, open_constraint_wrt_tm_rec k (erase a) (erase b) =
                 erase (open_constraint_wrt_tm_rec k a b)).

Lemma open_tm_erase_tm : forall a b,
  open_tm_wrt_tm (erase a) (erase b) =
                 erase (open_tm_wrt_tm a b).

Lemma open_co_erase_rec : forall a,
  (forall b k, (erase b) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k, (erase b) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k, (erase b) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm : forall a b,
  (erase b) = erase (open_tm_wrt_co b a).

Lemma open_co_erase2_rec : forall a,
  (forall b k g, (open_tm_wrt_co_rec k g (erase b)) =
                 erase (open_tm_wrt_co_rec k a b)) /\
  (forall b k g, (open_brs_wrt_co_rec k g (erase b)) =
                 erase (open_brs_wrt_co_rec k a b)) /\
  (forall g:co, True) /\
  (forall b k g, (open_constraint_wrt_co_rec k g (erase b)) =
                 erase (open_constraint_wrt_co_rec k a b)).

Lemma open_co_erase_tm2 : forall a b g,
  (open_tm_wrt_co (erase b) g) = erase (open_tm_wrt_co b a).

Corollary no_co_in_erased_tm : forall B g,
 open_tm_wrt_co (erase B) g = erase B.

Lemma close_tm_erase_all : ∀ x : tmvar,
  (∀ (a : tm)         k, close_tm_rec k x (erase a) = erase (close_tm_rec k x a)) /\
  (∀ (b : brs)        k, close_tm_rec k x (erase b) = erase (close_tm_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_tm_rec k x (erase c) = erase (close_tm_rec k x c)).

Lemma close_co_erase_all : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase (close_co_rec k x a)) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase (close_co_rec k x b)) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase (close_co_rec k x c)).

Definition close_tm_rec_erase_tm := fun x => proj1 (close_tm_erase_all x).
Definition close_co_rec_erase_tm := fun x => proj1 (close_co_erase_all x).

Lemma close_tm_erase_tm
     : ∀ (x : tmvar) (a : tm), close_tm x (erase a) = erase (close_tm x a).

Lemma close_co_erase_tm
  : ∀ (x : covar) (a : tm), close_co x (erase a) = erase (close_co x a).

Lemma close_co_erase_rec : ∀ x : covar,
  (∀ (a : tm)         k, close_co_rec k x (erase a) = erase a) /\
  (∀ (b : brs)        k, close_co_rec k x (erase b) = erase b) /\
  (∀ _ : co, True) /\
  (∀ (c : constraint) k, close_co_rec k x (erase c) = erase c).

Lemma close_co_erase_tm2 : forall x a, close_tm_wrt_co x (erase a) = erase a.

Lemma fv_tm_erase_tm : ∀ x (a : tm),
    x `notin` fv_tm a -> x `notin` fv_tm (erase a).

Lemma fv_co_erase_tm : ∀ x (a : tm),
    x `notin` fv_co a -> x `notin` fv_co (erase a).

Lemma subst_tm_erase : forall a x,
  (forall b, tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b)) /\
  (forall b, tm_subst_tm_brs (erase a) x (erase b) =
              erase (tm_subst_tm_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, tm_subst_tm_constraint (erase a) x (erase p) =
              erase (tm_subst_tm_constraint a x p)).

Lemma subst_co_erase : forall a x,
  (forall b, (erase b) =
              erase (co_subst_co_tm a x b)) /\
  (forall b, (erase b) =
              erase (co_subst_co_brs a x b)) /\
  (forall g:co, True) /\
  (forall p, (erase p) =
              erase (co_subst_co_constraint a x p)).

Lemma subst_tm_erase_tm:  forall a x b,
    tm_subst_tm_tm (erase a) x (erase b) =
              erase (tm_subst_tm_tm a x b).

Lemma subst_co_erase_tm : forall a x b,
    (erase b) =
    erase (co_subst_co_tm a x b).

Theorem erase_subst_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (tm_subst_tm_brs a x Bs1) =
                  erase_brs (tm_subst_tm_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (tm_subst_tm_constraint a x phi1) =
                  erase_constraint (tm_subst_tm_constraint a x phi2)).

Corollary erase_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (tm_subst_tm_constraint a x phi1) =
    erase_constraint (tm_subst_tm_constraint a x phi2).

Corollary erase_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (tm_subst_tm_tm a x A) = erase_tm (tm_subst_tm_tm a x B).

Corollary erase_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (tm_subst_tm_brs a x Bs1) = erase_brs (tm_subst_tm_brs a x Bs2).

Theorem erase_co_subst_co_mutual a x :
  (∀ A B,       erase_tm A = erase_tm B ->
                  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B))
  ∧
  (∀ Bs1 Bs2,   erase_brs Bs1 = erase_brs Bs2 ->
                  erase_brs (co_subst_co_brs a x Bs1) =
                  erase_brs (co_subst_co_brs a x Bs2))
  ∧
  (∀ g1 g2 : co, True)
  ∧
  (∀ phi1 phi2, erase_constraint phi1 = erase_constraint phi2 ->
                  erase_constraint (co_subst_co_constraint a x phi1) =
                  erase_constraint (co_subst_co_constraint a x phi2)).

Corollary erase_co_subst_constraint phi1 phi2 a x :
  erase_constraint phi1 = erase_constraint phi2 ->
    erase_constraint (co_subst_co_constraint a x phi1) =
    erase_constraint (co_subst_co_constraint a x phi2).

Corollary erase_co_subst_tm A B a x :
  erase_tm A = erase_tm B ->
  erase_tm (co_subst_co_tm a x A) = erase_tm (co_subst_co_tm a x B).

Corollary erase_co_subst_brs Bs1 Bs2 a x :
  erase_brs Bs1 = erase_brs Bs2 ->
  erase_brs (co_subst_co_brs a x Bs1) = erase_brs (co_subst_co_brs a x Bs2).

Lemma lc_erase :
  (forall a, lc_tm a -> lc_tm (erase a)) /\
  (forall b, lc_brs b -> lc_brs (erase b)) /\
  (forall (g:co) (l:lc_co g), True) /\
  (forall b, lc_constraint b -> lc_constraint (erase b)).

Lemma lc_tm_erase : (forall a, lc_tm a -> lc_tm (erase a)).

Lemma lc_brs_erase : (forall b, lc_brs b -> lc_brs (erase b)).

Lemma lc_constraint_erase : (forall b, lc_constraint b -> lc_constraint (erase b)).

Hint Resolve lc_tm_erase lc_brs_erase lc_constraint_erase : lc.

Lemma lc_tm_open_tm_wrt_tm_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_tm (erase_tm a) (a_Var_f x)).

Lemma lc_tm_open_tm_wrt_co_erase_tm : forall a,
    (∀ x, lc_tm (open_tm_wrt_co a (g_Var_f x))) ->
    forall x, lc_tm (open_tm_wrt_co (erase_tm a) (g_Var_f x)).

Hint Resolve lc_tm_open_tm_wrt_tm_erase_tm lc_tm_open_tm_wrt_co_erase_tm : lc.

Hint Rewrite open_co_erase_tm open_co_erase_tm2 open_tm_erase_tm : TODO.
Hint Resolve lc_erase binds_map_2.

Ltac auto_rew_erase :=
  multimatch goal with
    | [ e: erase _ = erase _ |- _ ] => rewrite e in *; clear e
  end.

Lemma asymmetric_erase : forall B x g,
  erase (open_tm_wrt_tm B (a_Var_f x)) =
  erase (open_tm_wrt_tm B (a_Conv (a_Var_f x) g)).

Lemma erase_dom : forall G, dom G = dom (erase_context G).

Lemma path_erase : forall T p, Path T p -> Path T (erase p).

Lemma CoercedValueValue_erase:
  (forall v,  CoercedValue v -> Value (erase v)) /\
  (forall v, Value v -> Value (erase v)).

Lemma Value_erase :  (forall v, Value v -> Value (erase v)).

Lemma CoercedValue_erase :  (forall v, CoercedValue v -> Value (erase v)).

Lemma value_type_erase: forall a, value_type a -> value_type (erase a).

Lemma ann_rho_swap : forall rho x x0 a,
    x `notin` fv_tm_tm_tm (erase_tm a) ->
    x0 `notin` fv_tm_tm_tm (erase_tm a) ->
    RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->
    RhoCheck rho x0 (erase_tm (open_tm_wrt_tm a (a_Var_f x0))).

Ltac simpl_erase :=
  simpl;
  repeat match goal with
         | [ |- context [ erase (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (open_tm_wrt_tm ?a ?b) ] ] =>
           autorewcs; rewrite -open_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (close_tm_wrt_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase (close_tm ?x ?a) ] ] =>
           autorewcs; rewrite -close_tm_erase_tm; simpl; autorewcs

         | [ |- context [ erase (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs
         | [ |- context [ erase_tm (tm_subst_tm_tm ?a ?x ?b) ] ] =>
           autorewcs; rewrite -subst_tm_erase_tm; simpl; autorewcs

end. *)

Require Import FcEtt.ett_par.
(* FcEtt.ett_par:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Import FcEtt.utils.

Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ext_context_fv.

Require Import FcEtt.ext_wf.
Import ext_wf.

Require Import FcEtt.erase_syntax.

Require Export FcEtt.toplevel.

Require Export FcEtt.ett_value.

Inductive multipar S D ( a : tm) : tm -> Prop :=
| mp_refl : multipar S D a a
| mp_step : forall b c, Par S D a b -> multipar S D b c -> multipar S D a c.

Hint Constructors multipar.

Ltac erased_pick_fresh x :=
  match goal with
    [ |- erased_tm ?s ] =>
    let v := match s with
             | a_UAbs _ _  => erased_a_Abs
             | a_Pi _ _ _  => erased_a_Pi
             | a_CPi _ _   => erased_a_CPi
             | a_UCAbs _   => erased_a_CAbs
             end
    in pick fresh x and apply v
  end.

Ltac erased_inversion :=
  repeat match goal with
  | [H : erased_tm (a_UAbs _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_App _ _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_Pi _ _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_CPi _ _)|- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_UCAbs _ ) |- _ ] =>
    inversion H; subst; clear H
  | [H : erased_tm (a_CApp _ _)|- _ ] =>
    inversion H; subst; clear H
end.

Ltac erased_case :=
  let x := fresh in
  let h0 := fresh in
  erased_pick_fresh x; eauto using lc_erase;
  match goal with
    [ H : forall x, erased_tm (erase (open_tm_wrt_tm ?b (a_Var_f x))) |- _ ] =>
    move: (H x) => h0; rewrite <- open_tm_erase_tm in h0; eauto
  | [ H : ∀ c, erased_tm (erase (open_tm_wrt_co ?b (g_Var_f c))) |- _ ] =>
    move: (H x) => h0; rewrite <- open_co_erase_tm2 with (g := (g_Var_f x)) in h0; auto
  end.

Inductive erased_sort : sort -> Prop :=
| erased_Tm : forall a, erased_tm a -> erased_sort (Tm a)
| erased_Co : forall a b A, erased_tm a -> erased_tm b -> erased_tm A -> erased_sort (Co (Eq a b A)).

Definition erased_context : context -> Prop :=
  Forall (fun p => match p with (a,s) => erased_sort s end).

Definition joins S D a b := exists c, erased_context S /\ erased_tm a /\ erased_tm b /\
                               multipar S D a c /\ multipar S D b c.

Lemma erased_lc : forall a, erased_tm a -> lc_tm a.

Hint Resolve erased_lc : lc.

Lemma subst_tm_erased : forall x b, erased_tm b -> forall a , erased_tm a -> erased_tm (tm_subst_tm_tm b x a).

Lemma erased_a_Abs_exists : ∀  (rho : relflag) (a : tm) x,
                x `notin` fv_tm_tm_tm a
              → erased_tm (open_tm_wrt_tm a (a_Var_f x))
              → RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x))
              → erased_tm (a_UAbs rho a).

Lemma erased_a_Abs_inversion : forall rho a, 
     erased_tm (a_UAbs rho a) -> forall x, x `notin` fv_tm_tm_tm a 
  -> erased_tm (open_tm_wrt_tm a (a_Var_f x)) /\ RhoCheck rho x (open_tm_wrt_tm a (a_Var_f x)).

Lemma subst_co_erased : forall c g a , lc_co g -> erased_tm a -> erased_tm (co_subst_co_tm g c a).

Hint Resolve subst_tm_erased subst_co_erased : erased.

Lemma erased_a_CAbs_inversion : forall b, 
     erased_tm (a_UCAbs b) -> forall c, c `notin` fv_co_co_tm b 
  -> erased_tm (open_tm_wrt_co b (g_Var_f c)).

Lemma Par_lc1 : forall G D a a' , Par G D a a' -> lc_tm a.

Ltac lc_toplevel_inversion :=
  match goal with
  | [ b : binds ?F _ toplevel |- _ ] =>
    apply Toplevel_lc in b; inversion b; auto
end.

Lemma Par_lc2 : forall G D a a' , Par G D a a' -> lc_tm a'.

Hint Resolve Par_lc1 Par_lc2 : lc.

Lemma typing_erased_mutual:
    (forall G b A, Typing G b A -> erased_tm b) /\
    (forall G0 phi (H : PropWff G0 phi),
        forall A B T, phi = Eq A B T -> erased_tm A /\ erased_tm B /\ erased_tm T) /\
     (forall G0 D p1 p2 (H : Iso G0 D p1 p2), True ) /\
     (forall G0 D A B T (H : DefEq G0 D A B T), True) /\
     (forall G0 (H : Ctx G0), True).

Lemma Typing_erased: forall G b A, Typing G b A -> erased_tm b.

Hint Resolve Typing_erased : erased.

Lemma typing_erased_type_mutual:
    (forall G b A, Typing G b A -> erased_tm A) /\
    (forall G0 phi (H : PropWff G0 phi), True) /\
     (forall G0 D p1 p2 (H : Iso G0 D p1 p2), True ) /\
     (forall G0 D A B T (H : DefEq G0 D A B T), True) /\
     (forall G0 (H : Ctx G0), erased_context G0).

Lemma Typing_erased_type : forall G b A, Typing G b A -> erased_tm A.

Hint Resolve Typing_erased_type : erased.

Lemma toplevel_erased1 : forall F a A, binds F (Ax a A) toplevel -> erased_tm a.
Lemma toplevel_erased2 : forall F a A, binds F (Ax a A) toplevel -> erased_tm A.

Hint Resolve toplevel_erased1 toplevel_erased2 : erased.

Ltac erased_body x Ea :=
    match goal with
     | [ H4 : ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_tm ?a (a_Var_f x))
                         |- _ ] =>
      move: (H4 x ltac:(auto)) => Ea; clear H4
     | [ H4 : ∀ x : atom, x `notin` ?L0 → erased_tm (open_tm_wrt_co ?a (g_Var_f x))
                         |- _ ] =>
      move: (H4 x ltac:(auto)) => Ea; clear H4
    end.

Ltac eta_eq y EQ :=
   match goal with
     | [ H : ∀ x : atom, x `notin` ?L → open_tm_wrt_tm ?a (a_Var_f x) =
                           a_App ?b ?rho _ |- _ ] =>
        move: (H y ltac:(auto)) =>  EQ
end.

Lemma Par_fv_preservation: forall G D x a b, Par G D a b ->
                                        x `notin` fv_tm_tm_tm a ->
                                        x `notin` fv_tm_tm_tm b.
Proof.
  intros.
  induction H; eauto 2; simpl.
  all: simpl in H0.
  all: try solve [move => h0; apply AtomSetFacts.union_iff in h0; case: h0 => h0; eauto; apply IHreduction_in_one; auto].
  all: try auto.
  - simpl in *.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_tm a' b') => h0.
    apply fv_tm_tm_tm_open_tm_wrt_tm_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec_fast.
    fsetdec_fast.
    auto.
  - rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper.
    fsetdec.
  - have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a' g_Triv) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec.
    auto.
  - pick fresh x0.
    assert (Fl : x0 `notin` L). auto.
    assert (Fa : x `notin` fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f x0))).
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper. auto.
    move: (H1 x0 Fl Fa) => h0.
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto. 
  - pick fresh x0.
    have na': x `notin` fv_tm_tm_tm A'. eauto.
    have nb: x `notin` fv_tm_tm_tm (open_tm_wrt_tm B (a_Var_f x0)).
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_upper. eauto.
    have nob': x `notin` fv_tm_tm_tm (open_tm_wrt_tm B' (a_Var_f x0)). eauto.
    have nb': x `notin` fv_tm_tm_tm B'.
    rewrite fv_tm_tm_tm_open_tm_wrt_tm_lower. eauto.
    eauto.
  - pick_fresh c0.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have K:= H1 c0 ltac:(auto) h0.
    move => h1.
    apply K. auto.
    apply fv_tm_tm_tm_open_tm_wrt_co_lower; auto.
  - pick fresh c0 for L.
    have: x `notin` fv_tm_tm_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_tm_tm_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have h2: x `notin` fv_tm_tm_tm (open_tm_wrt_co a' (g_Var_f c0)). eauto.
    move: (fv_tm_tm_tm_open_tm_wrt_co_lower a' (g_Var_f c0)) => h3.
    have h4: x `notin` fv_tm_tm_tm a'. fsetdec.

    move => h1.
    apply AtomSetFacts.union_iff in h1.
    case: h1 => h1; eauto.
    apply AtomSetFacts.union_iff in h1.

Lemma Par_fv_co_preservation: forall G D x a b, Par G D a b ->
                                        x `notin` fv_co_co_tm a ->
                                        x `notin` fv_co_co_tm b.
Proof.
  intros.
  induction H; eauto 2; simpl.
  all: simpl in H0.
  all: try solve [move => h0; apply AtomSetFacts.union_iff in h0; case: h0 => h0; eauto; apply IHreduction_in_one; auto].
  all: try auto.
  - simpl in *.
    have: x `notin` fv_co_co_tm (open_tm_wrt_tm a' b') => h0.
    apply fv_co_co_tm_open_tm_wrt_tm_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec_fast.
    fsetdec_fast.
    auto.
  - rewrite fv_co_co_tm_open_tm_wrt_tm_upper.
    fsetdec.
  - have: x `notin` fv_co_co_tm (open_tm_wrt_co a' g_Triv) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    fsetdec.
    auto.
  - pick fresh x0.
    assert (Fl : x0 `notin` L). auto.
    assert (Fa : x `notin` fv_co_co_tm (open_tm_wrt_tm a (a_Var_f x0))).
    rewrite fv_co_co_tm_open_tm_wrt_tm_upper. auto.
    move: (H1 x0 Fl Fa) => h0.
    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto. 
  - pick fresh x0.
    have na': x `notin` fv_co_co_tm A'. eauto.
    have nb: x `notin` fv_co_co_tm (open_tm_wrt_tm B (a_Var_f x0)).
    rewrite fv_co_co_tm_open_tm_wrt_tm_upper. eauto.
    have nob': x `notin` fv_co_co_tm (open_tm_wrt_tm B' (a_Var_f x0)). eauto.
    have nb': x `notin` fv_co_co_tm B'.
    rewrite fv_co_co_tm_open_tm_wrt_tm_lower. eauto.
    eauto.
  - pick_fresh c0.
    have: x `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0.
    fsetdec.
    have K:= H1 c0 ltac:(auto) h0.
    move => h1.
    apply K. auto.
    apply fv_co_co_tm_open_tm_wrt_co_lower; auto.
  - pick fresh c0.
    have: x `notin` fv_co_co_tm (open_tm_wrt_co a (g_Var_f c0)) => h0.
    apply fv_co_co_tm_open_tm_wrt_co_upper in h0.
    apply AtomSetFacts.union_iff in h0.
    case:h0; eauto => h0.
    simpl in h0. assert (Q: c0 `notin` singleton x). fsetdec. clear Fr.
    fsetdec.
    have h2: x `notin` fv_co_co_tm (open_tm_wrt_co a' (g_Var_f c0)). eauto.
    move: (fv_co_co_tm_open_tm_wrt_co_lower a' (g_Var_f c0)) => h3.
    have h4: x `notin` fv_co_co_tm a'. fsetdec.
    move => h1.
    apply AtomSetFacts.union_iff in h1.
    case: h1 => h1; eauto.
    apply AtomSetFacts.union_iff in h1.

Lemma Par_erased_tm : forall G D a a', Par G D a a' -> erased_tm a -> erased_tm a'.

Hint Resolve Par_erased_tm : erased. 

Lemma subst1 : forall b S D a a' x, Par S D a a' -> erased_tm b ->
                           Par S D (tm_subst_tm_tm a x b) (tm_subst_tm_tm a' x b).

Lemma open1 : forall b S D a a' L, Par S D a a'
  -> (forall x, x `notin` L -> erased_tm (open_tm_wrt_tm b (a_Var_f x)))
  -> Par S D (open_tm_wrt_tm b a) (open_tm_wrt_tm b a').

Lemma subst2 : forall S D b x, lc_tm b ->
  forall a a', Par S D a a' -> Par S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b x a').

Lemma subst3 : forall S D b b' x,
    Par S D b b' ->
    forall a a', erased_tm a -> Par S D a a' ->
    Par S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b' x a').

Lemma subst4 : forall S D b x, lc_co b ->
    forall a a', Par S D a a' ->
    Par S D (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Lemma multipar_subst3 : forall S D b b' x, erased_tm b ->
    multipar S D b b' ->
    forall a a', erased_tm a -> multipar S D a a' ->
    multipar S D (tm_subst_tm_tm b x a) (tm_subst_tm_tm b' x a').

Lemma multipar_subst4 : forall S D b x, lc_co b ->
    forall a a', multipar S D a a' ->
    multipar S D (co_subst_co_tm b x a) (co_subst_co_tm b x a').

Lemma erased_tm_open_tm_wrt_tm: forall a x, erased_tm a -> erased_tm (open_tm_wrt_tm a (a_Var_f x)).

Hint Resolve erased_tm_open_tm_wrt_tm : erased.

Lemma Par_Pi_exists: ∀ x (G : context) D rho (A B A' B' : tm),
    x `notin` fv_tm_tm_tm B -> Par G D A A'
    → Par G D (open_tm_wrt_tm B (a_Var_f x)) B'
    → Par G D (a_Pi rho A B) (a_Pi rho A' (close_tm_wrt_tm x B')).

Lemma Par_CPi_exists:  ∀ c (G : context) D (A B a A' B' a' T T': tm),
       c `notin` fv_co_co_tm a -> Par G D A A'
       → Par G D B B' -> Par G D T T'
         → Par G D (open_tm_wrt_co a (g_Var_f c)) (a')
         → Par G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') (close_tm_wrt_co c a')).

Lemma Par_Abs_exists: ∀ x (G : context) D rho (a a' : tm),
    x `notin` fv_tm_tm_tm a
    → Par G D (open_tm_wrt_tm a (a_Var_f x)) a'
    → Par G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma Par_CAbs_exists: forall c (G : context) D (a a': tm),
       c `notin` fv_co_co_tm a
       -> Par G D (open_tm_wrt_co a (g_Var_f c)) a'
       → Par G D (a_UCAbs a) (a_UCAbs (close_tm_wrt_co c a')).

Lemma Par_EtaRel_exists : forall (G: context) D a b b' x,
   x `notin` union (fv_tm_tm_tm a) (fv_tm_tm_tm b) ->
   Par G D b b' ->
   (open_tm_wrt_tm a (a_Var_f x)) = a_App b Rel (a_Var_f x) ->
   Par G D (a_UAbs Rel a) b'.

Lemma Par_EtaRel_close : forall (G: context) D b b' x,
   x `notin` fv_tm_tm_tm b ->
   Par G D b b' ->
   Par G D (a_UAbs Rel (close_tm_wrt_tm x (a_App b Rel (a_Var_f x)))) b'.

Lemma Par_open_tm_wrt_co_preservation: forall G D B1 B2 c, Par G D (open_tm_wrt_co B1 (g_Var_f c)) B2 -> exists B', B2 = open_tm_wrt_co B' (g_Var_f c) /\ Par G D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B' (g_Var_f c)).

Lemma Par_open_tm_wrt_tm_preservation: forall G D B1 B2 x, Par G D (open_tm_wrt_tm B1 (a_Var_f x)) B2 -> exists B', B2 = open_tm_wrt_tm B' (a_Var_f x) /\ Par G D (open_tm_wrt_tm B1 (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x)).

Lemma multipar_Pi_exists: ∀ x (G : context) D rho (A B A' B' : tm),
       lc_tm (a_Pi rho A B) -> x `notin` fv_tm_tm_tm B -> multipar G D A A'
       → multipar G D (open_tm_wrt_tm B (a_Var_f x)) B'
       → multipar G D (a_Pi rho A B) (a_Pi rho A' (close_tm_wrt_tm x B')).

Lemma multipar_Pi_A_proj: ∀ (G : context) D rho (A B A' B' : tm),
    lc_tm A -> multipar G D (a_Pi rho A B) (a_Pi rho A' B')
    -> multipar G D A A'.

Lemma multipar_Pi_B_proj: ∀ (G : context) D rho (A B A' B' : tm),
    multipar G D (a_Pi rho A B) (a_Pi rho A' B')
    → (exists L, forall x, x `notin` L -> multipar G D (open_tm_wrt_tm B (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x))).

Lemma multipar_CPi_exists:  ∀ c (G : context) D (A B a T A' B' a' T': tm),
       lc_tm (a_CPi (Eq A B T) a) -> c `notin` fv_co_co_tm a -> multipar G D A A'
       → multipar G D B B' -> multipar G D T T'
         → multipar G D (open_tm_wrt_co a (g_Var_f c)) a'
         → multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') (close_tm_wrt_co c a')).

Lemma multipar_CPi_B_proj:  ∀ (G : context) D (A B a A' B' a' T T': tm),
    multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') a')
  → (exists L, forall c, c `notin` L -> multipar G D (open_tm_wrt_co a (g_Var_f c)) (open_tm_wrt_co a' (g_Var_f c))).

Lemma multipar_CPi_phi_proj:  ∀ (G : context) D (A B a A' B' a' T T': tm),
    multipar G D (a_CPi (Eq A B T) a) (a_CPi (Eq A' B' T') a')
    -> (multipar G D A A'/\ multipar G D B B' /\ multipar G D T T').

Lemma multipar_Abs_exists: ∀ x (G : context) D rho (a a' : tm),
       lc_tm (a_UAbs rho a) -> x `notin` fv_tm_tm_tm a
       → multipar G D (open_tm_wrt_tm a (a_Var_f x)) a'
       → multipar G D (a_UAbs rho a) (a_UAbs rho (close_tm_wrt_tm x a')).

Lemma multipar_CAbs_exists: forall c (G : context) D (a a': tm),
       lc_tm (a_UCAbs a) -> c `notin` fv_co_co_tm a
       -> multipar G D (open_tm_wrt_co a (g_Var_f c)) a'
       → multipar G D (a_UCAbs a) (a_UCAbs (close_tm_wrt_co c a')).

Lemma multipar_open_tm_wrt_co_preservation: forall G D B1 B2 c, multipar G D (open_tm_wrt_co B1 (g_Var_f c)) B2 -> exists B', B2 = open_tm_wrt_co B' (g_Var_f c) /\ multipar G D (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B' (g_Var_f c)).

Lemma multipar_open_tm_wrt_tm_preservation: forall G D B1 B2 x, multipar G D (open_tm_wrt_tm B1 (a_Var_f x)) B2 -> exists B', B2 = open_tm_wrt_tm B' (a_Var_f x) /\ multipar G D (open_tm_wrt_tm B1 (a_Var_f x)) (open_tm_wrt_tm B' (a_Var_f x)).

Lemma context_Par_irrelevance: forall G1 G2 D1 D2 a a',
                                             Par G1 D1 a a' -> Par G2 D2 a a'.

Lemma multipar_context_independent: forall G1 G2 D A B,  multipar G1 D A B -> multipar G2 D A B.

Lemma Par_weaken_available :
  forall G D a b, Par G D a b -> forall D', D [<=] D' -> Par G D' a b.

Lemma Par_respects_atoms:
  forall G D a b, Par G D a b -> forall D', D [=] D' -> Par G D' a b.

Lemma Par_availability_independence: forall G D1 D2 a b, Par G D1 a b -> Par G D2 a b.

Lemma Par_remove_available:
  forall G D a b, Par G D a b -> Par G (AtomSetImpl.inter D (dom G)) a b.

Lemma Par_weakening :
  forall G0 D a b, Par G0 D a b ->
  forall E F G, (G0 = F ++ G) -> Ctx (F ++ E ++ G) ->  Par (F ++ E ++ G) D a b. *)



Require Import FcEtt.beta.
(* FcEtt.beta:
Set Bullet Behavior "Strict Subproofs".
Set Implicit Arguments.

Require Export FcEtt.tactics.
Require Export FcEtt.imports.
Require Export FcEtt.ett_inf.
Require Export FcEtt.ett_ott.
Require Export FcEtt.ett_ind.

Require Export FcEtt.ext_context_fv.

Require Import FcEtt.ext_wf.
Import ext_wf.

Require Import FcEtt.fc_wf.
Import fc_wf.

Require Import FcEtt.utils.
Require Import FcEtt.erase_syntax.
Require Export FcEtt.toplevel.
Require Import FcEtt.ett_value.

Lemma Beta_lc1 : forall a a' , Beta a a' -> lc_tm a.

Lemma Beta_lc2 : forall a a' , Beta a a' -> lc_tm a'.

Lemma cf : forall A B (f : A -> B) (a b : A),  a = b -> f a = f b.
Lemma Beta_tm_subst : forall a a' b x, Beta a a' -> lc_tm b -> Beta (tm_subst_tm_tm b x a) (tm_subst_tm_tm b x a').

Lemma Beta_co_subst : forall a a' b x, Beta a a' -> lc_co b -> Beta (co_subst_co_tm b x a) (co_subst_co_tm b x a'). *)



Require Export FcEtt.fc_wf.



Require Export FcEtt.fc_context_fv.



Import FcEtt.ett_ott.



Module fc_subst (wf : fc_wf_sig) (weak : fc_weak_sig) <: fc_subst_sig.



Export wf.

Export weak.



Set Bullet Behavior "Strict Subproofs".

Set Implicit Arguments.



Lemma AnnCtx_strengthen : forall G1 G2, AnnCtx (G2 ++ G1) -> AnnCtx G1.

Proof.

  induction G2; [ | inversion 1]; simpl; auto.

Qed.



Lemma binds_to_AnnTyping :

  forall G x A, AnnCtx G -> binds x (Tm A) G -> AnnTyping G A a_Star.

Proof.

  induction 1; intros.

  + inversion H.

  + simpl in H2.

  destruct (binds_cons_1 _ x x0 (Tm A) (Tm A0) G H2) as [ [EQ Y] | N].

  - inversion Y. subst.

    eapply (AnnTyping_weakening  H0 [(x0, Tm A0)] nil G); eauto.

    simpl. eapply An_ConsTm; eauto.

  - pose K:= IHAnnCtx N.

    eapply (AnnTyping_weakening K [(x0, Tm A0)] nil G); simpl; eauto.

    eapply An_ConsTm; eauto.

    + destruct (binds_cons_1 _ x c (Tm A) (Co phi) G H2) as [ [EQ Y] | N].

      inversion Y.

      pose K := IHAnnCtx N.

      apply (AnnTyping_weakening K [(c, Co phi)] nil G); simpl; eauto.

      eapply An_ConsCo; eauto.

Qed.



Lemma binds_to_AnnPropWff: forall G0 a b A c,

    AnnCtx G0 -> binds c (Co (Eq a b A)) G0 -> AnnPropWff G0 (Eq a b A).

  induction G0; auto; try done.

  destruct a as [x s].

  intros a b A c H H0.

  destruct s; auto; try done.

  case H0; try done.

  + move => h0;

    simpl_env;

    eapply AnnPropWff_weakening with (F:=nil); eauto; simpl_env;

    inversion H; subst;

    apply (IHG0 _ _ _ c); eauto.

  + destruct H0; subst.

    inversion H0; subst.

    inversion H; subst.

    rewrite_env (nil ++ [(c, Co (Eq a b A))] ++ G0).

    eapply AnnPropWff_weakening; eauto.

    rewrite_env (nil ++ [(x, Co phi)] ++ G0).

    eapply AnnPropWff_weakening; eauto.

    simpl.

    inversion H; subst.

    apply (IHG0 _ _ _ c); auto.

Qed.



Lemma tm_subst_fresh_1 :

forall G a A a0 x s,

  AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x A = A.

Proof.

  intros G a A a0 x s H H0.

  destruct s.

  - apply tm_subst_tm_tm_fresh_eq.

    inversion H0; subst; clear H0.

    move => h0.

    pose M1 := AnnTyping_context_fv H.

    clearbody M1.

    destruct M1 as [h2 [h3 [h4 h5]]].

    unfold "[<=]" in h4.

    pose M := h4 x h0; auto.

  - apply tm_subst_tm_tm_fresh_eq.

    inversion H0; subst; clear H0.

    move => h0.

    pose M1 := AnnTyping_context_fv H.

    clearbody M1.

    destruct M1 as [h2 [h3 [h4 h5]]].

    unfold "[<=]" in h4.

    pose M := h4 x h0; auto.

Qed.



Lemma tm_subst_fresh_2 :

forall G a A a0 x s,

  AnnTyping G a A -> AnnCtx ((x ~ s) ++ G) -> tm_subst_tm_tm a0 x a = a.

Proof.

  move=> G a A a' x s typ /= ctx.

  apply tm_subst_tm_tm_fresh_eq.

  apply AnnTyping_context_fv in typ; split_hyp.

  inversion ctx; subst; fsetdec.

Qed.



Lemma co_subst_fresh_1 :

  forall G a A g c s,

  AnnTyping G a A -> AnnCtx ((c ~ s) ++ G) -> co_subst_co_tm g c A = A.

Proof.

  intros.

  apply co_subst_co_tm_fresh_eq.

  apply AnnTyping_context_fv in H; split_hyp.

  inversion H0; subst; fsetdec.

Qed.



Lemma co_subst_fresh_2 :

  forall G a A g c s,

  AnnTyping G a A -> AnnCtx ((c ~ s) ++ G) -> co_subst_co_tm g c a = a.

Proof.

  intros.

  apply co_subst_co_tm_fresh_eq.

  apply AnnTyping_context_fv in H; split_hyp.

  inversion H0; subst; fsetdec.

Qed.



Lemma subst_rho: forall L G a A x y b rho

    (T : AnnTyping G a A)

    (Neq: x <> y)

    (Fr: y `notin` fv_tm_tm_tm (erase_tm a))

    (Fr2: y `notin` L)

    (K : (forall x, x `notin` L -> RhoCheck rho x (erase_tm (open_tm_wrt_tm b (a_Var_f x))))),

    RhoCheck rho y (erase_tm (open_tm_wrt_tm (tm_subst_tm_tm a x b) (a_Var_f y))).

Proof.

  intros.

  rewrite? tm_subst_tm_tm_open_tm_wrt_tm_var; auto;

    try solve [apply (lc_typing T)].

  move: (K y Fr2) => RC.

  destruct rho.

  constructor.

  auto.



  inversion RC.

  constructor.

  autorewcs.

  rewrite -subst_tm_erase_tm.

  apply fv_tm_tm_tm_tm_subst_tm_tm_notin.

  auto. auto.

  apply (AnnTyping_lc T).

Qed.



Lemma co_subst_rho: forall L x y a rho g

    (LC: lc_co g)

    (Neq: x <> y)

    (Fr2: x `notin` L)

    (K : (forall x, x `notin` L -> RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))))),

    RhoCheck rho x (erase_tm (open_tm_wrt_tm (co_subst_co_tm g y a) (a_Var_f x))).

Proof.

  intros.

  rewrite? co_subst_co_tm_open_tm_wrt_tm_var; auto.

  move: (K x Fr2) => RC.

  inversion RC. subst.



  constructor.

  auto.



  constructor.

  autorewcs.

  rewrite -subst_co_erase_tm.

  auto.

Qed.



Ltac prepare_env :=

  match goal with

    [ |- context[ (?x' ~ (?S (?sub ?a1 ?x ?A))) ++ map (?tm_subst_tm_sort ?a1 ?x) ?F ++ ?G ] ] =>

    rewrite -app_assoc;

    replace (x' ~ (S (sub a1 x A)) ++  map (tm_subst_tm_sort a1 x) F) with

    (map (tm_subst_tm_sort a1 x) (x' ~ S A ++ F)); eauto using map_app

  end.



Ltac binds_PropWff_inversion :=

  let wff := fresh in

  match goal with

    [ bind_c : binds ?c (Co (Eq ?a ?b ?A)) ?G0 |- _ ] =>

    move: (@binds_to_AnnPropWff G0 _ _ _ _ ltac:(eauto with ctx_wff) bind_c) => wff;

   inversion wff; subst

  end.



Lemma ann_tm_substitution_mutual :

  (forall G0 b B (H : AnnTyping G0 b B),

      forall G a A, AnnTyping G a A ->

               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->

                      AnnTyping (map (tm_subst_tm_sort a x) F ++ G)

                                (tm_subst_tm_tm a x b)

                                (tm_subst_tm_tm a x B)) /\

  (forall G0 phi (H : AnnPropWff G0 phi),

      forall G a A, AnnTyping G a A ->

               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->

                      AnnPropWff (map (tm_subst_tm_sort a x) F ++ G)

                                 (tm_subst_tm_constraint a x phi)) /\

  (forall G0 D g p1 p2 (H : AnnIso G0 D g p1 p2),

      forall G a A, AnnTyping G a A ->

               forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->

                      AnnIso (map (tm_subst_tm_sort a x) F ++ G)

                             D

                             (tm_subst_tm_co a x g)

                             (tm_subst_tm_constraint a x p1)

                             (tm_subst_tm_constraint a x p2)) /\

  (forall  G0 D g A B (H : AnnDefEq G0 D g A B),

      forall G a A0, AnnTyping G a A0 ->

                forall F x, G0 = (F ++ (x ~ Tm A0) ++ G) ->

                       AnnDefEq (map (tm_subst_tm_sort a x) F ++ G)

                                D

                                (tm_subst_tm_co a x g)

                                (tm_subst_tm_tm a x A)

                                (tm_subst_tm_tm a x B)) /\

  (forall G0 (H : AnnCtx G0),

  forall G a A, AnnTyping G a A ->

  forall F x, G0 = (F ++ (x ~ Tm A) ++ G) ->

                AnnCtx (map (tm_subst_tm_sort a x) F ++ G)).



Proof.

  ann_induction CON.



  all: intros; subst.



  all: simpl tm_subst_tm_tm in *;

       simpl tm_subst_tm_co in *;

       simpl tm_subst_tm_constraint in *.



  all: match goal with

         [H1 : AnnTyping ?G0 ?a1 ?A0 |- _ ] => move: (AnnTyping_lc1 H1) => ? end.



  all: try (autorewrite with subst_open; auto).



  all: try solve [ensure_case An_Left;

                  eapply An_Left with (b := (tm_subst_tm_tm a7 x b))

                                      (b' := (tm_subst_tm_tm a7 x b'));

                  try (autorewrite with open_subst; auto;

                       eapply AnnDefEq_weaken_available; eauto);

                  eauto 2 using Path_tm_subst_tm_tm;

                  eapply AnnDefEq_weaken_available; eauto].

  

  all: try solve [ensure_case An_Right;

                  eapply An_Right with (a := (tm_subst_tm_tm a7 x a))

                                       (a' := (tm_subst_tm_tm a7 x a'));

                  try (autorewrite with open_subst; auto;

                       eapply AnnDefEq_weaken_available; eauto);

                  eauto 2 using Path_tm_subst_tm_tm;

                  eapply AnnDefEq_weaken_available; eauto].

  

  all: try solve [ensure_case An_CLeft;

                  eapply An_CLeft with (g := (tm_subst_tm_co a9 x g))

                                         (g' := (tm_subst_tm_co a9 x g'));

                  try (autorewrite with open_subst; auto;

                       eapply AnnDefEq_weaken_available; eauto);

                  eauto 2 using Path_tm_subst_tm_tm;

                  eapply AnnDefEq_weaken_available; eauto].



  all: try (An_pick_fresh x'; eauto; try (have neq: x <> x' by fsetdec_fast)).

  all: 

       try (prepare_env; repeat autorewrite with subst_open_var => //; eauto).

  all: 

       try (eapply subst_rho; eauto using fv_tm_erase_tm).

  all: 

       try (autorewrite with subst_open_var; auto;

            rewrite_body;

            autorewrite with subst_open; auto;

            try (simpl; case: (x' == x) => [?|//]; by subst)).

  all: eauto 3 using AnnDefEq_weaken_available.



  all: try solve

           [ eapply CON; eauto 3 using AnnDefEq_weaken_available,

                         erase_subst_constraint, erase_subst_tm ].



  all: try ((have h0: AnnTyping nil A a_Star by eauto using an_toplevel_closed);

            eapply tm_subst_fresh_2 with (x:=x) in h0; eauto).

  

  all: try ((have h0: AnnTyping nil a A by eauto using an_toplevel_closed);

            eapply tm_subst_fresh_1 with (x:=x) in h0; eauto).

  

  all: try solve [eapply CON; eauto; rewrite h0; eauto].



  - ensure_case An_Var.

    case: (x == x0) => [?|neq]; first subst x0.

       + have: A = A0 by apply binds_mid_eq in b;

          [move: b => [] | apply AnnCtx_uniq].

        move=> ?; subst A0.

        erewrite tm_subst_fresh_1  => //;

        eauto;

        last by eapply AnnCtx_strengthen; eassumption.

        apply AnnTyping_weakening with (F := nil) (G0 := G0) => //=.

        eauto.

      + eapply CON; eauto.

        * apply binds_remove_mid, binds_app_iff in b => //.

          case: b => [b|b].

          -- apply binds_app_2.

             
             apply binds_map with (f := tm_subst_tm_sort a0 x0) in b; simpl in b.

             assumption.

          -- apply binds_app_3.

             erewrite tm_subst_fresh_2; try eauto using AnnCtx_strengthen.

             eapply binds_to_AnnTyping; last by eassumption.

             do 2 eapply AnnCtx_strengthen; eassumption.



    - 

      ensure_case An_Assn.

      eapply CON; eauto.

      rename b0 into bind_c.

      have neq: c ≠ x. {

        move=> ?; subst x.

        apply binds_mid_eq in bind_c.

        - discriminate bind_c.

        - by apply AnnCtx_uniq.

      }

      apply binds_remove_mid, binds_app_iff in bind_c => //.

      case: bind_c => [bind_c|bind_c].

      + apply binds_app_2.

      apply binds_map with (f := tm_subst_tm_sort a1 x) in bind_c; simpl in bind_c.

      eassumption.

      + apply binds_app_3.

      binds_PropWff_inversion.

      erewrite (tm_subst_fresh_1 (A := A));

        first repeat erewrite tm_subst_fresh_2;

        eauto using AnnCtx_strengthen.



    - 

      ensure_case An_Beta.

      eapply CON; eauto 2 using erase_subst_tm.

      autorewcs. rewrite -!subst_tm_erase_tm.

      eauto using Beta_tm_subst, lc_tm_erase, AnnTyping_lc1.

    - econstructor; eauto.

      intros.

      erewrite tm_subst_tm_tm_open_tm_wrt_co_var; eauto.

      erewrite e; eauto.



    - ensure_case An_Empty.

      by move: H0 => /nil_eq_app [] /=.



    - ensure_case An_ConsTm.

      case: F H2 => [|[x' s] F] /= H2; first by eauto with ctx_wff.

      case: s H2 => [sPhi | sFm]; inversion 1; subst; simpl; econstructor; eauto.



    - ensure_case An_ConsCo.

      case: F H2 => [|[x' s] F] /= H2; first by eauto with ctx_wff.

      case: s H2 => [sPhi | sFm]; inversion 1; subst; simpl; econstructor; eauto.

      Unshelve. all: eauto.

Qed.



Lemma ann_co_substitution_mutual :

  (forall G0 b B, AnnTyping G0 b B ->

             forall G D g A1 A2 A3 F c,

               G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

               -> AnnDefEq G D g A1 A2

               -> AnnTyping (map (co_subst_co_sort g c) F ++ G)

                           (co_subst_co_tm g c b) (co_subst_co_tm g c B)) /\

  (forall  G0 phi (H : AnnPropWff G0 phi),

      forall G D g A1 A2 A3 F c,

        G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

        -> AnnDefEq G D g A1 A2

        -> AnnPropWff (map (co_subst_co_sort g c) F ++ G) (co_subst_co_constraint g c phi)) /\

  (forall G0 D0 g1 p1 p2 (H : AnnIso G0 D0 g1 p1 p2),

      forall G D g A1 A2 A3 F c,

        G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

        -> AnnDefEq G D g A1 A2

        -> AnnIso (map (co_subst_co_sort g c) F ++ G)

                 (union D (remove c D0))

                 (co_subst_co_co g c g1)

                 (co_subst_co_constraint g c p1)

                 (co_subst_co_constraint g c p2)) /\

  (forall G0 D0 g1 A B (H : AnnDefEq G0 D0 g1 A B),

      forall G D g F c A1 A2 A3,

        G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

        -> AnnDefEq G D g A1 A2

        -> AnnDefEq (map (co_subst_co_sort g c) F ++ G) (union D (remove c D0))

                   (co_subst_co_co g c g1)

                   (co_subst_co_tm g c A) (co_subst_co_tm g c B)) /\



  (forall  G0 (H : AnnCtx G0),

      forall G D g F c A1 A2 A3,

        G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

        -> AnnDefEq G D g A1 A2

        -> AnnCtx (map (co_subst_co_sort g c) F ++ G)).

Proof.

  ann_induction CON.



  all: intros; subst.



  all: simpl co_subst_co_tm in *;

       simpl co_subst_co_co in *;

       simpl co_subst_co_constraint in *.



  all: match goal with

         [H1 : AnnDefEq ?G0 ?D ?g ?A1 ?A2 |- _ ] =>

         move: (AnnDefEq_lc H1) => [? [? ?]] end.



  all: try (autorewrite with subst_open; auto).



  all: try solve [ensure_case An_Left;

                  eapply An_Left with (b := (co_subst_co_tm g c b))

                                      (b' := (co_subst_co_tm g c b'));

                  try (eapply Path_co_subst_co_tm; eauto);

                  eauto 2;

                  try (autorewrite with open_subst; eauto 2);

                  try (eapply AnnDefEq_weaken_available; eauto 2)].



  all: try solve [ensure_case An_Right;

                  eapply An_Right with (a := (co_subst_co_tm g c a))

                                      (a' := (co_subst_co_tm g c a'));

                  try (eapply Path_co_subst_co_tm; eauto);

                  eauto 2;

                  try (autorewrite with open_subst; eauto 2);

                  try (eapply AnnDefEq_weaken_available; eauto 2)].

  all: try solve [ensure_case An_CLeft;

                  eapply An_CLeft with (g := (co_subst_co_co g0 c g))

                                      (g' := (co_subst_co_co g0 c g'));

                  try (eapply Path_co_subst_co_tm; eauto);

                  eauto 2;

                  try (autorewrite with open_subst; eauto 2);

                  try (eapply AnnDefEq_weaken_available; eauto 2)].



  all: try (An_pick_fresh x'; eauto; try (have neq: c <> x' by fsetdec_fast)).



  all: 

    try (prepare_env; repeat autorewrite with subst_open_var => //;

         eauto using app_assoc).

  all: 

       try (eapply co_subst_rho; eauto using fv_tm_erase_tm).

  all: 

       try (autorewrite with subst_open_var; auto;

            rewrite_body;

            autorewrite with subst_open; auto;

            try (simpl; case: (x' == c) => [?|//]; by subst)).

  all: eauto 3 using AnnDefEq_weaken_available.



  all: try solve

           [ eapply CON; eauto 3 using AnnDefEq_weaken_available,

                         erase_subst_constraint, erase_subst_tm ].

  all: try solve

           [ eapply CON; eauto 3 using AnnDefEq_weaken_available;

             autorewcs; repeat rewrite -subst_co_erase_tm; auto].



  all: try ((have h0: AnnTyping nil A a_Star by eauto using an_toplevel_closed);

            eapply co_subst_fresh_2 with (c:=c) in h0; eauto).

  

  all: try ((have h0: AnnTyping nil a A by eauto using an_toplevel_closed);

            eapply co_subst_fresh_1 with (c:=c) in h0; eauto).

  

  all: try solve [eapply CON; eauto; rewrite h0; eauto].



  - 

    apply binds_app_1 in b.

    case:b; try done.

    + move => h0.

      eapply binds_map with (f:= co_subst_co_sort g c) in h0.

      eauto using binds_app_2.

    + intros b.

      apply binds_app_1 in b.

      case:b; try solve [move => h0; inversion h0; inversion H0].

      move => h0.

      rewrite co_subst_co_tm_fresh_eq.

      apply An_Var; auto.

        by eapply H; eauto.

      pose K := AnnCtx_strengthen ([(c, Co (Eq A1 A2 A3) )] ++ G0) _ a.

      clearbody K.

      inversion K; subst.

      have: AnnTyping G0 (a_Var_f x) A; auto => h1.

      pose M := AnnTyping_context_fv h1.

      clearbody M.

      destruct M as [h2 [h6 [h5 h3]]].

      unfold "[<=]" in h3.

      move => h4.

      apply H6.

      pose M := h3 c h4; auto.



  - 

    apply binds_app_1 in b0.

    case:b0; try done.

    + move => h0.

      destruct eq_dec; first subst c0.

      * exfalso.

        have: (c `notin` dom F) by eauto using AnnCtx_uniq, fresh_mid_head.

        simpl in h0.

        eapply binds_dom_contradiction; eassumption.

      * eapply An_Assn; eauto.

        apply binds_app_2.

         apply binds_map with (f:= co_subst_co_sort g c0) in h0. simpl in h0.

        eauto.

    + intros b0.

      apply binds_app_1 in b0.

      case:b0.

      -- move => h0; subst.

         inversion h0; try done.

         inversion H0; subst; clear H0.

         have: AnnCtx ([(c, Co (Eq a b A))] ++ G0).

         apply (AnnCtx_strengthen _ F); auto.

         move => Hi2.

         inversion Hi2; subst; clear Hi2.

         inversion H5; subst; clear H5.

         destruct eq_dec; try congruence.

         have DE: AnnDefEq G0 D0 g a b; auto.

         
         repeat rewrite co_subst_co_tm_fresh_eq; auto.

         ++ rewrite_env (nil ++(map (co_subst_co_sort g c) F) ++ G0).

            eapply AnnDefEq_weakening in DE.

            eapply (fourth ann_weaken_available_mutual) in DE.

            eapply DE. fsetdec. reflexivity.

            eapply H; eauto 1.

         ++ pose M := AnnTyping_context_fv H9.

            clearbody M.

            destruct M as [h5 [h4 h7]].

            unfold "[<=]" in h4.

            move => h6.

            apply H6; auto.

         ++ pose M := AnnTyping_context_fv H8.

            clearbody M.

            destruct M as [h4 [h5 h7]].

            unfold "[<=]" in h5.

            move => h6.

            apply H6; auto.

      -- move => h0.

         destruct eq_dec; try congruence.

          ++ subst.

             have ctx: AnnCtx ([(c0, Co (Eq A1 A2 A3))] ++ G0) by apply (AnnCtx_strengthen _ F); auto.

             inversion ctx; subst.

             apply binds_In in h0; done.

          ++ eapply An_Assn; eauto.

             have: AnnCtx G0.

             apply (AnnCtx_strengthen _ (F ++ [(c0, Co (Eq A1 A2 A3)) ])); auto.

               by rewrite -List.app_assoc; auto.

             move => Hi2.

             have: AnnPropWff G0 (Eq a b A) by apply (binds_to_AnnPropWff _ _ _ c).

             move => h1.

             inversion h1; subst; clear h1.

             instantiate (1 := (co_subst_co_tm g c0 A)).

             repeat rewrite co_subst_co_tm_fresh_eq.

               by apply binds_app_3.

             ** have h2: AnnCtx ([(c0, Co (Eq A1 A2 A3))] ++ G0) by apply (AnnCtx_strengthen _ F); auto.

                inversion h2; subst.

                pose M := AnnTyping_context_fv H5.

                clearbody M.

                destruct M as [h5 [h7 [_ h4]]].

                unfold "[<=]" in h4.

                move => h6.

                apply H9; auto.

             ** have h2: AnnCtx ([(c0, Co (Eq A1 A2 A3))] ++ G0) by apply (AnnCtx_strengthen _ F); auto.

                inversion h2; subst.

                pose M := AnnTyping_context_fv H6.

                clearbody M.

                destruct M as [_ [h4 _]].

                unfold "[<=]" in h4.

                move => h6.

                apply H9; auto.

             ** have h2: AnnCtx ([(c0, Co (Eq A1 A2 A3))] ++ G0) by apply (AnnCtx_strengthen _ F); auto.

                inversion h2; subst.

                pose M := AnnTyping_context_fv H5.

                clearbody M.

                destruct M as [_ [h4 _]].

                unfold "[<=]" in h4.

                move => h6.

                apply H9; auto.

  - eapply An_EtaC with (L := union L (singleton c)); eauto.

    intros. assert (Q: c0 `notin` L); eauto. eapply e in Q. 

    erewrite co_subst_co_tm_open_tm_wrt_co_var; eauto.

    erewrite e; eauto. assert (W: c0 `notin` singleton c). eauto. 

    apply notin_singleton_1 in W. simpl. 

    assert (X: (if c0 == c then g else g_Var_f c0) = g_Var_f c0).

    destruct (c0 == c). contradict W. auto. auto.

    rewrite X. auto.



  - induction F; done.

  - induction F; try done.



    destruct a1.

    destruct s; try inversion H1; subst.

    + simpl.

      apply An_ConsTm; auto.

      * inversion H1.

        eapply H; eauto.

        instantiate (1:= A3); auto.

      * simpl in H0.

        inversion H1; subst; clear H1.

        eapply H0; eauto.



  - inversion H1; subst; clear H1.

    induction F; try done.

    + inversion H4; subst; clear H4; auto.

    + destruct a1.

      destruct s; try inversion H4.

      simpl; subst.

      apply An_ConsCo; auto.

      * eapply H; eauto.

        instantiate (1:=A3); eauto.

      * inversion H4; subst; clear H4.

        eapply H0; eauto.

        instantiate (1:=A3); eauto.

 Unshelve. all: eauto.

Qed.



Lemma AnnTyping_tm_subst : forall G x A b B (H : AnnTyping ((x ~ Tm A) ++ G) b B),

  forall a, AnnTyping G a A ->

       AnnTyping G (tm_subst_tm_tm a x b) (tm_subst_tm_tm a x B).

Proof.

  intros G x A b B H a H0.

  pose K := @first _ _ _ _ _ ann_tm_substitution_mutual _ b B H G a A H0 nil x.

  clearbody K. simpl in K.

  apply K. auto.

Qed.



Lemma AnnTyping_tm_subst_nondep : forall L G a A b B,

    AnnTyping G a A ->

    (forall x, x `notin` L -> AnnTyping ([(x,Tm A)] ++ G) (open_tm_wrt_tm b (a_Var_f x)) B) ->

    AnnTyping G (open_tm_wrt_tm b a) B.

Proof.

  intros L G a A b B H0 H4.

    pick fresh x. assert (FRL : x `notin` L). eauto.

    pose K := H4 x FRL. clearbody K.

    pose K2 := AnnTyping_tm_subst K H0. clearbody K2.

    simpl in K2.

    rewrite tm_subst_tm_tm_open_tm_wrt_tm in K2; [| eapply (AnnTyping_lc H0)].

    rewrite tm_subst_tm_tm_var in K2.

    rewrite tm_subst_tm_tm_fresh_eq in K2; eauto.

    rewrite tm_subst_tm_tm_fresh_eq in K2; eauto.

Qed.



Lemma AnnTyping_co_subst : forall G x A1 A2 A3 b B (H : AnnTyping ((x ~ Co (Eq A1 A2 A3)) ++ G) b B),

  forall D a, AnnDefEq G D a A1 A2 ->

       AnnTyping G (co_subst_co_tm a x b) (co_subst_co_tm a x B).

Proof.

  intros G x A1 A2 A3 b B H D a H0.

  pose K := @first _ _ _ _ _ ann_co_substitution_mutual _ b B H G D a A1 A2 A3 nil x eq_refl H0.

  clearbody K. simpl in K.

  apply K.

Qed.



Lemma AnnTyping_co_subst_nondep : forall L G D g A1 A2 A3 b B,

    AnnDefEq G D g A1 A2 ->

    (forall x, x `notin` L -> AnnTyping ([(x,Co (Eq A1 A2 A3))] ++ G) (open_tm_wrt_co b (g_Var_f x)) B) ->

    AnnTyping G (open_tm_wrt_co b g) B.

Proof.

  intros L G D g A1 A2 A3 b B H0 H4.

    pick fresh x. assert (FRL : x `notin` L). eauto.

    pose K := H4 x FRL. clearbody K.

    pose K2 := AnnTyping_co_subst K H0. clearbody K2.

    simpl in K2.

    rewrite co_subst_co_tm_open_tm_wrt_co in K2; [| eapply (AnnDefEq_lc H0)].

    rewrite co_subst_co_co_var in K2.

    rewrite co_subst_co_tm_fresh_eq in K2; eauto.

    rewrite co_subst_co_tm_fresh_eq in K2; eauto.

Qed.



Ltac co_subst_hyp :=

  match goal with

  | [a0 : AnnTyping _ (a_Abs ?rho ?A1 ?b) _  |-  AnnTyping _ (a_Abs ?rho (_ ?A1) (_ ?b)) _ ] =>

      eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [a0 :  AnnTyping _ (a_Pi ?rho ?A1 ?B1) _ |- AnnTyping _ (a_Pi ?rho (_ ?A1) (_ ?B1)) _  ] =>

      eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [a0 : AnnTyping _ (a_CAbs ?phi ?B) _  |- AnnTyping _ (a_CAbs (_ ?phi) (_ ?B)) _ ] =>

      eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [a0 : AnnTyping _ (a_CPi ?phi ?B) _ |- AnnTyping _ (a_CPi (_ ?phi) (_ ?B)) _ ] =>

    eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [ a0 : AnnTyping _ (a_App ?a1 ?rho ?a2) _ |- AnnTyping _ (a_App (_ ?a1) ?rho (_ ?a2)) _ ] =>

    eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [ a0 : AnnTyping _ (a_CApp ?a1 ?g2) _ |- AnnTyping _ (a_CApp (_ ?a1) (_ ?g2)) _ ] =>

    eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [a0 : AnnDefEq _  _ _ (a_CPi ?phi1 ?B1) (a_CPi ?phi2 ?B2)  |-

     AnnDefEq _ _ _ (a_CPi (_ ?phi1) _) (a_CPi (_ ?phi2) _) ] =>

    eapply AnnDefEq_weaken_available;

    eapply (fourth ann_co_substitution_mutual _ _ _ _ _ a0);

    eauto

  | [a0 : AnnPropWff _ (Eq ?a ?b ?A) |- AnnPropWff _ (Eq (_ ?a) (_ ?b) (_ ?A)) ] =>

    eapply (second ann_co_substitution_mutual _ _ a0); eauto

  | [ a0 : AnnTyping _ ?a _ |- AnnTyping _ (_ ?a) _ ] =>

    eapply (first ann_co_substitution_mutual _ _ _ a0); eauto

  | [a0 : AnnDefEq _ _ _ ?a _ |- AnnDefEq _ _ _ (_ ?a) _ ] =>

      eapply AnnDefEq_weaken_available;

      eapply (fourth ann_co_substitution_mutual _ _ _ _ _ a0);

      eauto

  | [ a0 : AnnDefEq _ _ ?g _ _ |- AnnDefEq _ _ (_ ?g) _ _ ] =>

      eapply AnnDefEq_weaken_available;

      eapply (fourth ann_co_substitution_mutual _ _ _ _ _ a0);

      eauto

  end.



Lemma ann_co_substitution_mutual2 :

    (forall G0 b B, AnnTyping G0 b B -> True) /\

    (forall G0 phi, AnnPropWff G0 phi -> True) /\

    (forall G0 D0 g1 p1 p2 (H : AnnIso G0 D0 g1 p1 p2),

        forall D G g A1 A2 A3 F c, G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

                              -> AnnDefEq G D g A1 A2

                              -> c `notin` D0

                              -> AnnIso (map (co_subst_co_sort g c) F ++ G)

                                       D0

                                       (co_subst_co_co g c g1)

                                       (co_subst_co_constraint g c p1)

                                       (co_subst_co_constraint g c p2)) /\

    (forall G0 D0 g1 A B (H : AnnDefEq G0 D0 g1 A B),

        forall G D g F c A1 A2 A3, G0 = (F ++ (c ~ Co (Eq A1 A2 A3)) ++ G)

                              -> AnnDefEq G D g A1 A2

                              -> c `notin` D0

                              -> AnnDefEq (map (co_subst_co_sort g c) F ++ G) D0

                                         (co_subst_co_co g c g1)

                                         (co_subst_co_tm g c A) (co_subst_co_tm g c B)) /\

    (forall G0, AnnCtx G0 -> True).

Proof.

  ann_induction CON.



  all: intros; subst; auto.



  all: simpl co_subst_co_tm in *;

       simpl co_subst_co_co in *;

       simpl co_subst_co_constraint in *.



  all: match goal with

         [H1 : AnnDefEq ?G0 ?D ?g ?A1 ?A2 |- _ ] =>

         move: (AnnDefEq_lc H1) => [? [? ?]] end.



  all: try (ensure_case An_Left;

            eapply An_Left with (b := (co_subst_co_tm g c b))

                                (b' := (co_subst_co_tm g c b'));

            try (eapply Path_co_subst_co_tm; eauto)).



  all: try (ensure_case An_Right;

            eapply An_Right with (a := (co_subst_co_tm g c a))

                                   (a' := (co_subst_co_tm g c a'));

            try (eapply Path_co_subst_co_tm; eauto)).



  all: try (ensure_case An_CLeft;

            eapply An_CLeft with (g := (co_subst_co_co g0 c g))

                                   (g' := (co_subst_co_co g0 c g'));

            try (eapply Path_co_subst_co_tm; eauto)).



  all: try (An_pick_fresh x'; eauto; try (have neq: c <> x' by fsetdec_fast)).



  all: try co_subst_hyp.



  all: 

      try (eapply co_subst_rho; eauto using fv_tm_erase_tm).



  all: 

       try (autorewrite with subst_open_var; auto;

            rewrite_body;

            autorewrite with subst_open; auto;

            try (simpl; case: (x' == c) => [?|//]; by subst)).



  all: try (prepare_env; repeat autorewrite with subst_open_var => //;

       eauto using app_assoc).



  all: try (autorewrite with open_subst; eauto 2; eapply AnnDefEq_weaken_available; eauto 2).



  all: try co_subst_hyp.



  all: try (autorewrite with subst_open; auto).



  all: try solve [eapply CON; eauto 2 using erase_co_subst_constraint, erase_co_subst_tm;

                  try co_subst_hyp].



  - simpl; simpl in H.

    apply binds_app_1 in b0.

    case:b0; try done.

    + move => h0.

      destruct eq_dec; first subst c0.

      * exfalso.

        have: (c `notin` dom F) by eauto using AnnCtx_uniq, fresh_mid_head.

        eapply binds_dom_contradiction; eassumption.

      * eapply An_Assn; eauto.

        eapply (fifth ann_co_substitution_mutual); eauto.

        apply binds_app_2.

        apply binds_map with (f:= co_subst_co_sort g c0) in h0; eauto.

    + intro bnd.

      destruct eq_dec; first subst c0.

      done.

      destruct (binds_app_1 _ c _ _ _ bnd).

      pose K := ( binds_one_1 _ _ _ _ _ H0). done.

      eapply An_Assn; eauto 2.

      eapply (fifth ann_co_substitution_mutual); eauto 1.

      assert (c0 `notin` dom G0).

      eapply fresh_mid_tail. eapply AnnCtx_uniq. eauto 1.

      assert (AnnPropWff G0 (Eq a b A)).

      eapply binds_to_AnnPropWff; eauto 1.

      eapply AnnCtx_strengthen.

      eapply AnnCtx_strengthen. eauto 2.

      inversion H4. subst.

      rewrite co_subst_co_tm_fresh_eq.

      rewrite co_subst_co_tm_fresh_eq.

      apply binds_app_3; eauto.

      destruct (AnnTyping_context_fv H10) as (h0 & h1 & h2 & h3).

      fsetdec.

      destruct (AnnTyping_context_fv H9) as (h0 & h1 & h2 & h3).

      fsetdec.

  - eapply An_Beta; try co_subst_hyp; eauto using erase_co_subst_tm.

    autorewcs.

    rewrite -!subst_co_erase_tm => /=.

    auto.

  - eapply An_EtaC with (L := union L (singleton c)); try co_subst_hyp; 

    eauto using erase_co_subst_tm.

    intros. assert (X: c0 `notin` L). eauto. apply e in X. 

    erewrite co_subst_co_tm_open_tm_wrt_co_var; eauto.

    rewrite X. simpl.

    assert (W: c0 `notin` singleton c). eauto.

    apply notin_singleton_1 in W.

    assert (Q: (if c0 == c then g else g_Var_f c0) = g_Var_f c0). 

    destruct (c0 == c). contradict W. auto. auto. 

    rewrite Q. auto.

Qed.



Lemma AnnTyping_tm_swap : forall c c0 B G a A,

    c `notin` fv_tm_tm_tm A ->

    c `notin` fv_tm_tm_tm a ->

    c0 `notin` dom G \u {{ c }} ->

    AnnTyping ([(c, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c))

         (open_tm_wrt_tm A (a_Var_f c)) ->

    AnnTyping ([(c0, Tm B)] ++ G) (open_tm_wrt_tm a (a_Var_f c0))

                  (open_tm_wrt_tm A (a_Var_f c0)).

  Proof.

    intros c c0 B G a A Fr1 Fr2 Fr3 H.

    assert (AC : AnnCtx ([(c, Tm B)] ++ G)). eauto with ctx_wff.

    inversion AC. subst.

    assert (TV : AnnTyping ([(c0,Tm B)] ++ G)

                          (a_Var_f c0) B).

    eauto.

    assert (CTX : AnnCtx ([(c, Tm B)] ++ [(c0, Tm B)] ++ G)).

    econstructor; eauto with ctx_wff.

    pose M1 := (AnnTyping_weakening H4 [(c0,Tm B)] nil G) eq_refl. simpl_env in M1. eapply M1; eauto.

    pose K1 := AnnTyping_weakening H [(c0,Tm B)] [(c, Tm B)] G eq_refl CTX. clearbody K1.

  pose K2 := AnnTyping_tm_subst K1 TV. clearbody K2.

  repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in K2; auto.

  repeat rewrite tm_subst_tm_tm_var in K2.

  repeat rewrite tm_subst_tm_tm_fresh_eq in K2; eauto.

  Qed.



  Ltac rename_tm_Typing x0 K2 :=

    let M1 := fresh in

    let K1 := fresh in

    match goal with

      [ H0 : AnnTyping ([(?x, Tm ?A)] ++ ?G) (open_tm_wrt_tm ?B (a_Var_f ?x)) ?C |- _]

        => assert (AC : AnnCtx ([(x, Tm A)] ++ G)); eauto with ctx_wff;

          inversion AC; subst;

          assert (TV : AnnTyping ([(x0,Tm A)] ++ G) (a_Var_f x0) A); eauto;

          assert (CTX : AnnCtx ([(x,Tm A)] ++ [(x0, Tm A)] ++ G));

       [ match goal with

          [ H7 : AnnTyping G A a_Star |- _] =>

        econstructor; auto;

           pose M1 := (AnnTyping_weakening H7 [(x0,Tm A)] nil G);

                      simpl_env in M1; eapply M1; eauto end |

           pose K1 := AnnTyping_weakening H0 [(x0,Tm A)] [(x, Tm A)] G eq_refl CTX;

                      clearbody K1;

          pose K2 := (first ann_tm_substitution_mutual) _ _ _ K1 _ _ _ TV nil x eq_refl;

          clearbody K2; simpl_env in K2;

          repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in K2; auto;

          rewrite tm_subst_tm_tm_var in K2;

          rewrite tm_subst_tm_tm_fresh_eq in K2]

    end.



 Lemma AnnTyping_co_swap : forall c c0 phi G a A,

    c `notin` fv_co_co_tm A ->

    c `notin` fv_co_co_tm a ->

    c0 `notin` dom G \u {{ c }} ->

    AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))

         (open_tm_wrt_co A (g_Var_f c)) ->

    AnnTyping ([(c0, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c0))

                  (open_tm_wrt_co A (g_Var_f c0)).

  Proof.

    intros c c0 phi G a A Fr1 Fr2 Fr3 H.

    destruct phi as [b0 b1  B].

    assert (AC : AnnCtx ([(c, Co (Eq b0 b1 B))] ++ G)). eauto with ctx_wff.

    inversion AC. subst.

    assert (TV : AnnDefEq ([(c0,Co (Eq b0 b1 B))] ++ G)

                          (singleton c0) (g_Var_f c0) b0 b1).

    eapply An_Assn; eauto.

    assert (CTX : AnnCtx ([(c, Co (Eq b0 b1 B))] ++ [(c0, Co (Eq b0 b1 B))] ++ G)).

    econstructor; eauto with ctx_wff.

    pose M1 := (AnnPropWff_weakening H4 [(c0,Co (Eq b0 b1 B))] nil G) eq_refl. simpl_env in M1. eapply M1; eauto.

    pose K1 := AnnTyping_weakening H [(c0,Co (Eq b0 b1 B))] [(c, Co (Eq b0 b1 B))] G eq_refl CTX. clearbody K1.

  pose K2 := AnnTyping_co_subst K1 TV. clearbody K2. simpl_env in K2.

  repeat rewrite co_subst_co_tm_open_tm_wrt_co in K2; auto.

  repeat rewrite co_subst_co_co_var in K2.

  repeat rewrite co_subst_co_tm_fresh_eq in K2; eauto.

Qed.



Lemma AnnDefEq_tm_swap : forall x1 x G A1 D g2 b1 b2,

   x1 `notin` fv_tm_tm_co g2 \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2

  -> x `notin` dom G \u {{ x1 }}

  -> AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))

             (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1))

  -> AnnDefEq ([(x, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x))

             (open_tm_wrt_tm b1 (a_Var_f x)) (open_tm_wrt_tm b2 (a_Var_f x)).

Proof.

  intros x1 x G A1 D g2 b1 b2 Fr1 Fr2 H.

  assert (AC : AnnCtx ([(x1, Tm A1)] ++ G)). eauto with ctx_wff.

  inversion AC. subst.

  assert (TV : AnnTyping ([(x,Tm A1)] ++ G) (a_Var_f x) A1); eauto.

  assert (CTX : AnnCtx ([(x1,Tm A1)] ++ [(x, Tm A1)] ++ G)).

  { eapply An_ConsTm; auto.

    pose M1 := (AnnTyping_weakening H4 [(x,Tm A1)] nil G).

    simpl_env in M1. eapply M1; eauto. }

  pose K1 := AnnDefEq_weakening H [(x,Tm A1)] [(x1, Tm A1)] G eq_refl CTX.

  clearbody K1.

  pose K2 := (fourth ann_tm_substitution_mutual) _ _ _ _ _ K1 _ _ _ TV nil x1 eq_refl.

  clearbody K2. simpl_env in K2.

  repeat rewrite tm_subst_tm_co_open_co_wrt_tm in K2; auto.

  repeat rewrite tm_subst_tm_tm_open_tm_wrt_tm in K2; auto.

  rewrite tm_subst_tm_tm_var in K2.

  repeat rewrite tm_subst_tm_tm_fresh_eq in K2; auto.

  rewrite tm_subst_tm_co_fresh_eq in K2; auto.

Qed.



Lemma AnnDefEq_co_swap : forall c1 c phi1 G D g3 B1 B2,

    c1 `notin` D \u fv_co_co_tm B1 \u fv_co_co_tm B2 \u fv_co_co_co g3 ->

    c `notin` dom G \u {{ c1 }} ->

    (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))

              (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))

    -> (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))

              (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))).

Proof.

  intros.

  assert (AC : AnnCtx ([(c1, Co phi1)] ++ G)). eauto with ctx_wff.

    inversion AC. subst.

    destruct phi1 as [A B A1].

    assert (TV : AnnDefEq ([(c,Co (Eq A B A1))] ++ G) (D \u singleton c) (g_Var_f c) A B).

    apply (An_Assn _ _ _ _ _ A1); auto.

    assert (CTX : AnnCtx ([(c1,Co (Eq A B A1))] ++ [(c, Co (Eq A B A1))] ++ G)). eapply An_ConsCo; auto.

    pose M1 := (AnnPropWff_weakening H6 [(c,Co (Eq A B A1))] nil G) eq_refl. simpl_env in M1. eapply M1; eauto.

    apply (fourth ann_remove_available_mutual) in H1.

    pose K1 := AnnDefEq_weakening H1 [(c,Co (Eq A B A1))] [(c1, Co (Eq A B A1))] G eq_refl CTX. clearbody K1.

    pose K2 := (fourth ann_co_substitution_mutual2) _ _ _ _ _ K1 _ _ _ nil c1 _ _ _ eq_refl TV; clearbody K2. simpl in K2.

    simpl_env in K2.

    repeat rewrite co_subst_co_co_open_co_wrt_co in K2; auto.

    repeat rewrite co_subst_co_tm_open_tm_wrt_co in K2; auto.

    repeat rewrite co_subst_co_co_var in K2.

    simpl in K2.

    repeat rewrite co_subst_co_tm_fresh_eq in K2.

    repeat rewrite co_subst_co_co_fresh_eq in K2.

  +  eapply (fourth ann_weaken_available_mutual).

      apply K2.

      apply notin_inter_2.

      fsetdec.

      fsetdec.

    + fsetdec.

    + fsetdec.

    + fsetdec.

Qed.



Lemma An_Pi_exists : forall x G rho A B,

    x `notin` dom G \u fv_tm_tm_tm B

  → AnnTyping ([(x, Tm A)] ++ G)

              (open_tm_wrt_tm B (a_Var_f x)) a_Star

  → AnnTyping G A a_Star

  → AnnTyping G (a_Pi rho A B) a_Star.

Proof.

  intros x G rho A B H H0 H1.

  eapply An_Pi with (L := (dom G \u singleton x)); auto.

  intros x0 H2.

  rename_tm_Typing x0 h0.

  eauto.

  eauto.

Qed.



Lemma An_Pi_inversion :

    ∀ (G:context) rho A B T,

      AnnTyping G (a_Pi rho A B) T ->

      T = a_Star /\

      AnnTyping G A a_Star /\

      ∀ x, x \notin dom G -> AnnTyping (( x ~ Tm  A) ++ G) (open_tm_wrt_tm B (a_Var_f x)) a_Star.

Proof.

  intros.

  inversion H. subst.

  do 2 split; auto.

  intros.

  pick fresh y.

  have: AnnTyping ([(y, Tm A)] ++ G) (open_tm_wrt_tm B (a_Var_f y)) a_Star by eapply H5; eauto 1.

  move => Ta.

  rename_tm_Typing x h0.

  auto. auto.

Qed.



Lemma An_Abs_exists :

  ∀ x (G:context) rho (A a B:tm),

    x \notin dom G \u fv_tm_tm_tm a \u fv_tm_tm_tm B ->

      AnnTyping G A a_Star ->

      AnnTyping (( x ~ Tm  A) ++ G)

                (open_tm_wrt_tm a (a_Var_f x))

                (open_tm_wrt_tm B (a_Var_f x))  ->

      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) ->

      AnnTyping G (a_Abs rho A a) (a_Pi rho A B).

Proof.

  intros x G rho A a B H H0 H1 RC.

  eapply An_Abs with (L := (dom G \u singleton x \u fv_tm_tm_tm (erase_tm a))); auto.

  intros x0 H2.

  rename_tm_Typing x0 K2; auto.

  repeat rewrite tm_subst_tm_tm_fresh_eq in K2; auto.

  intros. eapply ann_rho_swap with (x := x); eauto 2.

  eapply fv_tm_erase_tm. auto.

Qed.



Lemma fv_erase_tm_other : forall y G A x a,

    fv_tm_tm_tm (open_tm_wrt_tm a (a_Var_f y)) [<=] dom ([(y, Tm A)] ++ G) ->

    y `notin` {{ x }}  ->

    x `notin` dom G ->

    x `notin` fv_tm_tm_tm (erase_tm a).

    Proof.

      intros y G A x a H Fr Fr1.

    apply fv_tm_erase_tm.

    assert (H1 : fv_tm_tm_tm a [<=] dom ((y ~ Tm A) ++ G)).

    move: (@fv_tm_tm_tm_open_tm_wrt_tm_lower a (a_Var_f y)) => h1.

    fsetdec.

    simpl in H1.

    intros h2.

    apply H1 in h2.

    move: (F.add_iff (dom G) y x) => [h3 h4].

    apply h3 in h2. destruct h2. assert (y <> x). auto. done. done.

    Qed.



Lemma An_Abs_inversion :

  ∀ (G:context) rho (a:tm) A A1,

    AnnTyping G (a_Abs rho A a) A1 ->

    (exists B, A1 = a_Pi rho A B /\

    AnnTyping G A a_Star /\

    ∀ x, x \notin dom G ->

      RhoCheck rho x (erase_tm (open_tm_wrt_tm a (a_Var_f x))) /\

      AnnTyping (( x ~ Tm  A) ++ G)

                (open_tm_wrt_tm a (a_Var_f x))

                (open_tm_wrt_tm B (a_Var_f x))).

Proof.

  intros.

  inversion H. subst.

  exists B. split. auto. split. auto.

  intros.

  pose EA:= erase a.

  pick fresh y.

  have: AnnTyping ([(y, Tm A)] ++ G) (open_tm_wrt_tm a (a_Var_f y))

                  (open_tm_wrt_tm B (a_Var_f y)) by eapply H6; eauto 1.

  move => Ta.

  move: (H7 y ltac:(auto)) => h0.

  rename_tm_Typing x K2.

  repeat rewrite tm_subst_tm_tm_fresh_eq in K2; auto.

  split; last by auto.

  eapply ann_rho_swap with (x:=y); eauto.

  + destruct (AnnTyping_context_fv Ta) as [FV _].

    eapply (fv_erase_tm_other _ FV); eauto.

  + auto.

Qed.



Lemma An_Abs_impossible :   forall x G rho,

     x \notin dom G

   -> forall A a, (forall B, not (AnnTyping ((x ~ Tm A) ++ G) (open_tm_wrt_tm a (a_Var_f x)) B))

   -> forall A1, not (AnnTyping G (a_Abs rho A a) A1).

Proof.

  intros.

  intro TA1.

  inversion TA1. subst.

  destruct (An_Abs_inversion TA1) as (B0 & EQ & TA & ALLx).

  eapply H0.

  eapply ALLx. auto.

Qed.



Lemma An_CPi_exists :

    ∀ c (G : context) (phi : constraint) (B : tm),

      c \notin dom G \u fv_co_co_tm B ->

      AnnPropWff G phi

      → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star

      → AnnTyping G (a_CPi phi B) a_Star.

Proof.

  intros c G phi B H H0 H1.

  eapply An_CPi with (L := (dom G \u singleton c)); auto.

  intros c0 H2.

  replace a_Star with (open_tm_wrt_co a_Star (g_Var_f c0)); auto.

  eapply AnnTyping_co_swap; eauto.

Qed.



Lemma An_CPi_inversion :

    ∀ (G:context) (phi : constraint) (B T : tm),

      AnnTyping G (a_CPi phi B) T ->

      T = a_Star /\

      AnnPropWff G phi /\

      ∀ c, c \notin dom G

           -> AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c)) a_Star.

Proof.

  intros.

  inversion H. subst.

  do 2 split; auto.

  intros.

  pick fresh c'.

  have: AnnTyping ([(c', Co phi)] ++ G) (open_tm_wrt_co B (g_Var_f c')) a_Star by eapply H5; eauto 1.

  move => Ta.

  replace a_Star with (open_tm_wrt_co a_Star (g_Var_f c)); auto.

  eapply (@AnnTyping_co_swap c'); eauto.

Qed.



Lemma An_CAbs_exists :  ∀ c (G : context) (phi : constraint) (a B : tm),

    c \notin dom G \u fv_co_co_tm a \u fv_co_co_tm B

      ->  AnnPropWff G phi

       → AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))

              (open_tm_wrt_co B (g_Var_f c))

       → AnnTyping G (a_CAbs phi a) (a_CPi phi B).

Proof.

  intros c G phi a B H H0 H1.

  pick fresh c0 and apply An_CAbs; auto.

  eapply (@AnnTyping_co_swap c); eauto.

Qed.



Lemma An_CAbs_inversion : ∀ (G : context) (phi : constraint) (a A : tm),

    AnnTyping G (a_CAbs phi a) A

    -> exists B, A = (a_CPi phi B) /\

    forall c, c  `notin` dom G

     ->   AnnPropWff G phi /\

       AnnTyping ([(c, Co phi)] ++ G) (open_tm_wrt_co a (g_Var_f c))

                 (open_tm_wrt_co B (g_Var_f c)).

Proof.

  intros G phi a A H.

  inversion H. subst.

  exists B.  do 2 split; auto.

  pick fresh c'.

  have: AnnTyping ([(c', Co phi)] ++ G)

                  (open_tm_wrt_co a (g_Var_f c'))

                  (open_tm_wrt_co B (g_Var_f c'))by eapply H5; eauto 1.

  move => Ta.

  eapply (@AnnTyping_co_swap c'); eauto.

Qed.



Lemma An_AbsCong_exists : ∀ x1 x2 (G : context) D rho (g1 g2 : co) (A1 b1 A2 b3 b2 B : tm),

    x1 `notin` (dom G \u fv_tm_tm_tm b1 \u fv_tm_tm_tm b2 \u  fv_tm_tm_co g2)

    -> x2 `notin` (dom G \u fv_tm_tm_tm b2 \u fv_tm_tm_tm b3 \u  fv_tm_tm_co g1)

    ->  AnnDefEq G D g1 A1 A2

    → (AnnDefEq ([(x1, Tm A1)] ++ G) D  (open_co_wrt_tm g2 (a_Var_f x1))

                (open_tm_wrt_tm b1 (a_Var_f x1)) (open_tm_wrt_tm b2 (a_Var_f x1)))

    → (open_tm_wrt_tm b3 (a_Var_f x2) =

       open_tm_wrt_tm b2 (a_Conv (a_Var_f x2) (g_Sym g1)))

    → AnnTyping G A1 a_Star

    → AnnTyping G A2 a_Star

    → RhoCheck rho x1 (erase_tm (open_tm_wrt_tm b1 (a_Var_f x1)))

    → RhoCheck rho x2 (erase_tm (open_tm_wrt_tm b3 (a_Var_f x2)))

    -> AnnTyping G (a_Abs rho A1 b2) B

    → AnnDefEq G D (g_AbsCong rho g1 g2) (a_Abs rho A1 b1) (a_Abs rho A2 b3).

Proof.

  intros.

  eapply An_AbsCong with (L := (dom G \u singleton x1 \u singleton x2 \u

                                    fv_tm_tm_tm (erase_tm b1) \u fv_tm_tm_tm (erase_tm b3))) (b2 := b2); auto.

  { intros.

    eapply AnnDefEq_tm_swap; eauto.

  }

  { intros x Fr.

    rewrite (tm_subst_tm_tm_intro x2); auto.

    rewrite H3.

    rewrite (tm_subst_tm_tm_open_tm_wrt_tm); auto.

    rewrite (tm_subst_tm_tm_fresh_eq); auto.

    rewrite tm_subst_cast.

    rewrite (tm_subst_tm_co_fresh_eq); auto.

  }

  intros. eapply ann_rho_swap with (x:=x1); eauto.

  eapply fv_tm_erase_tm; eauto.

  intros. eapply ann_rho_swap with (x:=x2); eauto.

  eapply fv_tm_erase_tm; eauto.

  eauto.

Qed.



Lemma An_AbsCong_inversion :

  forall G D rho g1 g2 B1 B2,

    AnnDefEq G D (g_AbsCong rho g1 g2) B1 B2 ->

  exists A1 A2 b1 b2 b3 B,

    B1 = (a_Abs rho A1 b1) /\

    B2 = (a_Abs rho A2 b3) /\

    AnnTyping G A1 a_Star  /\

    AnnTyping G A2 a_Star  /\

    AnnDefEq G D g1 A1 A2  /\

    AnnTyping G (a_Abs rho A1 b2) B /\

    (forall x, x \notin dom G ->

          AnnDefEq  ((x ~ Tm A1) ++  G) D (open_co_wrt_tm g2 (a_Var_f x))

                    (open_tm_wrt_tm b1 (a_Var_f x))

                    ((open_tm_wrt_tm b2 (a_Var_f x))) /\

          (open_tm_wrt_tm b3 (a_Var_f x)) =

          (open_tm_wrt_tm b2 (a_Conv (a_Var_f x) (g_Sym g1))) /\

          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b1 (a_Var_f x)))) /\

          (RhoCheck rho x  (erase_tm (open_tm_wrt_tm b3 (a_Var_f x))))).

Proof.

  intros G D rho g1 g2 B1 B2 h0.

  inversion h0; subst.

  exists A1, A2, b1, b2, b3, B.

  split; auto; split; auto; split; auto; split; auto; split; auto; split; auto.

  intros x FrX.

  pose EA:= erase b1.

  pose EB:= erase b3.

  pick fresh y.

  have: AnnDefEq ([(y, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f y))

                 (open_tm_wrt_tm b1 (a_Var_f y)) (open_tm_wrt_tm b2 (a_Var_f y)) by

      eapply H3; eauto 1.

  move => Da.

  repeat split.

  eapply (@AnnDefEq_tm_swap y); eauto.

  {

    rewrite (tm_subst_tm_tm_intro y); auto.

    rewrite H4.

    rewrite (tm_subst_tm_tm_open_tm_wrt_tm); auto.

    rewrite (tm_subst_tm_tm_fresh_eq); auto.

    rewrite tm_subst_cast.

    rewrite (tm_subst_tm_co_fresh_eq); auto.

    eauto.

  }

  { eapply ann_rho_swap with (x:=y); eauto.

    destruct (AnnDefEq_context_fv Da) as [_ [_ [FV _]]].

    apply (fv_erase_tm_other _ FV); eauto.

  }

  {

    eapply ann_rho_swap with (x:=y); eauto.

    destruct (AnnDefEq_context_fv h0) as [_ [_ [_ [_ [FV _]]]]].

    simpl in FV.

    apply fv_tm_erase_tm.

    intro. apply FrX. fsetdec.

  }

Qed.



Lemma An_CPiCong_exists :  ∀ c1 c2 (G : context) D (g1 g3 : co) (phi1 : constraint)

       (B1 : tm) (phi2 : constraint) (B3 B2 : tm),

    AnnIso G D g1 phi1 phi2

    -> c1 `notin` D \u fv_co_co_tm B2 \u fv_co_co_tm B1 \u fv_co_co_co g3

    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm B2 \u fv_co_co_tm B3

    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))

                (open_tm_wrt_co B1 (g_Var_f c1)) (open_tm_wrt_co B2 (g_Var_f c1)))

    → (open_tm_wrt_co B3 (g_Var_f c2) =

       open_tm_wrt_co B2 (g_Cast (g_Var_f c2) (g_Sym g1)))

    → AnnTyping G (a_CPi phi1 B1) a_Star

    → AnnTyping G (a_CPi phi2 B3) a_Star

    -> AnnTyping G (a_CPi phi1 B2) a_Star

    → AnnDefEq G D (g_CPiCong g1 g3) (a_CPi phi1 B1)

               (a_CPi phi2 B3).

Proof.

  intros.

  eapply An_CPiCong with (L := (dom G \u D \u singleton c1 \u singleton c2)) (B2 := B2); auto.

  - intros c h5.

    eapply AnnDefEq_co_swap with (c1 := c1); eauto.

  - intros c Fr.

    rewrite (co_subst_co_tm_intro c2); auto.

    rewrite H3.

    rewrite (co_subst_co_tm_open_tm_wrt_co); auto.

    rewrite (co_subst_co_tm_fresh_eq); auto.

    simpl.

    destruct eq_dec; try congruence.

    rewrite (co_subst_co_co_fresh_eq); auto.

Qed.



Lemma An_CPiCong_inversion :  ∀ (G : context) D (g1 g3 : co)

                                (A1 A2 : tm),

    AnnDefEq G D (g_CPiCong g1 g3) A1 A2

    -> exists phi1 phi2 B1 B2 B3,

     A1 = (a_CPi phi1 B1) /\

    A2 = (a_CPi phi2 B3) /\

    AnnIso G D g1 phi1 phi2 /\

    AnnTyping G (a_CPi phi1 B1) a_Star /\

    AnnTyping G (a_CPi phi2 B3) a_Star /\

    AnnTyping G (a_CPi phi1 B2) a_Star /\

    (forall c, c  `notin` dom G

    → (AnnDefEq ([(c, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c))

                (open_tm_wrt_co B1 (g_Var_f c)) (open_tm_wrt_co B2 (g_Var_f c))) /\

      (open_tm_wrt_co B3 (g_Var_f c) =

       open_tm_wrt_co B2 (g_Cast (g_Var_f c) (g_Sym g1)))).

Proof.

  intros.

  inversion H. subst.

  exists phi1, phi2, B1, B2, B3.

  repeat split; auto.

  + pick fresh c1. eapply (@AnnDefEq_co_swap c1); eauto.

  + pick fresh c1.

    rewrite (co_subst_co_tm_intro c1); auto.

    rewrite H4.

    rewrite (co_subst_co_tm_open_tm_wrt_co); auto.

    rewrite (co_subst_co_tm_fresh_eq); auto.

    simpl.

    destruct eq_dec; try congruence.

    rewrite (co_subst_co_co_fresh_eq); auto.

    eauto.

Qed.



Lemma An_PiCong_exists : forall x1 x2 (G:context) D rho

                           (g1 g2 : co) (A1 B1 A2 B3 B2 : tm),

    x1 `notin` (dom G \u fv_tm_tm_tm B1 \u fv_tm_tm_tm B2 \u  fv_tm_tm_co g2)

    -> x2 `notin` (dom G \u fv_tm_tm_tm B2 \u fv_tm_tm_tm B3 \u  fv_tm_tm_co g1)

    -> AnnDefEq G D g1 A1 A2

    → AnnDefEq ([(x1, Tm A1)] ++ G) D (open_co_wrt_tm g2 (a_Var_f x1))

               (open_tm_wrt_tm B1 (a_Var_f x1)) (open_tm_wrt_tm B2 (a_Var_f x1))

    → (open_tm_wrt_tm B3 (a_Var_f x2) =

       open_tm_wrt_tm B2 (a_Conv (a_Var_f x2) (g_Sym g1)))

    → AnnTyping G (a_Pi rho A1 B1) a_Star

    → AnnTyping G (a_Pi rho A2 B3) a_Star

    → AnnTyping G (a_Pi rho A1 B2) a_Star

    → AnnDefEq G D (g_PiCong rho g1 g2) (a_Pi rho A1 B1) (a_Pi rho A2 B3).

Proof.

  intros.

  eapply An_PiCong with (L := (dom G \u singleton x1 \u singleton x2)) (B2 := B2) ; auto.

  { intros.

    eapply (@AnnDefEq_tm_swap x1); eauto.

  }

  { intros x Fr.

    rewrite (tm_subst_tm_tm_intro x2); auto.

    rewrite H3.

    rewrite (tm_subst_tm_tm_open_tm_wrt_tm); auto.

    rewrite (tm_subst_tm_tm_fresh_eq); auto.

    rewrite tm_subst_cast.

    rewrite (tm_subst_tm_co_fresh_eq); auto.

  }

Qed.



Lemma An_PiCong_inversion : forall (G:context) (D:available_props) (rho:relflag) (g1 g2:co) (C1 C2 :tm),

    AnnDefEq G D (g_PiCong rho g1 g2) C1 C2

  -> exists A1 B1 A2 B2 B3,

    C1 = (a_Pi rho A1 B1) /\

    C2 = (a_Pi rho A2 B3) /\

    AnnTyping G (a_Pi rho A1 B1) a_Star /\

    AnnTyping G (a_Pi rho A2 B3) a_Star /\

    AnnTyping G (a_Pi rho A1 B2) a_Star /\

    AnnDefEq G D g1 A1 A2 /\



    (forall x , x \notin dom G  ->

            AnnDefEq  (( x ~ Tm  A1 ) ++  G )  D  ( open_co_wrt_tm g2 (a_Var_f x) )   ( open_tm_wrt_tm B1 (a_Var_f x) )   (  (open_tm_wrt_tm  B2   (a_Var_f x) )  )  /\

            (open_tm_wrt_tm B3 (a_Var_f x)  = (open_tm_wrt_tm  B2   (a_Conv (a_Var_f x) (g_Sym g1))))).

Proof.

  intros G D rho g1 g2 C1 C2 h0.

  dependent induction h0; eauto.

  exists A1, B1, A2, B2, B3.

  repeat split; eauto.

  + pick fresh x1.

    eapply (@AnnDefEq_tm_swap x1); eauto.

  + pick fresh x1.

    rewrite (tm_subst_tm_tm_intro x1); auto.

    rewrite H1.

    rewrite (tm_subst_tm_tm_open_tm_wrt_tm); auto.

    rewrite (tm_subst_tm_tm_fresh_eq); auto.

    rewrite tm_subst_cast.

    rewrite (tm_subst_tm_co_fresh_eq); auto.

    eauto.

Qed.



Lemma An_CAbsCong_exists :

  forall c1 c2 (G : context) (D : available_props) (g1 g3 g4 : co)

    (phi1 : constraint) (a1 : tm) (phi2 : constraint) (a3 a2 B1 B2 B : tm),

    AnnIso G D g1 phi1 phi2

    -> c1 `notin` D \u fv_co_co_tm a2 \u fv_co_co_tm a1 \u fv_co_co_co g3

    -> c2 `notin` fv_co_co_co g1 \u fv_co_co_tm a2 \u fv_co_co_tm a3

    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))

                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1)))

    → (open_tm_wrt_co a3 (g_Var_f c2) =

       open_tm_wrt_co a2 (g_Cast (g_Var_f c2) (g_Sym g1)))

    → AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1)

    → AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2)

    → AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2)

    -> AnnTyping G (a_CAbs phi1 a2) B

    → AnnDefEq G D (g_CAbsCong g1 g3 g4) (a_CAbs phi1 a1) (a_CAbs phi2 a3).

Proof.

  intros c1 c2 G D g1 g3 g4 phi1 a1 phi2 a3 a2 B1 B2. intros.

  eapply An_CAbsCong with (a1 := a1) (a2 := a2)

     (L := (dom G \u D \u singleton c1 \u singleton c2)) (B2 := B2); eauto.

  - intros c Fr.

    eapply (@AnnDefEq_co_swap c1); eauto.

  - intros c Fr.

    rewrite (co_subst_co_tm_intro c2); auto.

    rewrite H3.

    rewrite (co_subst_co_tm_open_tm_wrt_co); auto.

    rewrite (co_subst_co_tm_fresh_eq); auto.

    simpl.

    destruct eq_dec; try congruence.

    rewrite (co_subst_co_co_fresh_eq); auto.

Qed.



Lemma An_CAbsCong_inversion :

  forall (G : context) (D : available_props) (g1 g3 g4 : co) A1 A2,

    AnnDefEq G D (g_CAbsCong g1 g3 g4) A1 A2

    -> exists phi1 phi2 a1 a2 a3 B1 B2 B,

      A1 = (a_CAbs phi1 a1) /\

      A2 = (a_CAbs phi2 a3) /\

      AnnIso G D g1 phi1 phi2 /\

      AnnTyping G (a_CAbs phi1 a1) (a_CPi phi1 B1) /\

      AnnTyping G (a_CAbs phi2 a3) (a_CPi phi2 B2) /\

      AnnTyping G (a_CAbs phi1 a2) B /\

      AnnDefEq G (dom G) g4 (a_CPi phi1 B1) (a_CPi phi2 B2) /\

      forall c1,

      c1`notin` dom G

    → (AnnDefEq ([(c1, Co phi1)] ++ G) D (open_co_wrt_co g3 (g_Var_f c1))

                (open_tm_wrt_co a1 (g_Var_f c1)) (open_tm_wrt_co a2 (g_Var_f c1))) /\

      (open_tm_wrt_co a3 (g_Var_f c1) =

       open_tm_wrt_co a2 (g_Cast (g_Var_f c1) (g_Sym g1))).

Proof.

  intros G D g1 g3 g4 A1 A2 h0.

  dependent induction h0; eauto.

  exists phi1, phi2, a1, a2, a3, B1, B2, B.

  repeat split; eauto; try done.

  + pick fresh c.

    eapply (@AnnDefEq_co_swap c); eauto.

  + pick fresh c.

    rewrite (co_subst_co_tm_intro c); auto.

    rewrite H2.

    rewrite (co_subst_co_tm_open_tm_wrt_co); auto.

    rewrite (co_subst_co_tm_fresh_eq); auto.

    simpl.

    destruct eq_dec; try congruence.

    rewrite (co_subst_co_co_fresh_eq); auto.

    eauto.

Qed.



End fc_subst.

