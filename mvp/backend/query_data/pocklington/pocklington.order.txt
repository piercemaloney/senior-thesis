

Require Import Arith.

Require Import ZArith.

Require Import Wf_nat.



Require Import lemmas.
(* lemmas:
Global Set Asymmetric Patterns.

Require Import ZArith.
Require Import EqNat.

Lemma predminus1 : forall n : nat, pred n = n - 1.

Lemma le_mult_l : forall p q : nat, p <= q -> forall r : nat, r * p <= r * q.

Lemma lt_plus_plus : forall n m p q : nat, n < m -> p < q -> n + p < m + q.

Lemma lt_mult_l :
 forall p q : nat, p < q -> forall r : nat, S r * p < S r * q.

Lemma le_mult_r : forall p q : nat, p <= q -> forall r : nat, p * r <= q * r.

Lemma sqrbound : forall p q : nat, p * p <= p * q \/ q * q <= p * q.

Lemma le_n_nm : forall n m : nat, n <= n * S m.

Lemma le_n_mn : forall n m : nat, n <= S m * n.

Lemma le_n_nn : forall n : nat, n <= n * n.

Lemma lt_n_nm : forall n m : nat, 0 < n -> 1 < m -> n < n * m. 

Lemma sqr_ascend : forall n : nat, n > 1 -> n < n * n.

Lemma witness_le : forall x y : nat, (exists q : nat, x + q = y) -> x <= y.

Lemma le_witness : forall x y : nat, x <= y -> exists q : nat, x + q = y.

Lemma lt_witness :
 forall x y : nat, x < y -> exists q : nat, x + q = y /\ 0 < q.

Lemma le_le_mult : forall b a c d : nat, a <= b -> c <= d -> a * c <= b * d.

Lemma lt_lt_mult : forall a b c d : nat, a < b -> c < d -> a * c < b * d.

Lemma lt_n_nm_m_gt_1 : forall a b : nat, a < a * b -> b > 1.

Lemma n0n1_or_gt : forall n : nat, n = 0 \/ n = 1 \/ n > 1.

Lemma lt_multpred_pp : forall p : nat, p > 1 -> pred p * pred p < p * p.

Lemma le_diff0 : forall b a c : nat, a <= b -> a = b + c -> c = 0.

Lemma simpl_lt_mult_l : forall a b c : nat, a * b < a * c -> b < c.

Lemma simpl_le_mult_l : forall a b c : nat, 0 < a -> a * b <= a * c -> b <= c.

Lemma simpl_eq_mult_l : forall a b c : nat, 0 < a -> a * b = a * c -> b = c.

Lemma mult_ppq_p0q1 : forall p q : nat, p = p * q -> p = 0 \/ q = 1.

Lemma mult_pq1_p1q1 : forall p q : nat, p * q = 1 -> p = 1 /\ q = 1.

Lemma Zmult_ab0a0b0 : forall a b : Z, (a * b)%Z = 0%Z -> a = 0%Z \/ b = 0%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zopp_lt_gt_0 : forall x : Z, (x < 0)%Z -> (- x > 0)%Z.

Lemma Zlt_neq : forall x y : Z, (x < y)%Z -> x <> y.

Lemma Zgt_neq : forall x y : Z, (x > y)%Z -> x <> y.

Lemma S_inj : forall n m : nat, S n = S m -> n = m.

Lemma Zlt_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p < q)%Z -> (r * p < r * q)%Z.

Lemma Zle_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p <= q)%Z -> (r * p <= r * q)%Z. *)

Require Import natZ.
(* natZ:
Require Import ZArith.
Require Import EqNat.

Require Import lemmas.

Lemma abs_opp : forall x : Z, Zabs_nat x = Zabs_nat (- x).

Lemma inj_abs_pos : forall x : Z, (x >= 0)%Z -> Z_of_nat (Zabs_nat x) = x.

Lemma inj_abs_neg :
 forall x : Z, (x < 0)%Z -> Z_of_nat (Zabs_nat x) = (- x)%Z.

Lemma abs_inj : forall n : nat, Zabs_nat (Z_of_nat n) = n.

Lemma abs_mult : forall x y : Z, Zabs_nat (x * y) = Zabs_nat x * Zabs_nat y.

Lemma isnat_inj_abs :
 forall (x : Z) (n : nat), x = Z_of_nat n -> n = Zabs_nat x.

Lemma isnat_abs_inj :
 forall (x : Z) (n : nat), (0 <= x)%Z -> n = Zabs_nat x -> x = Z_of_nat n.

Lemma isnat_plus : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x + y)%Z.

Lemma isnat_mult : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z.

Lemma lezle :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Zabs_nat x <= Zabs_nat y.

Lemma gtzgt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x > y)%Z -> Zabs_nat x > Zabs_nat y.

Lemma ltzlt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Zabs_nat x < Zabs_nat y.

Lemma abs_plus_pos :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Zabs_nat (x + y) = Zabs_nat x + Zabs_nat y.

Lemma abs_minus_pos :
 forall x y : Z,
 (0 <= x)%Z ->
 (0 <= y)%Z -> (x >= y)%Z -> Zabs_nat (x - y) = Zabs_nat x - Zabs_nat y.

Lemma abs_pred_pos :
 forall x : Z, (0 < x)%Z -> pred (Zabs_nat x) = Zabs_nat (x - 1).

Lemma abs_neq_lt : forall x : Z, x <> 0%Z -> 0 < Zabs_nat x.

Lemma nat_ge_0 : forall n : nat, (Z_of_nat n >= 0)%Z. *)

Require Import dec.
(* dec:
Require Import Arith.
Require Import ZArith.
Require Import EqNat.

Fixpoint allbefore (P : nat -> Prop) (n : nat) {struct n} : Prop :=
  match n with
  | O => True
  | S x => allbefore P x /\ P x
  end.

Fixpoint exbefore (P : nat -> Prop) (n : nat) {struct n} : Prop :=
  match n with
  | O => False
  | S x => exbefore P x \/ P x
  end.

Theorem allbefore_ok :
 forall (P : nat -> Prop) (n : nat),
 (forall q : nat, q < n -> P q) <-> allbefore P n.

Theorem exbefore_ok :
 forall (P : nat -> Prop) (n : nat),
 (exists q : nat, q < n /\ P q) <-> exbefore P n.

Lemma eqdec : forall n m : nat, n = m \/ n <> m.

Lemma ledec : forall n m : nat, n <= m \/ ~ n <= m.

Lemma ltdec : forall n m : nat, n < m \/ ~ n < m.

Lemma gedec : forall n m : nat, n >= m \/ ~ n >= m.

Lemma gtdec : forall n m : nat, n > m \/ ~ n > m.

Lemma zeqdec : forall x y : Z, x = y \/ x <> y.

Lemma notdec : forall P : Prop, P \/ ~ P -> ~ P \/ ~ ~ P.

Lemma anddec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> P /\ Q \/ ~ (P /\ Q).

Lemma ordec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P \/ Q) \/ ~ (P \/ Q).

Lemma impdec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P -> Q) \/ ~ (P -> Q).

Lemma iffdec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P <-> Q) \/ ~ (P <-> Q).

Theorem alldec :
 forall (P : nat -> Prop) (N : nat),
 (forall n : nat, P n \/ ~ P n) ->
 (forall x : nat, x < N -> P x) \/ ~ (forall x : nat, x < N -> P x).

Theorem exdec :
 forall (P : nat -> Prop) (N : nat),
 (forall n : nat, P n \/ ~ P n) ->
 (exists x : nat, x < N /\ P x) \/ ~ (exists x : nat, x < N /\ P x).

Theorem decDeMorgan :
 forall (N : nat) (P : nat -> Prop),
 (forall n : nat, P n \/ ~ P n) ->
 ((exists x : nat, x < N /\ P x) <-> ~ (forall x : nat, x < N -> ~ P x)).

Definition istrue (b : bool) := if b then True else False.

Lemma beq_nat_ok : forall n m : nat, n = m <-> istrue (beq_nat n m).

Lemma beq_nat_eq : forall n m : nat, n = m <-> beq_nat n m = true.

Lemma beq_nat_neq : forall n m : nat, n <> m <-> beq_nat n m = false.

Lemma zeq_bool_eq : forall x y : Z, x = y <-> Zeq_bool x y = true.

Lemma zeq_bool_neq : forall x y : Z, x <> y <-> Zeq_bool x y = false. *)

Require Import list.
(* list:
Require Import Arith.
Require Import ZArith.
Require Import EqNat.

Require Import dec.
Require Import natZ.

Inductive list (A : Set) : Set :=
  | Nil : list A
  | Cons : A -> list A -> list A.

Fixpoint length (A : Set) (l : list A) {struct l} : nat :=
  match l with
  | Nil => 0
  | Cons a r => S (length A r)
  end.

Lemma length_0 : forall (A : Set) (l : list A), length A l = 0 -> l = Nil A.

Lemma length_S :
 forall (A : Set) (l : list A) (n : nat),
 length A l = S n ->
 exists h : A, (exists t : list A, l = Cons A h t /\ length A t = n).

Fixpoint map (A B : Set) (f : A -> B) (l : list A) {struct l} : 
 list B :=
  match l with
  | Nil => Nil B
  | Cons a r => Cons B (f a) (map A B f r)
  end.

Notation Map := (map _ _) (only parsing).

Lemma map_length :
 forall (A B : Set) (f : A -> B) (l : list A),
 length A l = length B (map A B f l).

Fixpoint alllist (A : Set) (P : A -> Prop) (qlist : list A) {struct qlist} :
 Prop :=
  match qlist with
  | Nil => True
  | Cons m l => P m /\ alllist A P l
  end.

Lemma alllist_dec :
 forall (A : Set) (P : A -> Prop) (l : list A),
 (forall x : A, P x \/ ~ P x) -> alllist A P l \/ ~ alllist A P l.

Fixpoint exlist (A : Set) (P : A -> Prop) (qlist : list A) {struct qlist} :
 Prop :=
  match qlist with
  | Nil => False
  | Cons m l => P m \/ exlist A P l
  end.

Lemma exlist_dec :
 forall (A : Set) (P : A -> Prop) (l : list A),
 (forall x : A, P x \/ ~ P x) -> exlist A P l \/ ~ exlist A P l.

Definition inlist (A : Set) (a : A) := exlist A (fun b : A => a = b).

Lemma inlist_head_eq :
 forall (A : Set) (x y : A) (l : list A), x = y -> inlist A x (Cons A y l).

Lemma inlist_head_neq :
 forall (A : Set) (x y : A) (l : list A),
 x <> y -> (inlist A x (Cons A y l) <-> inlist A x l).

Lemma inlist_tail :
 forall (A : Set) (x y : A) (l : list A),
 inlist A x l -> inlist A x (Cons A y l).

Lemma inlist_dec :
 forall (A : Set) (x : A) (l : list A),
 (forall a b : A, a = b \/ a <> b) -> inlist A x l \/ ~ inlist A x l.

Theorem alllist_ok :
 forall (A : Set) (P : A -> Prop) (qlist : list A),
 alllist A P qlist <-> (forall q : A, inlist A q qlist -> P q).

Theorem exlist_ok :
 forall (A : Set) (P : A -> Prop) (qlist : list A),
 exlist A P qlist <-> (exists q : A, inlist A q qlist /\ P q).

Definition natlist := list nat.

Fixpoint product (qlist : natlist) : nat :=
  match qlist with
  | Nil => 1
  | Cons m l => m * product l
  end.

Fixpoint drop (q : nat) (qlist : natlist) {struct qlist} : natlist :=
  match qlist with
  | Nil => Nil nat
  | Cons q' l => if beq_nat q q' then l else Cons nat q' (drop q l)
  end.

Definition multDrop (q : nat) (l : natlist) := product (drop q l).

Lemma multdrop_cons_eq :
 forall (q : nat) (l : natlist), multDrop q (Cons nat q l) = product l.

Lemma multdrop_cons_neq :
 forall (p q : nat) (l : natlist),
 p <> q -> multDrop p (Cons nat q l) = q * multDrop p l.

Lemma multdrop_mult :
 forall (qlist : natlist) (q : nat),
 inlist nat q qlist -> q * multDrop q qlist = product qlist.

Definition Zlist := list Z.

Definition allPos : Zlist -> Prop := alllist Z (fun x : Z => (x >= 0)%Z).

Fixpoint zproduct (l : Zlist) : Z :=
  match l with
  | Nil => 1%Z
  | Cons x t => (x * zproduct t)%Z
  end.

Lemma productzproduct :
 forall l : natlist, Z_of_nat (product l) = zproduct (map nat Z Z_of_nat l).

Lemma zproductproduct :
 forall l : Zlist, Zabs_nat (zproduct l) = product (map Z nat Zabs_nat l).

Fixpoint zdrop (x : Z) (l : Zlist) {struct l} : Zlist :=
  match l with
  | Nil => Nil Z
  | Cons h t => if Zeq_bool x h then t else Cons Z h (zdrop x t)
  end.

Lemma zdrop_head_eq :
 forall (x y : Z) (l : Zlist), x = y -> zdrop x (Cons Z y l) = l.

Lemma zdrop_head_neq :
 forall (x y : Z) (l : Zlist),
 x <> y -> zdrop x (Cons Z y l) = Cons Z y (zdrop x l).

Lemma zdrop_length :
 forall (x : Z) (l : Zlist),
 inlist Z x l -> S (length Z (zdrop x l)) = length Z l.

Lemma zdrop_neq_inlist :
 forall (x y : Z) (l : Zlist),
 x <> y -> inlist Z x l -> inlist Z x (zdrop y l).

Lemma zdrop_inlist_weak :
 forall (x y : Z) (l : Zlist), inlist Z x (zdrop y l) -> inlist Z x l.

Lemma zdrop_swap :
 forall (x y : Z) (l : Zlist), zdrop x (zdrop y l) = zdrop y (zdrop x l).

Lemma zdrop_inlist_swap :
 forall (x y : Z) (l : Zlist),
 inlist Z y l -> inlist Z x (zdrop y l) -> inlist Z y (zdrop x l).

Lemma zdrop_product :
 forall (x : Z) (l : Zlist),
 inlist Z x l -> (x * zproduct (zdrop x l))%Z = zproduct l.

Definition zmultDrop (x : Z) (l : Zlist) := zproduct (zdrop x l).

Lemma zmultdrop_cons_eq :
 forall (q : Z) (l : Zlist), zmultDrop q (Cons Z q l) = zproduct l.

Lemma zmultdrop_cons_neq :
 forall (p q : Z) (l : Zlist),
 p <> q -> zmultDrop p (Cons Z q l) = (q * zmultDrop p l)%Z.

Lemma zmultdrop_mult :
 forall (qlist : Zlist) (q : Z),
 inlist Z q qlist -> (q * zmultDrop q qlist)%Z = zproduct qlist.

Lemma multdropzmultdrop :
 forall (q : nat) (qlist : natlist),
 Z_of_nat (multDrop q qlist) =
 zmultDrop (Z_of_nat q) (map nat Z Z_of_nat qlist).

Definition mapmult (a : Z) (l : Zlist) := map Z Z (fun x : Z => (a * x)%Z) l.

Lemma mapmult_image :
 forall (a : Z) (l : Zlist) (x : Z),
 inlist Z x l -> inlist Z (a * x)%Z (mapmult a l).

Lemma mapmult_orig :
 forall (a : Z) (l : Zlist) (y : Z),
 inlist Z y (mapmult a l) -> exists x : Z, inlist Z x l /\ y = (a * x)%Z.

Lemma abs_inj_list :
 forall l : natlist, map _ _ Zabs_nat (map _ _ Z_of_nat l) = l.

Lemma inj_abs_pos_list :
 forall l : Zlist, allPos l -> map _ _ Z_of_nat (map _ _ Zabs_nat l) = l.

Lemma inlist_inj_abs_pos_list :
 forall (q : nat) (l : Zlist),
 allPos l -> inlist nat q (map Z nat Zabs_nat l) -> inlist Z (Z_of_nat q) l. *)



Require Import exp.
(* exp:
Require Import ZArith.

Require Import lemmas.
Require Import natZ.

Fixpoint Exp (a : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => 1%Z
  | S m => (a * Exp a m)%Z
  end.

Lemma exp_0 : forall n : nat, Exp 0 (S n) = 0%Z.

Lemma exp_1 : forall n : nat, Exp 1 n = 1%Z.

Lemma exp_S : forall (a : Z) (n : nat), Exp a (S n) = (a * Exp a n)%Z.

Lemma exp_plus :
 forall (a : Z) (n m : nat), Exp a (n + m) = (Exp a n * Exp a m)%Z.

Lemma exp_abn :
 forall (a b : Z) (n : nat), Exp (a * b) n = (Exp a n * Exp b n)%Z.

Lemma exp_mult : forall (a : Z) (n m : nat), Exp a (n * m) = Exp (Exp a n) m.

Lemma exp_not0 : forall a : Z, a <> 0%Z -> forall m : nat, Exp a m <> 0%Z.

Lemma exp_eq : forall (n m : nat) (a : Z), n = m -> Exp a n = Exp a m.

Lemma exp_pred_succ : forall (a : Z) (n : nat), Exp a (pred (S n)) = Exp a n.

Definition ZExp (a n : Z) : Z :=
  match n with
  | Z0 => 1%Z
  | Zpos p => Exp a (nat_of_P p)
  | Zneg p => Exp a (nat_of_P p)
  end.

Lemma zexp_pred_succ : forall a x : Z, ZExp a (x + 1 - 1) = ZExp a x.

Lemma zexp_eq : forall x y a : Z, x = y -> ZExp a x = ZExp a y.

Lemma inj_zexp : forall (n : nat) (a : Z), ZExp a (Z_of_nat n) = Exp a n.

Lemma expzexp : forall x a : Z, ZExp a x = Exp a (Zabs_nat x).

Lemma zexp_S1 :
 forall a n : Z, (0 <= n)%Z -> ZExp a (n + 1) = (a * ZExp a n)%Z.

Lemma zexp_S :
 forall a n : Z, (0 <= n)%Z -> ZExp a (Zsucc n) = (a * ZExp a n)%Z.

Lemma zexp_plus :
 forall a n m : Z,
 (0 <= n)%Z -> (0 <= m)%Z -> ZExp a (n + m) = (ZExp a n * ZExp a m)%Z.

Lemma zexp_mult :
 forall a n m : Z,
 (0 <= n)%Z -> (0 <= m)%Z -> ZExp a (n * m) = ZExp (ZExp a n) m. *)

Require Import divides.
(* divides:
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import exp.

Definition Divides (n m : nat) : Prop := exists q : nat, m = n * q.

Lemma div_refl : forall a : nat, Divides a a.

Lemma div_trans :
 forall p q r : nat, Divides p q -> Divides q r -> Divides p r.

Lemma div_antisym : forall a b : nat, Divides a b -> Divides b a -> a = b.

Lemma div_le1 : forall n d : nat, Divides d (S n) -> d <= S n.

Lemma div_le : forall d n : nat, 0 < n -> Divides d n -> d <= n.

Definition bDivides (d n : nat) :=
  n = 0 \/ (exists q : nat, q < S n /\ n = d * q).

Lemma divbdiv : forall n d : nat, Divides d n <-> bDivides d n.

Lemma bdivdec : forall n d : nat, bDivides d n \/ ~ bDivides d n.

Lemma divdec : forall n d : nat, Divides d n \/ ~ Divides d n.

Theorem sqrdivbound :
 forall n d : nat,
 Divides d n ->
 exists x : nat, Divides x n /\ x * x <= n /\ (x = d \/ d * x = n).

Theorem div_rem :
 forall d n : nat,
 d > 0 -> exists q : nat, (exists r : nat, 0 <= r /\ r < d /\ n = q * d + r).

Lemma div_rem0 :
 forall n d q r : nat, n = q * d + r -> r < d -> Divides d n -> r = 0.

Theorem notdiv_rem :
 forall d n : nat,
 0 < d ->
 ~ Divides d n ->
 exists q : nat, (exists r : nat, 0 < r /\ r < d /\ n = q * d + r).

Lemma div_plus_compat :
 forall a b c : nat, Divides a b -> Divides a c -> Divides a (b + c).

Lemma div_minus_compat :
 forall a b d : nat, Divides d a -> Divides d b -> Divides d (a - b).

Lemma div_mult_compat_l :
 forall a b c : nat, Divides a b -> Divides a (b * c).

Lemma div_absexp_compat :
 forall (b : Z) (d : nat),
 Divides d (Zabs_nat b) -> forall n : nat, Divides d (Zabs_nat (Exp b (S n))).

Lemma div_plus_r :
 forall a b d : nat, Divides d a -> Divides d (a + b) -> Divides d b.

Definition ZDivides (x y : Z) : Prop := exists q : Z, y = (x * q)%Z.

Lemma zdivdiv :
 forall a b : Z, ZDivides a b -> Divides (Zabs_nat a) (Zabs_nat b).

Lemma divzdiv :
 forall a b : Z, Divides (Zabs_nat a) (Zabs_nat b) -> ZDivides a b.

Lemma zdivdec : forall x d : Z, ZDivides d x \/ ~ ZDivides d x. 

Lemma zdiv_plus_r :
 forall a b d : Z, ZDivides d a -> ZDivides d (a + b) -> ZDivides d b.

Lemma zdiv_plus_compat :
 forall a b c : Z, ZDivides a b -> ZDivides a c -> ZDivides a (b + c).

Lemma zdiv_mult_compat_l :
 forall a b c : Z, ZDivides a b -> ZDivides a (b * c).

Theorem zdiv_rem :
 forall d n : Z,
 (d > 0)%Z ->
 exists q : Z, (exists r : Z, (0 <= r < d)%Z /\ n = (q * d + r)%Z). *)

Require Import prime.

Require Import modulo.
(* modulo:
Require Import ZArith.

Require Import lemmas.
Require Import natZ.
Require Import exp.
Require Import divides.

Definition Mod (a b : Z) (n : nat) :=
  exists q : Z, a = (b + Z_of_nat n * q)%Z.

Lemma modpq_modp : forall (a b : Z) (p q : nat), Mod a b (p * q) -> Mod a b p.

Lemma mod_refl : forall (a : Z) (n : nat), Mod a a n.

Lemma mod_sym : forall (a b : Z) (n : nat), Mod a b n -> Mod b a n.

Lemma mod_trans :
 forall (a b c : Z) (n : nat), Mod a b n -> Mod b c n -> Mod a c n.

Lemma eqmod : forall x y : Z, x = y -> forall n : nat, Mod x y n.

Lemma mod_plus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a + c) (b + d) n.

Lemma mod_mult_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a * c) (b * d) n.

Lemma mod_sqr_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (a * a) (b * b) n.

Lemma mod_exp_compat :
 forall (a b : Z) (n : nat),
 Mod a b n -> forall m : nat, Mod (Exp a m) (Exp b m) n.

Lemma moda0_exp_compat :
 forall (a : Z) (n : nat),
 n > 0 -> Mod a 0 n -> forall m : nat, m > 0 -> Mod (Exp a m) 0 n.

Lemma mod_opp_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (- a) (- b) n.

Lemma mod_minus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a - c) (b - d) n.

Lemma mod_nx_0_n : forall (n : nat) (x : Z), Mod (Z_of_nat n * x) 0 n.

Lemma moddivmin :
 forall (a b : Z) (n : nat), Mod a b n <-> Divides n (Zabs_nat (a - b)).

Lemma moddec : forall (a b : Z) (n : nat), Mod a b n \/ ~ Mod a b n.

Lemma mod_0not1 : forall n : nat, n > 1 -> ~ Mod 0 1 n.

Lemma mod_exp1 :
 forall (a : Z) (n : nat), Mod a 1 n -> forall m : nat, Mod (Exp a m) 1 n.

Lemma mod_repr_non_0 :
 forall (n : nat) (x : Z), (0 < x < Z_of_nat n)%Z -> ~ Mod x 0 n.

Lemma mod_repr_eq :
 forall (p : nat) (x y : Z),
 0 < p ->
 (0 < x < Z_of_nat p)%Z -> (0 < y < Z_of_nat p)%Z -> Mod x y p -> x = y.

Definition ZMod (a b n : Z) := exists q : Z, a = (b + n * q)%Z.

Lemma zmodpq_modp : forall a b p q : Z, ZMod a b (p * q) -> ZMod a b p.

Lemma zmod_refl : forall a n : Z, ZMod a a n.

Lemma zmod_sym : forall a b n : Z, ZMod a b n -> ZMod b a n.

Lemma zmod_trans : forall a b c n : Z, ZMod a b n -> ZMod b c n -> ZMod a c n.

Lemma zeqmod : forall x y : Z, x = y -> forall n : Z, ZMod x y n.

Lemma zmod_plus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a + c) (b + d) n.

Lemma zmod_mult_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a * c) (b * d) n.

Lemma zmod_sqr_compat :
 forall a b n : Z, ZMod a b n -> ZMod (a * a) (b * b) n.

Lemma zmodmod : forall a b n : Z, ZMod a b n -> Mod a b (Zabs_nat n).

Lemma modzmod :
 forall (a b : Z) (n : nat), Mod a b n -> ZMod a b (Z_of_nat n).

Lemma absmodzmod : forall a b n : Z, Mod a b (Zabs_nat n) -> ZMod a b n.

Lemma zmod_exp_compat :
 forall a b n : Z, ZMod a b n -> forall m : Z, ZMod (ZExp a m) (ZExp b m) n.

Lemma zmoda0_exp_compat :
 forall a n : Z,
 (n > 0)%Z -> ZMod a 0 n -> forall m : Z, (m > 0)%Z -> ZMod (ZExp a m) 0 n.

Lemma zmod_opp_compat : forall a b n : Z, ZMod a b n -> ZMod (- a) (- b) n.

Lemma zmod_minus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a - c) (b - d) n.

Lemma zmod_nx_0_n : forall n x : Z, ZMod (n * x) 0 n.

Lemma zmoddivmin : forall a b n : Z, ZMod a b n <-> ZDivides n (a - b).

Lemma zmoddec : forall a b n : Z, ZMod a b n \/ ~ ZMod a b n.

Lemma zmod_0not1 : forall n : Z, (n > 1)%Z -> ~ ZMod 0 1 n.

Lemma zmod_repr_non_0 : forall n x : Z, (0 < x < n)%Z -> ~ ZMod x 0 n. *)

Require Import modprime.
(* modprime:
Require Import Arith.
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import list.
Require Import exp.
Require Import divides.
Require Import prime.
Require Import modulo.
Require Import gcd.

Lemma prime_div_or_gcd1 :
 forall (p : nat) (a : Z),
 Prime p -> ZDivides (Z_of_nat p) a \/ gcd (Z_of_nat p) a 1.

Lemma divmultgcd :
 forall a b c : Z,
 a <> 0%Z -> ZDivides a (b * c) -> gcd a b 1 -> ZDivides a c.

Lemma primedivmult :
 forall p n m : nat,
 Prime p -> Divides p (n * m) -> Divides p n \/ Divides p m.

Lemma mod_mult_inv_r :
 forall (a : Z) (p : nat),
 Prime p -> ~ Mod a 0 p -> exists ra : Z, Mod (a * ra) 1 p.

Lemma mod_mult_cancel_r :
 forall (a b c : Z) (p : nat),
 Prime p -> ~ Mod c 0 p -> Mod (a * c) (b * c) p -> Mod a b p.

Lemma mod_mult_0 :
 forall (p : nat) (a b : Z),
 Prime p -> Mod (a * b) 0 p -> Mod a 0 p \/ Mod b 0 p.

Lemma mod_not_exp_0 :
 forall p : nat,
 Prime p -> forall a : Z, ~ Mod a 0 p -> forall m : nat, ~ Mod (Exp a m) 0 p.

Lemma techlemma3 :
 forall (qlist : natlist) (a b : nat),
 0 < a ->
 a < b ->
 Divides a b ->
 b = product qlist ->
 allPrime qlist ->
 exists qi : nat, inlist nat qi qlist /\ Divides a (multDrop qi qlist). *)

Require Import fermat.
(* fermat:
Require Import Arith.
Require Import ZArith.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import list.
Require Import exp.
Require Import divides.
Require Import prime.
Require Import modulo.
Require Import modprime.

Definition nodoubles (p : nat) (l : Zlist) : Prop :=
  forall x : Z,
  inlist Z x l -> forall y : Z, inlist Z y (zdrop x l) -> ~ Mod x y p.

Lemma nodoubles_nil : forall p : nat, nodoubles p (Nil Z).

Lemma nodoubles_drop :
 forall (p : nat) (l : Zlist) (x : Z),
 nodoubles p l -> nodoubles p (zdrop x l).

Lemma nodoubles_ind :
 forall (p : nat) (h : Z) (t : Zlist),
 (forall x : Z, inlist Z x t -> ~ Mod h x p) ->
 nodoubles p t -> nodoubles p (Cons Z h t).

Definition allex (p : nat) (l0 l1 : Zlist) : Prop :=
  forall x : Z, inlist Z x l0 -> exists y : Z, inlist Z y l1 /\ Mod x y p.

Lemma allex_nodoubles_drop :
 forall (p : nat) (l0 l1 : Zlist) (x0 x1 : Z),
 Prime p ->
 Mod x0 x1 p ->
 inlist Z x0 l0 ->
 inlist Z x1 l1 ->
 nodoubles p l0 -> allex p l0 l1 -> allex p (zdrop x0 l0) (zdrop x1 l1).

Fixpoint until (n : nat) : Zlist :=
  match n with
  | O => Nil Z
  | S n => Cons Z (Z_of_nat (S n)) (until n)
  end.

Lemma until_ok :
 forall (n : nat) (x : Z), (0 < x <= Z_of_nat n)%Z -> inlist Z x (until n).

Lemma until_mod_all :
 forall (p : nat) (x : Z),
 0 < p ->
 ~ Mod x 0 p -> exists y : Z, inlist Z y (until (pred p)) /\ Mod x y p.

Lemma until_pos : forall (n : nat) (x : Z), inlist Z x (until n) -> (0 < x)%Z.

Lemma until_le_n :
 forall (n : nat) (x : Z), inlist Z x (until n) -> (x <= Z_of_nat n)%Z.

Lemma until_not_0mod :
 forall (p : nat) (x : Z),
 0 < p -> inlist Z x (until (pred p)) -> ~ Mod x 0 p.

Lemma untiln_prod_not_0modp :
 forall p n : nat,
 0 < n -> n < p -> Prime p -> ~ Mod (zproduct (until n)) 0 p.

Lemma until_prod_not_0mod :
 forall p : nat, Prime p -> ~ Mod (zproduct (until (pred p))) 0 p.

Lemma until_mapmult_exp :
 forall (a : Z) (n : nat),
 zproduct (mapmult a (until n)) = (Exp a n * zproduct (until n))%Z.

Lemma until_mapmult_allex :
 forall (p : nat) (a : Z),
 Prime p ->
 ~ Mod a 0 p -> allex p (until (pred p)) (mapmult a (until (pred p))).

Lemma until_nodoubles1 :
 forall p : nat, Prime p -> forall n : nat, n < p -> nodoubles p (until n).

Lemma until_nodoubles :
 forall p : nat, Prime p -> nodoubles p (until (pred p)).

Fixpoint permmod (p : nat) (l1 : Zlist) {struct l1} : 
 Zlist -> Prop :=
  fun l2 : Zlist =>
  match l1 with
  | Nil => l2 = Nil Z
  | Cons x t =>
      exists y : Z, inlist Z y l2 /\ Mod x y p /\ permmod p t (zdrop y l2)
  end.

Lemma permmod_nil : forall p : nat, permmod p (Nil Z) (Nil Z).

Lemma permmod_drop :
 forall (p : nat) (x1 x2 : Z) (l1 l2 : Zlist),
 Mod x1 x2 p ->
 inlist Z x1 l1 ->
 inlist Z x2 l2 -> permmod p (zdrop x1 l1) (zdrop x2 l2) -> permmod p l1 l2.

Lemma permmod_drop_cons :
 forall (p : nat) (x1 x2 : Z) (t1 l2 : Zlist),
 Mod x1 x2 p ->
 inlist Z x2 l2 -> permmod p t1 (zdrop x2 l2) -> permmod p (Cons Z x1 t1) l2.

Lemma permmod_cons_extend :
 forall (p : nat) (x1 x2 : Z) (l1 l2 : Zlist),
 permmod p l1 l2 -> Mod x1 x2 p -> permmod p (Cons Z x1 l1) (Cons Z x2 l2).

Lemma permmod_length :
 forall (p : nat) (l1 l2 : Zlist),
 permmod p l1 l2 -> length Z l1 = length Z l2.

Lemma permmod_refl : forall (p : nat) (l : Zlist), permmod p l l.

Lemma permmod_sym :
 forall (p : nat) (l1 l2 : Zlist), permmod p l1 l2 -> permmod p l2 l1.

Lemma permmod_product :
 forall (l0 l1 : Zlist) (p : nat),
 permmod p l0 l1 -> Mod (zproduct l0) (zproduct l1) p.

Lemma allex_permmod :
 forall (p : nat) (l0 l1 : Zlist),
 length Z l0 = length Z l1 ->
 (forall x0 : Z,
  inlist Z x0 l0 ->
  exists x1 : Z,
    inlist Z x1 l1 /\ Mod x0 x1 p /\ permmod p (zdrop x0 l0) (zdrop x1 l1)) ->
 permmod p l0 l1.

Lemma permmod_allex :
 forall (p : nat) (l0 l1 : Zlist),
 permmod p l0 l1 ->
 forall x : Z,
 inlist Z x l0 ->
 exists y : Z,
   inlist Z y l1 /\ Mod x y p /\ permmod p (zdrop x l0) (zdrop y l1).

Lemma permmod_trans1 :
 forall (n p : nat) (l0 l1 l2 : Zlist),
 length Z l0 = n ->
 length Z l1 = n ->
 length Z l2 = n -> permmod p l0 l1 -> permmod p l1 l2 -> permmod p l0 l2.

Lemma permmod_trans :
 forall (p : nat) (l0 l1 l2 : Zlist),
 permmod p l0 l1 -> permmod p l1 l2 -> permmod p l0 l2.

Lemma permmod_drop_drop1 :
 forall (n p : nat) (x y : Z) (l : Zlist),
 n = length Z l ->
 Mod x y p ->
 inlist Z x l -> inlist Z y l -> permmod p (zdrop x l) (zdrop y l).

Lemma permmod_drop_drop :
 forall (p : nat) (x y : Z) (l : Zlist),
 Mod x y p ->
 inlist Z x l -> inlist Z y l -> permmod p (zdrop x l) (zdrop y l).

Lemma permmod_drop_rev :
 forall (p : nat) (l0 l1 : Zlist) (x0 x1 : Z),
 Mod x0 x1 p ->
 inlist Z x0 l0 ->
 inlist Z x1 l1 -> permmod p l0 l1 -> permmod p (zdrop x0 l0) (zdrop x1 l1).

Lemma nodoubles_allex_permmod1 :
 forall (n p : nat) (l0 l1 : Zlist),
 n = length Z l0 ->
 n = length Z l1 ->
 Prime p ->
 length Z l0 = length Z l1 ->
 nodoubles p l0 -> allex p l0 l1 -> permmod p l0 l1.

Lemma nodoubles_allex_permmod :
 forall (p : nat) (l0 l1 : Zlist),
 Prime p ->
 length Z l0 = length Z l1 ->
 nodoubles p l0 -> allex p l0 l1 -> permmod p l0 l1.

Lemma until_mapmult_permmod :
 forall (p : nat) (a : Z),
 Prime p ->
 ~ Mod a 0 p -> permmod p (until (pred p)) (mapmult a (until (pred p))).

Theorem flt :
 forall (a : Z) (p : nat), Prime p -> ~ Mod a 0 p -> Mod (Exp a (pred p)) 1 p. *)



Definition Order (b : Z) (q p : nat) :=

  0 < q /\

  Mod (Exp b q) 1 p /\ (forall d : nat, 0 < d -> Mod (Exp b d) 1 p -> q <= d).



Lemma orderdec : forall (b : Z) (q p : nat), Order b q p \/ ~ Order b q p.

Proof.

   intros. unfold Order in |- *.

   apply anddec.

   apply ltdec.

   apply anddec.

   apply moddec.

   elim (exdec (fun d : nat => 0 < d /\ Mod (Exp b d) 1 p) q).

   right. intros.

   elim H. intro d. intros.

   elim H0. intros.

   elim H2. intros.

   intro. elim (le_not_lt q d).

   apply H5.

   assumption.

   assumption.

   assumption.

   left. intros.

   elim (le_or_lt q d).

   intro. assumption.

   intro.

   elim H.

   split with d.

   split.

   assumption.

   split.

   assumption.

   assumption.

   intro.

   apply anddec.

   apply ltdec.

   apply moddec.

Qed.



Lemma order_ex1 :

 forall (b : Z) (p : nat),

 Prime p ->

 (exists d : nat, 0 < d /\ Mod (Exp b d) 1 p) -> exists x : nat, Order b x p.

Proof.

   intros. elim H0.

   intro. apply (lt_wf_ind x).

   intros X IH.

   intros.

   elim (exdec (fun m : nat => 0 < m /\ Mod (Exp b m) 1 p) X).

   intro.

   elim H2. 

   intros.

   elim H3. intros.

   elim H5. intros.

   elim (IH x0). intros.

   split with x1.

   assumption.

   assumption.

   split. assumption. assumption.

   intros. split with X.

   elim H1. intros.

   split.

   assumption.

   split.

   assumption.

   intros.

   elim (le_or_lt X d).

   intro. assumption.

   intros.

   elim H2.

   split with d.

   split.

   assumption.

   split.

   assumption.

   assumption.

   intro. apply anddec. apply ltdec. apply moddec.

Qed.



Lemma order_ex :

 forall (b : Z) (p : nat),

 Prime p -> ~ Mod b 0 p -> exists x : nat, x < p /\ Order b x p.

Proof.

   intros.

   elim H.

   intros.

   elim (order_ex1 b p H).

   intros.

   split with x.

   split.

   apply le_lt_trans with (pred p).

   elim H3.

   intros.

   elim H5.

   intros.

   apply (H7 (pred p)).

   apply lt_pred.

   assumption.

   apply flt. assumption. assumption.

   apply lt_pred_n_n.

   apply lt_trans with 1. apply lt_O_Sn. assumption.

   assumption.

   split with (pred p).

   split.

   apply lt_pred.

   assumption.

   apply flt. assumption. assumption.

Qed.



Lemma order_div :

 forall (b : Z) (x p : nat),

 Order b x p -> forall y : nat, 0 < y -> Mod (Exp b y) 1 p -> Divides x y.

Proof.

   intros.

   elim H. intros.

   elim H3. intros.

   elim (divdec y x). intro. assumption. intro.

   elim (notdiv_rem x y H2 H6).

   intro q. intros. elim H7. intro r. intros.

   elim H8. intros. elim H10. intros.

   rewrite H12 in H1.

   elim (lt_not_le r x).

   assumption.

   apply H5.

   assumption.

   apply mod_trans with (Exp b (q * x) * Exp b r)%Z.

   apply mod_trans with (Exp (Exp b x) q * Exp b r)%Z.

   pattern (Exp b r) at 1 in |- *.

   replace (Exp b r) with (1 * Exp b r)%Z.

   apply mod_mult_compat.

   apply mod_sym.

   apply mod_exp1.

   assumption.

   apply mod_refl.

   apply Zmult_1_l.

   rewrite mult_comm.

   rewrite exp_mult.

   apply mod_refl.

   rewrite <- exp_plus.

   assumption.

Qed.



Lemma order_le_predp :

 forall (b : Z) (q p : nat), Prime p -> Order b q p -> q <= pred p.

Proof.

   intros.

   elim H. intros.

   elim H0. intros.

   elim H4. intros.

   apply H6.

   apply lt_pred. assumption.

   apply flt.

   assumption.

   intro.

   elim (mod_0not1 p).

   assumption.

   apply mod_trans with (Exp b q).

   apply mod_sym.

   apply moda0_exp_compat.

   unfold gt in |- *.

   unfold gt in H1.

   unfold lt in |- *.

   apply lt_le_weak.

   assumption.

   assumption.

   assumption.

   assumption.

Qed.

