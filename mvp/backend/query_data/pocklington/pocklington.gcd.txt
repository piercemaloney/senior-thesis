
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
(* lemmas:
Global Set Asymmetric Patterns.

Require Import ZArith.
Require Import EqNat.

Lemma predminus1 : forall n : nat, pred n = n - 1.

Lemma le_mult_l : forall p q : nat, p <= q -> forall r : nat, r * p <= r * q.

Lemma lt_plus_plus : forall n m p q : nat, n < m -> p < q -> n + p < m + q.

Lemma lt_mult_l :
 forall p q : nat, p < q -> forall r : nat, S r * p < S r * q.

Lemma le_mult_r : forall p q : nat, p <= q -> forall r : nat, p * r <= q * r.

Lemma sqrbound : forall p q : nat, p * p <= p * q \/ q * q <= p * q.

Lemma le_n_nm : forall n m : nat, n <= n * S m.

Lemma le_n_mn : forall n m : nat, n <= S m * n.

Lemma le_n_nn : forall n : nat, n <= n * n.

Lemma lt_n_nm : forall n m : nat, 0 < n -> 1 < m -> n < n * m. 

Lemma sqr_ascend : forall n : nat, n > 1 -> n < n * n.

Lemma witness_le : forall x y : nat, (exists q : nat, x + q = y) -> x <= y.

Lemma le_witness : forall x y : nat, x <= y -> exists q : nat, x + q = y.

Lemma lt_witness :
 forall x y : nat, x < y -> exists q : nat, x + q = y /\ 0 < q.

Lemma le_le_mult : forall b a c d : nat, a <= b -> c <= d -> a * c <= b * d.

Lemma lt_lt_mult : forall a b c d : nat, a < b -> c < d -> a * c < b * d.

Lemma lt_n_nm_m_gt_1 : forall a b : nat, a < a * b -> b > 1.

Lemma n0n1_or_gt : forall n : nat, n = 0 \/ n = 1 \/ n > 1.

Lemma lt_multpred_pp : forall p : nat, p > 1 -> pred p * pred p < p * p.

Lemma le_diff0 : forall b a c : nat, a <= b -> a = b + c -> c = 0.

Lemma simpl_lt_mult_l : forall a b c : nat, a * b < a * c -> b < c.

Lemma simpl_le_mult_l : forall a b c : nat, 0 < a -> a * b <= a * c -> b <= c.

Lemma simpl_eq_mult_l : forall a b c : nat, 0 < a -> a * b = a * c -> b = c.

Lemma mult_ppq_p0q1 : forall p q : nat, p = p * q -> p = 0 \/ q = 1.

Lemma mult_pq1_p1q1 : forall p q : nat, p * q = 1 -> p = 1 /\ q = 1.

Lemma Zmult_ab0a0b0 : forall a b : Z, (a * b)%Z = 0%Z -> a = 0%Z \/ b = 0%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zopp_lt_gt_0 : forall x : Z, (x < 0)%Z -> (- x > 0)%Z.

Lemma Zlt_neq : forall x y : Z, (x < y)%Z -> x <> y.

Lemma Zgt_neq : forall x y : Z, (x > y)%Z -> x <> y.

Lemma S_inj : forall n m : nat, S n = S m -> n = m.

Lemma Zlt_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p < q)%Z -> (r * p < r * q)%Z.

Lemma Zle_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p <= q)%Z -> (r * p <= r * q)%Z. *)
Require Import natZ.
(* natZ:
Require Import ZArith.
Require Import EqNat.

Require Import lemmas.

Lemma abs_opp : forall x : Z, Zabs_nat x = Zabs_nat (- x).

Lemma inj_abs_pos : forall x : Z, (x >= 0)%Z -> Z_of_nat (Zabs_nat x) = x.

Lemma inj_abs_neg :
 forall x : Z, (x < 0)%Z -> Z_of_nat (Zabs_nat x) = (- x)%Z.

Lemma abs_inj : forall n : nat, Zabs_nat (Z_of_nat n) = n.

Lemma abs_mult : forall x y : Z, Zabs_nat (x * y) = Zabs_nat x * Zabs_nat y.

Lemma isnat_inj_abs :
 forall (x : Z) (n : nat), x = Z_of_nat n -> n = Zabs_nat x.

Lemma isnat_abs_inj :
 forall (x : Z) (n : nat), (0 <= x)%Z -> n = Zabs_nat x -> x = Z_of_nat n.

Lemma isnat_plus : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x + y)%Z.

Lemma isnat_mult : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z.

Lemma lezle :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Zabs_nat x <= Zabs_nat y.

Lemma gtzgt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x > y)%Z -> Zabs_nat x > Zabs_nat y.

Lemma ltzlt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Zabs_nat x < Zabs_nat y.

Lemma abs_plus_pos :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Zabs_nat (x + y) = Zabs_nat x + Zabs_nat y.

Lemma abs_minus_pos :
 forall x y : Z,
 (0 <= x)%Z ->
 (0 <= y)%Z -> (x >= y)%Z -> Zabs_nat (x - y) = Zabs_nat x - Zabs_nat y.

Lemma abs_pred_pos :
 forall x : Z, (0 < x)%Z -> pred (Zabs_nat x) = Zabs_nat (x - 1).

Lemma abs_neq_lt : forall x : Z, x <> 0%Z -> 0 < Zabs_nat x.

Lemma nat_ge_0 : forall n : nat, (Z_of_nat n >= 0)%Z. *)
Require Import divides.
(* divides:
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import exp.

Definition Divides (n m : nat) : Prop := exists q : nat, m = n * q.

Lemma div_refl : forall a : nat, Divides a a.

Lemma div_trans :
 forall p q r : nat, Divides p q -> Divides q r -> Divides p r.

Lemma div_antisym : forall a b : nat, Divides a b -> Divides b a -> a = b.

Lemma div_le1 : forall n d : nat, Divides d (S n) -> d <= S n.

Lemma div_le : forall d n : nat, 0 < n -> Divides d n -> d <= n.

Definition bDivides (d n : nat) :=
  n = 0 \/ (exists q : nat, q < S n /\ n = d * q).

Lemma divbdiv : forall n d : nat, Divides d n <-> bDivides d n.

Lemma bdivdec : forall n d : nat, bDivides d n \/ ~ bDivides d n.

Lemma divdec : forall n d : nat, Divides d n \/ ~ Divides d n.

Theorem sqrdivbound :
 forall n d : nat,
 Divides d n ->
 exists x : nat, Divides x n /\ x * x <= n /\ (x = d \/ d * x = n).

Theorem div_rem :
 forall d n : nat,
 d > 0 -> exists q : nat, (exists r : nat, 0 <= r /\ r < d /\ n = q * d + r).

Lemma div_rem0 :
 forall n d q r : nat, n = q * d + r -> r < d -> Divides d n -> r = 0.

Theorem notdiv_rem :
 forall d n : nat,
 0 < d ->
 ~ Divides d n ->
 exists q : nat, (exists r : nat, 0 < r /\ r < d /\ n = q * d + r).

Lemma div_plus_compat :
 forall a b c : nat, Divides a b -> Divides a c -> Divides a (b + c).

Lemma div_minus_compat :
 forall a b d : nat, Divides d a -> Divides d b -> Divides d (a - b).

Lemma div_mult_compat_l :
 forall a b c : nat, Divides a b -> Divides a (b * c).

Lemma div_absexp_compat :
 forall (b : Z) (d : nat),
 Divides d (Zabs_nat b) -> forall n : nat, Divides d (Zabs_nat (Exp b (S n))).

Lemma div_plus_r :
 forall a b d : nat, Divides d a -> Divides d (a + b) -> Divides d b.

Definition ZDivides (x y : Z) : Prop := exists q : Z, y = (x * q)%Z.

Lemma zdivdiv :
 forall a b : Z, ZDivides a b -> Divides (Zabs_nat a) (Zabs_nat b).

Lemma divzdiv :
 forall a b : Z, Divides (Zabs_nat a) (Zabs_nat b) -> ZDivides a b.

Lemma zdivdec : forall x d : Z, ZDivides d x \/ ~ ZDivides d x. 

Lemma zdiv_plus_r :
 forall a b d : Z, ZDivides d a -> ZDivides d (a + b) -> ZDivides d b.

Lemma zdiv_plus_compat :
 forall a b c : Z, ZDivides a b -> ZDivides a c -> ZDivides a (b + c).

Lemma zdiv_mult_compat_l :
 forall a b c : Z, ZDivides a b -> ZDivides a (b * c).

Theorem zdiv_rem :
 forall d n : Z,
 (d > 0)%Z ->
 exists q : Z, (exists r : Z, (0 <= r < d)%Z /\ n = (q * d + r)%Z). *)
Require Import modulo.
(* modulo:
Require Import ZArith.

Require Import lemmas.
Require Import natZ.
Require Import exp.
Require Import divides.

Definition Mod (a b : Z) (n : nat) :=
  exists q : Z, a = (b + Z_of_nat n * q)%Z.

Lemma modpq_modp : forall (a b : Z) (p q : nat), Mod a b (p * q) -> Mod a b p.

Lemma mod_refl : forall (a : Z) (n : nat), Mod a a n.

Lemma mod_sym : forall (a b : Z) (n : nat), Mod a b n -> Mod b a n.

Lemma mod_trans :
 forall (a b c : Z) (n : nat), Mod a b n -> Mod b c n -> Mod a c n.

Lemma eqmod : forall x y : Z, x = y -> forall n : nat, Mod x y n.

Lemma mod_plus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a + c) (b + d) n.

Lemma mod_mult_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a * c) (b * d) n.

Lemma mod_sqr_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (a * a) (b * b) n.

Lemma mod_exp_compat :
 forall (a b : Z) (n : nat),
 Mod a b n -> forall m : nat, Mod (Exp a m) (Exp b m) n.

Lemma moda0_exp_compat :
 forall (a : Z) (n : nat),
 n > 0 -> Mod a 0 n -> forall m : nat, m > 0 -> Mod (Exp a m) 0 n.

Lemma mod_opp_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (- a) (- b) n.

Lemma mod_minus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a - c) (b - d) n.

Lemma mod_nx_0_n : forall (n : nat) (x : Z), Mod (Z_of_nat n * x) 0 n.

Lemma moddivmin :
 forall (a b : Z) (n : nat), Mod a b n <-> Divides n (Zabs_nat (a - b)).

Lemma moddec : forall (a b : Z) (n : nat), Mod a b n \/ ~ Mod a b n.

Lemma mod_0not1 : forall n : nat, n > 1 -> ~ Mod 0 1 n.

Lemma mod_exp1 :
 forall (a : Z) (n : nat), Mod a 1 n -> forall m : nat, Mod (Exp a m) 1 n.

Lemma mod_repr_non_0 :
 forall (n : nat) (x : Z), (0 < x < Z_of_nat n)%Z -> ~ Mod x 0 n.

Lemma mod_repr_eq :
 forall (p : nat) (x y : Z),
 0 < p ->
 (0 < x < Z_of_nat p)%Z -> (0 < y < Z_of_nat p)%Z -> Mod x y p -> x = y.

Definition ZMod (a b n : Z) := exists q : Z, a = (b + n * q)%Z.

Lemma zmodpq_modp : forall a b p q : Z, ZMod a b (p * q) -> ZMod a b p.

Lemma zmod_refl : forall a n : Z, ZMod a a n.

Lemma zmod_sym : forall a b n : Z, ZMod a b n -> ZMod b a n.

Lemma zmod_trans : forall a b c n : Z, ZMod a b n -> ZMod b c n -> ZMod a c n.

Lemma zeqmod : forall x y : Z, x = y -> forall n : Z, ZMod x y n.

Lemma zmod_plus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a + c) (b + d) n.

Lemma zmod_mult_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a * c) (b * d) n.

Lemma zmod_sqr_compat :
 forall a b n : Z, ZMod a b n -> ZMod (a * a) (b * b) n.

Lemma zmodmod : forall a b n : Z, ZMod a b n -> Mod a b (Zabs_nat n).

Lemma modzmod :
 forall (a b : Z) (n : nat), Mod a b n -> ZMod a b (Z_of_nat n).

Lemma absmodzmod : forall a b n : Z, Mod a b (Zabs_nat n) -> ZMod a b n.

Lemma zmod_exp_compat :
 forall a b n : Z, ZMod a b n -> forall m : Z, ZMod (ZExp a m) (ZExp b m) n.

Lemma zmoda0_exp_compat :
 forall a n : Z,
 (n > 0)%Z -> ZMod a 0 n -> forall m : Z, (m > 0)%Z -> ZMod (ZExp a m) 0 n.

Lemma zmod_opp_compat : forall a b n : Z, ZMod a b n -> ZMod (- a) (- b) n.

Lemma zmod_minus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a - c) (b - d) n.

Lemma zmod_nx_0_n : forall n x : Z, ZMod (n * x) 0 n.

Lemma zmoddivmin : forall a b n : Z, ZMod a b n <-> ZDivides n (a - b).

Lemma zmoddec : forall a b n : Z, ZMod a b n \/ ~ ZMod a b n.

Lemma zmod_0not1 : forall n : Z, (n > 1)%Z -> ~ ZMod 0 1 n.

Lemma zmod_repr_non_0 : forall n x : Z, (0 < x < n)%Z -> ~ ZMod x 0 n. *)

Definition LinComb (c x y : Z) :=
  exists a : Z, (exists b : Z, c = (x * a + y * b)%Z).

Definition LinCombMod (c x y : Z) (n : nat) :=
  exists a : Z, (exists b : Z, Mod c (x * a + y * b) n).

Definition ZLinCombMod (c x y n : Z) :=
  exists a : Z, (exists b : Z, ZMod c (x * a + y * b) n).

Lemma lincombmodzlincombmod :
 forall (c x y : Z) (n : nat),
 LinCombMod c x y n -> ZLinCombMod c x y (Z_of_nat n).
Proof.
   unfold LinCombMod, ZLinCombMod in |- *.
   intros. elim H. intros z Hz. exists z.
   elim Hz. intros b Hb. exists b.
   apply modzmod. assumption.
Qed.

Lemma zlincombmodlincombmod :
 forall c x y n : Z, ZLinCombMod c x y n -> LinCombMod c x y (Zabs_nat n).
Proof.
   unfold ZLinCombMod, LinCombMod in |- *.
   intros. elim H. intros a Ha. exists a.
   elim Ha. intros b Hb. exists b.
   apply zmodmod. assumption.
Qed.

Definition common_div (x y : Z) (d : nat) :=
  Divides d (Zabs_nat x) /\ Divides d (Zabs_nat y).

Definition gcd (x y : Z) (d : nat) :=
  common_div x y d /\ (forall e : nat, common_div x y e -> e <= d).

Lemma gcd_unq :
 forall (d1 d2 : nat) (x y : Z), gcd x y d1 -> gcd x y d2 -> d1 = d2.
Proof.
   unfold gcd in |- *.
   intros.
   elim H.
   elim H0.
   intros.
   apply le_antisym.
   apply H2.
   assumption.
   apply H4.
   assumption.
Qed.

Lemma gcd_sym : forall (d : nat) (x y : Z), gcd x y d -> gcd y x d.
Proof.
   unfold gcd in |- *. unfold common_div in |- *. intros.
   elim H. intros. elim H0. intros.
   split. split.
   assumption. assumption.
   intros.
   elim H4. intros. apply H1. split.
   assumption. assumption.
Qed.

Lemma gcd_opp_l : forall (d : nat) (x y : Z), gcd x y d -> gcd (- x) y d.
Proof.
   unfold gcd in |- *. unfold common_div in |- *. intros.
   elim H. intros. elim H0. intros.
   split.
   split.
   rewrite <- abs_opp.
   assumption.
   assumption.
   intros.
   elim H4. intros.
   apply H1. split.
   rewrite abs_opp.
   assumption.
   assumption.
Qed.

Lemma gcd_opp_r : forall (d : nat) (x y : Z), gcd x y d -> gcd x (- y) d.
Proof.
   unfold gcd in |- *. unfold common_div in |- *. intros.
   elim H. intros. elim H0. intros.
   split.
   split.
   assumption.
   rewrite <- abs_opp.
   assumption.
   intros.
   elim H4. intros.
   apply H1. split.
   assumption.
   rewrite abs_opp.
   assumption.
Qed.

Lemma gcd_0_l : forall d : nat, d > 0 -> gcd 0 (Z_of_nat d) d.
Proof.
   unfold gcd in |- *. unfold common_div in |- *.
   split. split.
   split with 0. simpl in |- *. rewrite <- mult_n_O. reflexivity.
   split with 1. simpl in |- *. rewrite <- mult_n_Sm.
   rewrite <- mult_n_O. simpl in |- *. rewrite abs_inj. reflexivity.
   intros.
   apply div_le.
   assumption.
   elim H0. intros.
   rewrite abs_inj in H2. assumption.
Qed.

Lemma gcd_0_r : forall d : nat, d > 0 -> gcd (Z_of_nat d) 0 d.
Proof.
   intros. apply gcd_sym. apply gcd_0_l. assumption.
Qed.

Lemma euclid_gcd1 :
 forall (d : nat) (x y q r : Z), gcd x y d -> x = (q * y + r)%Z -> gcd r y d.
Proof.
   unfold gcd in |- *. unfold common_div in |- *. intros.
   elim H. intros.
   elim H1. intros.
   split.
   split.
   rewrite <- (abs_inj d). apply zdivdiv.
   apply zdiv_plus_r with (q * y)%Z.
   rewrite Zmult_comm. apply zdiv_mult_compat_l.
   apply divzdiv. rewrite abs_inj. assumption.
   rewrite <- H0. apply divzdiv. rewrite abs_inj. assumption.
   assumption.
   intros.
   elim H5. intros.
   apply H2.
   split.
   rewrite <- (abs_inj e). apply zdivdiv.
   rewrite H0.
   apply zdiv_plus_compat.
   rewrite Zmult_comm. apply zdiv_mult_compat_l.
   apply divzdiv. rewrite abs_inj.
   assumption.
   apply divzdiv. rewrite abs_inj.
   assumption.
   assumption.
Qed.

Theorem euclid_gcd :
 forall (d1 d2 : nat) (x y q r : Z),
 x = (q * y + r)%Z -> gcd x y d1 -> gcd r y d2 -> d1 = d2.
Proof.
   intros.
   apply (gcd_unq d1 d2 r y).
   apply euclid_gcd1 with x q.
   assumption.
   assumption.
   assumption.
Qed.

Lemma gcd_lincomb_nat :
 forall x y d : nat,
 x > 0 ->
 gcd (Z_of_nat x) (Z_of_nat y) d ->
 LinComb (Z_of_nat d) (Z_of_nat x) (Z_of_nat y).
Proof.
   unfold LinComb in |- *. intro x.
   apply (lt_wf_ind x). intros X IH. intros.
   elim (div_rem X y). intro q. intros. elim H1.
   intro r. case r.

   intros.
   elim H2. intros. elim H4. intros.
   rewrite <- plus_n_O in H6.
   split with 1%Z. split with 0%Z.
   rewrite <- Zmult_0_r_reverse. rewrite <- Zplus_0_r_reverse.
   rewrite Zmult_comm. rewrite Zmult_1_l.
   apply Znat.inj_eq.
   apply (euclid_gcd d X (Z_of_nat y) (Z_of_nat X) (Z_of_nat q) 0).
   rewrite <- Zplus_0_r_reverse. rewrite <- Znat.inj_mult. apply Znat.inj_eq. assumption.
   apply gcd_sym. assumption. apply gcd_0_l. assumption.

   intro r1. intros.
   elim H2. intros. elim H4. intros.
   elim (IH (S r1) H5 X d).
   intro delta. intros. elim H7. intro gamma. intros.
   split with (gamma - Z_of_nat q * delta)%Z. split with delta.
   rewrite H6. rewrite H8.
   unfold Zminus in |- *. rewrite Zmult_plus_distr_r.
   rewrite Znat.inj_plus. rewrite Zmult_plus_distr_l.
   rewrite Znat.inj_mult. rewrite <- Zopp_mult_distr_l_reverse.
   rewrite (Zmult_assoc (Z_of_nat X)).
   rewrite (Zmult_comm (Z_of_nat X) (- Z_of_nat q)).
   rewrite Zopp_mult_distr_l_reverse. rewrite Zopp_mult_distr_l_reverse.
   rewrite (Zplus_assoc_reverse (Z_of_nat X * gamma)).
   rewrite <- Znat.inj_mult.
   rewrite (Zplus_assoc (- (Z_of_nat (q * X) * delta))). 
   rewrite Zplus_opp_l. simpl in |- *. apply Zplus_comm.
   apply gt_Sn_O.
   apply
    (euclid_gcd1 d (Z_of_nat y) (Z_of_nat X) (Z_of_nat q) (Z_of_nat (S r1))).
   apply gcd_sym. assumption.
   rewrite <- Znat.inj_mult. rewrite <- Znat.inj_plus. apply Znat.inj_eq. assumption.
   assumption.
Qed.

Lemma gcd_lincomb_pos :
 forall (x y : Z) (d : nat),
 (x > 0)%Z -> gcd x y d -> LinComb (Z_of_nat d) x y.
Proof.
   intros.
   elim (Zle_or_lt 0 y).

   intro. rewrite <- (inj_abs_pos x). rewrite <- (inj_abs_pos y).
   apply gcd_lincomb_nat.
   change (Zabs_nat x > Zabs_nat 0) in |- *.
   apply gtzgt. apply Zlt_le_weak. apply Zgt_lt. assumption.
   unfold Zle in |- *. simpl in |- *. discriminate.
   assumption.
   rewrite inj_abs_pos. rewrite inj_abs_pos. assumption.
   apply Zle_ge. assumption.
   apply Zle_ge. apply Zlt_le_weak. apply Zgt_lt. assumption.
   apply Zle_ge. assumption.
   apply Zle_ge. apply Zlt_le_weak. apply Zgt_lt. assumption.

   intro. rewrite <- (inj_abs_pos x).
   replace y with (- - y)%Z. rewrite <- (inj_abs_neg y).
   elim (gcd_lincomb_nat (Zabs_nat x) (Zabs_nat y) d).
   intro alpha. intros. elim H2. intro beta. intros.
   split with alpha. split with (- beta)%Z.
   rewrite <- Zopp_mult_distr_r. rewrite (Zmult_comm (- Z_of_nat (Zabs_nat y))).
   rewrite <- Zopp_mult_distr_r. rewrite Zopp_involutive. rewrite (Zmult_comm beta).
   assumption.
   change (Zabs_nat x > Zabs_nat 0) in |- *. apply gtzgt.
   apply Zlt_le_weak. apply Zgt_lt. assumption.
   unfold Zle in |- *. simpl in |- *. discriminate.
   assumption.
   rewrite inj_abs_pos. rewrite inj_abs_neg. apply gcd_opp_r. assumption.
   assumption.
   apply Zle_ge. apply Zlt_le_weak. apply Zgt_lt. assumption.
   assumption.
   apply Zopp_involutive.
   apply Zle_ge. apply Zlt_le_weak. apply Zgt_lt. assumption.
Qed.

Theorem gcd_lincomb :
 forall (x y : Z) (d : nat),
 x <> 0%Z -> gcd x y d -> LinComb (Z_of_nat d) x y.
Proof.
   intros.
   elim (Zle_or_lt 0 x).
   intro.
   elim (Zle_lt_or_eq 0 x).

   intro.
   apply gcd_lincomb_pos.
   apply Zlt_gt.
   assumption.
   assumption.

   intro.
   elim H.
   rewrite H2.
   reflexivity.
   assumption.

   intro.
   elim (gcd_lincomb_pos (- x) y d). intro alpha. intros.
   elim H2. intro beta. intros.
   split with (- alpha)%Z. split with beta.
   rewrite H3.
   rewrite (Zmult_comm x). rewrite Zopp_mult_distr_l_reverse. rewrite Zopp_mult_distr_l_reverse.
   rewrite (Zmult_comm alpha). reflexivity.
   apply Zopp_lt_gt_0. assumption. apply gcd_opp_l. assumption.
Qed.
