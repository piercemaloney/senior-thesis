

Require Import ZArith.



Require Import lemmas.
(* lemmas:
Global Set Asymmetric Patterns.

Require Import ZArith.
Require Import EqNat.

Lemma predminus1 : forall n : nat, pred n = n - 1.

Lemma le_mult_l : forall p q : nat, p <= q -> forall r : nat, r * p <= r * q.

Lemma lt_plus_plus : forall n m p q : nat, n < m -> p < q -> n + p < m + q.

Lemma lt_mult_l :
 forall p q : nat, p < q -> forall r : nat, S r * p < S r * q.

Lemma le_mult_r : forall p q : nat, p <= q -> forall r : nat, p * r <= q * r.

Lemma sqrbound : forall p q : nat, p * p <= p * q \/ q * q <= p * q.

Lemma le_n_nm : forall n m : nat, n <= n * S m.

Lemma le_n_mn : forall n m : nat, n <= S m * n.

Lemma le_n_nn : forall n : nat, n <= n * n.

Lemma lt_n_nm : forall n m : nat, 0 < n -> 1 < m -> n < n * m. 

Lemma sqr_ascend : forall n : nat, n > 1 -> n < n * n.

Lemma witness_le : forall x y : nat, (exists q : nat, x + q = y) -> x <= y.

Lemma le_witness : forall x y : nat, x <= y -> exists q : nat, x + q = y.

Lemma lt_witness :
 forall x y : nat, x < y -> exists q : nat, x + q = y /\ 0 < q.

Lemma le_le_mult : forall b a c d : nat, a <= b -> c <= d -> a * c <= b * d.

Lemma lt_lt_mult : forall a b c d : nat, a < b -> c < d -> a * c < b * d.

Lemma lt_n_nm_m_gt_1 : forall a b : nat, a < a * b -> b > 1.

Lemma n0n1_or_gt : forall n : nat, n = 0 \/ n = 1 \/ n > 1.

Lemma lt_multpred_pp : forall p : nat, p > 1 -> pred p * pred p < p * p.

Lemma le_diff0 : forall b a c : nat, a <= b -> a = b + c -> c = 0.

Lemma simpl_lt_mult_l : forall a b c : nat, a * b < a * c -> b < c.

Lemma simpl_le_mult_l : forall a b c : nat, 0 < a -> a * b <= a * c -> b <= c.

Lemma simpl_eq_mult_l : forall a b c : nat, 0 < a -> a * b = a * c -> b = c.

Lemma mult_ppq_p0q1 : forall p q : nat, p = p * q -> p = 0 \/ q = 1.

Lemma mult_pq1_p1q1 : forall p q : nat, p * q = 1 -> p = 1 /\ q = 1.

Lemma Zmult_ab0a0b0 : forall a b : Z, (a * b)%Z = 0%Z -> a = 0%Z \/ b = 0%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zopp_lt_gt_0 : forall x : Z, (x < 0)%Z -> (- x > 0)%Z.

Lemma Zlt_neq : forall x y : Z, (x < y)%Z -> x <> y.

Lemma Zgt_neq : forall x y : Z, (x > y)%Z -> x <> y.

Lemma S_inj : forall n m : nat, S n = S m -> n = m.

Lemma Zlt_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p < q)%Z -> (r * p < r * q)%Z.

Lemma Zle_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p <= q)%Z -> (r * p <= r * q)%Z. *)

Require Import natZ.
(* natZ:
Require Import ZArith.
Require Import EqNat.

Require Import lemmas.

Lemma abs_opp : forall x : Z, Zabs_nat x = Zabs_nat (- x).

Lemma inj_abs_pos : forall x : Z, (x >= 0)%Z -> Z_of_nat (Zabs_nat x) = x.

Lemma inj_abs_neg :
 forall x : Z, (x < 0)%Z -> Z_of_nat (Zabs_nat x) = (- x)%Z.

Lemma abs_inj : forall n : nat, Zabs_nat (Z_of_nat n) = n.

Lemma abs_mult : forall x y : Z, Zabs_nat (x * y) = Zabs_nat x * Zabs_nat y.

Lemma isnat_inj_abs :
 forall (x : Z) (n : nat), x = Z_of_nat n -> n = Zabs_nat x.

Lemma isnat_abs_inj :
 forall (x : Z) (n : nat), (0 <= x)%Z -> n = Zabs_nat x -> x = Z_of_nat n.

Lemma isnat_plus : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x + y)%Z.

Lemma isnat_mult : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z.

Lemma lezle :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Zabs_nat x <= Zabs_nat y.

Lemma gtzgt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x > y)%Z -> Zabs_nat x > Zabs_nat y.

Lemma ltzlt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Zabs_nat x < Zabs_nat y.

Lemma abs_plus_pos :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Zabs_nat (x + y) = Zabs_nat x + Zabs_nat y.

Lemma abs_minus_pos :
 forall x y : Z,
 (0 <= x)%Z ->
 (0 <= y)%Z -> (x >= y)%Z -> Zabs_nat (x - y) = Zabs_nat x - Zabs_nat y.

Lemma abs_pred_pos :
 forall x : Z, (0 < x)%Z -> pred (Zabs_nat x) = Zabs_nat (x - 1).

Lemma abs_neq_lt : forall x : Z, x <> 0%Z -> 0 < Zabs_nat x.

Lemma nat_ge_0 : forall n : nat, (Z_of_nat n >= 0)%Z. *)



Fixpoint Exp (a : Z) (n : nat) {struct n} : Z :=

  match n with

  | O => 1%Z

  | S m => (a * Exp a m)%Z

  end.



Lemma exp_0 : forall n : nat, Exp 0 (S n) = 0%Z.

Proof.

   simpl in |- *. intros. reflexivity.

Qed.



Lemma exp_1 : forall n : nat, Exp 1 n = 1%Z.

Proof.

   simple induction n.

   simpl in |- *. reflexivity.

   simpl in |- *. intros m IH. rewrite IH. reflexivity.

Qed.



Lemma exp_S : forall (a : Z) (n : nat), Exp a (S n) = (a * Exp a n)%Z.

Proof.

   simpl in |- *. reflexivity.

Qed.



Lemma exp_plus :

 forall (a : Z) (n m : nat), Exp a (n + m) = (Exp a n * Exp a m)%Z.

Proof.

   simple induction n.

   simpl in |- *. intros. elim (Exp a m). reflexivity. reflexivity. reflexivity.

   intros n1 IH. simpl in |- *. intros.

   rewrite (IH m).

   apply Zmult_assoc.

Qed.



Lemma exp_abn :

 forall (a b : Z) (n : nat), Exp (a * b) n = (Exp a n * Exp b n)%Z.

Proof.

   simple induction n.

   simpl in |- *. reflexivity.

   intros m IH. simpl in |- *.

   rewrite IH.

   rewrite (Zmult_assoc (a * Exp a m) b (Exp b m)).

   rewrite (Zmult_assoc_reverse a (Exp a m) b).

   rewrite (Zmult_comm (Exp a m) b).

   rewrite (Zmult_assoc a b (Exp a m)).

   apply Zmult_assoc.

Qed.



Lemma exp_mult : forall (a : Z) (n m : nat), Exp a (n * m) = Exp (Exp a n) m.

Proof.

   simple induction n.

   simpl in |- *. intro. rewrite exp_1. reflexivity.

   intros m IH. simpl in |- *. intros.

   rewrite exp_plus.

   rewrite exp_abn.

   rewrite IH.

   reflexivity.

Qed.



Lemma exp_not0 : forall a : Z, a <> 0%Z -> forall m : nat, Exp a m <> 0%Z.

Proof.

   intros a Ha. simple induction m.

   simpl in |- *. discriminate.

   intros n IH. simpl in |- *. intro.

   elim (Zmult_ab0a0b0 a (Exp a n)).

   assumption. assumption. assumption.

Qed.



Lemma exp_eq : forall (n m : nat) (a : Z), n = m -> Exp a n = Exp a m.

Proof.

   intros. rewrite H. reflexivity.

Qed.



Lemma exp_pred_succ : forall (a : Z) (n : nat), Exp a (pred (S n)) = Exp a n.

Proof.

   intros. simpl in |- *. reflexivity.

Qed.



Definition ZExp (a n : Z) : Z :=

  match n with

  | Z0 => 1%Z

  | Zpos p => Exp a (nat_of_P p)

  | Zneg p => Exp a (nat_of_P p)

  end.



Lemma zexp_pred_succ : forall a x : Z, ZExp a (x + 1 - 1) = ZExp a x.

Proof.

   unfold Zminus in |- *.

   intros.

   rewrite Zplus_assoc_reverse.

   rewrite Zplus_opp_r.

   rewrite <- Zplus_0_r_reverse.

   reflexivity.

Qed.



Lemma zexp_eq : forall x y a : Z, x = y -> ZExp a x = ZExp a y.

Proof.

   intros.

   rewrite H.

   reflexivity.

Qed.



Lemma inj_zexp : forall (n : nat) (a : Z), ZExp a (Z_of_nat n) = Exp a n.

Proof.

   simple induction n.

   simpl in |- *. reflexivity.

   intros m IH. intros.

   simpl in |- *. rewrite nat_of_P_o_P_of_succ_nat_eq_succ.

   simpl in |- *. reflexivity.

Qed.



Lemma expzexp : forall x a : Z, ZExp a x = Exp a (Zabs_nat x).

Proof.

   intros.

   induction  x as [| p| p].

   simpl in |- *. reflexivity.

   simpl in |- *. reflexivity.

   simpl in |- *. reflexivity.

Qed.



Lemma zexp_S1 :

 forall a n : Z, (0 <= n)%Z -> ZExp a (n + 1) = (a * ZExp a n)%Z.

Proof.

   intros.

   rewrite expzexp.

   rewrite expzexp.

   rewrite abs_plus_pos.

   rewrite plus_comm.

   change (Exp a (S (Zabs_nat n)) = (a * Exp a (Zabs_nat n))%Z) in |- *.

   apply exp_S.

   assumption.

   unfold Zle in |- *.

   simpl in |- *.

   discriminate.

Qed.



Lemma zexp_S :

 forall a n : Z, (0 <= n)%Z -> ZExp a (Zsucc n) = (a * ZExp a n)%Z.

Proof.

   intros.

   change (ZExp a (n + 1) = (a * ZExp a n)%Z) in |- *.

   apply zexp_S1.

   assumption.

Qed.



Lemma zexp_plus :

 forall a n m : Z,

 (0 <= n)%Z -> (0 <= m)%Z -> ZExp a (n + m) = (ZExp a n * ZExp a m)%Z.

Proof.

   intros.

   rewrite expzexp.

   rewrite expzexp.

   rewrite expzexp.

   rewrite abs_plus_pos.

   apply exp_plus. assumption. assumption.

Qed.



Lemma zexp_mult :

 forall a n m : Z,

 (0 <= n)%Z -> (0 <= m)%Z -> ZExp a (n * m) = ZExp (ZExp a n) m.

Proof.

   intros.

   rewrite expzexp.

   rewrite expzexp.

   rewrite expzexp.

   rewrite abs_mult.

   apply exp_mult.

Qed.
