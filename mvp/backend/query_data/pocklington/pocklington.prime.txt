
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
(* lemmas:
Global Set Asymmetric Patterns.

Require Import ZArith.
Require Import EqNat.

Lemma predminus1 : forall n : nat, pred n = n - 1.

Lemma le_mult_l : forall p q : nat, p <= q -> forall r : nat, r * p <= r * q.

Lemma lt_plus_plus : forall n m p q : nat, n < m -> p < q -> n + p < m + q.

Lemma lt_mult_l :
 forall p q : nat, p < q -> forall r : nat, S r * p < S r * q.

Lemma le_mult_r : forall p q : nat, p <= q -> forall r : nat, p * r <= q * r.

Lemma sqrbound : forall p q : nat, p * p <= p * q \/ q * q <= p * q.

Lemma le_n_nm : forall n m : nat, n <= n * S m.

Lemma le_n_mn : forall n m : nat, n <= S m * n.

Lemma le_n_nn : forall n : nat, n <= n * n.

Lemma lt_n_nm : forall n m : nat, 0 < n -> 1 < m -> n < n * m. 

Lemma sqr_ascend : forall n : nat, n > 1 -> n < n * n.

Lemma witness_le : forall x y : nat, (exists q : nat, x + q = y) -> x <= y.

Lemma le_witness : forall x y : nat, x <= y -> exists q : nat, x + q = y.

Lemma lt_witness :
 forall x y : nat, x < y -> exists q : nat, x + q = y /\ 0 < q.

Lemma le_le_mult : forall b a c d : nat, a <= b -> c <= d -> a * c <= b * d.

Lemma lt_lt_mult : forall a b c d : nat, a < b -> c < d -> a * c < b * d.

Lemma lt_n_nm_m_gt_1 : forall a b : nat, a < a * b -> b > 1.

Lemma n0n1_or_gt : forall n : nat, n = 0 \/ n = 1 \/ n > 1.

Lemma lt_multpred_pp : forall p : nat, p > 1 -> pred p * pred p < p * p.

Lemma le_diff0 : forall b a c : nat, a <= b -> a = b + c -> c = 0.

Lemma simpl_lt_mult_l : forall a b c : nat, a * b < a * c -> b < c.

Lemma simpl_le_mult_l : forall a b c : nat, 0 < a -> a * b <= a * c -> b <= c.

Lemma simpl_eq_mult_l : forall a b c : nat, 0 < a -> a * b = a * c -> b = c.

Lemma mult_ppq_p0q1 : forall p q : nat, p = p * q -> p = 0 \/ q = 1.

Lemma mult_pq1_p1q1 : forall p q : nat, p * q = 1 -> p = 1 /\ q = 1.

Lemma Zmult_ab0a0b0 : forall a b : Z, (a * b)%Z = 0%Z -> a = 0%Z \/ b = 0%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zopp_lt_gt_0 : forall x : Z, (x < 0)%Z -> (- x > 0)%Z.

Lemma Zlt_neq : forall x y : Z, (x < y)%Z -> x <> y.

Lemma Zgt_neq : forall x y : Z, (x > y)%Z -> x <> y.

Lemma S_inj : forall n m : nat, S n = S m -> n = m.

Lemma Zlt_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p < q)%Z -> (r * p < r * q)%Z.

Lemma Zle_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p <= q)%Z -> (r * p <= r * q)%Z. *)
Require Import natZ.
(* natZ:
Require Import ZArith.
Require Import EqNat.

Require Import lemmas.

Lemma abs_opp : forall x : Z, Zabs_nat x = Zabs_nat (- x).

Lemma inj_abs_pos : forall x : Z, (x >= 0)%Z -> Z_of_nat (Zabs_nat x) = x.

Lemma inj_abs_neg :
 forall x : Z, (x < 0)%Z -> Z_of_nat (Zabs_nat x) = (- x)%Z.

Lemma abs_inj : forall n : nat, Zabs_nat (Z_of_nat n) = n.

Lemma abs_mult : forall x y : Z, Zabs_nat (x * y) = Zabs_nat x * Zabs_nat y.

Lemma isnat_inj_abs :
 forall (x : Z) (n : nat), x = Z_of_nat n -> n = Zabs_nat x.

Lemma isnat_abs_inj :
 forall (x : Z) (n : nat), (0 <= x)%Z -> n = Zabs_nat x -> x = Z_of_nat n.

Lemma isnat_plus : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x + y)%Z.

Lemma isnat_mult : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z.

Lemma lezle :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Zabs_nat x <= Zabs_nat y.

Lemma gtzgt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x > y)%Z -> Zabs_nat x > Zabs_nat y.

Lemma ltzlt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Zabs_nat x < Zabs_nat y.

Lemma abs_plus_pos :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Zabs_nat (x + y) = Zabs_nat x + Zabs_nat y.

Lemma abs_minus_pos :
 forall x y : Z,
 (0 <= x)%Z ->
 (0 <= y)%Z -> (x >= y)%Z -> Zabs_nat (x - y) = Zabs_nat x - Zabs_nat y.

Lemma abs_pred_pos :
 forall x : Z, (0 < x)%Z -> pred (Zabs_nat x) = Zabs_nat (x - 1).

Lemma abs_neq_lt : forall x : Z, x <> 0%Z -> 0 < Zabs_nat x.

Lemma nat_ge_0 : forall n : nat, (Z_of_nat n >= 0)%Z. *)
Require Import dec.
(* dec:
Require Import Arith.
Require Import ZArith.
Require Import EqNat.

Fixpoint allbefore (P : nat -> Prop) (n : nat) {struct n} : Prop :=
  match n with
  | O => True
  | S x => allbefore P x /\ P x
  end.

Fixpoint exbefore (P : nat -> Prop) (n : nat) {struct n} : Prop :=
  match n with
  | O => False
  | S x => exbefore P x \/ P x
  end.

Theorem allbefore_ok :
 forall (P : nat -> Prop) (n : nat),
 (forall q : nat, q < n -> P q) <-> allbefore P n.

Theorem exbefore_ok :
 forall (P : nat -> Prop) (n : nat),
 (exists q : nat, q < n /\ P q) <-> exbefore P n.

Lemma eqdec : forall n m : nat, n = m \/ n <> m.

Lemma ledec : forall n m : nat, n <= m \/ ~ n <= m.

Lemma ltdec : forall n m : nat, n < m \/ ~ n < m.

Lemma gedec : forall n m : nat, n >= m \/ ~ n >= m.

Lemma gtdec : forall n m : nat, n > m \/ ~ n > m.

Lemma zeqdec : forall x y : Z, x = y \/ x <> y.

Lemma notdec : forall P : Prop, P \/ ~ P -> ~ P \/ ~ ~ P.

Lemma anddec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> P /\ Q \/ ~ (P /\ Q).

Lemma ordec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P \/ Q) \/ ~ (P \/ Q).

Lemma impdec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P -> Q) \/ ~ (P -> Q).

Lemma iffdec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P <-> Q) \/ ~ (P <-> Q).

Theorem alldec :
 forall (P : nat -> Prop) (N : nat),
 (forall n : nat, P n \/ ~ P n) ->
 (forall x : nat, x < N -> P x) \/ ~ (forall x : nat, x < N -> P x).

Theorem exdec :
 forall (P : nat -> Prop) (N : nat),
 (forall n : nat, P n \/ ~ P n) ->
 (exists x : nat, x < N /\ P x) \/ ~ (exists x : nat, x < N /\ P x).

Theorem decDeMorgan :
 forall (N : nat) (P : nat -> Prop),
 (forall n : nat, P n \/ ~ P n) ->
 ((exists x : nat, x < N /\ P x) <-> ~ (forall x : nat, x < N -> ~ P x)).

Definition istrue (b : bool) := if b then True else False.

Lemma beq_nat_ok : forall n m : nat, n = m <-> istrue (beq_nat n m).

Lemma beq_nat_eq : forall n m : nat, n = m <-> beq_nat n m = true.

Lemma beq_nat_neq : forall n m : nat, n <> m <-> beq_nat n m = false.

Lemma zeq_bool_eq : forall x y : Z, x = y <-> Zeq_bool x y = true.

Lemma zeq_bool_neq : forall x y : Z, x <> y <-> Zeq_bool x y = false. *)
Require Import divides.
(* divides:
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import exp.

Definition Divides (n m : nat) : Prop := exists q : nat, m = n * q.

Lemma div_refl : forall a : nat, Divides a a.

Lemma div_trans :
 forall p q r : nat, Divides p q -> Divides q r -> Divides p r.

Lemma div_antisym : forall a b : nat, Divides a b -> Divides b a -> a = b.

Lemma div_le1 : forall n d : nat, Divides d (S n) -> d <= S n.

Lemma div_le : forall d n : nat, 0 < n -> Divides d n -> d <= n.

Definition bDivides (d n : nat) :=
  n = 0 \/ (exists q : nat, q < S n /\ n = d * q).

Lemma divbdiv : forall n d : nat, Divides d n <-> bDivides d n.

Lemma bdivdec : forall n d : nat, bDivides d n \/ ~ bDivides d n.

Lemma divdec : forall n d : nat, Divides d n \/ ~ Divides d n.

Theorem sqrdivbound :
 forall n d : nat,
 Divides d n ->
 exists x : nat, Divides x n /\ x * x <= n /\ (x = d \/ d * x = n).

Theorem div_rem :
 forall d n : nat,
 d > 0 -> exists q : nat, (exists r : nat, 0 <= r /\ r < d /\ n = q * d + r).

Lemma div_rem0 :
 forall n d q r : nat, n = q * d + r -> r < d -> Divides d n -> r = 0.

Theorem notdiv_rem :
 forall d n : nat,
 0 < d ->
 ~ Divides d n ->
 exists q : nat, (exists r : nat, 0 < r /\ r < d /\ n = q * d + r).

Lemma div_plus_compat :
 forall a b c : nat, Divides a b -> Divides a c -> Divides a (b + c).

Lemma div_minus_compat :
 forall a b d : nat, Divides d a -> Divides d b -> Divides d (a - b).

Lemma div_mult_compat_l :
 forall a b c : nat, Divides a b -> Divides a (b * c).

Lemma div_absexp_compat :
 forall (b : Z) (d : nat),
 Divides d (Zabs_nat b) -> forall n : nat, Divides d (Zabs_nat (Exp b (S n))).

Lemma div_plus_r :
 forall a b d : nat, Divides d a -> Divides d (a + b) -> Divides d b.

Definition ZDivides (x y : Z) : Prop := exists q : Z, y = (x * q)%Z.

Lemma zdivdiv :
 forall a b : Z, ZDivides a b -> Divides (Zabs_nat a) (Zabs_nat b).

Lemma divzdiv :
 forall a b : Z, Divides (Zabs_nat a) (Zabs_nat b) -> ZDivides a b.

Lemma zdivdec : forall x d : Z, ZDivides d x \/ ~ ZDivides d x. 

Lemma zdiv_plus_r :
 forall a b d : Z, ZDivides d a -> ZDivides d (a + b) -> ZDivides d b.

Lemma zdiv_plus_compat :
 forall a b c : Z, ZDivides a b -> ZDivides a c -> ZDivides a (b + c).

Lemma zdiv_mult_compat_l :
 forall a b c : Z, ZDivides a b -> ZDivides a (b * c).

Theorem zdiv_rem :
 forall d n : Z,
 (d > 0)%Z ->
 exists q : Z, (exists r : Z, (0 <= r < d)%Z /\ n = (q * d + r)%Z). *)
Require Import modulo.
(* modulo:
Require Import ZArith.

Require Import lemmas.
Require Import natZ.
Require Import exp.
Require Import divides.

Definition Mod (a b : Z) (n : nat) :=
  exists q : Z, a = (b + Z_of_nat n * q)%Z.

Lemma modpq_modp : forall (a b : Z) (p q : nat), Mod a b (p * q) -> Mod a b p.

Lemma mod_refl : forall (a : Z) (n : nat), Mod a a n.

Lemma mod_sym : forall (a b : Z) (n : nat), Mod a b n -> Mod b a n.

Lemma mod_trans :
 forall (a b c : Z) (n : nat), Mod a b n -> Mod b c n -> Mod a c n.

Lemma eqmod : forall x y : Z, x = y -> forall n : nat, Mod x y n.

Lemma mod_plus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a + c) (b + d) n.

Lemma mod_mult_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a * c) (b * d) n.

Lemma mod_sqr_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (a * a) (b * b) n.

Lemma mod_exp_compat :
 forall (a b : Z) (n : nat),
 Mod a b n -> forall m : nat, Mod (Exp a m) (Exp b m) n.

Lemma moda0_exp_compat :
 forall (a : Z) (n : nat),
 n > 0 -> Mod a 0 n -> forall m : nat, m > 0 -> Mod (Exp a m) 0 n.

Lemma mod_opp_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (- a) (- b) n.

Lemma mod_minus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a - c) (b - d) n.

Lemma mod_nx_0_n : forall (n : nat) (x : Z), Mod (Z_of_nat n * x) 0 n.

Lemma moddivmin :
 forall (a b : Z) (n : nat), Mod a b n <-> Divides n (Zabs_nat (a - b)).

Lemma moddec : forall (a b : Z) (n : nat), Mod a b n \/ ~ Mod a b n.

Lemma mod_0not1 : forall n : nat, n > 1 -> ~ Mod 0 1 n.

Lemma mod_exp1 :
 forall (a : Z) (n : nat), Mod a 1 n -> forall m : nat, Mod (Exp a m) 1 n.

Lemma mod_repr_non_0 :
 forall (n : nat) (x : Z), (0 < x < Z_of_nat n)%Z -> ~ Mod x 0 n.

Lemma mod_repr_eq :
 forall (p : nat) (x y : Z),
 0 < p ->
 (0 < x < Z_of_nat p)%Z -> (0 < y < Z_of_nat p)%Z -> Mod x y p -> x = y.

Definition ZMod (a b n : Z) := exists q : Z, a = (b + n * q)%Z.

Lemma zmodpq_modp : forall a b p q : Z, ZMod a b (p * q) -> ZMod a b p.

Lemma zmod_refl : forall a n : Z, ZMod a a n.

Lemma zmod_sym : forall a b n : Z, ZMod a b n -> ZMod b a n.

Lemma zmod_trans : forall a b c n : Z, ZMod a b n -> ZMod b c n -> ZMod a c n.

Lemma zeqmod : forall x y : Z, x = y -> forall n : Z, ZMod x y n.

Lemma zmod_plus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a + c) (b + d) n.

Lemma zmod_mult_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a * c) (b * d) n.

Lemma zmod_sqr_compat :
 forall a b n : Z, ZMod a b n -> ZMod (a * a) (b * b) n.

Lemma zmodmod : forall a b n : Z, ZMod a b n -> Mod a b (Zabs_nat n).

Lemma modzmod :
 forall (a b : Z) (n : nat), Mod a b n -> ZMod a b (Z_of_nat n).

Lemma absmodzmod : forall a b n : Z, Mod a b (Zabs_nat n) -> ZMod a b n.

Lemma zmod_exp_compat :
 forall a b n : Z, ZMod a b n -> forall m : Z, ZMod (ZExp a m) (ZExp b m) n.

Lemma zmoda0_exp_compat :
 forall a n : Z,
 (n > 0)%Z -> ZMod a 0 n -> forall m : Z, (m > 0)%Z -> ZMod (ZExp a m) 0 n.

Lemma zmod_opp_compat : forall a b n : Z, ZMod a b n -> ZMod (- a) (- b) n.

Lemma zmod_minus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a - c) (b - d) n.

Lemma zmod_nx_0_n : forall n x : Z, ZMod (n * x) 0 n.

Lemma zmoddivmin : forall a b n : Z, ZMod a b n <-> ZDivides n (a - b).

Lemma zmoddec : forall a b n : Z, ZMod a b n \/ ~ ZMod a b n.

Lemma zmod_0not1 : forall n : Z, (n > 1)%Z -> ~ ZMod 0 1 n.

Lemma zmod_repr_non_0 : forall n x : Z, (0 < x < n)%Z -> ~ ZMod x 0 n. *)
Require Import list.
(* list:
Require Import Arith.
Require Import ZArith.
Require Import EqNat.

Require Import dec.
Require Import natZ.

Inductive list (A : Set) : Set :=
  | Nil : list A
  | Cons : A -> list A -> list A.

Fixpoint length (A : Set) (l : list A) {struct l} : nat :=
  match l with
  | Nil => 0
  | Cons a r => S (length A r)
  end.

Lemma length_0 : forall (A : Set) (l : list A), length A l = 0 -> l = Nil A.

Lemma length_S :
 forall (A : Set) (l : list A) (n : nat),
 length A l = S n ->
 exists h : A, (exists t : list A, l = Cons A h t /\ length A t = n).

Fixpoint map (A B : Set) (f : A -> B) (l : list A) {struct l} : 
 list B :=
  match l with
  | Nil => Nil B
  | Cons a r => Cons B (f a) (map A B f r)
  end.

Notation Map := (map _ _) (only parsing).

Lemma map_length :
 forall (A B : Set) (f : A -> B) (l : list A),
 length A l = length B (map A B f l).

Fixpoint alllist (A : Set) (P : A -> Prop) (qlist : list A) {struct qlist} :
 Prop :=
  match qlist with
  | Nil => True
  | Cons m l => P m /\ alllist A P l
  end.

Lemma alllist_dec :
 forall (A : Set) (P : A -> Prop) (l : list A),
 (forall x : A, P x \/ ~ P x) -> alllist A P l \/ ~ alllist A P l.

Fixpoint exlist (A : Set) (P : A -> Prop) (qlist : list A) {struct qlist} :
 Prop :=
  match qlist with
  | Nil => False
  | Cons m l => P m \/ exlist A P l
  end.

Lemma exlist_dec :
 forall (A : Set) (P : A -> Prop) (l : list A),
 (forall x : A, P x \/ ~ P x) -> exlist A P l \/ ~ exlist A P l.

Definition inlist (A : Set) (a : A) := exlist A (fun b : A => a = b).

Lemma inlist_head_eq :
 forall (A : Set) (x y : A) (l : list A), x = y -> inlist A x (Cons A y l).

Lemma inlist_head_neq :
 forall (A : Set) (x y : A) (l : list A),
 x <> y -> (inlist A x (Cons A y l) <-> inlist A x l).

Lemma inlist_tail :
 forall (A : Set) (x y : A) (l : list A),
 inlist A x l -> inlist A x (Cons A y l).

Lemma inlist_dec :
 forall (A : Set) (x : A) (l : list A),
 (forall a b : A, a = b \/ a <> b) -> inlist A x l \/ ~ inlist A x l.

Theorem alllist_ok :
 forall (A : Set) (P : A -> Prop) (qlist : list A),
 alllist A P qlist <-> (forall q : A, inlist A q qlist -> P q).

Theorem exlist_ok :
 forall (A : Set) (P : A -> Prop) (qlist : list A),
 exlist A P qlist <-> (exists q : A, inlist A q qlist /\ P q).

Definition natlist := list nat.

Fixpoint product (qlist : natlist) : nat :=
  match qlist with
  | Nil => 1
  | Cons m l => m * product l
  end.

Fixpoint drop (q : nat) (qlist : natlist) {struct qlist} : natlist :=
  match qlist with
  | Nil => Nil nat
  | Cons q' l => if beq_nat q q' then l else Cons nat q' (drop q l)
  end.

Definition multDrop (q : nat) (l : natlist) := product (drop q l).

Lemma multdrop_cons_eq :
 forall (q : nat) (l : natlist), multDrop q (Cons nat q l) = product l.

Lemma multdrop_cons_neq :
 forall (p q : nat) (l : natlist),
 p <> q -> multDrop p (Cons nat q l) = q * multDrop p l.

Lemma multdrop_mult :
 forall (qlist : natlist) (q : nat),
 inlist nat q qlist -> q * multDrop q qlist = product qlist.

Definition Zlist := list Z.

Definition allPos : Zlist -> Prop := alllist Z (fun x : Z => (x >= 0)%Z).

Fixpoint zproduct (l : Zlist) : Z :=
  match l with
  | Nil => 1%Z
  | Cons x t => (x * zproduct t)%Z
  end.

Lemma productzproduct :
 forall l : natlist, Z_of_nat (product l) = zproduct (map nat Z Z_of_nat l).

Lemma zproductproduct :
 forall l : Zlist, Zabs_nat (zproduct l) = product (map Z nat Zabs_nat l).

Fixpoint zdrop (x : Z) (l : Zlist) {struct l} : Zlist :=
  match l with
  | Nil => Nil Z
  | Cons h t => if Zeq_bool x h then t else Cons Z h (zdrop x t)
  end.

Lemma zdrop_head_eq :
 forall (x y : Z) (l : Zlist), x = y -> zdrop x (Cons Z y l) = l.

Lemma zdrop_head_neq :
 forall (x y : Z) (l : Zlist),
 x <> y -> zdrop x (Cons Z y l) = Cons Z y (zdrop x l).

Lemma zdrop_length :
 forall (x : Z) (l : Zlist),
 inlist Z x l -> S (length Z (zdrop x l)) = length Z l.

Lemma zdrop_neq_inlist :
 forall (x y : Z) (l : Zlist),
 x <> y -> inlist Z x l -> inlist Z x (zdrop y l).

Lemma zdrop_inlist_weak :
 forall (x y : Z) (l : Zlist), inlist Z x (zdrop y l) -> inlist Z x l.

Lemma zdrop_swap :
 forall (x y : Z) (l : Zlist), zdrop x (zdrop y l) = zdrop y (zdrop x l).

Lemma zdrop_inlist_swap :
 forall (x y : Z) (l : Zlist),
 inlist Z y l -> inlist Z x (zdrop y l) -> inlist Z y (zdrop x l).

Lemma zdrop_product :
 forall (x : Z) (l : Zlist),
 inlist Z x l -> (x * zproduct (zdrop x l))%Z = zproduct l.

Definition zmultDrop (x : Z) (l : Zlist) := zproduct (zdrop x l).

Lemma zmultdrop_cons_eq :
 forall (q : Z) (l : Zlist), zmultDrop q (Cons Z q l) = zproduct l.

Lemma zmultdrop_cons_neq :
 forall (p q : Z) (l : Zlist),
 p <> q -> zmultDrop p (Cons Z q l) = (q * zmultDrop p l)%Z.

Lemma zmultdrop_mult :
 forall (qlist : Zlist) (q : Z),
 inlist Z q qlist -> (q * zmultDrop q qlist)%Z = zproduct qlist.

Lemma multdropzmultdrop :
 forall (q : nat) (qlist : natlist),
 Z_of_nat (multDrop q qlist) =
 zmultDrop (Z_of_nat q) (map nat Z Z_of_nat qlist).

Definition mapmult (a : Z) (l : Zlist) := map Z Z (fun x : Z => (a * x)%Z) l.

Lemma mapmult_image :
 forall (a : Z) (l : Zlist) (x : Z),
 inlist Z x l -> inlist Z (a * x)%Z (mapmult a l).

Lemma mapmult_orig :
 forall (a : Z) (l : Zlist) (y : Z),
 inlist Z y (mapmult a l) -> exists x : Z, inlist Z x l /\ y = (a * x)%Z.

Lemma abs_inj_list :
 forall l : natlist, map _ _ Zabs_nat (map _ _ Z_of_nat l) = l.

Lemma inj_abs_pos_list :
 forall l : Zlist, allPos l -> map _ _ Z_of_nat (map _ _ Zabs_nat l) = l.

Lemma inlist_inj_abs_pos_list :
 forall (q : nat) (l : Zlist),
 allPos l -> inlist nat q (map Z nat Zabs_nat l) -> inlist Z (Z_of_nat q) l. *)

Definition Prime (n : nat) : Prop :=
  n > 1 /\ (forall q : nat, Divides q n -> q = 1 \/ q = n).

Definition bPrime (n : nat) :=
  n > 1 /\ (forall q : nat, q < S n -> Divides q n -> q = 1 \/ q = n).

Lemma primebprime : forall n : nat, Prime n <-> bPrime n.
Proof.
   unfold Prime, bPrime in |- *.
   split.
   intro. elim H.
   split.
   assumption.
   intros.
   apply H1.
   assumption.
   intro. elim H.
   split.
   assumption.
   intros.
   apply H1.
   unfold lt in |- *.
   apply le_n_S.
   apply div_le.
   apply lt_trans with 1. apply lt_O_Sn. assumption.
   assumption.
   assumption.
Qed.

Lemma bprimedec : forall n : nat, bPrime n \/ ~ bPrime n.
Proof.
   unfold bPrime in |- *. intros.
   apply anddec.
   apply gtdec.
   apply (alldec (fun q : nat => Divides q n -> q = 1 \/ q = n) (S n)).
   intros.
   apply impdec.
   apply divdec.
   apply ordec.
   apply eqdec.
   apply eqdec.
Qed.

Lemma primedec : forall n : nat, Prime n \/ ~ Prime n.
Proof.
   intro. elim (primebprime n).
   intros. elim (bprimedec n).
   left. apply (H0 H1).
   right. intro. apply H1. apply (H H2).
Qed.

Lemma nonprime_witness :
 forall n : nat,
 n > 1 -> ~ Prime n -> exists d : nat, 1 < d /\ d < n /\ Divides d n.
Proof.
   intro n. case n.
   intro. elim (lt_n_O 1). assumption.
   intro n1. case n1. intro. elim (lt_irrefl 1). assumption.
   intro n2. intros.
   elim
    (decDeMorgan (S (S n2)) (fun d : nat => 1 < d /\ Divides d (S (S n2)))).
   intros. elim H2. intros.
   split with x.
   elim H3. intros.
   elim H5. intros.
   split.
   assumption.
   split.
   assumption.
   assumption.
   intro. apply H0. unfold Prime in |- *. split. assumption.
   intro q. case q.
   intro. unfold Divides in H4. elim H4. simpl in |- *. intros. discriminate H5.
   intro q1. case q1. left. reflexivity.
   intro q2. intros. right.
   elim (le_lt_or_eq (S (S q2)) (S (S n2))).
   intros. elim (H3 (S (S q2))). assumption.
   split. apply lt_n_S. apply lt_O_Sn. assumption.
   intros. assumption.
   apply div_le1. assumption.
   intros. apply anddec. apply ltdec. apply divdec.
Qed.

Lemma nonprime_sqrwitness :
 forall n : nat,
 n > 1 -> ~ Prime n -> exists d : nat, 1 < d /\ d * d <= n /\ Divides d n.
Proof.
   intros. elim (nonprime_witness n).
   intro d. intros.
   elim (sqrdivbound n d). intro d'. intros.
   elim H2. intros.
   elim H4. intros.
   elim H6.
   intro. split with d'.
   split. rewrite H7. elim H1. tauto.
   split. assumption.
   rewrite H7. elim H1. tauto.
   intro. split with d'. split. apply (lt_n_nm_m_gt_1 d d').
   rewrite H7. elim H1. tauto.
   split. assumption.
   assumption.
   elim H1. tauto.
   assumption.
   assumption.
Qed.

Theorem nonprime_primewitness :
 forall n : nat,
 n > 1 ->
 ~ Prime n -> exists d : nat, 1 < d /\ d * d <= n /\ Divides d n /\ Prime d.
Proof.
   intro. apply (lt_wf_ind n).
   intros N IH. intros.
   elim (nonprime_sqrwitness N). intro x. intros.
   elim H1. intros.
   elim H3. intros.
   elim (primedec x).
   intros.
   split with x.
   split. assumption.
   split. assumption.
   split. assumption.
   assumption.
   intros. elim (IH x). intros.
   elim H7. intros.
   elim H9. intros.
   elim H11.
   intros.
   split with x0.
   split. assumption.
   split. apply le_trans with (x * x).
   apply le_trans with x. assumption. apply le_n_nn. assumption.
   split. apply div_trans with x. assumption. assumption.
   assumption.
   unfold lt in |- *. apply le_trans with (x * x).
   change (x < x * x) in |- *. apply sqr_ascend. assumption.
   assumption. assumption. assumption. assumption. assumption.
Qed.

Theorem primepropdiv :
 forall n : nat,
 n > 1 -> (forall q : nat, Prime q -> Divides q n -> q * q > n) -> Prime n.
Proof.
   intros. elim (primedec n).
   intro. assumption.
   intros. elim (nonprime_primewitness n).
   intros.
   elim H2. intros.
   elim H4. intros.
   elim H6. intros.
   elim (le_not_lt (x * x) n).
   assumption.
   unfold gt in H0. apply H0. assumption. assumption.
   assumption.
   assumption.
Qed.

Lemma primediv1p : forall p n : nat, Prime p -> Divides n p -> n = 1 \/ n = p.
Proof.
   intros.
   unfold Prime in H. elim H. intros.
   apply (H2 n). assumption.
Qed.

Lemma prime2 : Prime 2.
Proof.
   apply primepropdiv.
   auto.
   intro q. case q.
   intros. elim H. intro.
   elim (lt_n_O 1). assumption.
   intro q1. case q1.
   intros. elim H. intro.
   elim (lt_irrefl 1). assumption.
   intro q2. case q2.
   simpl in |- *. intros. auto.
   intro q3. simpl in |- *. intros.
   repeat apply gt_n_S. apply gt_Sn_O.
Qed.

Definition ZPrime (n : Z) : Prop :=
  (n > 1)%Z /\ (forall q : Z, (q >= 0)%Z -> ZDivides q n -> q = 1%Z \/ q = n).

Lemma primezprime : forall n : nat, Prime n -> ZPrime (Z_of_nat n).
Proof.
   unfold Prime, ZPrime in |- *. intros.
   elim H. intros. split.
   change (Z_of_nat n > Z_of_nat 1)%Z in |- *.
   apply Znat.inj_gt. assumption.
   intros. elim (H1 (Zabs_nat q)).
   left. rewrite <- (inj_abs_pos q). rewrite H4.
   simpl in |- *. reflexivity. assumption.
   right. rewrite <- (inj_abs_pos q). rewrite H4.
   reflexivity. assumption.
   rewrite <- (abs_inj n).
   apply zdivdiv. assumption.
Qed.

Lemma zprimeprime : forall n : Z, ZPrime n -> Prime (Zabs_nat n).
Proof.
   unfold ZPrime, Prime in |- *. intros.
   elim H. intros. split.
   change (Zabs_nat n > Zabs_nat 1) in |- *.
   apply gtzgt.
   apply Zle_trans with 1%Z.
   unfold Zle in |- *. simpl in |- *. discriminate.
   apply Zlt_le_weak. apply Zgt_lt. assumption.
   unfold Zle in |- *. simpl in |- *. discriminate.
   assumption.
   intros. elim (H1 (Z_of_nat q)).
   left. rewrite <- (abs_inj q). rewrite H3.
   simpl in |- *. reflexivity.
   right. rewrite <- (abs_inj q). rewrite H3.
   reflexivity. apply nat_ge_0.
   apply divzdiv. rewrite abs_inj. assumption.
Qed.

Lemma zprime2 : ZPrime 2.
Proof.
   change (ZPrime (Z_of_nat 2)) in |- *.
   apply primezprime.
   exact prime2.
Qed.

Lemma zprime2a : ZPrime 2.
Proof.
   exact zprime2.
Qed.

Definition allPrime : natlist -> Prop := alllist nat Prime.

Definition allZPrime : Zlist -> Prop := alllist Z ZPrime.

Lemma allzprimeallpos : forall l : Zlist, allZPrime l -> allPos l.
Proof.
   unfold allZPrime, allPos in |- *.
   simple induction l.
   simpl in |- *. intro. assumption.
   simpl in |- *. intros h t IH H.
   elim H. intros. elim H0. intros.
   split. apply Zle_ge. apply Zle_trans with 1%Z.
   unfold Zle in |- *. simpl in |- *. discriminate.
   apply Zlt_le_weak. apply Zgt_lt. assumption.
   apply IH. assumption.
Qed.

Lemma allprimeallzprime :
 forall l : natlist, allPrime l -> allZPrime (map _ _ Z_of_nat l).
Proof.
   unfold allPrime, allZPrime in |- *.
   simple induction l.
   simpl in |- *. intro. assumption.
   simpl in |- *. intros h t IH H. elim H. intros. split.
   apply primezprime. assumption.
   apply IH. assumption.
Qed.

Lemma allzprimeallprime :
 forall l : Zlist, allZPrime l -> allPrime (map _ _ Zabs_nat l).
Proof.
   unfold allPrime, allZPrime in |- *.
   simple induction l.
   simpl in |- *. intro. assumption.
   simpl in |- *. intros h t IH H. elim H. intros. split.
   apply zprimeprime. assumption.
   apply IH. assumption.
Qed.
