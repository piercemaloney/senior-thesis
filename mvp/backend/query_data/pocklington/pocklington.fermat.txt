

Require Import Arith.

Require Import ZArith.



Require Import lemmas.
(* lemmas:
Global Set Asymmetric Patterns.

Require Import ZArith.
Require Import EqNat.

Lemma predminus1 : forall n : nat, pred n = n - 1.

Lemma le_mult_l : forall p q : nat, p <= q -> forall r : nat, r * p <= r * q.

Lemma lt_plus_plus : forall n m p q : nat, n < m -> p < q -> n + p < m + q.

Lemma lt_mult_l :
 forall p q : nat, p < q -> forall r : nat, S r * p < S r * q.

Lemma le_mult_r : forall p q : nat, p <= q -> forall r : nat, p * r <= q * r.

Lemma sqrbound : forall p q : nat, p * p <= p * q \/ q * q <= p * q.

Lemma le_n_nm : forall n m : nat, n <= n * S m.

Lemma le_n_mn : forall n m : nat, n <= S m * n.

Lemma le_n_nn : forall n : nat, n <= n * n.

Lemma lt_n_nm : forall n m : nat, 0 < n -> 1 < m -> n < n * m. 

Lemma sqr_ascend : forall n : nat, n > 1 -> n < n * n.

Lemma witness_le : forall x y : nat, (exists q : nat, x + q = y) -> x <= y.

Lemma le_witness : forall x y : nat, x <= y -> exists q : nat, x + q = y.

Lemma lt_witness :
 forall x y : nat, x < y -> exists q : nat, x + q = y /\ 0 < q.

Lemma le_le_mult : forall b a c d : nat, a <= b -> c <= d -> a * c <= b * d.

Lemma lt_lt_mult : forall a b c d : nat, a < b -> c < d -> a * c < b * d.

Lemma lt_n_nm_m_gt_1 : forall a b : nat, a < a * b -> b > 1.

Lemma n0n1_or_gt : forall n : nat, n = 0 \/ n = 1 \/ n > 1.

Lemma lt_multpred_pp : forall p : nat, p > 1 -> pred p * pred p < p * p.

Lemma le_diff0 : forall b a c : nat, a <= b -> a = b + c -> c = 0.

Lemma simpl_lt_mult_l : forall a b c : nat, a * b < a * c -> b < c.

Lemma simpl_le_mult_l : forall a b c : nat, 0 < a -> a * b <= a * c -> b <= c.

Lemma simpl_eq_mult_l : forall a b c : nat, 0 < a -> a * b = a * c -> b = c.

Lemma mult_ppq_p0q1 : forall p q : nat, p = p * q -> p = 0 \/ q = 1.

Lemma mult_pq1_p1q1 : forall p q : nat, p * q = 1 -> p = 1 /\ q = 1.

Lemma Zmult_ab0a0b0 : forall a b : Z, (a * b)%Z = 0%Z -> a = 0%Z \/ b = 0%Z.

Lemma Zle_minus : forall a b : Z, (b <= a)%Z -> (0 <= a - b)%Z.

Lemma Zopp_lt_gt_0 : forall x : Z, (x < 0)%Z -> (- x > 0)%Z.

Lemma Zlt_neq : forall x y : Z, (x < y)%Z -> x <> y.

Lemma Zgt_neq : forall x y : Z, (x > y)%Z -> x <> y.

Lemma S_inj : forall n m : nat, S n = S m -> n = m.

Lemma Zlt_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p < q)%Z -> (r * p < r * q)%Z.

Lemma Zle_mult_l :
 forall p q r : Z, (0 < r)%Z -> (p <= q)%Z -> (r * p <= r * q)%Z. *)

Require Import natZ.
(* natZ:
Require Import ZArith.
Require Import EqNat.

Require Import lemmas.

Lemma abs_opp : forall x : Z, Zabs_nat x = Zabs_nat (- x).

Lemma inj_abs_pos : forall x : Z, (x >= 0)%Z -> Z_of_nat (Zabs_nat x) = x.

Lemma inj_abs_neg :
 forall x : Z, (x < 0)%Z -> Z_of_nat (Zabs_nat x) = (- x)%Z.

Lemma abs_inj : forall n : nat, Zabs_nat (Z_of_nat n) = n.

Lemma abs_mult : forall x y : Z, Zabs_nat (x * y) = Zabs_nat x * Zabs_nat y.

Lemma isnat_inj_abs :
 forall (x : Z) (n : nat), x = Z_of_nat n -> n = Zabs_nat x.

Lemma isnat_abs_inj :
 forall (x : Z) (n : nat), (0 <= x)%Z -> n = Zabs_nat x -> x = Z_of_nat n.

Lemma isnat_plus : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x + y)%Z.

Lemma isnat_mult : forall x y : Z, (0 <= x)%Z -> (0 <= y)%Z -> (0 <= x * y)%Z.

Lemma lezle :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x <= y)%Z -> Zabs_nat x <= Zabs_nat y.

Lemma gtzgt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x > y)%Z -> Zabs_nat x > Zabs_nat y.

Lemma ltzlt :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> (x < y)%Z -> Zabs_nat x < Zabs_nat y.

Lemma abs_plus_pos :
 forall x y : Z,
 (0 <= x)%Z -> (0 <= y)%Z -> Zabs_nat (x + y) = Zabs_nat x + Zabs_nat y.

Lemma abs_minus_pos :
 forall x y : Z,
 (0 <= x)%Z ->
 (0 <= y)%Z -> (x >= y)%Z -> Zabs_nat (x - y) = Zabs_nat x - Zabs_nat y.

Lemma abs_pred_pos :
 forall x : Z, (0 < x)%Z -> pred (Zabs_nat x) = Zabs_nat (x - 1).

Lemma abs_neq_lt : forall x : Z, x <> 0%Z -> 0 < Zabs_nat x.

Lemma nat_ge_0 : forall n : nat, (Z_of_nat n >= 0)%Z. *)

Require Import dec.
(* dec:
Require Import Arith.
Require Import ZArith.
Require Import EqNat.

Fixpoint allbefore (P : nat -> Prop) (n : nat) {struct n} : Prop :=
  match n with
  | O => True
  | S x => allbefore P x /\ P x
  end.

Fixpoint exbefore (P : nat -> Prop) (n : nat) {struct n} : Prop :=
  match n with
  | O => False
  | S x => exbefore P x \/ P x
  end.

Theorem allbefore_ok :
 forall (P : nat -> Prop) (n : nat),
 (forall q : nat, q < n -> P q) <-> allbefore P n.

Theorem exbefore_ok :
 forall (P : nat -> Prop) (n : nat),
 (exists q : nat, q < n /\ P q) <-> exbefore P n.

Lemma eqdec : forall n m : nat, n = m \/ n <> m.

Lemma ledec : forall n m : nat, n <= m \/ ~ n <= m.

Lemma ltdec : forall n m : nat, n < m \/ ~ n < m.

Lemma gedec : forall n m : nat, n >= m \/ ~ n >= m.

Lemma gtdec : forall n m : nat, n > m \/ ~ n > m.

Lemma zeqdec : forall x y : Z, x = y \/ x <> y.

Lemma notdec : forall P : Prop, P \/ ~ P -> ~ P \/ ~ ~ P.

Lemma anddec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> P /\ Q \/ ~ (P /\ Q).

Lemma ordec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P \/ Q) \/ ~ (P \/ Q).

Lemma impdec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P -> Q) \/ ~ (P -> Q).

Lemma iffdec :
 forall P Q : Prop, P \/ ~ P -> Q \/ ~ Q -> (P <-> Q) \/ ~ (P <-> Q).

Theorem alldec :
 forall (P : nat -> Prop) (N : nat),
 (forall n : nat, P n \/ ~ P n) ->
 (forall x : nat, x < N -> P x) \/ ~ (forall x : nat, x < N -> P x).

Theorem exdec :
 forall (P : nat -> Prop) (N : nat),
 (forall n : nat, P n \/ ~ P n) ->
 (exists x : nat, x < N /\ P x) \/ ~ (exists x : nat, x < N /\ P x).

Theorem decDeMorgan :
 forall (N : nat) (P : nat -> Prop),
 (forall n : nat, P n \/ ~ P n) ->
 ((exists x : nat, x < N /\ P x) <-> ~ (forall x : nat, x < N -> ~ P x)).

Definition istrue (b : bool) := if b then True else False.

Lemma beq_nat_ok : forall n m : nat, n = m <-> istrue (beq_nat n m).

Lemma beq_nat_eq : forall n m : nat, n = m <-> beq_nat n m = true.

Lemma beq_nat_neq : forall n m : nat, n <> m <-> beq_nat n m = false.

Lemma zeq_bool_eq : forall x y : Z, x = y <-> Zeq_bool x y = true.

Lemma zeq_bool_neq : forall x y : Z, x <> y <-> Zeq_bool x y = false. *)

Require Import list.
(* list:
Require Import Arith.
Require Import ZArith.
Require Import EqNat.

Require Import dec.
Require Import natZ.

Inductive list (A : Set) : Set :=
  | Nil : list A
  | Cons : A -> list A -> list A.

Fixpoint length (A : Set) (l : list A) {struct l} : nat :=
  match l with
  | Nil => 0
  | Cons a r => S (length A r)
  end.

Lemma length_0 : forall (A : Set) (l : list A), length A l = 0 -> l = Nil A.

Lemma length_S :
 forall (A : Set) (l : list A) (n : nat),
 length A l = S n ->
 exists h : A, (exists t : list A, l = Cons A h t /\ length A t = n).

Fixpoint map (A B : Set) (f : A -> B) (l : list A) {struct l} : 
 list B :=
  match l with
  | Nil => Nil B
  | Cons a r => Cons B (f a) (map A B f r)
  end.

Notation Map := (map _ _) (only parsing).

Lemma map_length :
 forall (A B : Set) (f : A -> B) (l : list A),
 length A l = length B (map A B f l).

Fixpoint alllist (A : Set) (P : A -> Prop) (qlist : list A) {struct qlist} :
 Prop :=
  match qlist with
  | Nil => True
  | Cons m l => P m /\ alllist A P l
  end.

Lemma alllist_dec :
 forall (A : Set) (P : A -> Prop) (l : list A),
 (forall x : A, P x \/ ~ P x) -> alllist A P l \/ ~ alllist A P l.

Fixpoint exlist (A : Set) (P : A -> Prop) (qlist : list A) {struct qlist} :
 Prop :=
  match qlist with
  | Nil => False
  | Cons m l => P m \/ exlist A P l
  end.

Lemma exlist_dec :
 forall (A : Set) (P : A -> Prop) (l : list A),
 (forall x : A, P x \/ ~ P x) -> exlist A P l \/ ~ exlist A P l.

Definition inlist (A : Set) (a : A) := exlist A (fun b : A => a = b).

Lemma inlist_head_eq :
 forall (A : Set) (x y : A) (l : list A), x = y -> inlist A x (Cons A y l).

Lemma inlist_head_neq :
 forall (A : Set) (x y : A) (l : list A),
 x <> y -> (inlist A x (Cons A y l) <-> inlist A x l).

Lemma inlist_tail :
 forall (A : Set) (x y : A) (l : list A),
 inlist A x l -> inlist A x (Cons A y l).

Lemma inlist_dec :
 forall (A : Set) (x : A) (l : list A),
 (forall a b : A, a = b \/ a <> b) -> inlist A x l \/ ~ inlist A x l.

Theorem alllist_ok :
 forall (A : Set) (P : A -> Prop) (qlist : list A),
 alllist A P qlist <-> (forall q : A, inlist A q qlist -> P q).

Theorem exlist_ok :
 forall (A : Set) (P : A -> Prop) (qlist : list A),
 exlist A P qlist <-> (exists q : A, inlist A q qlist /\ P q).

Definition natlist := list nat.

Fixpoint product (qlist : natlist) : nat :=
  match qlist with
  | Nil => 1
  | Cons m l => m * product l
  end.

Fixpoint drop (q : nat) (qlist : natlist) {struct qlist} : natlist :=
  match qlist with
  | Nil => Nil nat
  | Cons q' l => if beq_nat q q' then l else Cons nat q' (drop q l)
  end.

Definition multDrop (q : nat) (l : natlist) := product (drop q l).

Lemma multdrop_cons_eq :
 forall (q : nat) (l : natlist), multDrop q (Cons nat q l) = product l.

Lemma multdrop_cons_neq :
 forall (p q : nat) (l : natlist),
 p <> q -> multDrop p (Cons nat q l) = q * multDrop p l.

Lemma multdrop_mult :
 forall (qlist : natlist) (q : nat),
 inlist nat q qlist -> q * multDrop q qlist = product qlist.

Definition Zlist := list Z.

Definition allPos : Zlist -> Prop := alllist Z (fun x : Z => (x >= 0)%Z).

Fixpoint zproduct (l : Zlist) : Z :=
  match l with
  | Nil => 1%Z
  | Cons x t => (x * zproduct t)%Z
  end.

Lemma productzproduct :
 forall l : natlist, Z_of_nat (product l) = zproduct (map nat Z Z_of_nat l).

Lemma zproductproduct :
 forall l : Zlist, Zabs_nat (zproduct l) = product (map Z nat Zabs_nat l).

Fixpoint zdrop (x : Z) (l : Zlist) {struct l} : Zlist :=
  match l with
  | Nil => Nil Z
  | Cons h t => if Zeq_bool x h then t else Cons Z h (zdrop x t)
  end.

Lemma zdrop_head_eq :
 forall (x y : Z) (l : Zlist), x = y -> zdrop x (Cons Z y l) = l.

Lemma zdrop_head_neq :
 forall (x y : Z) (l : Zlist),
 x <> y -> zdrop x (Cons Z y l) = Cons Z y (zdrop x l).

Lemma zdrop_length :
 forall (x : Z) (l : Zlist),
 inlist Z x l -> S (length Z (zdrop x l)) = length Z l.

Lemma zdrop_neq_inlist :
 forall (x y : Z) (l : Zlist),
 x <> y -> inlist Z x l -> inlist Z x (zdrop y l).

Lemma zdrop_inlist_weak :
 forall (x y : Z) (l : Zlist), inlist Z x (zdrop y l) -> inlist Z x l.

Lemma zdrop_swap :
 forall (x y : Z) (l : Zlist), zdrop x (zdrop y l) = zdrop y (zdrop x l).

Lemma zdrop_inlist_swap :
 forall (x y : Z) (l : Zlist),
 inlist Z y l -> inlist Z x (zdrop y l) -> inlist Z y (zdrop x l).

Lemma zdrop_product :
 forall (x : Z) (l : Zlist),
 inlist Z x l -> (x * zproduct (zdrop x l))%Z = zproduct l.

Definition zmultDrop (x : Z) (l : Zlist) := zproduct (zdrop x l).

Lemma zmultdrop_cons_eq :
 forall (q : Z) (l : Zlist), zmultDrop q (Cons Z q l) = zproduct l.

Lemma zmultdrop_cons_neq :
 forall (p q : Z) (l : Zlist),
 p <> q -> zmultDrop p (Cons Z q l) = (q * zmultDrop p l)%Z.

Lemma zmultdrop_mult :
 forall (qlist : Zlist) (q : Z),
 inlist Z q qlist -> (q * zmultDrop q qlist)%Z = zproduct qlist.

Lemma multdropzmultdrop :
 forall (q : nat) (qlist : natlist),
 Z_of_nat (multDrop q qlist) =
 zmultDrop (Z_of_nat q) (map nat Z Z_of_nat qlist).

Definition mapmult (a : Z) (l : Zlist) := map Z Z (fun x : Z => (a * x)%Z) l.

Lemma mapmult_image :
 forall (a : Z) (l : Zlist) (x : Z),
 inlist Z x l -> inlist Z (a * x)%Z (mapmult a l).

Lemma mapmult_orig :
 forall (a : Z) (l : Zlist) (y : Z),
 inlist Z y (mapmult a l) -> exists x : Z, inlist Z x l /\ y = (a * x)%Z.

Lemma abs_inj_list :
 forall l : natlist, map _ _ Zabs_nat (map _ _ Z_of_nat l) = l.

Lemma inj_abs_pos_list :
 forall l : Zlist, allPos l -> map _ _ Z_of_nat (map _ _ Zabs_nat l) = l.

Lemma inlist_inj_abs_pos_list :
 forall (q : nat) (l : Zlist),
 allPos l -> inlist nat q (map Z nat Zabs_nat l) -> inlist Z (Z_of_nat q) l. *)

Require Import exp.
(* exp:
Require Import ZArith.

Require Import lemmas.
Require Import natZ.

Fixpoint Exp (a : Z) (n : nat) {struct n} : Z :=
  match n with
  | O => 1%Z
  | S m => (a * Exp a m)%Z
  end.

Lemma exp_0 : forall n : nat, Exp 0 (S n) = 0%Z.

Lemma exp_1 : forall n : nat, Exp 1 n = 1%Z.

Lemma exp_S : forall (a : Z) (n : nat), Exp a (S n) = (a * Exp a n)%Z.

Lemma exp_plus :
 forall (a : Z) (n m : nat), Exp a (n + m) = (Exp a n * Exp a m)%Z.

Lemma exp_abn :
 forall (a b : Z) (n : nat), Exp (a * b) n = (Exp a n * Exp b n)%Z.

Lemma exp_mult : forall (a : Z) (n m : nat), Exp a (n * m) = Exp (Exp a n) m.

Lemma exp_not0 : forall a : Z, a <> 0%Z -> forall m : nat, Exp a m <> 0%Z.

Lemma exp_eq : forall (n m : nat) (a : Z), n = m -> Exp a n = Exp a m.

Lemma exp_pred_succ : forall (a : Z) (n : nat), Exp a (pred (S n)) = Exp a n.

Definition ZExp (a n : Z) : Z :=
  match n with
  | Z0 => 1%Z
  | Zpos p => Exp a (nat_of_P p)
  | Zneg p => Exp a (nat_of_P p)
  end.

Lemma zexp_pred_succ : forall a x : Z, ZExp a (x + 1 - 1) = ZExp a x.

Lemma zexp_eq : forall x y a : Z, x = y -> ZExp a x = ZExp a y.

Lemma inj_zexp : forall (n : nat) (a : Z), ZExp a (Z_of_nat n) = Exp a n.

Lemma expzexp : forall x a : Z, ZExp a x = Exp a (Zabs_nat x).

Lemma zexp_S1 :
 forall a n : Z, (0 <= n)%Z -> ZExp a (n + 1) = (a * ZExp a n)%Z.

Lemma zexp_S :
 forall a n : Z, (0 <= n)%Z -> ZExp a (Zsucc n) = (a * ZExp a n)%Z.

Lemma zexp_plus :
 forall a n m : Z,
 (0 <= n)%Z -> (0 <= m)%Z -> ZExp a (n + m) = (ZExp a n * ZExp a m)%Z.

Lemma zexp_mult :
 forall a n m : Z,
 (0 <= n)%Z -> (0 <= m)%Z -> ZExp a (n * m) = ZExp (ZExp a n) m. *)

Require Import divides.
(* divides:
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import exp.

Definition Divides (n m : nat) : Prop := exists q : nat, m = n * q.

Lemma div_refl : forall a : nat, Divides a a.

Lemma div_trans :
 forall p q r : nat, Divides p q -> Divides q r -> Divides p r.

Lemma div_antisym : forall a b : nat, Divides a b -> Divides b a -> a = b.

Lemma div_le1 : forall n d : nat, Divides d (S n) -> d <= S n.

Lemma div_le : forall d n : nat, 0 < n -> Divides d n -> d <= n.

Definition bDivides (d n : nat) :=
  n = 0 \/ (exists q : nat, q < S n /\ n = d * q).

Lemma divbdiv : forall n d : nat, Divides d n <-> bDivides d n.

Lemma bdivdec : forall n d : nat, bDivides d n \/ ~ bDivides d n.

Lemma divdec : forall n d : nat, Divides d n \/ ~ Divides d n.

Theorem sqrdivbound :
 forall n d : nat,
 Divides d n ->
 exists x : nat, Divides x n /\ x * x <= n /\ (x = d \/ d * x = n).

Theorem div_rem :
 forall d n : nat,
 d > 0 -> exists q : nat, (exists r : nat, 0 <= r /\ r < d /\ n = q * d + r).

Lemma div_rem0 :
 forall n d q r : nat, n = q * d + r -> r < d -> Divides d n -> r = 0.

Theorem notdiv_rem :
 forall d n : nat,
 0 < d ->
 ~ Divides d n ->
 exists q : nat, (exists r : nat, 0 < r /\ r < d /\ n = q * d + r).

Lemma div_plus_compat :
 forall a b c : nat, Divides a b -> Divides a c -> Divides a (b + c).

Lemma div_minus_compat :
 forall a b d : nat, Divides d a -> Divides d b -> Divides d (a - b).

Lemma div_mult_compat_l :
 forall a b c : nat, Divides a b -> Divides a (b * c).

Lemma div_absexp_compat :
 forall (b : Z) (d : nat),
 Divides d (Zabs_nat b) -> forall n : nat, Divides d (Zabs_nat (Exp b (S n))).

Lemma div_plus_r :
 forall a b d : nat, Divides d a -> Divides d (a + b) -> Divides d b.

Definition ZDivides (x y : Z) : Prop := exists q : Z, y = (x * q)%Z.

Lemma zdivdiv :
 forall a b : Z, ZDivides a b -> Divides (Zabs_nat a) (Zabs_nat b).

Lemma divzdiv :
 forall a b : Z, Divides (Zabs_nat a) (Zabs_nat b) -> ZDivides a b.

Lemma zdivdec : forall x d : Z, ZDivides d x \/ ~ ZDivides d x. 

Lemma zdiv_plus_r :
 forall a b d : Z, ZDivides d a -> ZDivides d (a + b) -> ZDivides d b.

Lemma zdiv_plus_compat :
 forall a b c : Z, ZDivides a b -> ZDivides a c -> ZDivides a (b + c).

Lemma zdiv_mult_compat_l :
 forall a b c : Z, ZDivides a b -> ZDivides a (b * c).

Theorem zdiv_rem :
 forall d n : Z,
 (d > 0)%Z ->
 exists q : Z, (exists r : Z, (0 <= r < d)%Z /\ n = (q * d + r)%Z). *)

Require Import prime.

Require Import modulo.
(* modulo:
Require Import ZArith.

Require Import lemmas.
Require Import natZ.
Require Import exp.
Require Import divides.

Definition Mod (a b : Z) (n : nat) :=
  exists q : Z, a = (b + Z_of_nat n * q)%Z.

Lemma modpq_modp : forall (a b : Z) (p q : nat), Mod a b (p * q) -> Mod a b p.

Lemma mod_refl : forall (a : Z) (n : nat), Mod a a n.

Lemma mod_sym : forall (a b : Z) (n : nat), Mod a b n -> Mod b a n.

Lemma mod_trans :
 forall (a b c : Z) (n : nat), Mod a b n -> Mod b c n -> Mod a c n.

Lemma eqmod : forall x y : Z, x = y -> forall n : nat, Mod x y n.

Lemma mod_plus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a + c) (b + d) n.

Lemma mod_mult_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a * c) (b * d) n.

Lemma mod_sqr_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (a * a) (b * b) n.

Lemma mod_exp_compat :
 forall (a b : Z) (n : nat),
 Mod a b n -> forall m : nat, Mod (Exp a m) (Exp b m) n.

Lemma moda0_exp_compat :
 forall (a : Z) (n : nat),
 n > 0 -> Mod a 0 n -> forall m : nat, m > 0 -> Mod (Exp a m) 0 n.

Lemma mod_opp_compat :
 forall (a b : Z) (n : nat), Mod a b n -> Mod (- a) (- b) n.

Lemma mod_minus_compat :
 forall (a b c d : Z) (n : nat),
 Mod a b n -> Mod c d n -> Mod (a - c) (b - d) n.

Lemma mod_nx_0_n : forall (n : nat) (x : Z), Mod (Z_of_nat n * x) 0 n.

Lemma moddivmin :
 forall (a b : Z) (n : nat), Mod a b n <-> Divides n (Zabs_nat (a - b)).

Lemma moddec : forall (a b : Z) (n : nat), Mod a b n \/ ~ Mod a b n.

Lemma mod_0not1 : forall n : nat, n > 1 -> ~ Mod 0 1 n.

Lemma mod_exp1 :
 forall (a : Z) (n : nat), Mod a 1 n -> forall m : nat, Mod (Exp a m) 1 n.

Lemma mod_repr_non_0 :
 forall (n : nat) (x : Z), (0 < x < Z_of_nat n)%Z -> ~ Mod x 0 n.

Lemma mod_repr_eq :
 forall (p : nat) (x y : Z),
 0 < p ->
 (0 < x < Z_of_nat p)%Z -> (0 < y < Z_of_nat p)%Z -> Mod x y p -> x = y.

Definition ZMod (a b n : Z) := exists q : Z, a = (b + n * q)%Z.

Lemma zmodpq_modp : forall a b p q : Z, ZMod a b (p * q) -> ZMod a b p.

Lemma zmod_refl : forall a n : Z, ZMod a a n.

Lemma zmod_sym : forall a b n : Z, ZMod a b n -> ZMod b a n.

Lemma zmod_trans : forall a b c n : Z, ZMod a b n -> ZMod b c n -> ZMod a c n.

Lemma zeqmod : forall x y : Z, x = y -> forall n : Z, ZMod x y n.

Lemma zmod_plus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a + c) (b + d) n.

Lemma zmod_mult_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a * c) (b * d) n.

Lemma zmod_sqr_compat :
 forall a b n : Z, ZMod a b n -> ZMod (a * a) (b * b) n.

Lemma zmodmod : forall a b n : Z, ZMod a b n -> Mod a b (Zabs_nat n).

Lemma modzmod :
 forall (a b : Z) (n : nat), Mod a b n -> ZMod a b (Z_of_nat n).

Lemma absmodzmod : forall a b n : Z, Mod a b (Zabs_nat n) -> ZMod a b n.

Lemma zmod_exp_compat :
 forall a b n : Z, ZMod a b n -> forall m : Z, ZMod (ZExp a m) (ZExp b m) n.

Lemma zmoda0_exp_compat :
 forall a n : Z,
 (n > 0)%Z -> ZMod a 0 n -> forall m : Z, (m > 0)%Z -> ZMod (ZExp a m) 0 n.

Lemma zmod_opp_compat : forall a b n : Z, ZMod a b n -> ZMod (- a) (- b) n.

Lemma zmod_minus_compat :
 forall a b c d n : Z, ZMod a b n -> ZMod c d n -> ZMod (a - c) (b - d) n.

Lemma zmod_nx_0_n : forall n x : Z, ZMod (n * x) 0 n.

Lemma zmoddivmin : forall a b n : Z, ZMod a b n <-> ZDivides n (a - b).

Lemma zmoddec : forall a b n : Z, ZMod a b n \/ ~ ZMod a b n.

Lemma zmod_0not1 : forall n : Z, (n > 1)%Z -> ~ ZMod 0 1 n.

Lemma zmod_repr_non_0 : forall n x : Z, (0 < x < n)%Z -> ~ ZMod x 0 n. *)

Require Import modprime.
(* modprime:
Require Import Arith.
Require Import ZArith.
Require Import Wf_nat.

Require Import lemmas.
Require Import natZ.
Require Import dec.
Require Import list.
Require Import exp.
Require Import divides.
Require Import prime.
Require Import modulo.
Require Import gcd.

Lemma prime_div_or_gcd1 :
 forall (p : nat) (a : Z),
 Prime p -> ZDivides (Z_of_nat p) a \/ gcd (Z_of_nat p) a 1.

Lemma divmultgcd :
 forall a b c : Z,
 a <> 0%Z -> ZDivides a (b * c) -> gcd a b 1 -> ZDivides a c.

Lemma primedivmult :
 forall p n m : nat,
 Prime p -> Divides p (n * m) -> Divides p n \/ Divides p m.

Lemma mod_mult_inv_r :
 forall (a : Z) (p : nat),
 Prime p -> ~ Mod a 0 p -> exists ra : Z, Mod (a * ra) 1 p.

Lemma mod_mult_cancel_r :
 forall (a b c : Z) (p : nat),
 Prime p -> ~ Mod c 0 p -> Mod (a * c) (b * c) p -> Mod a b p.

Lemma mod_mult_0 :
 forall (p : nat) (a b : Z),
 Prime p -> Mod (a * b) 0 p -> Mod a 0 p \/ Mod b 0 p.

Lemma mod_not_exp_0 :
 forall p : nat,
 Prime p -> forall a : Z, ~ Mod a 0 p -> forall m : nat, ~ Mod (Exp a m) 0 p.

Lemma techlemma3 :
 forall (qlist : natlist) (a b : nat),
 0 < a ->
 a < b ->
 Divides a b ->
 b = product qlist ->
 allPrime qlist ->
 exists qi : nat, inlist nat qi qlist /\ Divides a (multDrop qi qlist). *)



Definition nodoubles (p : nat) (l : Zlist) : Prop :=

  forall x : Z,

  inlist Z x l -> forall y : Z, inlist Z y (zdrop x l) -> ~ Mod x y p.



Lemma nodoubles_nil : forall p : nat, nodoubles p (Nil Z).

Proof.

   unfold nodoubles in |- *. simpl in |- *. intros. elim H0.

Qed.



Lemma nodoubles_drop :

 forall (p : nat) (l : Zlist) (x : Z),

 nodoubles p l -> nodoubles p (zdrop x l).

Proof.

   unfold nodoubles in |- *. intros. apply H.

   apply zdrop_inlist_weak with x. assumption.

   apply zdrop_inlist_weak with x. rewrite zdrop_swap. assumption.

Qed.



Lemma nodoubles_ind :

 forall (p : nat) (h : Z) (t : Zlist),

 (forall x : Z, inlist Z x t -> ~ Mod h x p) ->

 nodoubles p t -> nodoubles p (Cons Z h t).

Proof.

   intros. unfold nodoubles in |- *. intros.

   elim (zeqdec x h).

   intro. rewrite zdrop_head_eq in H2.

   rewrite H3. apply (H y). assumption. assumption.

   intro. rewrite zdrop_head_neq in H2.

   elim (zeqdec y h).

   intro. rewrite H4. intro. elim (H x).

   elim (inlist_head_neq Z x h t). intros.

   apply H6. assumption. assumption.

   apply mod_sym. assumption.

   intro. unfold nodoubles in H0.

   apply (H0 x).

   elim (inlist_head_neq Z x h t). intros.

   apply H5. assumption. assumption.

   elim (inlist_head_neq Z y h (zdrop x t)). intros.

   apply H5. assumption. assumption.

   assumption.

Qed.



Definition allex (p : nat) (l0 l1 : Zlist) : Prop :=

  forall x : Z, inlist Z x l0 -> exists y : Z, inlist Z y l1 /\ Mod x y p.



Lemma allex_nodoubles_drop :

 forall (p : nat) (l0 l1 : Zlist) (x0 x1 : Z),

 Prime p ->

 Mod x0 x1 p ->

 inlist Z x0 l0 ->

 inlist Z x1 l1 ->

 nodoubles p l0 -> allex p l0 l1 -> allex p (zdrop x0 l0) (zdrop x1 l1).

Proof.

   intros.

   unfold allex in |- *. intros x Hx.

   elim (H4 x). intros y Hy.

   elim Hy. intros.

   split with y.

   split. apply zdrop_neq_inlist.

   intro. rewrite H7 in H6.

   elim H3 with x x0.

   apply zdrop_inlist_weak with x0. assumption.

   apply zdrop_inlist_swap. assumption. assumption.

   apply mod_trans with x1. assumption.

   apply mod_sym. assumption.

   assumption. assumption.

   apply zdrop_inlist_weak with x0. assumption.

Qed.



Fixpoint until (n : nat) : Zlist :=

  match n with

  | O => Nil Z

  | S n => Cons Z (Z_of_nat (S n)) (until n)

  end.



Lemma until_ok :

 forall (n : nat) (x : Z), (0 < x <= Z_of_nat n)%Z -> inlist Z x (until n).

Proof.

   simple induction n.

   simpl in |- *. intros. elim H. intros.

   elim (Zle_not_lt x 0). assumption. assumption.

   intros m IH. intros. elim H. intros.

   elim (Zle_lt_or_eq x (Z_of_nat (S m))).

   intros. unfold inlist in |- *. simpl in |- *. right. unfold inlist in IH.

   apply IH. split. assumption.

   apply Zlt_succ_le. rewrite <- Znat.inj_S. assumption.

   intro. rewrite H2. unfold inlist in |- *.

   simpl in |- *. left. reflexivity. assumption.

Qed.



Lemma until_mod_all :

 forall (p : nat) (x : Z),

 0 < p ->

 ~ Mod x 0 p -> exists y : Z, inlist Z y (until (pred p)) /\ Mod x y p.

Proof.

   intros.

   elim (zdiv_rem (Z_of_nat p) x).

   intro q. intros.

   elim H1. intro r. intros.

   elim H2. intros. elim H3. intros.

   elim (Zle_lt_or_eq 0 r).



   intro. split with r. split.

   apply until_ok. split.

   assumption.

   apply Zlt_succ_le. rewrite <- Znat.inj_S. rewrite <- (S_pred p 0).

   assumption. assumption.

   split with q. rewrite Zplus_comm. rewrite Zmult_comm. assumption.



   intro. elim H0. split with q.

   rewrite H7. rewrite Zplus_comm. rewrite Zmult_comm. assumption.



   assumption.

   change (Z_of_nat p > Z_of_nat 0)%Z in |- *. apply Znat.inj_gt. assumption.

Qed.



Lemma until_pos : forall (n : nat) (x : Z), inlist Z x (until n) -> (0 < x)%Z.

Proof.

   simple induction n.

   unfold inlist in |- *. simpl in |- *. intros. elim H.

   intros m IH. intros. unfold inlist in H. simpl in H. elim H. intros.

   rewrite H0. unfold Zlt in |- *. simpl in |- *. reflexivity.

   intros. apply IH. assumption.

Qed.



Lemma until_le_n :

 forall (n : nat) (x : Z), inlist Z x (until n) -> (x <= Z_of_nat n)%Z.

Proof.

   simple induction n.

   unfold inlist in |- *. simpl in |- *. intros. elim H.

   intros m IH. intros. unfold inlist in H. simpl in H. elim H. intros.

   rewrite H0. apply Zle_refl.

   intros. apply Zle_trans with (Z_of_nat m).

   apply IH. assumption. apply Znat.inj_le. apply le_S. apply le_n.

Qed.



Lemma until_not_0mod :

 forall (p : nat) (x : Z),

 0 < p -> inlist Z x (until (pred p)) -> ~ Mod x 0 p.

Proof.

   intros. apply mod_repr_non_0. split.

   apply (until_pos (pred p) x). assumption.

   rewrite (S_pred p 0). rewrite Znat.inj_S.

   apply Zle_lt_succ. apply until_le_n.

   assumption. assumption.

Qed.



Lemma untiln_prod_not_0modp :

 forall p n : nat,

 0 < n -> n < p -> Prime p -> ~ Mod (zproduct (until n)) 0 p.

Proof.

   simple induction n.

   intro. elim (lt_irrefl 0). assumption.

   intros m IH H0m Hmp Hp.

   change (~ Mod (Z_of_nat (S m) * zproduct (until m)) 0 p) in |- *.

   intro. elim (mod_mult_0 p (Z_of_nat (S m)) (zproduct (until m))).

   intro. elim (mod_repr_non_0 p (Z_of_nat (S m))). split.

   change (Z_of_nat 0 < Z_of_nat (S m))%Z in |- *.

   apply Znat.inj_lt. assumption.

   apply Znat.inj_lt. assumption.

   assumption.

   intro. elim (le_lt_or_eq 0 m). intro.

   elim IH. assumption. apply lt_trans with (S m).

   apply lt_n_Sn. assumption. assumption.

   assumption. intro. rewrite <- H1 in H. simpl in H.

   elim mod_0not1 with p. elim Hp. intros. assumption.

   apply mod_sym. assumption.

   apply le_O_n. assumption.

   assumption.

Qed.



Lemma until_prod_not_0mod :

 forall p : nat, Prime p -> ~ Mod (zproduct (until (pred p))) 0 p.

Proof.

   intros. elim H. intros.

   apply untiln_prod_not_0modp; auto with arith.

Qed.



Lemma until_mapmult_exp :

 forall (a : Z) (n : nat),

 zproduct (mapmult a (until n)) = (Exp a n * zproduct (until n))%Z.

Proof.

   simple induction n.

   simpl in |- *. reflexivity.

   intros m IH.

   replace (mapmult a (until (S m))) with

    (Cons Z (a * Z_of_nat (S m))%Z (mapmult a (until m))).

   rewrite exp_S.

   replace (zproduct (Cons Z (a * Z_of_nat (S m))%Z (mapmult a (until m))))

    with (a * Z_of_nat (S m) * zproduct (mapmult a (until m)))%Z.

   rewrite IH. rewrite Zmult_assoc_reverse.

   rewrite (Zmult_assoc (Z_of_nat (S m)) (Exp a m)).

   rewrite (Zmult_comm (Z_of_nat (S m))).

   rewrite Zmult_assoc. rewrite Zmult_assoc.

   replace (zproduct (until (S m))) with

    (Z_of_nat (S m) * zproduct (until m))%Z.

   rewrite Zmult_assoc. reflexivity.

   reflexivity. reflexivity. reflexivity.

Qed.



Lemma until_mapmult_allex :

 forall (p : nat) (a : Z),

 Prime p ->

 ~ Mod a 0 p -> allex p (until (pred p)) (mapmult a (until (pred p))).

Proof.

   unfold allex in |- *.

   intros p a Hprime Ha0 x Hx. elim Hprime. intros Hp Hp1.

   elim (mod_mult_inv_r a p). intros ra Hra.

   elim (zdiv_rem (Z_of_nat p) (ra * x)). intros q Hq. elim Hq.

   intros r Hr. elim Hr. intros. elim H. intros.

   split with (a * r)%Z.

   split. apply mapmult_image. apply until_ok.

   split. elim (Zle_lt_or_eq 0 r). intro. assumption.

   intro. rewrite <- H3 in H0. rewrite <- Zplus_0_r_reverse in H0.

   elim until_not_0mod with p x.

   apply lt_trans with 1. apply lt_n_Sn. assumption.

   assumption.

   apply mod_mult_cancel_r with (a * ra)%Z. assumption.

   intro. elim mod_0not1 with p. assumption.

   apply mod_trans with (a * ra)%Z. apply mod_sym. assumption. assumption.

   rewrite (Zmult_comm a ra). rewrite Zmult_assoc. rewrite (Zmult_comm x ra).

   rewrite H0. simpl in |- *. unfold Mod in |- *. split with (q * a)%Z. simpl in |- *.

   rewrite Zmult_assoc. rewrite (Zmult_comm q). reflexivity.

   assumption. apply Zlt_succ_le.

   rewrite <- Znat.inj_S. rewrite <- (S_pred p 1). assumption.

   assumption.

   apply mod_mult_cancel_r with ra. assumption.

   intro. elim mod_0not1 with p. assumption.

   apply mod_trans with (ra * a)%Z. change (Mod (0 * a) (ra * a) p) in |- *.

   apply mod_mult_compat. apply mod_sym. assumption.

   apply mod_refl. rewrite (Zmult_comm ra a). assumption.

   rewrite (Zmult_comm x ra). rewrite H0.

   rewrite (Zmult_comm a r). rewrite (Zmult_assoc_reverse r a ra).

   apply mod_trans with r. split with q.

   rewrite Zplus_comm. rewrite Zmult_comm. reflexivity.

   pattern r at 1 in |- *. rewrite <- Zmult_1_l with r.

   rewrite (Zmult_comm 1 r). apply mod_mult_compat.

   apply mod_refl. apply mod_sym. assumption.

   change (Z_of_nat p > Z_of_nat 0)%Z in |- *. apply Znat.inj_gt.

   apply gt_trans with 1. assumption. apply gt_Sn_n.

   assumption. assumption.

Qed.



Lemma until_nodoubles1 :

 forall p : nat, Prime p -> forall n : nat, n < p -> nodoubles p (until n).

Proof.

   simple induction n.

   intros. simpl in |- *. apply nodoubles_nil.

   intros m IH Hb.

   change (nodoubles p (Cons Z (Z_of_nat (S m)) (until m))) in |- *.

   apply nodoubles_ind. intros.

   intro. elim (Zlt_not_le x (Z_of_nat (S m))).

   rewrite Znat.inj_S. apply Zle_lt_succ. apply until_le_n.

   assumption. apply Zeq_le. apply mod_repr_eq with p.

   elim H. intros. apply lt_trans with 1. apply lt_n_Sn. assumption.

   split. change (Z_of_nat 0 < Z_of_nat (S m))%Z in |- *. apply Znat.inj_lt.

   apply lt_O_Sn. apply Znat.inj_lt. assumption.

   split. apply until_pos with m. assumption.

   apply Zle_lt_trans with (Z_of_nat m).

   apply until_le_n. assumption.

   apply Znat.inj_lt. apply le_lt_trans with (S m).

   apply le_n_Sn. assumption.

   assumption.

   apply IH. apply le_lt_trans with (S m).

   apply le_n_Sn. assumption.

Qed.



Lemma until_nodoubles :

 forall p : nat, Prime p -> nodoubles p (until (pred p)).

Proof.

   intros. apply until_nodoubles1. assumption.

   apply lt_pred_n_n. apply lt_trans with 1.

   apply lt_n_Sn. elim H. intros. assumption.

Qed.



Fixpoint permmod (p : nat) (l1 : Zlist) {struct l1} : 

 Zlist -> Prop :=

  fun l2 : Zlist =>

  match l1 with

  | Nil => l2 = Nil Z

  | Cons x t =>

      exists y : Z, inlist Z y l2 /\ Mod x y p /\ permmod p t (zdrop y l2)

  end.



Lemma permmod_nil : forall p : nat, permmod p (Nil Z) (Nil Z).

Proof.

   simpl in |- *. intro. reflexivity.

Qed.



Lemma permmod_drop :

 forall (p : nat) (x1 x2 : Z) (l1 l2 : Zlist),

 Mod x1 x2 p ->

 inlist Z x1 l1 ->

 inlist Z x2 l2 -> permmod p (zdrop x1 l1) (zdrop x2 l2) -> permmod p l1 l2.

Proof.

   simple induction l1.

   simpl in |- *. intros. elim H0.

   intros h t IH. intros l2 Hm.

   elim (zeqdec x1 h).

   intros. simpl in |- *. split with x2.

   split. assumption.

   split. rewrite <- H. assumption.

   rewrite H in H2. rewrite zdrop_head_eq in H2.

   assumption. reflexivity.

   intro.

   rewrite zdrop_head_neq.

   intros. elim H2. intros y Hy.

   elim Hy. intros. elim H4. intros.

   split with y. split.

   apply zdrop_inlist_weak with x2. assumption.

   split. assumption.

   rewrite zdrop_swap in H6.

   apply IH. assumption.

   elim (inlist_head_neq Z x1 h t). intros. apply H7. assumption.

   assumption.

   elim (zeqdec x2 y).

   intro. rewrite H7. rewrite H7 in H3. assumption.

   intro. apply zdrop_neq_inlist. assumption. assumption.

   assumption. assumption.

Qed.



Lemma permmod_drop_cons :

 forall (p : nat) (x1 x2 : Z) (t1 l2 : Zlist),

 Mod x1 x2 p ->

 inlist Z x2 l2 -> permmod p t1 (zdrop x2 l2) -> permmod p (Cons Z x1 t1) l2.

Proof.

   intros. apply permmod_drop with x1 x2.

   assumption.

   apply inlist_head_eq. reflexivity.

   assumption.

   rewrite zdrop_head_eq. assumption.

   reflexivity.

Qed.



Lemma permmod_cons_extend :

 forall (p : nat) (x1 x2 : Z) (l1 l2 : Zlist),

 permmod p l1 l2 -> Mod x1 x2 p -> permmod p (Cons Z x1 l1) (Cons Z x2 l2).

Proof.

   intros.

   apply permmod_drop with x1 x2.

   assumption.

   apply inlist_head_eq. reflexivity.

   apply inlist_head_eq. reflexivity.

   rewrite zdrop_head_eq. rewrite zdrop_head_eq.

   assumption. reflexivity. reflexivity.

Qed.



Lemma permmod_length :

 forall (p : nat) (l1 l2 : Zlist),

 permmod p l1 l2 -> length Z l1 = length Z l2.

Proof.

   simple induction l1.

   simpl in |- *. intros. rewrite H. simpl in |- *. reflexivity.

   intros h t IH. simpl in |- *. intros.

   elim H. intros y Hy.  elim Hy. intros.

   elim H1. intros.

   rewrite (IH (zdrop y l2)).

   rewrite zdrop_length with y l2.

   reflexivity. assumption. assumption.

Qed.



Lemma permmod_refl : forall (p : nat) (l : Zlist), permmod p l l.

Proof.

   simple induction l.

   simpl in |- *. reflexivity.

   intros h t IH. split with h.

   split. apply inlist_head_eq. reflexivity.

   split. apply mod_refl.

   rewrite zdrop_head_eq. assumption. reflexivity.

Qed.



Lemma permmod_sym :

 forall (p : nat) (l1 l2 : Zlist), permmod p l1 l2 -> permmod p l2 l1.

Proof.

   simple induction l1.

   simpl in |- *. intros. rewrite H. apply permmod_nil.

   intros h1 t1 IH1.

   intros. elim H. intros y Hy.

   elim Hy. intros. elim H1. intros.

   apply permmod_drop with y h1.

   apply mod_sym. assumption.

   assumption.

   apply inlist_head_eq. reflexivity.

   rewrite zdrop_head_eq. apply IH1.

   assumption.

   reflexivity.

Qed.



Lemma permmod_product :

 forall (l0 l1 : Zlist) (p : nat),

 permmod p l0 l1 -> Mod (zproduct l0) (zproduct l1) p.

Proof.

   simple induction l0.

   simpl in |- *. intros. rewrite H. simpl in |- *. apply mod_refl.

   intros h t IH. intros.

   elim H. intros. elim H0. intros. elim H2. intros.

   simpl in |- *. rewrite <- zdrop_product with x l1.

   apply mod_mult_compat.

   assumption.

   apply IH. assumption.

   assumption.

Qed.



Lemma allex_permmod :

 forall (p : nat) (l0 l1 : Zlist),

 length Z l0 = length Z l1 ->

 (forall x0 : Z,

  inlist Z x0 l0 ->

  exists x1 : Z,

    inlist Z x1 l1 /\ Mod x0 x1 p /\ permmod p (zdrop x0 l0) (zdrop x1 l1)) ->

 permmod p l0 l1.

Proof.

   simple induction l0.

   simple induction l1.

   intros. apply permmod_nil.

   intros. discriminate H0.

   intros h0 t0 IH0. intros.

   elim (H0 h0). intro x1. intros.

   elim H1. intros. elim H3. intros.

   rewrite zdrop_head_eq in H5.

   apply permmod_drop_cons with x1.

   assumption. assumption. assumption.

   reflexivity.

   apply inlist_head_eq. reflexivity.

Qed.



Lemma permmod_allex :

 forall (p : nat) (l0 l1 : Zlist),

 permmod p l0 l1 ->

 forall x : Z,

 inlist Z x l0 ->

 exists y : Z,

   inlist Z y l1 /\ Mod x y p /\ permmod p (zdrop x l0) (zdrop y l1).

Proof.

   simple induction l0.

   intros. elim H0.

   intros h0 t0 IH0. intros.

   elim H. intros h1 Hh1.

   elim Hh1. intros. elim H2. intros.

   elim (zeqdec x h0).

   intro. split with h1.

   split. assumption.

   split. rewrite H5. assumption.

   rewrite zdrop_head_eq. assumption. assumption.

   intro. elim (IH0 (zdrop h1 l1) H4 x).

   intros y Hy. elim Hy. intros. elim H7. intros.

   split with y.

   split. apply zdrop_inlist_weak with h1. assumption.

   split. assumption.

   rewrite zdrop_head_neq. split with h1.

   split. elim (zeqdec h1 y).

   intro. rewrite H10 in H6. rewrite H10. assumption.

   intro. apply zdrop_neq_inlist. assumption. assumption.

   split. assumption. rewrite zdrop_swap. assumption.

   assumption. elim (inlist_head_neq Z x h0 t0).

   intros. apply H6. assumption. assumption.

Qed.



Lemma permmod_trans1 :

 forall (n p : nat) (l0 l1 l2 : Zlist),

 length Z l0 = n ->

 length Z l1 = n ->

 length Z l2 = n -> permmod p l0 l1 -> permmod p l1 l2 -> permmod p l0 l2.

Proof.

   simple induction n.

   intros.

   rewrite length_0 with Z l0.

   rewrite length_0 with Z l2.

   apply permmod_nil. assumption. assumption.

   intros m IH.

   intros p l0 l1 l2 Hl0 Hl1 Hl2 H01 H12.

   apply allex_permmod. transitivity (length Z l1).

   apply permmod_length with p. assumption.

   apply permmod_length with p. assumption.

   intros x0 Hx0.

   elim (permmod_allex p l0 l1 H01 x0). intros x1 H0.

   elim H0. intros Hx1 H1. elim H1. intros Hm01 Hd01.

   elim (permmod_allex p l1 l2 H12 x1). intros x2 H2.

   elim H2. intros Hx2 H3. elim H3. intros Hm12 Hd12.

   split with x2.

   split. assumption.

   split. apply mod_trans with x1. assumption. assumption.

   apply IH with (zdrop x1 l1).

   apply S_inj. rewrite zdrop_length. assumption. assumption.

   apply S_inj. rewrite zdrop_length. assumption. assumption.

   apply S_inj. rewrite zdrop_length. assumption. assumption.

   assumption. assumption.

   assumption. assumption.

Qed.



Lemma permmod_trans :

 forall (p : nat) (l0 l1 l2 : Zlist),

 permmod p l0 l1 -> permmod p l1 l2 -> permmod p l0 l2.

Proof.

   intros. apply permmod_trans1 with (length Z l0) l1.

   reflexivity.

   symmetry  in |- *. apply permmod_length with p. assumption.

   symmetry  in |- *. transitivity (length Z l1).

   apply permmod_length with p. assumption.

   apply permmod_length with p. assumption.

   assumption. assumption.

Qed.



Lemma permmod_drop_drop1 :

 forall (n p : nat) (x y : Z) (l : Zlist),

 n = length Z l ->

 Mod x y p ->

 inlist Z x l -> inlist Z y l -> permmod p (zdrop x l) (zdrop y l).

Proof.

   simple induction n.

   intros. rewrite length_0 with Z l.

   simpl in |- *. reflexivity. symmetry  in |- *. assumption.

   intros m IH. intros.

   elim (zeqdec x y).

   intro. rewrite H3. apply permmod_refl.

   intro. apply allex_permmod.

   apply S_inj.

   rewrite zdrop_length. rewrite zdrop_length.

   reflexivity. assumption. assumption.   

   intros z Hz.

   elim (zeqdec y z).

   intro. split with x.

   split. apply zdrop_neq_inlist. assumption. assumption.

   split. rewrite <- H4. apply mod_sym. assumption.

   rewrite H4. rewrite zdrop_swap. apply permmod_refl.

   intro. split with z.

   split. apply zdrop_neq_inlist.

   intro. apply H4. symmetry  in |- *. assumption.

   apply zdrop_inlist_weak with x. assumption.

   split. apply mod_refl.

   rewrite (zdrop_swap z). rewrite (zdrop_swap z).

   apply (IH p x y (zdrop z l)).

   apply S_inj. rewrite zdrop_length. assumption.

   apply zdrop_inlist_weak with x. assumption.

   assumption.

   apply zdrop_inlist_swap. assumption. assumption.

   apply zdrop_neq_inlist. assumption. assumption.

Qed.



Lemma permmod_drop_drop :

 forall (p : nat) (x y : Z) (l : Zlist),

 Mod x y p ->

 inlist Z x l -> inlist Z y l -> permmod p (zdrop x l) (zdrop y l).

Proof.

   intros. apply permmod_drop_drop1 with (length Z l).

   reflexivity. assumption. assumption. assumption.

Qed.



Lemma permmod_drop_rev :

 forall (p : nat) (l0 l1 : Zlist) (x0 x1 : Z),

 Mod x0 x1 p ->

 inlist Z x0 l0 ->

 inlist Z x1 l1 -> permmod p l0 l1 -> permmod p (zdrop x0 l0) (zdrop x1 l1).

Proof.

   intros. elim (permmod_allex p l0 l1 H2 x0).

   intros y Hy. elim Hy. intros. elim H4. intros.

   apply permmod_trans with (zdrop y l1). assumption.

   apply permmod_drop_drop.

   apply mod_trans with x0. apply mod_sym. assumption.

   assumption. assumption. assumption. assumption.

Qed.



Lemma nodoubles_allex_permmod1 :

 forall (n p : nat) (l0 l1 : Zlist),

 n = length Z l0 ->

 n = length Z l1 ->

 Prime p ->

 length Z l0 = length Z l1 ->

 nodoubles p l0 -> allex p l0 l1 -> permmod p l0 l1.

Proof.

   simple induction n.

   intros.

   rewrite length_0 with Z l0.

   rewrite length_0 with Z l1. 

   apply permmod_nil.

   symmetry  in |- *. assumption. symmetry  in |- *. assumption.

   intros m IH. intros.

   apply allex_permmod.

   assumption.

   intros x Hx. elim H4 with x.

   intros y Hy. elim Hy. intros.

   split with y.

   split. assumption.

   split. assumption.

   apply IH.

   apply S_inj. rewrite zdrop_length. assumption.

   assumption.

   apply S_inj. rewrite zdrop_length. assumption.

   assumption.

   assumption.

   apply S_inj. rewrite zdrop_length.

   rewrite zdrop_length. assumption.

   assumption. assumption.

   apply nodoubles_drop. assumption.

   apply allex_nodoubles_drop.

   assumption. assumption. assumption. assumption.

   assumption. assumption. assumption.

Qed.



Lemma nodoubles_allex_permmod :

 forall (p : nat) (l0 l1 : Zlist),

 Prime p ->

 length Z l0 = length Z l1 ->

 nodoubles p l0 -> allex p l0 l1 -> permmod p l0 l1.

Proof.

   intros. apply nodoubles_allex_permmod1 with (length Z l0).

   reflexivity. assumption. assumption. assumption.

   assumption. assumption.

Qed.



Lemma until_mapmult_permmod :

 forall (p : nat) (a : Z),

 Prime p ->

 ~ Mod a 0 p -> permmod p (until (pred p)) (mapmult a (until (pred p))).

Proof.

   intros.

   apply nodoubles_allex_permmod.

   assumption. unfold mapmult in |- *. apply map_length.

   apply until_nodoubles. assumption.

   unfold allex in |- *. intros.

   apply (until_mapmult_allex p a H H0).

   assumption.

Qed.



Theorem flt :

 forall (a : Z) (p : nat), Prime p -> ~ Mod a 0 p -> Mod (Exp a (pred p)) 1 p.

Proof.

   intros. apply mod_sym.

   apply mod_mult_cancel_r with (zproduct (until (pred p))).

   assumption. apply until_prod_not_0mod. assumption.

   rewrite <- until_mapmult_exp. rewrite Zmult_1_l.

   apply permmod_product. apply until_mapmult_permmod.

   assumption. assumption.

Qed.

