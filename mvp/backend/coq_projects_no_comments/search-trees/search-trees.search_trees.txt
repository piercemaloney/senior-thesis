
Require Export nat_trees.
Require Import Lt.

Inductive min (p : nat) (t : nat_tree) : Prop :=
    min_intro : (forall q : nat, occ t q -> p < q) -> min p t.

Hint Resolve min_intro: searchtrees.

Inductive maj (p : nat) (t : nat_tree) : Prop :=
    maj_intro : (forall q : nat, occ t q -> q < p) -> maj p t.

Hint Resolve maj_intro: searchtrees.

Inductive search : nat_tree -> Prop :=
  | nil_search : search NIL
  | bin_search :
      forall (n : nat) (t1 t2 : nat_tree),
      search t1 -> search t2 -> maj n t1 -> min n t2 -> search (bin n t1 t2).

Hint Resolve nil_search bin_search: searchtrees.

Lemma min_nil : forall p : nat, min p NIL.

Proof.
 intro p; apply min_intro.
 intros q H; inversion_clear H.
Qed.

Hint Resolve min_nil: searchtrees.

Lemma maj_nil : forall p : nat, maj p NIL.

Proof.
 intro p; apply maj_intro.
 intros q H; inversion_clear H.
Qed.

Hint Resolve maj_nil: searchtrees.

Lemma maj_not_occ : forall (p : nat) (t : nat_tree), maj p t -> ~ occ t p.

Proof.
 unfold not in |- *; intros p t H H'.
 elim H; intros; absurd (p < p); auto with searchtrees arith.
Qed.

Hint Resolve maj_not_occ: searchtrees.

Lemma min_not_occ : forall (p : nat) (t : nat_tree), min p t -> ~ occ t p.

Proof. 
 unfold not in |- *; intros p t H H'.
 elim H; intros; absurd (p < p); auto with searchtrees arith.
Qed.

Hint Resolve min_not_occ: searchtrees.
 
Section search_tree_basic_properties.

     Variable n : nat.
     Variable t1 t2 : nat_tree.
     Hypothesis se : search (bin n t1 t2).

     Lemma search_l : search t1.
     
     Proof.
      inversion_clear se; auto with searchtrees arith.
     Qed.

     Hint Resolve search_l: searchtrees.

    Lemma search_r : search t2.
     
     Proof.
      inversion_clear se; auto with searchtrees arith.
     Qed.
     Hint Resolve search_r: searchtrees.

     Lemma maj_l : maj n t1.
     
     Proof.
      inversion_clear se; auto with searchtrees arith.
     Qed.
     Hint Resolve maj_l: searchtrees.

     Lemma min_r : min n t2.
     
     Proof.
     inversion_clear se; auto with searchtrees arith.
     Qed.
     Hint Resolve min_r: searchtrees.

     Lemma not_right : forall p : nat, p <= n -> ~ occ t2 p.
     
     Proof.
      intros p H; elim min_r.
      unfold not in |- *; intros; absurd (n < p); auto with searchtrees arith.
     Qed.
     Hint Resolve not_right: searchtrees.
 
     Lemma not_left : forall p : nat, n <= p -> ~ occ t1 p.
     
     Proof.
      intros p H; elim maj_l.
      unfold not in |- *; intros; absurd (p < n); auto with searchtrees arith.
     Qed.
     Hint Resolve not_left: searchtrees.

     Lemma go_left : forall p : nat, occ (bin n t1 t2) p -> p < n -> occ t1 p.
     
     Proof.
      intros p H H0; elim (occ_inv _ _ _ _ H).
       
        simple induction 1; absurd (p < n);
         [ rewrite H1; auto with searchtrees arith
         | auto with searchtrees arith ].
        simple induction 1; auto with searchtrees arith.
       
       intro H2; absurd (occ t2 p); auto with searchtrees arith.
      Qed.

     Lemma go_right :
      forall p : nat, occ (bin n t1 t2) p -> n < p -> occ t2 p.
     
     Proof.
      intros p H H0; elim (occ_inv _ _ _ _ H).
      
        simple induction 1; absurd (n < p);
         [ rewrite H1; auto with searchtrees arith
         | auto with searchtrees arith ].
        simple induction 1; auto with searchtrees arith.
       
      intro H2; absurd (occ t1 p); auto with searchtrees arith.
     Qed.

     Lemma search_inv :
      forall P : Prop,
      (search t1 -> search t2 -> maj n t1 -> min n t2 -> P) -> P.
     Proof.
      auto with searchtrees arith.
     Qed.

End search_tree_basic_properties.