

Require Import Description.

Require Import FunctionalExtensionality.

Require Import base.

Require Import function.

Require Import monoid.

Require Import group.

Require Import abelian_group.

Require Import ring.



Module Commutative_Ring.



Structure Commutative_Ring : Type := commutative_ring {



  E : Set;



  E_0 : E;



  E_1 : E;



  sum : E -> E -> E;



  prod : E -> E -> E;



  distinct_0_1: E_0 <> E_1;



  sum_is_assoc : Monoid.is_assoc E sum;



  sum_is_comm : Abelian_Group.is_comm E sum;



  sum_id_l : Monoid.is_id_l E sum E_0;



  sum_inv_l_ex : forall x : E, exists y : E, sum y x = E_0;



  prod_is_assoc : Monoid.is_assoc E prod;



  prod_is_comm : Abelian_Group.is_comm E prod;



   prod_id_l : Monoid.is_id_l E prod E_1;



  prod_sum_distrib_l : Ring.is_distrib_l E prod sum

}.

 

Arguments E_0 {c}.



Arguments E_1 {c}.



Arguments sum {c} x y.



Arguments prod {c} x y.



Arguments distinct_0_1 {c} _.



Arguments sum_is_assoc {c} x y z.



Arguments sum_is_comm {c} x y.



Arguments sum_id_l {c} x.



Arguments sum_inv_l_ex {c} x.



Arguments prod_is_assoc {c} x y z.



Arguments prod_id_l {c} x.



Arguments prod_sum_distrib_l {c} x y z.



Arguments prod_is_comm {c} x y.



Notation "0" := E_0 : commutative_ring_scope.



Notation "1" := E_1 : commutative_ring_scope.



Notation "x + y" := (sum x y) (at level 50, left associativity) : commutative_ring_scope.



Notation "{+}" := sum : commutative_ring_scope.



Notation "x # y" := (prod x y) (at level 50, left associativity) : commutative_ring_scope.



Notation "{#}" := prod : commutative_ring_scope.



Open Scope commutative_ring_scope.



Section Theorems.



Variable r : Commutative_Ring.



Let E := E r.



Definition sum_is_id_l := Monoid.is_id_l E {+}.



Definition sum_is_id_r := Monoid.is_id_r E {+}.



Definition sum_is_id := Monoid.is_id E {+}.



Definition prod_is_id_l := Monoid.is_id_l E {#}.



Definition prod_is_id_r := Monoid.is_id_r E {#}.



Definition prod_is_id := Monoid.is_id E {#}.



Theorem prod_id_r

  :  prod_is_id_r 1.

Proof

  fun x : E

    => eq_ind_r

         (fun a => a = x)

         (prod_id_l x)

         (prod_is_comm x 1).

 

Theorem prod_sum_distrib_r

  :  Ring.is_distrib_r E {#} {+}.

Proof

  fun x y z : E

    =>  prod_sum_distrib_l x y z

        || x # (y + z) = a + (x # z) @a by <- prod_is_comm x y

        || x # (y + z) = (y # x) + a @a by <- prod_is_comm x z

        || a = (y # x) + (z # x)     @a by <- prod_is_comm x (y + z).



Definition ring := Ring.ring E 0 1 {+} {#} distinct_0_1 sum_is_assoc sum_is_comm sum_id_l sum_inv_l_ex prod_is_assoc prod_id_l prod_id_r prod_sum_distrib_l prod_sum_distrib_r.



Definition sum_abelian_group := Ring.sum_abelian_group ring.



Definition sum_group := Ring.sum_group ring.



Definition sum_monoid := Ring.sum_monoid ring.



Definition prod_monoid := Ring.prod_monoid ring.



Theorem distinct_1_0

  :  E_1 (c := r) <> E_0 (c := r).

Proof

  fun H : E_1 = E_0

    => distinct_0_1 (eq_sym H).  



Definition nonzero

  : E -> Prop

  := Ring.nonzero ring.



Theorem sum_id_r

  :  sum_is_id_r 0.

Proof Ring.sum_id_r ring.



Theorem sum_id

  :  sum_is_id 0.

Proof Ring.sum_id ring.



Definition sum_is_inv_l

  := Ring.sum_is_inv_l ring.



Definition sum_is_inv_r

  := Ring.sum_is_inv_r ring.



Definition sum_is_inv

  := Ring.sum_is_inv ring.



Definition sum_has_inv_l := Ring.sum_has_inv_l ring.



Definition sum_has_inv_r := Ring.sum_has_inv_r ring.



Definition sum_has_inv := Ring.sum_has_inv ring.



Theorem sum_inv_r_ex

  :  forall x : E, exists y : E, sum_is_inv_r x y.

Proof Ring.sum_inv_r_ex ring.



Theorem sum_id_l_uniq

  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.

Proof Ring.sum_id_l_uniq ring.



Theorem sum_id_r_uniq

  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.

Proof Ring.sum_id_r_uniq ring.



Theorem sum_id_uniq

  :  forall x : E, Monoid.is_id E {+} x -> x = 0.

Proof Ring.sum_id_uniq ring.



Theorem sum_inv_l_r_eq

  :  forall x y : E, sum_is_inv_l x y -> forall z : E, sum_is_inv_r x z -> y = z.

Proof Ring.sum_inv_l_r_eq ring.



Theorem sum_inv_sym

  :  forall x y : E, sum_is_inv x y <-> sum_is_inv y x.

Proof Ring.sum_inv_sym ring.



Theorem sum_inv_uniq

  :  forall x y z :  E, sum_is_inv x y -> sum_is_inv x z -> z = y.

Proof Ring.sum_inv_uniq ring.



Theorem sum_inv_ex

  :  forall x : E, exists y : E, sum_is_inv x y.

Proof Ring.sum_inv_ex ring.



Theorem sum_inv_uniq_ex

  :  forall x : E, exists! y : E, sum_is_inv x y.

Proof Ring.sum_inv_uniq_ex ring.



Theorem sum_intro_l

  :  forall x y z : E, x = y -> z + x = z + y.

Proof Ring.sum_intro_l ring.



Theorem sum_intro_r

  :  forall x y z : E, x = y -> x + z = y + z.

Proof Ring.sum_intro_r ring.



Theorem sum_cancel_l

  :   forall x y z : E, z + x = z + y -> x = y.

Proof Ring.sum_cancel_l ring.



Theorem sum_cancel_r

  :   forall x y z : E, x + z = y + z -> x = y.

Proof Ring.sum_cancel_r ring.



Theorem sum_inv_l_uniq

  :  forall x y z : E, sum_is_inv_l x y -> sum_is_inv_l x z -> z = y.

Proof Ring.sum_inv_l_uniq ring.



Theorem sum_inv_r_uniq

  :  forall x y z : E, sum_is_inv_r x y -> sum_is_inv_r x z -> z = y.

Proof Ring.sum_inv_r_uniq ring.



Theorem sum_0_inv_l

  :  sum_is_inv_l 0 0.

Proof Ring.sum_0_inv_l ring.



Theorem sum_0_inv_r

  :  sum_is_inv_r 0 0.

Proof Ring.sum_0_inv_r ring.



Theorem sum_0_inv

  :  sum_is_inv 0 0.

Proof Ring.sum_0_inv ring.



Theorem sum_has_inv_l_0

  :  sum_has_inv_l 0.

Proof Ring.sum_has_inv_l_0 ring.



Theorem sum_has_inv_r_0

  :  sum_has_inv_r 0.

Proof Ring.sum_has_inv_r_0 ring.



Theorem sum_has_inv_0

  :  sum_has_inv 0.

Proof Ring.sum_has_inv_0 ring.



Theorem sum_inv_0_eq_0

  :  forall x : E, sum_is_inv x 0 -> x = 0.

Proof Ring.sum_inv_0_eq_0 ring.



Theorem sum_inv_0_uniq

  :  unique (fun x => sum_is_inv x 0) 0.

Proof Ring.sum_inv_0_uniq ring.



Definition sum_neg_strong

  :  forall x : E, { y | sum_is_inv x y }

  := Ring.sum_neg_strong ring.



Definition sum_neg 

  :  E -> E

  := Ring.sum_neg ring.



Notation "{-}" := (sum_neg) : commutative_ring_scope.



Notation "- x" := (sum_neg x) : commutative_ring_scope.



Definition sum_neg_def 

  :  forall x : E, sum_is_inv x (- x)

  := Ring.sum_neg_def ring.



Theorem sum_neg_inj

  :  is_injective E E sum_neg.

Proof Ring.sum_neg_inj ring.



Theorem sum_cancel_neg

  :  forall x : E, sum_neg (- x) = x.

Proof Ring.sum_cancel_neg ring.



Theorem sum_neg_onto

  :  is_onto E E sum_neg.

Proof Ring.sum_neg_onto ring.



Theorem sum_neg_bijective

  :  is_bijective E E sum_neg.

Proof Ring.sum_neg_bijective ring.



Theorem sum_neg_rev

  :  forall x y : E, - x = y -> - y = x.

Proof Ring.sum_neg_rev ring.



Theorem sum_neg_distrib_inv_l

  :  forall x y : E, sum_is_inv_l (x + y) (- y + - x).

Proof Ring.sum_neg_distrib_inv_l ring.



Theorem sum_neg_distrib_inv_r

  :  forall x y : E, sum_is_inv_r (x + y) (- y + - x).

Proof Ring.sum_neg_distrib_inv_r ring.



Theorem sum_neg_distrib_inv

  :  forall x y : E, sum_is_inv (x + y) (- y + - x).

Proof Ring.sum_neg_distrib_inv ring.



Theorem sum_neg_distrib

  :  forall x y : E, - (x + y) = - y + - x.

Proof Ring.sum_neg_distrib ring.



Theorem sum_0_neg

  :  - 0 = 0.

Proof Ring.sum_0_neg ring.



Theorem sum_neg_0

  :  forall x : E, - x = 0 -> x = 0.

Proof Ring.sum_neg_0 ring.



Theorem sum_neg_0_uniq

  :  unique (fun x => - x = 0) 0.

Proof Ring.sum_neg_0_uniq ring.



Theorem prod_id

  :  prod_is_id 1.

Proof Ring.prod_id ring.



Theorem prod_id_l_uniq

  :  forall x : E, (Monoid.is_id_l E {#} x) -> x = 1.

Proof Ring.prod_id_l_uniq ring.



Theorem prod_id_r_uniq

  :  forall x : E, (Monoid.is_id_r E {#} x) -> x = 1.

Proof Ring.prod_id_r_uniq ring.



Theorem prod_id_uniq

  :  forall x : E, (Monoid.is_id E {#} x) -> x = 1.

Proof Ring.prod_id_uniq ring.



Theorem prod_intro_l

  :  forall x y z : E, x = y -> z # x = z # y.

Proof Ring.prod_intro_l ring.



Theorem prod_intro_r

  :  forall x y z : E, x = y -> x # z = y # z.

Proof Ring.prod_intro_r ring.



Definition prod_is_inv_l := Ring.prod_is_inv_l ring.



Definition prod_is_inv_r := Ring.prod_is_inv_r ring.



Definition prod_is_inv := Ring.prod_is_inv ring.



Definition prod_has_inv_l := Ring.prod_has_inv_l ring.



Definition prod_has_inv_r := Ring.prod_has_inv_r ring.



Definition prod_has_inv := Ring.prod_has_inv ring.



Theorem prod_is_inv_lr 

  :  forall x y : E, prod_is_inv_l x y -> prod_is_inv_r x y.

Proof

  fun x y H

    => H || a = 1 @a by prod_is_comm x y.



Theorem prod_inv_l_r_eq

  :  forall x y : E, prod_is_inv_l x y -> forall z : E, prod_is_inv_r x z -> y = z.

Proof Ring.prod_inv_l_r_eq ring.



Theorem prod_inv_sym

  :  forall x y : E, prod_is_inv x y <-> prod_is_inv y x.

Proof Ring.prod_inv_sym ring.



Theorem prod_cancel_l

  :  forall x y z : E, prod_has_inv_l z -> z # x = z # y -> x = y.

Proof Ring.prod_cancel_l ring.



Theorem prod_cancel_r

  :  forall x y z : E, prod_has_inv_r z -> x # z = y # z -> x = y.

Proof Ring.prod_cancel_r ring.



Theorem prod_inv_l_uniq

  :  forall x : E, prod_has_inv_r x -> forall y z : E, prod_is_inv_l x y -> prod_is_inv_l x z -> z = y.

Proof Ring.prod_inv_l_uniq ring.



Theorem prod_inv_r_uniq

  :  forall x : E, prod_has_inv_l x -> forall y z : E, prod_is_inv_r x y -> prod_is_inv_r x z -> z = y.

Proof Ring.prod_inv_r_uniq ring.



Definition prod_inv_uniq

  :  forall x y z : E, prod_is_inv x y -> prod_is_inv x z -> z = y

  := Ring.prod_inv_uniq ring.



Theorem prod_inv_1_l

  :  prod_is_inv_l 1 1.

Proof Ring.prod_inv_1_l ring.



Theorem prod_inv_1_r

  :  prod_is_inv_r 1 1.

Proof Ring.prod_inv_1_l ring.



Theorem prod_inv_1

  :  prod_is_inv 1 1.

Proof Ring.prod_inv_1 ring.



Theorem prod_has_inv_l_1

  :  prod_has_inv_l 1.

Proof Ring.prod_has_inv_l_1 ring.



Theorem prod_has_inv_r_1

  :  prod_has_inv_r 1.

Proof Ring.prod_has_inv_r_1 ring.



Theorem prod_has_inv_1

  :  prod_has_inv 1.

Proof Ring.prod_has_inv_1 ring.



Theorem prod_inv_1_eq_1

  :  forall x : E, prod_is_inv x 1 -> x = 1.

Proof Ring.prod_inv_1_eq_1 ring.



Theorem prod_inv_1_uniq

  :  unique (fun x => prod_is_inv x 1) 1.

Proof Ring.prod_inv_1_uniq ring.



Theorem recipr_1_l

  :  prod_is_inv_l 1 1.

Proof Ring.recipr_1_l ring.



Theorem recipr_1_r

  :  prod_is_inv_r 1 1.

Proof Ring.recipr_1_r ring.



Theorem recipr_1

  :  prod_is_inv 1 1.

Proof Ring.recipr_1 ring.



Theorem prod_sum_distrib

  :  Ring.is_distrib E {#} {+}.

Proof Ring.prod_sum_distrib ring.



Theorem prod_0_l

  :  forall x : E, 0 # x = 0.

Proof Ring.prod_0_l ring.



Theorem prod_0_r

  :  forall x : E, x # 0 = 0.

Proof Ring.prod_0_r ring.



Theorem prod_0_inv_l

  :  ~ prod_has_inv_l 0.

Proof Ring.prod_0_inv_l ring.



Theorem prod_0_inv_r

  :  ~ prod_has_inv_r 0.

Proof Ring.prod_0_inv_r ring.



Theorem prod_0_inv

  :  ~ prod_has_inv 0.

Proof Ring.prod_0_inv ring.



Theorem prod_inv_0

  :  forall x y : E, prod_is_inv x y -> nonzero y.

Proof Ring.prod_inv_0 ring.



Definition E_n1_strong

  :  { x : E | sum_is_inv 1 x }

  := Ring.E_n1_strong ring.



Definition E_n1 : E := Ring.E_n1 ring.



Notation "{-1}" := E_n1 : commutative_ring_scope.



Definition E_n1_def

  :  sum_is_inv 1 {-1}

  := Ring.E_n1_def ring.

      

Theorem E_n1_inv_l

  :  sum_is_inv_l 1 {-1}.

Proof Ring.E_n1_inv_l ring.



Theorem E_n1_inv_r

  :  sum_is_inv_r 1 {-1}.

Proof Ring.E_n1_inv_r ring.



Theorem E_n1_uniq

  :  forall x : E, sum_is_inv 1 x -> x = {-1}.

Proof Ring.E_n1_uniq ring.



Theorem prod_n1_x_inv_l

  :  forall x : E, sum_is_inv_l x ({-1} # x).

Proof Ring.prod_n1_x_inv_l ring.



Theorem prod_x_n1_inv_l

  :  forall x : E, sum_is_inv_l x (x # {-1}).

Proof Ring.prod_x_n1_inv_l ring.



Theorem prod_n1_x_inv_r

  :  forall x : E, sum_is_inv_r x ({-1} # x).

Proof Ring.prod_n1_x_inv_r ring.



Theorem prod_x_n1_inv_r

  :  forall x : E, sum_is_inv_r x (x # {-1}).

Proof Ring.prod_x_n1_inv_r ring.



Theorem prod_n1_x_inv

  :  forall x : E, sum_is_inv x ({-1} # x).

Proof Ring.prod_n1_x_inv ring.



Theorem prod_x_n1_inv

  :  forall x : E, sum_is_inv x (x # {-1}).

Proof Ring.prod_x_n1_inv ring.



Theorem prod_n1_neg

  :  {#} {-1} = sum_neg.

Proof Ring.prod_n1_neg ring.



Theorem prod_x_n1_neg

  :  forall x : E, x # {-1} = - x.

Proof Ring.prod_x_n1_neg ring.



Theorem prod_n1_x_neg

  :  forall x : E, {-1} # x = - x.

Proof Ring.prod_n1_x_neg ring.



Theorem prod_n1_eq

  :  forall x : E, {-1} # x = x # {-1} .

Proof Ring.prod_n1_eq ring.



Theorem neg_1

  :  {-} 1 = {-1}.

Proof Ring.neg_1 ring.



Theorem neg_n1

  :  sum_neg {-1} = 1.

Proof Ring.neg_n1 ring.



Theorem prod_n1_n1

  :  {-1} # {-1} = 1.

Proof Ring.prod_n1_n1 ring.



Theorem E_n1_inv

  :  prod_is_inv {-1} {-1}.

Proof Ring.E_n1_inv ring.



End Theorems.



End Commutative_Ring.



Notation "0" := (Commutative_Ring.E_0) : commutative_ring_scope.



Notation "1" := (Commutative_Ring.E_1) : commutative_ring_scope.



Notation "x + y" := (Commutative_Ring.sum x y) (at level 50, left associativity) : commutative_ring_scope.



Notation "{+}" := (Commutative_Ring.sum) : commutative_ring_scope.



Notation "{-}" := (Commutative_Ring.sum_neg _) : commutative_ring_scope.



Notation "- x" := (Commutative_Ring.sum_neg _ x) : commutative_ring_scope.



Notation "x # y" := (Commutative_Ring.prod x y) (at level 50, left associativity) : commutative_ring_scope.



Notation "{#}" := (Commutative_Ring.prod) : commutative_ring_scope.

