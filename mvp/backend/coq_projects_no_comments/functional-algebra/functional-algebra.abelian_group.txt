

Require Import Description.

Require Import base.

Require Import function.

Require Import monoid.

Require Import group.



Module Abelian_Group.



Definition is_comm (T : Type) (f : T -> T -> T)

  :  Prop

  := forall x y : T, f x y = f y x.



Structure Abelian_Group : Type := abelian_group {



  E : Set;



  E_0 : E;



  op : E -> E -> E;



  op_is_assoc : Monoid.is_assoc E op;



  op_is_comm : is_comm E op;



  op_id_l : Monoid.is_id_l E op E_0;



  op_inv_l_ex : forall x : E, exists y : E, op y x = E_0

}.



Arguments E_0 {a}.



Arguments op {a} x y.



Arguments op_is_assoc {a} x y z.



Arguments op_is_comm {a} x y.



Arguments op_id_l {a} x.



Arguments op_inv_l_ex {a} x.



Notation "0" := E_0 : abelian_group_scope.



Notation "x + y" := (op x y) (at level 50, left associativity) : abelian_group_scope.



Notation "{+}" := op : abelian_group_scope.



Open Scope abelian_group_scope.



Section Theorems.



Variable g : Abelian_Group.



Let E := E g.



Definition op_is_id_l := Monoid.is_id_l E {+}.



Definition op_is_id_r := Monoid.is_id_r E {+}.



Definition op_is_id := Monoid.is_id E {+}.



Theorem op_is_id_lr

  :  forall x : E, op_is_id_l x -> op_is_id_r x.

Proof

  fun x H y

    => H y

    || a = y @a by op_is_comm y x.



Theorem op_is_id_lid

  : forall x : E, op_is_id_l x -> op_is_id x.

Proof

  fun x H

    => conj H (op_is_id_lr x H).



Theorem op_id_r

  :  op_is_id_r 0.

Proof op_is_id_lr 0 op_id_l.



Theorem op_id

  :  op_is_id 0.

Proof conj op_id_l op_id_r.



Definition op_is_inv_l := Monoid.is_inv_l E {+} 0 op_id.



Definition op_is_inv_r := Monoid.is_inv_r E {+} 0 op_id.



Definition op_is_inv := Monoid.is_inv E {+} 0 op_id.



Theorem op_inv_r_ex

  :  forall x : E, exists y : E, op_is_inv_r x y.

Proof

  fun x

    => ex_ind

         (fun (y : E) (H : op_is_inv_l x y)

           => ex_intro

                (op_is_inv_r x)

                y

                (H || a = 0 @a by op_is_comm x y))

         (op_inv_l_ex x).



Definition op_group := Group.group E 0 {+} op_is_assoc op_id_l op_id_r op_inv_l_ex op_inv_r_ex.



Definition op_monoid := Group.op_monoid op_group.



Definition has_inv_l := Group.has_inv_l op_group.



Definition has_inv_r := Group.has_inv_r op_group.



Definition has_inv := Group.has_inv op_group.



Theorem op_id_l_uniq

  :  forall x : E, Monoid.is_id_l E {+} x -> x = 0.

Proof Group.op_id_l_uniq op_group.



Theorem op_id_r_uniq

  :  forall x : E, Monoid.is_id_r E {+} x -> x = 0.

Proof Group.op_id_r_uniq op_group.



Theorem op_id_uniq

  :  forall x : E, Monoid.is_id E {+} x -> x = 0.

Proof Group.op_id_uniq op_group.



Theorem op_inv_l_r_eq

  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.

Proof Group.op_inv_l_r_eq op_group.



Theorem op_inv_sym

  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.

Proof Group.op_inv_sym op_group.



Theorem op_inv_ex

  :  forall x : E, exists y : E, op_is_inv x y.

Proof Group.op_inv_ex op_group.



Theorem op_intro_l

  :  forall x y z : E, x = y -> z + x = z + y.

Proof Group.op_intro_l op_group.



Theorem op_intro_r

  :  forall x y z : E, x = y -> x + z = y + z.

Proof Group.op_intro_r op_group.



Theorem op_cancel_l

  :   forall x y z : E, z + x = z + y -> x = y.

Proof Group.op_cancel_l op_group.



Theorem op_cancel_r

  :   forall x y z : E, x + z = y + z -> x = y.

Proof Group.op_cancel_r op_group.



Theorem op_inv_l_uniq

  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.

Proof Group.op_inv_l_uniq op_group.



Theorem op_inv_r_uniq

  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.

Proof Group.op_inv_r_uniq op_group.



Theorem op_inv_uniq

  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.

Proof Group.op_inv_uniq op_group.



Theorem op_inv_uniq_ex

  :  forall x : E, exists! y : E, op_is_inv x y.

Proof Group.op_inv_uniq_ex op_group.



Theorem op_inv_0_l

  :  op_is_inv_l 0 0.

Proof Group.op_inv_0_l op_group.



Theorem op_inv_0_r

  :  op_is_inv_r 0 0.

Proof Group.op_inv_0_r op_group.



Theorem op_inv_0

  :  op_is_inv 0 0.

Proof Group.op_inv_0 op_group.



Theorem op_has_inv_l_0

  :  has_inv_l 0.

Proof Group.op_has_inv_l_0 op_group.



Theorem op_has_inv_r_0

  :  has_inv_r 0.

Proof Group.op_has_inv_r_0 op_group.



Theorem op_has_inv_0

  :  has_inv 0.

Proof Group.op_has_inv_0 op_group.



Theorem op_inv_0_eq_0

  :  forall x : E, op_is_inv x 0 -> x = 0.

Proof Group.op_inv_0_eq_0 op_group.



Theorem op_inv_0_uniq

  :  unique (fun x => op_is_inv x 0) 0.

Proof Group.op_inv_0_uniq op_group.

 

Definition op_neg_strong

  :  forall x : E, { y | op_is_inv x y }

  := Group.op_neg_strong op_group.



Definition op_neg

  :  E -> E

  := Group.op_neg op_group.



Close Scope nat_scope.



Notation "{-}" := (op_neg) : abelian_group_scope.



Notation "- x" := (op_neg x) : abelian_group_scope.



Theorem op_neg_def

  :  forall x : E, op_is_inv x (- x).

Proof Group.op_neg_def op_group.



Theorem op_neg_inj

  :  is_injective E E op_neg.

Proof Group.op_neg_inj op_group.



Theorem op_cancel_neg

  :  forall x : E, op_neg (- x) = x.

Proof Group.op_cancel_neg op_group.



Theorem op_neg_onto

  :  is_onto E E op_neg.

Proof Group.op_neg_onto op_group.



Theorem op_neg_bijective

  :  is_bijective E E op_neg.

Proof Group.op_neg_bijective op_group.



Theorem op_neg_rev

  :  forall x y : E, - x = y -> - y = x.

Proof Group.op_neg_rev op_group.



Theorem op_neg_distrib_inv_l

  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).

Proof Group.op_neg_distrib_inv_l op_group.



Theorem op_neg_distrib_inv_r

  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).

Proof Group.op_neg_distrib_inv_r op_group.



Theorem op_neg_distrib_inv

  :  forall x y : E, op_is_inv (x + y) (- y + - x).

Proof Group.op_neg_distrib_inv op_group.



Theorem op_neg_distrib

  :  forall x y : E, - (x + y) = - y + - x.

Proof Group.op_neg_distrib op_group.



End Theorems.



End Abelian_Group.



Notation "0" := (Abelian_Group.E_0) : abelian_group_scope.



Notation "x + y" := (Abelian_Group.op x y) (at level 50, left associativity) : abelian_group_scope.



Notation "{+}" := (Abelian_Group.op) : abelian_group_scope.



Notation "{-}" := (Abelian_Group.op_neg _) : abelian_group_scope.



Notation "- x" := (Abelian_Group.op_neg _ x) : abelian_group_scope.

