

Require Import ProofIrrelevance.

Require Import Description.

Require Import base.

Require Import function.

Require Import monoid.



Module Group.



Structure Group : Type := group {



  E: Set;



  E_0: E;



  op: E -> E -> E;



  op_is_assoc : Monoid.is_assoc E op;



  op_id_l : Monoid.is_id_l E op E_0;



  op_id_r : Monoid.is_id_r E op E_0;



  op_inv_l_ex : forall x : E, exists y : E, Monoid.is_inv_l E op E_0 (conj op_id_l op_id_r) x y;



  op_inv_r_ex : forall x : E, exists y : E, Monoid.is_inv_r E op E_0 (conj op_id_l op_id_r) x y

}.



Arguments E_0 {g}.



Arguments op {g} x y.



Arguments op_is_assoc {g} x y z.



Arguments op_id_l {g} x.



Arguments op_id_r {g} x.



Arguments op_inv_l_ex {g} x.



Arguments op_inv_r_ex {g} x.



Notation "0" := E_0 : group_scope.



Notation "x + y" := (op x y) (at level 50, left associativity) : group_scope.



Notation "{+}" := op : group_scope.



Open Scope group_scope.



Section Theorems.



Variable g : Group.



Let E := E g.



Definition op_monoid := Monoid.monoid E 0 {+} op_is_assoc op_id_l op_id_r.



Definition op_is_id_l := Monoid.op_is_id_l op_monoid.



Definition op_is_id_r := Monoid.op_is_id_r op_monoid.



Definition op_is_id := Monoid.op_is_id op_monoid.



Theorem op_id

  :  op_is_id 0.

Proof Monoid.op_id op_monoid.



Definition op_is_inv_l := Monoid.op_is_inv_l op_monoid.



Definition op_is_inv_r := Monoid.op_is_inv_r op_monoid.



Theorem op_id_l_uniq

  :  forall x : E, (op_is_id_l x) -> x = 0.

Proof Monoid.op_id_l_uniq op_monoid.



Theorem op_id_r_uniq 

  :  forall x : E, (op_is_id_r x) -> x = 0.

Proof Monoid.op_id_r_uniq op_monoid.



Theorem op_id_uniq

  :  forall x : E, (op_is_id x) -> x = 0.

Proof Monoid.op_id_uniq op_monoid.



Theorem op_intro_l

  :  forall x y z : E, x = y -> z + x = z + y.

Proof Monoid.op_intro_l op_monoid.



Theorem op_intro_r

  :  forall x y z : E, x = y -> x + z = y + z.

Proof Monoid.op_intro_r op_monoid.



Definition op_is_inv := Monoid.op_is_inv op_monoid.



Definition has_inv_l := Monoid.has_inv_l op_monoid.



Definition has_inv_r := Monoid.has_inv_r op_monoid.



Definition has_inv := Monoid.has_inv op_monoid.



Theorem op_inv_l_r_eq

  :  forall x y : E, op_is_inv_l x y -> forall z : E, op_is_inv_r x z -> y = z.

Proof Monoid.op_inv_l_r_eq op_monoid.



Theorem op_inv_sym

  :  forall x y : E, op_is_inv x y <-> op_is_inv y x.

Proof Monoid.op_inv_sym op_monoid.



Theorem op_inv_ex

  :  forall x : E, exists y : E, op_is_inv x y.

Proof

  fun x : E

    => ex_ind

            (fun y H

              => ex_ind

                   (fun z H0

                     => let H1

                          :  op_is_inv_r x y

                          :=  H0

                          || op_is_inv_r x a @a

                             by op_inv_l_r_eq x y H z H0 in

                        ex_intro

                          (fun a => op_is_inv x a)

                          y

                          (conj H H1))

                   (op_inv_r_ex x))

            (op_inv_l_ex x).



Theorem op_cancel_l

  :  forall x y z : E, z + x = z + y -> x = y.

Proof

  fun x y z H 

    => Monoid.op_cancel_l op_monoid x y z (op_inv_l_ex z) H.



Theorem op_cancel_r

  :  forall x y z : E, x + z = y + z -> x = y.

Proof

  fun x y z

    => Monoid.op_cancel_r op_monoid x y z (op_inv_r_ex z).



Theorem op_inv_l_uniq

  :  forall x y z : E, op_is_inv_l x y -> op_is_inv_l x z -> z = y.

Proof

  fun x

    => Monoid.op_inv_l_uniq op_monoid x (op_inv_r_ex x).



Theorem op_inv_r_uniq

  :  forall x y z : E, op_is_inv_r x y -> op_is_inv_r x z -> z = y.

Proof

  fun x

    => Monoid.op_inv_r_uniq op_monoid x (op_inv_l_ex x).



Theorem op_inv_uniq

  :  forall x y z : E, op_is_inv x y -> op_is_inv x z -> z = y.

Proof Monoid.op_inv_uniq op_monoid.



Theorem op_inv_uniq_ex

  :  forall x : E, exists! y : E, op_is_inv x y.

Proof

  fun x

    => ex_ind

            (fun y (H : op_is_inv x y)

              => ex_intro 

                   (fun y => op_is_inv x y /\ forall z, op_is_inv x z -> y = z)

                   y

                   (conj H (fun z H0 => eq_sym (op_inv_uniq x y z H H0))))

            (op_inv_ex x).



Theorem op_inv_0_l

  :  op_is_inv_l 0 0.

Proof Monoid.op_inv_0_l op_monoid.



Theorem op_inv_0_r

  :  op_is_inv_r 0 0.

Proof Monoid.op_inv_0_r op_monoid.



Theorem op_inv_0

  :  op_is_inv 0 0.

Proof Monoid.op_inv_0 op_monoid.



Theorem op_has_inv_l_0

  :  has_inv_l 0.

Proof Monoid.op_has_inv_l_0 op_monoid.



Theorem op_has_inv_r_0

  :  has_inv_r 0.

Proof Monoid.op_has_inv_r_0 op_monoid.



Theorem op_has_inv_0

  :  has_inv 0.

Proof Monoid.op_has_inv_0 op_monoid.



Theorem op_inv_0_eq_0

  :  forall x : E, op_is_inv x 0 -> x = 0.

Proof Monoid.op_inv_0_eq_0 op_monoid.



Theorem op_inv_0_uniq

  :  unique (fun x => op_is_inv x 0) 0.

Proof Monoid.op_inv_0_uniq op_monoid.

 

Definition op_neg_strong

  :  forall x : E, { y | op_is_inv x y }

  := fun x => Monoid.op_neg_strong op_monoid x (op_inv_ex x).



Definition op_neg

  :  E -> E

  := fun x => Monoid.op_neg op_monoid x (op_inv_ex x).



Notation "{-}" := (op_neg) : group_scope.



Notation "- x" := (op_neg x) : group_scope.



Theorem op_neg_def

  :  forall x : E, op_is_inv x (- x).

Proof

  fun x

    => Monoid.op_neg_def op_monoid x (op_inv_ex x).



Theorem op_neg_inj

  :  is_injective E E op_neg.

Proof

  fun x y

    => Monoid.op_neg_inj op_monoid x (op_inv_ex x) y (op_inv_ex y).



Theorem op_cancel_neg

  :  forall x : E, - (- x) = x.

Proof

  fun x

    => Monoid.op_cancel_neg_gen op_monoid x (op_inv_ex x) (op_inv_ex (- x)).



Theorem op_neg_onto

  :  is_onto E E {-}.

Proof

  fun x => ex_intro (fun y => - y = x) (- x) (op_cancel_neg x).



Theorem op_neg_bijective

  :  is_bijective E E {-}.

Proof

  conj op_neg_inj op_neg_onto.



Theorem op_neg_rev

  :  forall x y : E, - x = y -> - y = x.

Proof

  fun x y H

    => eq_sym

            (f_equal {-} H

             || a = - y @a by <- op_cancel_neg x).



Theorem op_neg_distrib_inv_l

  :  forall x y : E, op_is_inv_l (x + y) (- y + - x).

Proof

  fun x y

    => ((proj2 (op_neg_def (- y)))

            || - y + a = 0                 @a by <- op_cancel_neg y

            || - y + a = 0                 @a by op_id_l y

            || - y + (a + y) = 0           @a by proj2 (op_neg_def (- x))

            || - y + ((- x + a) + y) = 0 @a by <- op_cancel_neg x

            || - y + a = 0                 @a by op_is_assoc (- x) x y

            || a = 0                         @a by <- op_is_assoc (- y) (- x) (x + y)).



Theorem op_neg_distrib_inv_r

  :  forall x y : E, op_is_inv_r (x + y) (- y + - x).

Proof

  fun x y

    => ((proj2 (op_neg_def x))

            || x + a = 0           @a by op_id_l (- x)

            || x + (a + - x) = 0 @a by proj2 (op_neg_def y)

            || x + a = 0           @a by op_is_assoc y (- y) (- x)

            || a = 0               @a by <- op_is_assoc x y (- y + - x)).



Theorem op_neg_distrib_inv

  :  forall x y : E, op_is_inv (x + y) (- y + - x).

Proof

  fun x y

    => conj

            (op_neg_distrib_inv_l x y)

            (op_neg_distrib_inv_r x y).



Theorem op_neg_distrib

  :  forall x y : E, - (x + y) = - y + - x.

Proof

  fun x y

    => ex_ind

            (fun z (H : unique (op_is_inv (x + y)) z)

              => let H0

                   :  z = - (x + y)

                   := (proj2 H) 

                       (- (x + y))

                       (op_neg_def (x + y)) in

                 let H1

                   :  z = (- y + - x)

                   := (proj2 H)

                        (- y + - x)

                        (op_neg_distrib_inv x y) in

                 (H1 || a = - y + - x @a by <- H0))

            (op_inv_uniq_ex (x + y)).



End Theorems.



End Group.



Notation "0" := (Group.E_0) : group_scope.



Notation "x + y" := (Group.op x y) (at level 50, left associativity) : group_scope.



Notation "{+}" := (Group.op) : group_scope.



Notation "{-}" := (Group.op_neg _) : group_scope.



Notation "- x" := (Group.op_neg _ x) : group_scope.

