

Require Import Arith Bool List ZArith. Import ListNotations.

From QuickChick Require Import QuickChick. Import QcNotation.



Set Warnings "-extraction-opaque-accessed,-extraction".



Require Export ExtLib.Structures.Monads.

Export MonadNotation. Open Scope monad_scope.



Require Import String. Local Open Scope string.



Check returnGen. 



Check bindGen.

 

Section GMonadDef. 



Instance GMonad : `{Monad G} | 3 :=

  {

    ret := @returnGen;

    bind := @bindGen

  }.



End GMonadDef.



Check @choose.



Print ChoosableFromInterval. 



Check listOf.



Check vectorOf.



Module DefineG.



Inductive G (A:Type) : Type :=

| MkG : (nat -> RandomSeed -> A) -> G A.



End DefineG.



Inductive Tree A :=

| Leaf : Tree A

| Node : A -> Tree A -> Tree A -> Tree A.



Arguments Leaf {A}.

Arguments Node {A} _ _ _.



Instance showTree {A} `{_ : Show A} : Show (Tree A) :=

  {| show := let fix aux t :=

       match t with

         | Leaf => "Leaf"

         | Node x l r =>

             "Node (" ++ show x ++ ") (" 

                      ++ aux l ++ ") (" 

                      ++ aux r ++ ")"

       end

     in aux

  |}.



Check oneOf_.



Fixpoint genTreeSized {A} (sz : nat) (g : G A) : G (Tree A) :=

  match sz with

    | O => ret Leaf

    | S sz' =>

        oneOf [ 

          ret Leaf ;

          liftM3 Node g (genTreeSized sz' g) (genTreeSized sz' g)

        ]

  end.



Check freq_.



Fixpoint genTreeSized' {A} (sz : nat) (g : G A) : G (Tree A) :=

  match sz with

    | O => ret Leaf 

    | S sz' =>

        freq [ (1,  ret Leaf) ;

               (sz, liftM3 Node g (genTreeSized' sz' g)

                                  (genTreeSized' sz' g))

             ]

  end.



Module CheckerPlayground1.



Inductive Result := Success | Failure.



Instance showResult : Show Result :=

  {

    show r := match r with Success => "Success" | Failure => "Failure" end

  }.



Definition Checker := G Result.



Class Checkable A :=

  {

    checker : A -> Checker

  }.



Instance checkableBool : Checkable bool :=

  {

    checker b := if b then ret Success else ret Failure

  }.



End CheckerPlayground1.



Module CheckerPlayground2.

Export CheckerPlayground1.



Instance checkableDec `{P : Prop} `{Dec P} : Checkable P :=

  {

    checker p := if P? then ret Success else ret Failure

  }.



Conjecture c1 : 0 = 42.

Conjecture c2 : 41 + 1 = 42.



End CheckerPlayground2.



Fixpoint mirror {A : Type} (t : Tree A) : Tree A :=

  match t with

    | Leaf => Leaf

    | Node x l r => Node x (mirror r) (mirror l)

  end.



Instance eq_dec_tree (t1 t2 : Tree nat) : Dec (t1 = t2) := {}.

Proof. dec_eq. Defined.



Definition mirrorP (t : Tree nat) := (mirror (mirror t)) = t?.



Module CheckerPlayground3.

Import CheckerPlayground2.



Definition forAll {A B : Type} `{Checkable B}

             (g : G A) (f : A -> B)

           : Checker :=

  a <- g ;;

  checker (f a).



End CheckerPlayground3.



Definition faultyMirrorP (t : Tree nat) := (mirror t) = t ?.



Module CheckerPlayground4.



Inductive Result :=

  | Success : Result

  | Failure : forall {A} `{Show A}, A -> Result.



Instance showResult : Show Result :=

  {

    show r := match r with

              | Success => "Success"

              | Failure A showA a => "Failure: " ++ show a

              end

  }.



Definition Checker := G Result.



Class Checkable A :=

  {

    checker : A -> Checker

  }.



Instance showUnit : Show unit :=

  {

    show u := "tt"

  }.



Instance checkableBool : Checkable bool :=

  {

    checker b := if b then ret Success else ret (Failure tt)

  }.



Instance checkableDec `{P : Prop} `{Dec P} : Checkable P :=

  {

    checker p := if P? then ret Success else ret (Failure tt)

  }.



Definition forAll {A B : Type} `{Show A} `{Checkable B}

                  (g : G A) (f : A -> B)

                : Checker :=

  a <- g ;;

  r <- checker (f a) ;;

  match r with

    Success => ret Success

  | Failure B showB b => ret (Failure (a,b))

  end.



End CheckerPlayground4.



Derive Shrink for Tree.



Derive Arbitrary for Tree.



Print GenSizedTree.

Print ShrinkTree.



Derive Show for Tree.



Print ShowTree.



Check @collect.



Fixpoint size {A} (t : Tree A) : nat :=

  match t with

    | Leaf => O

    | Node _ l r => 1 + size l + size r

  end.



Definition treeProp (g : nat -> G nat -> G (Tree nat)) n :=

  forAll (g n (choose (0,n))) (fun t => collect (size t) true).



Remove Hints genListSized : typeclass_instances.



Open Scope bool.



Fixpoint sorted (l : list nat) := 

  match l with 

  | [] => true 

  | x::xs => match xs with 

             | [] => true 

             | y :: ys => (x <=? y) && (sorted xs) 

             end 

  end.



Fixpoint insert (x : nat) (l : list nat) := 

  match l with 

  | [] => [x] 

  | y::ys => if x <=? y then x :: l 

             else y :: insert x ys 

  end.



Definition insert_spec (x : nat) (l : list nat) :=

  sorted l ==> sorted (insert x l).



Definition insert_spec' (x : nat) (l : list nat) :=

  collect (List.length l) (insert_spec x l).



Fixpoint genSortedList (low high : nat) (size : nat)

  : G (list nat).

  

Admitted.



Definition insert_spec_sorted (x : nat) :=

  forAllShrink 

    (genSortedList 0 10 10) 

    shrink 

    (fun l => insert_spec' x l).



QuickChick insert_spec_sorted.



