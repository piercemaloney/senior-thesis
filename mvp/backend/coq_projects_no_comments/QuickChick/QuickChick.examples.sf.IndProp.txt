
Set Warnings "-extraction-opaque-accessed,-extraction".
Set Warnings "-notation-overridden,-parsing".

Require Import String List. Open Scope string.

From QuickChick Require Import QuickChick Tactics.
From mathcomp Require Import ssreflect ssrfun ssrbool ssrnat eqtype seq.
Import QcDefaultNotation. Open Scope qc_scope.

Set Bullet Behavior "Strict Subproofs".

Inductive ev : nat -> Prop :=
| ev_0 : ev 0
| ev_SS : forall n : nat, ev n -> ev (S (S n)).

Derive ArbitrarySizedSuchThat for (fun n => ev n).
Derive SizedProofEqs for (fun n => ev n).
Derive SizeMonotonicSuchThatOpt for (fun n => ev n).
Derive GenSizedSuchThatCorrect for (fun n => ev n).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => ev n).

Instance dec_ev (n : nat) : Dec (ev n) :=
  {| dec := let fix aux n := 
                let n' := n in
                let Heq := erefl n' : n' = n in
                match n as n'' return (n' = n'' -> _) with
                | O => fun H => left _ 
                | S O => fun H => right _ 
                | S (S n) => fun H => _ (aux n) 
                end Heq in 
  aux n |}.
Proof.  
- assert (Eq: n' = n) by auto.
  rewrite -Eq; rewrite H; constructor.
- assert (Eq: n' = n) by auto.
  rewrite -Eq; rewrite H => Contra.
  inversion Contra.
- assert (Eq: n' = n2) by auto.
  clear Heq; rewrite Eq in H; clear Eq.
  move => [EvN | OddN].
  + rewrite H; left; constructor; auto.
  + rewrite H; right => Contra.
    inversion Contra; subst; auto.
Defined.

Theorem ev_plus4 : forall n, ev n -> ev (4 + n).
Admitted. 

Theorem ev_double : forall n,
  ev (double n).
Admitted. 

Theorem ev_minus2 : forall n,
  ev n -> ev (Peano.pred (Peano.pred n)).
Admitted. 

Theorem ev_minus2' : forall n,
  ev n -> ev (Peano.pred (Peano.pred n)).
Admitted. 

Theorem evSS_ev : forall n,
  ev (S (S n)) -> ev n.
Admitted. 

Definition double_reverse n : nat := n.

Axiom double_reverse_correct : forall n, n = double (double_reverse n).

Instance dec_ex_double n : Dec (exists k, n = double k).
constructor; unfold decidable.
left; exists (double_reverse n). 
eapply double_reverse_correct.
Defined.

Lemma ev_even_firsttry : forall n,
  ev n -> exists k, n = double k.
Admitted. 

Global Instance testSuchThat_swap_2 {A B : Type} {pre : A -> Prop} 
       {prop : A -> B -> Type}
       `{Checkable (forall a, pre a -> forall b, prop a b)} :
  Checkable (forall a b, pre a -> prop a b ) :=
  {| checker f := @checker (forall a, pre a -> forall b, prop a b) _ _ |}. 
Proof. intros; eauto. Defined.

Theorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).
Admitted. 

Inductive ev' : nat -> Prop :=
| ev'_0 : ev' 0
| ev'_2 : ev' 2
| ev'_sum : forall n m, ev' n -> ev' m -> ev' (n + m).

Theorem ev'_ev : forall n, ev' n <-> ev n.
Admitted. 

Theorem ev_ev__ev : forall n m,
  ev (n+m) -> ev n -> ev m.
Admitted. 

Theorem ev_plus_plus : forall n m p,
  ev (n+m) -> ev (n+p) -> ev (m+p).
Admitted. 

Inductive next_nat : nat -> nat -> Prop :=
  | nn : forall n:nat, next_nat n (S n).

Derive ArbitrarySizedSuchThat for (fun n => next_nat n m).
Derive SizeMonotonicSuchThatOpt for (fun n => next_nat n m).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_nat n m).
Derive SizedProofEqs for (fun n => next_nat n m).
Derive GenSizedSuchThatCorrect for (fun n => next_nat n m).

Derive ArbitrarySizedSuchThat for (fun n => next_nat m n).
Derive SizeMonotonicSuchThatOpt for (fun n => next_nat m n).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_nat n m).
Derive SizedProofEqs for (fun n => next_nat n m).
Derive GenSizedSuchThatCorrect for (fun n => next_nat n m).

Inductive next_even : nat -> nat -> Prop :=
  | ne_1 : forall n, ev (S n) -> next_even n (S n)
  | ne_2 : forall n, ev (S (S n)) -> next_even n (S (S n)).

Derive ArbitrarySizedSuchThat for (fun n => next_even n m).
Derive SizeMonotonicSuchThatOpt for (fun n => next_even n m).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_even n m).
Derive SizedProofEqs for (fun n => next_even n m).
Derive GenSizedSuchThatCorrect for (fun n => next_even n m).

Derive ArbitrarySizedSuchThat for (fun n => next_even m n).
Derive SizeMonotonicSuchThatOpt for (fun n => next_even m n).
Derive GenSizedSuchThatSizeMonotonicOpt for (fun n => next_even n m).
Derive SizedProofEqs for (fun n => next_even n m).
Derive GenSizedSuchThatCorrect for (fun n => next_even n m).

Lemma le_trans : forall m n o, m <= n -> n <= o -> m <= o.
Admitted. 

Theorem O_le_n : forall n,
  0 <= n.
Admitted. 

Theorem n_le_m__Sn_le_Sm : forall n m,
  n <= m -> S n <= S m.
Admitted. 

Theorem Sn_le_Sm__n_le_m : forall n m,
  S n <= S m -> n <= m.
Admitted. 

Theorem le_plus_l : forall a b,
  a <= a + b.
Admitted. 

Theorem plus_lt : forall n1 n2 m,
  n1 + n2 < m ->
  n1 < m /\ n2 < m.
Admitted. 

Theorem lt_S : forall n m,
  n < m ->
  n < S m.
Admitted. 

Inductive reg_exp (T : Type) : Type :=
| EmptySet : reg_exp T
| EmptyStr : reg_exp T
| Char : T -> reg_exp T
| App : reg_exp T -> reg_exp T -> reg_exp T
| Union : reg_exp T -> reg_exp T -> reg_exp T
| Star : reg_exp T -> reg_exp T.

Arguments EmptySet {T}.
Arguments EmptyStr {T}.
Arguments Char {T} _.
Arguments App {T} _ _.
Arguments Union {T} _ _.
Arguments Star {T} _.

Derive (Arbitrary, Show) for reg_exp.
Derive (Sized, CanonicalSized) for reg_exp.
Derive SizeMonotonic for reg_exp using genSreg_exp.
Derive SizedMonotonic for reg_exp.
Derive SizedCorrect for reg_exp using genSreg_exp and SizeMonotonicreg_exp.

Import ListNotations.
Inductive exp_match {T} : list T -> reg_exp T -> Prop :=
| MEmpty : exp_match [] EmptyStr
| MChar : forall x, exp_match [x] (Char x)
| MApp : forall s1 re1 s2 re2,
           exp_match s1 re1 ->
           exp_match s2 re2 ->
           exp_match (s1 ++ s2) (App re1 re2)
| MUnionL : forall s1 re1 re2,
              exp_match s1 re1 ->
              exp_match s1 (Union re1 re2)
| MUnionR : forall re1 s2 re2,
              exp_match s2 re2 ->
              exp_match s2 (Union re1 re2)
| MStar0 : forall re, exp_match [] (Star re)
| MStarApp : forall s1 s2 re,
               exp_match s1 re ->
               exp_match s2 (Star re) ->
               exp_match (s1 ++ s2) (Star re).

Notation "s =~ re" := (exp_match s re) (at level 80).

Lemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),
  s =~ re1 \/ s =~ re2 ->
  s =~ Union re1 re2.
Proof.
   Admitted.

