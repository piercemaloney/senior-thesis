
Require Import RandomQC GenLow.

Import GenLow.

Inductive vec A : nat -> Type :=
  | nil : vec A 0
  | cons : forall {n:nat}, A -> vec A n -> vec A (S n).

Definition vapp {A}{n}{p} (v:vec A n) (w:vec A p) : vec A (n+p).
induction v. apply w. simpl.
apply cons. apply a. apply IHv.
Defined.

Fixpoint tvec_to_fun {n} (v : vec Type n) (t:Type) (f : Type -> Type) : Type :=
  match v with
  | nil => t
  | cons _ X v' => f X -> tvec_to_fun v' t f
  end.

Fixpoint tvec_to_prod {n} (v : vec Type n) : Type :=
  match v with
  | nil => unit
  | cons _ X v' => prod X (tvec_to_prod v')
  end.

Definition applyN {n:nat} {As : vec Type n} {B : Type}
  (F : tvec_to_fun As B id) (vs : tvec_to_prod As) : B.
induction As as [| n A1 As']; simpl in *. exact F.
destruct vs as [v vs']. info_eauto.
Defined. Print applyN.

Definition liftGenN_aux : forall {n :nat} {As : vec Type n} {B : Type}
                                 (n':nat) (As': vec Type n') (vs : tvec_to_prod As')
             (F : tvec_to_fun (vapp As As') B id), tvec_to_fun As (G B) G.
induction As as [| n AH AsT]; intros; simpl in *. exact (returnGen (applyN F vs)).
intro m1. 

Admitted.

Definition liftGenN_aux' :
  forall (n':nat) (As': vec Type n') (vs : tvec_to_prod As')
                        {n :nat} {As : vec Type n} {B : Type}
             (F : tvec_to_fun (vapp As As') B id), tvec_to_fun As (G B) G.
Admitted.

Definition liftGenN : forall {n:nat} {As : vec Type n} {B : Type}
    (F : tvec_to_fun As B id), tvec_to_fun As (G B) G.
  
  intros. apply (liftGenN_aux' 0 (nil Type) tt).
Admitted.

