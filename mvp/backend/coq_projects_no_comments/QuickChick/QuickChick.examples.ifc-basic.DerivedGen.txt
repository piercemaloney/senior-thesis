From QuickChick Require Import QuickChick.



Require Import ZArith.

Require Import NPeano.

Require Import List.

Import ListNotations.

From QuickChick.ifcbasic Require Import Machine Printing Generation.



Set Bullet Behavior "Strict Subproofs".



Local Open Scope nat.



Inductive good_Z : Z -> Prop := 

  | GoodZ0 : good_Z 0

  | GoodZ1 : good_Z 1.



Derive ArbitrarySizedSuchThat for (fun z => good_Z z).



Derive Arbitrary for Label.



Inductive good_atom : Atom -> Prop :=

  | GoodAtom : forall z l, good_Z z -> good_atom (Atm z l).

Derive ArbitrarySizedSuchThat for (fun a => good_atom a).



Inductive good_mem : Mem -> Prop :=

  | GoodMem : forall a1 a2, good_atom a1 -> good_atom a2 -> good_mem [a1 ; a2].

Derive ArbitrarySizedSuchThat for (fun m => good_mem m).



Definition is_atom_low (a : Atom) :=

  match a with

    | _ @ L => true

    | _     => false

  end.



Inductive good_stack : nat -> Stack -> Prop :=

| GoodStackMty  : good_stack 0 Mty

| GoodStackCons : forall n a s , good_atom a  -> good_stack n s -> good_stack (S n) (a  :: s)

| GoodStackRet  : forall n pc s, good_atom pc -> good_stack n s -> good_stack (S n) (RetCons pc s).



QuickChickWeights [(GoodStackCons, 10); (GoodStackRet, 4)].

Derive ArbitrarySizedSuchThat for (fun s => good_stack n s).



Inductive contains_ret : Stack -> Prop := 

  | RetHere  : forall pc s, contains_ret (RetCons pc s)

  | RetLater : forall a  s, contains_ret s -> contains_ret (a :: s).

Instance dec_contains_ret (s : Stack) : Dec (contains_ret s).

Proof.

  dec_eq.

  induction s.

  - right => H; inversion H.

  - destruct IHs.

    + left; constructor; auto.

    + right => H; inversion H; eauto.

  - left; constructor; auto.

Defined.



Inductive stack_length : Stack -> nat -> Prop :=

| LenMty  : stack_length Mty 0

| LenRet  : forall pc s, stack_length (pc :: s) 0

| LenCons : forall a s n, stack_length s n -> stack_length (a :: s) (S n).

Derive ArbitrarySizedSuchThat for (fun n => stack_length s n).



Inductive between (x y : Z) (z : nat) : Prop :=

| Bet : (x < y -> y < Z.of_nat z -> between x y z)%Z.

Instance genST_bet x z : GenSizedSuchThat Z (fun y => between x y z) := 

{|

  arbitrarySizeST n := liftGen Some (choose (x, Z.of_nat z))

|}.



Inductive good_instr (stk : Stack) : Instruction -> Prop :=

  | GoodNop   : good_instr stk Nop

  | GoodPush  : forall z, good_Z z -> good_instr stk (Push z)

  | GoodCall  : forall z n, 

      stack_length stk n ->

      between 0 z n ->

      good_instr stk (BCall z)

  | GoodRet   : contains_ret stk -> good_instr stk BRet 

  | GoodAdd   : good_instr stk Add 

  | GoodLoad  : good_instr stk Load

  | GoodStore : good_instr stk Store.



QuickChickWeights [ (GoodNop, 1)

                  ; (GoodPush, 10)

                  ; (GoodCall, 10)

                  ; (GoodRet, 10)

                  ; (GoodAdd, 10)

                  ; (GoodLoad, 10)

                  ; (GoodStore, 100) ].

Derive ArbitrarySizedSuchThat for (fun i => good_instr stk i). 



Inductive good_state : State -> Prop :=

  | GoodState : 

      forall i m stk pc, 

        good_atom pc ->

        good_mem m ->

        good_stack 4 stk ->

        good_instr stk i ->

        good_state (St [i;i] m stk pc).

Derive ArbitrarySizedSuchThat for (fun st => good_state st).        



Inductive variation_atom : Atom -> Atom -> Prop :=

| VaryAtomL : forall x  , variation_atom (x @ L) (x @ L)

| VaryAtomH : forall x y, good_Z y -> variation_atom (x @ H) (y @ H).

Derive ArbitrarySizedSuchThat for (fun y => variation_atom x y).



Inductive variation_mem : Mem -> Mem -> Prop :=

| VaryMemNil  : variation_mem [] []

| VaryMemCons : forall a a' m m', variation_atom a a' ->

                                   variation_mem m m'  ->

                                   variation_mem (cons a m) (cons a' m').

Derive ArbitrarySizedSuchThat for (fun m2 => variation_mem m1 m2).    



Inductive variation_stack : Stack -> Stack -> Prop :=

  | VaryStkMty  : variation_stack Mty Mty

  | VaryStkCons : forall a a' s s', variation_atom a a' ->

                                    variation_stack s s' ->

                                    variation_stack (a :: s) (a' :: s')

  | VaryStkRet  : forall a a' s s', variation_atom a a' ->

                                    variation_stack s s' ->

                                    variation_stack (RetCons a s) (RetCons a' s').

Derive ArbitrarySizedSuchThat for (fun s2 => variation_stack s1 s2).



Inductive variation_high_stack : Atom -> Stack -> Stack -> Prop :=

| VaryStkAny : forall pc stk stk', variation_stack stk stk' ->

                                  variation_high_stack pc stk stk'

| VarystkHigh : forall pcx stk stk' a,

                       variation_stack stk stk' ->

                       good_atom a ->

                       variation_high_stack (pcx @ H) stk (a :: stk').

Derive ArbitrarySizedSuchThat for (fun stk' => variation_high_stack pc stk stk').



Inductive variation_state : State -> State -> Prop :=

  | VaryState : forall imem mem stk pc mem' stk' pc',

      variation_mem mem mem' ->

      variation_atom pc pc' ->

      variation_high_stack pc stk stk' ->

      variation_state (St imem mem stk pc) (St imem mem' stk' pc').

Derive ArbitrarySizedSuchThat for (fun st' => variation_state st st').



Definition gen_variation_state_derived : G (option (@Variation State)) :=

  bindGenOpt (genST (fun st => good_state st)) (fun st => 

  bindGenOpt (genST (fun st' => variation_state st st')) (fun st' =>

  returnGen (Some (V st st')))).                                                            

