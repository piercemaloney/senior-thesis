

Require Import List mathcomp.ssreflect.ssreflect.

Set Implicit Arguments.



Record Lazy (T : Type) := lazy { force : T }.



Inductive Rose (A : Type) : Type :=

  MkRose : A -> Lazy (list (Rose A)) -> Rose A.



Definition returnRose {A : Type} (x : A) := MkRose x (lazy nil).



Fixpoint joinRose {A : Type} (r : Rose (Rose A)) : Rose A :=

  match r with

    | MkRose (MkRose a ts) tts =>

      MkRose a (lazy ((List.map joinRose (force tts)) ++ (force ts)))

  end.



Fixpoint repeatRose {A : Type} (n : nat) (r : Rose A) :=

  match r with

  | MkRose a ts => MkRose a (lazy (concat (repeat (force ts) n)))

  end.



Fixpoint fmapRose {A B : Type} (f : A -> B) (r : Rose A) : Rose B :=

  match r with

    | MkRose x rs => MkRose (f x) (lazy (List.map (fmapRose f) (force rs)))

  end.



Definition bindRose {A B : Type} (m : Rose A) (k : A -> Rose B) : Rose B :=

  joinRose (fmapRose k m).



