Require Import aes.aesutils.
Require Import aes.AES256.

Require Import Coqlib.
Require Import msl.Coqlib2.
Require Import floyd.coqlib3.
Require Import Integers.
Require Import List. Import ListNotations.
Require Import floyd.sublist.
Require Import sha.SHA256.
Require Import sha.general_lemmas.

Local Open Scope logic.

Lemma extra_expansion_sublist : forall k : list word,
  Zlength k = Nk -> sublist 0 (Nb*(Nr+1)) (blocks_to_ints (extra_key_expansion k)) = blocks_to_ints (KeyExpansion k).
Proof.
  intros.
  simpl.
  unfold extra_key_expansion.
  unfold KeyExpansion.
  assert (length k = 8%nat).
    rewrite Zlength_correct in H.
    apply Nat2Z.inj.
    auto.
  do 9 (destruct k as [ | ?w k]; try (inv H0; rename H2 into H0)).
  reflexivity.
Qed.

Lemma subbytes_shiftrows_comm : forall b : block,
  ShiftRows (SubBytes b) = SubBytes (ShiftRows b).
Proof.
  intros.
  destruct b as [[[[[[? ?] ?] ?] [[[? ?] ?] ?]] [[[? ?] ?] ?]] [[[? ?] ?] ?]].
  reflexivity.
Qed.

Lemma invsubbytes_invshiftrows_comm : forall b : block,
    InvShiftRows (InvSubBytes b) = InvSubBytes (InvShiftRows b).
Proof.
  intros.
  destruct b as [[[[[[? ?] ?] ?] [[[? ?] ?] ?]] [[[? ?] ?] ?]] [[[? ?] ?] ?]].
  reflexivity.
Qed.

Lemma sbox_invsbox_inverse : forall a : nat, (a < 256)%nat ->
    let b := Z.to_nat (Int.unsigned (nth a sbox Int.zero)) in
    nth b inv_sbox Int.zero = Int.repr (Z.of_nat a).
Proof.
  intros.
  do 256 (destruct a as [| a]; [reflexivity | ]).
  omega.
Qed.

Lemma invsbox_sbox_inverse : forall a : nat, (a < 256)%nat ->
    let b := Z.to_nat (Int.unsigned (nth a inv_sbox Int.zero)) in
    nth b sbox Int.zero = Int.repr (Z.of_nat a).
Proof.
  intros.
  do 256 (destruct a as [| a]; [reflexivity | ]).
  omega.
Qed.
