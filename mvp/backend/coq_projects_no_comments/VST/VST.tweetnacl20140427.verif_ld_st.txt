Require Import VST.floyd.proofauto.

Local Open Scope logic.

Require Import tweetnacl20140427.split_array_lemmas.

Require Import ZArith.

Require Import tweetnacl20140427.tweetNaclBase.

Require Import tweetnacl20140427.Salsa20.

Require Import tweetnacl20140427.tweetnaclVerifiableC.

Require Import tweetnacl20140427.verif_salsa_base.



Require Import tweetnacl20140427.spec_salsa.

Require Import VST.veric.expr_lemmas3.



Opaque Snuffle20. Opaque Snuffle.Snuffle. Opaque prepare_data.

Opaque fcore_result.



Lemma L32_spec_ok: semax_body SalsaVarSpecs SalsaFunSpecs

       f_L32 L32_spec.

Proof.

start_function.

Time forward.    

entailer!. 

- 

 change (Int.unsigned Int.iwordsize) with 32.

 split.

 +

    unfold Int.signed in H;

    destruct (zlt (Int.unsigned c) Int.half_modulus); rep_omega.

 +

    unfold Int.sub.

    change (Int.unsigned (Int.repr 32)) with 32.

    unfold Int.signed in H.

    rewrite Int.unsigned_repr.

    * destruct (zlt (Int.unsigned c) Int.half_modulus); rep_omega.

    * destruct (zlt (Int.unsigned c) Int.half_modulus); rep_omega.

-

  unfold Int.signed in H.

  destruct (zlt (Int.unsigned c) Int.half_modulus); [| rep_omega].

  apply prop_right.

  unfold sem_shift; simpl.

  unfold Int.ltu.

 change (Int.unsigned Int.iwordsize) with 32.

 simpl.

unfold Int.rol, Int.shl, Int.shru. rewrite or_repr.

rewrite Z.mod_small; simpl; try omega.

unfold Int.sub.

rewrite Int.and_mone,Int.unsigned_repr; trivial.

rewrite Int.unsigned_repr; rep_omega.

rep_omega.

Qed.



Lemma ld32_spec_ok: semax_body SalsaVarSpecs SalsaFunSpecs

       f_ld32 ld32_spec.

Proof.

start_function.

destruct B as (((b0, b1), b2), b3). simpl.

specialize Byte_max_unsigned_Int_max_unsigned; intros BND.

assert (RNG3:= Byte.unsigned_range_2 b3).

assert (RNG2:= Byte.unsigned_range_2 b2).

assert (RNG1:= Byte.unsigned_range_2 b1).

assert (RNG0:= Byte.unsigned_range_2 b0).

Time forward. 

Time entailer!; omega. 

Time forward. 

Time entailer!; omega. 

Time forward. 

Time forward. 

Time entailer!; omega. 

Time forward. 

drop_LOCAL 1%nat.

Time forward.

Time entailer!; omega. 

Time forward. 

Time entailer!.

  assert (WS: Int.zwordsize = 32). reflexivity.

  assert (TP: two_p 8 = Byte.max_unsigned + 1). reflexivity.

  assert (BMU: Byte.max_unsigned = 255). reflexivity. simpl.

  repeat rewrite Int.shifted_or_is_add; try repeat rewrite Int.unsigned_repr; try omega.

  f_equal. f_equal. simpl.

    rewrite Z.mul_add_distr_r.

    rewrite (Zmult_comm (Z.pow_pos 2 8)).

    rewrite (Zmult_comm (Z.pow_pos 2 16)).

    rewrite (Zmult_comm (Z.pow_pos 2 24)).

    simpl. repeat rewrite <- two_power_pos_correct.

    rewrite Z.mul_add_distr_r.

    rewrite Z.mul_add_distr_r.

    repeat rewrite <- Z.mul_assoc.

    rewrite <- Z.add_assoc. rewrite <- Z.add_assoc. rewrite Z.add_comm. f_equal.

    rewrite Z.add_comm. f_equal. rewrite Z.add_comm. f_equal.

  rewrite TP, BMU, Z.mul_add_distr_l. rep_omega.

  rewrite TP, BMU, Z.mul_add_distr_l. rep_omega.

  rewrite TP, BMU, Z.mul_add_distr_l. rep_omega.

Time Qed. 



Fixpoint lendian (l:list byte): Z :=

  match l with

    nil => 0

  | h::t => Byte.unsigned h + 2^8 * lendian t

  end.



Lemma lendian4 b0 b1 b2 b3: littleendian (b0,b1,b2,b3) = Int.repr(lendian [b0;b1;b2;b3]).

Proof. simpl. rewrite Zplus_0_r. 

rewrite ! Z.mul_add_distr_l, ! (Z.mul_assoc _ (2^8)), <- ! Z.add_assoc; reflexivity.

Qed.



Lemma lendian_nil: lendian [] = 0. Proof. reflexivity. Qed.

Lemma lendian_singleton b: lendian [b] = Byte.unsigned b. Proof. simpl; omega. Qed.



Lemma lendian_app: forall l1 l2, lendian (l1++l2) =

   lendian l1 + 2^(8*Zlength l1) * lendian l2.

Proof.

induction l1; intros.

+ rewrite Zlength_nil; simpl; omega.  

+ simpl. rewrite IHl1. rewrite Zlength_cons; clear IHl1.

  rewrite ! Z.mul_add_distr_l, <- ! Z.add_assoc, Z.mul_assoc, Z.pow_pos_fold.

  f_equal. f_equal. 

  rewrite <- Zpower_exp, <- Zmult_succ_r_reverse, Z.add_comm; trivial. omega.

  specialize (Zlength_nonneg l1); omega. 

Qed.



Lemma lendian_range: forall l, 0 <= lendian l < 2^(8*Zlength l).

Proof. induction l; simpl; intros.

+ omega.

+ rewrite Zlength_cons. destruct (Byte.unsigned_range a).

  assert (Z.pow_pos 2 8 = 256) by reflexivity.

  split. rewrite H1. apply Z.add_nonneg_nonneg; trivial; omega.

  rewrite <- Zmult_succ_r_reverse, Z.pow_add_r; [| specialize (Zlength_nonneg l); omega | omega ].

  rewrite Z.mul_comm. change (Z.pow_pos 2 8) with (2^8).

  assert (Byte.unsigned a + lendian l * 2 ^ 8 < Byte.modulus + lendian l * 2 ^ 8). omega.

  eapply Z.lt_le_trans. apply H2. clear H2 H0. change Byte.modulus with 256.

  change (2^8) with 256. specialize (Z.mul_add_distr_r 1 (lendian l) 256). rewrite Z.mul_1_l.

  intros X; rewrite <- X; clear X. apply Zmult_le_compat_r; omega.

Qed.



Definition bendian l: Z := lendian (rev l).

Lemma bendian_nil: bendian [] = 0. Proof. reflexivity. Qed.

Lemma bendian_singleton b: bendian [b] = Byte.unsigned b. Proof. unfold bendian. simpl; omega. Qed.



Lemma bendian_app l1 l2: bendian (l1++l2) = bendian l2 + 2^(8*Zlength l2) * bendian l1.

Proof. unfold bendian. rewrite rev_app_distr, lendian_app, Zlength_rev; trivial. Qed.



Lemma bendian_range l: 0 <= bendian l < 2^(8*Zlength l).

Proof. unfold bendian. specialize (lendian_range (rev l)). rewrite Zlength_rev; trivial. Qed.



Lemma Zlor_2powpos_add a b (n:positive) (B: 0<=b <Z.pow_pos 2 n):

      a * Z.pow_pos 2 n + b = Z.lor (a * Z.pow_pos 2 n) b.

Proof. apply Byte.equal_same_bits; intros.

  rewrite Z.lor_spec. apply Byte.Z_add_is_or; trivial.

  intros. rewrite Z.pow_pos_fold in *.

  destruct (zlt j (Z.pos n)).

  + rewrite Z.mul_pow2_bits_low; simpl; trivial.

  + rewrite <- (positive_nat_Z n) in g, B.

    erewrite (Byte.Ztestbit_above _ b), andb_false_r. trivial. 2: eassumption.

    rewrite two_power_nat_equiv. apply B.

Qed. 



Lemma Byte_unsigned_range_32 b: 0 <= Byte.unsigned b <= Int.max_unsigned.

Proof. destruct (Byte.unsigned_range_2 b). specialize Byte_Int_max_unsigned; omega. Qed.



Lemma Byte_unsigned_range_64 b: 0 <= Byte.unsigned b <= Int64.max_unsigned.

Proof. destruct (Byte.unsigned_range_2 b).

  unfold Int64.max_unsigned; simpl.

  unfold Byte.max_unsigned in H0; simpl in H0; omega.

Qed. 



Lemma dl64_spec_ok: semax_body SalsaVarSpecs SalsaFunSpecs

       f_dl64 dl64_spec.

Proof.

start_function.

destruct B as (((b0, b1), b2), b3).

destruct C as (((c0, c1), c2), c3).

unfold QuadByte2ValList; simpl. 

forward. simpl. rewrite Int.signed_repr by  rep_omega.



forward_for_simple_bound 8 (EX i:Z, 

  (PROP  ()

   LOCAL (temp _x x; temp _u (Vlong (Int64.repr (bendian (sublist 0 i [b0;b1;b2;b3;c0;c1;c2;c3])))))

   SEP (data_at Tsh (tarray tuchar 8)

          (map Vint (map Int.repr (map Byte.unsigned 

            [b0;b1;b2;b3;c0;c1;c2;c3]))) x))).

1: solve [ entailer! ]. 

{ rename H into I.

  assert (HH: Znth i

                 [Byte.unsigned b0; Byte.unsigned b1; Byte.unsigned b2; Byte.unsigned b3; 

                 Byte.unsigned c0; Byte.unsigned c1; Byte.unsigned c2; Byte.unsigned c3] 

          = Byte.unsigned (Znth i [b0; b1; b2; b3; c0; c1; c2; c3])).

  solve [erewrite <- (Znth_map _ Byte.unsigned); [ reflexivity | apply I ] ].

  forward. 

  + entailer!. rewrite HH. 

     apply Byte.unsigned_range_2.

  + simpl; rewrite HH. forward.

    entailer!. clear H1 H0 H. f_equal. rewrite <- (sublist_rejoin 0 i (i+1)).

    2: omega. 2: rewrite ! Zlength_cons, Zlength_nil; omega.

    rewrite sublist_len_1.

    2: rewrite ! Zlength_cons, Zlength_nil; omega.

    simpl.

    unfold Int64.or. rewrite Int64.shl_mul_two_p, (Int64.unsigned_repr 8).

    2: unfold Int64.max_unsigned; simpl; omega.

    rewrite Int64.unsigned_repr. 2: apply Byte_unsigned_range_64.

    change (two_p 8) with 256. 

    rewrite bendian_app, bendian_singleton. simpl.

    unfold Int64.mul.

    rewrite (Int64.unsigned_repr 256). 2: unfold Int64.max_unsigned; simpl; omega.

    rewrite Zplus_comm, Zmult_comm, Zlor_2powpos_add. 2: apply Byte.unsigned_range.

    f_equal. f_equal. remember (bendian (sublist 0 i [b0; b1; b2; b3; c0; c1; c2; c3])) as q.

    specialize (Int64.shifted_or_is_add  (Int64.repr q) Int64.zero 8).

    change (two_p 8) with 256. rewrite Int64.unsigned_zero, Z.add_0_r.

    intros X; rewrite <- X, Int64.or_zero; clear X.

     2: replace Int64.zwordsize with 64 by reflexivity; omega. 2: omega.

    rewrite Int64.shl_mul_two_p, (Int64.unsigned_repr 8).

    2: unfold Int64.max_unsigned; simpl; omega.

    unfold Int64.mul.

    assert (Q: 0 <= q < 2^56).

    { specialize (bendian_range (sublist 0 i [b0; b1; b2; b3; c0; c1; c2; c3])).             

      rewrite Zlength_sublist, Zminus_0_r, <- Heqq. intros. 

      assert (2^(8 * i) <= 2^56) by (apply Z.pow_le_mono_r; omega). omega.

      omega. change (Zlength [b0; b1; b2; b3; c0; c1; c2; c3]) with 8; omega. }

    change (2^56) with 72057594037927936 in Q.

    change (two_p 8) with 256. change (Z.pow_pos 2 8) with 256. 

    rewrite (Int64.unsigned_repr 256).

    2: unfold Int64.max_unsigned; simpl; omega.

    rewrite (Int64.unsigned_repr q).

    2: unfold Int64.max_unsigned; simpl; omega.

    rewrite Int64.unsigned_repr; trivial.

    unfold Int64.max_unsigned; simpl; omega. } 

forward. apply prop_right.

clear H H0. 

unfold bendian. simpl. 

rewrite ! Z.mul_add_distr_l, ! (Z.mul_assoc _ (Z.pow_pos 2 8)),

        <- ! Z.add_assoc, ! Z.mul_0_r, Z.add_0_r.

reflexivity.

Qed.



Lemma div_bound u n (N:1<n): 0 <= Int.unsigned u / n <= Int.max_unsigned.

Proof.

destruct (Int.unsigned_range u).

split. apply Z_div_pos; try omega. 

assert (Int.unsigned u / n <Int.modulus).

2: unfold Int.max_unsigned; omega.

apply Z.div_lt_upper_bound; try omega.

specialize (Z.mul_lt_mono_nonneg 1 n (Int.unsigned u) (Int.modulus)).

rewrite Z.mul_1_l. intros Q; apply Q; trivial.

Qed. 



Lemma ST32_spec_ok: semax_body SalsaVarSpecs SalsaFunSpecs

       f_st32 st32_spec.

Proof. 

start_function. 

remember (littleendian_invert u) as U. destruct U as [[[u0 u1] u2] u3].



Time forward_for_simple_bound 4 (EX i:Z,

  (PROP  ()

   LOCAL (temp _x x; temp _u (Vint (iterShr8 u (Z.to_nat i))))

   SEP (data_at Tsh (tarray tuchar 4) 

              (sublist 0 i (map Vint (map Int.repr (map Byte.unsigned ([u0;u1;u2;u3])))) ++ 

               list_repeat (Z.to_nat(4-i)) Vundef)

                x))).

{ entailer!. simpl; cancel. }

{ rename H into I.

  Time assert_PROP (field_compatible (Tarray tuchar 4 noattr) [] x /\ isptr x)

       as FC_ptrX by solve [entailer!]. 

  destruct FC_ptrX as [FC ptrX].

  Time forward. 

  Time forward. 

  rewrite Z.add_comm, Z2Nat.inj_add; try omega.

  Time entailer!. 

  unfold upd_Znth.

  autorewrite with sublist.

  simpl.

  apply data_at_ext. rewrite Zplus_comm.

        assert (ZW: Int.zwordsize = 32) by reflexivity.

        assert (EIGHT: Int.unsigned (Int.repr 8) = 8). apply Int.unsigned_repr.

        rep_omega.

        inv HeqU. clear - ZW EIGHT I.

        destruct (zeq i 0); subst; simpl. f_equal. f_equal.

        { rewrite Byte.unsigned_repr.

            rewrite (Fcore_Zaux.Zmod_mod_mult _ (2^8) (2^8)). 2: cbv; trivial. 2: cbv; intros; discriminate.

            rewrite (Fcore_Zaux.Zmod_mod_mult _ (2^16) (2^8)). 2: cbv; trivial. 2: cbv; intros; discriminate.

            rewrite <- (Int.zero_ext_mod 8).

              rewrite Int.repr_unsigned; trivial.

              rewrite ZW; omega.

          assert (0 <= ((Int.unsigned u mod Z.pow_pos 2 24) mod Z.pow_pos 2 16) mod Z.pow_pos 2 8 < Byte.modulus).

            apply Z_mod_lt. cbv; trivial.

            unfold Byte.max_unsigned. omega. }

        destruct (zeq i 1); subst; simpl. f_equal. f_equal. f_equal.

        { rewrite Byte.unsigned_repr.

          2:{ assert (0 <= (Int.unsigned u mod Z.pow_pos 2 24) mod Z.pow_pos 2 16 / Z.pow_pos 2 8 < Byte.modulus).

                   2:{ unfold Byte.max_unsigned. omega. }

                   split. apply Z_div_pos. cbv; trivial. apply Z_mod_lt. cbv; trivial.

                   apply Zdiv_lt_upper_bound. cbv; trivial. apply Z_mod_lt. cbv; trivial.

          }

          apply Int.same_bits_eq. rewrite ZW; intros.

          rewrite Int.bits_zero_ext, Int.testbit_repr; try apply H.

          rewrite (Z.div_pow2_bits _ 8); try omega.

          rewrite (Int.Ztestbit_mod_two_p 16); try omega.

          rewrite (Int.Ztestbit_mod_two_p 24); try omega.

          rewrite Int.bits_shru; try omega. rewrite EIGHT, ZW. 

          remember (zlt i 8). 

          destruct s. repeat rewrite zlt_true. trivial. omega. omega. omega.

          rewrite zlt_false. trivial. omega. }

        destruct (zeq i 2); subst; simpl. f_equal. f_equal. f_equal.

          f_equal.

        { rewrite Byte.unsigned_repr.

          2:{ assert (0 <= Int.unsigned u mod Z.pow_pos 2 24 / Z.pow_pos 2 16 < Byte.modulus).

                   2: unfold Byte.max_unsigned; omega.

                   split. apply Z_div_pos. cbv; trivial. apply Z_mod_lt. cbv; trivial.

                   apply Zdiv_lt_upper_bound. cbv; trivial. apply Z_mod_lt. cbv; trivial.

          }

          apply Int.same_bits_eq. rewrite ZW; intros.

          rewrite Int.bits_zero_ext, Int.testbit_repr; try apply H.

          rewrite Int.bits_shru; try omega. rewrite EIGHT, ZW.

          rewrite (Z.div_pow2_bits _ 16); try omega.

          rewrite (Int.Ztestbit_mod_two_p 24); try omega.

          

          remember (zlt i 8). 

          destruct s. repeat rewrite zlt_true. rewrite Int.bits_shru, EIGHT, ZW.

              rewrite zlt_true. rewrite <- Z.add_assoc. reflexivity. omega. omega. omega. omega.

          rewrite zlt_false. trivial. omega. }

        destruct (zeq i 3); subst; simpl.

        + f_equal. f_equal. f_equal. f_equal.

          f_equal.

          rewrite Byte.unsigned_repr.  

          2:{ assert (0 <= Int.unsigned u / Z.pow_pos 2 24 < Byte.modulus).

                   2: unfold Byte.max_unsigned; omega.

                   split. apply Z_div_pos. cbv; trivial. apply Int.unsigned_range. 

                   apply Zdiv_lt_upper_bound. cbv; trivial. apply Int.unsigned_range. 

          }

          rewrite ! Int.shru_div_two_p.

          rewrite (Int.unsigned_repr 8); [| cbv; split; congruence ].

          rewrite (Int.unsigned_repr (Int.unsigned u / two_p 8)), Zdiv.Zdiv_Zdiv; [ | cbv; congruence | cbv; congruence | ] .

          2: apply div_bound; cbv; trivial.

          replace (two_p 8 * two_p 8)%Z with (two_p 16) by reflexivity.

          rewrite (Int.unsigned_repr (Int.unsigned u / two_p 16)), Zdiv.Zdiv_Zdiv; [ | cbv; congruence | cbv; congruence | ] .

          2: apply div_bound; cbv; trivial.

          replace (two_p 16 * two_p 8)%Z with (two_p 24) by reflexivity.

          apply zero_ext_inrange.

          rewrite (Int.unsigned_repr (Int.unsigned u / Z.pow_pos 2 24)).

          2: apply div_bound; cbv; trivial. 

          assert (Int.unsigned u / Z.pow_pos 2 24 < two_p 8). 2: omega.

          apply Z.div_lt_upper_bound; trivial. apply Int.unsigned_range.

        + omega. 

 }

 forward. 

Time Qed.  



Fixpoint iter64Shr8 (u : int64) (n : nat) {struct n} : int64 :=

  match n with

  | 0%nat => u

  | S n' => Int64.shru (iter64Shr8 u n') (Int64.repr 8)

  end.



Definition iter64Shr8' (u : int64) (n : nat): int64 := 

   Int64.shru u (Int64.mul (Int64.repr 8) (Int64.repr (Z.of_nat n))).



Lemma iter64: forall n u (N: Z.of_nat n < 8), 

      iter64Shr8 u n = iter64Shr8' u n.

Proof. unfold iter64Shr8'.

  assert (W: Int64.iwordsize = Int64.repr 64) by reflexivity.

  induction n; simpl; intros.

+ rewrite Int64.mul_zero, Int64.shru_zero; trivial.

+ rewrite Zpos_P_of_succ_nat in *.

  rewrite IHn, Int64.shru_shru, Int64.mul_commut; clear IHn.

  - f_equal.

    specialize (Int64.mul_add_distr_l (Int64.repr (Z.of_nat n)) Int64.one (Int64.repr 8)).

    rewrite (Int64.mul_commut Int64.one), Int64.mul_one.

    intros X; rewrite <- X, Int64.mul_commut, Int64.add_unsigned; clear X.

    f_equal. f_equal. unfold Int64.one.

    rewrite 2 Int64.unsigned_repr; try reflexivity.   

    unfold Int64.max_unsigned; simpl; omega.

    unfold Int64.max_unsigned; simpl; omega.

 - rewrite W, Int64.mul_signed, 2 Int64.signed_repr.

   unfold Int64.ltu. rewrite (Int64.unsigned_repr 64), if_true; trivial.

   rewrite Int64.unsigned_repr. omega.

   unfold Int64.max_unsigned; simpl; omega.

   unfold Int64.max_unsigned; simpl; omega.

   unfold Int64.min_signed, Int64.max_signed; simpl; omega.

   unfold Int64.min_signed, Int64.max_signed; simpl; omega.

 - rewrite W. unfold Int64.ltu. rewrite if_true; trivial.

 - rewrite W. unfold Int64.ltu. rewrite Int64.mul_signed, Int64.add_signed, if_true; trivial.

   rewrite (Int64.signed_repr 8). 

   2: unfold Int64.min_signed, Int64.max_signed; simpl; omega.

   rewrite (Int64.signed_repr (Z.of_nat n)).   

   2: unfold Int64.min_signed, Int64.max_signed; simpl; omega.

   rewrite Int64.signed_repr. 

   2: unfold Int64.min_signed, Int64.max_signed; simpl; omega.

   rewrite 2 Int64.unsigned_repr. omega.

   unfold Int64.max_unsigned; simpl; omega.

   unfold Int64.max_unsigned; simpl; omega.

 - omega.

Qed. 



Lemma unsigned_repr' z (Q: 0 <= z < Byte.modulus): Byte.unsigned (Byte.repr z) = z.

Proof. apply Byte.unsigned_repr. unfold Byte.max_unsigned. omega. Qed.



Lemma shru_shru x n m (NM:Int64.unsigned n + Int64.unsigned m <= Int64.max_unsigned): 

      Int64.shru (Int64.shru x n) m = Int64.shru x (Int64.add n m).

Proof. rewrite 3 Int64.shru_div_two_p. f_equal.

specialize (Int64.unsigned_range n).

specialize (Int64.unsigned_range m).

specialize (Int64.unsigned_range x). intros X M N.

rewrite Int64.unsigned_repr, Zdiv_Zdiv, <- two_p_is_exp, Int64.add_unsigned, 

Int64.unsigned_repr; trivial; try apply two_p_gt_ZERO; try omega.

split. apply Z_div_pos; trivial. apply two_p_gt_ZERO; try omega. omega.

assert (Int64.unsigned x / two_p (Int64.unsigned n) < Int64.max_unsigned +1). 2: omega.

specialize (two_p_gt_ZERO (Int64.unsigned n)); intros A.

apply Z.div_lt_upper_bound. omega. eapply Z.lt_le_trans. apply X.

unfold Int64.max_unsigned. replace (Int64.modulus - 1 + 1) with Int64.modulus by omega.

specialize (Zmult_le_compat_l 1 (two_p (Int64.unsigned n)) Int64.modulus).

rewrite Z.mul_1_r, Z.mul_comm. intros Y; apply Y; omega.

Qed. 



