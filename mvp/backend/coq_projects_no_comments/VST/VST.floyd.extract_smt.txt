Require Import VST.floyd.proofauto.



Ltac extract_smt_simplify :=

   match goal with

    | |- context [@reptype ?cs ?t] =>

           let p := fresh "p" in set (p := @reptype cs t);

                       lazy beta zeta iota delta in p; subst p

    end.



Ltac extract_smt_forbidden :=

  match goal with

  | |- context [value_fits] => idtac

  | |- context [field_compatible] => idtac

  end.



Ltac extract_smt :=

 try match goal with

         | |- ?A => has_evar A; fail 5 "Cannot extract_smt with evars present"

         | H: ?A |- _ => has_evar A; fail 5 "Cannot extract_smt with evars present"

         | H:= ?A |- _ => has_evar A; fail 5 "Cannot extract_smt with evars present"

         end;

 try match goal with | |- ?P |-- _ =>

    match type of P with ?T => unify T (environ->mpred); go_lower

    end

  end;

  try match goal with | |- _ |-- _ =>

    repeat (( simple apply derives_extract_prop

                || simple apply derives_extract_prop');

                fancy_intros true);

    autorewrite with gather_prop;

    repeat (( simple apply derives_extract_prop

                || simple apply derives_extract_prop');

                fancy_intros true);

   saturate_local;

   repeat erewrite unfold_reptype_elim in * by reflexivity;

   simpl_compare;

   simpl_denote_tc;

   first [ simple apply prop_right

        | simple apply prop_and_same_derives'

        | simple apply andp_right;

            [apply prop_right |  ]

        ]

   end;

   repeat

    match goal with

    | H := _ |- _ => clear H

    | H : name _ |- _ => clear H

    end;

    repeat extract_smt_simplify;

    try (extract_smt_forbidden; fail 3 "proof goal has a forbidden term");

    repeat match goal with

    | H : ?P |- _ =>

       match type of P with Prop =>

         revert H; repeat extract_smt_simplify;

         try (extract_smt_forbidden; fail 1)

       end

     end;

    repeat match goal with   H : ?P  |- _ =>

       match type of P with

       |Prop => idtac

       | _ => clear H || revert H

       end

    end.

