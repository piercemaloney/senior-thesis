

Require Import compcert.common.Memory.



Require Import VST.concurrency.common.threadPool.

Require Import VST.concurrency.common.scheduler.

Require Import VST.concurrency.common.HybridMachineSig.

Require Import VST.concurrency.common.semantics.

Require Import VST.concurrency.juicy.juicy_machine. Import Concur.

Require Import VST.concurrency.common.HybridMachine.



Definition init_inj_ok (j: Values.Val.meminj) m:=

  forall b b' ofs, j b = Some (b', ofs) ->

              b = b' /\

              Mem.valid_block m b.



Module Type ErasureSig.



  Import HybridMachineSig.



  Declare Instance Sem (ge : Clight.genv) : Semantics.



  Declare Instance JR : Resources.

  Declare Instance JTP (ge : Clight.genv) : ThreadPool.ThreadPool(Sem := Sem ge).

  Declare Instance JMS (ge : Clight.genv) : MachineSig(ThreadPool := JTP ge).

  Declare Instance DilMem : DiluteMem.

  Declare Instance scheduler : Scheduler.

  Declare Instance JuicyMachine (ge : Clight.genv) : HybridMachine(machineSig:=JMS ge).

  Notation JMachineSem ge := (MachineSemantics(HybridMachine := JuicyMachine ge)).

  Notation jres := (@res JR).

  Notation jstate ge := (@ThreadPool.t _ _ (JTP ge)).

  Notation jmachine_state ge := (@MachState _ _ (JTP ge)).

  Declare Instance DR : Resources.

  Declare Instance DTP (ge : Clight.genv) : ThreadPool.ThreadPool(Sem := Sem ge).

  Declare Instance DMS (ge : Clight.genv) : MachineSig(ThreadPool := DTP ge).

  Declare Instance DryMachine (ge : Clight.genv) : HybridMachine(machineSig := DMS ge).

  Notation DMachineSem ge := (MachineSemantics(HybridMachine := DryMachine ge)).

  Notation dres := (@res DR).

  Notation dstate ge := (@ThreadPool.t _ _ (DTP ge)).

  Notation dmachine_state ge := (@MachState _ _ (DTP ge)).



  Parameter match_st : forall (ge : Clight.genv), jstate ge -> dstate ge -> Prop.



  Axiom MTCH_cnt: forall {ge js tid ds},

      match_st ge js ds ->

      ThreadPool.containsThread js tid -> ThreadPool.containsThread ds tid.

  Axiom MTCH_cnt': forall {ge js tid ds},

      match_st ge js ds ->

      ThreadPool.containsThread ds tid -> ThreadPool.containsThread js tid.



  Axiom  MTCH_getThreadC: forall ge js ds tid c,

      forall (cnt: ThreadPool.containsThread js tid)

        (cnt': ThreadPool.containsThread ds tid)

        (M: match_st ge js ds),

        ThreadPool.getThreadC cnt =  c ->

        ThreadPool.getThreadC cnt'  =  c.



  Axiom MTCH_compat: forall ge js ds m,

      match_st ge js ds ->

      mem_compatible js m ->

      mem_compatible ds m.



  Axiom MTCH_updt:

    forall ge js ds tid c

      (H0:match_st ge js ds)

      (cnt: ThreadPool.containsThread js tid)

      (cnt': ThreadPool.containsThread ds tid),

      match_st ge (ThreadPool.updThreadC cnt c)

               (ThreadPool.updThreadC cnt' c).



  Axiom core_diagram:

    forall ge (m : mem)  (U0 U U': _) rmap pmap

      (ds : dstate ge) dtr (js js': jstate ge) jtr jtr'

      (m' : mem),

      corestep (JMachineSem ge U0 rmap) (U, jtr, js) m (U', jtr', js') m' ->

      match_st ge js ds ->

      invariant ds ->

      exists (ds' : dstate ge),

        invariant ds' /\

        match_st ge js' ds' /\

        exists dtr', corestep (DMachineSem ge U0 pmap) (U, dtr, ds) m (U', app dtr dtr', ds') m'.



  Axiom halted_diagram:

    forall ge U (ds : dmachine_state ge) (js : jmachine_state ge)  rmap pmap,

      fst (fst js) = fst (fst ds) ->

      halted (JMachineSem ge U rmap) js = halted (DMachineSem ge U pmap) ds.



End ErasureSig.



Module ErasureFnctr (PC:ErasureSig).

  Import HybridMachineSig PC.



  Section ErasureFnctr.



    Context (ge : Clight.genv).

    Notation jres := (@res JR).

    Notation jstate := (@ThreadPool.t _ _ (JTP ge)).

    Notation jmachine_state := (@MachState _ _ (JTP ge)).

    Notation dres := (@res DR).

    Notation dstate := (@ThreadPool.t _ _ (DTP ge)).

    Notation dmachine_state := (@MachState _ _ (DTP ge)).

    Instance DMS : MachineSig(ThreadPool := DTP ge) := DMS ge.

    Instance Sem : Semantics := Sem ge.

    Notation match_st := (match_st ge).



    Inductive init_inv:  Values.Val.meminj ->

                         semG -> list Values.val -> mem ->

                         semG -> list Values.val -> mem -> Prop:=

    |InitEq: forall j g1 args1 m1 g2 args2 m2,

        g1 = g2 ->

        args1 = args2 ->

        m1 = m2 ->

        init_inj_ok j m1 ->

        init_inv j g1 args1 m1 g2 args2 m2.



    Inductive halt_inv:  Values.Val.meminj ->

                         semG -> Values.val -> mem ->

                         semG -> Values.val -> mem -> Prop:=

    |HaltEq: forall j g1 args1 m1 g2 args2 m2,

        g1 = g2 ->

        args1 = args2 ->

        m1 = m2 ->

        halt_inv j g1 args1 m1 g2 args2 m2.



    Definition ge_inv: semG -> semG -> Prop:= @eq semG.

    Definition core_data:= unit.

    Definition core_ord: unit-> unit -> Prop := fun _ _ => False.



    Inductive match_state :

      core_data ->  Values.Val.meminj -> jmachine_state ->  mem -> dmachine_state -> mem -> Prop:=

      MATCH: forall d j js ds U m,

        invariant ds -> 

        match_st js ds ->

        match_state d j  (U, nil, js) m (U, nil, ds) m.



    Lemma core_ord_wf:  well_founded core_ord.

    Proof. constructor; intros y H; inversion H. Qed.



  End ErasureFnctr.



End ErasureFnctr.

