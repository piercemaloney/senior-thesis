
Require Import VST.floyd.proofauto.

Require Import VST.progs.reverse.

Instance CompSpecs : compspecs. make_compspecs prog. Defined.

Definition Vprog : varspecs. mk_varspecs prog. Defined.

Definition t_struct_list := Tstruct _list noattr.

Fixpoint listrep (sigma: list val) (x: val) : mpred :=
 match sigma with
 | h::hs => 
    EX y:val, 
      data_at Tsh t_struct_list (h,y) x  *  listrep hs y
 | nil => 
    !! (x = nullval) && emp
 end.

Fixpoint lsegrec (sigma: list val) (x z: val) : mpred :=
 match sigma with
 | h::hs => 
    EX y:val, 
      data_at Tsh t_struct_list (h,y) x  *  lsegrec hs y z
 | nil => 
    !! (x = z) && emp
 end.

Lemma list_ind_in_logc: forall {A: Type} (P: mpred) (Q: list A -> mpred),
  P |-- Q nil ->
  P |-- ALL a: A, (ALL l: list A, Q l --> Q (a :: l)) ->
  P |-- ALL l: list A, Q l.
Proof.
  intros.
  apply allp_right; intro l.
  induction l; auto.
  rewrite (add_andp _ _ IHl), (add_andp _ _ H0).
  apply imp_andp_adjoint.
  apply andp_left2.
  apply (allp_left _ a).
  apply (allp_left _ l).
  auto.
Qed.

Lemma listrep2lsegrec: forall l x,
  listrep l x |-- lsegrec l x nullval.
Proof.
  assert (emp |-- ALL l: list val, (ALL x: val, listrep l x -* lsegrec l x nullval)).
  + apply list_ind_in_logc.
    - apply allp_right; intros.
      apply wand_sepcon_adjoint.
      rewrite emp_sepcon.
      simpl.
      apply derives_refl.
    - apply allp_right; intros a.
      apply allp_right; intros l.
      apply imp_andp_adjoint.
      apply allp_right; intros x.
      apply andp_left2.
      apply wand_sepcon_adjoint.
      simpl.
      Intros y.
      Exists y.
      apply wand_sepcon_adjoint.
      apply (allp_left _ y).
      apply wand_sepcon_adjoint.
      cancel.
      apply wand_sepcon_adjoint.
      apply derives_refl.
  + intros.
    rewrite <- (emp_sepcon (listrep _ _)).
    apply wand_sepcon_adjoint.
    eapply derives_trans; [exact H | clear H].
    apply (allp_left _ l).
    apply (allp_left _ x).
    apply derives_refl.
Qed.
