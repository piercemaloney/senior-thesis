
Add LoadPath "../../msl" as msl.
Add LoadPath "../../compcert" as compcert.
Add LoadPath "../../../compcert" as compcert.
Add LoadPath "../../sepcomp" as sepcomp.
Add LoadPath "../../veric" as veric.
Add LoadPath "../../floyd" as floyd.

Require Import compcert.exportclight.Clightdefs.

Require Import veric.SeparationLogic.
Import Extensionality.

Check 0%Z : Z.
Check 1%Z : Z.

Goal int = Int.int.      Proof. reflexivity. Qed.

Check Int.repr :  Z -> int.
Goal Int.repr 0 = Int.repr (Z.pow 2 32).
apply Int.eqm_samerepr.
unfold Int.eqm.
apply Int.eqmod_sym; apply Int.eqmod_mod.
reflexivity.
Qed.

Check Int.signed: int -> Z.
Goal Int.signed (Int.repr 0) = 0%Z.
Proof. apply Int.signed_repr. compute; split; congruence. Qed.
Goal Int.signed (Int.repr (-1)) = (-1)%Z.
Proof. apply Int.signed_repr. compute; split; congruence. Qed.
Goal Int.signed (Int.repr (Z.pow 2 32 - 1)) = (-1)%Z.
Proof.
 replace (Int.repr (2 ^ 32 - 1)) with (Int.repr (-1)).
 apply Int.signed_repr.
 compute; split; congruence.
 apply Int.eqm_samerepr.
 change (-1)%Z with (0 - 1)%Z.
 apply Int.eqmod_sub.
 apply Int.eqmod_sym; apply Int.eqmod_mod.
 reflexivity.
 apply Int.eqmod_refl.
Qed.

Check Int.unsigned: int -> Z.
Goal Int.unsigned (Int.repr 0) = 0%Z.
Proof. apply Int.unsigned_repr. compute; split; congruence. Qed.
Goal Int.unsigned (Int.repr (-1)) = (Z.pow 2 32 - 1)%Z.
Proof.
 replace  (Int.repr (-1)) with (Int.repr (2 ^ 32 - 1)).
 apply Int.unsigned_repr.
 compute; split; congruence.
 apply Int.eqm_samerepr.
 change (-1)%Z with (0 - 1)%Z.
 apply Int.eqmod_sub.
 apply Int.eqmod_mod.
 reflexivity.
 apply Int.eqmod_refl.
Qed.

Goal Int.zero = Int.repr 0.     Proof. reflexivity. Qed.
Goal Int.one = Int.repr 1.      Proof. reflexivity. Qed.
Definition nullval := Vint Int.zero.

Print val.

Check (Vint (Int.repr 0)) : val.

Goal forall v, tc_val tint v -> exists i, v = Vint i.
Proof. intros. destruct v; inversion H. eauto. Qed.

Goal forall v, tc_val (tptr tint) v ->
   match v with Vint i => i=Int.zero
                     | Vptr _ _ => True
                     | _ => False
   end.
Proof. intros. destruct v; inversion H; auto.
Qed.

Print expr.

Locate mpred.

Check prop : Prop -> mpred.

Check mapsto : share -> type -> val -> val -> mpred.

Require Import floyd.proofauto.

Check data_at: Share.t -> forall t : type, reptype t -> val -> mpred.

Check (fun rho => mapsto Tsh tint (f rho) (Vint Int.zero)).

Check `(mapsto Tsh tint) f `(Vint Int.zero).

Definition _i : ident := 4%positive.
Definition _s : ident := 5%positive.
Definition _t : ident := 6%positive.

Check  (fun rho => prop (Vint Int.zero = eval_id _s rho)).
Check `prop (`(eq (Vint Int.zero)) (eval_id _s)).
Check local (`(eq nullval) (eval_id _s)).
Check local (`eq `nullval (eval_id _s)).

Require Import floyd.client_lemmas.
Require Import floyd.assert_lemmas.
Open Scope logic.

Check   ( local (`(eq nullval) (eval_id _i))
         &&   `(mapsto Tsh tint) (eval_id _s) (eval_id _i)).

Parameter i: int.
Check (prop (i <> Int.zero) && local (`(eq (Vint i)) (eval_id _i)) &&
              ( `(mapsto Tsh tint) (eval_id _s) `(Vint i)
                * `(mapsto Tsh (tptr tint)) (eval_id _t) (eval_id _s))).

Check (PROP(i<>Int.zero)
       LOCAL(`(eq (Vint i)) (eval_id _i))
       SEP (`(mapsto Tsh tint) (eval_id _s) `(Vint i);
             `(mapsto Tsh (tptr tint)) (eval_id _t) (eval_id _s))).

Locate eval_expr.
 Check eval_expr : expr -> environ -> val.
Print eval_expr.

Print environ.

Check (Etempvar _s tint : expr).
Check (eval_expr (Etempvar _s tint)).
Goal eval_expr (Etempvar _s tint) = eval_id _s.
Proof. reflexivity. Qed.
Check (fun rho : environ => Vint (Int.repr 0)) : environ -> val.
Check ( `(Vint (Int.repr 0)) ) : environ -> val.
Goal `(Vint (Int.repr 0)) = fun rho : environ => Vint (Int.repr 0).
Proof. reflexivity. Qed.
Check (Econst_int (Int.repr 0) tint) : expr.
Check eval_expr (Econst_int (Int.repr 0) tint) : environ -> val.
Goal eval_expr (Econst_int (Int.repr 0) tint) = `(Vint Int.zero).
Proof. reflexivity. Qed.

