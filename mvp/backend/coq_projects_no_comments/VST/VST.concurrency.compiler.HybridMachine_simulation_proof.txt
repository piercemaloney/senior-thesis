Require Import compcert.common.AST.

Require Import Coq.omega.Omega.

Require Import Clight.

Require Import Memory.

Require Import Values.

Require Import Globalenvs.



Require Import Coq.Classes.Morphisms.



Require Import compcert.driver.Compiler.

Require Import compcert.lib.Coqlib.



Require Import msl.Coqlib2.



Require veric.Clight_core. Import Clight_core.



Require Import Smallstep.

Require Import ExposedSmallstep.

Require Import VST.concurrency.SantiagosTactics.

Require Import VST.concurrency.MemoryEquivalences.

Require Import VST.concurrency.x86_context.

Require Import VST.concurrency.common.HybridMachineSig.

Require Import VST.concurrency.common.HybridMachine.

Require Import VST.concurrency.common.HybridMachineSig.

Require Import VST.concurrency.common.HybridMachine_simulation.



Require Import VST.concurrency.compiler.CoreSemantics_sum.

Require Import VST.concurrency.self_simulation.



Require Import VST.concurrency.common.permissions.



Require Import VST.concurrency.ClightCoreSemantincsForMachines.



Set Bullet Behavior "Strict Subproofs".



Section HybridProofs.



  Variable p: program.

  Variable tp: ia32.Asm.program. 

  Variable compiled: (simpl_transf_clight_program p = Errors.OK tp).



  Definition Clight_semantics2 (p: program) : semantics:=

    Clight.semantics2 p.



  Definition Asm_semantics (tp: Asm.program) : semantics:=

    Asm.semantics tp.



  Definition Sems:= ClightSEM_rec.

  Definition Semt:= X86SEM_rec. 



Section OneThreadCompiled.

  Variable (hb': nat).

  Notation hb1:= (Some hb').

  Notation hb2:= (Some (S hb')).

  Variable U: seq.seq nat.

  

  Notation C1:= (t_ (HybridMachine.ThreadPool hb1 Sems Semt)).

  Notation C2:= (t_ (HybridMachine.ThreadPool hb2 Sems Semt)).

  Notation G1:= (semG (HybridMachine.Sem hb1 Sems Semt)) .

  Notation G2:= (semG (HybridMachine.Sem hb2 Sems Semt)).



  Definition genvS:= Clight.globalenv p.

  Definition genvT:= (Genv.globalenv tp).

  Definition genv:= (genvS, genvT).



  Section OneThreadCompiledProofs.



    Parameter Clight_core_inject: meminj -> CC_core -> CC_core -> Prop.

    Parameter Clight_self_simulation:

      self_simulation (Clight.semantics2 p) _ CC_core_to_CC_state.

    Definition code_inject_source:=

      match_self (code_inject Clight_self_simulation).

    Parameter Asm_core_inject: meminj -> Asm.regset -> Asm.regset -> Prop.

    Parameter Asm_self_simulation:

      self_simulation (Asm_semantics tp) _ (Asm.State).  

    Definition code_inject_target:=

      match_self (code_inject Asm_self_simulation).

    

    Instance mem_Proper_match_perm_image:

      Proper (eq ==> mem_equiv ==> mem_equiv ==> iff) perm_image.

    Proof.

      proper_iff_tac; intros; subst.

      intros ??; rewrite <- H0; eapply H2.

    Qed.

    Instance mem_Proper_match_perm_preimage:

      Proper (eq ==> mem_equiv ==> mem_equiv ==> iff) perm_preimage.

    Proof.

      proper_iff_tac; intros; subst.

      intros ???; rewrite <- H1 in *.

      destruct (H2 _ _ H) as (b1 & delta & ofs & ?).

      do 3 eexists.

      rewrite <- H0; eauto.

    Qed.



    Instance mem_Proper_match_mem:

        Proper (eq ==> mem_equiv ==> mem_equiv ==> iff) match_mem.

      Proof.

        proper_iff_tac; intros; subst.

        inversion H2.

        econstructor; eauto;

          rewrite <- H0, <- H1; auto.

      Qed.

    

    Instance mem_Proper_code_inject_target:

      Proper (eq ==> eq ==> mem_equiv ==> eq ==> mem_equiv ==> iff) code_inject_target.

    Proof.

      proper_iff_tac; intros; subst.

      econstructor; try rewrite <- H1, <- H3;

        ez_eapply code_inject_target.

    Qed.



    Instance mem_Proper_code_inject_source:

      Proper (eq ==> eq ==> mem_equiv ==> eq ==> mem_equiv ==> iff) code_inject_source.

    Proof.

      proper_iff_tac; intros; subst.

      econstructor; try rewrite <- H1, <- H3;

        ez_eapply code_inject_source.

    Qed.

                      

    Definition make_state_Clight: CC_core -> mem -> Clight.state:=

      CC_core_to_CC_state.

    Definition get_state_Clight c:=

      fst (CC_state_to_CC_core c).

    Definition make_state_Asm

              (reg: X86Machines.ErasedMachine.ThreadPool.code)

              (m: mem): ia32.Asm.state:=

      ia32.Asm.State reg m.

    Definition get_state_Asm (st:Asm.state): X86Machines.ErasedMachine.ThreadPool.code:=

      match st with

        Asm.State reg _ => reg

      end.



    Definition compiler_simulation: fsim_properties_inj ( Clight.semantics2 p) (ia32.Asm.semantics tp)

                                                        ( Clight.get_mem) (ia32.Asm.get_mem):=

    simpl_clight_semantic_preservation p tp compiled.

    

    Definition compiler_index := Injindex compiler_simulation.

    Definition compiler_order := Injorder compiler_simulation.

    Definition compiler_match := Injmatch_states compiler_simulation.

    

    Definition match_compiled_states :=

      fun i f c1 m1 c2 m2 =>

        exists c1' m1' c2' m2' f1 f12 f2,

          code_inject_source f1 c1 m1 c1' m1' /\

          compiler_match i f12 (make_state_Clight c1' m1') (make_state_Asm c2' m2') /\

          code_inject_target f2 c2 m2 c2' m2' /\

          inject_incr (compose_meminj f1 (compose_meminj f12 f2)) f.

    Notation source_match f st1 m1 st2 m2 :=

      (code_inject_source f st1 m1 st2 m2).

    Notation target_match f st1 m1 st2 m2 :=

      (code_inject_target f st1 m1 st2 m2).

          

Section OneThreadCompiledMatch.



  Definition HM1:=HybridMachine hb1 Sems Semt.

  Definition HM2:=HybridMachine hb2 Sems Semt.



  Notation Sem1:=(ConcurMachineSemantics _ _ _ HM1 U None).

  Notation Sem2:=(ConcurMachineSemantics _ _ _ HM2 U None) .



  Inductive condition: Set :=

    running | blocked | resuming | initializing.



  Definition get_condition {cT} (c:@ctl cT):=

    match c with

    | Krun _ => running

    | Kblocked _ => blocked

    | Kresume _ _ => resuming

    | Kinit _ _ =>  initializing

    end.



  Definition get_state_inside {cT} (c:@ctl cT):=

    match c with

    | Krun c => Some c

    | Kblocked c => Some c

    | Kresume c _ => Some c

    | Kinit _ _ =>  None

    end.



  Lemma same_length_contains:

    forall {ms1: C1} {ms2: C2} {i},

      num_threads ms1 = num_threads ms2 ->

      containsThread ms1 i ->

      containsThread ms2 i.

  Proof.

    intros ? ? ? H; unfold containsThread.

    rewrite H; trivial.

  Qed.

  

  Notation CoreSem Sem :=(semantics.csem(event_semantics.msem (semSem Sem))).



  Inductive match_thread_source:

    meminj -> @ctl (state_sum (semC Sems) (semC Semt)) -> mem -> @ctl (state_sum (semC Sems) (semC Semt)) -> mem -> Prop  :=

  | SThread_Running: forall j code1 m1 code2 m2,

      source_match j code1 m1 code2 m2 ->

      match_thread_source

        j (Krun (SState _ _ code1)) m1

        (Krun (SState _ _ code2)) m2

  | SThread_Blocked: forall j code1 m1 code2 m2 ls1 ls2 f f',

      semantics.at_external (CoreSem Sems) genvS code1 m1 = Some (f,ls1) ->

      semantics.at_external (CoreSem Sems) genvS code2 m2 = Some (f',ls2) ->

      Val.inject_list j ls1 ls2 ->

      source_match j code1 m1 code2 m2 ->

      match_thread_source  j (Kblocked (SState _ _ code1)) m1

                          (Kblocked (SState _ _ code2)) m2

  | SThread_Resume: forall j code1 m1 code2 m2 ls1 ls2 f f' v v' code1' code2',

      

    semantics.at_external (CoreSem Sems) genvS code1 m1 = Some (f,ls1) ->

    semantics.at_external (CoreSem Sems) genvS code2 m2 = Some (f',ls2) ->

    Val.inject_list j ls1 ls2 ->

    semantics.after_external (CoreSem Sems) genvS None code1 = Some code1' ->

    semantics.after_external (CoreSem Sems) genvS None code2 = Some code2' ->

    source_match j code1' m2 code2' m2 ->

    match_thread_source j (Kresume (SState _ _ code1) v) m1

                        (Kresume (SState _ _ code2) v') m2

| SThread_Init: forall j m1 m2 v1 v1' v2 v2',

    Val.inject j v1 v2 ->

    Val.inject j v1' v2' ->

    match_thread_source j (Kinit v1 v1') m1

                        (Kinit v2 v2') m2.



  Inductive match_thread_target :

    meminj -> @ctl (state_sum (semC Sems) (semC Semt)) -> mem -> @ctl (state_sum (semC Sems) (semC Semt)) -> mem -> Prop  :=

  | TThread_Running: forall j code1 m1 code2 m2,

      target_match j code1 m1 code2 m2 ->

      match_thread_target  j (Krun (TState _ _ code1)) m1

                          (Krun (TState _ _ code2)) m2

  | TThread_Blocked: forall j code1 m1 code2 m2 ls1 ls2 f f',

      semantics.at_external (CoreSem Semt) genvT code1 m1 = Some (f,ls1) ->

      semantics.at_external (CoreSem Semt) genvT code2 m2 = Some (f',ls2) ->

      Val.inject_list j ls1 ls2 ->

      target_match j code1 m1 code2 m2 ->

      match_thread_target j (Kblocked (TState _ _ code1)) m1

                          (Kblocked (TState _ _ code2)) m2

  | TThread_Resume: forall j code1 m1 code2 m2 ls1 ls2 f f' v v' code1' code2',

      

      semantics.at_external (CoreSem Semt) genvT code1 m1 = Some (f,ls1) ->

      semantics.at_external (CoreSem Semt) genvT code2 m2 = Some (f',ls2) ->

      Val.inject_list j ls1 ls2 ->

      semantics.after_external (CoreSem Semt) genvT None code1 = Some code1' ->

      semantics.after_external (CoreSem Semt) genvT None code2 = Some code2' ->

      target_match j code1' m2 code2' m2 ->

      match_thread_target j (Kresume (TState _ _ code1) v) m1

                          (Kresume (TState _ _ code2) v') m2

  | TThread_Init: forall j m1 m2 v1 v1' v2 v2',

      Val.inject j v1 v2 ->

      Val.inject j v1' v2' ->

      match_thread_target j (Kinit v1 v1') m1

                          (Kinit v2 v2') m2.



  Inductive match_thread_compiled:

    compiler_index -> meminj ->

    @ctl (state_sum (semC Sems) (semC Semt)) -> mem ->

    @ctl (state_sum (semC Sems) (semC Semt)) -> mem -> Prop  :=

  | CThread_Running: forall cd j code1 m1 code2 m2,

      match_compiled_states cd j code1 m1 code2 m2 ->

      match_thread_compiled cd j (Krun (SState _ _ code1)) m1

                            (Krun (TState _ _ code2)) m2

  | CThread_Blocked: forall cd j code1 m1 code2 m2 ls1 ls2 f f',

      semantics.at_external (CoreSem Sems) genvS code1 m1  = Some (f,ls1) ->

      semantics.at_external (CoreSem Semt) genvT code2 m2 = Some (f',ls2) ->

      Val.inject_list j ls1 ls2 ->

      match_compiled_states cd j code1 m1 code2 m2 ->

      match_thread_compiled  cd j (Kblocked (SState _ _ code1)) m1

                            (Kblocked (TState _ _ code2)) m2

  | CThread_Resume: forall cd j code1 m1 code2 m2 ls1 ls2 f f' v v' code1' code2',

      

      semantics.at_external (CoreSem Sems) genvS code1 m1 = Some (f,ls1) ->

      semantics.at_external (CoreSem Semt) genvT code2 m2 = Some (f',ls2) ->

      Val.inject_list j ls1 ls2 ->

      semantics.after_external (CoreSem Sems) genvS None code1 = Some code1' ->

      semantics.after_external (CoreSem Semt) genvT None code2 = Some code2' ->

      match_compiled_states cd j code1' m1 code2' m2 ->

      match_thread_compiled cd j (Kresume (SState _ _ code1) v) m1

                            (Kresume (TState _ _ code2) v') m2

  | CThread_Init: forall cd j m1 m2 v1 v1' v2 v2',

      Val.inject j v1 v2 ->

      Val.inject j v1' v2' ->

      match_thread_compiled cd j (Kinit v1 v1') m1

                            (Kinit v2 v2') m2.



  Definition FST {A B} (HH : A /\ B):=

    fst (ssrfun.pair_of_and HH).



  Definition SND {A B} (HH : A /\ B):=

    snd (ssrfun.pair_of_and HH).

  

  Record concur_match (ocd: option compiler_index)

       (j:meminj) (cstate1: C1) (m1: mem) (cstate2: C2) (m2: mem):=

  { same_length: num_threads cstate1 = num_threads cstate2

    ; memcompat1: HybridMachine.mem_compatible _ _ _ cstate1 m1

    ; memcompat2: HybridMachine.mem_compatible _ _ _ cstate2 m2

    ; mtch_source:

        forall (i:nat),

          (i > hb')%nat ->

          forall (cnti1: containsThread cstate1 i)

            (cnti2: containsThread cstate2 i),

          match_thread_source  j

                              (getThreadC cnti1)

                              (restrPermMap (FST (memcompat1 i cnti1)))

                              (getThreadC cnti2)

                              (restrPermMap (FST (memcompat2 i cnti2)))

    ; mtch_target:

        forall (i:nat),

          (i < hb')%nat ->

          forall (cnti1: containsThread cstate1 i)

            (cnti2: containsThread cstate2 i),

          match_thread_target  j

                              (getThreadC cnti1)

                              (restrPermMap (FST(memcompat1 i cnti1)))

                              (getThreadC cnti2)

                              (restrPermMap (FST(memcompat2 i cnti2)))

    ; mtch_compiled:

        forall (i:nat),

          (i = hb')%nat ->

          forall (cnti1: containsThread cstate1 i)

            (cnti2: containsThread cstate2 i),

            exists cd, ocd = Some cd /\

          match_thread_compiled cd j

                                (getThreadC cnti1)

                                (restrPermMap (FST(memcompat1 i cnti1)))

                                (getThreadC cnti2)

                                (restrPermMap (FST(memcompat2 i cnti2))) }.



Lemma contains12:

  forall {data j cstate1 m1 cstate2 m2},

  concur_match data j cstate1 m1 cstate2 m2 ->

  forall {i:nat} (cnti1: containsThread cstate1 i),

    containsThread cstate2 i.

Proof.

  unfold containsThread.

  intros ? ? ? ? ? ? H. destruct H.

  rewrite same_length0; auto.

Qed.



Lemma contains21:

  forall {data j cstate1 m1 cstate2 m2},

  concur_match data j cstate1 m1 cstate2 m2 ->

  forall {i:nat} (cnti1: containsThread cstate2 i),

    containsThread cstate1 i.

Proof.

  unfold containsThread.

  intros ? ? ? ? ? ? H. destruct H.

  rewrite same_length0; auto.

Qed.



End OneThreadCompiledMatch.



Arguments same_length_contains {ms1 ms2}.

Arguments memcompat1 {ocd j cstate1 m1 cstate2 m2}.

Arguments memcompat2 {ocd j cstate1 m1 cstate2 m2}.

    

  Section HybridThreadDiagram.

    Notation the_simulation := compiler_simulation.



    Parameter option_compiler_order: option (Injindex the_simulation) -> option (Injindex the_simulation) -> Prop.



    Ltac auto_gsoThreadCode:=

      match goal with

      | [ |- context[getThreadC ?cntJ'] ] =>

        match type of cntJ' with

        | containsThread (updThread ?cntI _ _) ?J =>

          match type of cntI with

          | containsThread ?hb ?I =>

            match goal with

            | [ cntJ: containsThread hb J |- _ ] => 

              rewrite gsoThreadCode with

                  (cnti:= cntI)

                  (cntj:= cntJ)

                  (cntj':= cntJ') by eassumption

            end

          end

        end  

      end.

    Ltac simpl_getThreadC':=

      first[ rewrite gssThreadCode |

             auto_gsoThreadCode

           ].



