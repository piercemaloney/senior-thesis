
Require Import msl.msl_standard.

Require Import lam_ref_tcb.
Require Import lam_ref_eval.
Require Import lam_ref_mach_defs.
Require Import lam_ref_mach_lemmas.
Require Import lam_ref_type_defs.
Require Import lam_ref_type_safety.
Require Import lam_ref_type_rules.

Require Import programs.

Definition bad_UnivI_rule :=
  forall G e (X:pred world -> pred world),
    (forall tau, Typ G e (X tau)) ->
    Typ G e (allp X).

Definition crash :=
  e_let
    
    ( e_let  (New none) 
       (Lam 
          (Update (Var 1 )
              (App some (Var 0 ))
              (Var 1 ))))
    
    ( e_let  (App (Var 0 ) (Lam (Var 0))) 
     (e_let  (App (Var 1 ) (Nat 5))       
       (App (App (App out (Lam (Var 0))) (Deref (Var 1 ))) (Nat 42))
     )).

Lemma crash_steps : exists m,
  stepstar (empty_mem, crash) (m, App (Nat 5) (Nat 42)).
Proof.
  intros.
  case_eq (eval 100 empty_mem crash); intros.
  exists m.
  apply eval_correct with 100%Z.
  compute in *; congruence.
Qed.

Lemma crash_unsafe : ~safe_prog crash.
Proof.
  intros H.
  destruct crash_steps as [m Hst].
  spec H empty_mem (m,App (Nat 5) (Nat 42)) Hst.
  destruct H; inv H.
  inv H0.
  inv H4.
  simpl in H1; auto.
Qed.

Lemma bad_rule_crash :
  bad_UnivI_rule -> Typ nil crash ty_nat.
Proof.
  intros.
  unfold crash.
  unfold e_let at 1.
  apply T_App with (ALL tau:pred world, ty_lam tau (ty_ref (option tau))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option (ty_lam ty_nat ty_nat))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option ty_nat)).
  apply T_Abs.
  apply T_App with ty_nat.
  apply T_App with (option (ty_lam ty_nat ty_nat)).
  apply T_App with (ty_lam ty_nat ty_nat).
  apply T_weaken_nil.
  change (ty_lam (ty_lam ty_nat ty_nat)
    (ty_lam (option (ty_lam ty_nat ty_nat)) (ty_lam ty_nat ty_nat)))
  with ((fun t => ty_lam t (ty_lam (option t) t)) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply out_typ.
  apply T_Abs.
  apply T_Var; simpl; auto.
  apply T_Deref.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_App with ty_nat.
  change (ty_lam ty_nat (ty_ref (option ty_nat)))
    with ((fun t => ty_lam t (ty_ref (option t))) ty_nat).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Nat.

  apply T_App with (ty_lam ty_nat ty_nat).
  change (ty_lam (ty_lam ty_nat ty_nat) (ty_ref (option (ty_lam ty_nat ty_nat))))
    with ((fun t => ty_lam t (ty_ref (option t))) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Abs.
  apply T_Var; simpl; auto.

  unfold bad_UnivI_rule in H.
  apply H; intros.
  apply T_App with (ty_ref (option tau)).
  apply T_Abs.
  apply T_Abs.
  apply T_Update with (option tau).
  apply T_Var; simpl; auto.
  apply T_App with tau.
  change (ty_lam tau (option tau))
    with ((fun t => ty_lam t (option t)) tau).
  apply T_UnivE.
  apply T_weaken_nil.
  apply some_typ.
  apply T_Var; simpl; auto.
  apply T_Var; simpl; auto.
  apply T_New.
  apply T_UnivE.
  apply none_typ.
Qed.

Theorem unrestricted_universals_inconsistent : ~bad_UnivI_rule.
Proof.
  intro H.
  apply crash_unsafe.
  apply typing_implies_safety with ty_nat.
  apply bad_rule_crash.
  assumption.
Qed.

Definition ok_program :=
  e_let
    
    (Lam
    ( e_let  (New none) 
       (Lam 
          (Update (Var 1 )
              (App some (Var 0 ))
              (Var 1 )))))
    
    ( e_let  (App (App (Var 0 ) (Nat 0)) (Lam (Var 0))) 
     (e_let  (App (App (Var 1 ) (Nat 0)) (Nat 5))       
       (App (App (App out (Lam (Var 0))) (Deref (Var 1 ))) (Nat 42))
     )).

Lemma ok_program_types :
  Typ nil ok_program ty_nat.
Proof.
  intros.
  unfold ok_program.
  unfold e_let at 1.
  apply T_App with (ALL tau:pred world, ty_lam ty_nat (ty_lam tau (ty_ref (option tau)))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option (ty_lam ty_nat ty_nat))).
  apply T_Abs.
  unfold e_let at 1.
  apply T_App with (ty_ref (option ty_nat)).
  apply T_Abs.
  apply T_App with ty_nat.
  apply T_App with (option (ty_lam ty_nat ty_nat)).
  apply T_App with (ty_lam ty_nat ty_nat).
  apply T_weaken_nil.
  change (ty_lam (ty_lam ty_nat ty_nat)
    (ty_lam (option (ty_lam ty_nat ty_nat)) (ty_lam ty_nat ty_nat)))
  with ((fun t => ty_lam t (ty_lam (option t) t)) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply out_typ.
  apply T_Abs.
  apply T_Var; simpl; auto.
  apply T_Deref.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_App with ty_nat.
  apply T_App with ty_nat.
  change (ty_lam ty_nat (ty_lam ty_nat (ty_ref (option ty_nat))))
    with ((fun t => ty_lam ty_nat (ty_lam t (ty_ref (option t)))) ty_nat).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_Nat.

  apply T_App with (ty_lam ty_nat ty_nat).
  apply T_App with ty_nat.
  change (ty_lam ty_nat (ty_lam (ty_lam ty_nat ty_nat) (ty_ref (option (ty_lam ty_nat ty_nat)))))
    with ((fun t => ty_lam ty_nat (ty_lam t (ty_ref (option t)))) (ty_lam ty_nat ty_nat)).
  apply T_UnivE.
  apply T_Var; simpl; auto.
  apply T_Nat.
  apply T_Abs.
  apply T_Var; simpl; auto.

  apply T_UnivI; simpl; intros; auto.
  apply T_Abs.
  apply T_App with (ty_ref (option tau)).
  apply T_Abs.
  apply T_Abs.
  apply T_Update with (option tau).
  apply T_Var; simpl; auto.
  apply T_App with tau.
  change (ty_lam tau (option tau))
    with ((fun t => ty_lam t (option t)) tau).
  apply T_UnivE.
  apply T_weaken_nil.
  apply some_typ.
  apply T_Var; simpl; auto.
  apply T_Var; simpl; auto.
  apply T_New.
  apply T_UnivE.
  apply T_weaken_nil.
  apply none_typ.
Qed.

Theorem ok_program_safe :
  safe_prog ok_program.
Proof.
  eapply typing_implies_safety; apply ok_program_types.
Qed.

Eval vm_compute in (snd (eval 100 empty_mem crash)).
Eval vm_compute in (snd (eval 100 empty_mem ok_program)).

