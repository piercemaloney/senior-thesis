Require Import VST.veric.juicy_base.

Require Import VST.veric.juicy_mem.

Require Import VST.veric.juicy_mem_lemmas.



Require Import VST.veric.extend_tc.

Require Import VST.veric.Clight_seplog.

Require Import VST.veric.Clight_assert_lemmas.

Require Import VST.veric.tycontext.

Require Import VST.veric.expr2.

Require Import VST.veric.expr_lemmas.



Require Export VST.veric.initial_world.



Local Open Scope pred.



Obligation Tactic := idtac.



Notation initial_core' := (initial_core' function).



Notation initial_core := (@initial_core function).



Notation initial_core_ext := (@initial_core_ext  function).



Notation prog_funct := (@prog_funct function).



Inductive match_fdecs: list  (ident * fundef) -> funspecs -> Prop :=

| match_fdecs_nil: match_fdecs nil nil

| match_fdecs_cons: forall i fd fspec fs G,

                  type_of_fundef fd = type_of_funspec fspec ->

                  match_fdecs fs G ->

                  match_fdecs ((i,fd)::fs) ((i,fspec)::G)



.



Lemma match_fdecs_exists_Gfun:

  forall prog G i f,

    find_id i G = Some f ->

    match_fdecs (prog_funct prog) G ->

    exists fd,   In (i, Gfun fd) (prog_defs prog) /\

                     type_of_fundef fd = type_of_funspec f.

Proof. unfold prog_funct. unfold prog_defs_names.

intros ? ? ? ?.

forget (prog_defs prog) as dl.

revert G; induction dl; simpl; intros.

inv H0. inv H.

destruct a as [i' [?|?]].

inv H0.

simpl in H; if_tac in H. subst i'; inv H.

eauto.

destruct (IHdl G0) as [fd [? ?]]; auto.

exists fd; split; auto.

destruct (IHdl G) as [fd [? ?]]; auto.

exists fd; split; auto.



Qed.



Lemma initial_core_ok: forall (prog: program) G n m,

      list_norepet (prog_defs_names prog) ->

      match_fdecs (prog_funct prog) G ->

      Genv.init_mem prog = Some m ->

     initial_rmap_ok m (initial_core (Genv.globalenv prog) G n).

Proof.

intros.

rename H1 into Hm.

intros [b z]. simpl.

unfold initial_core; simpl.

rewrite <- core_resource_at.

rewrite resource_at_make_rmap.

unfold initial_core'.

simpl in *.

if_tac; [ | rewrite core_NO; auto].

case_eq (@Genv.invert_symbol (Ctypes.fundef function) type

       (@Genv.globalenv (Ctypes.fundef function) type prog) b);

   intros;  try now (rewrite core_NO; auto).

case_eq (find_id i G); intros; [ | rewrite core_NO; auto].

apply Genv.invert_find_symbol in H2.

pose proof (Genv.find_symbol_not_fresh _ _ Hm H2).

unfold valid_block in H4.

split; intros.

contradiction.

destruct (match_fdecs_exists_Gfun _ _ _ _ H3 H0) as [fd [? _]].

destruct f.

split; auto.

subst z.

destruct (find_symbol_globalenv _ _ _ H H2) as [RANGE [d ?]].

assert (d = Gfun fd).

clear - H H5 H1.

unfold prog_defs_names in H.

change (AST.prog_defs prog) with (prog_defs prog) in H.

forget (prog_defs prog) as dl. forget (nat_of_Z (Z.pos b-1)) as n.

revert dl H H5 H1; induction n; simpl; intros.

destruct dl; inv H1.

inv H. simpl in H5.

destruct H5. inv H; auto.

apply (in_map (@fst ident (globdef fundef type))) in H. simpl in H;  contradiction.

destruct dl; inv H1. inv H.

simpl in H5. destruct H5. subst.

clear - H2 H3. apply nth_error_in in H2.

apply (in_map (@fst ident (globdef fundef type))) in H2. simpl in *;  contradiction.

apply (IHn dl); auto.



subst d.

clear H5.

clear - RANGE H2 H1 H Hm.

unfold Genv.init_mem in Hm.

forget (Genv.globalenv prog) as ge.

change (AST.prog_defs prog) with (prog_defs prog) in Hm.

forget (prog_defs prog) as dl.

rewrite <- (rev_involutive dl) in H1,Hm.

rewrite nth_error_rev in H1.

2 : { rewrite rev_length. clear - RANGE.

      destruct RANGE.

      apply inj_lt_iff. rewrite Coqlib.nat_of_Z_eq by omega. omega. }

rename H1 into H5.

replace (length (rev dl) - nat_of_Z (Z.pos b - 1) - 1)%nat

 with (length (rev dl) - nat_of_Z (Z.pos b))%nat in H5.

2 : { rewrite rev_length.

      clear - RANGE.

      replace (nat_of_Z (Z.pos b-1)) with (nat_of_Z (Z.pos b) - 1)%nat.

      assert (nat_of_Z (Z.pos b) <= length dl)%nat.

      destruct RANGE.

      apply inj_le_iff. rewrite Coqlib.nat_of_Z_eq by omega. auto.

      assert (nat_of_Z (Z.pos b) > 0)%nat. apply inj_gt_iff.

      rewrite Coqlib.nat_of_Z_eq by omega.  simpl. omega.

      omega. destruct RANGE as [? _].

      apply nat_of_Z_lem1.

      assert (nat_of_Z (Z.pos b) > 0)%nat. apply inj_gt_iff. simpl.

      pose proof (Pos2Nat.is_pos b); omega.

      omega. }

assert (0 < nat_of_Z (Z.pos b) <= length dl)%nat.

{ clear - RANGE.

  destruct RANGE; split.

  apply inj_lt_iff. rewrite Coqlib.nat_of_Z_eq; try omega. simpl. auto.

  apply inj_le_iff. rewrite Coqlib.nat_of_Z_eq; try omega. }

clear RANGE; rename H0 into RANGE.

unfold nat_of_Z in *. rewrite Z2Nat.inj_pos in *.

rewrite <- rev_length in RANGE.

forget (rev dl) as dl'; clear dl; rename dl' into dl.

destruct RANGE.

rewrite alloc_globals_rev_eq in Hm.

revert m Hm H1 H5; induction dl; intros.

inv H5.

simpl in H1,Hm.

invSome.

specialize (IHdl _ Hm).

destruct (eq_dec (Pos.to_nat b) (S (length dl))).

+ rewrite e, minus_diag in H5. simpl in H5.

  inversion H5; clear H5; subst a.

  apply alloc_globals_rev_nextblock in Hm.

  rewrite Zlength_correct in Hm.

  rewrite <- inj_S in Hm. rewrite <- e in Hm.

  rewrite positive_nat_Z in Hm.  rewrite Pos2Z.id in Hm.

  subst b.

  clear IHdl H1 H0. clear dl e.

  unfold Genv.alloc_global in H6.

  revert H6; case_eq (alloc m0 0 1); intros.

  unfold drop_perm in H6.

  destruct (range_perm_dec m1 b 0 1 Cur Freeable).

  unfold max_access_at, access_at; inv H6.

  simpl. apply alloc_result in H0. subst b.

  rewrite PMap.gss.

  simpl. auto.

  inv H6.

+ destruct IHdl.

  omega.

  replace (length (a::dl) - Pos.to_nat b)%nat with (S (length dl - Pos.to_nat b))%nat in H5.

  apply H5.

  simpl. destruct (Pos.to_nat b); omega.

  assert (b < nextblock m0)%positive.

  apply alloc_globals_rev_nextblock in Hm.

  rewrite Zlength_correct in Hm. clear - Hm n H1.

  rewrite Hm.

  apply Pos2Nat.inj_lt.

  pattern Pos.to_nat at 1; rewrite <- Z2Nat.inj_pos.

  rewrite Z2Pos.id by omega.

  rewrite Z2Nat.inj_succ by omega.

  rewrite Nat2Z.id. omega.

  destruct (alloc_global_old _ _ _ _ H6 (b,0)) as [? ?]; auto.

  unfold max_access_at.

  rewrite <- H8.

  split; auto.

Qed.



Definition initial_jm (prog: program) m (G: funspecs) (n: nat)

        (H: Genv.init_mem prog = Some m)

        (H1: list_norepet (prog_defs_names prog))

        (H2: match_fdecs (prog_funct prog) G) : juicy_mem :=

  initial_mem m (initial_core (Genv.globalenv prog) G n)

           (initial_core_ok _ _ _ m H1 H2 H).



Lemma initial_jm_age (prog: program) m (G: funspecs) (n : nat)

        (H: Genv.init_mem prog = Some m)

        (H1: list_norepet (prog_defs_names prog))

        (H2: match_fdecs (prog_funct prog) G) :

age

    (initial_mem m (initial_core (Genv.globalenv prog) G (S n)) (initial_core_ok _ _ _ m H1 H2 H))

    (initial_mem m (initial_core (Genv.globalenv prog) G    n ) (initial_core_ok _ _ _ m H1 H2 H)).

Proof.

apply age1_juicy_mem_unpack''; [ | reflexivity].

simpl.

unfold inflate_initial_mem in *.

match goal with |- context [ proj1_sig ?x ] => destruct x as (r & lev & bah & Hg1); simpl end.

match goal with |- context [ proj1_sig ?x ] => destruct x as (r' & lev' & bah' & Hg2); simpl end.

apply rmap_age_i.

rewrite lev,lev'.

unfold initial_core; simpl.

rewrite !level_make_rmap. auto.

intro loc.

rewrite bah, bah'.

unfold inflate_initial_mem'.

destruct (access_at m loc Cur); [ | reflexivity].

destruct p; unfold resource_fmap; f_equal; try apply preds_fmap_NoneP.

unfold initial_core.

rewrite !resource_at_make_rmap.

unfold initial_core'.

if_tac; auto.

unfold fundef.

destruct (Genv.invert_symbol (Genv.globalenv (program_of_program prog))

        (fst loc)); auto.

destruct (find_id i G); auto.

destruct f; auto.

f_equal.

simpl.

f_equal.

rewrite lev'.

unfold initial_core.

rewrite level_make_rmap.

extensionality ts x b rho.

rewrite fmap_app.

match goal with

| |- ?A (?B ?C) = _ => change (A (B C)) with ((A oo B) C)

end.

rewrite approx_oo_approx' by omega.

rewrite approx'_oo_approx by omega.

auto.

rewrite Hg1, Hg2.

unfold initial_core; rewrite !ghost_of_make_rmap; auto.

Qed.



Lemma initial_core_ext_ok: forall {Z} (ora : Z) (prog: program) G n m,

      list_norepet (prog_defs_names prog) ->

      match_fdecs (prog_funct prog) G ->

      Genv.init_mem prog = Some m ->

     initial_rmap_ok m (initial_core_ext ora (Genv.globalenv prog) G n).

Proof.

intros.

rename H1 into Hm.

intros [b z]. simpl.

unfold initial_core_ext; simpl.

rewrite <- core_resource_at.

rewrite resource_at_make_rmap.

unfold initial_core'.

simpl in *.

if_tac; [ | rewrite core_NO; auto].

case_eq (@Genv.invert_symbol (Ctypes.fundef function) type (@Genv.globalenv (Ctypes.fundef function) type prog) b);

   intros;  try now (rewrite core_NO; auto).

case_eq (find_id i G); intros; [ | rewrite core_NO; auto].

apply Genv.invert_find_symbol in H2.

pose proof (Genv.find_symbol_not_fresh _ _ Hm H2).

unfold valid_block in H4.

split; intros.

contradiction.

destruct (match_fdecs_exists_Gfun _ _ _ _ H3 H0) as [fd [? _]].

destruct f.

split; auto.

subst z.

destruct (find_symbol_globalenv _ _ _ H H2) as [RANGE [d ?]].

assert (d = Gfun fd).

clear - H H5 H1.

unfold prog_defs_names in H.

change (AST.prog_defs prog) with (prog_defs prog) in H.

forget (prog_defs prog) as dl. forget (nat_of_Z (Z.pos b-1)) as n.

revert dl H H5 H1; induction n; simpl; intros.

destruct dl; inv H1.

inv H. simpl in H5.

destruct H5. inv H; auto.

apply (in_map (@fst ident (globdef fundef type))) in H. simpl in H;  contradiction.

destruct dl; inv H1. inv H.

simpl in H5. destruct H5. subst.

clear - H2 H3. apply nth_error_in in H2.

apply (in_map (@fst ident (globdef fundef type))) in H2. simpl in *;  contradiction.

apply (IHn dl); auto.



subst d.

clear H5.

clear - RANGE H2 H1 H Hm.

unfold Genv.init_mem in Hm.

forget (Genv.globalenv prog) as ge.

change (AST.prog_defs prog) with (prog_defs prog) in Hm.

forget (prog_defs prog) as dl.

rewrite <- (rev_involutive dl) in H1,Hm.

rewrite nth_error_rev in H1.

2 : {

  rewrite rev_length. clear - RANGE.

  destruct RANGE.

  apply inj_lt_iff. rewrite Coqlib.nat_of_Z_eq by omega. omega. }

rename H1 into H5.

replace (length (rev dl) - nat_of_Z (Z.pos b - 1) - 1)%nat

  with (length (rev dl) - nat_of_Z (Z.pos b))%nat in H5.

2 : { rewrite rev_length.

  clear - RANGE.

  replace (nat_of_Z (Z.pos b-1)) with (nat_of_Z (Z.pos b) - 1)%nat.

  assert (nat_of_Z (Z.pos b) <= length dl)%nat.

  destruct RANGE.

  apply inj_le_iff. rewrite Coqlib.nat_of_Z_eq by omega. auto.

  assert (nat_of_Z (Z.pos b) > 0)%nat. apply inj_gt_iff.

  rewrite Coqlib.nat_of_Z_eq by omega.  simpl. omega.

  omega. destruct RANGE as [? _].

  apply nat_of_Z_lem1.

  assert (nat_of_Z (Z.pos b) > 0)%nat. apply inj_gt_iff. simpl.

  pose proof (Pos2Nat.is_pos b); omega.

  omega. }

assert (0 < nat_of_Z (Z.pos b) <= length dl)%nat.

{ clear - RANGE.

  destruct RANGE; split.

  apply inj_lt_iff. rewrite Coqlib.nat_of_Z_eq; try omega. simpl. auto.

  apply inj_le_iff. rewrite Coqlib.nat_of_Z_eq; try omega. }

clear RANGE; rename H0 into RANGE.

unfold nat_of_Z in *. rewrite Z2Nat.inj_pos in *.

rewrite <- rev_length in RANGE.

forget (rev dl) as dl'; clear dl; rename dl' into dl.

destruct RANGE.

rewrite alloc_globals_rev_eq in Hm.

revert m Hm H1 H5; induction dl; intros.

inv H5.

simpl in H1,Hm.

invSome.

specialize (IHdl _ Hm).

destruct (eq_dec (Pos.to_nat b) (S (length dl))).

+ rewrite e, minus_diag in H5. simpl in H5.

  inversion H5; clear H5; subst a.

  apply alloc_globals_rev_nextblock in Hm.

  rewrite Zlength_correct in Hm.

  rewrite <- inj_S in Hm. rewrite <- e in Hm.

  rewrite positive_nat_Z in Hm.  rewrite Pos2Z.id in Hm.

  subst b.

  clear IHdl H1 H0. clear dl e.

  unfold Genv.alloc_global in H6.

  revert H6; case_eq (alloc m0 0 1); intros.

  unfold drop_perm in H6.

  destruct (range_perm_dec m1 b 0 1 Cur Freeable).

  unfold max_access_at, access_at; inv H6.

  simpl. apply alloc_result in H0. subst b.

  rewrite PMap.gss.

  simpl. auto.

  inv H6.

+ destruct IHdl.

  omega.

  replace (length (a::dl) - Pos.to_nat b)%nat with (S (length dl - Pos.to_nat b))%nat in H5.

  apply H5.

  simpl. destruct (Pos.to_nat b); omega.

  assert (b < nextblock m0)%positive.

  { apply alloc_globals_rev_nextblock in Hm.

    rewrite Zlength_correct in Hm. clear - Hm n H1.

    rewrite Hm.

    apply Pos2Nat.inj_lt.

    pattern Pos.to_nat at 1; rewrite <- Z2Nat.inj_pos.

    rewrite Z2Pos.id by omega.

    rewrite Z2Nat.inj_succ by omega.

    rewrite Nat2Z.id. omega. }

  destruct (alloc_global_old _ _ _ _ H6 (b,0)) as [? ?]; auto.

  unfold max_access_at.

  rewrite <- H8.

  split; auto.

Qed.



Definition initial_jm_ext {Z} (ora : Z) (prog: program) m (G: funspecs) (n: nat)

        (H: Genv.init_mem prog = Some m)

        (H1: list_norepet (prog_defs_names prog))

        (H2: match_fdecs (prog_funct prog) G) : juicy_mem :=

  initial_mem m (initial_core_ext ora (Genv.globalenv prog) G n)

           (initial_core_ext_ok _ _ _ _ m H1 H2 H).



Require Import VST.veric.ghost_PCM.

Lemma initial_jm_ext_eq : forall {Z} (ora : Z) (prog: program) m (G: funspecs) (n: nat)

        (H: Genv.init_mem prog = Some m)

        (H1: list_norepet (prog_defs_names prog))

        (H2: match_fdecs (prog_funct prog) G),

  join (m_phi (initial_jm prog m G n H H1 H2))

       (set_ghost (core (m_phi (initial_jm prog m G n H H1 H2))) (Some (ext_ghost ora, NoneP) :: nil) eq_refl)

       (m_phi (initial_jm_ext ora prog m G n H H1 H2)).

Proof.

  intros.

  apply resource_at_join2.

  - simpl.

    rewrite !inflate_initial_mem_level.

    unfold initial_core, initial_core_ext; rewrite !level_make_rmap; auto.

  - unfold set_ghost; rewrite level_make_rmap.

    rewrite level_core.

    simpl.

    rewrite !inflate_initial_mem_level.

    unfold initial_core, initial_core_ext; rewrite !level_make_rmap; auto.

  - intros.

    unfold set_ghost; rewrite resource_at_make_rmap, <- core_resource_at.

    simpl.

    unfold initial_core, initial_core_ext, inflate_initial_mem.

    rewrite !resource_at_make_rmap.

    unfold inflate_initial_mem'.

    rewrite !resource_at_make_rmap.

    apply join_comm, core_unit.

  - unfold set_ghost; rewrite ghost_of_make_rmap.

    simpl.

    unfold initial_core, initial_core_ext, inflate_initial_mem.

    rewrite !ghost_of_make_rmap.

    constructor.

Qed.



Notation prog_vars := (@prog_vars function).



Lemma initial_jm_without_locks prog m G n H H1 H2:

  no_locks (m_phi (initial_jm prog m G n H H1 H2)).

Proof.

  simpl.

  unfold inflate_initial_mem; simpl.

  match goal with |- context [ proj1_sig ?a ] => destruct a as (phi & lev & E & ?) end; simpl.

  unfold inflate_initial_mem' in E.

  unfold resource_at in E.

  unfold no_locks, "@"; intros.

  rewrite E.

  destruct (access_at m addr); [ |congruence].

  destruct p; try congruence.

  destruct (fst ((snd (unsquash (initial_core (Genv.globalenv prog) G n)))) addr);

  congruence.

Qed.



Lemma initial_jm_ext_without_locks {Z} (ora : Z) prog m G n H H1 H2:

  no_locks (m_phi (initial_jm_ext ora prog m G n H H1 H2)).

Proof.

  simpl.

  unfold inflate_initial_mem; simpl.

  match goal with |- context [ proj1_sig ?a ] => destruct a as (phi & lev & E & ?) end; simpl.

  unfold inflate_initial_mem' in E.

  unfold resource_at in E.

  unfold no_locks, "@"; intros.

  rewrite E.

  destruct (access_at m addr); try congruence.

  destruct p; try congruence.

  destruct (fst ((snd (unsquash (initial_core_ext ora (Genv.globalenv prog) G n)))) addr);

   congruence.

Qed.



Definition matchfunspecs (ge : genv) (G : funspecs) (Phi : rmap) : Prop :=

  forall (b : block) fsig cc A P Q,

    func_at'' fsig cc A P Q (b, 0%Z) Phi ->

    exists id P' Q' P'_ne Q'_ne,

      Genv.find_symbol ge id = Some b /\

      find_id id G = Some (mk_funspec fsig cc A P' Q' P'_ne Q'_ne) /\

      cond_approx_eq (level Phi) A P P' /\

      cond_approx_eq (level Phi) A Q Q'.



Lemma initial_jm_matchfunspecs prog m G n H H1 H2:

  matchfunspecs (globalenv prog) G (m_phi (initial_jm prog m G n H H1 H2)).

Proof.

  simpl.

  unfold inflate_initial_mem; simpl.

  match goal with |- context [ proj1_sig ?a ] => destruct a as (phi & lev & E & ?) end; simpl.

  unfold inflate_initial_mem' in E.

  unfold resource_at in E.

  intros b fsig cc A P Q FAT.

  unfold func_at'' in *.

  rewrite level_initial_core in lev.



  set (pp := SomeP _ _) in FAT.

  assert (Pi :

            initial_core (Genv.globalenv prog) G n @ (b, 0)

            = PURE (FUN fsig cc) (preds_fmap (approx n) (approx n) pp)).

  {

    simpl in FAT.

    pose proof FAT as E2.

    unfold "@" in *.

    rewrite E in FAT.

    destruct (access_at m (b, 0)) as [[]|]; simpl in E2; try congruence.

    set (r := fst ( _) _) in FAT at 2.

    destruct (fst ( (snd (unsquash (initial_core (Genv.globalenv prog) G n)))) (b, 0))

      as [t | t p k p0 | k p] eqn:E'''; simpl in E2; try congruence.

    subst r.

    injection FAT as -> ->; f_equal. subst pp. f_equal.

    simpl. f_equal.

    repeat extensionality.

    repeat (f_equal; auto).

  }



  clear -Pi lev.



  unfold initial_core in *.

  rewrite resource_at_make_rmap in Pi.

  unfold initial_core' in *.

  if_tac in Pi. 2:tauto.

  simpl fst in Pi.

  unfold fundef in *.

  destruct (Genv.invert_symbol (Genv.globalenv prog) b) as [i|] eqn:Eb. 2: congruence.

  destruct (find_id i G) as [f0 |] eqn:Ei. 2:congruence.

  destruct f0 as [f1 c0 A0 P0 Q0 P_ne0 Q_ne0].



  subst pp.

  injection Pi as <- -> -> EE.

  apply inj_pair2 in EE.

  apply Genv.invert_find_symbol in Eb.

  unfold filter_genv in *.

  exists i, P0, Q0, P_ne0, Q_ne0.

  split. assumption.

  split. assumption.

  subst n.



  constructor.

  all: intros ts.

  all: apply equal_f_dep with (x := ts) in EE.

  all: extensionality a.

  all: apply equal_f_dep with (x := a) in EE.



  1: apply equal_f_dep with (x := true) in EE.

  2: apply equal_f_dep with (x := false) in EE.



  all: extensionality ge.

  all: apply equal_f_dep with (x := ge) in EE.

  all: simpl in *.

  all: symmetry; rewrite <-EE.

  all: reflexivity.

Qed.



Lemma initial_jm_ext_matchfunspecs {Z} (ora : Z) prog m G n H H1 H2:

  matchfunspecs (globalenv prog) G (m_phi (initial_jm_ext ora prog m G n H H1 H2)).

Proof.

  simpl.

  unfold inflate_initial_mem; simpl.

  match goal with |- context [ proj1_sig ?a ] => destruct a as (phi & lev & E & ?) end; simpl.

  unfold inflate_initial_mem' in E.

  unfold resource_at in E.

  intros b fsig cc A P Q FAT.

  unfold func_at'' in *.

  unfold initial_core_ext in lev; rewrite level_make_rmap in lev.



  set (pp := SomeP _ _) in FAT.

  assert (Pi :

            initial_core_ext ora (Genv.globalenv prog) G n @ (b, 0)

            = PURE (FUN fsig cc) (preds_fmap (approx n) (approx n) pp)).

  {

    simpl in FAT.

    pose proof FAT as E2.

    unfold "@" in *.

    rewrite E in FAT.

    destruct (access_at m (b, 0)) as [[]|]; simpl in E2; try congruence.

    set (r := fst ( _) _) in FAT at 2.

    destruct (fst ( (snd (unsquash (initial_core_ext ora (Genv.globalenv prog) G n)))) (b, 0))

      as [t | t p k p0 | k p] eqn:E'''; simpl in E2; try congruence.

    subst r.

    injection FAT as -> ->; f_equal. subst pp. f_equal.

    simpl. f_equal.

    repeat extensionality.

    repeat (f_equal; auto).

  }



  clear -Pi lev.



  unfold initial_core_ext in *.

  rewrite resource_at_make_rmap in Pi.

  unfold initial_core' in *.

  if_tac in Pi. 2:tauto.

  simpl fst in Pi.

  unfold fundef in *.

  destruct (Genv.invert_symbol (Genv.globalenv prog) b) as [i|] eqn:Eb. 2: congruence.

  destruct (find_id i G) as [f0 |] eqn:Ei. 2:congruence.

  destruct f0 as [f1 c0 A0 P0 Q0 P_ne0 Q_ne0].



  subst pp.

  injection Pi as <- -> -> EE.

  apply inj_pair2 in EE.

  apply Genv.invert_find_symbol in Eb.

  unfold filter_genv in *.

  exists i, P0, Q0, P_ne0, Q_ne0.

  split. assumption.

  split. assumption.

  subst n.



  constructor.

  all: intros ts.

  all: apply equal_f_dep with (x := ts) in EE.

  all: extensionality a.

  all: apply equal_f_dep with (x := a) in EE.



  1: apply equal_f_dep with (x := true) in EE.

  2: apply equal_f_dep with (x := false) in EE.



  all: extensionality ge.

  all: apply equal_f_dep with (x := ge) in EE.

  all: simpl in *.

  all: symmetry; rewrite <-EE.

  all: reflexivity.

Qed.

