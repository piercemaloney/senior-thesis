
Set Implicit Arguments.

Require Import FCF.Crypto.
Require Import FCF.DistTacs.
Require Import FCF.ProgTacs.
Require Import FCF.GenTacs.
Require Import FCF.ProgramLogic.

Notation fcf_right := rightc.
Notation fcf_left := leftc.

Ltac fcf_inline := comp_inline.

Ltac fcf_swap := comp_swap.

Ltac fcf_ret := comp_ret.

Ltac fcf_irr_l := comp_irr_l.

Ltac fcf_irr_r := comp_irr_r.

Ltac fcf_inline_first := inline_first.

Ltac fcf_simp := comp_simp.

Ltac fcf_ident_expand_l :=
  dist_ident_expand_l || prog_ident_expand_l.

Ltac fcf_ident_expand_r :=
  dist_ident_expand_r || prog_ident_expand_r.

Ltac fcf_rewrite_expr e :=
  let x := fresh "x" in
  assert e as x; [idtac | rewrite x; clear x].

Ltac fcf_rewrite_l t :=
  match goal with 
    | [|- ?a == _ ] =>
      fcf_rewrite_expr (a == t)
    | [|- ?a <= _ ] =>
      fcf_rewrite_expr (a <= t)
  end.

Ltac fcf_rewrite_r t :=
  match goal with 
    | [|- _ == ?a ] =>
      fcf_rewrite_expr (a == t)
    | [|- _ <= ?a ] =>
      
      fcf_rewrite_expr (a == t)
  end.

Ltac fcf_skip := comp_skip.

Ltac fcf_skip_eq := prog_skip_eq.

Ltac fcf_to_prhl := 
  match goal with
    | [|- _ == _] => eapply comp_spec_impl_eq
    | [|- _ <= _] => eapply comp_spec_impl_le
  end.

Ltac fcf_to_prhl_eq := eapply comp_spec_eq_impl_eq.

Ltac fcf_to_probability :=
  match goal with 
    | [|- comp_spec (fun a b => a = _ -> b = _) _ _ ] => eapply le_impl_comp_spec
    | [|- comp_spec (fun a b => a = _ <-> b = _) _ _ ] => eapply eq_impl_comp_spec
    | [|- comp_spec eq _ _ ] => eapply comp_spec_consequence; [eapply eq_impl_comp_spec | idtac]
  end.

Ltac fcf_transitivity := dist_transitivity || prog_transitivity.

Ltac fcf_transitivity_r := prog_transitivity_r.

Ltac fcf_reflexivity := reflexivity || apply comp_spec_eq_refl.

Ltac fcf_symmetry := symmetry || prog_symmetry.

Ltac fcf_spec_ret :=
  eapply comp_spec_ret; trivial; intuition.

Ltac fcf_at t s l := comp_at t s l.

Ltac fcf_with pf t :=
    let x := fresh "x" in
    pose proof pf as x;
      t; 
      clear x.

Ltac fcf_fundamental_lemma := apply fundamental_lemma_h.

Ltac fcf_compute := dist_compute.

Ltac fcf_well_formed := wftac.

Ltac fcf_simp_in_support := repeat simp_in_support.

Theorem fcf_spec_seq : 
  forall {A B : Set} (P' : A -> B -> Prop) {C D : Set} P{eqda : EqDec A}{eqdb : EqDec B}{eqdc : EqDec C}{eqdd : EqDec D}(c1 : Comp A)(c2 : Comp B) (c : C) (d : D)
    (f1 : A -> Comp C)(f2 : B -> Comp D),
    comp_spec P' c1 c2 ->
    (forall a b, In a (getSupport c1) -> In b (getSupport c2) -> P' a b -> comp_spec P (f1 a) (f2 b)) ->
    comp_spec P (Bind c1 f1) (Bind c2 f2).

  intuition.
  eapply comp_spec_seq; intuition; eauto.

Qed.

Theorem fcf_oracle_eq :
  forall {S1 S2 : Set}(P : S1 -> S2 -> Prop)(A B C : Set) (c : OracleComp A B C) 
         (eqdb : EqDec B) (eqdc : EqDec C) 
         (o1 : S1 -> A -> Comp (B * S1)) (o2 : S2 -> A -> Comp (B * S2))
         (eqds1 : EqDec S1) (eqds2 : EqDec S2) (s1 : S1) 
         (s2 : S2),
    P s1 s2 ->
    (forall (a : A) (x1 : S1) (x2 : S2),
       P x1 x2 ->
       comp_spec
         (fun (y1 : B * S1) (y2 : B * S2) =>
            fst y1 = fst y2 /\ P (snd y1) (snd y2)) 
         (o1 x1 a) (o2 x2 a)) ->
    comp_spec
      (fun (a : C * S1) (b : C * S2) => fst a = fst b /\ P (snd a) (snd b))
      (c S1 eqds1 o1 s1) (c S2 eqds2 o2 s2).
  
  intuition.
  eapply oc_comp_spec_eq; intuition.
  
Qed.

Theorem fcf_oracle_eq_until_bad : 
  forall {S1 S2 : Set}(bad1 : S1 -> bool)
         (bad2 : S2 -> bool)(inv : S1 -> S2 -> Prop)(A B C : Set) (c : OracleComp A B C),
    well_formed_oc c ->
    forall (eqdb : EqDec B) (eqdc : EqDec C) 
           (o1 : S1 -> A -> Comp (B * S1)) (o2 : S2 -> A -> Comp (B * S2))
           (eqds1 : EqDec S1) (eqds2 : EqDec S2),
      (forall (a : S1) (b : A), bad1 a = true -> well_formed_comp (o1 a b)) ->
      (forall (a : S2) (b : A), bad2 a = true -> well_formed_comp (o2 a b)) ->
      (forall (x1 : S1) (x2 : S2) (a : A),
         inv x1 x2 ->
         bad1 x1 = bad2 x2 ->
         comp_spec
           (fun (y1 : B * S1) (y2 : B * S2) =>
              bad1 (snd y1) = bad2 (snd y2) /\
              (bad1 (snd y1) = false -> inv (snd y1) (snd y2) /\ fst y1 = fst y2))
           (o1 x1 a) (o2 x2 a)) ->
      (forall (a : B) (b c0 : S1) (d : A),
         bad1 c0 = true -> In (a, b) (getSupport (o1 c0 d)) -> bad1 b = true) ->
      (forall (a : B) (b c0 : S2) (d : A),
         bad2 c0 = true -> In (a, b) (getSupport (o2 c0 d)) -> bad2 b = true) ->
      forall (s1 : S1) (s2 : S2),
        inv s1 s2 ->
        bad1 s1 = bad2 s2 ->
        comp_spec
          (fun (y1 : C * S1) (y2 : C * S2) =>
             bad1 (snd y1) = bad2 (snd y2) /\
             (bad1 (snd y1) = false -> inv (snd y1) (snd y2) /\ fst y1 = fst y2))
          (c S1 eqds1 o1 s1) (c S2 eqds2 o2 s2).
  
  intuition.
  eapply oc_comp_spec_eq_until_bad; intuition.
  
Qed.

