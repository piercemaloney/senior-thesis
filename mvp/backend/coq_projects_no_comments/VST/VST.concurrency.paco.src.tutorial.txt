

Require Import Setoid Program.

Require Import VST.concurrency.paco.src.paco.



CoInductive stream :=

  | cons : nat -> stream -> stream.



Definition sunf s :=

  match s with cons n s' => cons n s' end.



Lemma sunf_eq : forall s, s = sunf s.

Proof.

  destruct s; auto.

Qed.



CoFixpoint enumerate n : stream :=

  cons n (enumerate (S n)).



CoFixpoint map f s : stream :=

  match s with cons n s' => cons (f n) (map f s') end.



Inductive seq_gen seq : stream -> stream -> Prop :=

  | _seq_gen : forall n s1 s2 (R : seq s1 s2 : Prop), seq_gen seq (cons n s1) (cons n s2).

Hint Constructors seq_gen.



CoInductive seq : stream -> stream -> Prop :=

  | seq_fold : forall s1 s2, seq_gen seq s1 s2 -> seq s1 s2.



Theorem example : forall n, seq (enumerate n) (cons n (map S (enumerate n))).

Proof.

  cofix CIH.

  intros; apply seq_fold.

  pattern (enumerate n) at 1; rewrite sunf_eq; simpl.

  constructor.

  rewrite (sunf_eq (enumerate n)); simpl.

  rewrite (sunf_eq (map _ _)); simpl.

  apply CIH.

Qed.



Definition seq' s1 s2 := paco2 seq_gen bot2 s1 s2.

Hint Unfold seq'.

Lemma seq_gen_mon: monotone2 seq_gen. Proof. pmonauto. Qed.

Hint Resolve seq_gen_mon : paco.



Theorem example' : forall n, seq' (enumerate n) (cons n (map S (enumerate n))).

Proof.

  pcofix CIH.

  intros; pfold.

  rewrite sunf_eq at 1; simpl.

  constructor.

  rewrite (sunf_eq (enumerate n)); simpl.

  rewrite (sunf_eq (map _ _)); simpl.

  right; apply CIH.

Qed.



Theorem seq_cons : forall n1 n2 s1 s2 (SEQ : seq (cons n1 s1) (cons n2 s2)),

  n1 = n2 /\ seq s1 s2.

Proof.

  intros.

  inversion_clear SEQ; rename H into SEQ.

  inversion_clear SEQ; auto.

Qed.



Theorem seq'_cons : forall n1 n2 s1 s2 (SEQ : seq' (cons n1 s1) (cons n2 s2)),

  n1 = n2 /\ seq' s1 s2.

Proof.

  intros.

  punfold SEQ.

  inversion_clear SEQ; pclearbot; auto.

Qed.



CoInductive inftree :=

  | node : nat -> inftree -> inftree -> inftree.



Definition tunf t : inftree :=

  match t with node n tl tr => node n tl tr end.



Lemma tunf_eq : forall t, t = tunf t.

Proof.

  destruct t; auto.

Qed.



CoFixpoint one : inftree := node 1 one two

with       two : inftree := node 2 one two.



CoFixpoint eins : inftree := node 1 eins (node 2 eins zwei)

with       zwei : inftree := node 2 eins zwei.



Inductive teq_gen teq : inftree -> inftree -> Prop :=

  | _teq_gen : forall n t1l t1r t2l t2r (Rl : teq t1l t2l : Prop) (Rr : teq t1r t2r),

                 teq_gen teq (node n t1l t1r) (node n t2l t2r).

Hint Constructors teq_gen.



CoInductive teq t1 t2 : Prop :=

  | teq_fold (IN : teq_gen teq t1 t2).



Theorem teq_one : teq one eins.

Proof.

  cofix CIH.

  apply teq_fold.

  rewrite (tunf_eq one), (tunf_eq eins); simpl.

  constructor; auto.

  apply teq_fold.

  rewrite (tunf_eq two); simpl.

  constructor; auto.

  cofix CIH'.

  apply teq_fold.

  rewrite (tunf_eq two), (tunf_eq zwei); simpl.

  constructor; auto.

Qed.



Theorem teq_two : teq two zwei.

Proof.

  cofix CIH.

  apply teq_fold.

  rewrite (tunf_eq two), (tunf_eq zwei); simpl.

  constructor; auto.

  cofix CIH'.

  apply teq_fold.

  rewrite (tunf_eq one), (tunf_eq eins); simpl.

  constructor; auto.

  apply teq_fold.

  rewrite (tunf_eq two); simpl.

  constructor; auto.

Qed.



Definition teq' t1 t2 := paco2 teq_gen bot2 t1 t2.

Hint Unfold teq'.

Lemma teq_gen_mon: monotone2 teq_gen. Proof. pmonauto. Qed.

Hint Resolve teq_gen_mon : paco.



Theorem teq'_one : teq' one eins.

Proof.

  pcofix CIH.

  pfold.

  rewrite (tunf_eq one), (tunf_eq eins); simpl.

  constructor; auto.

  left; pfold.

  rewrite (tunf_eq two); simpl.

  constructor; auto.

  left; pcofix CIH'.

  pfold.

  rewrite (tunf_eq two), (tunf_eq zwei); simpl.

  constructor; auto.

Qed.



Theorem teq'_two : teq' two zwei.

Proof.

  pcofix CIH.

  pfold.

  rewrite (tunf_eq two), (tunf_eq zwei); simpl.

  constructor; auto.

  left; pcofix CIH'.

  pfold.

  rewrite (tunf_eq one), (tunf_eq eins); simpl.

  constructor; auto.

  left; pfold.

  rewrite (tunf_eq two); simpl.

  constructor; auto.

Qed.



Lemma teq_two_one_bad : teq two zwei -> teq one eins.

Proof.

  intros; rewrite (tunf_eq two), (tunf_eq zwei) in H.

  destruct H; inversion IN; auto.

Defined.



Lemma teq_two_one : teq two zwei -> teq one eins.

Proof.

  intros; cofix CIH.

  apply teq_fold.

  rewrite (tunf_eq one), (tunf_eq eins); simpl.

  constructor; auto.

  apply teq_fold.

  rewrite (tunf_eq two); simpl.

  constructor; auto.

Defined.



Lemma teq_one_two : teq one eins -> teq two zwei.

Proof.

  intros; cofix CIH.

  apply teq_fold.

  rewrite (tunf_eq two), (tunf_eq zwei); simpl.

  constructor; auto.

Defined.



Theorem teq_eins : teq one eins.

Proof.

  cofix CIH.

  apply teq_two_one, teq_one_two, CIH.

Qed.



Theorem teq_zwei : teq two zwei.

Proof.

  cofix CIH.

  apply teq_one_two, teq_two_one, CIH.

Qed.



Theorem teq_eins_bad : teq one eins.

Proof.

  cofix CIH.

  apply teq_two_one_bad, teq_one_two, CIH.

Abort.



Lemma teq'_two_one : forall r,

  (r two zwei : Prop) -> paco2 teq_gen r one eins.

Proof.

  intros; pcofix CIH.

  pfold.

  rewrite (tunf_eq one), (tunf_eq eins); simpl.

  constructor; auto.

  left; pfold.

  rewrite (tunf_eq two); simpl.

  constructor; auto.

Qed.



Lemma teq'_one_two : forall r,

  (r one eins : Prop) -> paco2 teq_gen r two zwei.

Proof.

  intros; pcofix CIH.

  pfold.

  rewrite (tunf_eq two), (tunf_eq zwei); simpl.

  constructor; auto.

Qed.



Theorem teq'_eins : teq' one eins.

Proof.

  pcofix CIH.

  pmult; apply teq'_two_one, teq'_one_two, CIH.

Qed.



Theorem teq'_zwei : teq' two zwei.

Proof.

  pcofix CIH.

  pmult; apply teq'_one_two, teq'_two_one, CIH.

Qed.



Inductive eqone_gen eqone eqtwo : inftree -> Prop :=

  | _eqone_gen : forall tl tr (EQL : eqone tl : Prop) (EQR : eqtwo tr : Prop),

                    eqone_gen eqone eqtwo (node 1 tl tr).



Inductive eqtwo_gen eqone eqtwo : inftree -> Prop :=

  | _eqtwo_gen : forall tl tr (EQL : eqone tl : Prop) (EQR : eqtwo tr : Prop),

                   eqtwo_gen eqone eqtwo (node 2 tl tr).



Hint Constructors eqone_gen eqtwo_gen.



CoInductive eqone (t : inftree) : Prop :=

  | eqone_fold (EQ : eqone_gen eqone eqtwo t)

with eqtwo (t : inftree) : Prop :=

  | eqtwo_fold (EQ : eqtwo_gen eqone eqtwo t).



Lemma eqone_eins : eqone eins.

Proof.

  cofix CIH0; apply eqone_fold.

  rewrite tunf_eq; simpl; constructor.

    apply CIH0.

  cofix CIH1; apply eqtwo_fold.

  constructor.

    apply CIH0.

  rewrite tunf_eq; apply CIH1.

Qed.



Definition eqone' t := paco1_2_0 eqone_gen eqtwo_gen bot1 bot1 t.

Definition eqtwo' t := paco1_2_1 eqone_gen eqtwo_gen bot1 bot1 t.

Hint Unfold eqone' eqtwo'.

Lemma eqone_gen_mon: monotone1_2 eqone_gen. Proof. pmonauto. Qed.

Lemma eqtwo_gen_mon: monotone1_2 eqtwo_gen. Proof. pmonauto. Qed.

Hint Resolve eqone_gen_mon eqtwo_gen_mon : paco.



Lemma eqone'_eins: eqone' eins.

Proof.

  pcofix CIH0; pfold.

  rewrite tunf_eq; simpl; constructor.

    right; apply CIH0.

  left; pcofix CIH1; pfold.

  constructor.

    right; apply CIH0.

  right; rewrite tunf_eq; apply CIH1.

Qed.



Section safety.

  Context (X:Type)

  (P: X -> X -> Prop).



  CoInductive path x: Prop:=

  | step x': path x' -> P x x' -> path x.



  CoInductive stutter_path x: nat -> Prop :=

  | step' n1 n2 x':  stutter_path x' n1 -> P x x' -> stutter_path x n2

  | stutter n : stutter_path x n -> stutter_path x (S n).



  Inductive path_gen path : X -> Prop :=

  | _path_gen : forall x x', P x x' -> path x' -> path_gen path x.



  Definition path' := paco1 path_gen.



  Inductive stutterpath_gen (stutterpath : X -> nat -> Prop) : X -> nat -> Prop:=

  | _stutterpath_step : forall n1 n2 x x', P x x' -> stutterpath x' n1 -> stutterpath_gen stutterpath x n2

  | _stutterpath_stut : forall n x, stutterpath x n -> stutterpath_gen stutterpath x (S n).



  Definition stutterpath' := paco2 stutterpath_gen.



  Theorem theorem :

    forall x n,

      stutterpath' bot2 x n ->

      path' bot1  x.

  Proof.

    pcofix CIH. intros x n; revert x; induction n; intros x.

    - intros HH.

      inversion HH. clear HH.

      inversion SIM; subst. clear SIM.

      pfold.

      apply _path_gen with (x' := x'). auto.

      unfold upaco1 in *.

      right.

      apply CIH with n1.

      specialize (LE x' n1 ltac:(assumption)).

      destruct LE. 2: compute in *; tauto.

      unfold stutterpath' in *.

      auto. Guarded.

    - intros HH.

      inversion HH. clear HH.

      inversion SIM; subst; clear SIM.

      + pfold.

        apply _path_gen with (x' := x'). auto.

        unfold upaco1 in *.

        right.

        apply CIH with n1.

        specialize (LE x' n1 ltac:(assumption)).

        destruct LE. 2: compute in *; tauto.

        unfold stutterpath' in *.

        auto. Guarded.

      + pfold.



        Fail continue this.

  Abort.

End safety.

