Set Implicit Arguments.

Require Import VST.msl.Axioms.

Require Import compcert.lib.Coqlib.

Require Import compcert.lib.Integers.

Require Import sha.general_lemmas.

Require Import sha.ByteBitRelations.

Require Import sha.HMAC_common_defs.

Require Import sha.HMAC_spec_pad.



Require Import sha.SHA256.

Require Import sha.HMAC_functional_prog.

Require Import sha.HMAC256_functional_prog.

Require Import sha.hmac_common_lemmas.

Require Import sha.sha_padding_lemmas. 

Require Import sha.ShaInstantiation.



Lemma splitandpad_equiv : forall (bits : Blist) (bytes : list byte),

                            bytes_bits_lists bits bytes ->

                            bytes_bits_lists

                              (sha_splitandpad bits)

                              (pad bytes).

Proof.

  intros bits bytes inputs_eq.

  unfold concat.

  unfold sha_splitandpad.



  apply bytes_bits_ind_comp in inputs_eq.

  rewrite inputs_eq.

  apply bytes_bits_def_eq.

Qed.



Lemma gap_divide16 bits: NPeano.Nat.divide 16 (length (generate_and_pad' (bitsToBytes bits))).

Proof.

    unfold generate_and_pad'.

    destruct (pad_len_64_nat (bitsToBytes bits)).

     rewrite pure_lemmas.length_bytelist_to_intlist with (n:=(x*16)%nat).

       exists x. trivial.

     rewrite H. unfold WORD. rewrite (mult_comm (Z.to_nat 4)). rewrite mult_comm.

        rewrite <- mult_assoc. reflexivity.

Qed.



Module I256 <: INST.

Definition shah : Blist -> Blist ->  Blist := sha_h.

Definition hashblock : list int -> list int -> list int := SHA256.hash_block.

Definition HHB : shah =

      (fun rgs bl : Blist =>

       intsToBits (hashblock (bitsToInts rgs) (bitsToInts bl))).

  reflexivity. Qed.

Definition hashblocks: list int -> list int -> list int := SHA256.hash_blocks.

Definition d:nat := 16%nat.

Definition HBS_eq : forall r msg : list int,

         hash_blocks r msg =

         match msg with

         | List.nil => r

         | _ :: _ => hash_blocks (hash_block r (firstn d msg)) (skipn d msg)

         end := hash_blocks_equation.

End I256.



Module PAD := HMAC_Pad SHA256 I256.



Theorem HMAC_pad_concrete (K : list byte) (M H : list byte) (OP IP : byte)

                          (k m h : Blist) (op ip : Blist):

  ((length K) * 8)%nat = (c + p)%nat ->

  bytes_bits_lists k K ->

  bytes_bits_lists m M ->

  bytes_bits_lists op (HMAC_SHA256.sixtyfour OP) ->

  bytes_bits_lists ip (HMAC_SHA256.sixtyfour IP) ->

  sha.HMAC_spec_pad.HMAC c p B sha_h sha_iv sha_splitandpad op ip k m = h ->

  HMAC_SHA256.HmacCore IP OP M K = H ->

  bytes_bits_lists h H.

Proof. intros.

assert (sha_splitandpad =

        (fun bits : Blist =>

   bytesToBits (intlist_to_bytelist (generate_and_pad (bitsToBytes bits))))).

  clear.

  apply extensionality. intros l. unfold sha_splitandpad.

  f_equal. rewrite <- pad_compose_equal. unfold generate_and_pad'.

  rewrite pure_lemmas.bytelist_to_intlist_to_bytelist. trivial.

  destruct (pad_len_64_nat (bitsToBytes l)). rewrite Zlength_correct, H. exists (Z.of_nat (x*16)). do 2 rewrite Nat2Z.inj_mul. rewrite Z.mul_comm, <- Z.mul_assoc.  reflexivity.

rewrite H7 in H5; clear H7.

eapply PAD.HMAC_pad_concrete with (c:=c)(p:=p)(IP:=IP)(OP:=OP)(B:=B)(ip:=ip)(op:=op)(m:=m)(K:=K)

  (ir:=SHA256.init_registers)(gap:=generate_and_pad); try reflexivity; try eassumption.

- intros. rewrite <- pad_compose_equal. apply gap_divide16.

- intros; unfold SHA256.Hash.

  rewrite functional_prog.SHA_256'_eq; reflexivity.

- unfold SHA256.BlockSize.

  unfold c, p in H0. omega.

Qed.



Theorem HMAC_pad_concrete' (K : list byte) (M : list byte) (OP IP : byte)

                           (k m : Blist) (op ip : Blist):

  ((length K) * 8)%nat = (c + p)%nat ->

  Zlength K = Z.of_nat SHA256.BlockSize ->

  bytes_bits_lists k K ->

  bytes_bits_lists m M ->

  bytes_bits_lists op (HMAC_SHA256.sixtyfour OP) ->

  bytes_bits_lists ip (HMAC_SHA256.sixtyfour IP) ->

  sha.HMAC_spec_pad.HMAC c p B sha_h sha_iv sha_splitandpad op ip k m =

  bytesToBits (HMAC_SHA256.HmacCore IP OP M K).

Proof. intros.

  eapply bits_bytes_ind_comp.

    eapply HMAC_pad_concrete; try reflexivity; trivial.

Qed.



