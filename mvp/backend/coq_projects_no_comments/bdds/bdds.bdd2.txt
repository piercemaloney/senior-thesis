
Require Import Bool.
Require Import Sumbool.
Require Import Arith.
Require Import ZArith NArith Nnat Ndec Ndigits.
From IntMap Require Import Allmaps.
Require Import Wf_nat.

Require Import BDDvar_ad_nat.
Require Import bdd1.

Definition var (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   BDDzero
  | Some (x, (l, r)) => x
  end.

Definition low (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => l
  end.

Definition high (cfg : BDDconfig) (node : ad) :=
  match MapGet _ (fst cfg) node with
  | None =>   N0
  | Some (x, (l, r)) => r
  end.

Definition config_node_OK (cfg : BDDconfig) := node_OK (fst cfg).
Definition is_internal_node (cfg : BDDconfig) (node : ad) :=
  exists x : BDDvar,
    (exists l : ad,
       (exists r : ad, MapGet _ (fst cfg) node = Some (x, (l, r)))).

Lemma BDDvar_ordered_low :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (low cfg node) ->
 BDDcompare (var cfg (low cfg node)) (var cfg node) = Datatypes.Lt.
Proof.
  intro cfg.  elim cfg.  clear cfg.  intros bs y.  elim y.  clear y.
  intros share counter.  intros node H H0 H1.  elim H0.  intros x H2.  elim H2.  intros l H3.
  elim H3.  intros r H4.  clear H2 H3.  elim H1.  intros x1 H2.  elim H2.
  intros l1 H3.  elim H3.  intros r1 H5.  clear H2 H3.  unfold var, low in |- *.
  rewrite H4.  unfold low in H5.  rewrite H4 in H5.  rewrite H5.  elim H.
  intros H2 H3.  clear H3.  elim H2.  intros H3 H6.  elim H6.  intros H7 H8.
  cut (BDD_OK bs node).  intro H9.  unfold BDD_OK in H9.  unfold BDDordered in H9.
  simpl in H4.  simpl in H5.  rewrite H4 in H9.
  cut
   (node = BDDzero \/
    node = BDDone \/
    (exists x0 : BDDvar,
       (exists l0 : BDDvar,
          (exists r0 : BDDvar,
             MapGet _ bs node = Some (x0, (l0, r0)) /\
             BDDcompare x0 (ad_S x) = Datatypes.Lt /\
             Neqb l0 r0 = false /\
             BDDbounded bs l0 x0 /\ BDDbounded bs r0 x0)))).
  intros H10.  elim H10.  intro H11.  rewrite H11 in H4.  rewrite H4 in H3.
  discriminate H3.  intro H11.  elim H11.  intro H12.  rewrite H12 in H4.
  rewrite H4 in H6.  elim H6.  intros H13 H14.  discriminate H13.  intros H12.  elim H12.
  clear H12.  intros x0 H12.  elim H12.  clear H12.  intros x2 H12.  elim H12.  intros x3 H13.
  clear H12.  clear H10 H11.  elim H13.  intros H10 H11.  rewrite H4 in H10.
  injection H10.  intros H12 H14 H15.  rewrite <- H12 in H11.  rewrite <- H14 in H11.
  rewrite <- H15 in H11.  clear H13 H10.  cut (BDDbounded bs l x).  intros H10.
  cut
   (l = BDDzero \/
    l = BDDone \/
    (exists xl : BDDvar,
       (exists ll : BDDvar,
          (exists rl : BDDvar,
             MapGet _ bs l = Some (xl, (ll, rl)) /\
             BDDcompare xl x = Datatypes.Lt /\
             Neqb ll rl = false /\
             BDDbounded bs ll xl /\ BDDbounded bs rl xl)))).
  intros H13.  elim H13.  intro H16.  rewrite H16 in H5.  rewrite H5 in H3.
  discriminate H3.  intro H16.  elim H16.  intro H17.  rewrite H17 in H5.
  rewrite H5 in H7.  discriminate H7.  intro H17.  clear H13 H16.  elim H17.
  clear H17.  intros x4 H13.  elim H13.  clear H13.  intros x5 H13.  elim H13.  clear H13.
  intros x6 H13.  elim H13.  clear H13.  intros H13 H16.  rewrite H5 in H13.  injection H13.
  intros H17 H18 H19.  rewrite <- H19 in H16.  exact (proj1 H16).  
  apply BDDbounded_lemma.  assumption.  
  exact (proj1 (proj2 (proj2 H11))).  apply BDDbounded_lemma.
  assumption.  apply H8.  unfold in_dom in |- *.  simpl in H4.  rewrite H4.  trivial.
Qed.

Lemma BDDvar_ordered_high :
 forall (cfg : BDDconfig) (node : ad),
 BDDconfig_OK cfg ->
 is_internal_node cfg node ->
 is_internal_node cfg (high cfg node) ->
 BDDcompare (var cfg (high cfg node)) (var cfg node) = Datatypes.Lt.
Proof.
  intro cfg.  elim cfg.  clear cfg.  intros bs y.  elim y.  clear y.
  intros share counter.  intros node H H0 H1.  elim H0.  intros x H2.  elim H2.  intros l H3.
  elim H3.  intros r H4.  clear H2 H3.  elim H1.  intros x1 H2.  elim H2.
  intros l1 H3.  elim H3.  intros r1 H5.  clear H2 H3.  unfold var, high in |- *.
  rewrite H4.  unfold high in H5.  rewrite H4 in H5.  rewrite H5.  elim H.
  intros H2 H3.  clear H3.  elim H2.  intros H3 H6.  elim H6.  intros H7 H8.
  cut (BDD_OK bs node).  intro H9.  unfold BDD_OK in H9.  unfold BDDordered in H9.
  simpl in H4.  simpl in H5.  rewrite H4 in H9.
  cut
   (node = BDDzero \/
    node = BDDone \/
    (exists x0 : BDDvar,
       (exists l0 : BDDvar,
          (exists r0 : BDDvar,
             MapGet _ bs node = Some (x0, (l0, r0)) /\
             BDDcompare x0 (ad_S x) = Datatypes.Lt /\
             Neqb l0 r0 = false /\
             BDDbounded bs l0 x0 /\ BDDbounded bs r0 x0)))).
  intros H10.  elim H10.  intro H11.  rewrite H11 in H4.  rewrite H4 in H3.
  discriminate H3.  intro H11.  elim H11.  intro H12.  rewrite H12 in H4.
  rewrite H4 in H6.  elim H6.  intros H13 H14.  discriminate H13.  intros H12.  elim H12.
  clear H12.  intros x0 H12.  elim H12.  clear H12.  intros x2 H12.  elim H12.  intros x3 H13.
  clear H12.  clear H10 H11.  elim H13.  intros H10 H11.  rewrite H4 in H10.
  injection H10.  intros H12 H14 H15.  rewrite <- H12 in H11.  rewrite <- H14 in H11.
  rewrite <- H15 in H11.  clear H13 H10.  cut (BDDbounded bs r x).  intros H10.
  cut
   (r = BDDzero \/
    r = BDDone \/
    (exists xr : BDDvar,
       (exists lr : BDDvar,
          (exists rr : BDDvar,
             MapGet _ bs r = Some (xr, (lr, rr)) /\
             BDDcompare xr x = Datatypes.Lt /\
             Neqb lr rr = false /\
             BDDbounded bs lr xr /\ BDDbounded bs rr xr)))).
  intros H13.  elim H13.  intro H16.  rewrite H16 in H5.  rewrite H5 in H3.
  discriminate H3.  intro H16.  elim H16.  intro H17.  rewrite H17 in H5.
  rewrite H5 in H7.  discriminate H7.  intro H17.  clear H13 H16.  elim H17.
  clear H17.  intros x4 H13.  elim H13.  clear H13.  intros x5 H13.  elim H13.  clear H13.
  intros x6 H13.  elim H13.  clear H13.  intros H13 H16.  rewrite H5 in H13.  injection H13.
  intros H17 H18 H19.  rewrite <- H19 in H16.  exact (proj1 H16).  
  apply BDDbounded_lemma.  assumption.  
  exact (proj2 (proj2 (proj2 H11))).  apply BDDbounded_lemma.
  assumption.  apply H8.  unfold in_dom in |- *.  simpl in H4.  rewrite H4.  trivial.
Qed.

Definition var_binding := BDDvar -> bool.
 
Definition bool_fun := var_binding -> bool.

Definition bool_fun_eval (bf : bool_fun) (vb : var_binding) := bf vb.

Definition bool_fun_zero (vb : var_binding) := false. 
Definition bool_fun_one (vb : var_binding) := true. 

Fixpoint bool_fun_of_BDD_1 (cfg : BDDconfig) (node : ad) 
 (bound : nat) {struct bound} : bool_fun :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then bool_fun_zero else bool_fun_one
  | Some (x, (l, r)) =>
      match bound with
      | O =>   bool_fun_zero
      | S bound' =>
          let bfl := bool_fun_of_BDD_1 cfg l bound' in
          let bfr := bool_fun_of_BDD_1 cfg r bound' in
          fun vb : var_binding => if vb x then bfr vb else bfl vb
      end
  end.

Lemma bool_fun_of_BDD_1_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  forall vb : var_binding,
  (vb (var cfg node) = true ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (high cfg node) (pred bound)) vb) /\
  (vb (var cfg node) = false ->
   bool_fun_eval (bool_fun_of_BDD_1 cfg node bound) vb =
   bool_fun_eval (bool_fun_of_BDD_1 cfg (low cfg node) (pred bound)) vb)).
Proof.
  intro cfg.  elim cfg.  clear cfg.  intros bs y.  elim y.  clear y.
  intros share counter.  intro H.  simple induction bound.  split.
  unfold bool_fun_of_BDD_1 in |- *.  elim H.  intros H0 H1.  elim H0.  intros H2 H3.  simpl in |- *.
  rewrite H2.  trivial.  split.  elim H.  intros H0 H1.  elim H0.  intros H2 H3.
  unfold bool_fun_of_BDD_1 in |- *.  simpl in |- *.  rewrite (proj1 H3).  trivial.
  unfold is_internal_node in |- *.  intro node.  intro H0.  unfold var in |- *.  elim H0.  clear H0.
  intros x H0.  elim H0.  clear H0.  intros l H0.  elim H0.  clear H0.
  intros r H0.  rewrite H0.  intro H1.  cut (~ nat_of_N x < 0).
  unfold not in |- *.  tauto.  apply lt_n_O.  intros n H0.  elim H.  intros H1 H2.  elim H1.
  intros H3 H4.  elim H4.  intros H5 H6.  split.  unfold bool_fun_of_BDD_1 in |- *.  simpl in |- *.
  rewrite H3.  trivial.  split.  unfold bool_fun_of_BDD_1 in |- *.  simpl in |- *.
  rewrite H5.  trivial.  intro node.  intro H7.  unfold is_internal_node in H7.
  elim H7.  clear H7.  intro x.  intro H7.  elim H7.  clear H7.  intro x0.  intro H7.
  elim H7.  clear H7.  intro x1.  intro H7.  unfold var in |- *.  rewrite H7.  intro H8.
  intro vb.  split.  intro H9.  unfold bool_fun_of_BDD_1 in |- *.  rewrite H7.
  unfold high in |- *.  rewrite H7.  unfold pred in |- *.  unfold bool_fun_eval in |- *.  rewrite H9.
  trivial.  intro H9.  unfold bool_fun_of_BDD_1 in |- *.  rewrite H7.
  unfold bool_fun_eval in |- *.  rewrite H9.  unfold pred in |- *.  unfold low in |- *.  rewrite H7.
  trivial.
Qed.

Lemma bool_fun_of_BDD_1_semantics_1 :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall bound : nat,
 bool_fun_of_BDD_1 cfg BDDzero bound = bool_fun_zero /\
 bool_fun_of_BDD_1 cfg BDDone bound = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  nat_of_N (var cfg node) < bound ->
  bool_fun_of_BDD_1 cfg node bound =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD_1 cfg (high cfg node) (pred bound) vb
   else bool_fun_of_BDD_1 cfg (low cfg node) (pred bound) vb)).
Proof.
  intro cfg.  elim cfg.  clear cfg.  intros bs y.  elim y.  clear y.
  intros share counter.  intro H.  simple induction bound.  split.
  unfold bool_fun_of_BDD_1 in |- *.  elim H.  intros H0 H1.  elim H0.  intros H2 H3.  simpl in |- *.
  rewrite H2.  trivial.  split.  elim H.  intros H0 H1.  elim H0.  intros H2 H3.
  unfold bool_fun_of_BDD_1 in |- *.  simpl in |- *.  rewrite (proj1 H3).  trivial.
  unfold is_internal_node in |- *.  intro node.  intro H0.  unfold var in |- *.  elim H0.  clear H0.
  intros x H0.  elim H0.  clear H0.  intros l H0.  elim H0.  clear H0.
  intros r H0.  rewrite H0.  intro H1.  cut (~ nat_of_N x < 0).  unfold not in |- *.
  tauto.  apply lt_n_O.  intros n H0.  elim H.  intros H1 H2.  elim H1.  intros H3 H4.  elim H4.
  intros H5 H6.  split.  unfold bool_fun_of_BDD_1 in |- *.  simpl in |- *.  rewrite H3.  trivial.
  split.  unfold bool_fun_of_BDD_1 in |- *.  simpl in |- *.  rewrite H5.  trivial.  intro node.
  intro H7.  unfold is_internal_node in H7.  elim H7.  clear H7.  intro x.  intro H7.
  elim H7.  clear H7.  intro x0.  intro H7.  elim H7.  clear H7.  intro x1.  intro H7.
  unfold var in |- *.  rewrite H7.  intro H8.  unfold pred in |- *.  unfold bool_fun_of_BDD_1 at 1 in |- *.
  rewrite H7.  unfold high in |- *.  rewrite H7.  unfold low in |- *.  rewrite H7.  trivial.
Qed.

Lemma bool_fun_of_BDD_1_semantics_2 :
 forall (cfg : BDDconfig) (node : ad) (bound1 bound2 : nat),
 MapGet _ (fst cfg) node = None ->
 bool_fun_of_BDD_1 cfg node bound1 = bool_fun_of_BDD_1 cfg node bound2.
Proof.
  intros cfg node bound1 bound2 H.  case bound1.  simpl in |- *.  case bound2.  simpl in |- *.  reflexivity.  simpl in |- *.
  rewrite H.  trivial.  simpl in |- *.  rewrite H.  case bound2.  simpl in |- *.  rewrite H.
  trivial.  simpl in |- *.  rewrite H.  trivial.  
Qed.

Lemma bool_fun_of_BDD_1_change_bound :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 forall (bound : nat) (node : ad),
 nat_of_N (var cfg node) < bound ->
 bool_fun_of_BDD_1 cfg node bound =
 bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).
Proof.
  intro cfg.  elim cfg.  clear cfg.  intros bs y.  elim y.  clear y.
  intros share counter.  intro H.  intro bound.
  apply
   lt_wf_ind
    with
      (P := fun bound : nat =>
            forall node : ad,
            nat_of_N (var (bs, (share, counter)) node) < bound ->
            bool_fun_of_BDD_1 (bs, (share, counter)) node bound =
            bool_fun_of_BDD_1 (bs, (share, counter)) node
              (S (nat_of_N (var (bs, (share, counter)) node)))).
  intros n H0 node H1.  elim (option_sum _ (MapGet _ (fst (bs, (share, counter))) node)).
  intros y.  elim y.  clear y.  intro x.  elim x.  clear x.  intros x y.  elim y.
  clear y.  intros l r.  intros y.
  cut (is_internal_node (bs, (share, counter)) node).  intro H2.
  cut
   (bool_fun_of_BDD_1 (bs, (share, counter)) node n =
    (fun vb : var_binding =>
     match vb (var (bs, (share, counter)) node) with
     | true =>
         bool_fun_of_BDD_1 (bs, (share, counter))
           (high (bs, (share, counter)) node) (pred n) vb
     | false =>
         bool_fun_of_BDD_1 (bs, (share, counter))
           (low (bs, (share, counter)) node) (pred n) vb
     end)).
  intro H3.  rewrite H3.
  cut
   (bool_fun_of_BDD_1 (bs, (share, counter)) node
      (S (nat_of_N (var (bs, (share, counter)) node))) =
    (fun vb : var_binding =>
     match vb (var (bs, (share, counter)) node) with
     | true =>
         bool_fun_of_BDD_1 (bs, (share, counter))
           (high (bs, (share, counter)) node)
           (pred (S (nat_of_N (var (bs, (share, counter)) node)))) vb
     | false =>
         bool_fun_of_BDD_1 (bs, (share, counter))
           (low (bs, (share, counter)) node)
           (pred (S (nat_of_N (var (bs, (share, counter)) node)))) vb
     end)).
  intro H4.  rewrite H4.  unfold pred at 3 4 in |- *.
  cut
   (bool_fun_of_BDD_1 (bs, (share, counter))
      (high (bs, (share, counter)) node) (pred n) =
    bool_fun_of_BDD_1 (bs, (share, counter))
      (high (bs, (share, counter)) node)
      (nat_of_N (var (bs, (share, counter)) node))).
  intro H5.  rewrite H5.
  cut
   (bool_fun_of_BDD_1 (bs, (share, counter))
      (low (bs, (share, counter)) node) (pred n) =
    bool_fun_of_BDD_1 (bs, (share, counter))
      (low (bs, (share, counter)) node)
      (nat_of_N (var (bs, (share, counter)) node))).
  intro H6.  rewrite H6.  trivial.  
  elim
   (option_sum _
      (MapGet _ (fst (bs, (share, counter)))
         (low (bs, (share, counter)) node))).
  intros y0.  elim y0.  clear y0.  intro x0.  elim x0.  clear x0.  intros xl y0.
  elim y0.  clear y0.  intros ll rl.  intros y0.
  cut
   (nat_of_N (var (bs, (share, counter)) (low (bs, (share, counter)) node)) <
    pred n).
  intro H6.
  cut
   (nat_of_N (var (bs, (share, counter)) (low (bs, (share, counter)) node)) <
    nat_of_N (var (bs, (share, counter)) node)).
  intro H7.  clear H3 H4 H5.  cut (pred n < n).  intro H3.
  rewrite (H0 (pred n) H3 (low (bs, (share, counter)) node) H6).
  rewrite
   (H0 (nat_of_N (var (bs, (share, counter)) node)) H1
      (low (bs, (share, counter)) node) H7).
  trivial.  apply lt_pred_n_n.  apply neq_O_lt.  unfold not in |- *.  intro H3.
  rewrite <- H3 in H1.
  cut (~ nat_of_N (var (bs, (share, counter)) node) < 0).  unfold not in |- *.
  tauto.  apply lt_n_O.  apply BDDcompare_lt.  apply BDDvar_ordered_low.
  assumption.  assumption.  unfold is_internal_node in |- *.  split with xl.
  split with ll.  split with rl.  assumption.  
  apply
   le_lt_trans with (m := pred (nat_of_N (var (bs, (share, counter)) node))).
  cut (forall x y : nat, x < y -> x <= pred y).  intro H6.  apply H6.
  apply BDDcompare_lt.  apply BDDvar_ordered_low.  assumption.  assumption.
  unfold is_internal_node in |- *.  split with xl.  split with ll.  split with rl.
  assumption.  unfold lt in |- *.  double induction x0 y1.  auto.  intro n0.  intros H6 H7.
  auto with arith.  auto with arith.  intros n0 H6 n1 H7 H8.  unfold pred in |- *.  auto with arith.
  apply lt_pred.  assumption.  unfold not in |- *.  intro H6.
  cut (var (bs, (share, counter)) node = N0).
  cut (var (bs, (share, counter)) node <> N0).  auto.
  apply
   INFERIEUR_neq_O
    with (x := var (bs, (share, counter)) (low (bs, (share, counter)) node)).
  apply BDDvar_ordered_low.  assumption.  assumption.  split with xl.
  split with ll.  split with rl.  assumption.  apply O_N0.  assumption.
  intros y0.  apply bool_fun_of_BDD_1_semantics_2.  assumption.
  elim
   (option_sum _
      (MapGet _ (fst (bs, (share, counter)))
         (high (bs, (share, counter)) node))).
  intros y0.  elim y0.  clear y0.  intro x0.  elim x0.  clear x0.  intros xr y0.
  elim y0.  clear y0.  intros lr rr.  intros y0.
  cut
   (nat_of_N (var (bs, (share, counter)) (high (bs, (share, counter)) node)) <
    pred n).
  intro H5.
  cut
   (nat_of_N (var (bs, (share, counter)) (high (bs, (share, counter)) node)) <
    nat_of_N (var (bs, (share, counter)) node)).
  intro H6.  clear H3 H4.  cut (pred n < n).  intro H3.
  rewrite
   (H0 (nat_of_N (var (bs, (share, counter)) node)) H1
      (high (bs, (share, counter)) node) H6).
  rewrite (H0 (pred n) H3 (high (bs, (share, counter)) node) H5).  trivial.
  apply lt_pred_n_n.  apply neq_O_lt.  unfold not in |- *.  intro H3.
  rewrite <- H3 in H1.
  cut (~ nat_of_N (var (bs, (share, counter)) node) < 0).  unfold not in |- *.
  tauto.  apply lt_n_O.  apply BDDcompare_lt.  apply BDDvar_ordered_high.
  assumption.  assumption.  unfold is_internal_node in |- *.  split with xr.
  split with lr.  split with rr.  assumption.
  apply
   le_lt_trans with (m := pred (nat_of_N (var (bs, (share, counter)) node))).
  cut (forall x y : nat, x < y -> x <= pred y).  intro H5.  apply H5.
  apply BDDcompare_lt.  apply BDDvar_ordered_high.  assumption.  assumption.
  unfold is_internal_node in |- *.  split with xr.  split with lr.  split with rr.
  assumption.  unfold lt in |- *.  double induction x0 y1.  auto.  intro n0.  intros H5 H6.
  auto with arith.  auto with arith.  intros n0 H5 n1 H6 H7.  unfold pred in |- *.  auto with arith.
  apply lt_pred.  assumption.  unfold not in |- *.  intro H5.
  cut (var (bs, (share, counter)) node = N0).
  cut (var (bs, (share, counter)) node <> N0).  auto.  
  apply
   INFERIEUR_neq_O
    with (x := var (bs, (share, counter)) (high (bs, (share, counter)) node)).
  apply BDDvar_ordered_high.  assumption.  assumption.  split with xr.
  split with lr.  split with rr.  assumption.  apply O_N0.  assumption.
  intro y0.  apply bool_fun_of_BDD_1_semantics_2.  assumption.
  apply
   (proj2
      (proj2
         (bool_fun_of_BDD_1_semantics_1 (bs, (share, counter)) H
            (S (nat_of_N (var (bs, (share, counter)) node)))))).
  unfold is_internal_node in |- *.  split with x.  split with l.  split with r.
  assumption.  auto with arith.  
  apply
   (proj2 (proj2 (bool_fun_of_BDD_1_semantics_1 (bs, (share, counter)) H n))).
  unfold is_internal_node in |- *.  split with x.  split with l.  split with r.
  assumption.  auto with arith.  unfold is_internal_node in |- *.  split with x.
  split with l.  split with r.  assumption.  intros y.
  apply bool_fun_of_BDD_1_semantics_2.  assumption.
Qed.

Definition bool_fun_of_BDD (cfg : BDDconfig) (node : ad) :=
  bool_fun_of_BDD_1 cfg node (S (nat_of_N (var cfg node))).

Lemma bool_fun_of_BDD_semantics :
 forall cfg : BDDconfig,
 BDDconfig_OK cfg ->
 bool_fun_of_BDD cfg BDDzero = bool_fun_zero /\
 bool_fun_of_BDD cfg BDDone = bool_fun_one /\
 (forall node : ad,
  is_internal_node cfg node ->
  bool_fun_of_BDD cfg node =
  (fun vb : var_binding =>
   if vb (var cfg node)
   then bool_fun_of_BDD cfg (high cfg node) vb
   else bool_fun_of_BDD cfg (low cfg node) vb)).
Proof.
  intros cfg H.  unfold bool_fun_of_BDD in |- *.  split.
  apply
   (proj1
      (bool_fun_of_BDD_1_semantics_1 cfg H (S (nat_of_N (var cfg BDDzero))))).
  split.
  apply
   (proj1
      (proj2
         (bool_fun_of_BDD_1_semantics_1 cfg H
            (S (nat_of_N (var cfg BDDone)))))).
  intros node H0.  cut (nat_of_N (var cfg node) < S (nat_of_N (var cfg node))).
  intro H1.
  rewrite
   (proj2
      (proj2
         (bool_fun_of_BDD_1_semantics_1 cfg H (S (nat_of_N (var cfg node)))))
      node H0 H1).
  cut
   (bool_fun_of_BDD_1 cfg (high cfg node)
      (pred (S (nat_of_N (var cfg node)))) =
    bool_fun_of_BDD_1 cfg (high cfg node)
      (S (nat_of_N (var cfg (high cfg node))))).
  intro H2.
  cut
   (bool_fun_of_BDD_1 cfg (low cfg node)
      (pred (S (nat_of_N (var cfg node)))) =
    bool_fun_of_BDD_1 cfg (low cfg node)
      (S (nat_of_N (var cfg (low cfg node))))).
  intro H3.  rewrite H2.  rewrite H3.  trivial.  unfold pred in |- *.
  elim (option_sum _ (MapGet _ (fst cfg) (low cfg node))).  intros y.  elim y.
  clear y.  intro x.  elim x.  clear x.  intros x y.  elim y.  clear y.
  intros l r.  intro y.
  cut (nat_of_N (var cfg (low cfg node)) < nat_of_N (var cfg node)).
  intro H3.
  rewrite
   (bool_fun_of_BDD_1_change_bound cfg H (nat_of_N (var cfg node))
      (low cfg node) H3).
  trivial.  apply BDDcompare_lt.  apply BDDvar_ordered_low.  assumption.
  assumption.  unfold is_internal_node in |- *.  split with x.  split with l.
  split with r.  assumption.  intros y.  apply bool_fun_of_BDD_1_semantics_2.
  assumption.  unfold pred in |- *.
  elim (option_sum _ (MapGet _ (fst cfg) (high cfg node))).  intros y.  elim y.
  clear y.  intro x.  elim x.  clear x.  intros x y.  elim y.  clear y.
  intros l r.  intro y.
  cut (nat_of_N (var cfg (high cfg node)) < nat_of_N (var cfg node)).
  intro H2.
  rewrite
   (bool_fun_of_BDD_1_change_bound cfg H (nat_of_N (var cfg node))
      (high cfg node) H2).
  trivial.  apply BDDcompare_lt.  apply BDDvar_ordered_high.  assumption.
  assumption.  unfold is_internal_node in |- *.  split with x.  split with l.
  split with r.  assumption.  intros y.  apply bool_fun_of_BDD_1_semantics_2.
  assumption.  unfold lt in |- *.  auto.  
Qed.

Definition bool_fun_eq (bf1 bf2 : bool_fun) :=
  forall vb : var_binding, bool_fun_eval bf1 vb = bool_fun_eval bf2 vb.

Lemma bool_fun_eq_symm :
 forall bf1 bf2 : bool_fun, bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf1.
Proof.
  unfold bool_fun_eq in |- *.  unfold bool_fun_eval in |- *.  intros bf1 bf2 H vb.  rewrite (H vb).
  reflexivity.
Qed.

Lemma bool_fun_eq_trans :
 forall bf1 bf2 bf3 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq bf2 bf3 -> bool_fun_eq bf1 bf3.
Proof.
  unfold bool_fun_eq in |- *.  unfold bool_fun_eval in |- *.  intros bf1 bf2 bf3 H H0 vb.  rewrite (H vb).
  rewrite <- (H0 vb).  reflexivity.
Qed.

Definition bool_fun_neg (bf : bool_fun) : bool_fun :=
  fun vb : var_binding => negb (bf vb).
Definition bool_fun_or (bf1 bf2 : bool_fun) : bool_fun :=
  fun vb : var_binding => bf1 vb || bf2 vb.

Lemma bool_fun_neg_semantics :
 forall (bf : bool_fun) (vb : var_binding),
 (bool_fun_eval bf vb = true -> bool_fun_eval (bool_fun_neg bf) vb = false) /\
 (bool_fun_eval bf vb = false -> bool_fun_eval (bool_fun_neg bf) vb = true).
Proof.
  intros bf vb.  unfold bool_fun_eval in |- *.  unfold bool_fun_neg in |- *.  unfold negb in |- *.
  elim (bf vb).  auto.  auto.
Qed.

Lemma bool_fun_neg_zero : bool_fun_neg bool_fun_zero = bool_fun_one.
Proof.
  unfold bool_fun_neg, bool_fun_zero, bool_fun_one in |- *.  simpl in |- *.  trivial.
Qed.

Lemma bool_fun_neg_one : bool_fun_neg bool_fun_one = bool_fun_zero.
Proof.
  unfold bool_fun_neg, bool_fun_zero, bool_fun_one in |- *.  simpl in |- *.  trivial.
Qed.

Lemma bool_fun_eq_neg :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2) -> bool_fun_eq bf1 bf2.
Proof.
  unfold bool_fun_eq, bool_fun_neg in |- *.  unfold bool_fun_eval in |- *.  intros bf1 bf2 H vb.
  cut (negb (bf1 vb) = negb (bf2 vb)).  unfold negb in |- *.  elim (bf1 vb).
  elim (bf2 vb).  intro H0.  reflexivity.  intro H0.  rewrite H0.  reflexivity.
  elim (bf2 vb).  intro H0.  rewrite H0.  reflexivity.  intro H0.  reflexivity.  
  apply H.
Qed.

Lemma bool_fun_eq_neg_1 :
 forall bf1 bf2 : bool_fun,
 bool_fun_eq bf1 bf2 -> bool_fun_eq (bool_fun_neg bf1) (bool_fun_neg bf2).
Proof.
unfold bool_fun_eq, bool_fun_neg in |- *.  unfold bool_fun_eval in |- *.  unfold negb in |- *.  intros bf1 bf2 H vb.
rewrite (H vb).  reflexivity.
Qed.

Definition BDDneg_memo := Map ad.
Definition BDDneg_memo_lookup (memo : BDDneg_memo) 
  (a : ad) := MapGet _ memo a.
Definition BDDneg_memo_put (memo : BDDneg_memo) (a node : ad) :=
  MapPut _ memo a node.

Definition BDDneg_memo_OK (cfg : BDDconfig) (memo : BDDneg_memo) :=
  forall a node : ad,
  BDDneg_memo_lookup memo a = Some node ->
  config_node_OK cfg node /\
  bool_fun_of_BDD cfg node = bool_fun_neg (bool_fun_of_BDD cfg a) /\
  var cfg a = var cfg node. 

Fixpoint BDDneg_2 (cfg : BDDconfig) (node : ad) (bound : nat) {struct bound} 
   : BDDconfig * ad :=
  match MapGet _ (fst cfg) node with
  | None => if Neqb node BDDzero then (cfg, BDDone) else (cfg, BDDzero)
  | Some (x, (l, r)) =>
      match bound with
      | O =>   (initBDDconfig, BDDzero)
      | S bound' =>
          BDDmake (fst (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound')) x
            (snd (BDDneg_2 cfg l bound'))
            (snd (BDDneg_2 (fst (BDDneg_2 cfg l bound')) r bound'))
      end
  end.

