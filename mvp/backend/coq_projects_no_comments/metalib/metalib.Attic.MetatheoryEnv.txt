

Require Import Coq.FSets.FSets.

Require Import Coq.Lists.List.

Require Import Coq.Logic.Decidable.



Require Import Metalib.CoqFSetDecide.

Require Import Metalib.CoqListFacts.



Require Import Metalib.AssocList.

Require Import Metalib.MetatheoryAtom.

Import AtomSetImpl.

Require Import Metalib.LibTactics.



Module Type ENVIRONMENT.



Set Implicit Arguments.



Definition one (C : Type) (item : C) : list C := cons item nil.



Notation "x ~ a" := (one (x, a)) (at level 50) : list_scope.



Arguments Scope app [ type_scope list_scope list_scope ].



Open Scope list_scope.



Fixpoint dom

  (C : Type) (E : list (atom*C))

  : atoms :=

  match E with

    | nil => empty

    | (x, _) :: E' => add x (dom E')

  end.



Fixpoint get

  (C : Type) (x : atom) (E : list (atom*C))

  : option C :=

  match E with

    | nil => None

    | (y, c) :: F => if eq_atom_dec x y then Some c else get x F

  end.



Definition binds

  (A : Type) (x : atom) (a : A) (E : list (atom*A))

  : Prop :=

  List.In (x, a) E.



Definition maps

  (A : Type) (x : atom) (a : A) (E : list (atom*A))

  : Prop :=

  get x E = Some a.



Definition disjoint

  (A B : Type) (E : list (atom*A)) (F : list (atom*B))

  : Prop :=

  inter (dom E) (dom F) [<=] empty.



Definition map

  (A B : Type) (f : A -> B) (E : list (atom*A))

  : list (atom*B) :=

  List.map (fun b => match b with (x, a) => (x, f a) end) E.



Inductive uniq (A : Type) : list (atom*A) -> Prop :=

  | uniq_nil :

      uniq nil

  | uniq_push : forall x a E,

      uniq E ->

      ~ In x (dom E) ->

      uniq (x ~ a ++ E).



Unset Implicit Arguments.



Section ListProperties.

  Variable  X : Type.

  Variables x y : X.

  Variables l l1 l2 l3 : list X.



  Axiom cons_app_one :

    cons x l = one x ++ l.



  Axiom cons_app_assoc :

    (cons x l1) ++ l2 = cons x (l1 ++ l2).



  Axiom app_assoc :

    (l1 ++ l2) ++ l3 = l1 ++ (l2 ++ l3).



  Axiom app_nil_1 :

    nil ++ l = l.



  Axiom app_nil_2 :

    l ++ nil = l.



  Axiom in_nil_iff :

    List.In x nil <-> False.



  Axiom in_one_iff :

    List.In x (one y) <-> x = y.



  Axiom in_app_iff :

    List.In x (l1 ++ l2) <-> List.In x l1 \/ List.In x l2.



End ListProperties.



Section Properties.

  Variables A B key : Type.

  Variable  f       : A -> B.

  Variable  x       : atom.

  Variable  b       : A.

  Variables E F G   : list (atom*A).



  Axiom map_nil :

    map f (@nil (atom*A)) = nil.



  Axiom map_one :

    map f (x ~ b) = (x ~ f b).



  Axiom map_cons :

    map f ((x, b) :: E) = x ~ f b ++ map f E.



  Axiom map_app :

    map f (E ++ F) = map f E ++ map f F.



  Axiom dom_nil :

    dom (@nil (atom*A)) = empty.



  Axiom dom_one :

    dom (x ~ b) [=] singleton x.



  Axiom dom_cons :

    dom ((x, b) :: E) [=] union (singleton x) (dom E).



  Axiom dom_app :

    dom (E ++ F) [=] union (dom E) (dom F).



  Axiom dom_map :

    dom (map f E) [=] dom E.



End Properties.



Hint Rewrite cons_app_one cons_app_assoc      : rewr_list.

Hint Rewrite app_assoc app_nil_1 app_nil_2    : rewr_list.

Hint Rewrite in_nil_iff in_one_iff in_app_iff : rewr_list_in.



Hint Rewrite map_nil map_one map_cons map_app         : rewr_map.

Hint Rewrite dom_nil dom_one dom_cons dom_app dom_map : rewr_dom.



Ltac simpl_env :=

  autorewrite with rewr_list rewr_map rewr_dom.

Tactic Notation "simpl_env" "in" hyp(H) :=

  autorewrite with rewr_list rewr_map rewr_dom in H.

Tactic Notation "simpl_env" "in" "*" :=

  autorewrite with rewr_list rewr_map rewr_dom in *.



Tactic Notation "rewrite_env" constr(E) :=

  match goal with

    | |- context[?x] =>

      change x with E

    | |- context[?x] =>

      replace x with E;

        [ | try reflexivity; simpl_env; reflexivity ]

  end.



Tactic Notation "rewrite_env" constr(E) "in" hyp(H) :=

  match type of H with

    | context[?x] =>

      change x with E in H

    | context[?x] =>

      replace x with E in H;

        [ | try reflexivity; simpl_env; reflexivity ]

  end.



Axiom alist_ind : forall (A : Type) (P : list (atom * A) -> Type),

  (P nil) ->

  (forall x a xs, P xs -> P (x ~ a ++ xs)) ->

  (forall xs, P xs).



Tactic Notation "env" "induction" ident(E) :=

  try (intros until E);

  let T := type of E in

  let T := eval compute in T in

  match T with

    | list (?key * ?A) => induction E using (alist_ind A)

  end.



Tactic Notation "env" "induction" ident(E) "as" simple_intropattern(P) :=

  try (intros until E);

  let T := type of E in

  let T := eval compute in T in

  match T with

    | list (?key * ?A) => induction E as P using (alist_ind A)

  end.



Section Disjoint.

  Implicit Types A B C : Type.



  Axiom disjoint_sym_1 :

    forall A B (E : list (atom*A)) (F : list (atom*B)),

    disjoint E F ->

    disjoint F E.



  Axiom disjoint_sym :

    forall A B (E : list (atom*A)) (F : list (atom*B)),

    disjoint E F <-> disjoint F E.



  Axiom disjoint_nil_1 :

    forall A B (E : list (atom*B)),

    disjoint (@nil (atom*A)) E.



  Axiom disjoint_one_1 :

    forall A B (x : atom) (a : A) (F : list (atom*B)),

    disjoint (x ~ a) F ->

    ~ In x (dom F).



  Axiom disjoint_one_2 :

    forall A B (x : atom) (a : A) (F : list (atom*B)),

    ~ In x (dom F) ->

    disjoint (x ~ a) F.



  Axiom disjoint_one_l :

    forall A B (x : atom) (a : A) (E : list (atom*B)),

    disjoint (x ~ a) E <-> ~ In x (dom E).



  Axiom disjoint_one_r :

    forall A B (x : atom) (a : A) (E : list (atom*B)),

    disjoint E (x ~ a) <-> ~ In x (dom E).



  Axiom disjoint_cons_1 :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint ((x, a) :: E) F ->

    ~ In x (dom F).



  Axiom disjoint_cons_2 :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint ((x, a) :: E) F ->

    disjoint E F.



  Axiom disjoint_cons_3 :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint E F ->

    ~ In x (dom F) ->

    disjoint ((x, a) :: E) F.



  Axiom disjoint_cons_l :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint ((x, a) :: E) F <-> ~ In x (dom F) /\ disjoint E F.



  Axiom disjoint_cons_r :

    forall A B x a (E : list (atom*A)) (F : list (atom*B)),

    disjoint F ((x, a) :: E) <-> ~ In x (dom F) /\ disjoint E F.



  Axiom disjoint_app_1 :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint (E ++ F) G ->

    disjoint E G.



  Axiom disjoint_app_2 :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint (E ++ F) G ->

    disjoint F G.



  Axiom disjoint_app_3 :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint E G ->

    disjoint F G ->

    disjoint (E ++ F) G.



  Axiom disjoint_app_l :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint (E ++ F) G <-> disjoint E G /\ disjoint F G.



  Axiom disjoint_app_r :

    forall A B (E F : list (atom*A)) (G : list (atom*B)),

    disjoint G (E ++ F) <-> disjoint E G /\ disjoint F G.



  Axiom disjoint_map_1 :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint (map f E) F ->

    disjoint E F.



  Axiom disjoint_map_2 :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint E F ->

    disjoint (map f E) F.



  Axiom disjoint_map_l :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint (map f E) F <-> disjoint E F.



  Axiom disjoint_map_r :

    forall A B C (E : list (atom*A)) (F : list (atom*B)) (f:A->C),

    disjoint F (map f E) <-> disjoint E F.



End Disjoint.



Section UniqProperties.

  Variables A B   : Type.

  Variables f     : A -> B.

  Variables x     : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom uniq_one_1 :

    uniq (x ~ b).



  Axiom uniq_cons_1 :

    uniq ((x, a) :: E) ->

    uniq E.



  Axiom uniq_cons_2 :

    uniq ((x, a) :: E) ->

    ~ In x (dom E).



  Axiom uniq_cons_3 :

    uniq E ->

    ~ In x (dom E) ->

    uniq ((x, a) :: E).



  Axiom uniq_cons_iff :

    uniq ((x, a) :: E) <-> uniq E /\ ~ In x (dom E).



  Axiom uniq_app_1 :

    uniq (E ++ F) -> uniq E.



  Axiom uniq_app_2 :

    uniq (E ++ F) -> uniq F.



  Axiom uniq_app_3 :

    uniq (E ++ F) -> disjoint E F.



  Axiom uniq_app_4 :

    uniq E ->

    uniq F ->

    disjoint E F ->

    uniq (E ++ F).



  Axiom uniq_app_iff :

    uniq (E ++ F) <-> uniq E /\ uniq F /\ disjoint E F.



  Axiom uniq_map_1 :

    uniq (map f E) ->

    uniq E.



  Axiom uniq_map_2 :

    uniq E ->

    uniq (map f E).



  Axiom uniq_map_iff :

    uniq (map f E) <-> uniq E.



End UniqProperties.



Section BindsProperties.

  Variable  A B   : Type.

  Variables f     : A -> B.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom binds_nil_iff :

    binds x a nil <-> False.



  Axiom binds_one_1 :

    binds x a (y ~ b) ->

    x = y.



  Axiom binds_one_2 :

    binds x a (y ~ b) ->

    a = b.



  Axiom binds_one_3 :

    x = y ->

    a = b ->

    binds x a (y ~ b).



  Axiom binds_one_iff :

    binds x a (y ~ b) <-> x = y /\ a = b.



  Axiom binds_cons_1 :

    binds x a ((y, b) :: E) ->

    (x = y /\ a = b) \/ binds x a E.



  Axiom binds_cons_2 :

    x = y ->

    a = b ->

    binds x a ((y, b) :: E).



  Axiom binds_cons_3 :

    binds x a E ->

    binds x a ((y, b) :: E).



  Axiom binds_cons_iff :

    binds x a ((y, b) :: E) <-> (x = y /\ a = b) \/ binds x a E.



  Axiom binds_app_1 :

    binds x a (E ++ F) ->

    binds x a E \/ binds x a F.



  Axiom binds_app_2 :

    binds x a E ->

    binds x a (E ++ F).



  Axiom binds_app_3 :

    binds x a F ->

    binds x a (E ++ F).



  Axiom binds_app_iff :

    binds x a (E ++ F) <-> binds x a E \/ binds x a F.



  Axiom binds_map_1 :

    (forall a b, f a = f b -> a = b) ->

    binds x (f a) (map f E) ->

    binds x a E.



  Axiom binds_map_2 :

    binds x a E ->

    binds x (f a) (map f E).



  Axiom binds_dom_contradiction : forall (E : list (atom*A)),

    binds x a E ->

    ~ In x (dom E) ->

    False.



  Axiom binds_app_uniq_1 :

    uniq (E ++ F) ->

    binds x a (E ++ F) ->

    (binds x a E /\ ~ In x (dom F)) \/ (binds x a F /\ ~ In x (dom E)).



  Axiom binds_app_uniq_iff :

    uniq (E ++ F) ->

    (binds x a (E ++ F) <->

      (binds x a E /\ ~ In x (dom F)) \/

      (binds x a F /\ ~ In x (dom E))).



End BindsProperties.



Section BindsProperties2.

  Variable  A B   : Type.

  Variables f     : A -> B.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom binds_cons_uniq_1 :

    uniq ((y, b) :: E) ->

    binds x a ((y, b) :: E) ->

    (x = y /\ a = b /\ ~ In x (dom E)) \/ (binds x a E /\ x <> y).



  Axiom binds_cons_uniq_iff :

    uniq ((y, b) :: E) ->

    (binds x a ((y, b) :: E) <->

      (x = y /\ a = b /\ ~ In x (dom E)) \/

      (binds x a E /\ x <> y)).



End BindsProperties2.



Hint Resolve

  @app_assoc @app_nil_2 @map_app @dom_one @dom_cons @dom_app @dom_map.



Hint Resolve

  @disjoint_sym_1 @disjoint_nil_1 @disjoint_one_2 @disjoint_cons_3

  @disjoint_app_3 @disjoint_map_2 @uniq_nil @uniq_push @uniq_one_1

  @uniq_cons_3 @uniq_app_4 @uniq_map_2.



Hint Resolve

  @binds_one_3 @binds_cons_3 @binds_app_2 @binds_app_3 @binds_map_2.



Section AssortedListProperties.

  Variable  X : Type.

  Variables x : X.

  Variables xs ys zs : list X.



  Axiom one_eq_app :

    one x ++ xs = ys ++ zs ->

    (exists qs, ys = x :: qs /\ xs = qs ++ zs) \/

    (ys = nil /\ zs = x :: xs).



  Axiom app_eq_one :

    ys ++ zs = one x ++ xs ->

    (exists qs, ys = x :: qs /\ xs = qs ++ zs) \/

    (ys = nil /\ zs = x :: xs).



  Axiom nil_neq_one_mid :

    nil <> xs ++ one x ++ ys.



  Axiom one_mid_neq_nil :

    xs ++ one x ++ ys <> nil.



End AssortedListProperties.



Ltac destruct_uniq :=

  match goal with

    | H : uniq nil |- _ =>

      clear H;

      destruct_uniq

    | H : uniq (?x ~ ?a) |- _ =>

      clear H;

      destruct_uniq

    | H : uniq ((?x, ?a) :: ?E) |- _ =>

      let J := fresh "UniqTac" in

      pose proof H as J;

      apply uniq_cons_1 in H;

      apply uniq_cons_2 in J;

      autorewrite with rewr_dom in J;

      destruct_uniq

    | H : uniq (?E ++ ?F) |- _ =>

      let J1 := fresh "UniqTac" in

      let J2 := fresh "UniqTac" in

      pose proof H as J1;

      pose proof H as J2;

      apply uniq_app_1 in H;

      apply uniq_app_2 in J1;

      apply uniq_app_3 in J2;

      destruct_uniq

    | H : uniq (map ?f ?E) |- _ =>

      apply uniq_map_1 in H;

      destruct_uniq

    | H : disjoint nil ?E |- _ =>

      clear H;

      destruct_uniq

    | H : disjoint (?x ~ ?a) ?F |- _ =>

      apply disjoint_one_1 in H;

      autorewrite with rewr_dom in H;

      destruct_uniq

    | H : disjoint ((?x, ?a) :: ?E) ?F |- _ =>

      let J := fresh "UniqTac" in

      pose proof H as J;

      apply disjoint_cons_1 in H;

      apply disjoint_cons_2 in J;

      autorewrite with rewr_dom in H;

      destruct_uniq

    | H : disjoint (?E ++ ?F) ?G |- _ =>

      let J := fresh "UniqTac" in

      pose proof H as J;

      apply disjoint_app_1 in H;

      apply disjoint_app_2 in J;

      destruct_uniq

    | H : disjoint (map ?f ?E) ?F |- _ =>

      apply disjoint_map_1 in H;

      destruct_uniq

    | H : disjoint ?E nil |- _ =>

      clear H;

      destruct_uniq

    | H : disjoint ?F (?x ~ ?a) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | H : disjoint ?F ((?x, ?a) :: ?E) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | H : disjoint ?G (?E ++ ?F) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | H : disjoint ?F (map ?f ?E) |- _ =>

      apply disjoint_sym_1 in H;

      destruct_uniq

    | _ =>

      idtac

  end.



Ltac solve_uniq :=

  intros;

  destruct_uniq;

  repeat first [ apply uniq_push

               | apply uniq_cons_3

               | apply uniq_app_4

               | apply uniq_one_1

               | apply uniq_nil ];

  auto;

  try tauto;

  unfold disjoint in *;

  try fsetdec;

  fail "Not solvable by [solve_uniq]; try [destruct_uniq]".



Section UniqDerived.

  Variable  A     : Type.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom uniq_insert_mid :

    uniq (G ++ E) ->

    ~ In x (dom G) ->

    ~ In x (dom E) ->

    uniq (G ++ (x ~ a) ++ E).



  Axiom uniq_remove_mid :

    uniq (E ++ F ++ G) ->

    uniq (E ++ G).



  Axiom uniq_reorder_1 :

    uniq (E ++ F) ->

    uniq (F ++ E).



  Axiom uniq_reorder_2 :

    uniq (E ++ F ++ G) ->

    uniq (F ++ E ++ G).



  Axiom uniq_map_app_l : forall (f : A -> A),

    uniq (F ++ E) ->

    uniq (map f F ++ E).



  Axiom fresh_mid_tail :

    uniq (F ++ (x ~ a) ++ E) ->

    ~ In x (dom E).



  Axiom fresh_mid_head :

    uniq (F ++ (x ~ a) ++ E) ->

    ~ In x (dom F).



End UniqDerived.



Ltac destruct_binds_hyp H :=

  match type of H with

    | binds ?x ?a nil =>

      inversion H

    | binds ?x ?a (?y ~ ?b) =>

      let J1 := fresh "BindsTacKey" in

      let J2 := fresh "BindsTacVal" in

      rename H into J1;

      pose proof J1 as J2;

      apply binds_one_1 in J1;

      apply binds_one_2 in J2;

      try (subst x);

      try (subst a);

      try (subst y);

      try (subst b)

    | binds ?x ?a ((?y, ?b) :: ?E) =>

      change (binds x a (y ~ b ++ E)) in H;

      destruct_binds_hyp H

    | binds ?x ?a (?E ++ ?F) =>

      let J := fresh "BindsTac" in

      apply binds_app_1 in H;

      destruct H as [J | J];

      destruct_binds_hyp J

    | _ =>

      idtac

  end.



Ltac destruct_binds_hyp_uniq H :=

  match type of H with

    | binds ?x ?a nil =>

      inversion H

    | binds ?x ?a (?y ~ ?b) =>

      let J1 := fresh "BindsTacKey" in

      let J2 := fresh "BindsTacVal" in

      rename H into J1;

      pose proof J1 as J2;

      apply binds_one_1 in J1;

      apply binds_one_2 in J2;

      try (subst x);

      try (subst a);

      try (subst y);

      try (subst b)

    | binds ?x ?a ((?y, ?b) :: ?E) =>

      change (binds x a (y ~ b ++ E)) in H;

      destruct_binds_hyp_uniq H

    | binds ?x ?a (?E ++ ?F) =>

      let J1 := fresh "BindsTacSideCond" in

      assert (J1 : uniq (E ++ F));

        [ destruct_uniq; auto

        | match type of J1 with

            | @uniq ?A _ =>

              let J2 := fresh "BindsTac" in

              destruct (@binds_app_uniq_1 A x a E F J1 H)

                as [[J2 ?] | [J2 ?]];

              clear H;

              destruct_binds_hyp_uniq J2

          end

        ]

    | _ =>

      idtac

  end.



Ltac analyze_binds_cleanup :=

  auto;

  try tauto;

  try discriminate;

  try match goal with

        | J : ~ In ?x ?E |- _ =>

          match E with

            | context [x] => elim J; clear; simpl_env; auto with set

          end

      end.



Ltac analyze_binds H :=

  destruct_binds_hyp H;

  analyze_binds_cleanup.



Ltac analyze_binds_uniq H :=

  destruct_binds_hyp_uniq H;

  analyze_binds_cleanup.



Section BindsDerived.

  Variables A B   : Type.

  Variables f     : A -> B.

  Variables x y   : atom.

  Variables a b   : A.

  Variables E F G : list (atom*A).



  Axiom binds_dec :

    (forall a b : A, {a = b} + {a <> b}) ->

    {binds x a E} + {~ binds x a E}.



  Axiom binds_lookup :

    {a : A | binds x a E} + (forall a, ~ binds x a E).



  Axiom binds_lookup_dec :

    decidable (exists a, binds x a E).



  Axiom binds_weaken :

    binds x a (E ++ G) ->

    binds x a (E ++ F ++ G).



  Axiom binds_mid_eq :

    binds x a (F ++ (x ~ b) ++ E) ->

    uniq (F ++ (x ~ b) ++ E) ->

    a = b.



  Axiom binds_remove_mid :

    binds x a (F ++ (y ~ b) ++ G) ->

    x <> y ->

    binds x a (F ++ G).



  Axiom binds_In : forall x a (E : list (atom*A)),

    binds x a E ->

    In x (dom E).



  Axiom binds_In_inv : forall x (E : list (atom*A)),

    In x (dom E) ->

    exists a, binds x a E.



  Axiom binds_unique :

    binds x a E ->

    binds x b E ->

    uniq E ->

    a = b.



  Axiom fresh_app_l :

    uniq (F ++ E) ->

    binds x a E ->

    ~ In x (dom F).



  Axiom fresh_app_r :

    uniq (F ++ E) ->

    binds x a F ->

    ~ In x (dom E).



End BindsDerived.



Hint Resolve @nil_neq_one_mid @one_mid_neq_nil.



Hint Resolve @uniq_insert_mid @uniq_map_app_l.



Hint Immediate @uniq_remove_mid.



Hint Resolve @binds_weaken.



Hint Immediate @binds_remove_mid @binds_In.



End ENVIRONMENT.



Module Export EnvImpl : ENVIRONMENT := AssocList.Make AtomDT AtomSetImpl.

