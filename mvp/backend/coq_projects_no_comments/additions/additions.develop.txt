
Require Import Constants.
Require Import monoid.
Require Import spec.
Require Import machine.
Require Import Wf_compl.
Require Import Plus.
Require Import Mult.
Require Import Lt.
Require Import Mult_compl.
Require Import euclid.
Require Import two_power.

Lemma M3 : gencode (Call_M three).

Proof.
 refine (gencode_intro _ (seq PUSH (seq SQR (seq MUL End))) _).

 constructor 1.
 simpl in |- *; unfold power, three in |- *; intros.
 rewrite (u_neutral_r M MO).
 rewrite <- (point_assoc M MO); auto with arith.
 Qed.

Lemma M2q : forall q : nat, gencode (Call_M (two_power q)).

Proof.
 refine
  (let t := fun q : nat => gencode (Call_M (two_power q)) in
   (fix M2q (q : nat) : t q :=
      match q as x return (t x) with
      | O => gencode_intro _ End _
      | S p =>
          match M2q p with
          | gencode_intro c s => gencode_intro _ (seq SQR c) _
          end
      end)).

 constructor 1.
 unfold power in |- *; simpl in |- *.
 intros; rewrite (u_neutral_r M MO); auto with arith.
 constructor 1; auto with arith.
 intros; simpl in |- *.
 inversion_clear s.
 rewrite H.
 apply Config_inv; auto with arith.
 rewrite <- plus_n_O.
 apply a2x; auto with arith.
Qed.

Lemma C2M : forall p q : nat, gencode (Call_C p q) -> gencode (Call_M p).

Proof.
 refine
  (fun p q g => match g with
                | gencode_intro c s => gencode_intro _ c _
                end).

 constructor 1.
 inversion_clear s.
 auto with arith.
Qed.

Lemma MMC :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_C (q * p) p).

Proof.
 refine
  (fun p q g g' =>
   match g with
   | gencode_intro c s =>
       match g' with
       | gencode_intro c' s0 => gencode_intro _ (app c c') _
       end
   end).

 constructor 2.
 intros; rewrite Exec_app.
 inversion_clear s.
 rewrite H.
 inversion_clear s0.
 rewrite (H0 M MO).
 rewrite power_mult; auto with arith.
Qed.

Lemma KMC :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_C (q * p + r) p).

Proof.
 refine
  (fun p q r g g' =>
   match g with
   | gencode_intro cpr s =>
       match g' with
       | gencode_intro cq s0 =>
           gencode_intro _ (app cpr (app cq (seq MUL End))) _
       end
   end).

 inversion_clear s; inversion_clear s0.
 constructor 2.
 intros; rewrite Exec_app.
 rewrite (H M MO a).
 rewrite (Exec_app M MO); simpl in |- *; rewrite H0.
 simpl in |- *.
 apply Config_inv.
 rewrite power_eucl; auto with arith.
 auto with arith.
Qed.

Lemma MMK :
 forall p q : nat,
 gencode (Call_M p) -> gencode (Call_M q) -> gencode (Call_K (q * p) p).

Proof.
 refine
  (fun p q g g' =>
   match g with
   | gencode_intro cp s =>
       match g' with
       | gencode_intro cq s0 => gencode_intro _ (app cp (seq PUSH cq)) _
       end
   end).

 inversion_clear s; inversion_clear s0.
 constructor 3.
 intros; rewrite Exec_app. 
 rewrite H; simpl in |- *.
 rewrite H0; simpl in |- *.
 apply Config_inv; auto with arith.
 rewrite <- power_mult; auto with arith.
Qed.

Lemma KMK :
 forall p q r : nat,
 gencode (Call_K p r) -> gencode (Call_M q) -> gencode (Call_K (q * p + r) p).

Proof.
  refine
   (fun p q r g g' =>
    match g with
    | gencode_intro kpr s =>
        match g' with
        | gencode_intro mq s0 =>
            gencode_intro _
              (app kpr (seq PUSH (seq SWAP (app mq (seq MUL End))))) _
        end
    end).

 inversion_clear s; inversion_clear s0.
 constructor 3.
 intros; rewrite Exec_app.
 rewrite H; simpl in |- *.
 rewrite Exec_app.
 rewrite H0; simpl in |- *. auto with arith.
 rewrite power_eucl; auto with arith.
Qed.

