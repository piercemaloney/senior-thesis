

From mathcomp

Require Import ssreflect ssrbool seq eqtype.

From LemmaOverloading

Require Import heaps noalias.

Set Implicit Arguments.

Unset Strict Implicit.

Unset Printing Implicit Defensive.



Module NoAlias2.

Section NoAlias2Section.



Structure tagged_bool (x y : ptr) := Tag {untag : bool}.

Local Coercion untag : tagged_bool >-> bool.



Canonical Structure ineq x y := @Tag x y (x != y).



Structure form x y (s : seq ptr) :=

  Form {eq_of : tagged_bool x y;

        _ : uniq s -> untag eq_of}.



Lemma start_pf (x y : ptr) (f : Search2.form x y) : uniq f -> ineq x y.

Proof. by case: f=>s []. Qed.



Canonical Structure start x y (f : Search2.form x y) :=

  @Form x y f (ineq x y) (@start_pf x y f).



End NoAlias2Section.



Module Exports.

Canonical Structure ineq.

Canonical Structure start.

Coercion untag : tagged_bool >-> bool.

End Exports.



End NoAlias2.



Export NoAlias2.Exports.



Lemma noaliasR2 s x y (f : Scan.form s) (g : NoAlias2.form x y s) :

               def f -> NoAlias2.eq_of g.

Proof. by case: f=> [h] H /H [U _]; case: g=> [] /= ? /(_ U). Qed.



Arguments noaliasR2 [s x y f g].



Example exnc A (x1 x2 x3 x4 : ptr) (v1 v2 : A) (h1 h2 : heap) :

  def (h1 :+ x2 :-> 1 :+ h2 :+ x1 :-> v2 :+ (x3 :-> v1 :+ empty)) ->

     (x1 != x2) /\

     (x1 != x2) && (x2 != x3) && (x3 != x1) /\

     (x2 == x3) = false /\ (x1 == x2) = false /\

     (x1 != x2) && (x2 != x3) && (x1 != x4) && (x3 != x1).

Proof.

move=>D.

split.

- by apply: (noaliasR2 D).

split.

  

- by rewrite !(noaliasR2 D).

split.

  

- try by rewrite [x2 == x3](negbTE (noaliasR2 D)).

  admit.

split.

- 

  try by rewrite (negbTE (noaliasR2 D)).

  admit.

try rewrite !(negbTE (noaliasR2 D)).

admit.

Abort.



Module NoAlias3.

Section NoAlias3Section.



Structure form x (s : seq ptr) :=

  Form {y_of : ptr;

        _ : uniq s -> x != y_of}.

Local Coercion y_of : form >-> ptr.



Arguments Form : clear implicits.



Lemma noalias_pf (x y : ptr) (f : Search2.form x y) :

        uniq f -> x != y.

Proof. by move: f=>[[s]][]. Qed.



Canonical Structure start x y (f : Search2.form x y) :=

  @Form x f y (@noalias_pf x y f).



End NoAlias3Section.



Module Exports.

Canonical Structure start.

Coercion y_of : form >-> ptr.

End Exports.



End NoAlias3.



Export NoAlias3.Exports.



Lemma noaliasR s x (f : Scan.form s) (g : NoAlias3.form x s) :

               def f -> x != NoAlias3.y_of g.

Proof. by move: f g=>[[h]] H1 [[y']] /= H2; case/H1=>U _; apply: H2. Qed.



Arguments noaliasR {s x f g}.



Example exnc A (x1 x2 x3 x4 : ptr) (v1 v2 : A) (h1 h2 : heap) :

  def (h1 :+ x2 :-> 1 :+ h2 :+ x1 :-> v2 :+ (x3 :-> v1 :+ empty)) ->

     (x1 != x2) /\

     (x1 != x2) && (x2 != x3) && (x3 != x1) /\

     (x2 == x3) = false /\ (x1 == x2) = false /\

     (x1 != x2) && (x2 != x3) && (x1 != x4) && (x3 != x1).

Proof.

move=>D.

split.

- by apply: (noaliasR D).

split.

  

- by rewrite !(noaliasR D).

split.

  

- by rewrite [x2 == x3](negbTE (noaliasR D)).

split.

- 

  by rewrite (negbTE (noaliasR D)).



rewrite !(negbTE (noaliasR D)).

admit.

Abort.

