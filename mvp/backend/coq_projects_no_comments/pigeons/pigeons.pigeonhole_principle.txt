
Require Import base.
Require Import List.
Require Import Lt.          
Require Import Compare_dec. 
Require Import PeanoNat.    

Module Pigeonhole_Principle.

Parameter thing : Set.

Definition container := list thing.

Definition containers := list container.

Definition container_num_things := length (A := thing).

Definition num_containers := length (A := container).

Definition num_things (cs : containers) : nat
  := fold_right (fun c n => container_num_things c + n) 0 cs.

Definition container_ok (c : container) : Prop
  := container_num_things c <= 1.

Definition container_ok_dec 
  :  forall (c : container), {container_ok c}+{~ container_ok c}
  := fun c => le_dec (container_num_things c) 1.

Definition containers_ok (cs : containers) : Prop
  := Forall container_ok cs.

Theorem num_things_num_containers
  :  forall cs : containers,
     containers_ok cs ->
     num_things cs <= num_containers cs.
Proof
  let T cs := containers_ok cs -> num_things cs <= num_containers cs in
  list_ind T
    
    (fun _ => le_0_n 0)
    
    (list_ind
      (fun xs => forall cs, T cs -> T (xs :: cs))
      
      (fun cs
        (H  : T cs)
        (H0 : containers_ok (nil :: cs))
        => let H1
             :  num_things cs <= num_containers cs
             := H (Forall_tail nil cs H0) in
           (le_S
             (0 + num_things cs)
             (num_containers cs)
             (H1 || a <= num_containers cs @a by plus_O_n (num_things cs))))
      
      (fun x0
        => list_ind
             (fun xs => _ -> forall cs, T cs -> T ((x0 :: xs) :: cs))
             
             (fun _ cs
               (H  : T cs)
               (H0 : containers_ok ((x0 :: nil) :: cs))
               => let H1
                    :  num_things cs <= num_containers cs
                    := H (Forall_tail (x0 :: nil) cs H0) in
                  le_n_S (num_things cs) (num_containers cs) H1
                  || a <= S (num_containers cs) @a by Nat.add_1_l (num_things cs))
             
             (fun x1 xs _ _ cs
               (H  : T cs)
               (H0 : containers_ok ((x0 :: x1 :: xs) :: cs))
               => False_ind
                    (num_things ((x0 :: x1 :: xs) :: cs) <= num_containers ((x0 :: x1 :: xs) :: cs))
                    ((Nat.nle_succ_0 (length xs))
                      (le_S_n (S (length xs)) 0 ((Forall_inv H0) : S (S (length xs)) <= 1)))))).

Lemma lemma_0
  : forall cs : containers,
    num_things cs > num_containers cs ->
    ~ containers_ok cs.
Proof fun cs
       (H  : num_containers cs < num_things cs)
       (H0 : containers_ok cs)
       => le_not_lt
            (num_things cs)
            (num_containers cs)
            (num_things_num_containers cs H0)
            H.

Lemma lemma_1
  :  forall cs : containers,
     num_things cs > num_containers cs ->
     Exists (fun c : container => ~ container_ok c) cs.
Proof fun cs H
       => neg_Forall_Exists_neg container_ok_dec (lemma_0 cs H).

Theorem pigeonhole_principle
  :  forall cs : containers,
     num_things cs > num_containers cs ->
     Exists (fun c : container => container_num_things c > 1) cs.
Proof fun cs H
       => Exists_impl
            (fun c (H0 : ~ container_ok c)
              => not_le (container_num_things c) 1 H0)
            cs
            (lemma_1 cs H).

End Pigeonhole_Principle.
