

Require Import FSets FSetAVL.

Require Import Coqlib Maps Ordered Errors Lattice Kildall.

Require Import AST Op Locations LTL Linear.



Open Scope error_monad_scope.



Module DS := Dataflow_Solver(LBoolean)(NodeSetForward).



Definition reachable_aux (f: LTL.function) : option (PMap.t bool) :=

  DS.fixpoint

    (LTL.fn_code f) successors_block

    (fun pc r => r)

    f.(fn_entrypoint) true.



Definition reachable (f: LTL.function) : PMap.t bool :=

  match reachable_aux f with

  | None => PMap.init true

  | Some rs => rs

  end.



Parameter enumerate_aux: LTL.function -> PMap.t bool -> list node.



Module Nodeset := FSetAVL.Make(OrderedPositive).



Fixpoint nodeset_of_list (l: list node) (s: Nodeset.t)

                         {struct l}: res Nodeset.t :=

  match l with

  | nil => OK s

  | hd :: tl =>

      if Nodeset.mem hd s

      then Error (msg "Linearize: duplicates in enumeration")

      else nodeset_of_list tl (Nodeset.add hd s)

  end.



Definition check_reachable_aux

     (reach: PMap.t bool) (s: Nodeset.t)

     (ok: bool) (pc: node) (bb: LTL.bblock) : bool :=

  if reach!!pc then ok && Nodeset.mem pc s else ok.



Definition check_reachable

     (f: LTL.function) (reach: PMap.t bool) (s: Nodeset.t) : bool :=

  PTree.fold (check_reachable_aux reach s) f.(LTL.fn_code) true.



Definition enumerate (f: LTL.function) : res (list node) :=

  let reach := reachable f in

  let enum := enumerate_aux f reach in

  do s <- nodeset_of_list enum Nodeset.empty;

  if check_reachable f reach s

  then OK enum

  else Error (msg "Linearize: wrong enumeration").



Fixpoint starts_with (lbl: label) (k: code) {struct k} : bool :=

  match k with

  | Llabel lbl' :: k' => if peq lbl lbl' then true else starts_with lbl k'

  | _ => false

  end.



Definition add_branch (s: label) (k: code) : code :=

  if starts_with s k then k else Lgoto s :: k.



Fixpoint linearize_block (b: LTL.bblock) (k: code) : code :=

  match b with

  | nil => k

  | LTL.Lop op args res :: b' =>

      Lop op args res :: linearize_block b' k

  | LTL.Lload chunk addr args dst :: b' =>

      Lload chunk addr args dst :: linearize_block b' k

  | LTL.Lgetstack sl ofs ty dst :: b' =>

      Lgetstack sl ofs ty dst :: linearize_block b' k

  | LTL.Lsetstack src sl ofs ty :: b' =>

      Lsetstack src sl ofs ty :: linearize_block b' k

  | LTL.Lstore chunk addr args src :: b' =>

      Lstore chunk addr args src :: linearize_block b' k

  | LTL.Lcall sig ros :: b' =>

      Lcall sig ros :: linearize_block b' k

  | LTL.Ltailcall sig ros :: b' =>

      Ltailcall sig ros :: k

  | LTL.Lbuiltin ef args res :: b' =>

      Lbuiltin ef args res :: linearize_block b' k

  | LTL.Lbranch s :: b' =>

      add_branch s k

  | LTL.Lcond cond args s1 s2 :: b' =>

      if starts_with s1 k then

        Lcond (negate_condition cond) args s2 :: add_branch s1 k

      else

        Lcond cond args s1 :: add_branch s2 k

  | LTL.Ljumptable arg tbl :: b' =>

      Ljumptable arg tbl :: k

  | LTL.Lreturn :: b' =>

      Lreturn :: k

  end.



Definition linearize_node (f: LTL.function) (pc: node) (k: code) : code :=

  match f.(LTL.fn_code)!pc with

  | None => k

  | Some b => Llabel pc :: linearize_block b k

  end.



Definition linearize_body (f: LTL.function) (enum: list node) : code :=

  list_fold_right (linearize_node f) enum nil.



Definition transf_function (f: LTL.function) : res Linear.function :=

  do enum <- enumerate f;

  OK (mkfunction

       (LTL.fn_sig f)

       (LTL.fn_stacksize f)

       (add_branch (LTL.fn_entrypoint f) (linearize_body f enum))).



Definition transf_fundef (f: LTL.fundef) : res Linear.fundef :=

  AST.transf_partial_fundef transf_function f.



Definition transf_program (p: LTL.program) : res Linear.program :=

  transform_partial_program transf_fundef p.

