
Require Import Coqlib Decidableplus.
Require Import AST Machregs Locations.

Definition is_callee_save (r: mreg) : bool :=
  match r with
  | R5 | R6 | R7 => false
  | R8 | R9 => true
  | R10 | R11 | R12 | R13 | R14 | R15 | R16 | R17 => false
  | R18 | R19 | R20 | R21 | R22 | R23 | R24 | R25 | R26 | R27 => true
  | R28 | R29 | R30 => false
  | F0 | F1 | F2 | F3 | F4 | F5 | F6 | F7 => false
  | F8 | F9 => true
  | F10 | F11 | F12 | F13 | F14 | F15 | F16 | F17 => false
  | F18 | F19 | F20 | F21 | F22 | F23 | F24 | F25 | F26 | F27 => true
  | F28 | F29 | F30 | F31 => false
  end.

Definition int_caller_save_regs :=
  R5  :: R6  :: R7 ::
  R10 :: R11 :: R12 :: R13 :: R14 :: R15 :: R16 :: R17 ::
  R28 :: R29 :: R30 ::
  nil.

Definition float_caller_save_regs :=
  F0  :: F1  :: F2  :: F3  :: F4  :: F5  :: F6  :: F7  ::
  F10 :: F11 :: F12 :: F13 :: F14 :: F15 :: F16 :: F17 ::
  F28 :: F29 :: F30 :: F31 ::
  nil.

Definition int_callee_save_regs :=
  R8  :: R9  ::
  R18 :: R19 :: R20 :: R21 :: R22 :: R23 :: R24 :: R25 :: R26 :: R27 ::
  nil.

Definition float_callee_save_regs :=
  F8  :: F9  ::
  F18 :: F19 :: F20 :: F21 :: F22 :: F23 :: F24 :: F25 :: F26 :: F27 ::
  nil.

Definition destroyed_at_call :=
  List.filter (fun r => negb (is_callee_save r)) all_mregs.

Definition dummy_int_reg   := R6.    
Definition dummy_float_reg := F0 .   

Definition callee_save_type := mreg_type.
  
Definition is_float_reg (r: mreg) :=
  match r with
        | R5  | R6  | R7  | R8  | R9  | R10 | R11
  | R12 | R13 | R14 | R15 | R16 | R17 | R18 | R19
  | R20 | R21 | R22 | R23 | R24 | R25 | R26 | R27
  | R28 | R29 | R30 => false

  | F0  | F1  | F2  | F3  | F4  | F5  | F6  | F7
  | F8  | F9  | F10 | F11 | F12 | F13 | F14 | F15
  | F16 | F17 | F18 | F19 | F20 | F21 | F22 | F23
  | F24 | F25 | F26 | F27 | F28 | F29 | F30 | F31 => true
  end.

Definition loc_result (s: signature) : rpair mreg :=
  match s.(sig_res) with
  | None => One R10
  | Some (Tint | Tany32) => One R10
  | Some (Tfloat | Tsingle | Tany64) => One F10
  | Some Tlong => if Archi.ptr64 then One R10 else Twolong R11 R10
  end.

Lemma loc_result_type:
  forall sig,
  subtype (proj_sig_res sig) (typ_rpair mreg_type (loc_result sig)) = true.
Proof.
  intros. unfold proj_sig_res, loc_result, mreg_type;
  destruct (sig_res sig) as [[]|]; auto; destruct Archi.ptr64; auto.
Qed.

Lemma loc_result_caller_save:
  forall (s: signature),
  forall_rpair (fun r => is_callee_save r = false) (loc_result s).
Proof.
  intros. unfold loc_result, is_callee_save;
  destruct (sig_res s) as [[]|]; simpl; auto; destruct Archi.ptr64; simpl; auto.
Qed.

Lemma loc_result_pair:
  forall sg,
  match loc_result sg with
  | One _ => True
  | Twolong r1 r2 =>
       r1 <> r2 /\ sg.(sig_res) = Some Tlong
    /\ subtype Tint (mreg_type r1) = true /\ subtype Tint (mreg_type r2) = true 
    /\ Archi.ptr64 = false
  end.
Proof.
  intros.
  unfold loc_result; destruct (sig_res sg) as [[]|]; auto.
  unfold mreg_type; destruct Archi.ptr64; auto.
  split; auto. congruence.
Qed.

Lemma loc_result_exten:
  forall s1 s2, s1.(sig_res) = s2.(sig_res) -> loc_result s1 = loc_result s2.
Proof.
  intros. unfold loc_result. rewrite H; auto.  
Qed.

Definition int_param_regs :=
  R10 :: R11 :: R12 :: R13 :: R14 :: R15 :: R16 :: R17 :: nil.
Definition float_param_regs :=
  F10 :: F11 :: F12 :: F13 :: F14 :: F15 :: F16 :: F17 :: nil.

Definition one_arg (regs: list mreg) (rn: Z) (ofs: Z) (ty: typ)
                           (rec: Z -> Z -> list (rpair loc)) :=
  match list_nth_z regs rn with
  | Some r =>
      One(R r) :: rec (rn + 1) ofs
  | None   =>
      let ofs := align ofs (typealign ty) in
      One(S Outgoing ofs ty) :: rec rn (ofs + (if Archi.ptr64 then 2 else typesize ty))
  end.

Definition two_args (regs: list mreg) (rn: Z) (ofs: Z)
                    (rec: Z -> Z -> list (rpair loc)) :=
  let rn := align rn 2 in
  match list_nth_z regs rn, list_nth_z regs (rn + 1) with
  | Some r1, Some r2 =>
      Twolong (R r2) (R r1) :: rec (rn + 2) ofs
  | _, _ =>
      let ofs := align ofs 2 in
      Twolong (S Outgoing (ofs + 1) Tint) (S Outgoing ofs Tint) ::
      rec rn (ofs + 2)
  end.

Definition hybrid_arg (regs: list mreg) (rn: Z) (ofs: Z) (ty: typ)
                      (rec: Z -> Z -> list (rpair loc)) :=
  let rn := align rn 2 in
  match list_nth_z regs rn with
  | Some r =>
      One (R r) :: rec (rn + 2) ofs
  | None =>
      let ofs := align ofs 2 in
      One (S Outgoing ofs ty) :: rec rn (ofs + 2)
  end.

Fixpoint loc_arguments_rec (va: bool)
    (tyl: list typ) (r ofs: Z) {struct tyl} : list (rpair loc) :=
  match tyl with
  | nil => nil
  | (Tint | Tany32) as ty :: tys =>
      one_arg int_param_regs r ofs ty (loc_arguments_rec va tys)
  | Tsingle as ty :: tys =>
      one_arg float_param_regs r ofs ty (loc_arguments_rec va tys)
  | Tlong as ty :: tys =>
      if Archi.ptr64
      then one_arg int_param_regs r ofs ty (loc_arguments_rec va tys)
      else two_args int_param_regs r ofs  (loc_arguments_rec va tys)
  | (Tfloat | Tany64) as ty :: tys =>
      if va && negb Archi.ptr64
      then hybrid_arg float_param_regs r ofs ty (loc_arguments_rec va tys)
      else one_arg float_param_regs r ofs ty (loc_arguments_rec va tys)
  end.

Definition loc_arguments (s: signature) : list (rpair loc) :=
  loc_arguments_rec s.(sig_cc).(cc_vararg) s.(sig_args) 0 0.

Definition max_outgoing_1 (accu: Z) (l: loc) : Z :=
  match l with
  | S Outgoing ofs ty => Z.max accu (ofs + typesize ty)
  | _ => accu
  end.

Definition max_outgoing_2 (accu: Z) (rl: rpair loc) : Z :=
  match rl with
  | One l => max_outgoing_1 accu l
  | Twolong l1 l2 => max_outgoing_1 (max_outgoing_1 accu l1) l2
  end.

Definition size_arguments (s: signature) : Z :=
  List.fold_left max_outgoing_2 (loc_arguments s) 0.

Definition loc_argument_acceptable (l: loc) : Prop :=
  match l with
  | R r => is_callee_save r = false
  | S Outgoing ofs ty => ofs >= 0 /\ (typealign ty | ofs)
  | _ => False
  end.

Lemma loc_arguments_rec_charact:
  forall va tyl rn ofs p,
  ofs >= 0 ->
  In p (loc_arguments_rec va tyl rn ofs) -> forall_rpair loc_argument_acceptable p.
Proof.
  set (OK := fun (l: list (rpair loc)) =>
             forall p, In p l -> forall_rpair loc_argument_acceptable p).
  set (OKF := fun (f: Z -> Z -> list (rpair loc)) =>
              forall rn ofs, ofs >= 0 -> OK (f rn ofs)).
  set (OKREGS := fun (l: list mreg) => forall r, In r l -> is_callee_save r = false).
  assert (AL: forall ofs ty, ofs >= 0 -> align ofs (typealign ty) >= 0).
  { intros. 
    assert (ofs <= align ofs (typealign ty)) by (apply align_le; apply typealign_pos).
    omega. }
  assert (SK: (if Archi.ptr64 then 2 else 1) > 0).
  { destruct Archi.ptr64; omega. }
  assert (SKK: forall ty, (if Archi.ptr64 then 2 else typesize ty) > 0).
  { intros. destruct Archi.ptr64. omega. apply typesize_pos.  }
  assert (A: forall regs rn ofs ty f,
             OKREGS regs -> OKF f -> ofs >= 0 -> OK (one_arg regs rn ofs ty f)).
  { intros until f; intros OR OF OO; red; unfold one_arg; intros.
    destruct (list_nth_z regs rn) as [r|] eqn:NTH; destruct H.
  - subst p; simpl. apply OR. eapply list_nth_z_in; eauto. 
  - eapply OF; eauto. 
  - subst p; simpl. auto using align_divides, typealign_pos.
  - eapply OF; [idtac|eauto].
    generalize (AL ofs ty OO) (SKK ty); omega.
  }
  assert (B: forall regs rn ofs f,
             OKREGS regs -> OKF f -> ofs >= 0 -> OK (two_args regs rn ofs f)).
  { intros until f; intros OR OF OO; unfold two_args.
    set (rn' := align rn 2).
    set (ofs' := align ofs 2).
    assert (OO': ofs' >= 0) by (apply (AL ofs Tlong); auto).
    assert (DFL: OK (Twolong (S Outgoing (ofs' + 1) Tint) (S Outgoing ofs' Tint)
                     :: f rn' (ofs' + 2))).
    { red; simpl; intros. destruct H.
    - subst p; simpl. 
      repeat split; auto using Z.divide_1_l. omega.
    - eapply OF; [idtac|eauto]. omega.
    }
    destruct (list_nth_z regs rn') as [r1|] eqn:NTH1;
    destruct (list_nth_z regs (rn' + 1)) as [r2|] eqn:NTH2;
    try apply DFL.
    red; simpl; intros; destruct H.
  - subst p; simpl. split; apply OR; eauto using list_nth_z_in.  
  - eapply OF; [idtac|eauto]. auto.
  }
  assert (C: forall regs rn ofs ty f,
             OKREGS regs -> OKF f -> ofs >= 0 -> typealign ty = 1 -> OK (hybrid_arg regs rn ofs ty f)).
  { intros until f; intros OR OF OO OTY; unfold hybrid_arg; red; intros.
    set (rn' := align rn 2) in *.
    destruct (list_nth_z regs rn') as [r|] eqn:NTH; destruct H.
  - subst p; simpl. apply OR. eapply list_nth_z_in; eauto. 
  - eapply OF; eauto. 
  - subst p; simpl. rewrite OTY. split. apply (AL ofs Tlong OO). apply Z.divide_1_l. 
  - eapply OF; [idtac|eauto]. generalize (AL ofs Tlong OO); simpl; omega.
  }
  assert (D: OKREGS int_param_regs).
  { red. decide_goal. }
  assert (E: OKREGS float_param_regs).
  { red. decide_goal. }

  cut (forall va tyl rn ofs, ofs >= 0 -> OK (loc_arguments_rec va tyl rn ofs)).
  unfold OK. eauto.
  induction tyl as [ | ty1 tyl]; intros until ofs; intros OO; simpl.
- red; simpl; tauto.
- destruct ty1.
+  apply A; auto.
+  
  destruct (va && negb Archi.ptr64).
  apply C; auto.
  apply A; auto.
+ 
  destruct Archi.ptr64.
  apply A; auto.
  apply B; auto.
+ 
  apply A; auto.
+ 
  apply A; auto.
+ 
  destruct (va && negb Archi.ptr64).
  apply C; auto.
  apply A; auto.
Qed.

Lemma loc_arguments_acceptable:
  forall (s: signature) (p: rpair loc),
  In p (loc_arguments s) -> forall_rpair loc_argument_acceptable p.
Proof.
  unfold loc_arguments; intros. eapply loc_arguments_rec_charact; eauto. omega.
Qed.

Remark fold_max_outgoing_above:
  forall l n, fold_left max_outgoing_2 l n >= n.
Proof.
  assert (A: forall n l, max_outgoing_1 n l >= n).
  { intros; unfold max_outgoing_1. destruct l as [_ | []]; xomega. }
  induction l; simpl; intros. 
  - omega.
  - eapply Zge_trans. eauto.
    destruct a; simpl. apply A. eapply Zge_trans; eauto.
Qed.

Lemma size_arguments_above:
  forall s, size_arguments s >= 0.
Proof.
  intros. apply fold_max_outgoing_above.
Qed.

Lemma loc_arguments_bounded:
  forall (s: signature) (ofs: Z) (ty: typ),
  In (S Outgoing ofs ty) (regs_of_rpairs (loc_arguments s)) ->
  ofs + typesize ty <= size_arguments s.
Proof.
  intros until ty.
  assert (A: forall n l, n <= max_outgoing_1 n l).
  { intros; unfold max_outgoing_1. destruct l as [_ | []]; xomega. }
  assert (B: forall p n,
             In (S Outgoing ofs ty) (regs_of_rpair p) ->
             ofs + typesize ty <= max_outgoing_2 n p).
  { intros. destruct p; simpl in H; intuition; subst; simpl.
  - xomega.
  - eapply Z.le_trans. 2: apply A. xomega.
  - xomega. }
  assert (C: forall l n,
             In (S Outgoing ofs ty) (regs_of_rpairs l) ->
             ofs + typesize ty <= fold_left max_outgoing_2 l n).
  { induction l; simpl; intros.
  - contradiction.
  - rewrite in_app_iff in H. destruct H.
  + eapply Z.le_trans. eapply B; eauto. apply Z.ge_le. apply fold_max_outgoing_above.
  + apply IHl; auto.
  }
  apply C. 
Qed.

Lemma loc_arguments_main:
  loc_arguments signature_main = nil.
Proof.
  reflexivity.
Qed.
