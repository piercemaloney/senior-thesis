

Require Grammar.

Require Import Orders.

Require Export Alphabet.

Require Export List.

Require Export Syntax.



Module Type AutInit.

  

  Declare Module Gram:Grammar.T.

  Export Gram.



  Parameter noninitstate : Type.

  Declare Instance NonInitStateAlph : Alphabet noninitstate.



  Parameter initstate : Type.

  Declare Instance InitStateAlph : Alphabet initstate.



  Parameter last_symb_of_non_init_state: noninitstate -> symbol.

End AutInit.



Module Types(Import Init:AutInit).

  
  Inductive state :=

    | Init: initstate -> state

    | Ninit: noninitstate -> state.



  Program Instance StateAlph : Alphabet state :=

    { AlphabetComparable := {| compare := fun x y =>

        match x, y return comparison with

          | Init _, Ninit _ => Lt

          | Init x, Init y => compare x y

          | Ninit _, Init _ => Gt

          | Ninit x, Ninit y => compare x y

        end |};

      AlphabetFinite := {| all_list := map Init all_list ++ map Ninit all_list |} }.

  Local Obligation Tactic := intros.

  Next Obligation.

  destruct x, y; intuition; apply compare_antisym.

  Qed.

  Next Obligation.

  destruct x, y, z; intuition.

  apply (compare_trans _ i0); intuition.

  congruence.

  congruence.

  apply (compare_trans _ n0); intuition.

  Qed.

  Next Obligation.

  intros x y.

  destruct x, y; intuition; try discriminate.

  rewrite (compare_eq i i0); intuition.

  rewrite (compare_eq n n0); intuition.

  Qed.

  Next Obligation.

  apply in_or_app; destruct x; intuition;

    [left|right]; apply in_map; apply  all_list_forall.

  Qed.



  Coercion Ninit : noninitstate >-> state.

  Coercion Init : initstate >-> state.



  Inductive lookahead_action (term:terminal) :=

  | Shift_act: forall s:noninitstate,

                 T term = last_symb_of_non_init_state s -> lookahead_action term

  | Reduce_act: production -> lookahead_action term

  | Fail_act: lookahead_action term.

  Arguments Shift_act [term].

  Arguments Reduce_act [term].

  Arguments Fail_act [term].



  Inductive action :=

  | Default_reduce_act: production -> action

  | Lookahead_act : (forall term:terminal, lookahead_action term) -> action.



  Record item := {

  

    prod_item: production;



    dot_pos_item: nat;



    lookaheads_item: list terminal

  }.

End Types.



Module Type T.

  Include AutInit <+ Types.

  Module Export GramDefs := Grammar.Defs Gram.



  Parameter start_nt: initstate -> nonterminal.



  Parameter action_table:

    state -> action.

  

  Parameter goto_table: state -> forall nt:nonterminal,

    option { s:noninitstate | NT nt = last_symb_of_non_init_state s }.



  Parameter past_symb_of_non_init_state: noninitstate -> list symbol.



  Parameter past_state_of_non_init_state: noninitstate -> list (state -> bool).



  Parameter items_of_state: state -> list item.



  Parameter nullable_nterm: nonterminal -> bool.



  Parameter first_nterm: nonterminal -> list terminal.

End T.

