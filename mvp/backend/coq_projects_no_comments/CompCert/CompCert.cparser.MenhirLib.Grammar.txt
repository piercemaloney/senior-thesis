

Require Import List.

Require Import Syntax.

Require Import Alphabet.

Require Import Orders.

Require Tuples.



Module Type Alphs.

  Parameters terminal nonterminal : Type.

  Declare Instance TerminalAlph: Alphabet terminal.

  Declare Instance NonTerminalAlph: Alphabet nonterminal.

End Alphs.



Module Symbol(Import A:Alphs).



  Inductive symbol :=

    | T: terminal -> symbol

    | NT: nonterminal -> symbol.



  Program Instance SymbolAlph : Alphabet symbol :=

    { AlphabetComparable := {| compare := fun x y =>

        match x, y return comparison with

          | T _, NT _ => Gt

          | NT _, T _ => Lt

          | T x, T y => compare x y

          | NT x, NT y => compare x y

        end |};

      AlphabetFinite := {| all_list :=

        map T all_list++map NT all_list |} }.

  Next Obligation.

  destruct x; destruct y; intuition; apply compare_antisym.

  Qed.

  Next Obligation.

  destruct x; destruct y; destruct z; intuition; try discriminate.

  apply (compare_trans _ t0); intuition.

  apply (compare_trans _ n0); intuition.

  Qed.

  Next Obligation.

  intros x y.

  destruct x; destruct y; try discriminate; intros.

  rewrite (compare_eq t t0); intuition.

  rewrite (compare_eq n n0); intuition.

  Qed.

  Next Obligation.

  rewrite in_app_iff.

  destruct x; [left | right]; apply in_map; apply all_list_forall.

  Qed.



End Symbol.



Module Type T.

  Export Tuples.



  Include Alphs <+ Symbol.



  Parameter symbol_semantic_type: symbol -> Type.



  Parameter production : Type.

  Declare Instance ProductionAlph : Alphabet production.



  Parameter prod_lhs: production -> nonterminal.

  Parameter prod_rhs_rev: production -> list symbol.

  Parameter prod_action:

    forall p:production,

      arrows_left

        (map symbol_semantic_type (rev (prod_rhs_rev p)))

        (symbol_semantic_type (NT (prod_lhs p))).



End T.



Module Defs(Import G:T).



  Definition token := {t:terminal & symbol_semantic_type (T t)}.



  Inductive parse_tree:

    forall (head_symbol:symbol) (word:list token)

      (semantic_value:symbol_semantic_type head_symbol), Type :=



  | Terminal_pt:

    forall (t:terminal) (sem:symbol_semantic_type (T t)),

      parse_tree (T t)

      [existT (fun t => symbol_semantic_type (T t)) t sem] sem



  | Non_terminal_pt:

    forall {p:production} {word:list token}

      {semantic_values:tuple (map symbol_semantic_type (rev (prod_rhs_rev p)))},

      parse_tree_list (rev (prod_rhs_rev p)) word semantic_values ->

      parse_tree (NT (prod_lhs p)) word (uncurry (prod_action p) semantic_values)



  with parse_tree_list:

    forall (head_symbols:list symbol) (word:list token)

      (semantic_values:tuple (map symbol_semantic_type head_symbols)),

      Type :=



  | Nil_ptl: parse_tree_list [] [] ()



  | Cons_ptl:

  

    forall {head_symbolt:symbol} {wordt:list token}

      {semantic_valuet:symbol_semantic_type head_symbolt},

      parse_tree head_symbolt wordt semantic_valuet ->



    forall {head_symbolsq:list symbol} {wordq:list token}

      {semantic_valuesq:tuple (map symbol_semantic_type head_symbolsq)},

      parse_tree_list head_symbolsq wordq semantic_valuesq ->



      parse_tree_list

        (head_symbolt::head_symbolsq)

        (wordt++wordq)

        (semantic_valuet, semantic_valuesq).



  Fixpoint pt_size {head_symbol word sem} (tree:parse_tree head_symbol word sem) :=

    match tree with

      | Terminal_pt _ _ => 1

      | Non_terminal_pt l => S (ptl_size l)

    end

  with ptl_size {head_symbols word sems} (tree:parse_tree_list head_symbols word sems) :=

    match tree with

      | Nil_ptl => 0

      | Cons_ptl t q =>

         pt_size t + ptl_size q

    end.

End Defs.

