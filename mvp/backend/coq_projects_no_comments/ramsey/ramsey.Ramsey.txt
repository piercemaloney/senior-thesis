

Require Import Lt.

Require Import Plus.



Definition increasing (f : nat -> nat) :=

  forall x y : nat, x < y -> f x < f y.



Lemma compose_increasing :

 forall f g : nat -> nat,

 increasing f -> increasing g -> increasing (fun x : nat => f (g x)).

unfold increasing in |- *; auto with arith.

Qed.

Hint Resolve compose_increasing.



Lemma increasingbystep :

 forall f : nat -> nat, (forall n : nat, f n < f (S n)) -> increasing f.

unfold increasing in |- *; intros f i x y ltxy.

elim ltxy; trivial with arith.

intros; apply lt_trans with (f m); auto with arith.

Qed.



Definition full (A : nat -> Prop) (Y : (nat -> nat) -> nat) :=

  forall f : nat -> nat, increasing f -> A (f (Y f)).



Definition enumerate (Y : (nat -> nat) -> nat) :=

  (fix F (x : nat) : nat :=

     match x return nat with

     | O => 

           Y (fun n : nat => n)

          

     | S y => Y (fun n : nat => n + S (F y)) + S (F y)

     end).



Lemma increasing_enumerate :

 forall Y : (nat -> nat) -> nat, increasing (enumerate Y).

intro; apply increasingbystep; unfold enumerate in |- *; auto with arith.

Qed.



Section dimension_one.



Variable A : nat -> Prop.

Variable YA : (nat -> nat) -> nat.



Definition FYA (x n : nat) := n + S (enumerate YA x).



Lemma increasing_FYA : forall x : nat, increasing (FYA x).

unfold increasing, FYA in |- *.

intros; apply plus_lt_compat_r; trivial with arith.

Qed.

Hint Resolve increasing_FYA.



Lemma enumerate_YA : full A YA -> forall x : nat, A (enumerate YA x).

intro YAfull; unfold enumerate in |- *; simple induction x.

apply (YAfull (fun n : nat => n)).

unfold increasing in |- *; trivial with arith.

intros y H.

change (A (FYA y (YA (FYA y)))) in |- *.

apply YAfull; auto with arith.

Qed.



Variable B : nat -> Prop.

Variable YB : (nat -> nat) -> nat.



Lemma YB_enumerate_YA : full B YB -> B (enumerate YA (YB (enumerate YA))).

intro YBfull.

apply YBfull.

apply increasing_enumerate.

Qed.



Lemma pre_Ramsey1 :

 full A YA ->

 full B YB ->

 A (enumerate YA (YB (enumerate YA))) /\ B (enumerate YA (YB (enumerate YA))).

intros YAfull YBfull; split.

apply enumerate_YA; trivial with arith.

apply YB_enumerate_YA; trivial with arith.

Qed.



End dimension_one.



Definition inter (A B : nat -> Prop) (n : nat) := A n /\ B n.



Definition combine (YA YB : (nat -> nat) -> nat) (f : nat -> nat) :=

  enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x)))

    ((fun g : nat -> nat => YB (fun x : nat => f (g x)))

       (enumerate (fun g : nat -> nat => YA (fun x : nat => f (g x))))).



Theorem Ramsey1 :

 forall (A B : nat -> Prop) (YA YB : (nat -> nat) -> nat),

 full A YA -> full B YB -> full (inter A B) (combine YA YB).

unfold full, inter, combine in |- *; intros A B YA YB FAYA FBYB f If.

apply

 (pre_Ramsey1 (fun x : nat => A (f x))

    (fun g : nat -> nat => YA (fun x : nat => f (g x)))

    (fun x : nat => B (f x))

    (fun g : nat -> nat => YB (fun x : nat => f (g x)))); 

 unfold full in |- *; intros g Ig.

apply (FAYA (fun x : nat => f (g x))); auto with arith.

apply (FBYB (fun x : nat => f (g x))); auto with arith.

Qed.
