
Require Import Ensf_types.
Require Import Ensf_dans.
Require Import Ensf_union.
Require Import Ensf_couple.

Fixpoint singleprod (x : Elt) (A : Ensf) {struct A} : Ensf :=
  match A with
  | empty => empty
  | add y e => add (couple x y) (singleprod x e)
  end.

Fixpoint prodcart (A : Ensf) : Ensf -> Ensf :=
  fun B : Ensf =>
  match A with
  | empty => empty
  | add x e => union (singleprod x B) (prodcart e B)
  end.

Lemma dans_singleprod :
 forall (x y x0 : Elt) (b : Ensf),
 dans (couple x y) (singleprod x0 b) -> x = x0 :>Elt /\ dans y b.
intros x y x0.
simple induction b.
simpl in |- *.
intro.
apply (dans_empty_imp_P (couple x y)); auto.

intros a b0 H.
simpl in |- *.
intro.
cut (couple x0 a = couple x y :>Elt \/ dans (couple x y) (singleprod x0 b0)).
2: apply dans_add; auto.
intro H1; elim H1; clear H1.
intro H1.
injection H1; intros.
split; auto.
rewrite H2; auto.

intro.
cut (x = x0 :>Elt /\ dans y b0); auto.
intro H2; elim H2; clear H2.
intros.
split; auto.
Qed.

Lemma coupl2 :
 forall (x y : Elt) (a b : Ensf),
 dans (couple x y) (prodcart a b) -> dans x a /\ dans y b.
intros x y.
simple induction a.
intro b.
simpl in |- *.
intro.
apply (dans_empty_imp_P (couple x y)); auto.

intros a0 b H b0.
simpl in |- *.
intro.
cut
 (dans (couple x y) (singleprod a0 b0) \/ dans (couple x y) (prodcart b b0)).
2: apply dans_union; auto.
intro H1; elim H1; clear H1.
intro H1.
cut (x = a0 :>Elt /\ dans y b0).
2: apply dans_singleprod; auto.
intro H2; elim H2; clear H2.
intros.
rewrite H2.
split; auto.
intro.
cut (dans x b /\ dans y b0); auto.
intro H2; elim H2; clear H2.
intros.
split; auto.
Qed.

Lemma dans_single :
 forall (x y : Elt) (a : Ensf),
 dans y a -> dans (couple x y) (singleprod x a).
intros x y.
simple induction a.
intro.
apply (dans_empty_imp_P y); auto.
intros a0 b H H1.
cut (a0 = y :>Elt \/ dans y b).
2: apply dans_add; auto.
intro H2; elim H2; clear H2.
intro.
simpl in |- *.
rewrite H0; auto.
simpl in |- *; auto.
Qed.

Lemma coupl2_inv :
 forall (x y : Elt) (a b : Ensf),
 dans x a -> dans y b -> dans (couple x y) (prodcart a b).
intros x y.
simple induction a.
intros b H.
apply (dans_empty_imp_P x); auto.

intros a0 b H b0 H0.
cut (a0 = x :>Elt \/ dans x b).
2: apply dans_add; auto.
simpl in |- *.
intro H1; elim H1; clear H1.
intros H1 H2.
apply dans_union_inv.
left.
rewrite H1.
apply dans_single; auto.
intros H1 H2.
apply dans_union_inv.
right.
auto.
Qed.
Hint Resolve coupl2_inv.

Lemma dans_singleprod2 :
 forall (x x0 : Elt) (b : Ensf),
 dans x (singleprod x0 b) -> exists y : Elt, x = couple x0 y /\ dans y b.
intros x x0.
simple induction b.
intro.
apply (dans_empty_imp_P x); auto.
intros a b0 H.
simpl in |- *.
intro.
cut (couple x0 a = x :>Elt \/ dans x (singleprod x0 b0)).
2: apply dans_add; auto.
intro H1; elim H1; clear H1.
intro.
exists a; auto.
intro.
cut (exists y : Elt, x = couple x0 y /\ dans y b0); auto.
intro H2; elim H2; clear H2.
intros.
exists x1.
elim H2; clear H2.
intros.
split; auto.
Qed.

Lemma coupl3 :
 forall (a b : Ensf) (x : Elt),
 dans x (prodcart a b) ->
 exists x1 : Elt,
   (exists x2 : Elt, dans x1 a /\ dans x2 b /\ x = couple x1 x2).
simple induction a.
intro b.
simpl in |- *.
intros x H.
apply (dans_empty_imp_P x); auto.

intros a0 b H b0 x.
simpl in |- *.
intro.
cut (dans x (singleprod a0 b0) \/ dans x (prodcart b b0)); auto.
intro H1; elim H1; clear H1.
intro.
cut (exists y : Elt, x = couple a0 y /\ dans y b0).
2: apply dans_singleprod2; auto.
intro H2; elim H2; clear H2.
intros x0 H2.
exists a0.
exists x0.
elim H2; clear H2.
intros.
split; auto.
intro.
cut
 (exists x1 : Elt,
    (exists x2 : Elt, dans x1 b /\ dans x2 b0 /\ x = couple x1 x2));
 auto.
intro H2; elim H2; clear H2.
intros x0 H2; elim H2; clear H2.
intros x1 H2; elim H2; clear H2.
intros H2 H3; elim H3; clear H3.
intros H4 H5.
exists x0.
exists x1.
split; auto.
Qed.