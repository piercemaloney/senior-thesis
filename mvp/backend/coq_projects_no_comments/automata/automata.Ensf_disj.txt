
Require Import Ensf_types.
Require Import Ensf_dans.
Require Import Ensf_union.
Require Import Ensf_couple.
Require Import Ensf_inclus.
Require Import Ensf_map.

Definition injgauche (e : Elt) : Elt := couple e zero.

Definition injdroite (e : Elt) : Elt := couple e un.

Definition union_disj (e f : Ensf) : Ensf :=
  union (map injgauche e) (map injdroite f).

Lemma dans_map_injg :
 forall (e : Ensf) (x : Elt), dans x (map injgauche e) -> dans (first x) e.
intros.
cut (exists y : Elt, dans y e /\ x = injgauche y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht.
intros.  
unfold injgauche in H1.
replace (first x) with y; auto.
symmetry  in |- *.
replace y with (first (couple y zero)); auto.
apply (f_equal (A:=Elt) (B:=Elt)); auto.
Qed.

Lemma dans_map_injd :
 forall (e : Ensf) (x : Elt), dans x (map injdroite e) -> dans (first x) e.
intros.
cut (exists y : Elt, dans y e /\ x = injdroite y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht.
intros.  
unfold injdroite in H1.
replace (first x) with y; auto.
symmetry  in |- *.
replace y with (first (couple y un)); auto.
apply (f_equal (A:=Elt) (B:=Elt)); auto.
Qed.

Lemma absurd_injg_injd :
 forall (x : Elt) (e f : Ensf),
 dans x (map injgauche e) -> ~ dans x (map injdroite f).
intros.
cut (exists y : Elt, dans y e /\ x = injgauche y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht.
intros.  
red in |- *.
intro.
cut (exists y' : Elt, dans y' f /\ x = injdroite y' :>Elt).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y' Ht; elim Ht; clear Ht.
intros.  
absurd (zero = un :>Elt).
unfold zero in |- *.
unfold un in |- *.
discriminate.

unfold injdroite in H4.
unfold injgauche in H1.
replace zero with (second (couple y zero)); auto.
replace un with (second (couple y' un)); auto.
rewrite <- H4.
rewrite <- H1.
auto.
Qed.

Lemma union_disj1 :
 forall (x : Elt) (a b : Ensf),
 dans x (union_disj a b) ->
 (exists y : Elt, dans y a /\ x = injgauche y :>Elt) \/
 (exists y : Elt, dans y b /\ x = injdroite y :>Elt).
unfold union_disj in |- *.
intros.
cut (dans x (map injgauche a) \/ dans x (map injdroite b)).
2: auto.
intro H0; elim H0; clear H0.
intro; left.
apply dans_map; auto.
intro; right.
apply dans_map; auto.
Qed.

Lemma union_disj_d :
 forall (x : Elt) (a b : Ensf),
 dans x b -> dans (injdroite x) (union_disj a b).
intros.
unfold union_disj in |- *.
apply union_d.
apply dans_map_inv.
auto.
Qed.

Lemma union_disj_g :
 forall (x : Elt) (a b : Ensf),
 dans x a -> dans (injgauche x) (union_disj a b).
intros.
unfold union_disj in |- *.
apply union_g.
apply dans_map_inv.
auto.
Qed.

Lemma inclus_union_disj :
 forall a b c d : Ensf,
 inclus a c -> inclus b d -> inclus (union_disj a b) (union_disj c d).
unfold inclus in |- *.
intros.
unfold union_disj in H1.
cut (dans x (map injgauche a) \/ dans x (map injdroite b)); auto.
intro Ht; elim Ht; clear Ht.

intro.
cut (exists y : Elt, dans y a /\ x = injgauche y).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht; intros H3 H4.
cut (dans y c); auto.
intro.
unfold union_disj in |- *.
apply union_g.
rewrite H4.
apply dans_map_inv; auto.

intro.
cut (exists y : Elt, dans y b /\ x = injdroite y :>Elt).
2: apply dans_map; auto.
intro Ht; elim Ht; clear Ht.
intros y Ht; elim Ht; clear Ht; intros H3 H4.
cut (dans y d); auto.
intro.
unfold union_disj in |- *.
apply union_d.
rewrite H4.
apply dans_map_inv; auto.
Qed.

Lemma pair_equal :
 forall (A B : Set) (x x' : A) (y y' : B),
 x = x' :>A -> y = y' :>B -> pair x y = pair x' y' :>A * B.
intros A B x x' y y' X Y.
rewrite X.
rewrite Y.
apply refl_equal.
Qed.
Hint Resolve pair_equal.