
Require Import Ensf_types.

Inductive dans : Elt -> Ensf -> Prop :=
  | dans_add1 : forall (x : Elt) (e : Ensf), dans x (add x e)
  | dans_add2 : forall (x y : Elt) (e : Ensf), dans x e -> dans x (add y e).
Hint Resolve dans_add1 dans_add2.
 
Lemma dans_add :
 forall (x y : Elt) (e : Ensf), dans x (add y e) -> y = x \/ dans x e.
intros x y e H.
simple inversion H.
left.
injection H1.
intros.
apply trans_equal with x0; [ auto | assumption ].

intro.
right.
injection H2.
intros.
rewrite <- H3.
rewrite <- H1.
assumption.
Qed. 
 
Lemma dans_add_contr :
 forall (x y : Elt) (e : Ensf), y <> x -> ~ dans x e -> ~ dans x (add y e).
intros; red in |- *; intro.
absurd (y = x \/ dans x e).
2: apply dans_add; auto.
red in |- *.
intro.
elim H2; auto.
Qed.
 
Lemma empty_empty : forall E : Elt, ~ dans E empty.
unfold not in |- *; intros E H.
simple inversion H; [ discriminate H1 | discriminate H2 ].
Qed.
Hint Resolve empty_empty.
 
Lemma dans_empty_imp_P : forall (x : Elt) (P : Prop), dans x empty -> P.
intros.
elimtype False.
cut (~ dans x empty); auto.
Qed.
 
Lemma singl2 : forall x : Elt, dans x (singleton x).
unfold singleton in |- *.
auto.
Qed.
Hint Resolve singl2.

Unset Structural Injection.

Lemma singl2_inv : forall x e : Elt, dans x (singleton e) -> x = e :>Elt.
unfold singleton in |- *.
intros x e H.
simple inversion H.
injection H1; intros.
rewrite <- H0; assumption.
injection H2; intros.
apply dans_empty_imp_P with x0.
rewrite <- H0; assumption.
Qed.
Hint Resolve singl2_inv.
