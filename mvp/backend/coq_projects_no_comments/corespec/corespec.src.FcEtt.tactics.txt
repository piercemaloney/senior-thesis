Require Import FcEtt.imports.



Require Import FcEtt.ett_inf.



Inductive Dyn : Type := dyn : forall {T : Type}, T -> Dyn.



Ltac unwrap_dyn d :=

  match d with

    | dyn ?v => v

  end.



Ltac split_hyp :=

  repeat (

      match goal with

        | [ H : _ /\ _ |- _ ] => destruct H

      end).



Ltac rewrite_and_clear eq :=

  first [rewrite -> eq | rewrite <- eq]; clear eq.



Ltac try_rewrite_and_clear eq :=

  first [rewrite -> ! eq | rewrite <- ! eq | idtac]; clear eq.



Ltac try_rewrite_and_clear_f eq :=

  first [rewrite ! eq | idtac]; clear eq.



Ltac find_eq_rew_clear :=

  match goal with

    | [ eq : forall t1,                _ = _ |- _ ] => rewrite_and_clear eq

    | [ eq : forall t1 t2,             _ = _ |- _ ] => rewrite_and_clear eq

    | [ eq : forall t1 t2 t3,          _ = _ |- _ ] => rewrite_and_clear eq

    | [ eq : forall t1 t2 t3 t4,       _ = _ |- _ ] => rewrite_and_clear eq

    | [ eq : forall t1 t2 t3 t4 t5,    _ = _ |- _ ] => rewrite_and_clear eq

    | [ eq : forall t1 t2 t3 t4 t5 t6, _ = _ |- _ ] => rewrite_and_clear eq

  end.



Ltac subst_forall :=

  repeat find_eq_rew_clear.



Tactic Notation "basic_nosolve_n"     int_or_var(n) :=

  intuition (subst; eauto n).

Tactic Notation "basic_nosolve_n'"    int_or_var(n) :=

  intuition (subst; simpl in *; subst; eauto n; try done).

Tactic Notation "basic_nosolve_fo_n"  int_or_var(n) :=

  firstorder (subst; eauto n).

Tactic Notation "basic_nosolve_fo_n'" int_or_var(n) :=

  firstorder (subst_forall; simpl in *; subst_forall; eauto n; try done).



Tactic Notation "basic_solve_n"     int_or_var(n) := try solve [basic_nosolve_n     n].

Tactic Notation "basic_solve_n'"    int_or_var(n) := try solve [basic_nosolve_n'    n].

Tactic Notation "basic_solve_fo_n"  int_or_var(n) := try solve [basic_nosolve_fo_n  n].

Tactic Notation "basic_solve_fo_n'" int_or_var(n) := try solve [basic_nosolve_fo_n' n].



Ltac basic_nosolve     := basic_nosolve_n     5.

Ltac basic_nosolve'    := basic_nosolve_n'    5.

Ltac basic_nosolve_fo  := basic_nosolve_fo_n  5.

Ltac basic_nosolve_fo' := basic_nosolve_fo_n' 5.



Ltac basic_solve     := try solve [basic_nosolve].

Ltac basic_solve'    := try solve [basic_nosolve'].

Ltac basic_solve_fo  := try solve [basic_nosolve_fo].

Ltac basic_solve_fo' := try solve [basic_nosolve_fo'].



Ltac solve_by_inv_hyp_about A :=

  multimatch goal with

    | [ H : context [?A] |- _ ] => solve [inversion H; basic_solve]

  end.



Ltac revert_all :=

  repeat match goal with

      | [ H : _ |- _ ] => revert H

    end.



Ltac revert_all_with t :=

  repeat match goal with

      | [ H : _ |- _ ] => try t H; revert dependent H

    end.



Ltac intro_all_with t :=

  repeat

    (let x := fresh in intro x; try (t x)).



Ltac disjunction_assumption :=

  match goal with

    | [H : ?P |- ?P]     => exact H

    | [H : ?P |- ?P ∨ _] => left; exact H

    | [       |- _  ∨ _] => right; disjunction_assumption

  end.



Ltac invert_and_clear H := inversion H; clear H.



Definition wrap : forall P : Prop, P -> P * True := fun _ p => (p, I).

Ltac wrap_hyp H := apply wrap in H.



Lemma AnnCtx_uniq G : AnnCtx G -> uniq G.

Proof. by elim=> * //=; apply uniq_cons. Qed.



Ltac prove_this stmt name :=



  match stmt with

    | uniq ?G =>

      match goal with

      | [ HG : AnnCtx G |- _ ] =>

        

        move: (AnnCtx_uniq HG) => name 

      end

    end.



Ltac find_invertible_hyps :=

  repeat (

  match goal with

    

    | [ H : AnnIso _ _ (g_EqCong _ _ _) _ _ |- _ ] => invert_and_clear H

    

    | [ H : AnnIso _ _ (_ _) _ _ |- _ ] => inversion H; wrap_hyp H



    | [ H : AnnTyping _ (_ _) _ |- _ ] => inversion H; wrap_hyp H



  end).



Ltac pair_coupled_hyps :=

  repeat match goal with

    | [ H1 : binds ?T _ ?G, H2 : binds ?T _ ?G |- _ ] =>

      let unG := fresh "uniq" G in

      prove_this (uniq G) unG;

      move: (binds_unique _ _ _ _ _ H1 H2 unG) => ?; wrap_hyp H2



  end.



Ltac pcess_hyps :=

  find_invertible_hyps;



  pair_coupled_hyps;



  repeat (

    match goal with

      | [ H : _ /\ _       |- _ ] => destruct H



      | [ H : exists x, _  |- _ ] => destruct H



      | [ H : _ * True  |- _      ] => destruct H as [H _]



      | [ H :                   ?A = ?A |- _ ] => clear H

      | [ H : forall _,         ?A = ?A |- _ ] => clear H

      | [ H : forall _ _,       ?A = ?A |- _ ] => clear H

      | [ H : forall _ _ _,     ?A = ?A |- _ ] => clear H

      | [ H : forall _ _ _ _,   ?A = ?A |- _ ] => clear H

      | [ H : forall _ _ _ _ _, ?A = ?A |- _ ] => clear H

      

      | [ H : ?P |- _ ] => clear H; let x := fresh in assert (x : P) by solve [assumption | trivial]; clear x



      | [ H : ?C _                         = ?C _                         |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _                       = ?C _ _                       |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _                     = ?C _ _ _                     |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _                   = ?C _ _ _ _                   |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _                 = ?C _ _ _ _ _                 |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   |- _ ] => injection H; clear H; intros; try subst

      | [ H : ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ |- _ ] => injection H; clear H; intros; try subst



    end).



Ltac pre :=

  repeat (intros; try split);

  

  unfold "~" in *.



Ltac pre' :=

  repeat (intros; try split);

  pcess_hyps;

  unfold "~" in *.



Ltac prove_eq_same_head :=

  solve [subst; reflexivity | f_equal; basic_solve].



Ltac break_union :=

  repeat match goal with

  

    | [ H : ~ ?x `in` union _ _ |- _ ] =>

        move: (notin_union_1 _ _ _ H) (notin_union_2 _ _ _ H) => ??; clear H

  end.



Ltac fsetdec_fast := solve [break_union; basic_solve_n 3].



Ltac autofresh_fixed x :=

   repeat match goal with

     | [ H : ∀ x' : atom, x' `notin` ?L -> _ |- _] =>

       let xL := fresh x L in

       (have xL : x `notin` L by first [fsetdec_fast | fsetdec]);

       specialize (H x xL);

       clear xL 

   end.



 Ltac autofresh :=

   let x := fresh "x" in

   pick fresh x;

   autofresh_fixed x.



Ltac autotype :=

  pcess_hyps;



  repeat match goal with

    | [ |- _ /\ _ ] => split



    | [ |- _ `in` _   ] => try fsetdec_fast; first [fsetdec | fail 2] 

    | [ |- ¬ _ `in` _ ] => try fsetdec_fast; first [fsetdec | fail 2]



    | [ |- _ [=] _  ] => first [fsetdec | fail 2]

    | [ |- _ [<=] _ ] => first [fsetdec | fail 2]



    | [ |- ?C _                         = ?C _                         ] => prove_eq_same_head

    | [ |- ?C _ _                       = ?C _ _                       ] => prove_eq_same_head

    | [ |- ?C _ _ _                     = ?C _ _ _                     ] => prove_eq_same_head

    | [ |- ?C _ _ _ _                   = ?C _ _ _ _                   ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _                 = ?C _ _ _ _ _                 ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _               = ?C _ _ _ _ _ _               ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _             = ?C _ _ _ _ _ _ _             ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _ _           = ?C _ _ _ _ _ _ _ _           ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _ _ _         = ?C _ _ _ _ _ _ _ _ _         ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _ _ _ _       = ?C _ _ _ _ _ _ _ _ _ _       ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _     = ?C _ _ _ _ _ _ _ _ _ _ _     ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _   = ?C _ _ _ _ _ _ _ _ _ _ _ _   ] => prove_eq_same_head

    | [ |- ?C _ _ _ _ _ _ _ _ _ _ _ _ _ = ?C _ _ _ _ _ _ _ _ _ _ _ _ _ ] => prove_eq_same_head



    | _ => try done; basic_solve; fail 0



    | [ |- ex _ ] => eexists



    | [ |- AnnTyping _   (_ _) _   ] => econstructor; pcess_hyps

    | [ |- AnnDefEq  _ _ (_ _) _ _ ] => econstructor; pcess_hyps

    | [ |- AnnIso    _ _ (_ _) _ _ ] => econstructor; pcess_hyps

  end.



Ltac ok := autotype.

Ltac depind x := dependent induction x.

