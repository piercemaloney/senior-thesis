

Require Export Fill_defs.



Fixpoint di (st : nat) : BV -> BV -> BV -> Memo -> BV :=

  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>

  match st return BV with

  | O => di0

  | S t =>

      match IsNull (cx t di0 cx0 al0 mem0) return BV with

      | true => di t di0 cx0 al0 mem0

      | false => BV_increment (di t di0 cx0 al0 mem0)

      end

  end

 

 with cx (st : nat) : BV -> BV -> BV -> Memo -> BV :=

  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>

  match st return BV with

  | O => cx0

  | S t =>

      match IsNull (cx t di0 cx0 al0 mem0) return BV with

      | true => cx t di0 cx0 al0 mem0

      | false => BV_decrement (cx t di0 cx0 al0 mem0)

      end

  end

 

 with al (st : nat) : BV -> BV -> BV -> Memo -> BV :=

  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>

  match st return BV with

  | O => al0

  | S t =>

      match IsNull (cx t di0 cx0 al0 mem0) return BV with

      | true => al t di0 cx0 al0 mem0

      | false => al t di0 cx0 al0 mem0

      end

  end

 

 with mem (st : nat) : BV -> BV -> BV -> Memo -> Memo :=

  fun (di0 cx0 al0 : BV) (mem0 : Memo) =>

  match st return Memo with

  | O => mem0

  | S t =>

      match IsNull (cx t di0 cx0 al0 mem0) return Memo with

      | true => mem t di0 cx0 al0 mem0

      | false =>

          MemoWrite (mem t di0 cx0 al0 mem0)

            (BV_to_nat (di t di0 cx0 al0 mem0)) (al t di0 cx0 al0 mem0)

      end

  end.



Lemma di_t :

 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),

 di (S t) di0 cx0 al0 mem0 =

 match IsNull (cx t di0 cx0 al0 mem0) return BV with

 | true => di t di0 cx0 al0 mem0

 | false => BV_increment (di t di0 cx0 al0 mem0)

 end.

auto.

Qed.



Lemma cx_t :

 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),

 cx (S t) di0 cx0 al0 mem0 =

 match IsNull (cx t di0 cx0 al0 mem0) return BV with

 | true => cx t di0 cx0 al0 mem0

 | false => BV_decrement (cx t di0 cx0 al0 mem0)

 end.

auto.

Qed.



Lemma al_t :

 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),

 al (S t) di0 cx0 al0 mem0 =

 match IsNull (cx t di0 cx0 al0 mem0) return BV with

 | true => al t di0 cx0 al0 mem0

 | false => al t di0 cx0 al0 mem0

 end.

auto.

Qed.



Lemma al_constant :

 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),

 al t di0 cx0 al0 mem0 = al0.

simple induction t. auto.

intros. rewrite al_t. elim (IsNull (cx n di0 cx0 al0 mem0)). apply H. apply H.

Qed.



Lemma mem_t :

 forall (t : nat) (di0 cx0 al0 : BV) (mem0 : Memo),

 mem (S t) di0 cx0 al0 mem0 =

 match IsNull (cx t di0 cx0 al0 mem0) return Memo with

 | true => mem t di0 cx0 al0 mem0

 | false =>

     MemoWrite (mem t di0 cx0 al0 mem0) (BV_to_nat (di t di0 cx0 al0 mem0))

       (al t di0 cx0 al0 mem0)

 end.

auto.

Qed.



Lemma length_di :

 forall t : nat, lengthbv (di t di_init cx_init al_init mem_init) = a_size.

simple induction t. simpl in |- *. exact di_initsize.

intros.

rewrite di_t. elim (IsNull (cx n di_init cx_init al_init mem_init)). exact H.

rewrite length_BV_increment. exact H.

Qed.



Lemma length_cx :

 forall t : nat, lengthbv (cx t di_init cx_init al_init mem_init) = a_size.

simple induction t. simpl in |- *. exact cx_initsize.

intros.

rewrite cx_t. elim (IsNull (cx n di_init cx_init al_init mem_init)). exact H.

rewrite length_BV_decrement. exact H.

Qed.



Lemma length_al :

 forall t : nat, lengthbv (al t di_init cx_init al_init mem_init) = d_size.

intro. rewrite al_constant. exact al_initsize.

Qed.
