

Require Import IZF_logic.

Require Import IZF_base.

Require Import IZF_nat.



Definition unit : Typ1 := forall X : Typ0, X -> X.

Definition id : unit := fun X x => x.

Definition ZERO : Rel unit := fun _ _ => bot.



Lemma ZERO_elim :

 forall (X : Typ1) (A : Rel X) (a : X), ELT X A a unit ZERO id -> bot.



Proof.

intros X A a H; apply H.

intros b' H1 H2; exact H1.

Qed.



Definition SUCC (X : Typ1) (A : Rel X) (a : X) : Rel (opt X) :=

  fun z' z =>

  forall E : Prop,

  (forall x x' : X,

   eq (opt X) z (some X x) -> eq (opt X) z' (some X x') -> A x' x -> E) ->

  (forall x' : X,

   eq (opt X) z (none X) -> eq (opt X) z' (some X x') -> A x' a -> E) ->

  (eq (opt X) z (none X) -> eq (opt X) z' (some X a) -> E) -> E.



Lemma SUCC_in :

 forall (X : Typ1) (A : Rel X) (a x x' : X),

 A x' x -> SUCC X A a (some X x') (some X x).



Proof

  fun X A a x x' H E H1 _ _ =>

  H1 x x' (eq_refl (opt X) (some X x)) (eq_refl (opt X) (some X x')) H.



Lemma SUCC_rt1 :

 forall (X : Typ1) (A : Rel X) (a x' : X),

 A x' a -> SUCC X A a (some X x') (none X).



Proof

  fun X A a x' H E _ H2 _ =>

  H2 x' (eq_refl (opt X) (none X)) (eq_refl (opt X) (some X x')) H.



Lemma SUCC_rt2 :

 forall (X : Typ1) (A : Rel X) (a : X), SUCC X A a (some X a) (none X).



Proof

  fun X A a E _ _ H3 =>

  H3 (eq_refl (opt X) (none X)) (eq_refl (opt X) (some X a)).



Lemma SUCC_deloc :

 forall (X : Typ1) (A : Rel X) (a : X),

 deloc X A (opt X) (SUCC X A a) (some X).



Proof.

intros X A a; unfold deloc in |- *; apply and_intro.



intros; apply SUCC_in; assumption.



intros x y' H; apply H; clear H.



intros x0 x' H1 H2 H3; apply ex2_intro with x'.

apply (eq_sym _ _ _ (eq_some_some X x x0 H1)); assumption.

assumption.



intros x' H1 H2 H3; apply (eq_some_none _ _ H1).



intros H1 H2; apply (eq_some_none _ _ H1).

Qed.



Lemma SUCC_eqv :

 forall (X : Typ1) (A : Rel X) (a x : X),

 EQV X A x (opt X) (SUCC X A a) (some X x).



Proof.

intros X A a x; apply EQV_deloc; apply SUCC_deloc.

Qed.



Lemma SUCC_intro1 :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 ELT Y B b X A a -> ELT Y B b (opt X) (SUCC X A a) (none X).



Proof.

intros X A a Y B b H; apply H; clear H; intros a' H1 H2.

apply ELT_intro with (some X a'). apply SUCC_rt1; assumption.

apply EQV_trans with X A a'. assumption. apply SUCC_eqv.

Qed.



Lemma SUCC_intro2 :

 forall (X : Typ1) (A : Rel X) (a : X),

 ELT X A a (opt X) (SUCC X A a) (none X).



Proof.

intros X A a; apply ELT_intro with (some X a).

apply SUCC_rt2. apply SUCC_eqv.

Qed.



Lemma SUCC_elim :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 ELT Y B b (opt X) (SUCC X A a) (none X) ->

 or (ELT Y B b X A a) (EQV Y B b X A a).



Proof.

intros X A a Y B b H; apply H; clear H.

intros z' H H1; apply H; clear H.



intros x x' H2 H3 H4; apply (eq_none_some _ _ H2).



intros x' H2 H3 H4; apply or_inl; apply ELT_intro with x'.

assumption.

apply EQV_trans with (opt X) (SUCC X A a) (some X x').

apply H3; assumption. apply EQV_sym; apply SUCC_eqv.



intros H2 H3; apply or_inr.

apply EQV_trans with (opt X) (SUCC X A a) (some X a).

apply H3; assumption. apply EQV_sym; apply SUCC_eqv.

Qed.



Lemma successor :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 iff (ELT Y B b (opt X) (SUCC X A a) (none X))

   (or (ELT Y B b X A a) (EQV Y B b X A a)).



Proof.

intros X A a Y B b; unfold iff in |- *.

apply and_intro; intro H.



apply SUCC_elim; assumption.



apply H; clear H; intro H.

apply SUCC_intro1; assumption.

apply ELT_compat_l with X A a.

assumption. apply SUCC_intro2.

Qed.



Lemma SUCC_compat :

 forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

 EQV X A a Y B b ->

 EQV (opt X) (SUCC X A a) (none X) (opt Y) (SUCC Y B b) (none Y).



Proof.

cut

 (forall (X : Typ1) (A : Rel X) (a : X) (Y : Typ1) (B : Rel Y) (b : Y),

  EQV X A a Y B b ->

  SUB (opt X) (SUCC X A a) (none X) (opt Y) (SUCC Y B b) (none Y)).

intros H X A a Y B b H1; apply extensionality.

apply H; assumption. apply H; apply EQV_sym; assumption.

unfold SUB in |- *; intros X A a Y B b H Z C c H1.

apply (SUCC_elim X A a Z C c H1); clear H1; intro H1.

apply SUCC_intro1; apply ELT_compat_r with X A a; assumption.

apply ELT_compat_l with Y B b.

apply EQV_trans with X A a; assumption.

apply SUCC_intro2.

Qed.



Definition OMEGA : Rel (opt nat) :=

  fun z' z =>

  forall E : Prop,

  (forall n n' : nat,

   eq (opt nat) z (some nat n) ->

   eq (opt nat) z' (some nat n') -> wf_nat n -> wf_nat n' -> lt n' n -> E) ->

  (forall n' : nat,

   eq (opt nat) z (none nat) ->

   eq (opt nat) z' (some nat n') -> wf_nat n' -> E) -> E.



Lemma OMEGA_in :

 forall n : nat,

 wf_nat n ->

 forall m : nat, wf_nat m -> lt n m -> OMEGA (some nat n) (some nat m).



Proof

  fun n Hn m Hm H E H1 _ =>

  H1 m n (eq_refl (opt nat) (some nat m)) (eq_refl (opt nat) (some nat n)) Hm

    Hn H.



Lemma OMEGA_rt : forall n : nat, wf_nat n -> OMEGA (some nat n) (none nat).



Proof

  fun n Hn E _ H2 =>

  H2 n (eq_refl (opt nat) (none nat)) (eq_refl (opt nat) (some nat n)) Hn.



Lemma OMEGA_ZERO : EQV (opt nat) OMEGA (some nat O) unit ZERO id.



Proof.

apply extensionality; unfold SUB in |- *; intros X A a H.



apply H; clear H; intros z H H1; apply H; clear H.



intros n m H2 H3 Hn Hm H4.

generalize (eq_sym _ _ _ (eq_some_some _ _ _ H2)); intro H5.

apply (lt_n_O m (H5 (lt m) H4)).



intros n H2 H3 Hn; apply (eq_some_none _ _ H2).



apply H; clear H; intros u H H1; apply H.

Qed.



Lemma OMEGA_SUCC :

 forall n : nat,

 wf_nat n ->

 EQV (opt nat) OMEGA (some nat (S n)) (opt (opt nat))

   (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).



Proof.

intros n Hn; apply extensionality; unfold SUB in |- *; intros X A a H.



apply H; clear H; intros z H H1; apply H; clear H.



intros n0 m H H2 Hn0 Hm H3.

generalize (eq_sym _ _ _ (eq_some_some _ _ _ H)); clear H; intro H.

generalize (H (lt m) H3); clear H H3 Hn0 n0; intro H3.



apply (lt_n_Sm m Hm n Hn H3); clear H3; intro H3.



apply SUCC_intro1; apply ELT_intro with (some nat m).

exact (OMEGA_in m Hm n Hn H3).  apply H2; assumption.



apply ELT_compat_l with (opt nat) OMEGA (some nat n).

apply H3; apply H2; assumption.  apply SUCC_intro2.



intros m H H2 Hm; apply (eq_some_none _ _ H).



apply (SUCC_elim _ _ _ _ _ _ H); clear H; intro H.



apply H; clear H; intros z H H1; apply H; clear H.



intros n0 m H H2 Hn0 Hm H3.

generalize (eq_sym _ _ _ (eq_some_some _ _ _ H)); clear H; intro H.

generalize (H (lt m) H3); clear H H3 Hn0 n0; intro H3.

apply ELT_intro with (some nat m).

exact (OMEGA_in m Hm (S n) (wf_nat_S n Hn) (lt_S m n H3)).

apply H2; assumption.



intros m H H2 Hm; apply (eq_some_none _ _ H).



apply ELT_intro with (some nat n).

exact (OMEGA_in n Hn (S n) (wf_nat_S n Hn) (lt_n_Sn n)).

assumption.

Qed.



Theorem omega_zero : ELT unit ZERO id (opt nat) OMEGA (none nat).



Proof.

apply ELT_intro with (some nat O).

exact (OMEGA_rt O wf_nat_O).

apply EQV_sym; exact OMEGA_ZERO.

Qed.



Theorem omega_succ :

 forall (X : Typ1) (A : Rel X) (a : X),

 ELT X A a (opt nat) OMEGA (none nat) ->

 ELT (opt X) (SUCC X A a) (none X) (opt nat) OMEGA (none nat).



Proof.

intros X A a H; apply H; clear H; intros z H H1; apply H; clear H.



intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).



intros n H0 H Hn; apply ELT_intro with (some nat (S n)).

exact (OMEGA_rt (S n) (wf_nat_S n Hn)).

apply

 EQV_trans

  with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).

apply SUCC_compat; apply H; assumption.

apply EQV_sym; apply OMEGA_SUCC; assumption.

Qed.



Require Import IZF_select.  



Theorem omega_ind

 :

 

 forall P : PRED,

 Compat P ->

 

 P unit ZERO id ->

 
 (forall (X : Typ1) (A : Rel X) (a : X),

  ELT X A a (opt nat) OMEGA (none nat) ->

  P X A a -> P (opt X) (SUCC X A a) (none X)) ->

 

 forall (X : Typ1) (A : Rel X) (a : X),

 ELT X A a (opt nat) OMEGA (none nat) -> P X A a.



Proof.

intros P HP HO HS X A a H; apply H; clear H.

intros z H H1; apply H; clear H.



intros n m H H2 Hn Hm H3; apply (eq_none_some _ _ H).



intros n H0 H Hn; clear H0.

apply (HP _ _ _ _ _ _ (EQV_sym _ _ _ _ _ _ H1)).

apply (eq_sym _ _ _ H); clear H H1 a A X z.



apply (nat_ind' n Hn); clear Hn n.



apply HP with unit ZERO id.

apply EQV_sym; exact OMEGA_ZERO. assumption.



intros n Hn Hind.

apply

 HP with (opt (opt nat)) (SUCC (opt nat) OMEGA (some nat n)) (none (opt nat)).

apply EQV_sym; apply OMEGA_SUCC; assumption.

apply HS. apply ELT_direct; apply OMEGA_rt; assumption.

assumption.

Qed.

