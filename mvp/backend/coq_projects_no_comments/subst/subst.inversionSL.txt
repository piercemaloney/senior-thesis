
Require Import sur_les_relations.
Require Import TS.
Require Import sigma_lift.

Definition e_invSL (b : wsort) (M N : TS b) :=
  match M, N with
  | lift M1, id => M1 = id
  | lift M1, lift N1 => e_relSL _ M1 N1
  | lambda M1, lambda N1 => e_relSL _ M1 N1
  | app M1 M2, app N1 N2 =>
      e_relSL _ M1 N1 /\ M2 = N2 \/ M1 = N1 /\ e_relSL _ M2 N2
  | env M1 M2, var n as V =>
      (exists m : nat, M1 = var m /\ n = S m /\ M2 = shift) \/
      (exists s : sub_explicits, M1 = var 0 /\ M2 = lift s /\ n = 0) \/
      (exists s : sub_explicits, M1 = var 0 /\ M2 = cons V s) \/
      M1 = V /\ M2 = id
  | env M1 M2, app N1 N2 as A =>
      (exists a : terms,
         (exists b : terms, M1 = app a b /\ N1 = env a M2 /\ N2 = env b M2)) \/
      (exists s : sub_explicits, M1 = var 0 /\ M2 = cons A s) \/
      M1 = A /\ M2 = id
  | env M1 M2, lambda N1 as L =>
      (exists a : terms, M1 = lambda a /\ N1 = env a (lift M2)) \/
      (exists s : sub_explicits, M1 = var 0 /\ M2 = cons L s) \/
      M1 = L /\ M2 = id
  | env M1 M2, env N1 N2 as E =>
      (exists s : sub_explicits, M1 = env N1 s /\ N2 = comp s M2) \/
      (exists n : nat, M1 = var n /\ M2 = comp shift N2 /\ N1 = var (S n)) \/
      (exists s : sub_explicits, M1 = var 0 /\ M2 = cons E s) \/
      (exists s : sub_explicits,
         M1 = var 0 /\ M2 = comp (lift s) N2 /\ N1 = var 0) \/
      (exists n : nat,
         (exists a : terms, M1 = var (S n) /\ M2 = cons a N2 /\ N1 = var n)) \/
      (exists n : nat,
         (exists s : sub_explicits,
            M1 = var (S n) /\ M2 = lift s /\ N1 = var n /\ N2 = comp s shift)) \/
      (exists n : nat,
         (exists s : sub_explicits,
            (exists t : sub_explicits,
               M1 = var (S n) /\
               M2 = comp (lift s) t /\
               N1 = var n /\ N2 = comp s (comp shift t)))) \/
      M1 = E /\ M2 = id \/
      e_relSL _ M1 N1 /\ M2 = N2 \/ M1 = N1 /\ e_relSL _ M2 N2
  | env M1 M2, meta_X n =>
      (exists s : sub_explicits, M1 = var 0 /\ M2 = cons (meta_X n) s) \/
      M1 = meta_X n /\ M2 = id
  | cons M1 M2, cons N1 N2 =>
      e_relSL _ M1 N1 /\ M2 = N2 \/ M1 = N1 /\ e_relSL _ M2 N2
  | comp M1 M2, id =>
      (exists a : terms, M1 = shift /\ M2 = cons a id) \/ M1 = id /\ M2 = id
  | comp M1 M2, shift =>
      (exists a : terms, M1 = shift /\ M2 = cons a shift) \/
      M1 = id /\ M2 = shift \/ M1 = shift /\ M2 = id
  | comp M1 M2, cons N1 N2 as C =>
      (exists a : terms,
         (exists s : sub_explicits,
            M1 = cons a s /\ N1 = env a M2 /\ N2 = comp s M2)) \/
      (exists a : terms, M1 = shift /\ M2 = cons a C) \/
      (exists s : sub_explicits,
         (exists t : sub_explicits,
            M1 = lift s /\ M2 = cons N1 t /\ N2 = comp s t)) \/
      M1 = id /\ M2 = C \/ M1 = C /\ M2 = id
  | comp M1 M2, comp N1 N2 =>
      (exists t : sub_explicits, M1 = comp N1 t /\ N2 = comp t M2) \/
      (exists a : terms, M1 = shift /\ M2 = cons a (comp N1 N2)) \/
      M1 = shift /\ M2 = lift N1 /\ N2 = shift \/
      (exists t : sub_explicits,
         M1 = shift /\ M2 = comp (lift N1) t /\ N2 = comp shift t) \/
      (exists s : sub_explicits,
         (exists t : sub_explicits,
            M1 = lift s /\ M2 = comp (lift t) N2 /\ N1 = lift (comp s t))) \/
      M1 = id /\ M2 = comp N1 N2 \/
      M1 = comp N1 N2 /\ M2 = id \/
      e_relSL _ M1 N1 /\ M2 = N2 \/ M1 = N1 /\ e_relSL _ M2 N2
  | comp M1 M2, lift N1 as L =>
      (exists a : terms, M1 = shift /\ M2 = cons a L) \/
      (exists s : sub_explicits,
         (exists t : sub_explicits,
            M1 = lift s /\ M2 = lift t /\ N1 = comp s t)) \/
      M1 = id /\ M2 = L \/ M1 = L /\ M2 = id
  | comp M1 M2, meta_x n as x =>
      (exists a : terms, M1 = shift /\ M2 = cons a x) \/
      M1 = id /\ M2 = x \/ M1 = x /\ M2 = id
  | _, _ => False
  end.

Notation invSL := (e_invSL _) (only parsing).

Goal forall (b : wsort) (M N : TS b), e_systemSL _ M N -> e_invSL _ M N.
simple induction 1; simple induction 1; intros.

simpl in |- *; left; exists a0; exists b1; auto.

simpl in |- *; left; exists a0; auto.

simpl in |- *; left; exists s; auto.

simpl in |- *; left; exists n; auto.

simpl in |- *; right; left; exists n; auto.

pattern a0 in |- *; apply terms_ind; intros; simpl in |- *.
 
do 2 right; left; exists s; auto.
 
right; left; exists s; auto.
 
right; left; exists s; auto.
 
do 2 right; left; exists s; auto.
 
left; exists s; auto.

simpl in |- *; right; left; exists s; auto.

simpl in |- *; do 3 right; left; exists s; auto.

simpl in |- *; do 4 right; left; exists n; exists a0; auto.

simpl in |- *; do 5 right; left; exists n; exists s; auto.

simpl in |- *; do 6 right; left; exists n; exists s; exists t; auto.

simpl in |- *; left; exists t0; auto.

simpl in |- *; left; exists a; exists s0; auto.

pattern s0 in |- *; apply sub_explicits_ind; intros; simpl in |- *.
 
left; exists a; auto.
 
left; exists a; auto.
 
right; left; exists a; auto.
 
right; left; exists a; auto.
 
left; exists a; auto.
 
left; exists a; auto.

simpl in |- *; do 2 right; left; auto.

simpl in |- *; do 3 right; left; exists t0; auto.

simpl in |- *; right; left; exists s0; exists t0; auto.

simpl in |- *; do 4 right; left; exists s0; exists t0; auto.

simpl in |- *; right; right; left; exists s0; exists t0; auto.

pattern s0 in |- *; apply sub_explicits_ind; intros; simpl in |- *.
 
right; auto.
 
right; left; auto.
 
do 3 right; left; auto.
 
do 5 right; left; auto.
 
do 2 right; left; auto.
 
right; left; auto.

pattern s0 in |- *; apply sub_explicits_ind; intros; simpl in |- *.
 
right; auto.
 
right; right; auto.
 
do 4 right; auto.
 
do 6 right; left; auto.
 
do 3 right; auto.
 
right; right; auto.

simpl in |- *; auto.

pattern a0 in |- *; apply terms_ind; intros; simpl in |- *.
 
do 3 right; auto.
 
do 2 right; auto.
 
do 2 right; auto.
 
do 7 right; left; auto.
 
right; auto.
Save lemma1_inv_systemSL.
Hint Resolve lemma1_inv_systemSL.

Goal forall (b : wsort) (M N : TS b), e_relSL _ M N -> e_invSL _ M N.
simple induction 1; intros; simpl in |- *; auto 11.
Save lemma1_invSL.
Hint Resolve lemma1_invSL.

